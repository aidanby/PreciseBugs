{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * evalvars.c: functions for dealing with variables\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\nstatic dictitem_T\tglobvars_var;\t\t// variable used for g:\nstatic dict_T\t\tglobvardict;\t\t// Dictionary with g: variables\n#define globvarht globvardict.dv_hashtab\n\n/*\n * Old Vim variables such as \"v:version\" are also available without the \"v:\".\n * Also in functions.  We need a special hashtable for them.\n */\nstatic hashtab_T\tcompat_hashtab;\n\n/*\n * Array to hold the value of v: variables.\n * The value is in a dictitem, so that it can also be used in the v: scope.\n * The reason to use this table anyway is for very quick access to the\n * variables with the VV_ defines.\n */\n\n// values for vv_flags:\n#define VV_COMPAT\t1\t// compatible, also used without \"v:\"\n#define VV_RO\t\t2\t// read-only\n#define VV_RO_SBX\t4\t// read-only in the sandbox\n\n#define VV_NAME(s, t)\ts, {{t, 0, {0}}, 0, {0}}\n\ntypedef struct vimvar vimvar_T;\n\nstatic struct vimvar\n{\n    char\t*vv_name;\t// name of variable, without v:\n    dictitem16_T vv_di;\t\t// value and name for key (max 16 chars!)\n    type_T\t*vv_type;\t// type or NULL\n    char\tvv_flags;\t// VV_COMPAT, VV_RO, VV_RO_SBX\n} vimvars[VV_LEN] =\n{\n    // The order here must match the VV_ defines in vim.h!\n    // Initializing a union does not work, leave tv.vval empty to get zero's.\n    {VV_NAME(\"count\",\t\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"count1\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"prevcount\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"errmsg\",\t\t VAR_STRING), NULL, VV_COMPAT},\n    {VV_NAME(\"warningmsg\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"statusmsg\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"shell_error\",\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"this_session\",\t VAR_STRING), NULL, VV_COMPAT},\n    {VV_NAME(\"version\",\t\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"lnum\",\t\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"termresponse\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"lang\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"lc_time\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"ctype\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"charconvert_from\", VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"charconvert_to\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_in\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_out\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_new\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_diff\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"cmdarg\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"foldstart\",\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"foldend\",\t\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"folddashes\",\t VAR_STRING), NULL, VV_RO_SBX},\n    {VV_NAME(\"foldlevel\",\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"progname\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"servername\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"dying\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"exception\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"throwpoint\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"register\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"cmdbang\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"insertmode\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"val\",\t\t VAR_UNKNOWN), NULL, VV_RO},\n    {VV_NAME(\"key\",\t\t VAR_UNKNOWN), NULL, VV_RO},\n    {VV_NAME(\"profiling\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"fcs_reason\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fcs_choice\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"beval_bufnr\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_winnr\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_winid\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_lnum\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_col\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_text\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"scrollstart\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"swapname\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"swapchoice\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"swapcommand\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"char\",\t\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"mouse_win\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_winid\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_lnum\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_col\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"operator\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"searchforward\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"hlsearch\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"oldfiles\",\t VAR_LIST), &t_list_string, 0},\n    {VV_NAME(\"windowid\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"progpath\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"completed_item\",\t VAR_DICT), &t_dict_string, VV_RO},\n    {VV_NAME(\"option_new\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_old\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_oldlocal\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_oldglobal\", VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_command\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_type\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"errors\",\t\t VAR_LIST), &t_list_string, 0},\n    {VV_NAME(\"false\",\t\t VAR_BOOL), NULL, VV_RO},\n    {VV_NAME(\"true\",\t\t VAR_BOOL), NULL, VV_RO},\n    {VV_NAME(\"none\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"null\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"numbermax\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"numbermin\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"numbersize\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"vim_did_enter\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"testing\",\t\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"t_number\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_string\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_func\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_list\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_dict\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_float\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_bool\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_none\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_job\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_channel\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_blob\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"termrfgresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termrbgresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termu7resp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termstyleresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termblinkresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"event\",\t\t VAR_DICT), NULL, VV_RO},\n    {VV_NAME(\"versionlong\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"echospace\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"argv\",\t\t VAR_LIST), &t_list_string, VV_RO},\n    {VV_NAME(\"collate\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"exiting\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"colornames\",       VAR_DICT), &t_dict_string, VV_RO},\n    {VV_NAME(\"sizeofint\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"sizeoflong\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"sizeofpointer\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"maxcol\",\t\t VAR_NUMBER), NULL, VV_RO},\n};\n\n// shorthand\n#define vv_tv_type\tvv_di.di_tv.v_type\n#define vv_nr\t\tvv_di.di_tv.vval.v_number\n#define vv_float\tvv_di.di_tv.vval.v_float\n#define vv_str\t\tvv_di.di_tv.vval.v_string\n#define vv_list\t\tvv_di.di_tv.vval.v_list\n#define vv_dict\t\tvv_di.di_tv.vval.v_dict\n#define vv_blob\t\tvv_di.di_tv.vval.v_blob\n#define vv_tv\t\tvv_di.di_tv\n\nstatic dictitem_T\tvimvars_var;\t\t// variable used for v:\nstatic dict_T\t\tvimvardict;\t\t// Dictionary with v: variables\n#define vimvarht  vimvardict.dv_hashtab\n\n// for VIM_VERSION_ defines\n#include \"version.h\"\n\nstatic void list_glob_vars(int *first);\nstatic void list_buf_vars(int *first);\nstatic void list_win_vars(int *first);\nstatic void list_tab_vars(int *first);\nstatic char_u *list_arg_vars(exarg_T *eap, char_u *arg, int *first);\nstatic char_u *ex_let_one(char_u *arg, typval_T *tv, int copy, int flags, char_u *endchars, char_u *op, int var_idx);\nstatic int do_unlet_var(lval_T *lp, char_u *name_end, exarg_T *eap, int deep, void *cookie);\nstatic int do_lock_var(lval_T *lp, char_u *name_end, exarg_T *eap, int deep, void *cookie);\nstatic void list_one_var(dictitem_T *v, char *prefix, int *first);\nstatic void list_one_var_a(char *prefix, char_u *name, int type, char_u *string, int *first);\n\n/*\n * Initialize global and vim special variables\n */\n    void\nevalvars_init(void)\n{\n    int\t\t    i;\n    struct vimvar   *p;\n\n    init_var_dict(&globvardict, &globvars_var, VAR_DEF_SCOPE);\n    init_var_dict(&vimvardict, &vimvars_var, VAR_SCOPE);\n    vimvardict.dv_lock = VAR_FIXED;\n    hash_init(&compat_hashtab);\n\n    for (i = 0; i < VV_LEN; ++i)\n    {\n\tp = &vimvars[i];\n\tif (STRLEN(p->vv_name) > DICTITEM16_KEY_LEN)\n\t{\n\t    iemsg(\"INTERNAL: name too long, increase size of dictitem16_T\");\n\t    getout(1);\n\t}\n\tSTRCPY(p->vv_di.di_key, p->vv_name);\n\tif (p->vv_flags & VV_RO)\n\t    p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\telse if (p->vv_flags & VV_RO_SBX)\n\t    p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;\n\telse\n\t    p->vv_di.di_flags = DI_FLAGS_FIX;\n\n\t// add to v: scope dict, unless the value is not always available\n\tif (p->vv_tv_type != VAR_UNKNOWN)\n\t    hash_add(&vimvarht, p->vv_di.di_key);\n\tif (p->vv_flags & VV_COMPAT)\n\t    // add to compat scope dict\n\t    hash_add(&compat_hashtab, p->vv_di.di_key);\n    }\n    set_vim_var_nr(VV_VERSION, VIM_VERSION_100);\n    set_vim_var_nr(VV_VERSIONLONG, VIM_VERSION_100 * 10000 + highest_patch());\n\n    set_vim_var_nr(VV_SEARCHFORWARD, 1L);\n    set_vim_var_nr(VV_HLSEARCH, 1L);\n    set_vim_var_nr(VV_EXITING, VVAL_NULL);\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n    set_vim_var_list(VV_ERRORS, list_alloc());\n    set_vim_var_dict(VV_EVENT, dict_alloc_lock(VAR_FIXED));\n\n    set_vim_var_nr(VV_FALSE, VVAL_FALSE);\n    set_vim_var_nr(VV_TRUE, VVAL_TRUE);\n    set_vim_var_nr(VV_NONE, VVAL_NONE);\n    set_vim_var_nr(VV_NULL, VVAL_NULL);\n    set_vim_var_nr(VV_NUMBERMAX, VARNUM_MAX);\n    set_vim_var_nr(VV_NUMBERMIN, VARNUM_MIN);\n    set_vim_var_nr(VV_NUMBERSIZE, sizeof(varnumber_T) * 8);\n    set_vim_var_nr(VV_SIZEOFINT, sizeof(int));\n    set_vim_var_nr(VV_SIZEOFLONG, sizeof(long));\n    set_vim_var_nr(VV_SIZEOFPOINTER, sizeof(char *));\n    set_vim_var_nr(VV_MAXCOL, MAXCOL);\n\n    set_vim_var_nr(VV_TYPE_NUMBER,  VAR_TYPE_NUMBER);\n    set_vim_var_nr(VV_TYPE_STRING,  VAR_TYPE_STRING);\n    set_vim_var_nr(VV_TYPE_FUNC,    VAR_TYPE_FUNC);\n    set_vim_var_nr(VV_TYPE_LIST,    VAR_TYPE_LIST);\n    set_vim_var_nr(VV_TYPE_DICT,    VAR_TYPE_DICT);\n    set_vim_var_nr(VV_TYPE_FLOAT,   VAR_TYPE_FLOAT);\n    set_vim_var_nr(VV_TYPE_BOOL,    VAR_TYPE_BOOL);\n    set_vim_var_nr(VV_TYPE_NONE,    VAR_TYPE_NONE);\n    set_vim_var_nr(VV_TYPE_JOB,     VAR_TYPE_JOB);\n    set_vim_var_nr(VV_TYPE_CHANNEL, VAR_TYPE_CHANNEL);\n    set_vim_var_nr(VV_TYPE_BLOB,    VAR_TYPE_BLOB);\n\n    set_vim_var_nr(VV_ECHOSPACE,    sc_col - 1);\n\n    set_vim_var_dict(VV_COLORNAMES, dict_alloc());\n\n    // Default for v:register is not 0 but '\"'.  This is adjusted once the\n    // clipboard has been setup by calling reset_reg_var().\n    set_reg_var(0);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all vim variables information on exit\n */\n    void\nevalvars_clear(void)\n{\n    int\t\t    i;\n    struct vimvar   *p;\n\n    for (i = 0; i < VV_LEN; ++i)\n    {\n\tp = &vimvars[i];\n\tif (p->vv_di.di_tv.v_type == VAR_STRING)\n\t    VIM_CLEAR(p->vv_str);\n\telse if (p->vv_di.di_tv.v_type == VAR_LIST)\n\t{\n\t    list_unref(p->vv_list);\n\t    p->vv_list = NULL;\n\t}\n    }\n    hash_clear(&vimvarht);\n    hash_init(&vimvarht);  // garbage_collect() will access it\n    hash_clear(&compat_hashtab);\n\n    // global variables\n    vars_clear(&globvarht);\n\n    // Script-local variables. Clear all the variables here.\n    // The scriptvar_T is cleared later in free_scriptnames(), because a\n    // variable in one script might hold a reference to the whole scope of\n    // another script.\n    for (i = 1; i <= script_items.ga_len; ++i)\n\tvars_clear(&SCRIPT_VARS(i));\n}\n#endif\n\n    int\ngarbage_collect_globvars(int copyID)\n{\n    return set_ref_in_ht(&globvarht, copyID, NULL);\n}\n\n    int\ngarbage_collect_vimvars(int copyID)\n{\n    return set_ref_in_ht(&vimvarht, copyID, NULL);\n}\n\n    int\ngarbage_collect_scriptvars(int copyID)\n{\n    int\t\t    i;\n    int\t\t    idx;\n    int\t\t    abort = FALSE;\n    scriptitem_T    *si;\n\n    for (i = 1; i <= script_items.ga_len; ++i)\n    {\n\tabort = abort || set_ref_in_ht(&SCRIPT_VARS(i), copyID, NULL);\n\n\tsi = SCRIPT_ITEM(i);\n\tfor (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n\t{\n\t    svar_T    *sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t    if (sv->sv_name != NULL)\n\t\tabort = abort || set_ref_in_item(sv->sv_tv, copyID, NULL, NULL);\n\t}\n    }\n\n    return abort;\n}\n\n/*\n * Set an internal variable to a string value. Creates the variable if it does\n * not already exist.\n */\n    void\nset_internal_string_var(char_u *name, char_u *value)\n{\n    char_u\t*val;\n    typval_T\t*tvp;\n\n    val = vim_strsave(value);\n    if (val != NULL)\n    {\n\ttvp = alloc_string_tv(val);\n\tif (tvp != NULL)\n\t{\n\t    set_var(name, tvp, FALSE);\n\t    free_tv(tvp);\n\t}\n    }\n}\n\n    int\neval_charconvert(\n    char_u\t*enc_from,\n    char_u\t*enc_to,\n    char_u\t*fname_from,\n    char_u\t*fname_to)\n{\n    int\t\terr = FALSE;\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    set_vim_var_string(VV_CC_FROM, enc_from, -1);\n    set_vim_var_string(VV_CC_TO, enc_to, -1);\n    set_vim_var_string(VV_FNAME_IN, fname_from, -1);\n    set_vim_var_string(VV_FNAME_OUT, fname_to, -1);\n    ctx = get_option_sctx(\"charconvert\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval_to_bool(p_ccv, &err, NULL, FALSE))\n\terr = TRUE;\n\n    set_vim_var_string(VV_CC_FROM, NULL, -1);\n    set_vim_var_string(VV_CC_TO, NULL, -1);\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n\n    if (err)\n\treturn FAIL;\n    return OK;\n}\n\n# if defined(FEAT_POSTSCRIPT) || defined(PROTO)\n    int\neval_printexpr(char_u *fname, char_u *args)\n{\n    int\t\terr = FALSE;\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    set_vim_var_string(VV_FNAME_IN, fname, -1);\n    set_vim_var_string(VV_CMDARG, args, -1);\n    ctx = get_option_sctx(\"printexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval_to_bool(p_pexpr, &err, NULL, FALSE))\n\terr = TRUE;\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_CMDARG, NULL, -1);\n    current_sctx = saved_sctx;\n\n    if (err)\n    {\n\tmch_remove(fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n# endif\n\n# if defined(FEAT_DIFF) || defined(PROTO)\n    void\neval_diff(\n    char_u\t*origfile,\n    char_u\t*newfile,\n    char_u\t*outfile)\n{\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n    typval_T\t*tv;\n\n    set_vim_var_string(VV_FNAME_IN, origfile, -1);\n    set_vim_var_string(VV_FNAME_NEW, newfile, -1);\n    set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n\n    ctx = get_option_sctx(\"diffexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    // errors are ignored\n    tv = eval_expr(p_dex, NULL);\n    free_tv(tv);\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_NEW, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n}\n\n    void\neval_patch(\n    char_u\t*origfile,\n    char_u\t*difffile,\n    char_u\t*outfile)\n{\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n    typval_T\t*tv;\n\n    set_vim_var_string(VV_FNAME_IN, origfile, -1);\n    set_vim_var_string(VV_FNAME_DIFF, difffile, -1);\n    set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n\n    ctx = get_option_sctx(\"patchexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    // errors are ignored\n    tv = eval_expr(p_pex, NULL);\n    free_tv(tv);\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_DIFF, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n}\n# endif\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Evaluate an expression to a list with suggestions.\n * For the \"expr:\" part of 'spellsuggest'.\n * Returns NULL when there is an error.\n */\n    list_T *\neval_spell_expr(char_u *badword, char_u *expr)\n{\n    typval_T\tsave_val;\n    typval_T\trettv;\n    list_T\t*list = NULL;\n    char_u\t*p = skipwhite(expr);\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    // Set \"v:val\" to the bad word.\n    prepare_vimvar(VV_VAL, &save_val);\n    set_vim_var_string(VV_VAL, badword, -1);\n    if (p_verbose == 0)\n\t++emsg_off;\n    ctx = get_option_sctx(\"spellsuggest\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == OK)\n    {\n\tif (rettv.v_type != VAR_LIST)\n\t    clear_tv(&rettv);\n\telse\n\t    list = rettv.vval.v_list;\n    }\n\n    if (p_verbose == 0)\n\t--emsg_off;\n    clear_tv(get_vim_var_tv(VV_VAL));\n    restore_vimvar(VV_VAL, &save_val);\n    current_sctx = saved_sctx;\n\n    return list;\n}\n\n/*\n * \"list\" is supposed to contain two items: a word and a number.  Return the\n * word in \"pp\" and the number as the return value.\n * Return -1 if anything isn't right.\n * Used to get the good word and score from the eval_spell_expr() result.\n */\n    int\nget_spellword(list_T *list, char_u **pp)\n{\n    listitem_T\t*li;\n\n    li = list->lv_first;\n    if (li == NULL)\n\treturn -1;\n    *pp = tv_get_string(&li->li_tv);\n\n    li = li->li_next;\n    if (li == NULL)\n\treturn -1;\n    return (int)tv_get_number(&li->li_tv);\n}\n#endif\n\n/*\n * Prepare v: variable \"idx\" to be used.\n * Save the current typeval in \"save_tv\" and clear it.\n * When not used yet add the variable to the v: hashtable.\n */\n    void\nprepare_vimvar(int idx, typval_T *save_tv)\n{\n    *save_tv = vimvars[idx].vv_tv;\n    vimvars[idx].vv_str = NULL;  // don't free it now\n    if (vimvars[idx].vv_tv_type == VAR_UNKNOWN)\n\thash_add(&vimvarht, vimvars[idx].vv_di.di_key);\n}\n\n/*\n * Restore v: variable \"idx\" to typeval \"save_tv\".\n * Note that the v: variable must have been cleared already.\n * When no longer defined, remove the variable from the v: hashtable.\n */\n    void\nrestore_vimvar(int idx, typval_T *save_tv)\n{\n    hashitem_T\t*hi;\n\n    vimvars[idx].vv_tv = *save_tv;\n    if (vimvars[idx].vv_tv_type == VAR_UNKNOWN)\n    {\n\thi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);\n\tif (HASHITEM_EMPTY(hi))\n\t    internal_error(\"restore_vimvar()\");\n\telse\n\t    hash_remove(&vimvarht, hi);\n    }\n}\n\n/*\n * List Vim variables.\n */\n    static void\nlist_vim_vars(int *first)\n{\n    list_hashtable_vars(&vimvarht, \"v:\", FALSE, first);\n}\n\n/*\n * List script-local variables, if there is a script.\n */\n    static void\nlist_script_vars(int *first)\n{\n    if (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\tlist_hashtable_vars(&SCRIPT_VARS(current_sctx.sc_sid),\n\t\t\t\t\t\t\t   \"s:\", FALSE, first);\n}\n\n/*\n * Get a list of lines from a HERE document. The here document is a list of\n * lines surrounded by a marker.\n *\tcmd << {marker}\n *\t  {line1}\n *\t  {line2}\n *\t  ....\n *\t{marker}\n *\n * The {marker} is a string. If the optional 'trim' word is supplied before the\n * marker, then the leading indentation before the lines (matching the\n * indentation in the 'cmd' line) is stripped.\n *\n * When getting lines for an embedded script (e.g. python, lua, perl, ruby,\n * tcl, mzscheme), script_get is set to TRUE. In this case, if the marker is\n * missing, then '.' is accepted as a marker.\n *\n * Returns a List with {lines} or NULL.\n */\n    list_T *\nheredoc_get(exarg_T *eap, char_u *cmd, int script_get)\n{\n    char_u\t*theline;\n    char_u\t*marker;\n    list_T\t*l;\n    char_u\t*p;\n    int\t\tmarker_indent_len = 0;\n    int\t\ttext_indent_len = 0;\n    char_u\t*text_indent = NULL;\n    char_u\tdot[] = \".\";\n    int\t\tcomment_char = in_vim9script() ? '#' : '\"';\n\n    if (eap->getline == NULL)\n    {\n\temsg(_(e_cannot_use_heredoc_here));\n\treturn NULL;\n    }\n\n    // Check for the optional 'trim' word before the marker\n    cmd = skipwhite(cmd);\n    if (STRNCMP(cmd, \"trim\", 4) == 0 && (cmd[4] == NUL || VIM_ISWHITE(cmd[4])))\n    {\n\tcmd = skipwhite(cmd + 4);\n\n\t// Trim the indentation from all the lines in the here document.\n\t// The amount of indentation trimmed is the same as the indentation of\n\t// the first line after the :let command line.  To find the end marker\n\t// the indent of the :let command line is trimmed.\n\tp = *eap->cmdlinep;\n\twhile (VIM_ISWHITE(*p))\n\t{\n\t    p++;\n\t    marker_indent_len++;\n\t}\n\ttext_indent_len = -1;\n    }\n\n    // The marker is the next word.\n    if (*cmd != NUL && *cmd != comment_char)\n    {\n\tmarker = skipwhite(cmd);\n\tp = skiptowhite(marker);\n\tif (*skipwhite(p) != NUL && *skipwhite(p) != comment_char)\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\t*p = NUL;\n\tif (!script_get && vim_islower(*marker))\n\t{\n\t    emsg(_(e_marker_cannot_start_with_lower_case_letter));\n\t    return NULL;\n\t}\n    }\n    else\n    {\n\t// When getting lines for an embedded script, if the marker is missing,\n\t// accept '.' as the marker.\n\tif (script_get)\n\t    marker = dot;\n\telse\n\t{\n\t    emsg(_(e_missing_marker));\n\t    return NULL;\n\t}\n    }\n\n    l = list_alloc();\n    if (l == NULL)\n\treturn NULL;\n\n    for (;;)\n    {\n\tint\tmi = 0;\n\tint\tti = 0;\n\n\ttheline = eap->getline(NUL, eap->cookie, 0, FALSE);\n\tif (theline == NULL)\n\t{\n\t    semsg(_(e_missing_end_marker_str), marker);\n\t    break;\n\t}\n\n\t// with \"trim\": skip the indent matching the :let line to find the\n\t// marker\n\tif (marker_indent_len > 0\n\t\t&& STRNCMP(theline, *eap->cmdlinep, marker_indent_len) == 0)\n\t    mi = marker_indent_len;\n\tif (STRCMP(marker, theline + mi) == 0)\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\tif (text_indent_len == -1 && *theline != NUL)\n\t{\n\t    // set the text indent from the first line.\n\t    p = theline;\n\t    text_indent_len = 0;\n\t    while (VIM_ISWHITE(*p))\n\t    {\n\t\tp++;\n\t\ttext_indent_len++;\n\t    }\n\t    text_indent = vim_strnsave(theline, text_indent_len);\n\t}\n\t// with \"trim\": skip the indent matching the first line\n\tif (text_indent != NULL)\n\t    for (ti = 0; ti < text_indent_len; ++ti)\n\t\tif (theline[ti] != text_indent[ti])\n\t\t    break;\n\n\tif (list_append_string(l, theline + ti, -1) == FAIL)\n\t    break;\n\tvim_free(theline);\n    }\n    vim_free(text_indent);\n\n    return l;\n}\n\n/*\n * Vim9 variable declaration:\n * \":var name\"\n * \":var name: type\"\n * \":var name = expr\"\n * \":var name: type = expr\"\n * etc.\n */\n    void\nex_var(exarg_T *eap)\n{\n    if (!in_vim9script())\n    {\n\tsemsg(_(e_str_cannot_be_used_in_legacy_vim_script), \":var\");\n\treturn;\n    }\n    ex_let(eap);\n}\n\n/*\n * \":let\"\t\t\tlist all variable values\n * \":let var1 var2\"\t\tlist variable values\n * \":let var = expr\"\t\tassignment command.\n * \":let var += expr\"\t\tassignment command.\n * \":let var -= expr\"\t\tassignment command.\n * \":let var *= expr\"\t\tassignment command.\n * \":let var /= expr\"\t\tassignment command.\n * \":let var %= expr\"\t\tassignment command.\n * \":let var .= expr\"\t\tassignment command.\n * \":let var ..= expr\"\t\tassignment command.\n * \":let [var1, var2] = expr\"\tunpack list.\n * \":let var =<< ...\"\t\theredoc\n * \":let var: string\"\t\tVim9 declaration\n *\n * \":final var = expr\"\t\tassignment command.\n * \":final [var1, var2] = expr\"\tunpack list.\n *\n * \":const\"\t\t\tlist all variable values\n * \":const var1 var2\"\t\tlist variable values\n * \":const var = expr\"\t\tassignment command.\n * \":const [var1, var2] = expr\"\tunpack list.\n */\n    void\nex_let(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*expr = NULL;\n    typval_T\trettv;\n    int\t\ti;\n    int\t\tvar_count = 0;\n    int\t\tsemicolon = 0;\n    char_u\top[4];\n    char_u\t*argend;\n    int\t\tfirst = TRUE;\n    int\t\tconcat;\n    int\t\thas_assign;\n    int\t\tflags = 0;\n    int\t\tvim9script = in_vim9script();\n\n    if (eap->cmdidx == CMD_final && !vim9script)\n    {\n\t// In legacy Vim script \":final\" is short for \":finally\".\n\tex_finally(eap);\n\treturn;\n    }\n    if (eap->cmdidx == CMD_let && vim9script)\n    {\n\temsg(_(e_cannot_use_let_in_vim9_script));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_const)\n\tflags |= ASSIGN_CONST;\n    else if (eap->cmdidx == CMD_final)\n\tflags |= ASSIGN_FINAL;\n\n    // Vim9 assignment without \":let\", \":const\" or \":final\"\n    if (eap->arg == eap->cmd)\n\tflags |= ASSIGN_NO_DECL;\n\n    argend = skip_var_list(arg, TRUE, &var_count, &semicolon, FALSE);\n    if (argend == NULL)\n\treturn;\n    if (argend > arg && argend[-1] == '.')  // for var.='str'\n\t--argend;\n    expr = skipwhite(argend);\n    concat = expr[0] == '.'\n\t&& ((expr[1] == '=' && in_old_script(2))\n\t\t|| (expr[1] == '.' && expr[2] == '='));\n    has_assign =  *expr == '=' || (vim_strchr((char_u *)\"+-*/%\", *expr) != NULL\n\t\t\t\t\t\t\t    && expr[1] == '=');\n    if (!has_assign && !concat)\n    {\n\t// \":let\" without \"=\": list variables\n\tif (*arg == '[')\n\t    emsg(_(e_invalid_argument));\n\telse if (expr[0] == '.' && expr[1] == '=')\n\t    emsg(_(e_dot_equal_not_supported_with_script_version_two));\n\telse if (!ends_excmd2(eap->cmd, arg))\n\t{\n\t    if (vim9script)\n\t    {\n\t\tif (!ends_excmd2(eap->cmd, skipwhite(argend)))\n\t\t    semsg(_(e_trailing_characters_str), argend);\n\t\telse\n\t\t    // Vim9 declaration \":var name: type\"\n\t\t    arg = vim9_declare_scriptvar(eap, arg);\n\t    }\n\t    else\n\t    {\n\t\t// \":let var1 var2\" - list values\n\t\targ = list_arg_vars(eap, arg, &first);\n\t    }\n\t}\n\telse if (!eap->skip)\n\t{\n\t    // \":let\"\n\t    list_glob_vars(&first);\n\t    list_buf_vars(&first);\n\t    list_win_vars(&first);\n\t    list_tab_vars(&first);\n\t    list_script_vars(&first);\n\t    list_func_vars(&first);\n\t    list_vim_vars(&first);\n\t}\n\tset_nextcmd(eap, arg);\n    }\n    else if (expr[0] == '=' && expr[1] == '<' && expr[2] == '<')\n    {\n\tlist_T\t*l;\n\tlong\tcur_lnum = SOURCING_LNUM;\n\n\t// HERE document\n\tl = heredoc_get(eap, expr + 3, FALSE);\n\tif (l != NULL)\n\t{\n\t    rettv_list_set(&rettv, l);\n\t    if (!eap->skip)\n\t    {\n\t\t// errors are for the assignment, not the end marker\n\t\tSOURCING_LNUM = cur_lnum;\n\t\top[0] = '=';\n\t\top[1] = NUL;\n\t\t(void)ex_let_vars(eap->arg, &rettv, FALSE, semicolon, var_count,\n\t\t\t\t\t\t\t\tflags, op);\n\t    }\n\t    clear_tv(&rettv);\n\t}\n    }\n    else\n    {\n\tevalarg_T   evalarg;\n\tint\t    len = 1;\n\n\tCLEAR_FIELD(rettv);\n\ti = FAIL;\n\tif (has_assign || concat)\n\t{\n\t    int cur_lnum;\n\n\t    op[0] = '=';\n\t    op[1] = NUL;\n\t    if (*expr != '=')\n\t    {\n\t\tif (vim9script && (flags & ASSIGN_NO_DECL) == 0)\n\t\t{\n\t\t    // +=, /=, etc. require an existing variable\n\t\t    semsg(_(e_cannot_use_operator_on_new_variable), eap->arg);\n\t\t    i = FAIL;\n\t\t}\n\t\telse if (vim_strchr((char_u *)\"+-*/%.\", *expr) != NULL)\n\t\t{\n\t\t    op[0] = *expr;   // +=, -=, *=, /=, %= or .=\n\t\t    ++len;\n\t\t    if (expr[0] == '.' && expr[1] == '.') // ..=\n\t\t    {\n\t\t\t++expr;\n\t\t\t++len;\n\t\t    }\n\t\t}\n\t\texpr += 2;\n\t    }\n\t    else\n\t\t++expr;\n\n\t    if (vim9script && !eap->skip && (!VIM_ISWHITE(*argend)\n\t\t\t\t\t\t   || !IS_WHITE_OR_NUL(*expr)))\n\t    {\n\t\tvim_strncpy(op, expr - len, len);\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t   op, argend);\n\t\ti = FAIL;\n\t    }\n\n\t    if (eap->skip)\n\t\t++emsg_skip;\n\t    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\t    expr = skipwhite_and_linebreak(expr, &evalarg);\n\t    cur_lnum = SOURCING_LNUM;\n\t    i = eval0(expr, &rettv, eap, &evalarg);\n\t    if (eap->skip)\n\t\t--emsg_skip;\n\t    clear_evalarg(&evalarg, eap);\n\n\t    // Restore the line number so that any type error is given for the\n\t    // declaration, not the expression.\n\t    SOURCING_LNUM = cur_lnum;\n\t}\n\tif (eap->skip)\n\t{\n\t    if (i != FAIL)\n\t\tclear_tv(&rettv);\n\t}\n\telse if (i != FAIL)\n\t{\n\t    (void)ex_let_vars(eap->arg, &rettv, FALSE, semicolon, var_count,\n\t\t\t\t\t\t\t\t    flags, op);\n\t    clear_tv(&rettv);\n\t}\n    }\n}\n\n/*\n * Assign the typeval \"tv\" to the variable or variables at \"arg_start\".\n * Handles both \"var\" with any type and \"[var, var; var]\" with a list type.\n * When \"op\" is not NULL it points to a string with characters that\n * must appear after the variable(s).  Use \"+\", \"-\" or \".\" for add, subtract\n * or concatenate.\n * Returns OK or FAIL;\n */\n    int\nex_let_vars(\n    char_u\t*arg_start,\n    typval_T\t*tv,\n    int\t\tcopy,\t\t// copy values from \"tv\", don't move\n    int\t\tsemicolon,\t// from skip_var_list()\n    int\t\tvar_count,\t// from skip_var_list()\n    int\t\tflags,\t\t// ASSIGN_FINAL, ASSIGN_CONST, etc.\n    char_u\t*op)\n{\n    char_u\t*arg = arg_start;\n    list_T\t*l;\n    int\t\ti;\n    int\t\tvar_idx = 0;\n    listitem_T\t*item;\n    typval_T\tltv;\n\n    if (*arg != '[')\n    {\n\t// \":let var = expr\" or \":for var in list\"\n\tif (ex_let_one(arg, tv, copy, flags, op, op, var_idx) == NULL)\n\t    return FAIL;\n\treturn OK;\n    }\n\n    // \":let [v1, v2] = list\" or \":for [v1, v2] in listlist\"\n    if (tv->v_type != VAR_LIST || (l = tv->vval.v_list) == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn FAIL;\n    }\n\n    i = list_len(l);\n    if (semicolon == 0 && var_count < i)\n    {\n\temsg(_(e_less_targets_than_list_items));\n\treturn FAIL;\n    }\n    if (var_count - semicolon > i)\n    {\n\temsg(_(e_more_targets_than_list_items));\n\treturn FAIL;\n    }\n\n    CHECK_LIST_MATERIALIZE(l);\n    item = l->lv_first;\n    while (*arg != ']')\n    {\n\targ = skipwhite(arg + 1);\n\t++var_idx;\n\targ = ex_let_one(arg, &item->li_tv, TRUE,\n\t\t\t  flags | ASSIGN_UNPACK, (char_u *)\",;]\", op, var_idx);\n\titem = item->li_next;\n\tif (arg == NULL)\n\t    return FAIL;\n\n\targ = skipwhite(arg);\n\tif (*arg == ';')\n\t{\n\t    // Put the rest of the list (may be empty) in the var after ';'.\n\t    // Create a new list for this.\n\t    l = list_alloc();\n\t    if (l == NULL)\n\t\treturn FAIL;\n\t    while (item != NULL)\n\t    {\n\t\tlist_append_tv(l, &item->li_tv);\n\t\titem = item->li_next;\n\t    }\n\n\t    ltv.v_type = VAR_LIST;\n\t    ltv.v_lock = 0;\n\t    ltv.vval.v_list = l;\n\t    l->lv_refcount = 1;\n\t    ++var_idx;\n\n\t    arg = ex_let_one(skipwhite(arg + 1), &ltv, FALSE,\n\t\t\t    flags | ASSIGN_UNPACK, (char_u *)\"]\", op, var_idx);\n\t    clear_tv(&ltv);\n\t    if (arg == NULL)\n\t\treturn FAIL;\n\t    break;\n\t}\n\telse if (*arg != ',' && *arg != ']')\n\t{\n\t    internal_error(\"ex_let_vars()\");\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Skip over assignable variable \"var\" or list of variables \"[var, var]\".\n * Used for \":let varvar = expr\" and \":for varvar in expr\".\n * For \"[var, var]\" increment \"*var_count\" for each variable.\n * for \"[var, var; var]\" set \"semicolon\" to 1.\n * If \"silent\" is TRUE do not give an \"invalid argument\" error message.\n * Return NULL for an error.\n */\n    char_u *\nskip_var_list(\n    char_u\t*arg,\n    int\t\tinclude_type,\n    int\t\t*var_count,\n    int\t\t*semicolon,\n    int\t\tsilent)\n{\n    char_u\t*p, *s;\n\n    if (*arg == '[')\n    {\n\t// \"[var, var]\": find the matching ']'.\n\tp = arg;\n\tfor (;;)\n\t{\n\t    p = skipwhite(p + 1);\t// skip whites after '[', ';' or ','\n\t    s = skip_var_one(p, include_type);\n\t    if (s == p)\n\t    {\n\t\tif (!silent)\n\t\t    semsg(_(e_invalid_argument_str), p);\n\t\treturn NULL;\n\t    }\n\t    ++*var_count;\n\n\t    p = skipwhite(s);\n\t    if (*p == ']')\n\t\tbreak;\n\t    else if (*p == ';')\n\t    {\n\t\tif (*semicolon == 1)\n\t\t{\n\t\t    if (!silent)\n\t\t\temsg(_(e_double_semicolon_in_list_of_variables));\n\t\t    return NULL;\n\t\t}\n\t\t*semicolon = 1;\n\t    }\n\t    else if (*p != ',')\n\t    {\n\t\tif (!silent)\n\t\t    semsg(_(e_invalid_argument_str), p);\n\t\treturn NULL;\n\t    }\n\t}\n\treturn p + 1;\n    }\n    else\n\treturn skip_var_one(arg, include_type);\n}\n\n/*\n * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,\n * l[idx].\n * In Vim9 script also skip over \": type\" if \"include_type\" is TRUE.\n */\n    char_u *\nskip_var_one(char_u *arg, int include_type)\n{\n    char_u\t*end;\n    int\t\tvim9 = in_vim9script();\n\n    if (*arg == '@' && arg[1] != NUL)\n\treturn arg + 2;\n    end = find_name_end(*arg == '$' || *arg == '&' ? arg + 1 : arg,\n\t\t\t\t   NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);\n\n    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n    // Same for \"s: type\".\n    if (vim9 && end == arg + 2 && end[-1] == ':')\n\t--end;\n\n    if (include_type && vim9)\n    {\n\tif (*end == ':')\n\t    end = skip_type(skipwhite(end + 1), FALSE);\n    }\n    return end;\n}\n\n/*\n * List variables for hashtab \"ht\" with prefix \"prefix\".\n * If \"empty\" is TRUE also list NULL strings as empty strings.\n */\n    void\nlist_hashtable_vars(\n    hashtab_T\t*ht,\n    char\t*prefix,\n    int\t\tempty,\n    int\t\t*first)\n{\n    hashitem_T\t*hi;\n    dictitem_T\t*di;\n    int\t\ttodo;\n    char_u\tbuf[IOSIZE];\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    di = HI2DI(hi);\n\n\t    // apply :filter /pat/ to variable name\n\t    vim_strncpy((char_u *)buf, (char_u *)prefix, IOSIZE - 1);\n\t    vim_strcat((char_u *)buf, di->di_key, IOSIZE);\n\t    if (message_filtered(buf))\n\t\tcontinue;\n\n\t    if (empty || di->di_tv.v_type != VAR_STRING\n\t\t\t\t\t   || di->di_tv.vval.v_string != NULL)\n\t\tlist_one_var(di, prefix, first);\n\t}\n    }\n}\n\n/*\n * List global variables.\n */\n    static void\nlist_glob_vars(int *first)\n{\n    list_hashtable_vars(&globvarht, \"\", TRUE, first);\n}\n\n/*\n * List buffer variables.\n */\n    static void\nlist_buf_vars(int *first)\n{\n    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, \"b:\", TRUE, first);\n}\n\n/*\n * List window variables.\n */\n    static void\nlist_win_vars(int *first)\n{\n    list_hashtable_vars(&curwin->w_vars->dv_hashtab, \"w:\", TRUE, first);\n}\n\n/*\n * List tab page variables.\n */\n    static void\nlist_tab_vars(int *first)\n{\n    list_hashtable_vars(&curtab->tp_vars->dv_hashtab, \"t:\", TRUE, first);\n}\n\n/*\n * List variables in \"arg\".\n */\n    static char_u *\nlist_arg_vars(exarg_T *eap, char_u *arg, int *first)\n{\n    int\t\terror = FALSE;\n    int\t\tlen;\n    char_u\t*name;\n    char_u\t*name_start;\n    char_u\t*arg_subsc;\n    char_u\t*tofree;\n    typval_T    tv;\n\n    while (!ends_excmd2(eap->cmd, arg) && !got_int)\n    {\n\tif (error || eap->skip)\n\t{\n\t    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);\n\t    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))\n\t    {\n\t\temsg_severe = TRUE;\n\t\tif (!did_emsg)\n\t\t    semsg(_(e_trailing_characters_str), arg);\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t{\n\t    // get_name_len() takes care of expanding curly braces\n\t    name_start = name = arg;\n\t    len = get_name_len(&arg, &tofree, TRUE, TRUE);\n\t    if (len <= 0)\n\t    {\n\t\t// This is mainly to keep test 49 working: when expanding\n\t\t// curly braces fails overrule the exception error message.\n\t\tif (len < 0 && !aborting())\n\t\t{\n\t\t    emsg_severe = TRUE;\n\t\t    semsg(_(e_invalid_argument_str), arg);\n\t\t    break;\n\t\t}\n\t\terror = TRUE;\n\t    }\n\t    else\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (tofree != NULL)\n\t\t    name = tofree;\n\t\tif (eval_variable(name, len, 0, &tv, NULL,\n\t\t\t\t\t\t     EVAL_VAR_VERBOSE) == FAIL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // handle d.key, l[idx], f(expr)\n\t\t    arg_subsc = arg;\n\t\t    if (handle_subscript(&arg, name_start, &tv,\n\t\t\t\t\t      &EVALARG_EVALUATE, TRUE) == FAIL)\n\t\t\terror = TRUE;\n\t\t    else\n\t\t    {\n\t\t\tif (arg == arg_subsc && len == 2 && name[1] == ':')\n\t\t\t{\n\t\t\t    switch (*name)\n\t\t\t    {\n\t\t\t\tcase 'g': list_glob_vars(first); break;\n\t\t\t\tcase 'b': list_buf_vars(first); break;\n\t\t\t\tcase 'w': list_win_vars(first); break;\n\t\t\t\tcase 't': list_tab_vars(first); break;\n\t\t\t\tcase 'v': list_vim_vars(first); break;\n\t\t\t\tcase 's': list_script_vars(first); break;\n\t\t\t\tcase 'l': list_func_vars(first); break;\n\t\t\t\tdefault:\n\t\t\t\t\t  semsg(_(e_cant_list_variables_for_str), name);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t\t    char_u\t*tf;\n\t\t\t    int\t\tc;\n\t\t\t    char_u\t*s;\n\n\t\t\t    s = echo_string(&tv, &tf, numbuf, 0);\n\t\t\t    c = *arg;\n\t\t\t    *arg = NUL;\n\t\t\t    list_one_var_a(\"\",\n\t\t\t\t    arg == arg_subsc ? name : name_start,\n\t\t\t\t    tv.v_type,\n\t\t\t\t    s == NULL ? (char_u *)\"\" : s,\n\t\t\t\t    first);\n\t\t\t    *arg = c;\n\t\t\t    vim_free(tf);\n\t\t\t}\n\t\t\tclear_tv(&tv);\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(tofree);\n\t}\n\n\targ = skipwhite(arg);\n    }\n\n    return arg;\n}\n\n/*\n * Set an environment variable, part of ex_let_one().\n */\n    static char_u *\nex_let_env(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*arg_end = NULL;\n    char_u\t*name;\n    int\t\tlen;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_environment_variable));\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    ++arg;\n    name = arg;\n    len = get_env_len(&arg);\n    if (len == 0)\n\tsemsg(_(e_invalid_argument_str), name - 1);\n    else\n    {\n\tif (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t    semsg(_(e_wrong_variable_type_for_str_equal), op);\n\telse if (endchars != NULL\n\t\t\t      && vim_strchr(endchars, *skipwhite(arg)) == NULL)\n\t    emsg(_(e_unexpected_characters_in_let));\n\telse if (!check_secure())\n\t{\n\t    char_u\t*tofree = NULL;\n\t    int\t\tc1 = name[len];\n\t    char_u\t*p;\n\n\t    name[len] = NUL;\n\t    p = tv_get_string_chk(tv);\n\t    if (p != NULL && op != NULL && *op == '.')\n\t    {\n\t\tint\tmustfree = FALSE;\n\t\tchar_u  *s = vim_getenv(name, &mustfree);\n\n\t\tif (s != NULL)\n\t\t{\n\t\t    p = tofree = concat_str(s, p);\n\t\t    if (mustfree)\n\t\t\tvim_free(s);\n\t\t}\n\t    }\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv_ext(name, p);\n\t\targ_end = arg;\n\t    }\n\t    name[len] = c1;\n\t    vim_free(tofree);\n\t}\n    }\n    return arg_end;\n}\n\n/*\n * Set an option, part of ex_let_one().\n */\n    static char_u *\nex_let_option(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*p;\n    int\t\tscope;\n    char_u\t*arg_end = NULL;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_option));\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_option_end(&arg, &scope);\n    if (p == NULL || (endchars != NULL\n\t\t\t       && vim_strchr(endchars, *skipwhite(p)) == NULL))\n\temsg(_(e_unexpected_characters_in_let));\n    else\n    {\n\tint\t    c1;\n\tlong\t    n = 0;\n\tgetoption_T opt_type;\n\tlong\t    numval;\n\tchar_u\t    *stringval = NULL;\n\tchar_u\t    *s = NULL;\n\tint\t    failed = FALSE;\n\tint\t    opt_p_flags;\n\tchar_u\t    *tofree = NULL;\n\tchar_u\t    numbuf[NUMBUFLEN];\n\n\tc1 = *p;\n\t*p = NUL;\n\n\topt_type = get_option_value(arg, &numval, &stringval, &opt_p_flags,\n\t\t\t\t\t\t\t\t\tscope);\n\tif ((opt_type == gov_bool\n\t\t    || opt_type == gov_number\n\t\t    || opt_type == gov_hidden_bool\n\t\t    || opt_type == gov_hidden_number)\n\t\t\t && (tv->v_type != VAR_STRING || !in_vim9script()))\n\t{\n\t    if (opt_type == gov_bool || opt_type == gov_hidden_bool)\n\t\t// bool, possibly hidden\n\t\tn = (long)tv_get_bool(tv);\n\t    else\n\t\t// number, possibly hidden\n\t\tn = (long)tv_get_number(tv);\n\t}\n\n\tif ((opt_p_flags & P_FUNC) && (tv->v_type == VAR_PARTIAL\n\t\t\t\t\t\t|| tv->v_type == VAR_FUNC))\n\t{\n\t    // If the option can be set to a function reference or a lambda\n\t    // and the passed value is a function reference, then convert it to\n\t    // the name (string) of the function reference.\n\t    s = tv2string(tv, &tofree, numbuf, 0);\n\t}\n\t// Avoid setting a string option to the text \"v:false\" or similar.\n\t// In Vim9 script also don't convert a number to string.\n\telse if (tv->v_type != VAR_BOOL && tv->v_type != VAR_SPECIAL\n\t\t\t && (!in_vim9script() || tv->v_type != VAR_NUMBER))\n\t    s = tv_get_string_chk(tv);\n\n\tif (op != NULL && *op != '=')\n\t{\n\t    if (((opt_type == gov_bool || opt_type == gov_number) && *op == '.')\n\t\t    || (opt_type == gov_string && *op != '.'))\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\tfailed = TRUE;  // don't set the value\n\n\t    }\n\t    else\n\t    {\n\t\t// number, in legacy script also bool\n\t\tif (opt_type == gov_number\n\t\t\t     || (opt_type == gov_bool && !in_vim9script()))\n\t\t{\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': n = numval + n; break;\n\t\t\tcase '-': n = numval - n; break;\n\t\t\tcase '*': n = numval * n; break;\n\t\t\tcase '/': n = (long)num_divide(numval, n,\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\tcase '%': n = (long)num_modulus(numval, n,\n\t\t\t\t\t\t\t       &failed); break;\n\t\t    }\n\t\t    s = NULL;\n\t\t}\n\t\telse if (opt_type == gov_string\n\t\t\t\t\t && stringval != NULL && s != NULL)\n\t\t{\n\t\t    // string\n\t\t    s = concat_str(stringval, s);\n\t\t    vim_free(stringval);\n\t\t    stringval = s;\n\t\t}\n\t    }\n\t}\n\n\tif (!failed)\n\t{\n\t    if (opt_type != gov_string || s != NULL)\n\t    {\n\t\tset_option_value(arg, n, s, scope);\n\t\targ_end = p;\n\t    }\n\t    else\n\t\temsg(_(e_string_required));\n\t}\n\t*p = c1;\n\tvim_free(stringval);\n\tvim_free(tofree);\n    }\n    return arg_end;\n}\n\n/*\n * Set a register, part of ex_let_one().\n */\n    static char_u *\nex_let_register(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*arg_end = NULL;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_register));\n\treturn NULL;\n    }\n    ++arg;\n    if (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n    else if (endchars != NULL\n\t\t\t  && vim_strchr(endchars, *skipwhite(arg + 1)) == NULL)\n\temsg(_(e_unexpected_characters_in_let));\n    else\n    {\n\tchar_u\t*ptofree = NULL;\n\tchar_u\t*p;\n\n\tp = tv_get_string_chk(tv);\n\tif (p != NULL && op != NULL && *op == '.')\n\t{\n\t    char_u  *s = get_reg_contents(*arg == '@'\n\t\t\t\t\t\t  ? '\"' : *arg, GREG_EXPR_SRC);\n\n\t    if (s != NULL)\n\t    {\n\t\tp = ptofree = concat_str(s, p);\n\t\tvim_free(s);\n\t    }\n\t}\n\tif (p != NULL)\n\t{\n\t    write_reg_contents(*arg == '@' ? '\"' : *arg, p, -1, FALSE);\n\t    arg_end = arg + 1;\n\t}\n\tvim_free(ptofree);\n    }\n    return arg_end;\n}\n\n/*\n * Set one item of \":let var = expr\" or \":let [v1, v2] = list\" to its value.\n * Returns a pointer to the char just after the var name.\n * Returns NULL if there is an error.\n */\n    static char_u *\nex_let_one(\n    char_u\t*arg,\t\t// points to variable name\n    typval_T\t*tv,\t\t// value to assign to variable\n    int\t\tcopy,\t\t// copy value from \"tv\"\n    int\t\tflags,\t\t// ASSIGN_CONST, ASSIGN_FINAL, etc.\n    char_u\t*endchars,\t// valid chars after variable name  or NULL\n    char_u\t*op,\t\t// \"+\", \"-\", \".\"  or NULL\n    int\t\tvar_idx)\t// variable index for \"let [a, b] = list\"\n{\n    char_u\t*arg_end = NULL;\n\n    if (in_vim9script() && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t\t\t&& (flags & (ASSIGN_CONST | ASSIGN_FINAL)) == 0\n\t\t\t\t  && vim_strchr((char_u *)\"$@&\", *arg) != NULL)\n    {\n\tvim9_declare_error(arg);\n\treturn NULL;\n    }\n\n    if (*arg == '$')\n    {\n\t// \":let $VAR = expr\": Set environment variable.\n\treturn ex_let_env(arg, tv, flags, endchars, op);\n    }\n    else if (*arg == '&')\n    {\n\t// \":let &option = expr\": Set option value.\n\t// \":let &l:option = expr\": Set local option value.\n\t// \":let &g:option = expr\": Set global option value.\n\t// \":for &ts in range(8)\": Set option value for for loop\n\treturn ex_let_option(arg, tv, flags, endchars, op);\n    }\n    else if (*arg == '@')\n    {\n\t// \":let @r = expr\": Set register contents.\n\treturn ex_let_register(arg, tv, flags, endchars, op);\n    }\n    else if (eval_isnamec1(*arg) || *arg == '{')\n    {\n\tlval_T\tlv;\n\tchar_u\t*p;\n\n\t// \":let var = expr\": Set internal variable.\n\t// \":let var: type = expr\": Set internal variable with type.\n\t// \":let {expr} = expr\": Idem, name made with curly braces\n\tp = get_lval(arg, tv, &lv, FALSE, FALSE,\n\t\t(flags & (ASSIGN_NO_DECL | ASSIGN_DECL))\n\t\t\t\t\t   ? GLV_NO_DECL : 0, FNE_CHECK_START);\n\tif (p != NULL && lv.ll_name != NULL)\n\t{\n\t    if (endchars != NULL && vim_strchr(endchars,\n\t\t\t\t\t   *skipwhite(lv.ll_name_end)) == NULL)\n\t    {\n\t\temsg(_(e_unexpected_characters_in_let));\n\t    }\n\t    else\n\t    {\n\t\tset_var_lval(&lv, p, tv, copy, flags, op, var_idx);\n\t\targ_end = lv.ll_name_end;\n\t    }\n\t}\n\tclear_lval(&lv);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n\n    return arg_end;\n}\n\n/*\n * \":unlet[!] var1 ... \" command.\n */\n    void\nex_unlet(exarg_T *eap)\n{\n    ex_unletlock(eap, eap->arg, 0, 0, do_unlet_var, NULL);\n}\n\n/*\n * \":lockvar\" and \":unlockvar\" commands\n */\n    void\nex_lockvar(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tdeep = 2;\n\n    if (eap->forceit)\n\tdeep = -1;\n    else if (vim_isdigit(*arg))\n    {\n\tdeep = getdigits(&arg);\n\targ = skipwhite(arg);\n    }\n\n    ex_unletlock(eap, arg, deep, 0, do_lock_var, NULL);\n}\n\n/*\n * \":unlet\", \":lockvar\" and \":unlockvar\" are quite similar.\n * Also used for Vim9 script.  \"callback\" is invoked as:\n *\tcallback(&lv, name_end, eap, deep, cookie)\n */\n    void\nex_unletlock(\n    exarg_T\t*eap,\n    char_u\t*argstart,\n    int\t\tdeep,\n    int\t\tglv_flags,\n    int\t\t(*callback)(lval_T *, char_u *, exarg_T *, int, void *),\n    void\t*cookie)\n{\n    char_u\t*arg = argstart;\n    char_u\t*name_end;\n    int\t\terror = FALSE;\n    lval_T\tlv;\n\n    do\n    {\n\tif (*arg == '$')\n\t{\n\t    lv.ll_name = arg;\n\t    lv.ll_tv = NULL;\n\t    ++arg;\n\t    if (get_env_len(&arg) == 0)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), arg - 1);\n\t\treturn;\n\t    }\n\t    if (!error && !eap->skip\n\t\t\t      && callback(&lv, arg, eap, deep, cookie) == FAIL)\n\t\terror = TRUE;\n\t    name_end = arg;\n\t}\n\telse\n\t{\n\t    // Parse the name and find the end.\n\t    name_end = get_lval(arg, NULL, &lv, TRUE, eap->skip || error,\n\t\t\t\t     glv_flags | GLV_NO_DECL, FNE_CHECK_START);\n\t    if (lv.ll_name == NULL)\n\t\terror = TRUE;\t    // error but continue parsing\n\t    if (name_end == NULL || (!VIM_ISWHITE(*name_end)\n\t\t\t\t\t\t    && !ends_excmd(*name_end)))\n\t    {\n\t\tif (name_end != NULL)\n\t\t{\n\t\t    emsg_severe = TRUE;\n\t\t    semsg(_(e_trailing_characters_str), name_end);\n\t\t}\n\t\tif (!(eap->skip || error))\n\t\t    clear_lval(&lv);\n\t\tbreak;\n\t    }\n\n\t    if (!error && !eap->skip\n\t\t\t && callback(&lv, name_end, eap, deep, cookie) == FAIL)\n\t\terror = TRUE;\n\n\t    if (!eap->skip)\n\t\tclear_lval(&lv);\n\t}\n\n\targ = skipwhite(name_end);\n    } while (!ends_excmd2(name_end, arg));\n\n    set_nextcmd(eap, arg);\n}\n\n    static int\ndo_unlet_var(\n    lval_T\t*lp,\n    char_u\t*name_end,\n    exarg_T\t*eap,\n    int\t\tdeep UNUSED,\n    void\t*cookie UNUSED)\n{\n    int\t\tforceit = eap->forceit;\n    int\t\tret = OK;\n    int\t\tcc;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *name_end;\n\t*name_end = NUL;\n\n\t// Environment variable, normal name or expanded name.\n\tif (*lp->ll_name == '$')\n\t    vim_unsetenv(lp->ll_name + 1);\n\telse if (do_unlet(lp->ll_name, forceit) == FAIL)\n\t    ret = FAIL;\n\t*name_end = cc;\n    }\n    else if ((lp->ll_list != NULL\n\t\t && value_check_lock(lp->ll_list->lv_lock, lp->ll_name, FALSE))\n\t    || (lp->ll_dict != NULL\n\t\t&& value_check_lock(lp->ll_dict->dv_lock, lp->ll_name, FALSE)))\n\treturn FAIL;\n    else if (lp->ll_range)\n    {\n\tif (list_unlet_range(lp->ll_list, lp->ll_li, lp->ll_name, lp->ll_n1,\n\t\t\t\t\t   !lp->ll_empty2, lp->ll_n2) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\tif (lp->ll_list != NULL)\n\t    // unlet a List item.\n\t    listitem_remove(lp->ll_list, lp->ll_li);\n\telse\n\t    // unlet a Dictionary item.\n\t    dictitem_remove(lp->ll_dict, lp->ll_di);\n    }\n\n    return ret;\n}\n\n/*\n * Unlet one item or a range of items from a list.\n * Return OK or FAIL.\n */\n    int\nlist_unlet_range(\n\tlist_T\t    *l,\n\tlistitem_T  *li_first,\n\tchar_u\t    *name,\n\tlong\t    n1_arg,\n\tint\t    has_n2,\n\tlong\t    n2)\n{\n    listitem_T  *li = li_first;\n    int\t\tn1 = n1_arg;\n\n    while (li != NULL && (!has_n2 || n2 >= n1))\n    {\n\tif (value_check_lock(li->li_tv.v_lock, name, FALSE))\n\t    return FAIL;\n\tli = li->li_next;\n\t++n1;\n    }\n\n    // Delete a range of List items.\n    li = li_first;\n    n1 = n1_arg;\n    while (li != NULL && (!has_n2 || n2 >= n1))\n    {\n\tlistitem_T *next = li->li_next;\n\n\tlistitem_remove(l, li);\n\tli = next;\n\t++n1;\n    }\n    return OK;\n}\n/*\n * \"unlet\" a variable.  Return OK if it existed, FAIL if not.\n * When \"forceit\" is TRUE don't complain if the variable doesn't exist.\n */\n    int\ndo_unlet(char_u *name, int forceit)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    char_u\t*varname;\n    dict_T\t*d;\n    dictitem_T\t*di;\n\n    // can't :unlet a script variable in Vim9 script\n    if (in_vim9script() && check_vim9_unlet(name) == FAIL)\n\treturn FAIL;\n\n    ht = find_var_ht(name, &varname);\n\n    // can't :unlet a script variable in Vim9 script from a function\n    if (ht == get_script_local_ht()\n\t    && SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t    && SCRIPT_ITEM(current_sctx.sc_sid)->sn_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t    && check_vim9_unlet(name) == FAIL)\n\treturn FAIL;\n\n    if (ht != NULL && *varname != NUL)\n    {\n\td = get_current_funccal_dict(ht);\n\tif (d == NULL)\n\t{\n\t    if (ht == &globvarht)\n\t\td = &globvardict;\n\t    else if (ht == &compat_hashtab)\n\t\td = &vimvardict;\n\t    else\n\t    {\n\t\tdi = find_var_in_ht(ht, *name, (char_u *)\"\", FALSE);\n\t\td = di == NULL ? NULL : di->di_tv.vval.v_dict;\n\t    }\n\t    if (d == NULL)\n\t    {\n\t\tinternal_error(\"do_unlet()\");\n\t\treturn FAIL;\n\t    }\n\t}\n\thi = hash_find(ht, varname);\n\tif (HASHITEM_EMPTY(hi))\n\t    hi = find_hi_in_scoped_ht(name, &ht);\n\tif (hi != NULL && !HASHITEM_EMPTY(hi))\n\t{\n\t    di = HI2DI(hi);\n\t    if (var_check_fixed(di->di_flags, name, FALSE)\n\t\t    || var_check_ro(di->di_flags, name, FALSE)\n\t\t    || value_check_lock(d->dv_lock, name, FALSE))\n\t\treturn FAIL;\n\n\t    delete_var(ht, hi);\n\t    return OK;\n\t}\n    }\n    if (forceit)\n\treturn OK;\n    semsg(_(e_no_such_variable_str), name);\n    return FAIL;\n}\n\n/*\n * Lock or unlock variable indicated by \"lp\".\n * \"deep\" is the levels to go (-1 for unlimited);\n * \"lock\" is TRUE for \":lockvar\", FALSE for \":unlockvar\".\n */\n    static int\ndo_lock_var(\n    lval_T\t*lp,\n    char_u\t*name_end,\n    exarg_T\t*eap,\n    int\t\tdeep,\n    void\t*cookie UNUSED)\n{\n    int\t\tlock = eap->cmdidx == CMD_lockvar;\n    int\t\tret = OK;\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *name_end;\n\t*name_end = NUL;\n\tif (*lp->ll_name == '$')\n\t{\n\t    semsg(_(e_cannot_lock_or_unlock_variable_str), lp->ll_name);\n\t    ret = FAIL;\n\t}\n\telse\n\t{\n\t    // Normal name or expanded name.\n\t    di = find_var(lp->ll_name, NULL, TRUE);\n\t    if (di == NULL)\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_cannot_find_variable_to_unlock_str),\n\t\t\t\t\t\t\t\t  lp->ll_name);\n\t\tret = FAIL;\n\t    }\n\t    else if ((di->di_flags & DI_FLAGS_FIX)\n\t\t\t    && di->di_tv.v_type != VAR_DICT\n\t\t\t    && di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\t// For historic reasons this error is not given for a list or\n\t\t// dict.  E.g., the b: dict could be locked/unlocked.\n\t\tsemsg(_(e_cannot_lock_or_unlock_variable_str), lp->ll_name);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tif (lock)\n\t\t    di->di_flags |= DI_FLAGS_LOCK;\n\t\telse\n\t\t    di->di_flags &= ~DI_FLAGS_LOCK;\n\t\tif (deep != 0)\n\t\t    item_lock(&di->di_tv, deep, lock, FALSE);\n\t    }\n\t}\n\t*name_end = cc;\n    }\n    else if (deep == 0)\n    {\n\t// nothing to do\n    }\n    else if (lp->ll_range)\n    {\n\tlistitem_T    *li = lp->ll_li;\n\n\t// (un)lock a range of List items.\n\twhile (li != NULL && (lp->ll_empty2 || lp->ll_n2 >= lp->ll_n1))\n\t{\n\t    item_lock(&li->li_tv, deep, lock, FALSE);\n\t    li = li->li_next;\n\t    ++lp->ll_n1;\n\t}\n    }\n    else if (lp->ll_list != NULL)\n\t// (un)lock a List item.\n\titem_lock(&lp->ll_li->li_tv, deep, lock, FALSE);\n    else\n\t// (un)lock a Dictionary item.\n\titem_lock(&lp->ll_di->di_tv, deep, lock, FALSE);\n\n    return ret;\n}\n\n/*\n * Lock or unlock an item.  \"deep\" is nr of levels to go.\n * When \"check_refcount\" is TRUE do not lock a list or dict with a reference\n * count larger than 1.\n */\n    void\nitem_lock(typval_T *tv, int deep, int lock, int check_refcount)\n{\n    static int\trecurse = 0;\n    list_T\t*l;\n    listitem_T\t*li;\n    dict_T\t*d;\n    blob_T\t*b;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_unlock));\n\treturn;\n    }\n    if (deep == 0)\n\treturn;\n    ++recurse;\n\n    // lock/unlock the item itself\n    if (lock)\n\ttv->v_lock |= VAR_LOCKED;\n    else\n\ttv->v_lock &= ~VAR_LOCKED;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break;\n\n\tcase VAR_BLOB:\n\t    if ((b = tv->vval.v_blob) != NULL\n\t\t\t\t    && !(check_refcount && b->bv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    b->bv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    b->bv_lock &= ~VAR_LOCKED;\n\t    }\n\t    break;\n\tcase VAR_LIST:\n\t    if ((l = tv->vval.v_list) != NULL\n\t\t\t\t    && !(check_refcount && l->lv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    l->lv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    l->lv_lock &= ~VAR_LOCKED;\n\t\tif (deep < 0 || deep > 1)\n\t\t{\n\t\t    if (l->lv_first == &range_list_item)\n\t\t\tl->lv_lock |= VAR_ITEMS_LOCKED;\n\t\t    else\n\t\t    {\n\t\t\t// recursive: lock/unlock the items the List contains\n\t\t\tCHECK_LIST_MATERIALIZE(l);\n\t\t\tFOR_ALL_LIST_ITEMS(l, li) item_lock(&li->li_tv,\n\t\t\t\t\t       deep - 1, lock, check_refcount);\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase VAR_DICT:\n\t    if ((d = tv->vval.v_dict) != NULL\n\t\t\t\t    && !(check_refcount && d->dv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    d->dv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    d->dv_lock &= ~VAR_LOCKED;\n\t\tif (deep < 0 || deep > 1)\n\t\t{\n\t\t    // recursive: lock/unlock the items the List contains\n\t\t    todo = (int)d->dv_hashtab.ht_used;\n\t\t    for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t\t    {\n\t\t\tif (!HASHITEM_EMPTY(hi))\n\t\t\t{\n\t\t\t    --todo;\n\t\t\t    item_lock(&HI2DI(hi)->di_tv, deep - 1, lock,\n\t\t\t\t\t\t\t       check_refcount);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n    }\n    --recurse;\n}\n\n#if (defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)) || defined(PROTO)\n/*\n * Delete all \"menutrans_\" variables.\n */\n    void\ndel_menutrans_vars(void)\n{\n    hashitem_T\t*hi;\n    int\t\ttodo;\n\n    hash_lock(&globvarht);\n    todo = (int)globvarht.ht_used;\n    for (hi = globvarht.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    if (STRNCMP(HI2DI(hi)->di_key, \"menutrans_\", 10) == 0)\n\t\tdelete_var(&globvarht, hi);\n\t}\n    }\n    hash_unlock(&globvarht);\n}\n#endif\n\n/*\n * Local string buffer for the next two functions to store a variable name\n * with its prefix. Allocated in cat_prefix_varname(), freed later in\n * get_user_var_name().\n */\n\nstatic char_u\t*varnamebuf = NULL;\nstatic int\tvarnamebuflen = 0;\n\n/*\n * Function to concatenate a prefix and a variable name.\n */\n    char_u *\ncat_prefix_varname(int prefix, char_u *name)\n{\n    int\t\tlen;\n\n    len = (int)STRLEN(name) + 3;\n    if (len > varnamebuflen)\n    {\n\tvim_free(varnamebuf);\n\tlen += 10;\t\t\t// some additional space\n\tvarnamebuf = alloc(len);\n\tif (varnamebuf == NULL)\n\t{\n\t    varnamebuflen = 0;\n\t    return NULL;\n\t}\n\tvarnamebuflen = len;\n    }\n    *varnamebuf = prefix;\n    varnamebuf[1] = ':';\n    STRCPY(varnamebuf + 2, name);\n    return varnamebuf;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * (global/buffer/window/built-in) variable names.\n */\n    char_u *\nget_user_var_name(expand_T *xp, int idx)\n{\n    static long_u\tgdone;\n    static long_u\tbdone;\n    static long_u\twdone;\n    static long_u\ttdone;\n    static int\t\tvidx;\n    static hashitem_T\t*hi;\n    hashtab_T\t\t*ht;\n\n    if (idx == 0)\n    {\n\tgdone = bdone = wdone = vidx = 0;\n\ttdone = 0;\n    }\n\n    // Global variables\n    if (gdone < globvarht.ht_used)\n    {\n\tif (gdone++ == 0)\n\t    hi = globvarht.ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tif (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)\n\t    return cat_prefix_varname('g', hi->hi_key);\n\treturn hi->hi_key;\n    }\n\n    // b: variables\n    ht =\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :\n#endif\n\t&curbuf->b_vars->dv_hashtab;\n    if (bdone < ht->ht_used)\n    {\n\tif (bdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('b', hi->hi_key);\n    }\n\n    // w: variables\n    ht =\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative window should be used.\n\tis_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :\n#endif\n\t&curwin->w_vars->dv_hashtab;\n    if (wdone < ht->ht_used)\n    {\n\tif (wdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('w', hi->hi_key);\n    }\n\n    // t: variables\n    ht = &curtab->tp_vars->dv_hashtab;\n    if (tdone < ht->ht_used)\n    {\n\tif (tdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('t', hi->hi_key);\n    }\n\n    // v: variables\n    if (vidx < VV_LEN)\n\treturn cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);\n\n    VIM_CLEAR(varnamebuf);\n    varnamebuflen = 0;\n    return NULL;\n}\n\n    char *\nget_var_special_name(int nr)\n{\n    switch (nr)\n    {\n\tcase VVAL_FALSE: return in_vim9script() ? \"false\" : \"v:false\";\n\tcase VVAL_TRUE:  return in_vim9script() ? \"true\" : \"v:true\";\n\tcase VVAL_NULL:  return in_vim9script() ? \"null\" : \"v:null\";\n\tcase VVAL_NONE:  return \"v:none\";\n    }\n    internal_error(\"get_var_special_name()\");\n    return \"42\";\n}\n\n/*\n * Returns the global variable dictionary\n */\n    dict_T *\nget_globvar_dict(void)\n{\n    return &globvardict;\n}\n\n/*\n * Returns the global variable hash table\n */\n    hashtab_T *\nget_globvar_ht(void)\n{\n    return &globvarht;\n}\n\n/*\n * Returns the v: variable dictionary\n */\n    dict_T *\nget_vimvar_dict(void)\n{\n    return &vimvardict;\n}\n\n/*\n * Returns the index of a v:variable.  Negative if not found.\n * Returns DI_ flags in \"di_flags\".\n */\n    int\nfind_vim_var(char_u *name, int *di_flags)\n{\n    dictitem_T\t    *di = find_var_in_ht(&vimvarht, 0, name, TRUE);\n    struct vimvar   *vv;\n\n    if (di == NULL)\n\treturn -1;\n    *di_flags = di->di_flags;\n    vv = (struct vimvar *)((char *)di - offsetof(vimvar_T, vv_di));\n    return (int)(vv - vimvars);\n}\n\n\n/*\n * Set type of v: variable to \"type\".\n */\n    void\nset_vim_var_type(int idx, vartype_T type)\n{\n    vimvars[idx].vv_tv_type = type;\n}\n\n/*\n * Set number v: variable to \"val\".\n * Note that this does not set the type, use set_vim_var_type() for that.\n */\n    void\nset_vim_var_nr(int idx, varnumber_T val)\n{\n    vimvars[idx].vv_nr = val;\n}\n\n    char *\nget_vim_var_name(int idx)\n{\n    return vimvars[idx].vv_name;\n}\n\n/*\n * Get typval_T v: variable value.\n */\n    typval_T *\nget_vim_var_tv(int idx)\n{\n    return &vimvars[idx].vv_tv;\n}\n\n    type_T *\nget_vim_var_type(int idx, garray_T *type_list)\n{\n    if (vimvars[idx].vv_type != NULL)\n\treturn vimvars[idx].vv_type;\n    return typval2type_vimvar(&vimvars[idx].vv_tv, type_list);\n}\n\n/*\n * Set v: variable to \"tv\".  Only accepts the same type.\n * Takes over the value of \"tv\".\n */\n    int\nset_vim_var_tv(int idx, typval_T *tv)\n{\n    if (vimvars[idx].vv_tv_type != tv->v_type)\n    {\n\temsg(_(e_type_mismatch_for_v_variable));\n\tclear_tv(tv);\n\treturn FAIL;\n    }\n    // VV_RO is also checked when compiling, but let's check here as well.\n    if (vimvars[idx].vv_flags & VV_RO)\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), vimvars[idx].vv_name);\n\treturn FAIL;\n    }\n    if (sandbox && (vimvars[idx].vv_flags & VV_RO_SBX))\n    {\n\tsemsg(_(e_cannot_set_variable_in_sandbox_str), vimvars[idx].vv_name);\n\treturn FAIL;\n    }\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_di.di_tv = *tv;\n    return OK;\n}\n\n/*\n * Get number v: variable value.\n */\n    varnumber_T\nget_vim_var_nr(int idx)\n{\n    return vimvars[idx].vv_nr;\n}\n\n/*\n * Get string v: variable value.  Uses a static buffer, can only be used once.\n * If the String variable has never been set, return an empty string.\n * Never returns NULL;\n */\n    char_u *\nget_vim_var_str(int idx)\n{\n    return tv_get_string(&vimvars[idx].vv_tv);\n}\n\n/*\n * Get List v: variable value.  Caller must take care of reference count when\n * needed.\n */\n    list_T *\nget_vim_var_list(int idx)\n{\n    return vimvars[idx].vv_list;\n}\n\n/*\n * Get Dict v: variable value.  Caller must take care of reference count when\n * needed.\n */\n    dict_T *\nget_vim_var_dict(int idx)\n{\n    return vimvars[idx].vv_dict;\n}\n\n/*\n * Set v:char to character \"c\".\n */\n    void\nset_vim_var_char(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n    set_vim_var_string(VV_CHAR, buf, -1);\n}\n\n/*\n * Set v:count to \"count\" and v:count1 to \"count1\".\n * When \"set_prevcount\" is TRUE first set v:prevcount from v:count.\n */\n    void\nset_vcount(\n    long\tcount,\n    long\tcount1,\n    int\t\tset_prevcount)\n{\n    if (set_prevcount)\n\tvimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;\n    vimvars[VV_COUNT].vv_nr = count;\n    vimvars[VV_COUNT1].vv_nr = count1;\n}\n\n/*\n * Save variables that might be changed as a side effect.  Used when executing\n * a timer callback.\n */\n    void\nsave_vimvars(vimvars_save_T *vvsave)\n{\n    vvsave->vv_prevcount = vimvars[VV_PREVCOUNT].vv_nr;\n    vvsave->vv_count = vimvars[VV_COUNT].vv_nr;\n    vvsave->vv_count1 = vimvars[VV_COUNT1].vv_nr;\n}\n\n/*\n * Restore variables saved by save_vimvars().\n */\n    void\nrestore_vimvars(vimvars_save_T *vvsave)\n{\n    vimvars[VV_PREVCOUNT].vv_nr = vvsave->vv_prevcount;\n    vimvars[VV_COUNT].vv_nr = vvsave->vv_count;\n    vimvars[VV_COUNT1].vv_nr = vvsave->vv_count1;\n}\n\n/*\n * Set string v: variable to a copy of \"val\". If 'copy' is FALSE, then set the\n * value.\n */\n    void\nset_vim_var_string(\n    int\t\tidx,\n    char_u\t*val,\n    int\t\tlen)\t    // length of \"val\" to use or -1 (whole string)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_STRING;\n    if (val == NULL)\n\tvimvars[idx].vv_str = NULL;\n    else if (len == -1)\n\tvimvars[idx].vv_str = vim_strsave(val);\n    else\n\tvimvars[idx].vv_str = vim_strnsave(val, len);\n}\n\n/*\n * Set List v: variable to \"val\".\n */\n    void\nset_vim_var_list(int idx, list_T *val)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_LIST;\n    vimvars[idx].vv_list = val;\n    if (val != NULL)\n\t++val->lv_refcount;\n}\n\n/*\n * Set Dictionary v: variable to \"val\".\n */\n    void\nset_vim_var_dict(int idx, dict_T *val)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_DICT;\n    vimvars[idx].vv_dict = val;\n    if (val != NULL)\n    {\n\t++val->dv_refcount;\n\tdict_set_items_ro(val);\n    }\n}\n\n/*\n * Set the v:argv list.\n */\n    void\nset_argv_var(char **argv, int argc)\n{\n    list_T\t*l = list_alloc();\n    int\t\ti;\n\n    if (l == NULL)\n\tgetout(1);\n    l->lv_lock = VAR_FIXED;\n    for (i = 0; i < argc; ++i)\n    {\n\tif (list_append_string(l, (char_u *)argv[i], -1) == FAIL)\n\t    getout(1);\n\tl->lv_u.mat.lv_last->li_tv.v_lock = VAR_FIXED;\n    }\n    set_vim_var_list(VV_ARGV, l);\n}\n\n/*\n * Reset v:register, taking the 'clipboard' setting into account.\n */\n    void\nreset_reg_var(void)\n{\n    int regname = 0;\n\n    // Adjust the register according to 'clipboard', so that when\n    // \"unnamed\" is present it becomes '*' or '+' instead of '\"'.\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n#endif\n    set_reg_var(regname);\n}\n\n/*\n * Set v:register if needed.\n */\n    void\nset_reg_var(int c)\n{\n    char_u\tregname;\n\n    if (c == 0 || c == ' ')\n\tregname = '\"';\n    else\n\tregname = c;\n    // Avoid free/alloc when the value is already right.\n    if (vimvars[VV_REG].vv_str == NULL || vimvars[VV_REG].vv_str[0] != c)\n\tset_vim_var_string(VV_REG, &regname, 1);\n}\n\n/*\n * Get or set v:exception.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:exception!  Does not\n * take care of memory allocations.\n */\n    char_u *\nv_exception(char_u *oldval)\n{\n    if (oldval == NULL)\n\treturn vimvars[VV_EXCEPTION].vv_str;\n\n    vimvars[VV_EXCEPTION].vv_str = oldval;\n    return NULL;\n}\n\n/*\n * Get or set v:throwpoint.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:throwpoint!  Does not\n * take care of memory allocations.\n */\n    char_u *\nv_throwpoint(char_u *oldval)\n{\n    if (oldval == NULL)\n\treturn vimvars[VV_THROWPOINT].vv_str;\n\n    vimvars[VV_THROWPOINT].vv_str = oldval;\n    return NULL;\n}\n\n/*\n * Set v:cmdarg.\n * If \"eap\" != NULL, use \"eap\" to generate the value and return the old value.\n * If \"oldarg\" != NULL, restore the value to \"oldarg\" and return NULL.\n * Must always be called in pairs!\n */\n    char_u *\nset_cmdarg(exarg_T *eap, char_u *oldarg)\n{\n    char_u\t*oldval;\n    char_u\t*newval;\n    unsigned\tlen;\n\n    oldval = vimvars[VV_CMDARG].vv_str;\n    if (eap == NULL)\n    {\n\tvim_free(oldval);\n\tvimvars[VV_CMDARG].vv_str = oldarg;\n\treturn NULL;\n    }\n\n    if (eap->force_bin == FORCE_BIN)\n\tlen = 6;\n    else if (eap->force_bin == FORCE_NOBIN)\n\tlen = 8;\n    else\n\tlen = 0;\n\n    if (eap->read_edit)\n\tlen += 7;\n\n    if (eap->force_ff != 0)\n\tlen += 10; // \" ++ff=unix\"\n    if (eap->force_enc != 0)\n\tlen += (unsigned)STRLEN(eap->cmd + eap->force_enc) + 7;\n    if (eap->bad_char != 0)\n\tlen += 7 + 4;  // \" ++bad=\" + \"keep\" or \"drop\"\n\n    newval = alloc(len + 1);\n    if (newval == NULL)\n\treturn NULL;\n\n    if (eap->force_bin == FORCE_BIN)\n\tsprintf((char *)newval, \" ++bin\");\n    else if (eap->force_bin == FORCE_NOBIN)\n\tsprintf((char *)newval, \" ++nobin\");\n    else\n\t*newval = NUL;\n\n    if (eap->read_edit)\n\tSTRCAT(newval, \" ++edit\");\n\n    if (eap->force_ff != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++ff=%s\",\n\t\t\t\t\t\teap->force_ff == 'u' ? \"unix\"\n\t\t\t\t\t\t: eap->force_ff == 'd' ? \"dos\"\n\t\t\t\t\t\t: \"mac\");\n    if (eap->force_enc != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++enc=%s\",\n\t\t\t\t\t       eap->cmd + eap->force_enc);\n    if (eap->bad_char == BAD_KEEP)\n\tSTRCPY(newval + STRLEN(newval), \" ++bad=keep\");\n    else if (eap->bad_char == BAD_DROP)\n\tSTRCPY(newval + STRLEN(newval), \" ++bad=drop\");\n    else if (eap->bad_char != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++bad=%c\", eap->bad_char);\n    vimvars[VV_CMDARG].vv_str = newval;\n    return oldval;\n}\n\n/*\n * Get the value of internal variable \"name\".\n * If \"flags\" has EVAL_VAR_IMPORT may return a VAR_ANY with v_number set to the\n * imported script ID.\n * Return OK or FAIL.  If OK is returned \"rettv\" must be cleared.\n */\n    int\neval_variable(\n    char_u\t*name,\n    int\t\tlen,\t\t// length of \"name\"\n    scid_T\tsid,\t\t// script ID for imported item or zero\n    typval_T\t*rettv,\t\t// NULL when only checking existence\n    dictitem_T\t**dip,\t\t// non-NULL when typval's dict item is needed\n    int\t\tflags)\t\t// EVAL_VAR_ flags\n{\n    int\t\tret = OK;\n    typval_T\t*tv = NULL;\n    int\t\tfound = FALSE;\n    hashtab_T\t*ht = NULL;\n    int\t\tcc;\n    type_T\t*type = NULL;\n\n    // truncate the name, so that we can use strcmp()\n    cc = name[len];\n    name[len] = NUL;\n\n    // Check for local variable when debugging.\n    if ((tv = lookup_debug_var(name)) == NULL)\n    {\n\t// Check for user-defined variables.\n\tdictitem_T\t*v = find_var(name, &ht, flags & EVAL_VAR_NOAUTOLOAD);\n\n\tif (v != NULL)\n\t{\n\t    tv = &v->di_tv;\n\t    if (dip != NULL)\n\t\t*dip = v;\n\t}\n\telse\n\t    ht = NULL;\n    }\n\n    if (tv == NULL && (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0))\n    {\n\timported_T  *import = NULL;\n\tchar_u\t    *p = STRNCMP(name, \"s:\", 2) == 0 ? name + 2 : name;\n\n\tif (sid == 0)\n\t    import = find_imported(p, 0, TRUE);\n\n\t// imported variable from another script\n\tif (import != NULL || sid != 0)\n\t{\n\t    if ((flags & EVAL_VAR_IMPORT) == 0)\n\t    {\n\t\tif (SCRIPT_ID_VALID(sid))\n\t\t{\n\t\t    ht = &SCRIPT_VARS(sid);\n\t\t    if (ht != NULL)\n\t\t    {\n\t\t\tdictitem_T *v = find_var_in_ht(ht, 0, name,\n\t\t\t\t\t\t  flags & EVAL_VAR_NOAUTOLOAD);\n\n\t\t\tif (v != NULL)\n\t\t\t{\n\t\t\t    tv = &v->di_tv;\n\t\t\t    if (dip != NULL)\n\t\t\t\t*dip = v;\n\t\t\t}\n\t\t\telse\n\t\t\t    ht = NULL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (flags & EVAL_VAR_VERBOSE)\n\t\t\tsemsg(_(e_expected_dot_after_name_str), name);\n\t\t    ret = FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (rettv != NULL)\n\t\t{\n\t\t    rettv->v_type = VAR_ANY;\n\t\t    rettv->vval.v_number = sid != 0 ? sid : import->imp_sid;\n\t\t}\n\t\tfound = TRUE;\n\t    }\n\t}\n\telse if (in_vim9script() && (flags & EVAL_VAR_NO_FUNC) == 0)\n\t{\n\t    int\t    has_g_prefix = STRNCMP(name, \"g:\", 2) == 0;\n\t    ufunc_T *ufunc = find_func(name, FALSE);\n\n\t    // In Vim9 script we can get a function reference by using the\n\t    // function name.  For a global non-autoload function \"g:\" is\n\t    // required.\n\t    if (ufunc != NULL && (has_g_prefix\n\t\t\t\t\t    || !func_requires_g_prefix(ufunc)))\n\t    {\n\t\tfound = TRUE;\n\t\tif (rettv != NULL)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    if (has_g_prefix)\n\t\t\t// Keep the \"g:\", otherwise script-local may be\n\t\t\t// assumed.\n\t\t\trettv->vval.v_string = vim_strsave(name);\n\t\t    else\n\t\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t\t    if (rettv->vval.v_string != NULL)\n\t\t\tfunc_ref(ufunc->uf_name);\n\t\t}\n\t    }\n\t}\n    }\n\n    if (!found)\n    {\n\tif (tv == NULL)\n\t{\n\t    if (rettv != NULL && (flags & EVAL_VAR_VERBOSE))\n\t\tsemsg(_(e_undefined_variable_str), name);\n\t    ret = FAIL;\n\t}\n\telse if (rettv != NULL)\n\t{\n\t    if (ht != NULL && ht == get_script_local_ht()\n\t\t    && tv != &SCRIPT_SV(current_sctx.sc_sid)->sv_var.di_tv)\n\t    {\n\t\tsvar_T *sv = find_typval_in_script(tv, 0);\n\n\t\tif (sv != NULL)\n\t\t    type = sv->sv_type;\n\t    }\n\n\t    // If a list or dict variable wasn't initialized, do it now.\n\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict == NULL)\n\t    {\n\t\ttv->vval.v_dict = dict_alloc();\n\t\tif (tv->vval.v_dict != NULL)\n\t\t{\n\t\t    ++tv->vval.v_dict->dv_refcount;\n\t\t    tv->vval.v_dict->dv_type = alloc_type(type);\n\t\t}\n\t    }\n\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list == NULL)\n\t    {\n\t\ttv->vval.v_list = list_alloc();\n\t\tif (tv->vval.v_list != NULL)\n\t\t{\n\t\t    ++tv->vval.v_list->lv_refcount;\n\t\t    tv->vval.v_list->lv_type = alloc_type(type);\n\t\t}\n\t    }\n\t    else if (tv->v_type == VAR_BLOB && tv->vval.v_blob == NULL)\n\t    {\n\t\ttv->vval.v_blob = blob_alloc();\n\t\tif (tv->vval.v_blob != NULL)\n\t\t    ++tv->vval.v_blob->bv_refcount;\n\t    }\n\t    copy_tv(tv, rettv);\n\t}\n    }\n\n    name[len] = cc;\n\n    return ret;\n}\n\n/*\n * Check if variable \"name[len]\" is a local variable or an argument.\n * If so, \"*eval_lavars_used\" is set to TRUE.\n */\n    void\ncheck_vars(char_u *name, int len)\n{\n    int\t\tcc;\n    char_u\t*varname;\n    hashtab_T\t*ht;\n\n    if (eval_lavars_used == NULL)\n\treturn;\n\n    // truncate the name, so that we can use strcmp()\n    cc = name[len];\n    name[len] = NUL;\n\n    ht = find_var_ht(name, &varname);\n    if (ht == get_funccal_local_ht() || ht == get_funccal_args_ht())\n    {\n\tif (find_var(name, NULL, TRUE) != NULL)\n\t    *eval_lavars_used = TRUE;\n    }\n\n    name[len] = cc;\n}\n\n/*\n * Find variable \"name\" in the list of variables.\n * Return a pointer to it if found, NULL if not found.\n * Careful: \"a:0\" variables don't have a name.\n * When \"htp\" is not NULL  set \"htp\" to the hashtab_T used.\n */\n    dictitem_T *\nfind_var(char_u *name, hashtab_T **htp, int no_autoload)\n{\n    char_u\t*varname;\n    hashtab_T\t*ht;\n    dictitem_T\t*ret = NULL;\n\n    ht = find_var_ht(name, &varname);\n    if (htp != NULL)\n\t*htp = ht;\n    if (ht == NULL)\n\treturn NULL;\n    ret = find_var_in_ht(ht, *name, varname, no_autoload);\n    if (ret != NULL)\n\treturn ret;\n\n    // Search in parent scope for lambda\n    ret = find_var_in_scoped_ht(name, no_autoload);\n    if (ret != NULL)\n\treturn ret;\n\n    // in Vim9 script items without a scope can be script-local\n    if (in_vim9script() && name[0] != NUL && name[1] != ':')\n    {\n\tht = get_script_local_ht();\n\tif (ht != NULL)\n\t{\n\t    ret = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (ret != NULL)\n\t    {\n\t\tif (htp != NULL)\n\t\t    *htp = ht;\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    // When using \"vim9script autoload\" script-local items are prefixed but can\n    // be used with s:name.\n    if (SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t\t\t\t\t   && name[0] == 's' && name[1] == ':')\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    char_u *auto_name = concat_str(si->sn_autoload_prefix, name + 2);\n\n\t    if (auto_name != NULL)\n\t    {\n\t\tht = &globvarht;\n\t\tret = find_var_in_ht(ht, *name, auto_name, TRUE);\n\t\tvim_free(auto_name);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    if (htp != NULL)\n\t\t\t*htp = ht;\n\t\t    return ret;\n\t\t}\n\t    }\n\t}\n    }\n\n    return NULL;\n}\n\n/*\n * Like find_var() but if the name starts with <SNR>99_ then look in the\n * referenced script (used for a funcref).\n */\n    dictitem_T *\nfind_var_also_in_script(char_u *name, hashtab_T **htp, int no_autoload)\n{\n    if (STRNCMP(name, \"<SNR>\", 5) == 0 && isdigit(name[5]))\n    {\n\tchar_u\t    *p = name + 5;\n\tint\t    sid = getdigits(&p);\n\n\tif (SCRIPT_ID_VALID(sid) && *p == '_')\n\t{\n\t    hashtab_T\t*ht = &SCRIPT_VARS(sid);\n\n\t    if (ht != NULL)\n\t    {\n\t\tdictitem_T *di = find_var_in_ht(ht, 0, p + 1, no_autoload);\n\n\t\tif (di != NULL)\n\t\t{\n\t\t    if (htp != NULL)\n\t\t\t*htp = ht;\n\t\t    return di;\n\t\t}\n\t    }\n\t}\n    }\n\n    return find_var(name, htp, no_autoload);\n}\n\n/*\n * Find variable \"varname\" in hashtab \"ht\" with name \"htname\".\n * When \"varname\" is empty returns curwin/curtab/etc vars dictionary.\n * Returns NULL if not found.\n */\n    dictitem_T *\nfind_var_in_ht(\n    hashtab_T\t*ht,\n    int\t\thtname,\n    char_u\t*varname,\n    int\t\tno_autoload)\n{\n    hashitem_T\t*hi;\n\n    if (*varname == NUL)\n    {\n\t// Must be something like \"s:\", otherwise \"ht\" would be NULL.\n\tswitch (htname)\n\t{\n\t    case 's': return &SCRIPT_SV(current_sctx.sc_sid)->sv_var;\n\t    case 'g': return &globvars_var;\n\t    case 'v': return &vimvars_var;\n\t    case 'b': return &curbuf->b_bufvar;\n\t    case 'w': return &curwin->w_winvar;\n\t    case 't': return &curtab->tp_winvar;\n\t    case 'l': return get_funccal_local_var();\n\t    case 'a': return get_funccal_args_var();\n\t}\n\treturn NULL;\n    }\n\n    hi = hash_find(ht, varname);\n    if (HASHITEM_EMPTY(hi))\n    {\n\t// For global variables we may try auto-loading the script.  If it\n\t// worked find the variable again.  Don't auto-load a script if it was\n\t// loaded already, otherwise it would be loaded every time when\n\t// checking if a function name is a Funcref variable.\n\tif (ht == &globvarht && !no_autoload)\n\t{\n\t    // Note: script_autoload() may make \"hi\" invalid. It must either\n\t    // be obtained again or not used.\n\t    if (!script_autoload(varname, FALSE) || aborting())\n\t\treturn NULL;\n\t    hi = hash_find(ht, varname);\n\t}\n\tif (HASHITEM_EMPTY(hi))\n\t    return NULL;\n    }\n    return HI2DI(hi);\n}\n\n/*\n * Get the script-local hashtab.  NULL if not in a script context.\n */\n    hashtab_T *\nget_script_local_ht(void)\n{\n    scid_T sid = current_sctx.sc_sid;\n\n    if (SCRIPT_ID_VALID(sid))\n\treturn &SCRIPT_VARS(sid);\n    return NULL;\n}\n\n/*\n * Look for \"name[len]\" in script-local variables and functions.\n * When \"cmd\" is TRUE it must look like a command, a function must be followed\n * by \"(\" or \"->\".\n * Return OK when found, FAIL when not found.\n */\n    int\nlookup_scriptitem(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tcmd,\n\tcctx_T\t*dummy UNUSED)\n{\n    hashtab_T\t*ht = get_script_local_ht();\n    char_u\tbuffer[30];\n    char_u\t*p;\n    int\t\tres;\n    hashitem_T\t*hi;\n    int\t\tis_global = FALSE;\n    char_u\t*fname = name;\n\n    if (ht == NULL)\n\treturn FAIL;\n    if (len < sizeof(buffer) - 1)\n    {\n\t// avoid an alloc/free for short names\n\tvim_strncpy(buffer, name, len);\n\tp = buffer;\n    }\n    else\n    {\n\tp = vim_strnsave(name, len);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    hi = hash_find(ht, p);\n    res = HASHITEM_EMPTY(hi) ? FAIL : OK;\n\n    // if not script-local, then perhaps imported\n    if (res == FAIL && find_imported(p, 0, FALSE) != NULL)\n\tres = OK;\n    if (p != buffer)\n\tvim_free(p);\n\n    // Find a function, so that a following \"->\" works.\n    // When used as a command require \"(\" or \"->\" to follow, \"Cmd\" is a user\n    // command while \"Cmd()\" is a function call.\n    if (res != OK)\n    {\n\tp = skipwhite(name + len);\n\n\tif (!cmd || name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n\t{\n\t    // Do not check for an internal function, since it might also be a\n\t    // valid command, such as \":split\" versus \"split()\".\n\t    // Skip \"g:\" before a function name.\n\t    if (name[0] == 'g' && name[1] == ':')\n\t    {\n\t\tis_global = TRUE;\n\t\tfname = name + 2;\n\t    }\n\t    if (find_func(fname, is_global) != NULL)\n\t\tres = OK;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Find the hashtab used for a variable name.\n * Return NULL if the name is not valid.\n * Set \"varname\" to the start of name without ':'.\n */\n    hashtab_T *\nfind_var_ht(char_u *name, char_u **varname)\n{\n    hashitem_T\t*hi;\n    hashtab_T\t*ht;\n\n    if (name[0] == NUL)\n\treturn NULL;\n    if (name[1] != ':')\n    {\n\t// The name must not start with a colon or #.\n\tif (name[0] == ':' || name[0] == AUTOLOAD_CHAR)\n\t    return NULL;\n\t*varname = name;\n\n\t// \"version\" is \"v:version\" in all scopes if scriptversion < 3.\n\t// Same for a few other variables marked with VV_COMPAT.\n\tif (in_old_script(3))\n\t{\n\t    hi = hash_find(&compat_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn &compat_hashtab;\n\t}\n\n\tht = get_funccal_local_ht();\n\tif (ht != NULL)\n\t    return ht;\t\t\t\t// local variable\n\n\t// In Vim9 script items at the script level are script-local, except\n\t// for autoload names.\n\tif (in_vim9script() && vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t{\n\t    ht = get_script_local_ht();\n\t    if (ht != NULL)\n\t\treturn ht;\n\t}\n\n\treturn &globvarht;\t\t\t// global variable\n    }\n    *varname = name + 2;\n    if (*name == 'g')\t\t\t\t// global variable\n\treturn &globvarht;\n    // There must be no ':' or '#' in the rest of the name, unless g: is used\n    if (vim_strchr(name + 2, ':') != NULL\n\t\t\t       || vim_strchr(name + 2, AUTOLOAD_CHAR) != NULL)\n\treturn NULL;\n    if (*name == 'b')\t\t\t\t// buffer variable\n\treturn &curbuf->b_vars->dv_hashtab;\n    if (*name == 'w')\t\t\t\t// window variable\n\treturn &curwin->w_vars->dv_hashtab;\n    if (*name == 't')\t\t\t\t// tab page variable\n\treturn &curtab->tp_vars->dv_hashtab;\n    if (*name == 'v')\t\t\t\t// v: variable\n\treturn &vimvarht;\n    if (get_current_funccal() != NULL\n\t       && get_current_funccal()->func->uf_def_status == UF_NOT_COMPILED)\n    {\n\t// a: and l: are only used in functions defined with \":function\"\n\tif (*name == 'a')\t\t\t// a: function argument\n\t    return get_funccal_args_ht();\n\tif (*name == 'l')\t\t\t// l: local function variable\n\t    return get_funccal_local_ht();\n    }\n    if (*name == 's')\t\t\t\t// script variable\n    {\n\tht = get_script_local_ht();\n\tif (ht != NULL)\n\t    return ht;\n    }\n    return NULL;\n}\n\n/*\n * Get the string value of a (global/local) variable.\n * Note: see tv_get_string() for how long the pointer remains valid.\n * Returns NULL when it doesn't exist.\n */\n    char_u *\nget_var_value(char_u *name)\n{\n    dictitem_T\t*v;\n\n    v = find_var(name, NULL, FALSE);\n    if (v == NULL)\n\treturn NULL;\n    return tv_get_string(&v->di_tv);\n}\n\n/*\n * Allocate a new hashtab for a sourced script.  It will be used while\n * sourcing this script and when executing functions defined in the script.\n */\n    void\nnew_script_vars(scid_T id)\n{\n    scriptvar_T *sv;\n\n    sv = ALLOC_CLEAR_ONE(scriptvar_T);\n    if (sv == NULL)\n\treturn;\n    init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);\n    SCRIPT_ITEM(id)->sn_vars = sv;\n}\n\n/*\n * Initialize dictionary \"dict\" as a scope and set variable \"dict_var\" to\n * point to it.\n */\n    void\ninit_var_dict(dict_T *dict, dictitem_T *dict_var, int scope)\n{\n    hash_init(&dict->dv_hashtab);\n    dict->dv_lock = 0;\n    dict->dv_scope = scope;\n    dict->dv_refcount = DO_NOT_FREE_CNT;\n    dict->dv_copyID = 0;\n    dict_var->di_tv.vval.v_dict = dict;\n    dict_var->di_tv.v_type = VAR_DICT;\n    dict_var->di_tv.v_lock = VAR_FIXED;\n    dict_var->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    dict_var->di_key[0] = NUL;\n}\n\n/*\n * Unreference a dictionary initialized by init_var_dict().\n */\n    void\nunref_var_dict(dict_T *dict)\n{\n    // Now the dict needs to be freed if no one else is using it, go back to\n    // normal reference counting.\n    dict->dv_refcount -= DO_NOT_FREE_CNT - 1;\n    dict_unref(dict);\n}\n\n/*\n * Clean up a list of internal variables.\n * Frees all allocated variables and the value they contain.\n * Clears hashtab \"ht\", does not free it.\n */\n    void\nvars_clear(hashtab_T *ht)\n{\n    vars_clear_ext(ht, TRUE);\n}\n\n/*\n * Like vars_clear(), but only free the value if \"free_val\" is TRUE.\n */\n    void\nvars_clear_ext(hashtab_T *ht, int free_val)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    dictitem_T\t*v;\n\n    hash_lock(ht);\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\n\t    // Free the variable.  Don't remove it from the hashtab,\n\t    // ht_array might change then.  hash_clear() takes care of it\n\t    // later.\n\t    v = HI2DI(hi);\n\t    if (free_val)\n\t\tclear_tv(&v->di_tv);\n\t    if (v->di_flags & DI_FLAGS_ALLOC)\n\t\tvim_free(v);\n\t}\n    }\n    hash_clear(ht);\n    hash_init(ht);\n}\n\n/*\n * Delete a variable from hashtab \"ht\" at item \"hi\".\n * Clear the variable value and free the dictitem.\n */\n    void\ndelete_var(hashtab_T *ht, hashitem_T *hi)\n{\n    dictitem_T\t*di = HI2DI(hi);\n\n    hash_remove(ht, hi);\n    clear_tv(&di->di_tv);\n    vim_free(di);\n}\n\n/*\n * List the value of one internal variable.\n */\n    static void\nlist_one_var(dictitem_T *v, char *prefix, int *first)\n{\n    char_u\t*tofree;\n    char_u\t*s;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    s = echo_string(&v->di_tv, &tofree, numbuf, get_copyID());\n    list_one_var_a(prefix, v->di_key, v->di_tv.v_type,\n\t\t\t\t\t s == NULL ? (char_u *)\"\" : s, first);\n    vim_free(tofree);\n}\n\n    static void\nlist_one_var_a(\n    char\t*prefix,\n    char_u\t*name,\n    int\t\ttype,\n    char_u\t*string,\n    int\t\t*first)  // when TRUE clear rest of screen and set to FALSE\n{\n    // don't use msg() or msg_attr() to avoid overwriting \"v:statusmsg\"\n    msg_start();\n    msg_puts(prefix);\n    if (name != NULL)\t// \"a:\" vars don't have a name stored\n\tmsg_puts((char *)name);\n    msg_putchar(' ');\n    msg_advance(22);\n    if (type == VAR_NUMBER)\n\tmsg_putchar('#');\n    else if (type == VAR_FUNC || type == VAR_PARTIAL)\n\tmsg_putchar('*');\n    else if (type == VAR_LIST)\n    {\n\tmsg_putchar('[');\n\tif (*string == '[')\n\t    ++string;\n    }\n    else if (type == VAR_DICT)\n    {\n\tmsg_putchar('{');\n\tif (*string == '{')\n\t    ++string;\n    }\n    else\n\tmsg_putchar(' ');\n\n    msg_outtrans(string);\n\n    if (type == VAR_FUNC || type == VAR_PARTIAL)\n\tmsg_puts(\"()\");\n    if (*first)\n    {\n\tmsg_clr_eos();\n\t*first = FALSE;\n    }\n}\n\n/*\n * Set variable \"name\" to value in \"tv\".\n * If the variable already exists, the value is updated.\n * Otherwise the variable is created.\n */\n    void\nset_var(\n    char_u\t*name,\n    typval_T\t*tv,\n    int\t\tcopy)\t    // make copy of value in \"tv\"\n{\n    set_var_const(name, 0, NULL, tv, copy, ASSIGN_DECL, 0);\n}\n\n/*\n * Set variable \"name\" to value in \"tv_arg\".\n * When \"sid\" is non-zero \"name\" is in the script with this ID.\n * If the variable already exists and \"is_const\" is FALSE the value is updated.\n * Otherwise the variable is created.\n */\n    void\nset_var_const(\n    char_u\t*name,\n    scid_T\tsid,\n    type_T\t*type_arg,\n    typval_T\t*tv_arg,\n    int\t\tcopy,\t    // make copy of value in \"tv\"\n    int\t\tflags_arg,  // ASSIGN_CONST, ASSIGN_FINAL, etc.\n    int\t\tvar_idx)    // index for \":let [a, b] = list\"\n{\n    typval_T\t*tv = tv_arg;\n    type_T\t*type = type_arg;\n    typval_T\tbool_tv;\n    dictitem_T\t*di;\n    typval_T\t*dest_tv = NULL;\n    char_u\t*varname;\n    char_u\t*name_tofree = NULL;\n    hashtab_T\t*ht = NULL;\n    int\t\tis_script_local;\n    int\t\tvim9script = in_vim9script();\n    int\t\tvar_in_vim9script;\n    int\t\tvar_in_autoload = FALSE;\n    int\t\tflags = flags_arg;\n    int\t\tfree_tv_arg = !copy;  // free tv_arg if not used\n\n    if (sid != 0)\n    {\n\tif (SCRIPT_ID_VALID(sid))\n\t    ht = &SCRIPT_VARS(sid);\n\tvarname = name;\n    }\n    else\n    {\n\tscriptitem_T *si;\n\n\tif (in_vim9script() && is_export\n\t\t&& SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t\t&& (si = SCRIPT_ITEM(current_sctx.sc_sid))\n\t\t\t\t\t\t   ->sn_autoload_prefix != NULL)\n\t{\n\t    // In a vim9 autoload script an exported variable is put in the\n\t    // global namespace with the autoload prefix.\n\t    var_in_autoload = TRUE;\n\t    varname = concat_str(si->sn_autoload_prefix, name);\n\t    if (varname == NULL)\n\t\tgoto failed;\n\t    name_tofree = varname;\n\t    ht = &globvarht;\n\t}\n\telse\n\t    ht = find_var_ht(name, &varname);\n    }\n    if (ht == NULL || *varname == NUL)\n    {\n\tsemsg(_(e_illegal_variable_name_str), name);\n\tgoto failed;\n    }\n    is_script_local = ht == get_script_local_ht() || sid != 0\n\t\t\t\t\t\t\t    || var_in_autoload;\n\n    if (vim9script\n\t    && !is_script_local\n\t    && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t    && (flags & (ASSIGN_CONST | ASSIGN_FINAL)) == 0\n\t    && name[1] == ':')\n    {\n\tvim9_declare_error(name);\n\tgoto failed;\n    }\n    if ((flags & ASSIGN_FOR_LOOP) && name[1] == ':'\n\t\t\t      && vim_strchr((char_u *)\"gwbt\", name[0]) != NULL)\n\t// Do not make g:var, w:var, b:var or t:var final.\n\tflags &= ~ASSIGN_FINAL;\n\n    var_in_vim9script = is_script_local && current_script_is_vim9();\n    if (var_in_vim9script && name[0] == '_' && name[1] == NUL)\n    {\n\t// For \"[a, _] = list\" the underscore is ignored.\n\tif ((flags & ASSIGN_UNPACK) == 0)\n\t    emsg(_(e_cannot_use_underscore_here));\n\tgoto failed;\n    }\n\n    di = find_var_in_ht(ht, 0, varname, TRUE);\n\n    if (di == NULL && var_in_vim9script)\n    {\n\timported_T  *import = find_imported(varname, 0, FALSE);\n\n\tif (import != NULL)\n\t{\n\t    // imported name space cannot be used\n\t    if ((flags & ASSIGN_NO_DECL) == 0)\n\t    {\n\t\tsemsg(_(e_redefining_imported_item_str), name);\n\t\tgoto failed;\n\t    }\n\t    semsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    goto failed;\n\t}\n\tif (!in_vim9script())\n\t{\n\t    semsg(_(e_cannot_create_vim9_script_variable_in_function_str),\n\t\t\t\t\t\t\t\t\t name);\n\t    goto failed;\n\t}\n    }\n\n    if (dest_tv == NULL)\n    {\n\t// Search in parent scope which is possible to reference from lambda\n\tif (di == NULL)\n\t    di = find_var_in_scoped_ht(name, TRUE);\n\n\tif ((tv->v_type == VAR_FUNC || tv->v_type == VAR_PARTIAL)\n\t\t\t\t      && var_wrong_func_name(name, di == NULL))\n\t    goto failed;\n\n\tif (need_convert_to_bool(type, tv))\n\t{\n\t    // Destination is a bool and the value is not, but it can be\n\t    // converted.\n\t    CLEAR_FIELD(bool_tv);\n\t    bool_tv.v_type = VAR_BOOL;\n\t    bool_tv.vval.v_number = tv2bool(tv) ? VVAL_TRUE : VVAL_FALSE;\n\t    tv = &bool_tv;\n\t}\n\n\tif (di != NULL)\n\t{\n\t    // Item already exists.  Allowed to replace when reloading.\n\t    if ((di->di_flags & DI_FLAGS_RELOAD) == 0)\n\t    {\n\t\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_modify_existing_variable));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (is_script_local && vim9script\n\t\t\t      && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0)\n\t\t{\n\t\t    semsg(_(e_redefining_script_item_str), name);\n\t\t    goto failed;\n\t\t}\n\n\t\tif (var_in_vim9script && (flags & ASSIGN_FOR_LOOP) == 0)\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\t\t    svar_T  *sv = find_typval_in_script(&di->di_tv, sid);\n\n\t\t    if (sv != NULL)\n\t\t    {\n\t\t\t// check the type and adjust to bool if needed\n\t\t\twhere.wt_index = var_idx;\n\t\t\twhere.wt_variable = TRUE;\n\t\t\tif (check_script_var_type(sv, tv, name, where) == FAIL)\n\t\t\t    goto failed;\n\t\t\tif (type == NULL)\n\t\t\t    type = sv->sv_type;\n\t\t    }\n\t\t}\n\n\t\tif ((flags & ASSIGN_FOR_LOOP) == 0\n\t\t\t\t     && var_check_permission(di, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// can only redefine once\n\t\tdi->di_flags &= ~DI_FLAGS_RELOAD;\n\n\t\t// A Vim9 script-local variable is also present in sn_all_vars\n\t\t// and sn_var_vals.  It may set \"type\" from \"tv\".\n\t\tif (var_in_vim9script || var_in_autoload)\n\t\t    update_vim9_script_var(FALSE, di,\n\t\t\t    var_in_autoload ? name : di->di_key, flags,\n\t\t\t    tv, &type, (flags & ASSIGN_NO_MEMBER_TYPE) == 0);\n\t    }\n\n\t    // existing variable, need to clear the value\n\n\t    // Handle setting internal di: variables separately where needed to\n\t    // prevent changing the type.\n\t    if (ht == &vimvarht)\n\t    {\n\t\tif (di->di_tv.v_type == VAR_STRING)\n\t\t{\n\t\t    VIM_CLEAR(di->di_tv.vval.v_string);\n\t\t    if (copy || tv->v_type != VAR_STRING)\n\t\t    {\n\t\t\tchar_u *val = tv_get_string(tv);\n\n\t\t\t// Careful: when assigning to v:errmsg and\n\t\t\t// tv_get_string() causes an error message the variable\n\t\t\t// will already be set.\n\t\t\tif (di->di_tv.vval.v_string == NULL)\n\t\t\t    di->di_tv.vval.v_string = vim_strsave(val);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Take over the string to avoid an extra alloc/free.\n\t\t\tdi->di_tv.vval.v_string = tv->vval.v_string;\n\t\t\ttv->vval.v_string = NULL;\n\t\t    }\n\t\t    goto failed;\n\t\t}\n\t\telse if (di->di_tv.v_type == VAR_NUMBER)\n\t\t{\n\t\t    di->di_tv.vval.v_number = tv_get_number(tv);\n\t\t    if (STRCMP(varname, \"searchforward\") == 0)\n\t\t\tset_search_direction(di->di_tv.vval.v_number\n\t\t\t\t\t\t\t\t  ? '/' : '?');\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    else if (STRCMP(varname, \"hlsearch\") == 0)\n\t\t    {\n\t\t\tno_hlsearch = !di->di_tv.vval.v_number;\n\t\t\tredraw_all_later(SOME_VALID);\n\t\t    }\n#endif\n\t\t    goto failed;\n\t\t}\n\t\telse if (di->di_tv.v_type != tv->v_type)\n\t\t{\n\t\t    semsg(_(e_setting_str_to_value_with_wrong_type), name);\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    clear_tv(&di->di_tv);\n\t}\n\telse\n\t{\n\t    // Item not found, check if a function already exists.\n\t    if (is_script_local && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t\t   && lookup_scriptitem(name, STRLEN(name), FALSE, NULL) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // add a new variable\n\t    if (var_in_vim9script && (flags & ASSIGN_NO_DECL))\n\t    {\n\t\tsemsg(_(e_unknown_variable_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // Can't add \"v:\" or \"a:\" variable.\n\t    if (ht == &vimvarht || ht == get_funccal_args_ht())\n\t    {\n\t\tsemsg(_(e_illegal_variable_name_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // Make sure the variable name is valid.  In Vim9 script an\n\t    // autoload variable must be prefixed with \"g:\" unless in an\n\t    // autoload script.\n\t    if (!valid_varname(varname, -1, !vim9script\n\t\t\t    || STRNCMP(name, \"g:\", 2) == 0 || var_in_autoload))\n\t\tgoto failed;\n\n\t    di = alloc(sizeof(dictitem_T) + STRLEN(varname));\n\t    if (di == NULL)\n\t\tgoto failed;\n\t    STRCPY(di->di_key, varname);\n\t    if (hash_add(ht, DI2HIKEY(di)) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\tgoto failed;\n\t    }\n\t    di->di_flags = DI_FLAGS_ALLOC;\n\t    if (flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\tdi->di_flags |= DI_FLAGS_LOCK;\n\n\t    // A Vim9 script-local variable is also added to sn_all_vars and\n\t    // sn_var_vals. It may set \"type\" from \"tv\".\n\t    if (var_in_vim9script || var_in_autoload)\n\t\tupdate_vim9_script_var(TRUE, di,\n\t\t\tvar_in_autoload ? name : di->di_key, flags,\n\t\t\t      tv, &type, (flags & ASSIGN_NO_MEMBER_TYPE) == 0);\n\t}\n\n\tdest_tv = &di->di_tv;\n    }\n\n    if (copy || tv->v_type == VAR_NUMBER || tv->v_type == VAR_FLOAT)\n\tcopy_tv(tv, dest_tv);\n    else\n    {\n\t*dest_tv = *tv;\n\tdest_tv->v_lock = 0;\n\tinit_tv(tv);\n    }\n    free_tv_arg = FALSE;\n\n    if (vim9script && type != NULL)\n\tset_tv_type(dest_tv, type);\n\n    // \":const var = value\" locks the value\n    // \":final var = value\" locks \"var\"\n    if (flags & ASSIGN_CONST)\n\t// Like :lockvar! name: lock the value and what it contains, but only\n\t// if the reference count is up to one.  That locks only literal\n\t// values.\n\titem_lock(dest_tv, DICT_MAXNEST, TRUE, TRUE);\n\nfailed:\n    vim_free(name_tofree);\n    if (free_tv_arg)\n\tclear_tv(tv_arg);\n}\n\n/*\n * Check in this order for backwards compatibility:\n * - Whether the variable is read-only\n * - Whether the variable value is locked\n * - Whether the variable is locked\n */\n    int\nvar_check_permission(dictitem_T *di, char_u *name)\n{\n    if (var_check_ro(di->di_flags, name, FALSE)\n\t\t    || value_check_lock(di->di_tv.v_lock, name, FALSE)\n\t\t    || var_check_lock(di->di_flags, name, FALSE))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is read-only.\n * Also give an error message.\n */\n    int\nvar_check_ro(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_RO)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_readonly_variable));\n\telse\n\t    semsg(_(e_cannot_change_readonly_variable_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if ((flags & DI_FLAGS_RO_SBX) && sandbox)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_set_variable_in_sandbox));\n\telse\n\t    semsg(_(e_cannot_set_variable_in_sandbox_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is locked.\n * Also give an error message.\n */\n    int\nvar_check_lock(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_LOCK)\n    {\n\tsemsg(_(e_variable_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is fixed.\n * Also give an error message.\n */\n    int\nvar_check_fixed(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_FIX)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_delete_variable));\n\telse\n\t    semsg(_(e_cannot_delete_variable_str),\n\t\t\t\t      use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if a funcref is assigned to a valid variable name.\n * Return TRUE and give an error if not.\n */\n    int\nvar_wrong_func_name(\n    char_u *name,    // points to start of variable name\n    int    new_var)  // TRUE when creating the variable\n{\n    // Allow for w: b: s: and t:.  In Vim9 script s: is not allowed, because\n    // the name can be used without the s: prefix.\n    if (!((vim_strchr((char_u *)\"wbt\", name[0]) != NULL\n\t\t    || (!in_vim9script() && name[0] == 's')) && name[1] == ':')\n\t    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')\n\t\t\t\t\t\t     ? name[2] : name[0]))\n    {\n\tsemsg(_(e_funcref_variable_name_must_start_with_capital_str), name);\n\treturn TRUE;\n    }\n    // Don't allow hiding a function.  When \"v\" is not NULL we might be\n    // assigning another function to the same var, the type is checked\n    // below.\n    if (new_var && function_exists(name, FALSE))\n    {\n\tsemsg(_(e_variable_name_conflicts_with_existing_function_str),\n\t\t\t\t\t\t\t\t    name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" indicates variable \"name\" has a locked (immutable)\n * value.  Also give an error message, using \"name\" or _(\"name\") when\n * \"use_gettext\" is TRUE.\n */\n    int\nvalue_check_lock(int lock, char_u *name, int use_gettext)\n{\n    if (lock & VAR_LOCKED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_value_is_locked));\n\telse\n\t    semsg(_(e_value_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if (lock & VAR_FIXED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_value));\n\telse\n\t    semsg(_(e_cannot_change_value_of_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if a variable name is valid.  When \"autoload\" is true \"#\" is allowed.\n * If \"len\" is -1 use all of \"varname\", otherwise up to \"varname[len]\".\n * Return FALSE and give an error if not.\n */\n    int\nvalid_varname(char_u *varname, int len, int autoload)\n{\n    char_u *p;\n\n    for (p = varname; len < 0 ? *p != NUL : p < varname + len; ++p)\n\tif (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))\n\t\t\t\t\t && !(autoload && *p == AUTOLOAD_CHAR))\n\t{\n\t    semsg(_(e_illegal_variable_name_str), varname);\n\t    return FALSE;\n\t}\n    return TRUE;\n}\n\n/*\n * getwinvar() and gettabwinvar()\n */\n    static void\ngetwinvar(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\toff)\t    // 1 for gettabwinvar()\n{\n    win_T\t*win;\n    char_u\t*varname;\n    dictitem_T\t*v;\n    tabpage_T\t*tp = NULL;\n    int\t\tdone = FALSE;\n    switchwin_T\tswitchwin;\n    int\t\tneed_switch_win;\n\n    if (off == 1)\n\ttp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    else\n\ttp = curtab;\n    win = find_win_by_nr(&argvars[off], tp);\n    varname = tv_get_string_chk(&argvars[off + 1]);\n    ++emsg_off;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (win != NULL && varname != NULL)\n    {\n\t// Set curwin to be our win, temporarily.  Also set the tabpage,\n\t// otherwise the window is not valid. Only do this when needed,\n\t// autocommands get blocked.\n\tneed_switch_win = !(tp == curtab && win == curwin);\n\tif (!need_switch_win\n\t\t  || switch_win(&switchwin, win, tp, TRUE) == OK)\n\t{\n\t    if (*varname == '&')\n\t    {\n\t\tif (varname[1] == NUL)\n\t\t{\n\t\t    // get all window-local options in a dict\n\t\t    dict_T\t*opts = get_winbuf_options(FALSE);\n\n\t\t    if (opts != NULL)\n\t\t    {\n\t\t\trettv_dict_set(rettv, opts);\n\t\t\tdone = TRUE;\n\t\t    }\n\t\t}\n\t\telse if (eval_option(&varname, rettv, 1) == OK)\n\t\t    // window-local-option\n\t\t    done = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Look up the variable.\n\t\t// Let getwinvar({nr}, \"\") return the \"w:\" dictionary.\n\t\tv = find_var_in_ht(&win->w_vars->dv_hashtab, 'w',\n\t\t\t\t\t\t\t      varname, FALSE);\n\t\tif (v != NULL)\n\t\t{\n\t\t    copy_tv(&v->di_tv, rettv);\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t}\n\n\tif (need_switch_win)\n\t    // restore previous notion of curwin\n\t    restore_win(&switchwin, TRUE);\n    }\n\n    if (!done && argvars[off + 2].v_type != VAR_UNKNOWN)\n\t// use the default return value\n\tcopy_tv(&argvars[off + 2], rettv);\n\n    --emsg_off;\n}\n\n/*\n * Set option \"varname\" to the value of \"varp\" for the current buffer/window.\n */\n    static void\nset_option_from_tv(char_u *varname, typval_T *varp)\n{\n    long\tnumval = 0;\n    char_u\t*strval;\n    char_u\tnbuf[NUMBUFLEN];\n    int\t\terror = FALSE;\n\n    if (varp->v_type == VAR_BOOL)\n    {\n\tnumval = (long)varp->vval.v_number;\n\tstrval = (char_u *)\"0\";  // avoid using \"false\"\n    }\n    else\n    {\n\tif (!in_vim9script() || varp->v_type != VAR_STRING)\n\t    numval = (long)tv_get_number_chk(varp, &error);\n\tstrval = tv_get_string_buf_chk(varp, nbuf);\n    }\n    if (!error && strval != NULL)\n\tset_option_value(varname, numval, strval, OPT_LOCAL);\n}\n\n/*\n * \"setwinvar()\" and \"settabwinvar()\" functions\n */\n    static void\nsetwinvar(typval_T *argvars, int off)\n{\n    win_T\t*win;\n    switchwin_T\tswitchwin;\n    int\t\tneed_switch_win;\n    char_u\t*varname, *winvarname;\n    typval_T\t*varp;\n    tabpage_T\t*tp = NULL;\n\n    if (check_secure())\n\treturn;\n\n    if (off == 1)\n\ttp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    else\n\ttp = curtab;\n    win = find_win_by_nr(&argvars[off], tp);\n    varname = tv_get_string_chk(&argvars[off + 1]);\n    varp = &argvars[off + 2];\n\n    if (win != NULL && varname != NULL && varp != NULL)\n    {\n\tneed_switch_win = !(tp == curtab && win == curwin);\n\tif (!need_switch_win\n\t       || switch_win(&switchwin, win, tp, TRUE) == OK)\n\t{\n\t    if (*varname == '&')\n\t\tset_option_from_tv(varname + 1, varp);\n\t    else\n\t    {\n\t\twinvarname = alloc(STRLEN(varname) + 3);\n\t\tif (winvarname != NULL)\n\t\t{\n\t\t    STRCPY(winvarname, \"w:\");\n\t\t    STRCPY(winvarname + 2, varname);\n\t\t    set_var(winvarname, varp, TRUE);\n\t\t    vim_free(winvarname);\n\t\t}\n\t    }\n\t}\n\tif (need_switch_win)\n\t    restore_win(&switchwin, TRUE);\n    }\n}\n\n/*\n * reset v:option_new, v:option_old, v:option_oldlocal, v:option_oldglobal,\n * v:option_type, and v:option_command.\n */\n    void\nreset_v_option_vars(void)\n{\n    set_vim_var_string(VV_OPTION_NEW,  NULL, -1);\n    set_vim_var_string(VV_OPTION_OLD,  NULL, -1);\n    set_vim_var_string(VV_OPTION_OLDLOCAL, NULL, -1);\n    set_vim_var_string(VV_OPTION_OLDGLOBAL, NULL, -1);\n    set_vim_var_string(VV_OPTION_TYPE, NULL, -1);\n    set_vim_var_string(VV_OPTION_COMMAND, NULL, -1);\n}\n\n/*\n * Add an assert error to v:errors.\n */\n    void\nassert_error(garray_T *gap)\n{\n    struct vimvar   *vp = &vimvars[VV_ERRORS];\n\n    if (vp->vv_tv_type != VAR_LIST || vimvars[VV_ERRORS].vv_list == NULL)\n\t// Make sure v:errors is a list.\n\tset_vim_var_list(VV_ERRORS, list_alloc());\n    list_append_string(vimvars[VV_ERRORS].vv_list, gap->ga_data, gap->ga_len);\n}\n\n    int\nvar_exists(char_u *var)\n{\n    char_u\t*arg = var;\n    char_u\t*name;\n    char_u\t*tofree;\n    typval_T    tv;\n    int\t\tlen = 0;\n    int\t\tn = FALSE;\n\n    // get_name_len() takes care of expanding curly braces\n    name = var;\n    len = get_name_len(&arg, &tofree, TRUE, FALSE);\n    if (len > 0)\n    {\n\tif (tofree != NULL)\n\t    name = tofree;\n\tn = (eval_variable(name, len, 0, &tv, NULL,\n\t\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT) == OK);\n\tif (n)\n\t{\n\t    // handle d.key, l[idx], f(expr)\n\t    arg = skipwhite(arg);\n\t    n = (handle_subscript(&arg, name, &tv, &EVALARG_EVALUATE,\n\t\t\t\t\t\t\t\t FALSE) == OK);\n\t    if (n)\n\t\tclear_tv(&tv);\n\t}\n    }\n    if (*arg != NUL)\n\tn = FALSE;\n\n    vim_free(tofree);\n    return n;\n}\n\nstatic lval_T\t*redir_lval = NULL;\n#define EVALCMD_BUSY (redir_lval == (lval_T *)&redir_lval)\nstatic garray_T redir_ga;\t// only valid when redir_lval is not NULL\nstatic char_u\t*redir_endp = NULL;\nstatic char_u\t*redir_varname = NULL;\n\n    int\nalloc_redir_lval(void)\n{\n    redir_lval = ALLOC_CLEAR_ONE(lval_T);\n    if (redir_lval == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n    void\nclear_redir_lval(void)\n{\n    VIM_CLEAR(redir_lval);\n}\n\n    void\ninit_redir_ga(void)\n{\n    ga_init2(&redir_ga, sizeof(char), 500);\n}\n\n/*\n * Start recording command output to a variable\n * When \"append\" is TRUE append to an existing variable.\n * Returns OK if successfully completed the setup.  FAIL otherwise.\n */\n    int\nvar_redir_start(char_u *name, int append)\n{\n    int\t\tcalled_emsg_before;\n    typval_T\ttv;\n\n    // Catch a bad name early.\n    if (!eval_isnamec1(*name))\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    // Make a copy of the name, it is used in redir_lval until redir ends.\n    redir_varname = vim_strsave(name);\n    if (redir_varname == NULL)\n\treturn FAIL;\n\n    if (alloc_redir_lval() == FAIL)\n    {\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    // The output is stored in growarray \"redir_ga\" until redirection ends.\n    init_redir_ga();\n\n    // Parse the variable name (can be a dict or list entry).\n    redir_endp = get_lval(redir_varname, NULL, redir_lval, FALSE, FALSE, 0,\n\t\t\t\t\t\t\t     FNE_CHECK_START);\n    if (redir_endp == NULL || redir_lval->ll_name == NULL || *redir_endp != NUL)\n    {\n\tclear_lval(redir_lval);\n\tif (redir_endp != NULL && *redir_endp != NUL)\n\t    // Trailing characters are present after the variable name\n\t    semsg(_(e_trailing_characters_str), redir_endp);\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n\tredir_endp = NULL;  // don't store a value, only cleanup\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    // check if we can write to the variable: set it to or append an empty\n    // string\n    called_emsg_before = called_emsg;\n    tv.v_type = VAR_STRING;\n    tv.vval.v_string = (char_u *)\"\";\n    if (append)\n\tset_var_lval(redir_lval, redir_endp, &tv, TRUE,\n\t\t\t\t\t     ASSIGN_NO_DECL, (char_u *)\".\", 0);\n    else\n\tset_var_lval(redir_lval, redir_endp, &tv, TRUE,\n\t\t\t\t\t     ASSIGN_NO_DECL, (char_u *)\"=\", 0);\n    clear_lval(redir_lval);\n    if (called_emsg > called_emsg_before)\n    {\n\tredir_endp = NULL;  // don't store a value, only cleanup\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Append \"value[value_len]\" to the variable set by var_redir_start().\n * The actual appending is postponed until redirection ends, because the value\n * appended may in fact be the string we write to, changing it may cause freed\n * memory to be used:\n *   :redir => foo\n *   :let foo\n *   :redir END\n */\n    void\nvar_redir_str(char_u *value, int value_len)\n{\n    int\t\tlen;\n\n    if (redir_lval == NULL)\n\treturn;\n\n    if (value_len == -1)\n\tlen = (int)STRLEN(value);\t// Append the entire string\n    else\n\tlen = value_len;\t\t// Append only \"value_len\" characters\n\n    if (ga_grow(&redir_ga, len) == OK)\n    {\n\tmch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);\n\tredir_ga.ga_len += len;\n    }\n    else\n\tvar_redir_stop();\n}\n\n/*\n * Stop redirecting command output to a variable.\n * Frees the allocated memory.\n */\n    void\nvar_redir_stop(void)\n{\n    typval_T\ttv;\n\n    if (EVALCMD_BUSY)\n    {\n\tredir_lval = NULL;\n\treturn;\n    }\n\n    if (redir_lval != NULL)\n    {\n\t// If there was no error: assign the text to the variable.\n\tif (redir_endp != NULL)\n\t{\n\t    ga_append(&redir_ga, NUL);  // Append the trailing NUL.\n\t    tv.v_type = VAR_STRING;\n\t    tv.vval.v_string = redir_ga.ga_data;\n\t    // Call get_lval() again, if it's inside a Dict or List it may\n\t    // have changed.\n\t    redir_endp = get_lval(redir_varname, NULL, redir_lval,\n\t\t\t\t\tFALSE, FALSE, 0, FNE_CHECK_START);\n\t    if (redir_endp != NULL && redir_lval->ll_name != NULL)\n\t\tset_var_lval(redir_lval, redir_endp, &tv, FALSE, 0,\n\t\t\t\t\t\t\t     (char_u *)\".\", 0);\n\t    clear_lval(redir_lval);\n\t}\n\n\t// free the collected output\n\tVIM_CLEAR(redir_ga.ga_data);\n\n\tVIM_CLEAR(redir_lval);\n    }\n    VIM_CLEAR(redir_varname);\n}\n\n/*\n * Get the collected redirected text and clear redir_ga.\n */\n    char_u *\nget_clear_redir_ga(void)\n{\n    char_u *res;\n\n    ga_append(&redir_ga, NUL);  // Append the trailing NUL.\n    res = redir_ga.ga_data;\n    redir_ga.ga_data = NULL;\n    return res;\n}\n\n/*\n * \"gettabvar()\" function\n */\n    void\nf_gettabvar(typval_T *argvars, typval_T *rettv)\n{\n    switchwin_T\tswitchwin;\n    tabpage_T\t*tp;\n    dictitem_T\t*v;\n    char_u\t*varname;\n    int\t\tdone = FALSE;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    if (tp != NULL && varname != NULL)\n    {\n\t// Set tp to be our tabpage, temporarily.  Also set the window to the\n\t// first window in the tabpage, otherwise the window is not valid.\n\tif (switch_win(&switchwin,\n\t\ttp == curtab || tp->tp_firstwin == NULL ? firstwin\n\t\t\t\t\t    : tp->tp_firstwin, tp, TRUE) == OK)\n\t{\n\t    // look up the variable\n\t    // Let gettabvar({nr}, \"\") return the \"t:\" dictionary.\n\t    v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't', varname, FALSE);\n\t    if (v != NULL)\n\t    {\n\t\tcopy_tv(&v->di_tv, rettv);\n\t\tdone = TRUE;\n\t    }\n\t}\n\n\t// restore previous notion of curwin\n\trestore_win(&switchwin, TRUE);\n    }\n\n    if (!done && argvars[2].v_type != VAR_UNKNOWN)\n\tcopy_tv(&argvars[2], rettv);\n}\n\n/*\n * \"gettabwinvar()\" function\n */\n    void\nf_gettabwinvar(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    getwinvar(argvars, rettv, 1);\n}\n\n/*\n * \"getwinvar()\" function\n */\n    void\nf_getwinvar(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    getwinvar(argvars, rettv, 0);\n}\n\n/*\n * \"getbufvar()\" function\n */\n    void\nf_getbufvar(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf;\n    char_u\t*varname;\n    dictitem_T\t*v;\n    int\t\tdone = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_buffer_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf_from_arg(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (buf != NULL && varname != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    // set curbuf to be our buf, temporarily\n\t    curbuf = buf;\n\n\t    if (varname[1] == NUL)\n\t    {\n\t\t// get all buffer-local options in a dict\n\t\tdict_T\t*opts = get_winbuf_options(TRUE);\n\n\t\tif (opts != NULL)\n\t\t{\n\t\t    rettv_dict_set(rettv, opts);\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t    else if (eval_option(&varname, rettv, TRUE) == OK)\n\t\t// buffer-local-option\n\t\tdone = TRUE;\n\n\t    // restore previous notion of curbuf\n\t    curbuf = save_curbuf;\n\t}\n\telse\n\t{\n\t    // Look up the variable.\n\t    if (*varname == NUL)\n\t\t// Let getbufvar({nr}, \"\") return the \"b:\" dictionary.\n\t\tv = &buf->b_bufvar;\n\t    else\n\t\tv = find_var_in_ht(&buf->b_vars->dv_hashtab, 'b',\n\t\t\t\t\t\t\t       varname, FALSE);\n\t    if (v != NULL)\n\t    {\n\t\tcopy_tv(&v->di_tv, rettv);\n\t\tdone = TRUE;\n\t    }\n\t}\n    }\n\n    if (!done && argvars[2].v_type != VAR_UNKNOWN)\n\t// use the default value\n\tcopy_tv(&argvars[2], rettv);\n}\n\n/*\n * \"settabvar()\" function\n */\n    void\nf_settabvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc(STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t// Restore current tabpage\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}\n\n/*\n * \"settabwinvar()\" function\n */\n    void\nf_settabwinvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    setwinvar(argvars, 1);\n}\n\n/*\n * \"setwinvar()\" function\n */\n    void\nf_setwinvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    setwinvar(argvars, 0);\n}\n\n/*\n * \"setbufvar()\" function\n */\n    void\nf_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf;\n    char_u\t*varname, *bufvarname;\n    typval_T\t*varp;\n\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_buffer_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf_from_arg(&argvars[0]);\n    varp = &argvars[2];\n\n    if (buf != NULL && varname != NULL && varp != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    aco_save_T\taco;\n\n\t    // set curbuf to be our buf, temporarily\n\t    aucmd_prepbuf(&aco, buf);\n\n\t    set_option_from_tv(varname + 1, varp);\n\n\t    // reset notion of buffer\n\t    aucmd_restbuf(&aco);\n\t}\n\telse\n\t{\n\t    bufvarname = alloc(STRLEN(varname) + 3);\n\t    if (bufvarname != NULL)\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\tcurbuf = buf;\n\t\tSTRCPY(bufvarname, \"b:\");\n\t\tSTRCPY(bufvarname + 2, varname);\n\t\tset_var(bufvarname, varp, TRUE);\n\t\tvim_free(bufvarname);\n\t\tcurbuf = save_curbuf;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a callback from \"arg\".  It can be a Funcref or a function name.\n * When \"arg\" is zero return an empty string.\n * \"cb_name\" is not allocated.\n * \"cb_name\" is set to NULL for an invalid argument.\n */\n    callback_T\nget_callback(typval_T *arg)\n{\n    callback_T  res;\n    int\t\tr = OK;\n\n    res.cb_free_name = FALSE;\n    if (arg->v_type == VAR_PARTIAL && arg->vval.v_partial != NULL)\n    {\n\tres.cb_partial = arg->vval.v_partial;\n\t++res.cb_partial->pt_refcount;\n\tres.cb_name = partial_name(res.cb_partial);\n    }\n    else\n    {\n\tres.cb_partial = NULL;\n\tif (arg->v_type == VAR_STRING && arg->vval.v_string != NULL\n\t\t\t\t\t       && isdigit(*arg->vval.v_string))\n\t    r = FAIL;\n\telse if (arg->v_type == VAR_FUNC || arg->v_type == VAR_STRING)\n\t{\n\t    if (arg->v_type == VAR_STRING)\n\t    {\n\t\tchar_u *name;\n\n\t\tname = get_scriptlocal_funcname(arg->vval.v_string);\n\t\tif (name != NULL)\n\t\t{\n\t\t    vim_free(arg->vval.v_string);\n\t\t    arg->vval.v_string = name;\n\t\t}\n\t    }\n\n\t    res.cb_name = arg->vval.v_string;\n\t    func_ref(res.cb_name);\n\t}\n\telse if (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)\n\t    res.cb_name = (char_u *)\"\";\n\telse\n\t    r = FAIL;\n\n\tif (r == FAIL)\n\t{\n\t    emsg(_(e_invalid_callback_argument));\n\t    res.cb_name = NULL;\n\t}\n    }\n    return res;\n}\n\n/*\n * Copy a callback into a typval_T.\n */\n    void\nput_callback(callback_T *cb, typval_T *tv)\n{\n    if (cb->cb_partial != NULL)\n    {\n\ttv->v_type = VAR_PARTIAL;\n\ttv->vval.v_partial = cb->cb_partial;\n\t++tv->vval.v_partial->pt_refcount;\n    }\n    else\n    {\n\ttv->v_type = VAR_FUNC;\n\ttv->vval.v_string = vim_strsave(cb->cb_name);\n\tfunc_ref(cb->cb_name);\n    }\n}\n\n/*\n * Make a copy of \"src\" into \"dest\", allocating the function name if needed,\n * without incrementing the refcount.\n */\n    void\nset_callback(callback_T *dest, callback_T *src)\n{\n    if (src->cb_partial == NULL)\n    {\n\t// just a function name, make a copy\n\tdest->cb_name = vim_strsave(src->cb_name);\n\tdest->cb_free_name = TRUE;\n    }\n    else\n    {\n\t// cb_name is a pointer into cb_partial\n\tdest->cb_name = src->cb_name;\n\tdest->cb_free_name = FALSE;\n    }\n    dest->cb_partial = src->cb_partial;\n}\n\n/*\n * Copy callback from \"src\" to \"dest\", incrementing the refcounts.\n */\n    void\ncopy_callback(callback_T *dest, callback_T *src)\n{\n    dest->cb_partial = src->cb_partial;\n    if (dest->cb_partial != NULL)\n    {\n\tdest->cb_name = src->cb_name;\n\tdest->cb_free_name = FALSE;\n\t++dest->cb_partial->pt_refcount;\n    }\n    else\n    {\n\tdest->cb_name = vim_strsave(src->cb_name);\n\tdest->cb_free_name = TRUE;\n\tfunc_ref(src->cb_name);\n    }\n}\n\n/*\n * When a callback refers to an autoload import, change the function name to\n * the \"path#name\" form.  Uses the current script context.\n * Only works when the name is allocated.\n */\n    void\nexpand_autload_callback(callback_T *cb)\n{\n    char_u\t*name;\n    char_u\t*p;\n    imported_T\t*import;\n\n    if (!in_vim9script() || cb->cb_name == NULL\n\t    || (!cb->cb_free_name\n\t       && (cb->cb_partial == NULL || cb->cb_partial->pt_name == NULL)))\n\treturn;\n    if (cb->cb_partial != NULL)\n\tname = cb->cb_partial->pt_name;\n    else\n\tname = cb->cb_name;\n    p = vim_strchr(name, '.');\n    if (p == NULL)\n\treturn;\n    import = find_imported(name, p - name, FALSE);\n    if (import != NULL && SCRIPT_ID_VALID(import->imp_sid))\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(import->imp_sid);\n\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    char_u *newname = concat_str(si->sn_autoload_prefix, p + 1);\n\n\t    if (newname != NULL)\n\t    {\n\t\tif (cb->cb_partial != NULL)\n\t\t{\n\t\t    if (cb->cb_name == cb->cb_partial->pt_name)\n\t\t\tcb->cb_name = newname;\n\t\t    vim_free(cb->cb_partial->pt_name);\n\t\t    cb->cb_partial->pt_name = newname;\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_free(cb->cb_name);\n\t\t    cb->cb_name = newname;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Unref/free \"callback\" returned by get_callback() or set_callback().\n */\n    void\nfree_callback(callback_T *callback)\n{\n    if (callback->cb_partial != NULL)\n    {\n\tpartial_unref(callback->cb_partial);\n\tcallback->cb_partial = NULL;\n    }\n    else if (callback->cb_name != NULL)\n\tfunc_unref(callback->cb_name);\n    if (callback->cb_free_name)\n    {\n\tvim_free(callback->cb_name);\n\tcallback->cb_free_name = FALSE;\n    }\n    callback->cb_name = NULL;\n}\n\n#endif // FEAT_EVAL\n", "/* window.c */\nvoid do_window(int nchar, long Prenum, int xchar);\nvoid get_wincmd_addr_type(char_u *arg, exarg_T *eap);\nint win_split(int size, int flags);\nint win_split_ins(int size, int flags, win_T *new_wp, int dir);\nint win_valid_popup(win_T *win);\nint win_valid(win_T *win);\nwin_T *win_find_by_id(int id);\nint win_valid_any_tab(win_T *win);\nint win_count(void);\nint make_windows(int count, int vertical);\nvoid win_move_after(win_T *win1, win_T *win2);\nvoid win_equal(win_T *next_curwin, int current, int dir);\nvoid entering_window(win_T *win);\nvoid close_windows(buf_T *buf, int keep_curwin);\nint one_window(void);\nint win_close(win_T *win, int free_buf);\nvoid win_close_othertab(win_T *win, int free_buf, tabpage_T *tp);\nvoid win_free_all(void);\nwin_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp);\nvoid close_others(int message, int forceit);\nvoid curwin_init(void);\nint win_alloc_first(void);\nwin_T *win_alloc_popup_win(void);\nvoid win_init_popup_win(win_T *wp, buf_T *buf);\nvoid win_init_size(void);\nvoid free_tabpage(tabpage_T *tp);\nint win_new_tabpage(int after);\nint make_tabpages(int maxcount);\nint valid_tabpage(tabpage_T *tpc);\nint valid_tabpage_win(tabpage_T *tpc);\nvoid close_tabpage(tabpage_T *tab);\ntabpage_T *find_tabpage(int n);\nint tabpage_index(tabpage_T *ftp);\nvoid goto_tabpage(int n);\nvoid goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds);\nint goto_tabpage_lastused(void);\nvoid goto_tabpage_win(tabpage_T *tp, win_T *wp);\nvoid tabpage_move(int nr);\nvoid win_goto(win_T *wp);\nwin_T *win_find_nr(int winnr);\ntabpage_T *win_find_tabpage(win_T *win);\nwin_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count);\nwin_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count);\nvoid win_enter(win_T *wp, int undo_sync);\nwin_T *buf_jump_open_win(buf_T *buf);\nwin_T *buf_jump_open_tab(buf_T *buf);\nvoid win_free_popup(win_T *win);\nvoid win_remove(win_T *wp, tabpage_T *tp);\nint win_alloc_lines(win_T *wp);\nvoid win_free_lsize(win_T *wp);\nvoid shell_new_rows(void);\nvoid shell_new_columns(void);\nvoid win_size_save(garray_T *gap);\nvoid win_size_restore(garray_T *gap);\nint win_comp_pos(void);\nvoid win_ensure_size(void);\nvoid win_setheight(int height);\nvoid win_setheight_win(int height, win_T *win);\nvoid win_setwidth(int width);\nvoid win_setwidth_win(int width, win_T *wp);\nvoid win_setminheight(void);\nvoid win_setminwidth(void);\nvoid win_drag_status_line(win_T *dragwin, int offset);\nvoid win_drag_vsep_line(win_T *dragwin, int offset);\nvoid set_fraction(win_T *wp);\nvoid win_new_height(win_T *wp, int height);\nvoid scroll_to_fraction(win_T *wp, int prev_height);\nvoid win_new_width(win_T *wp, int width);\nvoid win_comp_scroll(win_T *wp);\nvoid command_height(void);\nvoid last_status(int morewin);\nint tabline_height(void);\nint min_rows(void);\nint only_one_window(void);\nvoid check_lnums(int do_curwin);\nvoid reset_lnums(void);\nvoid make_snapshot(int idx);\nvoid restore_snapshot(int idx, int close_curwin);\nint win_hasvertsplit(void);\nint get_win_number(win_T *wp, win_T *first_win);\nint get_tab_number(tabpage_T *tp);\nchar *check_colorcolumn(win_T *wp);\n/* vim: set ft=c : */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * usercmd.c: User defined command support\n */\n\n#include \"vim.h\"\n\ntypedef struct ucmd\n{\n    char_u\t*uc_name;\t// The command name\n    long_u\tuc_argt;\t// The argument type\n    char_u\t*uc_rep;\t// The command's replacement string\n    long\tuc_def;\t\t// The default value for a range/count\n    int\t\tuc_compl;\t// completion type\n    cmd_addr_T\tuc_addr_type;\t// The command's address type\n    sctx_T\tuc_script_ctx;\t// SCTX where the command was defined\n# ifdef FEAT_EVAL\n    char_u\t*uc_compl_arg;\t// completion argument if any\n# endif\n} ucmd_T;\n\n// List of all user commands.\nstatic garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};\n\n#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])\n#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])\n\n/*\n * List of names for completion for \":command\" with the EXPAND_ flag.\n * Must be alphabetical for completion.\n */\nstatic struct\n{\n    int\t    expand;\n    char    *name;\n} command_complete[] =\n{\n    {EXPAND_ARGLIST, \"arglist\"},\n    {EXPAND_AUGROUP, \"augroup\"},\n    {EXPAND_BEHAVE, \"behave\"},\n    {EXPAND_BUFFERS, \"buffer\"},\n    {EXPAND_COLORS, \"color\"},\n    {EXPAND_COMMANDS, \"command\"},\n    {EXPAND_COMPILER, \"compiler\"},\n#if defined(FEAT_CSCOPE)\n    {EXPAND_CSCOPE, \"cscope\"},\n#endif\n#if defined(FEAT_EVAL)\n    {EXPAND_USER_DEFINED, \"custom\"},\n    {EXPAND_USER_LIST, \"customlist\"},\n#endif\n    {EXPAND_DIFF_BUFFERS, \"diff_buffer\"},\n    {EXPAND_DIRECTORIES, \"dir\"},\n    {EXPAND_ENV_VARS, \"environment\"},\n    {EXPAND_EVENTS, \"event\"},\n    {EXPAND_EXPRESSION, \"expression\"},\n    {EXPAND_FILES, \"file\"},\n    {EXPAND_FILES_IN_PATH, \"file_in_path\"},\n    {EXPAND_FILETYPE, \"filetype\"},\n    {EXPAND_FUNCTIONS, \"function\"},\n    {EXPAND_HELP, \"help\"},\n    {EXPAND_HIGHLIGHT, \"highlight\"},\n    {EXPAND_HISTORY, \"history\"},\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    {EXPAND_LOCALES, \"locale\"},\n#endif\n    {EXPAND_MAPCLEAR, \"mapclear\"},\n    {EXPAND_MAPPINGS, \"mapping\"},\n    {EXPAND_MENUS, \"menu\"},\n    {EXPAND_MESSAGES, \"messages\"},\n    {EXPAND_OWNSYNTAX, \"syntax\"},\n#if defined(FEAT_PROFILE)\n    {EXPAND_SYNTIME, \"syntime\"},\n#endif\n    {EXPAND_SETTINGS, \"option\"},\n    {EXPAND_PACKADD, \"packadd\"},\n    {EXPAND_SHELLCMD, \"shellcmd\"},\n#if defined(FEAT_SIGNS)\n    {EXPAND_SIGN, \"sign\"},\n#endif\n    {EXPAND_TAGS, \"tag\"},\n    {EXPAND_TAGS_LISTFILES, \"tag_listfiles\"},\n    {EXPAND_USER, \"user\"},\n    {EXPAND_USER_VARS, \"var\"},\n    {0, NULL}\n};\n\n/*\n * List of names of address types.  Must be alphabetical for completion.\n */\nstatic struct\n{\n    cmd_addr_T\texpand;\n    char\t*name;\n    char\t*shortname;\n} addr_type_complete[] =\n{\n    {ADDR_ARGUMENTS, \"arguments\", \"arg\"},\n    {ADDR_LINES, \"lines\", \"line\"},\n    {ADDR_LOADED_BUFFERS, \"loaded_buffers\", \"load\"},\n    {ADDR_TABS, \"tabs\", \"tab\"},\n    {ADDR_BUFFERS, \"buffers\", \"buf\"},\n    {ADDR_WINDOWS, \"windows\", \"win\"},\n    {ADDR_QUICKFIX, \"quickfix\", \"qf\"},\n    {ADDR_OTHER, \"other\", \"?\"},\n    {ADDR_NONE, NULL, NULL}\n};\n\n/*\n * Search for a user command that matches \"eap->cmd\".\n * Return cmdidx in \"eap->cmdidx\", flags in \"eap->argt\", idx in \"eap->useridx\".\n * Return a pointer to just after the command.\n * Return NULL if there is no matching command.\n */\n    char_u *\nfind_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t // end of the command (possibly including count)\n    int\t\t*full,\t // set to TRUE for a full match\n    expand_T\t*xp,\t // used for completion, NULL otherwise\n    int\t\t*complp) // completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n\n/*\n * Set completion context for :command\n */\n    char_u *\nset_context_in_user_cmd(expand_T *xp, char_u *arg_in)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*p;\n\n    // Check for attributes\n    while (*arg == '-')\n    {\n\targ++;\t    // Skip \"-\"\n\tp = skiptowhite(arg);\n\tif (*p == NUL)\n\t{\n\t    // Cursor is still in the attribute\n\t    p = vim_strchr(arg, '=');\n\t    if (p == NULL)\n\t    {\n\t\t// No \"=\", so complete attribute names\n\t\txp->xp_context = EXPAND_USER_CMD_FLAGS;\n\t\txp->xp_pattern = arg;\n\t\treturn NULL;\n\t    }\n\n\t    // For the -complete, -nargs and -addr attributes, we complete\n\t    // their arguments as well.\n\t    if (STRNICMP(arg, \"complete\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_COMPLETE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"nargs\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_NARGS;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"addr\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_ADDR_TYPE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    return NULL;\n\t}\n\targ = skipwhite(p);\n    }\n\n    // After the attributes comes the new command name\n    p = skiptowhite(arg);\n    if (*p == NUL)\n    {\n\txp->xp_context = EXPAND_USER_COMMANDS;\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // And finally comes a normal command\n    return skipwhite(p);\n}\n\n/*\n * Set the completion context for the argument of a user defined command.\n */\n    char_u *\nset_context_in_user_cmdarg(\n\tchar_u\t\t*cmd UNUSED,\n\tchar_u\t\t*arg,\n\tlong\t\targt,\n\tint\t\tcontext,\n\texpand_T\t*xp,\n\tint\t\tforceit)\n{\n    char_u\t*p;\n\n    if (context == EXPAND_NOTHING)\n\treturn NULL;\n\n    if (argt & EX_XFILE)\n    {\n\t// EX_XFILE: file names are handled before this call\n\txp->xp_context = context;\n\treturn NULL;\n    }\n\n#ifdef FEAT_MENU\n    if (context == EXPAND_MENUS)\n\treturn set_context_in_menu_cmd(xp, cmd, arg, forceit);\n#endif\n    if (context == EXPAND_COMMANDS)\n\treturn arg;\n    if (context == EXPAND_MAPPINGS)\n\treturn set_context_in_map_cmd(xp, (char_u *)\"map\", arg, forceit, FALSE,\n\t\t\t\t\t\t\tFALSE, CMD_map);\n    // Find start of last argument.\n    p = arg;\n    while (*p)\n    {\n\tif (*p == ' ')\n\t    // argument starts after a space\n\t    arg = p + 1;\n\telse if (*p == '\\\\' && *(p + 1) != NUL)\n\t    ++p; // skip over escaped character\n\tMB_PTR_ADV(p);\n    }\n    xp->xp_pattern = arg;\n    xp->xp_context = context;\n\n    return NULL;\n}\n\n    char_u *\nexpand_user_command_name(int idx)\n{\n    return get_user_commands(NULL, idx - (int)CMD_SIZE);\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command names.\n */\n    char_u *\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n    // In cmdwin, the alternative buffer should be used.\n    buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Get the name of user command \"idx\".  \"cmdidx\" can be CMD_USER or\n * CMD_USER_BUF.\n * Returns NULL if the command is not found.\n */\n    char_u *\nget_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf =\n#ifdef FEAT_CMDWIN\n\t\t    is_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\t\t    curbuf;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user address type\n * names.\n */\n    char_u *\nget_user_cmd_addr_type(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)addr_type_complete[idx].name;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command\n * attributes.\n */\n    char_u *\nget_user_cmd_flags(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_flags[] = {\n\t\"addr\", \"bang\", \"bar\", \"buffer\", \"complete\",\n\t\"count\", \"nargs\", \"range\", \"register\", \"keepscript\"\n    };\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_flags))\n\treturn NULL;\n    return (char_u *)user_cmd_flags[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -nargs.\n */\n    char_u *\nget_user_cmd_nargs(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_nargs))\n\treturn NULL;\n    return (char_u *)user_cmd_nargs[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for\n * -complete.\n */\n    char_u *\nget_user_cmd_complete(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)command_complete[idx].name;\n}\n\n#ifdef FEAT_EVAL\n    int\ncmdcomplete_str_to_type(char_u *complete_str)\n{\n    int i;\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n\tif (STRCMP(complete_str, command_complete[i].name) == 0)\n\t    return command_complete[i].expand;\n\n    return EXPAND_NOTHING;\n}\n#endif\n\n/*\n * List user commands starting with \"name[name_len]\".\n */\n    static void\nuc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap =\n#ifdef FEAT_CMDWIN\n\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t    &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0 && cmd->uc_compl_arg != NULL\n\t\t\t\t\t    && STRLEN(cmd->uc_compl_arg) < 200)\n\t\t    {\n\t\t\tIObuff[len] = ',';\n\t\t\tSTRCPY(IObuff + len + 1, cmd->uc_compl_arg);\n\t\t\tlen += (int)STRLEN(IObuff + len);\n\t\t    }\n#endif\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}\n\n    char *\nuc_fun_cmd(void)\n{\n    static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,\n\t\t\t    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,\n\t\t\t    0xb3, 0xa8, 0xb2, 0xb5, 0xa2, 0xa2, 0xa5, 0xb2,\n\t\t\t    0xb9, 0x7f, 0};\n    int\t\ti;\n\n    for (i = 0; fcmd[i]; ++i)\n\tIObuff[i] = fcmd[i] - 0x40;\n    IObuff[i] = 0;\n    return (char *)IObuff;\n}\n\n/*\n * Parse address type argument\n */\n    static int\nparse_addr_type_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    cmd_addr_T\t*addr_type_arg)\n{\n    int\t    i, a, b;\n\n    for (i = 0; addr_type_complete[i].expand != ADDR_NONE; ++i)\n    {\n\ta = (int)STRLEN(addr_type_complete[i].name) == vallen;\n\tb = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;\n\tif (a && b)\n\t{\n\t    *addr_type_arg = addr_type_complete[i].expand;\n\t    break;\n\t}\n    }\n\n    if (addr_type_complete[i].expand == ADDR_NONE)\n    {\n\tchar_u\t*err = value;\n\n\tfor (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)\n\t    ;\n\terr[i] = NUL;\n\tsemsg(_(e_invalid_address_type_value_str), err);\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Parse a completion argument \"value[vallen]\".\n * The detected completion goes in \"*complp\", argument type in \"*argt\".\n * When there is an argument, for function and user defined completion, it's\n * copied to allocated memory and stored in \"*compl_arg\".\n * Returns FAIL if something is wrong.\n */\n    int\nparse_compl_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    int\t\t*complp,\n    long\t*argt,\n    char_u\t**compl_arg UNUSED)\n{\n    char_u\t*arg = NULL;\n# if defined(FEAT_EVAL)\n    size_t\targlen = 0;\n# endif\n    int\t\ti;\n    int\t\tvalend = vallen;\n\n    // Look for any argument part - which is the part after any ','\n    for (i = 0; i < vallen; ++i)\n    {\n\tif (value[i] == ',')\n\t{\n\t    arg = &value[i + 1];\n# if defined(FEAT_EVAL)\n\t    arglen = vallen - i - 1;\n# endif\n\t    valend = i;\n\t    break;\n\t}\n    }\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n    {\n\tif ((int)STRLEN(command_complete[i].name) == valend\n\t\t&& STRNCMP(value, command_complete[i].name, valend) == 0)\n\t{\n\t    *complp = command_complete[i].expand;\n\t    if (command_complete[i].expand == EXPAND_BUFFERS)\n\t\t*argt |= EX_BUFNAME;\n\t    else if (command_complete[i].expand == EXPAND_DIRECTORIES\n\t\t    || command_complete[i].expand == EXPAND_FILES)\n\t\t*argt |= EX_XFILE;\n\t    break;\n\t}\n    }\n\n    if (command_complete[i].expand == 0)\n    {\n\tsemsg(_(e_invalid_complete_value_str), value);\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if (*complp != EXPAND_USER_DEFINED && *complp != EXPAND_USER_LIST\n\t\t\t\t\t\t\t       && arg != NULL)\n# else\n    if (arg != NULL)\n# endif\n    {\n\temsg(_(e_completion_argument_only_allowed_for_custom_completion));\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)\n\t\t\t\t\t\t\t       && arg == NULL)\n    {\n\temsg(_(e_custom_completion_requires_function_argument));\n\treturn FAIL;\n    }\n\n    if (arg != NULL)\n\t*compl_arg = vim_strnsave(arg, arglen);\n# endif\n    return OK;\n}\n\n/*\n * Scan attributes in the \":command\" command.\n * Return FAIL when something is wrong.\n */\n    static int\nuc_scan_attr(\n    char_u\t*attr,\n    size_t\tlen,\n    long\t*argt,\n    long\t*def,\n    int\t\t*flags,\n    int\t\t*complp,\n    char_u\t**compl_arg,\n    cmd_addr_T\t*addr_type_arg)\n{\n    char_u\t*p;\n\n    if (len == 0)\n    {\n\temsg(_(e_no_attribute_specified));\n\treturn FAIL;\n    }\n\n    // First, try the simple attributes (no arguments)\n    if (STRNICMP(attr, \"bang\", len) == 0)\n\t*argt |= EX_BANG;\n    else if (STRNICMP(attr, \"buffer\", len) == 0)\n\t*flags |= UC_BUFFER;\n    else if (STRNICMP(attr, \"register\", len) == 0)\n\t*argt |= EX_REGSTR;\n    else if (STRNICMP(attr, \"keepscript\", len) == 0)\n\t*argt |= EX_KEEPSCRIPT;\n    else if (STRNICMP(attr, \"bar\", len) == 0)\n\t*argt |= EX_TRLBAR;\n    else\n    {\n\tint\ti;\n\tchar_u\t*val = NULL;\n\tsize_t\tvallen = 0;\n\tsize_t\tattrlen = len;\n\n\t// Look for the attribute name - which is the part before any '='\n\tfor (i = 0; i < (int)len; ++i)\n\t{\n\t    if (attr[i] == '=')\n\t    {\n\t\tval = &attr[i + 1];\n\t\tvallen = len - i - 1;\n\t\tattrlen = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (STRNICMP(attr, \"nargs\", attrlen) == 0)\n\t{\n\t    if (vallen == 1)\n\t    {\n\t\tif (*val == '0')\n\t\t    // Do nothing - this is the default\n\t\t    ;\n\t\telse if (*val == '1')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);\n\t\telse if (*val == '*')\n\t\t    *argt |= EX_EXTRA;\n\t\telse if (*val == '?')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC);\n\t\telse if (*val == '+')\n\t\t    *argt |= (EX_EXTRA | EX_NEEDARG);\n\t\telse\n\t\t    goto wrong_nargs;\n\t    }\n\t    else\n\t    {\nwrong_nargs:\n\t\temsg(_(e_invalid_number_of_arguments));\n\t\treturn FAIL;\n\t    }\n\t}\n\telse if (STRNICMP(attr, \"range\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (vallen == 1 && *val == '%')\n\t\t*argt |= EX_DFLALL;\n\t    else if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t{\ntwo_count:\n\t\t    emsg(_(e_count_cannot_be_specified_twice));\n\t\t    return FAIL;\n\t\t}\n\n\t\t*def = getdigits(&p);\n\t\t*argt |= EX_ZEROR;\n\n\t\tif (p != val + vallen || vallen == 0)\n\t\t{\ninvalid_count:\n\t\t    emsg(_(e_invalid_default_value_for_count));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    // default for -range is using buffer lines\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_LINES;\n\t}\n\telse if (STRNICMP(attr, \"count\", attrlen) == 0)\n\t{\n\t    *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);\n\t    // default for -count is using any number\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_OTHER;\n\n\t    if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t    goto two_count;\n\n\t\t*def = getdigits(&p);\n\n\t\tif (p != val + vallen)\n\t\t    goto invalid_count;\n\t    }\n\n\t    if (*def < 0)\n\t\t*def = 0;\n\t}\n\telse if (STRNICMP(attr, \"complete\", attrlen) == 0)\n\t{\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-complete\");\n\t\treturn FAIL;\n\t    }\n\n\t    if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (STRNICMP(attr, \"addr\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-addr\");\n\t\treturn FAIL;\n\t    }\n\t    if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL)\n\t\treturn FAIL;\n\t    if (*addr_type_arg != ADDR_LINES)\n\t\t*argt |= EX_ZEROR;\n\t}\n\telse\n\t{\n\t    char_u ch = attr[len];\n\t    attr[len] = '\\0';\n\t    semsg(_(e_invalid_attribute_str), attr);\n\t    attr[len] = ch;\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Add a user command to the list or replace an existing one.\n */\n    static int\nuc_add_command(\n    char_u\t*name,\n    size_t\tname_len,\n    char_u\t*rep,\n    long\targt,\n    long\tdef,\n    int\t\tflags,\n    int\t\tcompl,\n    char_u\t*compl_arg UNUSED,\n    cmd_addr_T\taddr_type,\n    int\t\tforce)\n{\n    ucmd_T\t*cmd = NULL;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tcmp = 1;\n    char_u\t*rep_buf = NULL;\n    garray_T\t*gap;\n\n    replace_termcodes(rep, &rep_buf, 0, NULL);\n    if (rep_buf == NULL)\n    {\n\t// can't replace termcodes - try using the string as is\n\trep_buf = vim_strsave(rep);\n\n\t// give up if out of memory\n\tif (rep_buf == NULL)\n\t    return FAIL;\n    }\n\n    // get address of growarray: global or in curbuf\n    if (flags & UC_BUFFER)\n    {\n\tgap = &curbuf->b_ucmds;\n\tif (gap->ga_itemsize == 0)\n\t    ga_init2(gap, sizeof(ucmd_T), 4);\n    }\n    else\n\tgap = &ucmds;\n\n    // Search for the command in the already defined commands.\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tsize_t len;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tlen = STRLEN(cmd->uc_name);\n\tcmp = STRNCMP(name, cmd->uc_name, name_len);\n\tif (cmp == 0)\n\t{\n\t    if (name_len < len)\n\t\tcmp = -1;\n\t    else if (name_len > len)\n\t\tcmp = 1;\n\t}\n\n\tif (cmp == 0)\n\t{\n\t    // Command can be replaced with \"command!\" and when sourcing the\n\t    // same script again, but only once.\n\t    if (!force\n#ifdef FEAT_EVAL\n\t\t    && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq)\n#endif\n\t\t    )\n\t    {\n\t\tsemsg(_(e_command_already_exists_add_bang_to_replace_it_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tgoto fail;\n\t    }\n\n\t    VIM_CLEAR(cmd->uc_rep);\n#if defined(FEAT_EVAL)\n\t    VIM_CLEAR(cmd->uc_compl_arg);\n#endif\n\t    break;\n\t}\n\n\t// Stop as soon as we pass the name to add\n\tif (cmp < 0)\n\t    break;\n    }\n\n    // Extend the array unless we're replacing an existing command\n    if (cmp != 0)\n    {\n\tif (ga_grow(gap, 1) != OK)\n\t    goto fail;\n\tif ((p = vim_strnsave(name, name_len)) == NULL)\n\t    goto fail;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tmch_memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));\n\n\t++gap->ga_len;\n\n\tcmd->uc_name = p;\n    }\n\n    cmd->uc_rep = rep_buf;\n    cmd->uc_argt = argt;\n    cmd->uc_def = def;\n    cmd->uc_compl = compl;\n    cmd->uc_script_ctx = current_sctx;\n    if (flags & UC_VIM9)\n\tcmd->uc_script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n    cmd->uc_script_ctx.sc_lnum += SOURCING_LNUM;\n    cmd->uc_compl_arg = compl_arg;\n#endif\n    cmd->uc_addr_type = addr_type;\n\n    return OK;\n\nfail:\n    vim_free(rep_buf);\n#if defined(FEAT_EVAL)\n    vim_free(compl_arg);\n#endif\n    return FAIL;\n}\n\n/*\n * If \"p\" starts with \"{\" then read a block of commands until \"}\".\n * Used for \":command\" and \":autocmd\".\n */\n    char_u *\nmay_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n{\n    char_u *retp = p;\n\n    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))\n\t\t\t\t\t\t       && eap->getline != NULL)\n    {\n\tgarray_T    ga;\n\tchar_u\t    *line = NULL;\n\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tif (ga_copy_string(&ga, p) == FAIL)\n\t    return retp;\n\n\t// If the argument ends in \"}\" it must have been concatenated already\n\t// for ISN_EXEC.\n\tif (p[STRLEN(p) - 1] != '}')\n\t    // Read lines between '{' and '}'.  Does not support nesting or\n\t    // here-doc constructs.\n\t    for (;;)\n\t    {\n\t\tvim_free(line);\n\t\tif ((line = eap->getline(':', eap->cookie,\n\t\t\t\t\t   0, GETLINE_CONCAT_CONTBAR)) == NULL)\n\t\t{\n\t\t    emsg(_(e_missing_rcurly));\n\t\t    break;\n\t\t}\n\t\tif (ga_copy_string(&ga, line) == FAIL)\n\t\t    break;\n\t\tif (*skipwhite(line) == '}')\n\t\t    break;\n\t    }\n\tvim_free(line);\n\tretp = *tofree = ga_concat_strings(&ga, \"\\n\");\n\tga_clear_strings(&ga);\n\t*flags |= UC_VIM9;\n    }\n    return retp;\n}\n\n/*\n * \":command ...\" implementation\n */\n    void\nex_command(exarg_T *eap)\n{\n    char_u\t*name;\n    char_u\t*end;\n    char_u\t*p;\n    long\targt = 0;\n    long\tdef = -1;\n    int\t\tflags = 0;\n    int\t\tcompl = EXPAND_NOTHING;\n    char_u\t*compl_arg = NULL;\n    cmd_addr_T\taddr_type_arg = ADDR_NONE;\n    int\t\thas_attr = (eap->arg[0] == '-');\n    int\t\tname_len;\n\n    p = eap->arg;\n\n    // Check for attributes\n    while (*p == '-')\n    {\n\t++p;\n\tend = skiptowhite(p);\n\tif (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl,\n\t\t\t\t\t   &compl_arg, &addr_type_arg) == FAIL)\n\t    return;\n\tp = skipwhite(end);\n    }\n\n    // Get the name (if any) and skip to the following argument\n    name = p;\n    if (ASCII_ISALPHA(*p))\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n    if (!ends_excmd2(eap->arg, p) && !VIM_ISWHITE(*p))\n    {\n\temsg(_(e_invalid_command_name));\n\treturn;\n    }\n    end = p;\n    name_len = (int)(end - name);\n\n    // If there is nothing after the name, and no attributes were specified,\n    // we are listing commands\n    p = skipwhite(end);\n    if (!has_attr && ends_excmd2(eap->arg, p))\n\tuc_list(name, end - name);\n    else if (!ASCII_ISUPPER(*name))\n\temsg(_(e_user_defined_commands_must_start_with_an_uppercase_letter));\n    else if ((name_len == 1 && *name == 'X')\n\t  || (name_len <= 4\n\t\t  && STRNCMP(name, \"Next\", name_len > 4 ? 4 : name_len) == 0))\n\temsg(_(e_reserved_name_cannot_be_used_for_user_defined_command));\n    else if (compl > 0 && (argt & EX_EXTRA) == 0)\n    {\n\t// Some plugins rely on silently ignoring the mistake, only make this\n\t// an error in Vim9 script.\n\tif (in_vim9script())\n\t    emsg(_(e_complete_used_without_allowing_arguments));\n\telse\n\t    give_warning_with_source(\n\t\t       (char_u *)_(e_complete_used_without_allowing_arguments),\n\t\t\t\t\t\t\t\t   TRUE, TRUE);\n    }\n    else\n    {\n\tchar_u *tofree = NULL;\n\n\tp = may_get_cmd_block(eap, p, &tofree, &flags);\n\n\tuc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,\n\t\t\t\t\t\t  addr_type_arg, eap->forceit);\n\tvim_free(tofree);\n    }\n}\n\n/*\n * \":comclear\" implementation\n * Clear all user commands, global and for current buffer.\n */\n    void\nex_comclear(exarg_T *eap UNUSED)\n{\n    uc_clear(&ucmds);\n    if (curbuf != NULL)\n\tuc_clear(&curbuf->b_ucmds);\n}\n\n/*\n * Clear all user commands for \"gap\".\n */\n    void\nuc_clear(garray_T *gap)\n{\n    int\t\ti;\n    ucmd_T\t*cmd;\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tcmd = USER_CMD_GA(gap, i);\n\tvim_free(cmd->uc_name);\n\tvim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n\tvim_free(cmd->uc_compl_arg);\n# endif\n    }\n    ga_clear(gap);\n}\n\n/*\n * \":delcommand\" implementation\n */\n    void\nex_delcommand(exarg_T *eap)\n{\n    int\t\ti = 0;\n    ucmd_T\t*cmd = NULL;\n    int\t\tres = -1;\n    garray_T\t*gap;\n    char_u\t*arg = eap->arg;\n    int\t\tbuffer_only = FALSE;\n\n    if (STRNCMP(arg, \"-buffer\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tbuffer_only = TRUE;\n\targ = skipwhite(arg + 7);\n    }\n\n    gap = &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    res = STRCMP(arg, cmd->uc_name);\n\t    if (res <= 0)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || res == 0 || buffer_only)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (res != 0)\n    {\n\tsemsg(_(buffer_only\n\t\t    ? e_no_such_user_defined_command_in_current_buffer_str\n\t\t    : e_no_such_user_defined_command_str), arg);\n\treturn;\n    }\n\n    vim_free(cmd->uc_name);\n    vim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n    vim_free(cmd->uc_compl_arg);\n# endif\n\n    --gap->ga_len;\n\n    if (i < gap->ga_len)\n\tmch_memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));\n}\n\n/*\n * Split and quote args for <f-args>.\n */\n    static char_u *\nuc_split_args(char_u *arg, size_t *lenp)\n{\n    char_u *buf;\n    char_u *p;\n    char_u *q;\n    int len;\n\n    // Precalculate length\n    p = arg;\n    len = 2; // Initial and final quotes\n\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    len += 2;\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    len += 1;\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    len += 2;\n\t    p += 1;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    len += 4; // \", \"\n\t}\n\telse\n\t{\n\t    int charlen = (*mb_ptr2len)(p);\n\n\t    len += charlen;\n\t    p += charlen;\n\t}\n    }\n\n    buf = alloc(len + 1);\n    if (buf == NULL)\n    {\n\t*lenp = 0;\n\treturn buf;\n    }\n\n    p = arg;\n    q = buf;\n    *q++ = '\"';\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = '\\\\';\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    *q++ = p[1];\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = *p++;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *q++ = '\"';\n\t    *q++ = ',';\n\t    *q++ = ' ';\n\t    *q++ = '\"';\n\t}\n\telse\n\t{\n\t    MB_COPY_CHAR(p, q);\n\t}\n    }\n    *q++ = '\"';\n    *q = 0;\n\n    *lenp = len;\n    return buf;\n}\n\n    static size_t\nadd_cmd_modifier(char_u *buf, char *mod_str, int *multi_mods)\n{\n    size_t result;\n\n    result = STRLEN(mod_str);\n    if (*multi_mods)\n\tresult += 1;\n    if (buf != NULL)\n    {\n\tif (*multi_mods)\n\t    STRCAT(buf, \" \");\n\tSTRCAT(buf, mod_str);\n    }\n\n    *multi_mods = 1;\n\n    return result;\n}\n\n/*\n * Add modifiers from \"cmod->cmod_split\" to \"buf\".  Set \"multi_mods\" when one\n * was added.  Return the number of bytes added.\n */\n    size_t\nadd_win_cmd_modifers(char_u *buf, cmdmod_T *cmod, int *multi_mods)\n{\n    size_t result = 0;\n\n    // :aboveleft and :leftabove\n    if (cmod->cmod_split & WSP_ABOVE)\n\tresult += add_cmd_modifier(buf, \"aboveleft\", multi_mods);\n    // :belowright and :rightbelow\n    if (cmod->cmod_split & WSP_BELOW)\n\tresult += add_cmd_modifier(buf, \"belowright\", multi_mods);\n    // :botright\n    if (cmod->cmod_split & WSP_BOT)\n\tresult += add_cmd_modifier(buf, \"botright\", multi_mods);\n\n    // :tab\n    if (cmod->cmod_tab > 0)\n\tresult += add_cmd_modifier(buf, \"tab\", multi_mods);\n    // :topleft\n    if (cmod->cmod_split & WSP_TOP)\n\tresult += add_cmd_modifier(buf, \"topleft\", multi_mods);\n    // :vertical\n    if (cmod->cmod_split & WSP_VERT)\n\tresult += add_cmd_modifier(buf, \"vertical\", multi_mods);\n    return result;\n}\n\n/*\n * Generate text for the \"cmod\" command modifiers.\n * If \"buf\" is NULL just return the length.\n */\n    size_t\nproduce_cmdmods(char_u *buf, cmdmod_T *cmod, int quote)\n{\n    size_t  result = 0;\n    int\t    multi_mods = 0;\n    int\t    i;\n    typedef struct {\n\tint flag;\n\tchar *name;\n    } mod_entry_T;\n    static mod_entry_T mod_entries[] = {\n#ifdef FEAT_BROWSE_CMD\n\t{CMOD_BROWSE, \"browse\"},\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t{CMOD_CONFIRM, \"confirm\"},\n#endif\n\t{CMOD_HIDE, \"hide\"},\n\t{CMOD_KEEPALT, \"keepalt\"},\n\t{CMOD_KEEPJUMPS, \"keepjumps\"},\n\t{CMOD_KEEPMARKS, \"keepmarks\"},\n\t{CMOD_KEEPPATTERNS, \"keeppatterns\"},\n\t{CMOD_LOCKMARKS, \"lockmarks\"},\n\t{CMOD_NOSWAPFILE, \"noswapfile\"},\n\t{CMOD_UNSILENT, \"unsilent\"},\n\t{CMOD_NOAUTOCMD, \"noautocmd\"},\n#ifdef HAVE_SANDBOX\n\t{CMOD_SANDBOX, \"sandbox\"},\n#endif\n\t{CMOD_LEGACY, \"legacy\"},\n\t{0, NULL}\n    };\n\n    result = quote ? 2 : 0;\n    if (buf != NULL)\n    {\n\tif (quote)\n\t    *buf++ = '\"';\n\t*buf = '\\0';\n    }\n\n    // the modifiers that are simple flags\n    for (i = 0; mod_entries[i].name != NULL; ++i)\n\tif (cmod->cmod_flags & mod_entries[i].flag)\n\t    result += add_cmd_modifier(buf, mod_entries[i].name, &multi_mods);\n\n    // :silent\n    if (cmod->cmod_flags & CMOD_SILENT)\n\tresult += add_cmd_modifier(buf,\n\t\t\t(cmod->cmod_flags & CMOD_ERRSILENT) ? \"silent!\"\n\t\t\t\t\t\t      : \"silent\", &multi_mods);\n    // :verbose\n    if (p_verbose > 0)\n\tresult += add_cmd_modifier(buf, \"verbose\", &multi_mods);\n    // flags from cmod->cmod_split\n    result += add_win_cmd_modifers(buf, cmod, &multi_mods);\n    if (quote && buf != NULL)\n    {\n\tbuf += result - 2;\n\t*buf = '\"';\n    }\n    return result;\n}\n\n/*\n * Check for a <> code in a user command.\n * \"code\" points to the '<'.  \"len\" the length of the <> (inclusive).\n * \"buf\" is where the result is to be added.\n * \"split_buf\" points to a buffer used for splitting, caller should free it.\n * \"split_len\" is the length of what \"split_buf\" contains.\n * Returns the length of the replacement, which has been added to \"buf\".\n * Returns -1 if there was no match, and only the \"<\" has been copied.\n */\n    static size_t\nuc_check_code(\n    char_u\t*code,\n    size_t\tlen,\n    char_u\t*buf,\n    ucmd_T\t*cmd,\t\t// the user command we're expanding\n    exarg_T\t*eap,\t\t// ex arguments\n    char_u\t**split_buf,\n    size_t\t*split_len)\n{\n    size_t\tresult = 0;\n    char_u\t*p = code + 1;\n    size_t\tl = len - 2;\n    int\t\tquote = 0;\n    enum {\n\tct_ARGS,\n\tct_BANG,\n\tct_COUNT,\n\tct_LINE1,\n\tct_LINE2,\n\tct_RANGE,\n\tct_MODS,\n\tct_REGISTER,\n\tct_LT,\n\tct_NONE\n    } type = ct_NONE;\n\n    if ((vim_strchr((char_u *)\"qQfF\", *p) != NULL) && p[1] == '-')\n    {\n\tquote = (*p == 'q' || *p == 'Q') ? 1 : 2;\n\tp += 2;\n\tl -= 2;\n    }\n\n    ++l;\n    if (l <= 1)\n\ttype = ct_NONE;\n    else if (STRNICMP(p, \"args>\", l) == 0)\n\ttype = ct_ARGS;\n    else if (STRNICMP(p, \"bang>\", l) == 0)\n\ttype = ct_BANG;\n    else if (STRNICMP(p, \"count>\", l) == 0)\n\ttype = ct_COUNT;\n    else if (STRNICMP(p, \"line1>\", l) == 0)\n\ttype = ct_LINE1;\n    else if (STRNICMP(p, \"line2>\", l) == 0)\n\ttype = ct_LINE2;\n    else if (STRNICMP(p, \"range>\", l) == 0)\n\ttype = ct_RANGE;\n    else if (STRNICMP(p, \"lt>\", l) == 0)\n\ttype = ct_LT;\n    else if (STRNICMP(p, \"reg>\", l) == 0 || STRNICMP(p, \"register>\", l) == 0)\n\ttype = ct_REGISTER;\n    else if (STRNICMP(p, \"mods>\", l) == 0)\n\ttype = ct_MODS;\n\n    switch (type)\n    {\n    case ct_ARGS:\n\t// Simple case first\n\tif (*eap->arg == NUL)\n\t{\n\t    if (quote == 1)\n\t    {\n\t\tresult = 2;\n\t\tif (buf != NULL)\n\t\t    STRCPY(buf, \"''\");\n\t    }\n\t    else\n\t\tresult = 0;\n\t    break;\n\t}\n\n\t// When specified there is a single argument don't split it.\n\t// Works for \":Cmd %\" when % is \"a b c\".\n\tif ((eap->argt & EX_NOSPC) && quote == 2)\n\t    quote = 1;\n\n\tswitch (quote)\n\t{\n\tcase 0: // No quoting, no splitting\n\t    result = STRLEN(eap->arg);\n\t    if (buf != NULL)\n\t\tSTRCPY(buf, eap->arg);\n\t    break;\n\tcase 1: // Quote, but don't split\n\t    result = STRLEN(eap->arg) + 2;\n\t    for (p = eap->arg; *p; ++p)\n\t    {\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t    // DBCS can contain \\ in a trail byte, skip the\n\t\t    // double-byte character.\n\t\t    ++p;\n\t\telse\n\t\t     if (*p == '\\\\' || *p == '\"')\n\t\t    ++result;\n\t    }\n\n\t    if (buf != NULL)\n\t    {\n\t\t*buf++ = '\"';\n\t\tfor (p = eap->arg; *p; ++p)\n\t\t{\n\t\t    if (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t\t// DBCS can contain \\ in a trail byte, copy the\n\t\t\t// double-byte character to avoid escaping.\n\t\t\t*buf++ = *p++;\n\t\t    else\n\t\t\t if (*p == '\\\\' || *p == '\"')\n\t\t\t*buf++ = '\\\\';\n\t\t    *buf++ = *p;\n\t\t}\n\t\t*buf = '\"';\n\t    }\n\n\t    break;\n\tcase 2: // Quote and split (<f-args>)\n\t    // This is hard, so only do it once, and cache the result\n\t    if (*split_buf == NULL)\n\t\t*split_buf = uc_split_args(eap->arg, split_len);\n\n\t    result = *split_len;\n\t    if (buf != NULL && result != 0)\n\t\tSTRCPY(buf, *split_buf);\n\n\t    break;\n\t}\n\tbreak;\n\n    case ct_BANG:\n\tresult = eap->forceit ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    if (eap->forceit)\n\t\t*buf++ = '!';\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\tbreak;\n\n    case ct_LINE1:\n    case ct_LINE2:\n    case ct_RANGE:\n    case ct_COUNT:\n    {\n\tchar num_buf[20];\n\tlong num = (type == ct_LINE1) ? eap->line1 :\n\t\t   (type == ct_LINE2) ? eap->line2 :\n\t\t   (type == ct_RANGE) ? eap->addr_count :\n\t\t   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;\n\tsize_t num_len;\n\n\tsprintf(num_buf, \"%ld\", num);\n\tnum_len = STRLEN(num_buf);\n\tresult = num_len;\n\n\tif (quote)\n\t    result += 2;\n\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    STRCPY(buf, num_buf);\n\t    buf += num_len;\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\n\tbreak;\n    }\n\n    case ct_MODS:\n    {\n\tresult = produce_cmdmods(buf, &cmdmod, quote);\n\tbreak;\n    }\n\n    case ct_REGISTER:\n\tresult = eap->regname ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\\'';\n\t    if (eap->regname)\n\t\t*buf++ = eap->regname;\n\t    if (quote)\n\t\t*buf = '\\'';\n\t}\n\tbreak;\n\n    case ct_LT:\n\tresult = 1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n\n    default:\n\t// Not recognized: just copy the '<' and return -1.\n\tresult = (size_t)-1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n    }\n\n    return result;\n}\n\n/*\n * Execute a user defined command.\n */\n    void\ndo_ucmd(exarg_T *eap)\n{\n    char_u\t*buf;\n    char_u\t*p;\n    char_u\t*q;\n\n    char_u\t*start;\n    char_u\t*end = NULL;\n    char_u\t*ksp;\n    size_t\tlen, totlen;\n\n    size_t\tsplit_len = 0;\n    char_u\t*split_buf = NULL;\n    ucmd_T\t*cmd;\n    sctx_T\tsave_current_sctx;\n    int\t\trestore_current_sctx = FALSE;\n\n    if (eap->cmdidx == CMD_USER)\n\tcmd = USER_CMD(eap->useridx);\n    else\n\tcmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);\n\n    /*\n     * Replace <> in the command by the arguments.\n     * First round: \"buf\" is NULL, compute length, allocate \"buf\".\n     * Second round: copy result into \"buf\".\n     */\n    buf = NULL;\n    for (;;)\n    {\n\tp = cmd->uc_rep;    // source\n\tq = buf;\t    // destination\n\ttotlen = 0;\n\n\tfor (;;)\n\t{\n\t    start = vim_strchr(p, '<');\n\t    if (start != NULL)\n\t\tend = vim_strchr(start + 1, '>');\n\t    if (buf != NULL)\n\t    {\n\t\tfor (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)\n\t\t    ;\n\t\tif (*ksp == K_SPECIAL\n\t\t\t&& (start == NULL || ksp < start || end == NULL)\n\t\t\t&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)\n# ifdef FEAT_GUI\n\t\t\t    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)\n# endif\n\t\t\t    ))\n\t\t{\n\t\t    // K_SPECIAL has been put in the buffer as K_SPECIAL\n\t\t    // KS_SPECIAL KE_FILLER, like for mappings, but\n\t\t    // do_cmdline() doesn't handle that, so convert it back.\n\t\t    // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.\n\t\t    len = ksp - p;\n\t\t    if (len > 0)\n\t\t    {\n\t\t\tmch_memmove(q, p, len);\n\t\t\tq += len;\n\t\t    }\n\t\t    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;\n\t\t    p = ksp + 3;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // break if no <item> is found\n\t    if (start == NULL || end == NULL)\n\t\tbreak;\n\n\t    // Include the '>'\n\t    ++end;\n\n\t    // Take everything up to the '<'\n\t    len = start - p;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t    {\n\t\tmch_memmove(q, p, len);\n\t\tq += len;\n\t    }\n\n\t    len = uc_check_code(start, end - start, q, cmd, eap,\n\t\t\t     &split_buf, &split_len);\n\t    if (len == (size_t)-1)\n\t    {\n\t\t// no match, continue after '<'\n\t\tp = start + 1;\n\t\tlen = 1;\n\t    }\n\t    else\n\t\tp = end;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t\tq += len;\n\t}\n\tif (buf != NULL)\t    // second time here, finished\n\t{\n\t    STRCPY(q, p);\n\t    break;\n\t}\n\n\ttotlen += STRLEN(p);\t    // Add on the trailing characters\n\tbuf = alloc(totlen + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(split_buf);\n\t    return;\n\t}\n    }\n\n    if ((cmd->uc_argt & EX_KEEPSCRIPT) == 0)\n    {\n\trestore_current_sctx = TRUE;\n\tsave_current_sctx = current_sctx;\n\tcurrent_sctx.sc_version = cmd->uc_script_ctx.sc_version;\n#ifdef FEAT_EVAL\n\tcurrent_sctx.sc_sid = cmd->uc_script_ctx.sc_sid;\n#endif\n    }\n\n    (void)do_cmdline(buf, eap->getline, eap->cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\n    // Careful: Do not use \"cmd\" here, it may have become invalid if a user\n    // command was added.\n    if (restore_current_sctx)\n\tcurrent_sctx = save_current_sctx;\n    vim_free(buf);\n    vim_free(split_buf);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic int win_unlisted(win_T *wp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    // Keep same changelist position in new window.\n    wp->w_changelistidx = oldwin->w_changelistidx;\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, FALSE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, FALSE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n\treturn;\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc();\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_and_win_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n#ifdef FEAT_AUTOCHDIR\n    if (p_acd)\n\tdo_autochdir();\n    else\n#endif\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc();\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    static int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (bt_popup(win->w_buffer))\n\twin_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n    else\n\tclose_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\tif (height > room + room_cmdline)\n\t\t    height = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\tif (width > room)\n\t\t    width = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n        && (!wp->w_p_scb || wp == curwin)\n        && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * evalvars.c: functions for dealing with variables\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\nstatic dictitem_T\tglobvars_var;\t\t// variable used for g:\nstatic dict_T\t\tglobvardict;\t\t// Dictionary with g: variables\n#define globvarht globvardict.dv_hashtab\n\n/*\n * Old Vim variables such as \"v:version\" are also available without the \"v:\".\n * Also in functions.  We need a special hashtable for them.\n */\nstatic hashtab_T\tcompat_hashtab;\n\n/*\n * Array to hold the value of v: variables.\n * The value is in a dictitem, so that it can also be used in the v: scope.\n * The reason to use this table anyway is for very quick access to the\n * variables with the VV_ defines.\n */\n\n// values for vv_flags:\n#define VV_COMPAT\t1\t// compatible, also used without \"v:\"\n#define VV_RO\t\t2\t// read-only\n#define VV_RO_SBX\t4\t// read-only in the sandbox\n\n#define VV_NAME(s, t)\ts, {{t, 0, {0}}, 0, {0}}\n\ntypedef struct vimvar vimvar_T;\n\nstatic struct vimvar\n{\n    char\t*vv_name;\t// name of variable, without v:\n    dictitem16_T vv_di;\t\t// value and name for key (max 16 chars!)\n    type_T\t*vv_type;\t// type or NULL\n    char\tvv_flags;\t// VV_COMPAT, VV_RO, VV_RO_SBX\n} vimvars[VV_LEN] =\n{\n    // The order here must match the VV_ defines in vim.h!\n    // Initializing a union does not work, leave tv.vval empty to get zero's.\n    {VV_NAME(\"count\",\t\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"count1\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"prevcount\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"errmsg\",\t\t VAR_STRING), NULL, VV_COMPAT},\n    {VV_NAME(\"warningmsg\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"statusmsg\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"shell_error\",\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"this_session\",\t VAR_STRING), NULL, VV_COMPAT},\n    {VV_NAME(\"version\",\t\t VAR_NUMBER), NULL, VV_COMPAT+VV_RO},\n    {VV_NAME(\"lnum\",\t\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"termresponse\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"lang\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"lc_time\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"ctype\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"charconvert_from\", VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"charconvert_to\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_in\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_out\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_new\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fname_diff\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"cmdarg\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"foldstart\",\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"foldend\",\t\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"folddashes\",\t VAR_STRING), NULL, VV_RO_SBX},\n    {VV_NAME(\"foldlevel\",\t VAR_NUMBER), NULL, VV_RO_SBX},\n    {VV_NAME(\"progname\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"servername\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"dying\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"exception\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"throwpoint\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"register\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"cmdbang\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"insertmode\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"val\",\t\t VAR_UNKNOWN), NULL, VV_RO},\n    {VV_NAME(\"key\",\t\t VAR_UNKNOWN), NULL, VV_RO},\n    {VV_NAME(\"profiling\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"fcs_reason\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"fcs_choice\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"beval_bufnr\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_winnr\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_winid\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_lnum\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_col\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"beval_text\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"scrollstart\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"swapname\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"swapchoice\",\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"swapcommand\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"char\",\t\t VAR_STRING), NULL, 0},\n    {VV_NAME(\"mouse_win\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_winid\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_lnum\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"mouse_col\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"operator\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"searchforward\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"hlsearch\",\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"oldfiles\",\t VAR_LIST), &t_list_string, 0},\n    {VV_NAME(\"windowid\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"progpath\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"completed_item\",\t VAR_DICT), &t_dict_string, VV_RO},\n    {VV_NAME(\"option_new\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_old\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_oldlocal\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_oldglobal\", VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_command\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"option_type\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"errors\",\t\t VAR_LIST), &t_list_string, 0},\n    {VV_NAME(\"false\",\t\t VAR_BOOL), NULL, VV_RO},\n    {VV_NAME(\"true\",\t\t VAR_BOOL), NULL, VV_RO},\n    {VV_NAME(\"none\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"null\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"numbermax\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"numbermin\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"numbersize\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"vim_did_enter\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"testing\",\t\t VAR_NUMBER), NULL, 0},\n    {VV_NAME(\"t_number\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_string\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_func\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_list\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_dict\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_float\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_bool\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_none\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_job\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_channel\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"t_blob\",\t\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"termrfgresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termrbgresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termu7resp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termstyleresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"termblinkresp\",\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"event\",\t\t VAR_DICT), NULL, VV_RO},\n    {VV_NAME(\"versionlong\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"echospace\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"argv\",\t\t VAR_LIST), &t_list_string, VV_RO},\n    {VV_NAME(\"collate\",\t\t VAR_STRING), NULL, VV_RO},\n    {VV_NAME(\"exiting\",\t\t VAR_SPECIAL), NULL, VV_RO},\n    {VV_NAME(\"colornames\",       VAR_DICT), &t_dict_string, VV_RO},\n    {VV_NAME(\"sizeofint\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"sizeoflong\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"sizeofpointer\",\t VAR_NUMBER), NULL, VV_RO},\n    {VV_NAME(\"maxcol\",\t\t VAR_NUMBER), NULL, VV_RO},\n};\n\n// shorthand\n#define vv_tv_type\tvv_di.di_tv.v_type\n#define vv_nr\t\tvv_di.di_tv.vval.v_number\n#define vv_float\tvv_di.di_tv.vval.v_float\n#define vv_str\t\tvv_di.di_tv.vval.v_string\n#define vv_list\t\tvv_di.di_tv.vval.v_list\n#define vv_dict\t\tvv_di.di_tv.vval.v_dict\n#define vv_blob\t\tvv_di.di_tv.vval.v_blob\n#define vv_tv\t\tvv_di.di_tv\n\nstatic dictitem_T\tvimvars_var;\t\t// variable used for v:\nstatic dict_T\t\tvimvardict;\t\t// Dictionary with v: variables\n#define vimvarht  vimvardict.dv_hashtab\n\n// for VIM_VERSION_ defines\n#include \"version.h\"\n\nstatic void list_glob_vars(int *first);\nstatic void list_buf_vars(int *first);\nstatic void list_win_vars(int *first);\nstatic void list_tab_vars(int *first);\nstatic char_u *list_arg_vars(exarg_T *eap, char_u *arg, int *first);\nstatic char_u *ex_let_one(char_u *arg, typval_T *tv, int copy, int flags, char_u *endchars, char_u *op, int var_idx);\nstatic int do_unlet_var(lval_T *lp, char_u *name_end, exarg_T *eap, int deep, void *cookie);\nstatic int do_lock_var(lval_T *lp, char_u *name_end, exarg_T *eap, int deep, void *cookie);\nstatic void list_one_var(dictitem_T *v, char *prefix, int *first);\nstatic void list_one_var_a(char *prefix, char_u *name, int type, char_u *string, int *first);\n\n/*\n * Initialize global and vim special variables\n */\n    void\nevalvars_init(void)\n{\n    int\t\t    i;\n    struct vimvar   *p;\n\n    init_var_dict(&globvardict, &globvars_var, VAR_DEF_SCOPE);\n    init_var_dict(&vimvardict, &vimvars_var, VAR_SCOPE);\n    vimvardict.dv_lock = VAR_FIXED;\n    hash_init(&compat_hashtab);\n\n    for (i = 0; i < VV_LEN; ++i)\n    {\n\tp = &vimvars[i];\n\tif (STRLEN(p->vv_name) > DICTITEM16_KEY_LEN)\n\t{\n\t    iemsg(\"INTERNAL: name too long, increase size of dictitem16_T\");\n\t    getout(1);\n\t}\n\tSTRCPY(p->vv_di.di_key, p->vv_name);\n\tif (p->vv_flags & VV_RO)\n\t    p->vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\telse if (p->vv_flags & VV_RO_SBX)\n\t    p->vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;\n\telse\n\t    p->vv_di.di_flags = DI_FLAGS_FIX;\n\n\t// add to v: scope dict, unless the value is not always available\n\tif (p->vv_tv_type != VAR_UNKNOWN)\n\t    hash_add(&vimvarht, p->vv_di.di_key);\n\tif (p->vv_flags & VV_COMPAT)\n\t    // add to compat scope dict\n\t    hash_add(&compat_hashtab, p->vv_di.di_key);\n    }\n    set_vim_var_nr(VV_VERSION, VIM_VERSION_100);\n    set_vim_var_nr(VV_VERSIONLONG, VIM_VERSION_100 * 10000 + highest_patch());\n\n    set_vim_var_nr(VV_SEARCHFORWARD, 1L);\n    set_vim_var_nr(VV_HLSEARCH, 1L);\n    set_vim_var_nr(VV_EXITING, VVAL_NULL);\n    set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc_lock(VAR_FIXED));\n    set_vim_var_list(VV_ERRORS, list_alloc());\n    set_vim_var_dict(VV_EVENT, dict_alloc_lock(VAR_FIXED));\n\n    set_vim_var_nr(VV_FALSE, VVAL_FALSE);\n    set_vim_var_nr(VV_TRUE, VVAL_TRUE);\n    set_vim_var_nr(VV_NONE, VVAL_NONE);\n    set_vim_var_nr(VV_NULL, VVAL_NULL);\n    set_vim_var_nr(VV_NUMBERMAX, VARNUM_MAX);\n    set_vim_var_nr(VV_NUMBERMIN, VARNUM_MIN);\n    set_vim_var_nr(VV_NUMBERSIZE, sizeof(varnumber_T) * 8);\n    set_vim_var_nr(VV_SIZEOFINT, sizeof(int));\n    set_vim_var_nr(VV_SIZEOFLONG, sizeof(long));\n    set_vim_var_nr(VV_SIZEOFPOINTER, sizeof(char *));\n    set_vim_var_nr(VV_MAXCOL, MAXCOL);\n\n    set_vim_var_nr(VV_TYPE_NUMBER,  VAR_TYPE_NUMBER);\n    set_vim_var_nr(VV_TYPE_STRING,  VAR_TYPE_STRING);\n    set_vim_var_nr(VV_TYPE_FUNC,    VAR_TYPE_FUNC);\n    set_vim_var_nr(VV_TYPE_LIST,    VAR_TYPE_LIST);\n    set_vim_var_nr(VV_TYPE_DICT,    VAR_TYPE_DICT);\n    set_vim_var_nr(VV_TYPE_FLOAT,   VAR_TYPE_FLOAT);\n    set_vim_var_nr(VV_TYPE_BOOL,    VAR_TYPE_BOOL);\n    set_vim_var_nr(VV_TYPE_NONE,    VAR_TYPE_NONE);\n    set_vim_var_nr(VV_TYPE_JOB,     VAR_TYPE_JOB);\n    set_vim_var_nr(VV_TYPE_CHANNEL, VAR_TYPE_CHANNEL);\n    set_vim_var_nr(VV_TYPE_BLOB,    VAR_TYPE_BLOB);\n\n    set_vim_var_nr(VV_ECHOSPACE,    sc_col - 1);\n\n    set_vim_var_dict(VV_COLORNAMES, dict_alloc());\n\n    // Default for v:register is not 0 but '\"'.  This is adjusted once the\n    // clipboard has been setup by calling reset_reg_var().\n    set_reg_var(0);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all vim variables information on exit\n */\n    void\nevalvars_clear(void)\n{\n    int\t\t    i;\n    struct vimvar   *p;\n\n    for (i = 0; i < VV_LEN; ++i)\n    {\n\tp = &vimvars[i];\n\tif (p->vv_di.di_tv.v_type == VAR_STRING)\n\t    VIM_CLEAR(p->vv_str);\n\telse if (p->vv_di.di_tv.v_type == VAR_LIST)\n\t{\n\t    list_unref(p->vv_list);\n\t    p->vv_list = NULL;\n\t}\n    }\n    hash_clear(&vimvarht);\n    hash_init(&vimvarht);  // garbage_collect() will access it\n    hash_clear(&compat_hashtab);\n\n    // global variables\n    vars_clear(&globvarht);\n\n    // Script-local variables. Clear all the variables here.\n    // The scriptvar_T is cleared later in free_scriptnames(), because a\n    // variable in one script might hold a reference to the whole scope of\n    // another script.\n    for (i = 1; i <= script_items.ga_len; ++i)\n\tvars_clear(&SCRIPT_VARS(i));\n}\n#endif\n\n    int\ngarbage_collect_globvars(int copyID)\n{\n    return set_ref_in_ht(&globvarht, copyID, NULL);\n}\n\n    int\ngarbage_collect_vimvars(int copyID)\n{\n    return set_ref_in_ht(&vimvarht, copyID, NULL);\n}\n\n    int\ngarbage_collect_scriptvars(int copyID)\n{\n    int\t\t    i;\n    int\t\t    idx;\n    int\t\t    abort = FALSE;\n    scriptitem_T    *si;\n\n    for (i = 1; i <= script_items.ga_len; ++i)\n    {\n\tabort = abort || set_ref_in_ht(&SCRIPT_VARS(i), copyID, NULL);\n\n\tsi = SCRIPT_ITEM(i);\n\tfor (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n\t{\n\t    svar_T    *sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t    if (sv->sv_name != NULL)\n\t\tabort = abort || set_ref_in_item(sv->sv_tv, copyID, NULL, NULL);\n\t}\n    }\n\n    return abort;\n}\n\n/*\n * Set an internal variable to a string value. Creates the variable if it does\n * not already exist.\n */\n    void\nset_internal_string_var(char_u *name, char_u *value)\n{\n    char_u\t*val;\n    typval_T\t*tvp;\n\n    val = vim_strsave(value);\n    if (val != NULL)\n    {\n\ttvp = alloc_string_tv(val);\n\tif (tvp != NULL)\n\t{\n\t    set_var(name, tvp, FALSE);\n\t    free_tv(tvp);\n\t}\n    }\n}\n\n    int\neval_charconvert(\n    char_u\t*enc_from,\n    char_u\t*enc_to,\n    char_u\t*fname_from,\n    char_u\t*fname_to)\n{\n    int\t\terr = FALSE;\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    set_vim_var_string(VV_CC_FROM, enc_from, -1);\n    set_vim_var_string(VV_CC_TO, enc_to, -1);\n    set_vim_var_string(VV_FNAME_IN, fname_from, -1);\n    set_vim_var_string(VV_FNAME_OUT, fname_to, -1);\n    ctx = get_option_sctx(\"charconvert\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval_to_bool(p_ccv, &err, NULL, FALSE))\n\terr = TRUE;\n\n    set_vim_var_string(VV_CC_FROM, NULL, -1);\n    set_vim_var_string(VV_CC_TO, NULL, -1);\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n\n    if (err)\n\treturn FAIL;\n    return OK;\n}\n\n# if defined(FEAT_POSTSCRIPT) || defined(PROTO)\n    int\neval_printexpr(char_u *fname, char_u *args)\n{\n    int\t\terr = FALSE;\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    set_vim_var_string(VV_FNAME_IN, fname, -1);\n    set_vim_var_string(VV_CMDARG, args, -1);\n    ctx = get_option_sctx(\"printexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval_to_bool(p_pexpr, &err, NULL, FALSE))\n\terr = TRUE;\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_CMDARG, NULL, -1);\n    current_sctx = saved_sctx;\n\n    if (err)\n    {\n\tmch_remove(fname);\n\treturn FAIL;\n    }\n    return OK;\n}\n# endif\n\n# if defined(FEAT_DIFF) || defined(PROTO)\n    void\neval_diff(\n    char_u\t*origfile,\n    char_u\t*newfile,\n    char_u\t*outfile)\n{\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n    typval_T\t*tv;\n\n    set_vim_var_string(VV_FNAME_IN, origfile, -1);\n    set_vim_var_string(VV_FNAME_NEW, newfile, -1);\n    set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n\n    ctx = get_option_sctx(\"diffexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    // errors are ignored\n    tv = eval_expr(p_dex, NULL);\n    free_tv(tv);\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_NEW, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n}\n\n    void\neval_patch(\n    char_u\t*origfile,\n    char_u\t*difffile,\n    char_u\t*outfile)\n{\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n    typval_T\t*tv;\n\n    set_vim_var_string(VV_FNAME_IN, origfile, -1);\n    set_vim_var_string(VV_FNAME_DIFF, difffile, -1);\n    set_vim_var_string(VV_FNAME_OUT, outfile, -1);\n\n    ctx = get_option_sctx(\"patchexpr\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    // errors are ignored\n    tv = eval_expr(p_pex, NULL);\n    free_tv(tv);\n\n    set_vim_var_string(VV_FNAME_IN, NULL, -1);\n    set_vim_var_string(VV_FNAME_DIFF, NULL, -1);\n    set_vim_var_string(VV_FNAME_OUT, NULL, -1);\n    current_sctx = saved_sctx;\n}\n# endif\n\n#if defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Evaluate an expression to a list with suggestions.\n * For the \"expr:\" part of 'spellsuggest'.\n * Returns NULL when there is an error.\n */\n    list_T *\neval_spell_expr(char_u *badword, char_u *expr)\n{\n    typval_T\tsave_val;\n    typval_T\trettv;\n    list_T\t*list = NULL;\n    char_u\t*p = skipwhite(expr);\n    sctx_T\tsaved_sctx = current_sctx;\n    sctx_T\t*ctx;\n\n    // Set \"v:val\" to the bad word.\n    prepare_vimvar(VV_VAL, &save_val);\n    set_vim_var_string(VV_VAL, badword, -1);\n    if (p_verbose == 0)\n\t++emsg_off;\n    ctx = get_option_sctx(\"spellsuggest\");\n    if (ctx != NULL)\n\tcurrent_sctx = *ctx;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == OK)\n    {\n\tif (rettv.v_type != VAR_LIST)\n\t    clear_tv(&rettv);\n\telse\n\t    list = rettv.vval.v_list;\n    }\n\n    if (p_verbose == 0)\n\t--emsg_off;\n    clear_tv(get_vim_var_tv(VV_VAL));\n    restore_vimvar(VV_VAL, &save_val);\n    current_sctx = saved_sctx;\n\n    return list;\n}\n\n/*\n * \"list\" is supposed to contain two items: a word and a number.  Return the\n * word in \"pp\" and the number as the return value.\n * Return -1 if anything isn't right.\n * Used to get the good word and score from the eval_spell_expr() result.\n */\n    int\nget_spellword(list_T *list, char_u **pp)\n{\n    listitem_T\t*li;\n\n    li = list->lv_first;\n    if (li == NULL)\n\treturn -1;\n    *pp = tv_get_string(&li->li_tv);\n\n    li = li->li_next;\n    if (li == NULL)\n\treturn -1;\n    return (int)tv_get_number(&li->li_tv);\n}\n#endif\n\n/*\n * Prepare v: variable \"idx\" to be used.\n * Save the current typeval in \"save_tv\" and clear it.\n * When not used yet add the variable to the v: hashtable.\n */\n    void\nprepare_vimvar(int idx, typval_T *save_tv)\n{\n    *save_tv = vimvars[idx].vv_tv;\n    vimvars[idx].vv_str = NULL;  // don't free it now\n    if (vimvars[idx].vv_tv_type == VAR_UNKNOWN)\n\thash_add(&vimvarht, vimvars[idx].vv_di.di_key);\n}\n\n/*\n * Restore v: variable \"idx\" to typeval \"save_tv\".\n * Note that the v: variable must have been cleared already.\n * When no longer defined, remove the variable from the v: hashtable.\n */\n    void\nrestore_vimvar(int idx, typval_T *save_tv)\n{\n    hashitem_T\t*hi;\n\n    vimvars[idx].vv_tv = *save_tv;\n    if (vimvars[idx].vv_tv_type == VAR_UNKNOWN)\n    {\n\thi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);\n\tif (HASHITEM_EMPTY(hi))\n\t    internal_error(\"restore_vimvar()\");\n\telse\n\t    hash_remove(&vimvarht, hi);\n    }\n}\n\n/*\n * List Vim variables.\n */\n    static void\nlist_vim_vars(int *first)\n{\n    list_hashtable_vars(&vimvarht, \"v:\", FALSE, first);\n}\n\n/*\n * List script-local variables, if there is a script.\n */\n    static void\nlist_script_vars(int *first)\n{\n    if (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\tlist_hashtable_vars(&SCRIPT_VARS(current_sctx.sc_sid),\n\t\t\t\t\t\t\t   \"s:\", FALSE, first);\n}\n\n/*\n * Get a list of lines from a HERE document. The here document is a list of\n * lines surrounded by a marker.\n *\tcmd << {marker}\n *\t  {line1}\n *\t  {line2}\n *\t  ....\n *\t{marker}\n *\n * The {marker} is a string. If the optional 'trim' word is supplied before the\n * marker, then the leading indentation before the lines (matching the\n * indentation in the 'cmd' line) is stripped.\n *\n * When getting lines for an embedded script (e.g. python, lua, perl, ruby,\n * tcl, mzscheme), script_get is set to TRUE. In this case, if the marker is\n * missing, then '.' is accepted as a marker.\n *\n * Returns a List with {lines} or NULL.\n */\n    list_T *\nheredoc_get(exarg_T *eap, char_u *cmd, int script_get)\n{\n    char_u\t*theline;\n    char_u\t*marker;\n    list_T\t*l;\n    char_u\t*p;\n    int\t\tmarker_indent_len = 0;\n    int\t\ttext_indent_len = 0;\n    char_u\t*text_indent = NULL;\n    char_u\tdot[] = \".\";\n    int\t\tcomment_char = in_vim9script() ? '#' : '\"';\n\n    if (eap->getline == NULL)\n    {\n\temsg(_(e_cannot_use_heredoc_here));\n\treturn NULL;\n    }\n\n    // Check for the optional 'trim' word before the marker\n    cmd = skipwhite(cmd);\n    if (STRNCMP(cmd, \"trim\", 4) == 0 && (cmd[4] == NUL || VIM_ISWHITE(cmd[4])))\n    {\n\tcmd = skipwhite(cmd + 4);\n\n\t// Trim the indentation from all the lines in the here document.\n\t// The amount of indentation trimmed is the same as the indentation of\n\t// the first line after the :let command line.  To find the end marker\n\t// the indent of the :let command line is trimmed.\n\tp = *eap->cmdlinep;\n\twhile (VIM_ISWHITE(*p))\n\t{\n\t    p++;\n\t    marker_indent_len++;\n\t}\n\ttext_indent_len = -1;\n    }\n\n    // The marker is the next word.\n    if (*cmd != NUL && *cmd != comment_char)\n    {\n\tmarker = skipwhite(cmd);\n\tp = skiptowhite(marker);\n\tif (*skipwhite(p) != NUL && *skipwhite(p) != comment_char)\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\t*p = NUL;\n\tif (!script_get && vim_islower(*marker))\n\t{\n\t    emsg(_(e_marker_cannot_start_with_lower_case_letter));\n\t    return NULL;\n\t}\n    }\n    else\n    {\n\t// When getting lines for an embedded script, if the marker is missing,\n\t// accept '.' as the marker.\n\tif (script_get)\n\t    marker = dot;\n\telse\n\t{\n\t    emsg(_(e_missing_marker));\n\t    return NULL;\n\t}\n    }\n\n    l = list_alloc();\n    if (l == NULL)\n\treturn NULL;\n\n    for (;;)\n    {\n\tint\tmi = 0;\n\tint\tti = 0;\n\n\ttheline = eap->getline(NUL, eap->cookie, 0, FALSE);\n\tif (theline == NULL)\n\t{\n\t    semsg(_(e_missing_end_marker_str), marker);\n\t    break;\n\t}\n\n\t// with \"trim\": skip the indent matching the :let line to find the\n\t// marker\n\tif (marker_indent_len > 0\n\t\t&& STRNCMP(theline, *eap->cmdlinep, marker_indent_len) == 0)\n\t    mi = marker_indent_len;\n\tif (STRCMP(marker, theline + mi) == 0)\n\t{\n\t    vim_free(theline);\n\t    break;\n\t}\n\n\tif (text_indent_len == -1 && *theline != NUL)\n\t{\n\t    // set the text indent from the first line.\n\t    p = theline;\n\t    text_indent_len = 0;\n\t    while (VIM_ISWHITE(*p))\n\t    {\n\t\tp++;\n\t\ttext_indent_len++;\n\t    }\n\t    text_indent = vim_strnsave(theline, text_indent_len);\n\t}\n\t// with \"trim\": skip the indent matching the first line\n\tif (text_indent != NULL)\n\t    for (ti = 0; ti < text_indent_len; ++ti)\n\t\tif (theline[ti] != text_indent[ti])\n\t\t    break;\n\n\tif (list_append_string(l, theline + ti, -1) == FAIL)\n\t    break;\n\tvim_free(theline);\n    }\n    vim_free(text_indent);\n\n    return l;\n}\n\n/*\n * Vim9 variable declaration:\n * \":var name\"\n * \":var name: type\"\n * \":var name = expr\"\n * \":var name: type = expr\"\n * etc.\n */\n    void\nex_var(exarg_T *eap)\n{\n    if (!in_vim9script())\n    {\n\tsemsg(_(e_str_cannot_be_used_in_legacy_vim_script), \":var\");\n\treturn;\n    }\n    ex_let(eap);\n}\n\n/*\n * \":let\"\t\t\tlist all variable values\n * \":let var1 var2\"\t\tlist variable values\n * \":let var = expr\"\t\tassignment command.\n * \":let var += expr\"\t\tassignment command.\n * \":let var -= expr\"\t\tassignment command.\n * \":let var *= expr\"\t\tassignment command.\n * \":let var /= expr\"\t\tassignment command.\n * \":let var %= expr\"\t\tassignment command.\n * \":let var .= expr\"\t\tassignment command.\n * \":let var ..= expr\"\t\tassignment command.\n * \":let [var1, var2] = expr\"\tunpack list.\n * \":let var =<< ...\"\t\theredoc\n * \":let var: string\"\t\tVim9 declaration\n *\n * \":final var = expr\"\t\tassignment command.\n * \":final [var1, var2] = expr\"\tunpack list.\n *\n * \":const\"\t\t\tlist all variable values\n * \":const var1 var2\"\t\tlist variable values\n * \":const var = expr\"\t\tassignment command.\n * \":const [var1, var2] = expr\"\tunpack list.\n */\n    void\nex_let(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*expr = NULL;\n    typval_T\trettv;\n    int\t\ti;\n    int\t\tvar_count = 0;\n    int\t\tsemicolon = 0;\n    char_u\top[4];\n    char_u\t*argend;\n    int\t\tfirst = TRUE;\n    int\t\tconcat;\n    int\t\thas_assign;\n    int\t\tflags = 0;\n    int\t\tvim9script = in_vim9script();\n\n    if (eap->cmdidx == CMD_final && !vim9script)\n    {\n\t// In legacy Vim script \":final\" is short for \":finally\".\n\tex_finally(eap);\n\treturn;\n    }\n    if (eap->cmdidx == CMD_let && vim9script)\n    {\n\temsg(_(e_cannot_use_let_in_vim9_script));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_const)\n\tflags |= ASSIGN_CONST;\n    else if (eap->cmdidx == CMD_final)\n\tflags |= ASSIGN_FINAL;\n\n    // Vim9 assignment without \":let\", \":const\" or \":final\"\n    if (eap->arg == eap->cmd)\n\tflags |= ASSIGN_NO_DECL;\n\n    argend = skip_var_list(arg, TRUE, &var_count, &semicolon, FALSE);\n    if (argend == NULL)\n\treturn;\n    if (argend > arg && argend[-1] == '.')  // for var.='str'\n\t--argend;\n    expr = skipwhite(argend);\n    concat = expr[0] == '.'\n\t&& ((expr[1] == '=' && in_old_script(2))\n\t\t|| (expr[1] == '.' && expr[2] == '='));\n    has_assign =  *expr == '=' || (vim_strchr((char_u *)\"+-*/%\", *expr) != NULL\n\t\t\t\t\t\t\t    && expr[1] == '=');\n    if (!has_assign && !concat)\n    {\n\t// \":let\" without \"=\": list variables\n\tif (*arg == '[')\n\t    emsg(_(e_invalid_argument));\n\telse if (expr[0] == '.' && expr[1] == '=')\n\t    emsg(_(e_dot_equal_not_supported_with_script_version_two));\n\telse if (!ends_excmd2(eap->cmd, arg))\n\t{\n\t    if (vim9script)\n\t    {\n\t\tif (!ends_excmd2(eap->cmd, skipwhite(argend)))\n\t\t    semsg(_(e_trailing_characters_str), argend);\n\t\telse\n\t\t    // Vim9 declaration \":var name: type\"\n\t\t    arg = vim9_declare_scriptvar(eap, arg);\n\t    }\n\t    else\n\t    {\n\t\t// \":let var1 var2\" - list values\n\t\targ = list_arg_vars(eap, arg, &first);\n\t    }\n\t}\n\telse if (!eap->skip)\n\t{\n\t    // \":let\"\n\t    list_glob_vars(&first);\n\t    list_buf_vars(&first);\n\t    list_win_vars(&first);\n\t    list_tab_vars(&first);\n\t    list_script_vars(&first);\n\t    list_func_vars(&first);\n\t    list_vim_vars(&first);\n\t}\n\tset_nextcmd(eap, arg);\n    }\n    else if (expr[0] == '=' && expr[1] == '<' && expr[2] == '<')\n    {\n\tlist_T\t*l;\n\tlong\tcur_lnum = SOURCING_LNUM;\n\n\t// HERE document\n\tl = heredoc_get(eap, expr + 3, FALSE);\n\tif (l != NULL)\n\t{\n\t    rettv_list_set(&rettv, l);\n\t    if (!eap->skip)\n\t    {\n\t\t// errors are for the assignment, not the end marker\n\t\tSOURCING_LNUM = cur_lnum;\n\t\top[0] = '=';\n\t\top[1] = NUL;\n\t\t(void)ex_let_vars(eap->arg, &rettv, FALSE, semicolon, var_count,\n\t\t\t\t\t\t\t\tflags, op);\n\t    }\n\t    clear_tv(&rettv);\n\t}\n    }\n    else\n    {\n\tevalarg_T   evalarg;\n\tint\t    len = 1;\n\n\tCLEAR_FIELD(rettv);\n\ti = FAIL;\n\tif (has_assign || concat)\n\t{\n\t    int cur_lnum;\n\n\t    op[0] = '=';\n\t    op[1] = NUL;\n\t    if (*expr != '=')\n\t    {\n\t\tif (vim9script && (flags & ASSIGN_NO_DECL) == 0)\n\t\t{\n\t\t    // +=, /=, etc. require an existing variable\n\t\t    semsg(_(e_cannot_use_operator_on_new_variable), eap->arg);\n\t\t    i = FAIL;\n\t\t}\n\t\telse if (vim_strchr((char_u *)\"+-*/%.\", *expr) != NULL)\n\t\t{\n\t\t    op[0] = *expr;   // +=, -=, *=, /=, %= or .=\n\t\t    ++len;\n\t\t    if (expr[0] == '.' && expr[1] == '.') // ..=\n\t\t    {\n\t\t\t++expr;\n\t\t\t++len;\n\t\t    }\n\t\t}\n\t\texpr += 2;\n\t    }\n\t    else\n\t\t++expr;\n\n\t    if (vim9script && !eap->skip && (!VIM_ISWHITE(*argend)\n\t\t\t\t\t\t   || !IS_WHITE_OR_NUL(*expr)))\n\t    {\n\t\tvim_strncpy(op, expr - len, len);\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t   op, argend);\n\t\ti = FAIL;\n\t    }\n\n\t    if (eap->skip)\n\t\t++emsg_skip;\n\t    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\t    expr = skipwhite_and_linebreak(expr, &evalarg);\n\t    cur_lnum = SOURCING_LNUM;\n\t    i = eval0(expr, &rettv, eap, &evalarg);\n\t    if (eap->skip)\n\t\t--emsg_skip;\n\t    clear_evalarg(&evalarg, eap);\n\n\t    // Restore the line number so that any type error is given for the\n\t    // declaration, not the expression.\n\t    SOURCING_LNUM = cur_lnum;\n\t}\n\tif (eap->skip)\n\t{\n\t    if (i != FAIL)\n\t\tclear_tv(&rettv);\n\t}\n\telse if (i != FAIL)\n\t{\n\t    (void)ex_let_vars(eap->arg, &rettv, FALSE, semicolon, var_count,\n\t\t\t\t\t\t\t\t    flags, op);\n\t    clear_tv(&rettv);\n\t}\n    }\n}\n\n/*\n * Assign the typeval \"tv\" to the variable or variables at \"arg_start\".\n * Handles both \"var\" with any type and \"[var, var; var]\" with a list type.\n * When \"op\" is not NULL it points to a string with characters that\n * must appear after the variable(s).  Use \"+\", \"-\" or \".\" for add, subtract\n * or concatenate.\n * Returns OK or FAIL;\n */\n    int\nex_let_vars(\n    char_u\t*arg_start,\n    typval_T\t*tv,\n    int\t\tcopy,\t\t// copy values from \"tv\", don't move\n    int\t\tsemicolon,\t// from skip_var_list()\n    int\t\tvar_count,\t// from skip_var_list()\n    int\t\tflags,\t\t// ASSIGN_FINAL, ASSIGN_CONST, etc.\n    char_u\t*op)\n{\n    char_u\t*arg = arg_start;\n    list_T\t*l;\n    int\t\ti;\n    int\t\tvar_idx = 0;\n    listitem_T\t*item;\n    typval_T\tltv;\n\n    if (*arg != '[')\n    {\n\t// \":let var = expr\" or \":for var in list\"\n\tif (ex_let_one(arg, tv, copy, flags, op, op, var_idx) == NULL)\n\t    return FAIL;\n\treturn OK;\n    }\n\n    // \":let [v1, v2] = list\" or \":for [v1, v2] in listlist\"\n    if (tv->v_type != VAR_LIST || (l = tv->vval.v_list) == NULL)\n    {\n\temsg(_(e_list_required));\n\treturn FAIL;\n    }\n\n    i = list_len(l);\n    if (semicolon == 0 && var_count < i)\n    {\n\temsg(_(e_less_targets_than_list_items));\n\treturn FAIL;\n    }\n    if (var_count - semicolon > i)\n    {\n\temsg(_(e_more_targets_than_list_items));\n\treturn FAIL;\n    }\n\n    CHECK_LIST_MATERIALIZE(l);\n    item = l->lv_first;\n    while (*arg != ']')\n    {\n\targ = skipwhite(arg + 1);\n\t++var_idx;\n\targ = ex_let_one(arg, &item->li_tv, TRUE,\n\t\t\t  flags | ASSIGN_UNPACK, (char_u *)\",;]\", op, var_idx);\n\titem = item->li_next;\n\tif (arg == NULL)\n\t    return FAIL;\n\n\targ = skipwhite(arg);\n\tif (*arg == ';')\n\t{\n\t    // Put the rest of the list (may be empty) in the var after ';'.\n\t    // Create a new list for this.\n\t    l = list_alloc();\n\t    if (l == NULL)\n\t\treturn FAIL;\n\t    while (item != NULL)\n\t    {\n\t\tlist_append_tv(l, &item->li_tv);\n\t\titem = item->li_next;\n\t    }\n\n\t    ltv.v_type = VAR_LIST;\n\t    ltv.v_lock = 0;\n\t    ltv.vval.v_list = l;\n\t    l->lv_refcount = 1;\n\t    ++var_idx;\n\n\t    arg = ex_let_one(skipwhite(arg + 1), &ltv, FALSE,\n\t\t\t    flags | ASSIGN_UNPACK, (char_u *)\"]\", op, var_idx);\n\t    clear_tv(&ltv);\n\t    if (arg == NULL)\n\t\treturn FAIL;\n\t    break;\n\t}\n\telse if (*arg != ',' && *arg != ']')\n\t{\n\t    internal_error(\"ex_let_vars()\");\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Skip over assignable variable \"var\" or list of variables \"[var, var]\".\n * Used for \":let varvar = expr\" and \":for varvar in expr\".\n * For \"[var, var]\" increment \"*var_count\" for each variable.\n * for \"[var, var; var]\" set \"semicolon\" to 1.\n * If \"silent\" is TRUE do not give an \"invalid argument\" error message.\n * Return NULL for an error.\n */\n    char_u *\nskip_var_list(\n    char_u\t*arg,\n    int\t\tinclude_type,\n    int\t\t*var_count,\n    int\t\t*semicolon,\n    int\t\tsilent)\n{\n    char_u\t*p, *s;\n\n    if (*arg == '[')\n    {\n\t// \"[var, var]\": find the matching ']'.\n\tp = arg;\n\tfor (;;)\n\t{\n\t    p = skipwhite(p + 1);\t// skip whites after '[', ';' or ','\n\t    s = skip_var_one(p, include_type);\n\t    if (s == p)\n\t    {\n\t\tif (!silent)\n\t\t    semsg(_(e_invalid_argument_str), p);\n\t\treturn NULL;\n\t    }\n\t    ++*var_count;\n\n\t    p = skipwhite(s);\n\t    if (*p == ']')\n\t\tbreak;\n\t    else if (*p == ';')\n\t    {\n\t\tif (*semicolon == 1)\n\t\t{\n\t\t    if (!silent)\n\t\t\temsg(_(e_double_semicolon_in_list_of_variables));\n\t\t    return NULL;\n\t\t}\n\t\t*semicolon = 1;\n\t    }\n\t    else if (*p != ',')\n\t    {\n\t\tif (!silent)\n\t\t    semsg(_(e_invalid_argument_str), p);\n\t\treturn NULL;\n\t    }\n\t}\n\treturn p + 1;\n    }\n    else\n\treturn skip_var_one(arg, include_type);\n}\n\n/*\n * Skip one (assignable) variable name, including @r, $VAR, &option, d.key,\n * l[idx].\n * In Vim9 script also skip over \": type\" if \"include_type\" is TRUE.\n */\n    char_u *\nskip_var_one(char_u *arg, int include_type)\n{\n    char_u\t*end;\n    int\t\tvim9 = in_vim9script();\n\n    if (*arg == '@' && arg[1] != NUL)\n\treturn arg + 2;\n    end = find_name_end(*arg == '$' || *arg == '&' ? arg + 1 : arg,\n\t\t\t\t   NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);\n\n    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n    // Same for \"s: type\".\n    if (vim9 && end == arg + 2 && end[-1] == ':')\n\t--end;\n\n    if (include_type && vim9)\n    {\n\tif (*end == ':')\n\t    end = skip_type(skipwhite(end + 1), FALSE);\n    }\n    return end;\n}\n\n/*\n * List variables for hashtab \"ht\" with prefix \"prefix\".\n * If \"empty\" is TRUE also list NULL strings as empty strings.\n */\n    void\nlist_hashtable_vars(\n    hashtab_T\t*ht,\n    char\t*prefix,\n    int\t\tempty,\n    int\t\t*first)\n{\n    hashitem_T\t*hi;\n    dictitem_T\t*di;\n    int\t\ttodo;\n    char_u\tbuf[IOSIZE];\n\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    di = HI2DI(hi);\n\n\t    // apply :filter /pat/ to variable name\n\t    vim_strncpy((char_u *)buf, (char_u *)prefix, IOSIZE - 1);\n\t    vim_strcat((char_u *)buf, di->di_key, IOSIZE);\n\t    if (message_filtered(buf))\n\t\tcontinue;\n\n\t    if (empty || di->di_tv.v_type != VAR_STRING\n\t\t\t\t\t   || di->di_tv.vval.v_string != NULL)\n\t\tlist_one_var(di, prefix, first);\n\t}\n    }\n}\n\n/*\n * List global variables.\n */\n    static void\nlist_glob_vars(int *first)\n{\n    list_hashtable_vars(&globvarht, \"\", TRUE, first);\n}\n\n/*\n * List buffer variables.\n */\n    static void\nlist_buf_vars(int *first)\n{\n    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, \"b:\", TRUE, first);\n}\n\n/*\n * List window variables.\n */\n    static void\nlist_win_vars(int *first)\n{\n    list_hashtable_vars(&curwin->w_vars->dv_hashtab, \"w:\", TRUE, first);\n}\n\n/*\n * List tab page variables.\n */\n    static void\nlist_tab_vars(int *first)\n{\n    list_hashtable_vars(&curtab->tp_vars->dv_hashtab, \"t:\", TRUE, first);\n}\n\n/*\n * List variables in \"arg\".\n */\n    static char_u *\nlist_arg_vars(exarg_T *eap, char_u *arg, int *first)\n{\n    int\t\terror = FALSE;\n    int\t\tlen;\n    char_u\t*name;\n    char_u\t*name_start;\n    char_u\t*arg_subsc;\n    char_u\t*tofree;\n    typval_T    tv;\n\n    while (!ends_excmd2(eap->cmd, arg) && !got_int)\n    {\n\tif (error || eap->skip)\n\t{\n\t    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);\n\t    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))\n\t    {\n\t\temsg_severe = TRUE;\n\t\tif (!did_emsg)\n\t\t    semsg(_(e_trailing_characters_str), arg);\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t{\n\t    // get_name_len() takes care of expanding curly braces\n\t    name_start = name = arg;\n\t    len = get_name_len(&arg, &tofree, TRUE, TRUE);\n\t    if (len <= 0)\n\t    {\n\t\t// This is mainly to keep test 49 working: when expanding\n\t\t// curly braces fails overrule the exception error message.\n\t\tif (len < 0 && !aborting())\n\t\t{\n\t\t    emsg_severe = TRUE;\n\t\t    semsg(_(e_invalid_argument_str), arg);\n\t\t    break;\n\t\t}\n\t\terror = TRUE;\n\t    }\n\t    else\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (tofree != NULL)\n\t\t    name = tofree;\n\t\tif (eval_variable(name, len, 0, &tv, NULL,\n\t\t\t\t\t\t     EVAL_VAR_VERBOSE) == FAIL)\n\t\t    error = TRUE;\n\t\telse\n\t\t{\n\t\t    // handle d.key, l[idx], f(expr)\n\t\t    arg_subsc = arg;\n\t\t    if (handle_subscript(&arg, name_start, &tv,\n\t\t\t\t\t      &EVALARG_EVALUATE, TRUE) == FAIL)\n\t\t\terror = TRUE;\n\t\t    else\n\t\t    {\n\t\t\tif (arg == arg_subsc && len == 2 && name[1] == ':')\n\t\t\t{\n\t\t\t    switch (*name)\n\t\t\t    {\n\t\t\t\tcase 'g': list_glob_vars(first); break;\n\t\t\t\tcase 'b': list_buf_vars(first); break;\n\t\t\t\tcase 'w': list_win_vars(first); break;\n\t\t\t\tcase 't': list_tab_vars(first); break;\n\t\t\t\tcase 'v': list_vim_vars(first); break;\n\t\t\t\tcase 's': list_script_vars(first); break;\n\t\t\t\tcase 'l': list_func_vars(first); break;\n\t\t\t\tdefault:\n\t\t\t\t\t  semsg(_(e_cant_list_variables_for_str), name);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    char_u\tnumbuf[NUMBUFLEN];\n\t\t\t    char_u\t*tf;\n\t\t\t    int\t\tc;\n\t\t\t    char_u\t*s;\n\n\t\t\t    s = echo_string(&tv, &tf, numbuf, 0);\n\t\t\t    c = *arg;\n\t\t\t    *arg = NUL;\n\t\t\t    list_one_var_a(\"\",\n\t\t\t\t    arg == arg_subsc ? name : name_start,\n\t\t\t\t    tv.v_type,\n\t\t\t\t    s == NULL ? (char_u *)\"\" : s,\n\t\t\t\t    first);\n\t\t\t    *arg = c;\n\t\t\t    vim_free(tf);\n\t\t\t}\n\t\t\tclear_tv(&tv);\n\t\t    }\n\t\t}\n\t    }\n\n\t    vim_free(tofree);\n\t}\n\n\targ = skipwhite(arg);\n    }\n\n    return arg;\n}\n\n/*\n * Set an environment variable, part of ex_let_one().\n */\n    static char_u *\nex_let_env(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*arg_end = NULL;\n    char_u\t*name;\n    int\t\tlen;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_environment_variable));\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    ++arg;\n    name = arg;\n    len = get_env_len(&arg);\n    if (len == 0)\n\tsemsg(_(e_invalid_argument_str), name - 1);\n    else\n    {\n\tif (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t    semsg(_(e_wrong_variable_type_for_str_equal), op);\n\telse if (endchars != NULL\n\t\t\t      && vim_strchr(endchars, *skipwhite(arg)) == NULL)\n\t    emsg(_(e_unexpected_characters_in_let));\n\telse if (!check_secure())\n\t{\n\t    char_u\t*tofree = NULL;\n\t    int\t\tc1 = name[len];\n\t    char_u\t*p;\n\n\t    name[len] = NUL;\n\t    p = tv_get_string_chk(tv);\n\t    if (p != NULL && op != NULL && *op == '.')\n\t    {\n\t\tint\tmustfree = FALSE;\n\t\tchar_u  *s = vim_getenv(name, &mustfree);\n\n\t\tif (s != NULL)\n\t\t{\n\t\t    p = tofree = concat_str(s, p);\n\t\t    if (mustfree)\n\t\t\tvim_free(s);\n\t\t}\n\t    }\n\t    if (p != NULL)\n\t    {\n\t\tvim_setenv_ext(name, p);\n\t\targ_end = arg;\n\t    }\n\t    name[len] = c1;\n\t    vim_free(tofree);\n\t}\n    }\n    return arg_end;\n}\n\n/*\n * Set an option, part of ex_let_one().\n */\n    static char_u *\nex_let_option(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*p;\n    int\t\tscope;\n    char_u\t*arg_end = NULL;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_option));\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_option_end(&arg, &scope);\n    if (p == NULL || (endchars != NULL\n\t\t\t       && vim_strchr(endchars, *skipwhite(p)) == NULL))\n\temsg(_(e_unexpected_characters_in_let));\n    else\n    {\n\tint\t    c1;\n\tlong\t    n = 0;\n\tgetoption_T opt_type;\n\tlong\t    numval;\n\tchar_u\t    *stringval = NULL;\n\tchar_u\t    *s = NULL;\n\tint\t    failed = FALSE;\n\tint\t    opt_p_flags;\n\tchar_u\t    *tofree = NULL;\n\tchar_u\t    numbuf[NUMBUFLEN];\n\n\tc1 = *p;\n\t*p = NUL;\n\n\topt_type = get_option_value(arg, &numval, &stringval, &opt_p_flags,\n\t\t\t\t\t\t\t\t\tscope);\n\tif ((opt_type == gov_bool\n\t\t    || opt_type == gov_number\n\t\t    || opt_type == gov_hidden_bool\n\t\t    || opt_type == gov_hidden_number)\n\t\t\t && (tv->v_type != VAR_STRING || !in_vim9script()))\n\t{\n\t    if (opt_type == gov_bool || opt_type == gov_hidden_bool)\n\t\t// bool, possibly hidden\n\t\tn = (long)tv_get_bool(tv);\n\t    else\n\t\t// number, possibly hidden\n\t\tn = (long)tv_get_number(tv);\n\t}\n\n\tif ((opt_p_flags & P_FUNC) && (tv->v_type == VAR_PARTIAL\n\t\t\t\t\t\t|| tv->v_type == VAR_FUNC))\n\t{\n\t    // If the option can be set to a function reference or a lambda\n\t    // and the passed value is a function reference, then convert it to\n\t    // the name (string) of the function reference.\n\t    s = tv2string(tv, &tofree, numbuf, 0);\n\t}\n\t// Avoid setting a string option to the text \"v:false\" or similar.\n\t// In Vim9 script also don't convert a number to string.\n\telse if (tv->v_type != VAR_BOOL && tv->v_type != VAR_SPECIAL\n\t\t\t && (!in_vim9script() || tv->v_type != VAR_NUMBER))\n\t    s = tv_get_string_chk(tv);\n\n\tif (op != NULL && *op != '=')\n\t{\n\t    if (((opt_type == gov_bool || opt_type == gov_number) && *op == '.')\n\t\t    || (opt_type == gov_string && *op != '.'))\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\tfailed = TRUE;  // don't set the value\n\n\t    }\n\t    else\n\t    {\n\t\t// number, in legacy script also bool\n\t\tif (opt_type == gov_number\n\t\t\t     || (opt_type == gov_bool && !in_vim9script()))\n\t\t{\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': n = numval + n; break;\n\t\t\tcase '-': n = numval - n; break;\n\t\t\tcase '*': n = numval * n; break;\n\t\t\tcase '/': n = (long)num_divide(numval, n,\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\tcase '%': n = (long)num_modulus(numval, n,\n\t\t\t\t\t\t\t       &failed); break;\n\t\t    }\n\t\t    s = NULL;\n\t\t}\n\t\telse if (opt_type == gov_string\n\t\t\t\t\t && stringval != NULL && s != NULL)\n\t\t{\n\t\t    // string\n\t\t    s = concat_str(stringval, s);\n\t\t    vim_free(stringval);\n\t\t    stringval = s;\n\t\t}\n\t    }\n\t}\n\n\tif (!failed)\n\t{\n\t    if (opt_type != gov_string || s != NULL)\n\t    {\n\t\tset_option_value(arg, n, s, scope);\n\t\targ_end = p;\n\t    }\n\t    else\n\t\temsg(_(e_string_required));\n\t}\n\t*p = c1;\n\tvim_free(stringval);\n\tvim_free(tofree);\n    }\n    return arg_end;\n}\n\n/*\n * Set a register, part of ex_let_one().\n */\n    static char_u *\nex_let_register(\n    char_u\t*arg,\n    typval_T\t*tv,\n    int\t\tflags,\n    char_u\t*endchars,\n    char_u\t*op)\n{\n    char_u\t*arg_end = NULL;\n\n    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t && (flags & ASSIGN_FOR_LOOP) == 0)\n    {\n\temsg(_(e_cannot_lock_register));\n\treturn NULL;\n    }\n    ++arg;\n    if (op != NULL && vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n    else if (endchars != NULL\n\t\t\t  && vim_strchr(endchars, *skipwhite(arg + 1)) == NULL)\n\temsg(_(e_unexpected_characters_in_let));\n    else\n    {\n\tchar_u\t*ptofree = NULL;\n\tchar_u\t*p;\n\n\tp = tv_get_string_chk(tv);\n\tif (p != NULL && op != NULL && *op == '.')\n\t{\n\t    char_u  *s = get_reg_contents(*arg == '@'\n\t\t\t\t\t\t  ? '\"' : *arg, GREG_EXPR_SRC);\n\n\t    if (s != NULL)\n\t    {\n\t\tp = ptofree = concat_str(s, p);\n\t\tvim_free(s);\n\t    }\n\t}\n\tif (p != NULL)\n\t{\n\t    write_reg_contents(*arg == '@' ? '\"' : *arg, p, -1, FALSE);\n\t    arg_end = arg + 1;\n\t}\n\tvim_free(ptofree);\n    }\n    return arg_end;\n}\n\n/*\n * Set one item of \":let var = expr\" or \":let [v1, v2] = list\" to its value.\n * Returns a pointer to the char just after the var name.\n * Returns NULL if there is an error.\n */\n    static char_u *\nex_let_one(\n    char_u\t*arg,\t\t// points to variable name\n    typval_T\t*tv,\t\t// value to assign to variable\n    int\t\tcopy,\t\t// copy value from \"tv\"\n    int\t\tflags,\t\t// ASSIGN_CONST, ASSIGN_FINAL, etc.\n    char_u\t*endchars,\t// valid chars after variable name  or NULL\n    char_u\t*op,\t\t// \"+\", \"-\", \".\"  or NULL\n    int\t\tvar_idx)\t// variable index for \"let [a, b] = list\"\n{\n    char_u\t*arg_end = NULL;\n\n    if (in_vim9script() && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t\t\t&& (flags & (ASSIGN_CONST | ASSIGN_FINAL)) == 0\n\t\t\t\t  && vim_strchr((char_u *)\"$@&\", *arg) != NULL)\n    {\n\tvim9_declare_error(arg);\n\treturn NULL;\n    }\n\n    if (*arg == '$')\n    {\n\t// \":let $VAR = expr\": Set environment variable.\n\treturn ex_let_env(arg, tv, flags, endchars, op);\n    }\n    else if (*arg == '&')\n    {\n\t// \":let &option = expr\": Set option value.\n\t// \":let &l:option = expr\": Set local option value.\n\t// \":let &g:option = expr\": Set global option value.\n\t// \":for &ts in range(8)\": Set option value for for loop\n\treturn ex_let_option(arg, tv, flags, endchars, op);\n    }\n    else if (*arg == '@')\n    {\n\t// \":let @r = expr\": Set register contents.\n\treturn ex_let_register(arg, tv, flags, endchars, op);\n    }\n    else if (eval_isnamec1(*arg) || *arg == '{')\n    {\n\tlval_T\tlv;\n\tchar_u\t*p;\n\n\t// \":let var = expr\": Set internal variable.\n\t// \":let var: type = expr\": Set internal variable with type.\n\t// \":let {expr} = expr\": Idem, name made with curly braces\n\tp = get_lval(arg, tv, &lv, FALSE, FALSE,\n\t\t(flags & (ASSIGN_NO_DECL | ASSIGN_DECL))\n\t\t\t\t\t   ? GLV_NO_DECL : 0, FNE_CHECK_START);\n\tif (p != NULL && lv.ll_name != NULL)\n\t{\n\t    if (endchars != NULL && vim_strchr(endchars,\n\t\t\t\t\t   *skipwhite(lv.ll_name_end)) == NULL)\n\t    {\n\t\temsg(_(e_unexpected_characters_in_let));\n\t    }\n\t    else\n\t    {\n\t\tset_var_lval(&lv, p, tv, copy, flags, op, var_idx);\n\t\targ_end = lv.ll_name_end;\n\t    }\n\t}\n\tclear_lval(&lv);\n    }\n    else\n\tsemsg(_(e_invalid_argument_str), arg);\n\n    return arg_end;\n}\n\n/*\n * \":unlet[!] var1 ... \" command.\n */\n    void\nex_unlet(exarg_T *eap)\n{\n    ex_unletlock(eap, eap->arg, 0, 0, do_unlet_var, NULL);\n}\n\n/*\n * \":lockvar\" and \":unlockvar\" commands\n */\n    void\nex_lockvar(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    int\t\tdeep = 2;\n\n    if (eap->forceit)\n\tdeep = -1;\n    else if (vim_isdigit(*arg))\n    {\n\tdeep = getdigits(&arg);\n\targ = skipwhite(arg);\n    }\n\n    ex_unletlock(eap, arg, deep, 0, do_lock_var, NULL);\n}\n\n/*\n * \":unlet\", \":lockvar\" and \":unlockvar\" are quite similar.\n * Also used for Vim9 script.  \"callback\" is invoked as:\n *\tcallback(&lv, name_end, eap, deep, cookie)\n */\n    void\nex_unletlock(\n    exarg_T\t*eap,\n    char_u\t*argstart,\n    int\t\tdeep,\n    int\t\tglv_flags,\n    int\t\t(*callback)(lval_T *, char_u *, exarg_T *, int, void *),\n    void\t*cookie)\n{\n    char_u\t*arg = argstart;\n    char_u\t*name_end;\n    int\t\terror = FALSE;\n    lval_T\tlv;\n\n    do\n    {\n\tif (*arg == '$')\n\t{\n\t    lv.ll_name = arg;\n\t    lv.ll_tv = NULL;\n\t    ++arg;\n\t    if (get_env_len(&arg) == 0)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), arg - 1);\n\t\treturn;\n\t    }\n\t    if (!error && !eap->skip\n\t\t\t      && callback(&lv, arg, eap, deep, cookie) == FAIL)\n\t\terror = TRUE;\n\t    name_end = arg;\n\t}\n\telse\n\t{\n\t    // Parse the name and find the end.\n\t    name_end = get_lval(arg, NULL, &lv, TRUE, eap->skip || error,\n\t\t\t\t     glv_flags | GLV_NO_DECL, FNE_CHECK_START);\n\t    if (lv.ll_name == NULL)\n\t\terror = TRUE;\t    // error but continue parsing\n\t    if (name_end == NULL || (!VIM_ISWHITE(*name_end)\n\t\t\t\t\t\t    && !ends_excmd(*name_end)))\n\t    {\n\t\tif (name_end != NULL)\n\t\t{\n\t\t    emsg_severe = TRUE;\n\t\t    semsg(_(e_trailing_characters_str), name_end);\n\t\t}\n\t\tif (!(eap->skip || error))\n\t\t    clear_lval(&lv);\n\t\tbreak;\n\t    }\n\n\t    if (!error && !eap->skip\n\t\t\t && callback(&lv, name_end, eap, deep, cookie) == FAIL)\n\t\terror = TRUE;\n\n\t    if (!eap->skip)\n\t\tclear_lval(&lv);\n\t}\n\n\targ = skipwhite(name_end);\n    } while (!ends_excmd2(name_end, arg));\n\n    set_nextcmd(eap, arg);\n}\n\n    static int\ndo_unlet_var(\n    lval_T\t*lp,\n    char_u\t*name_end,\n    exarg_T\t*eap,\n    int\t\tdeep UNUSED,\n    void\t*cookie UNUSED)\n{\n    int\t\tforceit = eap->forceit;\n    int\t\tret = OK;\n    int\t\tcc;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *name_end;\n\t*name_end = NUL;\n\n\t// Environment variable, normal name or expanded name.\n\tif (*lp->ll_name == '$')\n\t    vim_unsetenv(lp->ll_name + 1);\n\telse if (do_unlet(lp->ll_name, forceit) == FAIL)\n\t    ret = FAIL;\n\t*name_end = cc;\n    }\n    else if ((lp->ll_list != NULL\n\t\t && value_check_lock(lp->ll_list->lv_lock, lp->ll_name, FALSE))\n\t    || (lp->ll_dict != NULL\n\t\t&& value_check_lock(lp->ll_dict->dv_lock, lp->ll_name, FALSE)))\n\treturn FAIL;\n    else if (lp->ll_range)\n    {\n\tif (list_unlet_range(lp->ll_list, lp->ll_li, lp->ll_name, lp->ll_n1,\n\t\t\t\t\t   !lp->ll_empty2, lp->ll_n2) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\tif (lp->ll_list != NULL)\n\t    // unlet a List item.\n\t    listitem_remove(lp->ll_list, lp->ll_li);\n\telse\n\t    // unlet a Dictionary item.\n\t    dictitem_remove(lp->ll_dict, lp->ll_di);\n    }\n\n    return ret;\n}\n\n/*\n * Unlet one item or a range of items from a list.\n * Return OK or FAIL.\n */\n    int\nlist_unlet_range(\n\tlist_T\t    *l,\n\tlistitem_T  *li_first,\n\tchar_u\t    *name,\n\tlong\t    n1_arg,\n\tint\t    has_n2,\n\tlong\t    n2)\n{\n    listitem_T  *li = li_first;\n    int\t\tn1 = n1_arg;\n\n    while (li != NULL && (!has_n2 || n2 >= n1))\n    {\n\tif (value_check_lock(li->li_tv.v_lock, name, FALSE))\n\t    return FAIL;\n\tli = li->li_next;\n\t++n1;\n    }\n\n    // Delete a range of List items.\n    li = li_first;\n    n1 = n1_arg;\n    while (li != NULL && (!has_n2 || n2 >= n1))\n    {\n\tlistitem_T *next = li->li_next;\n\n\tlistitem_remove(l, li);\n\tli = next;\n\t++n1;\n    }\n    return OK;\n}\n/*\n * \"unlet\" a variable.  Return OK if it existed, FAIL if not.\n * When \"forceit\" is TRUE don't complain if the variable doesn't exist.\n */\n    int\ndo_unlet(char_u *name, int forceit)\n{\n    hashtab_T\t*ht;\n    hashitem_T\t*hi;\n    char_u\t*varname;\n    dict_T\t*d;\n    dictitem_T\t*di;\n\n    // can't :unlet a script variable in Vim9 script\n    if (in_vim9script() && check_vim9_unlet(name) == FAIL)\n\treturn FAIL;\n\n    ht = find_var_ht(name, &varname);\n\n    // can't :unlet a script variable in Vim9 script from a function\n    if (ht == get_script_local_ht()\n\t    && SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t    && SCRIPT_ITEM(current_sctx.sc_sid)->sn_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t    && check_vim9_unlet(name) == FAIL)\n\treturn FAIL;\n\n    if (ht != NULL && *varname != NUL)\n    {\n\td = get_current_funccal_dict(ht);\n\tif (d == NULL)\n\t{\n\t    if (ht == &globvarht)\n\t\td = &globvardict;\n\t    else if (ht == &compat_hashtab)\n\t\td = &vimvardict;\n\t    else\n\t    {\n\t\tdi = find_var_in_ht(ht, *name, (char_u *)\"\", FALSE);\n\t\td = di == NULL ? NULL : di->di_tv.vval.v_dict;\n\t    }\n\t    if (d == NULL)\n\t    {\n\t\tinternal_error(\"do_unlet()\");\n\t\treturn FAIL;\n\t    }\n\t}\n\thi = hash_find(ht, varname);\n\tif (HASHITEM_EMPTY(hi))\n\t    hi = find_hi_in_scoped_ht(name, &ht);\n\tif (hi != NULL && !HASHITEM_EMPTY(hi))\n\t{\n\t    di = HI2DI(hi);\n\t    if (var_check_fixed(di->di_flags, name, FALSE)\n\t\t    || var_check_ro(di->di_flags, name, FALSE)\n\t\t    || value_check_lock(d->dv_lock, name, FALSE))\n\t\treturn FAIL;\n\n\t    delete_var(ht, hi);\n\t    return OK;\n\t}\n    }\n    if (forceit)\n\treturn OK;\n    semsg(_(e_no_such_variable_str), name);\n    return FAIL;\n}\n\n/*\n * Lock or unlock variable indicated by \"lp\".\n * \"deep\" is the levels to go (-1 for unlimited);\n * \"lock\" is TRUE for \":lockvar\", FALSE for \":unlockvar\".\n */\n    static int\ndo_lock_var(\n    lval_T\t*lp,\n    char_u\t*name_end,\n    exarg_T\t*eap,\n    int\t\tdeep,\n    void\t*cookie UNUSED)\n{\n    int\t\tlock = eap->cmdidx == CMD_lockvar;\n    int\t\tret = OK;\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *name_end;\n\t*name_end = NUL;\n\tif (*lp->ll_name == '$')\n\t{\n\t    semsg(_(e_cannot_lock_or_unlock_variable_str), lp->ll_name);\n\t    ret = FAIL;\n\t}\n\telse\n\t{\n\t    // Normal name or expanded name.\n\t    di = find_var(lp->ll_name, NULL, TRUE);\n\t    if (di == NULL)\n\t    {\n\t\tif (in_vim9script())\n\t\t    semsg(_(e_cannot_find_variable_to_unlock_str),\n\t\t\t\t\t\t\t\t  lp->ll_name);\n\t\tret = FAIL;\n\t    }\n\t    else if ((di->di_flags & DI_FLAGS_FIX)\n\t\t\t    && di->di_tv.v_type != VAR_DICT\n\t\t\t    && di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\t// For historic reasons this error is not given for a list or\n\t\t// dict.  E.g., the b: dict could be locked/unlocked.\n\t\tsemsg(_(e_cannot_lock_or_unlock_variable_str), lp->ll_name);\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tif (lock)\n\t\t    di->di_flags |= DI_FLAGS_LOCK;\n\t\telse\n\t\t    di->di_flags &= ~DI_FLAGS_LOCK;\n\t\tif (deep != 0)\n\t\t    item_lock(&di->di_tv, deep, lock, FALSE);\n\t    }\n\t}\n\t*name_end = cc;\n    }\n    else if (deep == 0)\n    {\n\t// nothing to do\n    }\n    else if (lp->ll_range)\n    {\n\tlistitem_T    *li = lp->ll_li;\n\n\t// (un)lock a range of List items.\n\twhile (li != NULL && (lp->ll_empty2 || lp->ll_n2 >= lp->ll_n1))\n\t{\n\t    item_lock(&li->li_tv, deep, lock, FALSE);\n\t    li = li->li_next;\n\t    ++lp->ll_n1;\n\t}\n    }\n    else if (lp->ll_list != NULL)\n\t// (un)lock a List item.\n\titem_lock(&lp->ll_li->li_tv, deep, lock, FALSE);\n    else\n\t// (un)lock a Dictionary item.\n\titem_lock(&lp->ll_di->di_tv, deep, lock, FALSE);\n\n    return ret;\n}\n\n/*\n * Lock or unlock an item.  \"deep\" is nr of levels to go.\n * When \"check_refcount\" is TRUE do not lock a list or dict with a reference\n * count larger than 1.\n */\n    void\nitem_lock(typval_T *tv, int deep, int lock, int check_refcount)\n{\n    static int\trecurse = 0;\n    list_T\t*l;\n    listitem_T\t*li;\n    dict_T\t*d;\n    blob_T\t*b;\n    hashitem_T\t*hi;\n    int\t\ttodo;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_unlock));\n\treturn;\n    }\n    if (deep == 0)\n\treturn;\n    ++recurse;\n\n    // lock/unlock the item itself\n    if (lock)\n\ttv->v_lock |= VAR_LOCKED;\n    else\n\ttv->v_lock &= ~VAR_LOCKED;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_NUMBER:\n\tcase VAR_BOOL:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break;\n\n\tcase VAR_BLOB:\n\t    if ((b = tv->vval.v_blob) != NULL\n\t\t\t\t    && !(check_refcount && b->bv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    b->bv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    b->bv_lock &= ~VAR_LOCKED;\n\t    }\n\t    break;\n\tcase VAR_LIST:\n\t    if ((l = tv->vval.v_list) != NULL\n\t\t\t\t    && !(check_refcount && l->lv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    l->lv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    l->lv_lock &= ~VAR_LOCKED;\n\t\tif (deep < 0 || deep > 1)\n\t\t{\n\t\t    if (l->lv_first == &range_list_item)\n\t\t\tl->lv_lock |= VAR_ITEMS_LOCKED;\n\t\t    else\n\t\t    {\n\t\t\t// recursive: lock/unlock the items the List contains\n\t\t\tCHECK_LIST_MATERIALIZE(l);\n\t\t\tFOR_ALL_LIST_ITEMS(l, li) item_lock(&li->li_tv,\n\t\t\t\t\t       deep - 1, lock, check_refcount);\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\tcase VAR_DICT:\n\t    if ((d = tv->vval.v_dict) != NULL\n\t\t\t\t    && !(check_refcount && d->dv_refcount > 1))\n\t    {\n\t\tif (lock)\n\t\t    d->dv_lock |= VAR_LOCKED;\n\t\telse\n\t\t    d->dv_lock &= ~VAR_LOCKED;\n\t\tif (deep < 0 || deep > 1)\n\t\t{\n\t\t    // recursive: lock/unlock the items the List contains\n\t\t    todo = (int)d->dv_hashtab.ht_used;\n\t\t    for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi)\n\t\t    {\n\t\t\tif (!HASHITEM_EMPTY(hi))\n\t\t\t{\n\t\t\t    --todo;\n\t\t\t    item_lock(&HI2DI(hi)->di_tv, deep - 1, lock,\n\t\t\t\t\t\t\t       check_refcount);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n    }\n    --recurse;\n}\n\n#if (defined(FEAT_MENU) && defined(FEAT_MULTI_LANG)) || defined(PROTO)\n/*\n * Delete all \"menutrans_\" variables.\n */\n    void\ndel_menutrans_vars(void)\n{\n    hashitem_T\t*hi;\n    int\t\ttodo;\n\n    hash_lock(&globvarht);\n    todo = (int)globvarht.ht_used;\n    for (hi = globvarht.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    if (STRNCMP(HI2DI(hi)->di_key, \"menutrans_\", 10) == 0)\n\t\tdelete_var(&globvarht, hi);\n\t}\n    }\n    hash_unlock(&globvarht);\n}\n#endif\n\n/*\n * Local string buffer for the next two functions to store a variable name\n * with its prefix. Allocated in cat_prefix_varname(), freed later in\n * get_user_var_name().\n */\n\nstatic char_u\t*varnamebuf = NULL;\nstatic int\tvarnamebuflen = 0;\n\n/*\n * Function to concatenate a prefix and a variable name.\n */\n    char_u *\ncat_prefix_varname(int prefix, char_u *name)\n{\n    int\t\tlen;\n\n    len = (int)STRLEN(name) + 3;\n    if (len > varnamebuflen)\n    {\n\tvim_free(varnamebuf);\n\tlen += 10;\t\t\t// some additional space\n\tvarnamebuf = alloc(len);\n\tif (varnamebuf == NULL)\n\t{\n\t    varnamebuflen = 0;\n\t    return NULL;\n\t}\n\tvarnamebuflen = len;\n    }\n    *varnamebuf = prefix;\n    varnamebuf[1] = ':';\n    STRCPY(varnamebuf + 2, name);\n    return varnamebuf;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * (global/buffer/window/built-in) variable names.\n */\n    char_u *\nget_user_var_name(expand_T *xp, int idx)\n{\n    static long_u\tgdone;\n    static long_u\tbdone;\n    static long_u\twdone;\n    static long_u\ttdone;\n    static int\t\tvidx;\n    static hashitem_T\t*hi;\n    hashtab_T\t\t*ht;\n\n    if (idx == 0)\n    {\n\tgdone = bdone = wdone = vidx = 0;\n\ttdone = 0;\n    }\n\n    // Global variables\n    if (gdone < globvarht.ht_used)\n    {\n\tif (gdone++ == 0)\n\t    hi = globvarht.ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tif (STRNCMP(\"g:\", xp->xp_pattern, 2) == 0)\n\t    return cat_prefix_varname('g', hi->hi_key);\n\treturn hi->hi_key;\n    }\n\n    // b: variables\n    ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;\n    if (bdone < ht->ht_used)\n    {\n\tif (bdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('b', hi->hi_key);\n    }\n\n    // w: variables\n    ht = &prevwin_curwin()->w_vars->dv_hashtab;\n    if (wdone < ht->ht_used)\n    {\n\tif (wdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('w', hi->hi_key);\n    }\n\n    // t: variables\n    ht = &curtab->tp_vars->dv_hashtab;\n    if (tdone < ht->ht_used)\n    {\n\tif (tdone++ == 0)\n\t    hi = ht->ht_array;\n\telse\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\treturn cat_prefix_varname('t', hi->hi_key);\n    }\n\n    // v: variables\n    if (vidx < VV_LEN)\n\treturn cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name);\n\n    VIM_CLEAR(varnamebuf);\n    varnamebuflen = 0;\n    return NULL;\n}\n\n    char *\nget_var_special_name(int nr)\n{\n    switch (nr)\n    {\n\tcase VVAL_FALSE: return in_vim9script() ? \"false\" : \"v:false\";\n\tcase VVAL_TRUE:  return in_vim9script() ? \"true\" : \"v:true\";\n\tcase VVAL_NULL:  return in_vim9script() ? \"null\" : \"v:null\";\n\tcase VVAL_NONE:  return \"v:none\";\n    }\n    internal_error(\"get_var_special_name()\");\n    return \"42\";\n}\n\n/*\n * Returns the global variable dictionary\n */\n    dict_T *\nget_globvar_dict(void)\n{\n    return &globvardict;\n}\n\n/*\n * Returns the global variable hash table\n */\n    hashtab_T *\nget_globvar_ht(void)\n{\n    return &globvarht;\n}\n\n/*\n * Returns the v: variable dictionary\n */\n    dict_T *\nget_vimvar_dict(void)\n{\n    return &vimvardict;\n}\n\n/*\n * Returns the index of a v:variable.  Negative if not found.\n * Returns DI_ flags in \"di_flags\".\n */\n    int\nfind_vim_var(char_u *name, int *di_flags)\n{\n    dictitem_T\t    *di = find_var_in_ht(&vimvarht, 0, name, TRUE);\n    struct vimvar   *vv;\n\n    if (di == NULL)\n\treturn -1;\n    *di_flags = di->di_flags;\n    vv = (struct vimvar *)((char *)di - offsetof(vimvar_T, vv_di));\n    return (int)(vv - vimvars);\n}\n\n\n/*\n * Set type of v: variable to \"type\".\n */\n    void\nset_vim_var_type(int idx, vartype_T type)\n{\n    vimvars[idx].vv_tv_type = type;\n}\n\n/*\n * Set number v: variable to \"val\".\n * Note that this does not set the type, use set_vim_var_type() for that.\n */\n    void\nset_vim_var_nr(int idx, varnumber_T val)\n{\n    vimvars[idx].vv_nr = val;\n}\n\n    char *\nget_vim_var_name(int idx)\n{\n    return vimvars[idx].vv_name;\n}\n\n/*\n * Get typval_T v: variable value.\n */\n    typval_T *\nget_vim_var_tv(int idx)\n{\n    return &vimvars[idx].vv_tv;\n}\n\n    type_T *\nget_vim_var_type(int idx, garray_T *type_list)\n{\n    if (vimvars[idx].vv_type != NULL)\n\treturn vimvars[idx].vv_type;\n    return typval2type_vimvar(&vimvars[idx].vv_tv, type_list);\n}\n\n/*\n * Set v: variable to \"tv\".  Only accepts the same type.\n * Takes over the value of \"tv\".\n */\n    int\nset_vim_var_tv(int idx, typval_T *tv)\n{\n    if (vimvars[idx].vv_tv_type != tv->v_type)\n    {\n\temsg(_(e_type_mismatch_for_v_variable));\n\tclear_tv(tv);\n\treturn FAIL;\n    }\n    // VV_RO is also checked when compiling, but let's check here as well.\n    if (vimvars[idx].vv_flags & VV_RO)\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), vimvars[idx].vv_name);\n\treturn FAIL;\n    }\n    if (sandbox && (vimvars[idx].vv_flags & VV_RO_SBX))\n    {\n\tsemsg(_(e_cannot_set_variable_in_sandbox_str), vimvars[idx].vv_name);\n\treturn FAIL;\n    }\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_di.di_tv = *tv;\n    return OK;\n}\n\n/*\n * Get number v: variable value.\n */\n    varnumber_T\nget_vim_var_nr(int idx)\n{\n    return vimvars[idx].vv_nr;\n}\n\n/*\n * Get string v: variable value.  Uses a static buffer, can only be used once.\n * If the String variable has never been set, return an empty string.\n * Never returns NULL;\n */\n    char_u *\nget_vim_var_str(int idx)\n{\n    return tv_get_string(&vimvars[idx].vv_tv);\n}\n\n/*\n * Get List v: variable value.  Caller must take care of reference count when\n * needed.\n */\n    list_T *\nget_vim_var_list(int idx)\n{\n    return vimvars[idx].vv_list;\n}\n\n/*\n * Get Dict v: variable value.  Caller must take care of reference count when\n * needed.\n */\n    dict_T *\nget_vim_var_dict(int idx)\n{\n    return vimvars[idx].vv_dict;\n}\n\n/*\n * Set v:char to character \"c\".\n */\n    void\nset_vim_var_char(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n    set_vim_var_string(VV_CHAR, buf, -1);\n}\n\n/*\n * Set v:count to \"count\" and v:count1 to \"count1\".\n * When \"set_prevcount\" is TRUE first set v:prevcount from v:count.\n */\n    void\nset_vcount(\n    long\tcount,\n    long\tcount1,\n    int\t\tset_prevcount)\n{\n    if (set_prevcount)\n\tvimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;\n    vimvars[VV_COUNT].vv_nr = count;\n    vimvars[VV_COUNT1].vv_nr = count1;\n}\n\n/*\n * Save variables that might be changed as a side effect.  Used when executing\n * a timer callback.\n */\n    void\nsave_vimvars(vimvars_save_T *vvsave)\n{\n    vvsave->vv_prevcount = vimvars[VV_PREVCOUNT].vv_nr;\n    vvsave->vv_count = vimvars[VV_COUNT].vv_nr;\n    vvsave->vv_count1 = vimvars[VV_COUNT1].vv_nr;\n}\n\n/*\n * Restore variables saved by save_vimvars().\n */\n    void\nrestore_vimvars(vimvars_save_T *vvsave)\n{\n    vimvars[VV_PREVCOUNT].vv_nr = vvsave->vv_prevcount;\n    vimvars[VV_COUNT].vv_nr = vvsave->vv_count;\n    vimvars[VV_COUNT1].vv_nr = vvsave->vv_count1;\n}\n\n/*\n * Set string v: variable to a copy of \"val\". If 'copy' is FALSE, then set the\n * value.\n */\n    void\nset_vim_var_string(\n    int\t\tidx,\n    char_u\t*val,\n    int\t\tlen)\t    // length of \"val\" to use or -1 (whole string)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_STRING;\n    if (val == NULL)\n\tvimvars[idx].vv_str = NULL;\n    else if (len == -1)\n\tvimvars[idx].vv_str = vim_strsave(val);\n    else\n\tvimvars[idx].vv_str = vim_strnsave(val, len);\n}\n\n/*\n * Set List v: variable to \"val\".\n */\n    void\nset_vim_var_list(int idx, list_T *val)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_LIST;\n    vimvars[idx].vv_list = val;\n    if (val != NULL)\n\t++val->lv_refcount;\n}\n\n/*\n * Set Dictionary v: variable to \"val\".\n */\n    void\nset_vim_var_dict(int idx, dict_T *val)\n{\n    clear_tv(&vimvars[idx].vv_di.di_tv);\n    vimvars[idx].vv_tv_type = VAR_DICT;\n    vimvars[idx].vv_dict = val;\n    if (val != NULL)\n    {\n\t++val->dv_refcount;\n\tdict_set_items_ro(val);\n    }\n}\n\n/*\n * Set the v:argv list.\n */\n    void\nset_argv_var(char **argv, int argc)\n{\n    list_T\t*l = list_alloc();\n    int\t\ti;\n\n    if (l == NULL)\n\tgetout(1);\n    l->lv_lock = VAR_FIXED;\n    for (i = 0; i < argc; ++i)\n    {\n\tif (list_append_string(l, (char_u *)argv[i], -1) == FAIL)\n\t    getout(1);\n\tl->lv_u.mat.lv_last->li_tv.v_lock = VAR_FIXED;\n    }\n    set_vim_var_list(VV_ARGV, l);\n}\n\n/*\n * Reset v:register, taking the 'clipboard' setting into account.\n */\n    void\nreset_reg_var(void)\n{\n    int regname = 0;\n\n    // Adjust the register according to 'clipboard', so that when\n    // \"unnamed\" is present it becomes '*' or '+' instead of '\"'.\n#ifdef FEAT_CLIPBOARD\n    adjust_clip_reg(&regname);\n#endif\n    set_reg_var(regname);\n}\n\n/*\n * Set v:register if needed.\n */\n    void\nset_reg_var(int c)\n{\n    char_u\tregname;\n\n    if (c == 0 || c == ' ')\n\tregname = '\"';\n    else\n\tregname = c;\n    // Avoid free/alloc when the value is already right.\n    if (vimvars[VV_REG].vv_str == NULL || vimvars[VV_REG].vv_str[0] != c)\n\tset_vim_var_string(VV_REG, &regname, 1);\n}\n\n/*\n * Get or set v:exception.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:exception!  Does not\n * take care of memory allocations.\n */\n    char_u *\nv_exception(char_u *oldval)\n{\n    if (oldval == NULL)\n\treturn vimvars[VV_EXCEPTION].vv_str;\n\n    vimvars[VV_EXCEPTION].vv_str = oldval;\n    return NULL;\n}\n\n/*\n * Get or set v:throwpoint.  If \"oldval\" == NULL, return the current value.\n * Otherwise, restore the value to \"oldval\" and return NULL.\n * Must always be called in pairs to save and restore v:throwpoint!  Does not\n * take care of memory allocations.\n */\n    char_u *\nv_throwpoint(char_u *oldval)\n{\n    if (oldval == NULL)\n\treturn vimvars[VV_THROWPOINT].vv_str;\n\n    vimvars[VV_THROWPOINT].vv_str = oldval;\n    return NULL;\n}\n\n/*\n * Set v:cmdarg.\n * If \"eap\" != NULL, use \"eap\" to generate the value and return the old value.\n * If \"oldarg\" != NULL, restore the value to \"oldarg\" and return NULL.\n * Must always be called in pairs!\n */\n    char_u *\nset_cmdarg(exarg_T *eap, char_u *oldarg)\n{\n    char_u\t*oldval;\n    char_u\t*newval;\n    unsigned\tlen;\n\n    oldval = vimvars[VV_CMDARG].vv_str;\n    if (eap == NULL)\n    {\n\tvim_free(oldval);\n\tvimvars[VV_CMDARG].vv_str = oldarg;\n\treturn NULL;\n    }\n\n    if (eap->force_bin == FORCE_BIN)\n\tlen = 6;\n    else if (eap->force_bin == FORCE_NOBIN)\n\tlen = 8;\n    else\n\tlen = 0;\n\n    if (eap->read_edit)\n\tlen += 7;\n\n    if (eap->force_ff != 0)\n\tlen += 10; // \" ++ff=unix\"\n    if (eap->force_enc != 0)\n\tlen += (unsigned)STRLEN(eap->cmd + eap->force_enc) + 7;\n    if (eap->bad_char != 0)\n\tlen += 7 + 4;  // \" ++bad=\" + \"keep\" or \"drop\"\n\n    newval = alloc(len + 1);\n    if (newval == NULL)\n\treturn NULL;\n\n    if (eap->force_bin == FORCE_BIN)\n\tsprintf((char *)newval, \" ++bin\");\n    else if (eap->force_bin == FORCE_NOBIN)\n\tsprintf((char *)newval, \" ++nobin\");\n    else\n\t*newval = NUL;\n\n    if (eap->read_edit)\n\tSTRCAT(newval, \" ++edit\");\n\n    if (eap->force_ff != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++ff=%s\",\n\t\t\t\t\t\teap->force_ff == 'u' ? \"unix\"\n\t\t\t\t\t\t: eap->force_ff == 'd' ? \"dos\"\n\t\t\t\t\t\t: \"mac\");\n    if (eap->force_enc != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++enc=%s\",\n\t\t\t\t\t       eap->cmd + eap->force_enc);\n    if (eap->bad_char == BAD_KEEP)\n\tSTRCPY(newval + STRLEN(newval), \" ++bad=keep\");\n    else if (eap->bad_char == BAD_DROP)\n\tSTRCPY(newval + STRLEN(newval), \" ++bad=drop\");\n    else if (eap->bad_char != 0)\n\tsprintf((char *)newval + STRLEN(newval), \" ++bad=%c\", eap->bad_char);\n    vimvars[VV_CMDARG].vv_str = newval;\n    return oldval;\n}\n\n/*\n * Get the value of internal variable \"name\".\n * If \"flags\" has EVAL_VAR_IMPORT may return a VAR_ANY with v_number set to the\n * imported script ID.\n * Return OK or FAIL.  If OK is returned \"rettv\" must be cleared.\n */\n    int\neval_variable(\n    char_u\t*name,\n    int\t\tlen,\t\t// length of \"name\"\n    scid_T\tsid,\t\t// script ID for imported item or zero\n    typval_T\t*rettv,\t\t// NULL when only checking existence\n    dictitem_T\t**dip,\t\t// non-NULL when typval's dict item is needed\n    int\t\tflags)\t\t// EVAL_VAR_ flags\n{\n    int\t\tret = OK;\n    typval_T\t*tv = NULL;\n    int\t\tfound = FALSE;\n    hashtab_T\t*ht = NULL;\n    int\t\tcc;\n    type_T\t*type = NULL;\n\n    // truncate the name, so that we can use strcmp()\n    cc = name[len];\n    name[len] = NUL;\n\n    // Check for local variable when debugging.\n    if ((tv = lookup_debug_var(name)) == NULL)\n    {\n\t// Check for user-defined variables.\n\tdictitem_T\t*v = find_var(name, &ht, flags & EVAL_VAR_NOAUTOLOAD);\n\n\tif (v != NULL)\n\t{\n\t    tv = &v->di_tv;\n\t    if (dip != NULL)\n\t\t*dip = v;\n\t}\n\telse\n\t    ht = NULL;\n    }\n\n    if (tv == NULL && (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0))\n    {\n\timported_T  *import = NULL;\n\tchar_u\t    *p = STRNCMP(name, \"s:\", 2) == 0 ? name + 2 : name;\n\n\tif (sid == 0)\n\t    import = find_imported(p, 0, TRUE);\n\n\t// imported variable from another script\n\tif (import != NULL || sid != 0)\n\t{\n\t    if ((flags & EVAL_VAR_IMPORT) == 0)\n\t    {\n\t\tif (SCRIPT_ID_VALID(sid))\n\t\t{\n\t\t    ht = &SCRIPT_VARS(sid);\n\t\t    if (ht != NULL)\n\t\t    {\n\t\t\tdictitem_T *v = find_var_in_ht(ht, 0, name,\n\t\t\t\t\t\t  flags & EVAL_VAR_NOAUTOLOAD);\n\n\t\t\tif (v != NULL)\n\t\t\t{\n\t\t\t    tv = &v->di_tv;\n\t\t\t    if (dip != NULL)\n\t\t\t\t*dip = v;\n\t\t\t}\n\t\t\telse\n\t\t\t    ht = NULL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (flags & EVAL_VAR_VERBOSE)\n\t\t\tsemsg(_(e_expected_dot_after_name_str), name);\n\t\t    ret = FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (rettv != NULL)\n\t\t{\n\t\t    rettv->v_type = VAR_ANY;\n\t\t    rettv->vval.v_number = sid != 0 ? sid : import->imp_sid;\n\t\t}\n\t\tfound = TRUE;\n\t    }\n\t}\n\telse if (in_vim9script() && (flags & EVAL_VAR_NO_FUNC) == 0)\n\t{\n\t    int\t    has_g_prefix = STRNCMP(name, \"g:\", 2) == 0;\n\t    ufunc_T *ufunc = find_func(name, FALSE);\n\n\t    // In Vim9 script we can get a function reference by using the\n\t    // function name.  For a global non-autoload function \"g:\" is\n\t    // required.\n\t    if (ufunc != NULL && (has_g_prefix\n\t\t\t\t\t    || !func_requires_g_prefix(ufunc)))\n\t    {\n\t\tfound = TRUE;\n\t\tif (rettv != NULL)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    if (has_g_prefix)\n\t\t\t// Keep the \"g:\", otherwise script-local may be\n\t\t\t// assumed.\n\t\t\trettv->vval.v_string = vim_strsave(name);\n\t\t    else\n\t\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t\t    if (rettv->vval.v_string != NULL)\n\t\t\tfunc_ref(ufunc->uf_name);\n\t\t}\n\t    }\n\t}\n    }\n\n    if (!found)\n    {\n\tif (tv == NULL)\n\t{\n\t    if (rettv != NULL && (flags & EVAL_VAR_VERBOSE))\n\t\tsemsg(_(e_undefined_variable_str), name);\n\t    ret = FAIL;\n\t}\n\telse if (rettv != NULL)\n\t{\n\t    if (ht != NULL && ht == get_script_local_ht()\n\t\t    && tv != &SCRIPT_SV(current_sctx.sc_sid)->sv_var.di_tv)\n\t    {\n\t\tsvar_T *sv = find_typval_in_script(tv, 0);\n\n\t\tif (sv != NULL)\n\t\t    type = sv->sv_type;\n\t    }\n\n\t    // If a list or dict variable wasn't initialized, do it now.\n\t    if (tv->v_type == VAR_DICT && tv->vval.v_dict == NULL)\n\t    {\n\t\ttv->vval.v_dict = dict_alloc();\n\t\tif (tv->vval.v_dict != NULL)\n\t\t{\n\t\t    ++tv->vval.v_dict->dv_refcount;\n\t\t    tv->vval.v_dict->dv_type = alloc_type(type);\n\t\t}\n\t    }\n\t    else if (tv->v_type == VAR_LIST && tv->vval.v_list == NULL)\n\t    {\n\t\ttv->vval.v_list = list_alloc();\n\t\tif (tv->vval.v_list != NULL)\n\t\t{\n\t\t    ++tv->vval.v_list->lv_refcount;\n\t\t    tv->vval.v_list->lv_type = alloc_type(type);\n\t\t}\n\t    }\n\t    else if (tv->v_type == VAR_BLOB && tv->vval.v_blob == NULL)\n\t    {\n\t\ttv->vval.v_blob = blob_alloc();\n\t\tif (tv->vval.v_blob != NULL)\n\t\t    ++tv->vval.v_blob->bv_refcount;\n\t    }\n\t    copy_tv(tv, rettv);\n\t}\n    }\n\n    name[len] = cc;\n\n    return ret;\n}\n\n/*\n * Check if variable \"name[len]\" is a local variable or an argument.\n * If so, \"*eval_lavars_used\" is set to TRUE.\n */\n    void\ncheck_vars(char_u *name, int len)\n{\n    int\t\tcc;\n    char_u\t*varname;\n    hashtab_T\t*ht;\n\n    if (eval_lavars_used == NULL)\n\treturn;\n\n    // truncate the name, so that we can use strcmp()\n    cc = name[len];\n    name[len] = NUL;\n\n    ht = find_var_ht(name, &varname);\n    if (ht == get_funccal_local_ht() || ht == get_funccal_args_ht())\n    {\n\tif (find_var(name, NULL, TRUE) != NULL)\n\t    *eval_lavars_used = TRUE;\n    }\n\n    name[len] = cc;\n}\n\n/*\n * Find variable \"name\" in the list of variables.\n * Return a pointer to it if found, NULL if not found.\n * Careful: \"a:0\" variables don't have a name.\n * When \"htp\" is not NULL  set \"htp\" to the hashtab_T used.\n */\n    dictitem_T *\nfind_var(char_u *name, hashtab_T **htp, int no_autoload)\n{\n    char_u\t*varname;\n    hashtab_T\t*ht;\n    dictitem_T\t*ret = NULL;\n\n    ht = find_var_ht(name, &varname);\n    if (htp != NULL)\n\t*htp = ht;\n    if (ht == NULL)\n\treturn NULL;\n    ret = find_var_in_ht(ht, *name, varname, no_autoload);\n    if (ret != NULL)\n\treturn ret;\n\n    // Search in parent scope for lambda\n    ret = find_var_in_scoped_ht(name, no_autoload);\n    if (ret != NULL)\n\treturn ret;\n\n    // in Vim9 script items without a scope can be script-local\n    if (in_vim9script() && name[0] != NUL && name[1] != ':')\n    {\n\tht = get_script_local_ht();\n\tif (ht != NULL)\n\t{\n\t    ret = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (ret != NULL)\n\t    {\n\t\tif (htp != NULL)\n\t\t    *htp = ht;\n\t\treturn ret;\n\t    }\n\t}\n    }\n\n    // When using \"vim9script autoload\" script-local items are prefixed but can\n    // be used with s:name.\n    if (SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t\t\t\t\t   && name[0] == 's' && name[1] == ':')\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    char_u *auto_name = concat_str(si->sn_autoload_prefix, name + 2);\n\n\t    if (auto_name != NULL)\n\t    {\n\t\tht = &globvarht;\n\t\tret = find_var_in_ht(ht, *name, auto_name, TRUE);\n\t\tvim_free(auto_name);\n\t\tif (ret != NULL)\n\t\t{\n\t\t    if (htp != NULL)\n\t\t\t*htp = ht;\n\t\t    return ret;\n\t\t}\n\t    }\n\t}\n    }\n\n    return NULL;\n}\n\n/*\n * Like find_var() but if the name starts with <SNR>99_ then look in the\n * referenced script (used for a funcref).\n */\n    dictitem_T *\nfind_var_also_in_script(char_u *name, hashtab_T **htp, int no_autoload)\n{\n    if (STRNCMP(name, \"<SNR>\", 5) == 0 && isdigit(name[5]))\n    {\n\tchar_u\t    *p = name + 5;\n\tint\t    sid = getdigits(&p);\n\n\tif (SCRIPT_ID_VALID(sid) && *p == '_')\n\t{\n\t    hashtab_T\t*ht = &SCRIPT_VARS(sid);\n\n\t    if (ht != NULL)\n\t    {\n\t\tdictitem_T *di = find_var_in_ht(ht, 0, p + 1, no_autoload);\n\n\t\tif (di != NULL)\n\t\t{\n\t\t    if (htp != NULL)\n\t\t\t*htp = ht;\n\t\t    return di;\n\t\t}\n\t    }\n\t}\n    }\n\n    return find_var(name, htp, no_autoload);\n}\n\n/*\n * Find variable \"varname\" in hashtab \"ht\" with name \"htname\".\n * When \"varname\" is empty returns curwin/curtab/etc vars dictionary.\n * Returns NULL if not found.\n */\n    dictitem_T *\nfind_var_in_ht(\n    hashtab_T\t*ht,\n    int\t\thtname,\n    char_u\t*varname,\n    int\t\tno_autoload)\n{\n    hashitem_T\t*hi;\n\n    if (*varname == NUL)\n    {\n\t// Must be something like \"s:\", otherwise \"ht\" would be NULL.\n\tswitch (htname)\n\t{\n\t    case 's': return &SCRIPT_SV(current_sctx.sc_sid)->sv_var;\n\t    case 'g': return &globvars_var;\n\t    case 'v': return &vimvars_var;\n\t    case 'b': return &curbuf->b_bufvar;\n\t    case 'w': return &curwin->w_winvar;\n\t    case 't': return &curtab->tp_winvar;\n\t    case 'l': return get_funccal_local_var();\n\t    case 'a': return get_funccal_args_var();\n\t}\n\treturn NULL;\n    }\n\n    hi = hash_find(ht, varname);\n    if (HASHITEM_EMPTY(hi))\n    {\n\t// For global variables we may try auto-loading the script.  If it\n\t// worked find the variable again.  Don't auto-load a script if it was\n\t// loaded already, otherwise it would be loaded every time when\n\t// checking if a function name is a Funcref variable.\n\tif (ht == &globvarht && !no_autoload)\n\t{\n\t    // Note: script_autoload() may make \"hi\" invalid. It must either\n\t    // be obtained again or not used.\n\t    if (!script_autoload(varname, FALSE) || aborting())\n\t\treturn NULL;\n\t    hi = hash_find(ht, varname);\n\t}\n\tif (HASHITEM_EMPTY(hi))\n\t    return NULL;\n    }\n    return HI2DI(hi);\n}\n\n/*\n * Get the script-local hashtab.  NULL if not in a script context.\n */\n    hashtab_T *\nget_script_local_ht(void)\n{\n    scid_T sid = current_sctx.sc_sid;\n\n    if (SCRIPT_ID_VALID(sid))\n\treturn &SCRIPT_VARS(sid);\n    return NULL;\n}\n\n/*\n * Look for \"name[len]\" in script-local variables and functions.\n * When \"cmd\" is TRUE it must look like a command, a function must be followed\n * by \"(\" or \"->\".\n * Return OK when found, FAIL when not found.\n */\n    int\nlookup_scriptitem(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tcmd,\n\tcctx_T\t*dummy UNUSED)\n{\n    hashtab_T\t*ht = get_script_local_ht();\n    char_u\tbuffer[30];\n    char_u\t*p;\n    int\t\tres;\n    hashitem_T\t*hi;\n    int\t\tis_global = FALSE;\n    char_u\t*fname = name;\n\n    if (ht == NULL)\n\treturn FAIL;\n    if (len < sizeof(buffer) - 1)\n    {\n\t// avoid an alloc/free for short names\n\tvim_strncpy(buffer, name, len);\n\tp = buffer;\n    }\n    else\n    {\n\tp = vim_strnsave(name, len);\n\tif (p == NULL)\n\t    return FAIL;\n    }\n\n    hi = hash_find(ht, p);\n    res = HASHITEM_EMPTY(hi) ? FAIL : OK;\n\n    // if not script-local, then perhaps imported\n    if (res == FAIL && find_imported(p, 0, FALSE) != NULL)\n\tres = OK;\n    if (p != buffer)\n\tvim_free(p);\n\n    // Find a function, so that a following \"->\" works.\n    // When used as a command require \"(\" or \"->\" to follow, \"Cmd\" is a user\n    // command while \"Cmd()\" is a function call.\n    if (res != OK)\n    {\n\tp = skipwhite(name + len);\n\n\tif (!cmd || name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n\t{\n\t    // Do not check for an internal function, since it might also be a\n\t    // valid command, such as \":split\" versus \"split()\".\n\t    // Skip \"g:\" before a function name.\n\t    if (name[0] == 'g' && name[1] == ':')\n\t    {\n\t\tis_global = TRUE;\n\t\tfname = name + 2;\n\t    }\n\t    if (find_func(fname, is_global) != NULL)\n\t\tres = OK;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Find the hashtab used for a variable name.\n * Return NULL if the name is not valid.\n * Set \"varname\" to the start of name without ':'.\n */\n    hashtab_T *\nfind_var_ht(char_u *name, char_u **varname)\n{\n    hashitem_T\t*hi;\n    hashtab_T\t*ht;\n\n    if (name[0] == NUL)\n\treturn NULL;\n    if (name[1] != ':')\n    {\n\t// The name must not start with a colon or #.\n\tif (name[0] == ':' || name[0] == AUTOLOAD_CHAR)\n\t    return NULL;\n\t*varname = name;\n\n\t// \"version\" is \"v:version\" in all scopes if scriptversion < 3.\n\t// Same for a few other variables marked with VV_COMPAT.\n\tif (in_old_script(3))\n\t{\n\t    hi = hash_find(&compat_hashtab, name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn &compat_hashtab;\n\t}\n\n\tht = get_funccal_local_ht();\n\tif (ht != NULL)\n\t    return ht;\t\t\t\t// local variable\n\n\t// In Vim9 script items at the script level are script-local, except\n\t// for autoload names.\n\tif (in_vim9script() && vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t{\n\t    ht = get_script_local_ht();\n\t    if (ht != NULL)\n\t\treturn ht;\n\t}\n\n\treturn &globvarht;\t\t\t// global variable\n    }\n    *varname = name + 2;\n    if (*name == 'g')\t\t\t\t// global variable\n\treturn &globvarht;\n    // There must be no ':' or '#' in the rest of the name, unless g: is used\n    if (vim_strchr(name + 2, ':') != NULL\n\t\t\t       || vim_strchr(name + 2, AUTOLOAD_CHAR) != NULL)\n\treturn NULL;\n    if (*name == 'b')\t\t\t\t// buffer variable\n\treturn &curbuf->b_vars->dv_hashtab;\n    if (*name == 'w')\t\t\t\t// window variable\n\treturn &curwin->w_vars->dv_hashtab;\n    if (*name == 't')\t\t\t\t// tab page variable\n\treturn &curtab->tp_vars->dv_hashtab;\n    if (*name == 'v')\t\t\t\t// v: variable\n\treturn &vimvarht;\n    if (get_current_funccal() != NULL\n\t       && get_current_funccal()->func->uf_def_status == UF_NOT_COMPILED)\n    {\n\t// a: and l: are only used in functions defined with \":function\"\n\tif (*name == 'a')\t\t\t// a: function argument\n\t    return get_funccal_args_ht();\n\tif (*name == 'l')\t\t\t// l: local function variable\n\t    return get_funccal_local_ht();\n    }\n    if (*name == 's')\t\t\t\t// script variable\n    {\n\tht = get_script_local_ht();\n\tif (ht != NULL)\n\t    return ht;\n    }\n    return NULL;\n}\n\n/*\n * Get the string value of a (global/local) variable.\n * Note: see tv_get_string() for how long the pointer remains valid.\n * Returns NULL when it doesn't exist.\n */\n    char_u *\nget_var_value(char_u *name)\n{\n    dictitem_T\t*v;\n\n    v = find_var(name, NULL, FALSE);\n    if (v == NULL)\n\treturn NULL;\n    return tv_get_string(&v->di_tv);\n}\n\n/*\n * Allocate a new hashtab for a sourced script.  It will be used while\n * sourcing this script and when executing functions defined in the script.\n */\n    void\nnew_script_vars(scid_T id)\n{\n    scriptvar_T *sv;\n\n    sv = ALLOC_CLEAR_ONE(scriptvar_T);\n    if (sv == NULL)\n\treturn;\n    init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);\n    SCRIPT_ITEM(id)->sn_vars = sv;\n}\n\n/*\n * Initialize dictionary \"dict\" as a scope and set variable \"dict_var\" to\n * point to it.\n */\n    void\ninit_var_dict(dict_T *dict, dictitem_T *dict_var, int scope)\n{\n    hash_init(&dict->dv_hashtab);\n    dict->dv_lock = 0;\n    dict->dv_scope = scope;\n    dict->dv_refcount = DO_NOT_FREE_CNT;\n    dict->dv_copyID = 0;\n    dict_var->di_tv.vval.v_dict = dict;\n    dict_var->di_tv.v_type = VAR_DICT;\n    dict_var->di_tv.v_lock = VAR_FIXED;\n    dict_var->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    dict_var->di_key[0] = NUL;\n}\n\n/*\n * Unreference a dictionary initialized by init_var_dict().\n */\n    void\nunref_var_dict(dict_T *dict)\n{\n    // Now the dict needs to be freed if no one else is using it, go back to\n    // normal reference counting.\n    dict->dv_refcount -= DO_NOT_FREE_CNT - 1;\n    dict_unref(dict);\n}\n\n/*\n * Clean up a list of internal variables.\n * Frees all allocated variables and the value they contain.\n * Clears hashtab \"ht\", does not free it.\n */\n    void\nvars_clear(hashtab_T *ht)\n{\n    vars_clear_ext(ht, TRUE);\n}\n\n/*\n * Like vars_clear(), but only free the value if \"free_val\" is TRUE.\n */\n    void\nvars_clear_ext(hashtab_T *ht, int free_val)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi;\n    dictitem_T\t*v;\n\n    hash_lock(ht);\n    todo = (int)ht->ht_used;\n    for (hi = ht->ht_array; todo > 0; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\n\t    // Free the variable.  Don't remove it from the hashtab,\n\t    // ht_array might change then.  hash_clear() takes care of it\n\t    // later.\n\t    v = HI2DI(hi);\n\t    if (free_val)\n\t\tclear_tv(&v->di_tv);\n\t    if (v->di_flags & DI_FLAGS_ALLOC)\n\t\tvim_free(v);\n\t}\n    }\n    hash_clear(ht);\n    hash_init(ht);\n}\n\n/*\n * Delete a variable from hashtab \"ht\" at item \"hi\".\n * Clear the variable value and free the dictitem.\n */\n    void\ndelete_var(hashtab_T *ht, hashitem_T *hi)\n{\n    dictitem_T\t*di = HI2DI(hi);\n\n    hash_remove(ht, hi);\n    clear_tv(&di->di_tv);\n    vim_free(di);\n}\n\n/*\n * List the value of one internal variable.\n */\n    static void\nlist_one_var(dictitem_T *v, char *prefix, int *first)\n{\n    char_u\t*tofree;\n    char_u\t*s;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    s = echo_string(&v->di_tv, &tofree, numbuf, get_copyID());\n    list_one_var_a(prefix, v->di_key, v->di_tv.v_type,\n\t\t\t\t\t s == NULL ? (char_u *)\"\" : s, first);\n    vim_free(tofree);\n}\n\n    static void\nlist_one_var_a(\n    char\t*prefix,\n    char_u\t*name,\n    int\t\ttype,\n    char_u\t*string,\n    int\t\t*first)  // when TRUE clear rest of screen and set to FALSE\n{\n    // don't use msg() or msg_attr() to avoid overwriting \"v:statusmsg\"\n    msg_start();\n    msg_puts(prefix);\n    if (name != NULL)\t// \"a:\" vars don't have a name stored\n\tmsg_puts((char *)name);\n    msg_putchar(' ');\n    msg_advance(22);\n    if (type == VAR_NUMBER)\n\tmsg_putchar('#');\n    else if (type == VAR_FUNC || type == VAR_PARTIAL)\n\tmsg_putchar('*');\n    else if (type == VAR_LIST)\n    {\n\tmsg_putchar('[');\n\tif (*string == '[')\n\t    ++string;\n    }\n    else if (type == VAR_DICT)\n    {\n\tmsg_putchar('{');\n\tif (*string == '{')\n\t    ++string;\n    }\n    else\n\tmsg_putchar(' ');\n\n    msg_outtrans(string);\n\n    if (type == VAR_FUNC || type == VAR_PARTIAL)\n\tmsg_puts(\"()\");\n    if (*first)\n    {\n\tmsg_clr_eos();\n\t*first = FALSE;\n    }\n}\n\n/*\n * Set variable \"name\" to value in \"tv\".\n * If the variable already exists, the value is updated.\n * Otherwise the variable is created.\n */\n    void\nset_var(\n    char_u\t*name,\n    typval_T\t*tv,\n    int\t\tcopy)\t    // make copy of value in \"tv\"\n{\n    set_var_const(name, 0, NULL, tv, copy, ASSIGN_DECL, 0);\n}\n\n/*\n * Set variable \"name\" to value in \"tv_arg\".\n * When \"sid\" is non-zero \"name\" is in the script with this ID.\n * If the variable already exists and \"is_const\" is FALSE the value is updated.\n * Otherwise the variable is created.\n */\n    void\nset_var_const(\n    char_u\t*name,\n    scid_T\tsid,\n    type_T\t*type_arg,\n    typval_T\t*tv_arg,\n    int\t\tcopy,\t    // make copy of value in \"tv\"\n    int\t\tflags_arg,  // ASSIGN_CONST, ASSIGN_FINAL, etc.\n    int\t\tvar_idx)    // index for \":let [a, b] = list\"\n{\n    typval_T\t*tv = tv_arg;\n    type_T\t*type = type_arg;\n    typval_T\tbool_tv;\n    dictitem_T\t*di;\n    typval_T\t*dest_tv = NULL;\n    char_u\t*varname;\n    char_u\t*name_tofree = NULL;\n    hashtab_T\t*ht = NULL;\n    int\t\tis_script_local;\n    int\t\tvim9script = in_vim9script();\n    int\t\tvar_in_vim9script;\n    int\t\tvar_in_autoload = FALSE;\n    int\t\tflags = flags_arg;\n    int\t\tfree_tv_arg = !copy;  // free tv_arg if not used\n\n    if (sid != 0)\n    {\n\tif (SCRIPT_ID_VALID(sid))\n\t    ht = &SCRIPT_VARS(sid);\n\tvarname = name;\n    }\n    else\n    {\n\tscriptitem_T *si;\n\n\tif (in_vim9script() && is_export\n\t\t&& SCRIPT_ID_VALID(current_sctx.sc_sid)\n\t\t&& (si = SCRIPT_ITEM(current_sctx.sc_sid))\n\t\t\t\t\t\t   ->sn_autoload_prefix != NULL)\n\t{\n\t    // In a vim9 autoload script an exported variable is put in the\n\t    // global namespace with the autoload prefix.\n\t    var_in_autoload = TRUE;\n\t    varname = concat_str(si->sn_autoload_prefix, name);\n\t    if (varname == NULL)\n\t\tgoto failed;\n\t    name_tofree = varname;\n\t    ht = &globvarht;\n\t}\n\telse\n\t    ht = find_var_ht(name, &varname);\n    }\n    if (ht == NULL || *varname == NUL)\n    {\n\tsemsg(_(e_illegal_variable_name_str), name);\n\tgoto failed;\n    }\n    is_script_local = ht == get_script_local_ht() || sid != 0\n\t\t\t\t\t\t\t    || var_in_autoload;\n\n    if (vim9script\n\t    && !is_script_local\n\t    && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t    && (flags & (ASSIGN_CONST | ASSIGN_FINAL)) == 0\n\t    && name[1] == ':')\n    {\n\tvim9_declare_error(name);\n\tgoto failed;\n    }\n    if ((flags & ASSIGN_FOR_LOOP) && name[1] == ':'\n\t\t\t      && vim_strchr((char_u *)\"gwbt\", name[0]) != NULL)\n\t// Do not make g:var, w:var, b:var or t:var final.\n\tflags &= ~ASSIGN_FINAL;\n\n    var_in_vim9script = is_script_local && current_script_is_vim9();\n    if (var_in_vim9script && name[0] == '_' && name[1] == NUL)\n    {\n\t// For \"[a, _] = list\" the underscore is ignored.\n\tif ((flags & ASSIGN_UNPACK) == 0)\n\t    emsg(_(e_cannot_use_underscore_here));\n\tgoto failed;\n    }\n\n    di = find_var_in_ht(ht, 0, varname, TRUE);\n\n    if (di == NULL && var_in_vim9script)\n    {\n\timported_T  *import = find_imported(varname, 0, FALSE);\n\n\tif (import != NULL)\n\t{\n\t    // imported name space cannot be used\n\t    if ((flags & ASSIGN_NO_DECL) == 0)\n\t    {\n\t\tsemsg(_(e_redefining_imported_item_str), name);\n\t\tgoto failed;\n\t    }\n\t    semsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    goto failed;\n\t}\n\tif (!in_vim9script())\n\t{\n\t    semsg(_(e_cannot_create_vim9_script_variable_in_function_str),\n\t\t\t\t\t\t\t\t\t name);\n\t    goto failed;\n\t}\n    }\n\n    if (dest_tv == NULL)\n    {\n\t// Search in parent scope which is possible to reference from lambda\n\tif (di == NULL)\n\t    di = find_var_in_scoped_ht(name, TRUE);\n\n\tif ((tv->v_type == VAR_FUNC || tv->v_type == VAR_PARTIAL)\n\t\t\t\t      && var_wrong_func_name(name, di == NULL))\n\t    goto failed;\n\n\tif (need_convert_to_bool(type, tv))\n\t{\n\t    // Destination is a bool and the value is not, but it can be\n\t    // converted.\n\t    CLEAR_FIELD(bool_tv);\n\t    bool_tv.v_type = VAR_BOOL;\n\t    bool_tv.vval.v_number = tv2bool(tv) ? VVAL_TRUE : VVAL_FALSE;\n\t    tv = &bool_tv;\n\t}\n\n\tif (di != NULL)\n\t{\n\t    // Item already exists.  Allowed to replace when reloading.\n\t    if ((di->di_flags & DI_FLAGS_RELOAD) == 0)\n\t    {\n\t\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t\t{\n\t\t    emsg(_(e_cannot_modify_existing_variable));\n\t\t    goto failed;\n\t\t}\n\n\t\tif (is_script_local && vim9script\n\t\t\t      && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0)\n\t\t{\n\t\t    semsg(_(e_redefining_script_item_str), name);\n\t\t    goto failed;\n\t\t}\n\n\t\tif (var_in_vim9script && (flags & ASSIGN_FOR_LOOP) == 0)\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\t\t    svar_T  *sv = find_typval_in_script(&di->di_tv, sid);\n\n\t\t    if (sv != NULL)\n\t\t    {\n\t\t\t// check the type and adjust to bool if needed\n\t\t\twhere.wt_index = var_idx;\n\t\t\twhere.wt_variable = TRUE;\n\t\t\tif (check_script_var_type(sv, tv, name, where) == FAIL)\n\t\t\t    goto failed;\n\t\t\tif (type == NULL)\n\t\t\t    type = sv->sv_type;\n\t\t    }\n\t\t}\n\n\t\tif ((flags & ASSIGN_FOR_LOOP) == 0\n\t\t\t\t     && var_check_permission(di, name) == FAIL)\n\t\t    goto failed;\n\t    }\n\t    else\n\t    {\n\t\t// can only redefine once\n\t\tdi->di_flags &= ~DI_FLAGS_RELOAD;\n\n\t\t// A Vim9 script-local variable is also present in sn_all_vars\n\t\t// and sn_var_vals.  It may set \"type\" from \"tv\".\n\t\tif (var_in_vim9script || var_in_autoload)\n\t\t    update_vim9_script_var(FALSE, di,\n\t\t\t    var_in_autoload ? name : di->di_key, flags,\n\t\t\t    tv, &type, (flags & ASSIGN_NO_MEMBER_TYPE) == 0);\n\t    }\n\n\t    // existing variable, need to clear the value\n\n\t    // Handle setting internal di: variables separately where needed to\n\t    // prevent changing the type.\n\t    if (ht == &vimvarht)\n\t    {\n\t\tif (di->di_tv.v_type == VAR_STRING)\n\t\t{\n\t\t    VIM_CLEAR(di->di_tv.vval.v_string);\n\t\t    if (copy || tv->v_type != VAR_STRING)\n\t\t    {\n\t\t\tchar_u *val = tv_get_string(tv);\n\n\t\t\t// Careful: when assigning to v:errmsg and\n\t\t\t// tv_get_string() causes an error message the variable\n\t\t\t// will already be set.\n\t\t\tif (di->di_tv.vval.v_string == NULL)\n\t\t\t    di->di_tv.vval.v_string = vim_strsave(val);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Take over the string to avoid an extra alloc/free.\n\t\t\tdi->di_tv.vval.v_string = tv->vval.v_string;\n\t\t\ttv->vval.v_string = NULL;\n\t\t    }\n\t\t    goto failed;\n\t\t}\n\t\telse if (di->di_tv.v_type == VAR_NUMBER)\n\t\t{\n\t\t    di->di_tv.vval.v_number = tv_get_number(tv);\n\t\t    if (STRCMP(varname, \"searchforward\") == 0)\n\t\t\tset_search_direction(di->di_tv.vval.v_number\n\t\t\t\t\t\t\t\t  ? '/' : '?');\n#ifdef FEAT_SEARCH_EXTRA\n\t\t    else if (STRCMP(varname, \"hlsearch\") == 0)\n\t\t    {\n\t\t\tno_hlsearch = !di->di_tv.vval.v_number;\n\t\t\tredraw_all_later(SOME_VALID);\n\t\t    }\n#endif\n\t\t    goto failed;\n\t\t}\n\t\telse if (di->di_tv.v_type != tv->v_type)\n\t\t{\n\t\t    semsg(_(e_setting_str_to_value_with_wrong_type), name);\n\t\t    goto failed;\n\t\t}\n\t    }\n\n\t    clear_tv(&di->di_tv);\n\t}\n\telse\n\t{\n\t    // Item not found, check if a function already exists.\n\t    if (is_script_local && (flags & (ASSIGN_NO_DECL | ASSIGN_DECL)) == 0\n\t\t   && lookup_scriptitem(name, STRLEN(name), FALSE, NULL) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // add a new variable\n\t    if (var_in_vim9script && (flags & ASSIGN_NO_DECL))\n\t    {\n\t\tsemsg(_(e_unknown_variable_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // Can't add \"v:\" or \"a:\" variable.\n\t    if (ht == &vimvarht || ht == get_funccal_args_ht())\n\t    {\n\t\tsemsg(_(e_illegal_variable_name_str), name);\n\t\tgoto failed;\n\t    }\n\n\t    // Make sure the variable name is valid.  In Vim9 script an\n\t    // autoload variable must be prefixed with \"g:\" unless in an\n\t    // autoload script.\n\t    if (!valid_varname(varname, -1, !vim9script\n\t\t\t    || STRNCMP(name, \"g:\", 2) == 0 || var_in_autoload))\n\t\tgoto failed;\n\n\t    di = alloc(sizeof(dictitem_T) + STRLEN(varname));\n\t    if (di == NULL)\n\t\tgoto failed;\n\t    STRCPY(di->di_key, varname);\n\t    if (hash_add(ht, DI2HIKEY(di)) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\tgoto failed;\n\t    }\n\t    di->di_flags = DI_FLAGS_ALLOC;\n\t    if (flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\tdi->di_flags |= DI_FLAGS_LOCK;\n\n\t    // A Vim9 script-local variable is also added to sn_all_vars and\n\t    // sn_var_vals. It may set \"type\" from \"tv\".\n\t    if (var_in_vim9script || var_in_autoload)\n\t\tupdate_vim9_script_var(TRUE, di,\n\t\t\tvar_in_autoload ? name : di->di_key, flags,\n\t\t\t      tv, &type, (flags & ASSIGN_NO_MEMBER_TYPE) == 0);\n\t}\n\n\tdest_tv = &di->di_tv;\n    }\n\n    if (copy || tv->v_type == VAR_NUMBER || tv->v_type == VAR_FLOAT)\n\tcopy_tv(tv, dest_tv);\n    else\n    {\n\t*dest_tv = *tv;\n\tdest_tv->v_lock = 0;\n\tinit_tv(tv);\n    }\n    free_tv_arg = FALSE;\n\n    if (vim9script && type != NULL)\n\tset_tv_type(dest_tv, type);\n\n    // \":const var = value\" locks the value\n    // \":final var = value\" locks \"var\"\n    if (flags & ASSIGN_CONST)\n\t// Like :lockvar! name: lock the value and what it contains, but only\n\t// if the reference count is up to one.  That locks only literal\n\t// values.\n\titem_lock(dest_tv, DICT_MAXNEST, TRUE, TRUE);\n\nfailed:\n    vim_free(name_tofree);\n    if (free_tv_arg)\n\tclear_tv(tv_arg);\n}\n\n/*\n * Check in this order for backwards compatibility:\n * - Whether the variable is read-only\n * - Whether the variable value is locked\n * - Whether the variable is locked\n */\n    int\nvar_check_permission(dictitem_T *di, char_u *name)\n{\n    if (var_check_ro(di->di_flags, name, FALSE)\n\t\t    || value_check_lock(di->di_tv.v_lock, name, FALSE)\n\t\t    || var_check_lock(di->di_flags, name, FALSE))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is read-only.\n * Also give an error message.\n */\n    int\nvar_check_ro(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_RO)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_readonly_variable));\n\telse\n\t    semsg(_(e_cannot_change_readonly_variable_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if ((flags & DI_FLAGS_RO_SBX) && sandbox)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_set_variable_in_sandbox));\n\telse\n\t    semsg(_(e_cannot_set_variable_in_sandbox_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is locked.\n * Also give an error message.\n */\n    int\nvar_check_lock(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_LOCK)\n    {\n\tsemsg(_(e_variable_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if di_flags \"flags\" indicates variable \"name\" is fixed.\n * Also give an error message.\n */\n    int\nvar_check_fixed(int flags, char_u *name, int use_gettext)\n{\n    if (flags & DI_FLAGS_FIX)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_delete_variable));\n\telse\n\t    semsg(_(e_cannot_delete_variable_str),\n\t\t\t\t      use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if a funcref is assigned to a valid variable name.\n * Return TRUE and give an error if not.\n */\n    int\nvar_wrong_func_name(\n    char_u *name,    // points to start of variable name\n    int    new_var)  // TRUE when creating the variable\n{\n    // Allow for w: b: s: and t:.  In Vim9 script s: is not allowed, because\n    // the name can be used without the s: prefix.\n    if (!((vim_strchr((char_u *)\"wbt\", name[0]) != NULL\n\t\t    || (!in_vim9script() && name[0] == 's')) && name[1] == ':')\n\t    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')\n\t\t\t\t\t\t     ? name[2] : name[0]))\n    {\n\tsemsg(_(e_funcref_variable_name_must_start_with_capital_str), name);\n\treturn TRUE;\n    }\n    // Don't allow hiding a function.  When \"v\" is not NULL we might be\n    // assigning another function to the same var, the type is checked\n    // below.\n    if (new_var && function_exists(name, FALSE))\n    {\n\tsemsg(_(e_variable_name_conflicts_with_existing_function_str),\n\t\t\t\t\t\t\t\t    name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if \"flags\" indicates variable \"name\" has a locked (immutable)\n * value.  Also give an error message, using \"name\" or _(\"name\") when\n * \"use_gettext\" is TRUE.\n */\n    int\nvalue_check_lock(int lock, char_u *name, int use_gettext)\n{\n    if (lock & VAR_LOCKED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_value_is_locked));\n\telse\n\t    semsg(_(e_value_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if (lock & VAR_FIXED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_value));\n\telse\n\t    semsg(_(e_cannot_change_value_of_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check if a variable name is valid.  When \"autoload\" is true \"#\" is allowed.\n * If \"len\" is -1 use all of \"varname\", otherwise up to \"varname[len]\".\n * Return FALSE and give an error if not.\n */\n    int\nvalid_varname(char_u *varname, int len, int autoload)\n{\n    char_u *p;\n\n    for (p = varname; len < 0 ? *p != NUL : p < varname + len; ++p)\n\tif (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))\n\t\t\t\t\t && !(autoload && *p == AUTOLOAD_CHAR))\n\t{\n\t    semsg(_(e_illegal_variable_name_str), varname);\n\t    return FALSE;\n\t}\n    return TRUE;\n}\n\n/*\n * getwinvar() and gettabwinvar()\n */\n    static void\ngetwinvar(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\toff)\t    // 1 for gettabwinvar()\n{\n    win_T\t*win;\n    char_u\t*varname;\n    dictitem_T\t*v;\n    tabpage_T\t*tp = NULL;\n    int\t\tdone = FALSE;\n    switchwin_T\tswitchwin;\n    int\t\tneed_switch_win;\n\n    if (off == 1)\n\ttp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    else\n\ttp = curtab;\n    win = find_win_by_nr(&argvars[off], tp);\n    varname = tv_get_string_chk(&argvars[off + 1]);\n    ++emsg_off;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (win != NULL && varname != NULL)\n    {\n\t// Set curwin to be our win, temporarily.  Also set the tabpage,\n\t// otherwise the window is not valid. Only do this when needed,\n\t// autocommands get blocked.\n\tneed_switch_win = !(tp == curtab && win == curwin);\n\tif (!need_switch_win\n\t\t  || switch_win(&switchwin, win, tp, TRUE) == OK)\n\t{\n\t    if (*varname == '&')\n\t    {\n\t\tif (varname[1] == NUL)\n\t\t{\n\t\t    // get all window-local options in a dict\n\t\t    dict_T\t*opts = get_winbuf_options(FALSE);\n\n\t\t    if (opts != NULL)\n\t\t    {\n\t\t\trettv_dict_set(rettv, opts);\n\t\t\tdone = TRUE;\n\t\t    }\n\t\t}\n\t\telse if (eval_option(&varname, rettv, 1) == OK)\n\t\t    // window-local-option\n\t\t    done = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// Look up the variable.\n\t\t// Let getwinvar({nr}, \"\") return the \"w:\" dictionary.\n\t\tv = find_var_in_ht(&win->w_vars->dv_hashtab, 'w',\n\t\t\t\t\t\t\t      varname, FALSE);\n\t\tif (v != NULL)\n\t\t{\n\t\t    copy_tv(&v->di_tv, rettv);\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t}\n\n\tif (need_switch_win)\n\t    // restore previous notion of curwin\n\t    restore_win(&switchwin, TRUE);\n    }\n\n    if (!done && argvars[off + 2].v_type != VAR_UNKNOWN)\n\t// use the default return value\n\tcopy_tv(&argvars[off + 2], rettv);\n\n    --emsg_off;\n}\n\n/*\n * Set option \"varname\" to the value of \"varp\" for the current buffer/window.\n */\n    static void\nset_option_from_tv(char_u *varname, typval_T *varp)\n{\n    long\tnumval = 0;\n    char_u\t*strval;\n    char_u\tnbuf[NUMBUFLEN];\n    int\t\terror = FALSE;\n\n    if (varp->v_type == VAR_BOOL)\n    {\n\tnumval = (long)varp->vval.v_number;\n\tstrval = (char_u *)\"0\";  // avoid using \"false\"\n    }\n    else\n    {\n\tif (!in_vim9script() || varp->v_type != VAR_STRING)\n\t    numval = (long)tv_get_number_chk(varp, &error);\n\tstrval = tv_get_string_buf_chk(varp, nbuf);\n    }\n    if (!error && strval != NULL)\n\tset_option_value(varname, numval, strval, OPT_LOCAL);\n}\n\n/*\n * \"setwinvar()\" and \"settabwinvar()\" functions\n */\n    static void\nsetwinvar(typval_T *argvars, int off)\n{\n    win_T\t*win;\n    switchwin_T\tswitchwin;\n    int\t\tneed_switch_win;\n    char_u\t*varname, *winvarname;\n    typval_T\t*varp;\n    tabpage_T\t*tp = NULL;\n\n    if (check_secure())\n\treturn;\n\n    if (off == 1)\n\ttp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    else\n\ttp = curtab;\n    win = find_win_by_nr(&argvars[off], tp);\n    varname = tv_get_string_chk(&argvars[off + 1]);\n    varp = &argvars[off + 2];\n\n    if (win != NULL && varname != NULL && varp != NULL)\n    {\n\tneed_switch_win = !(tp == curtab && win == curwin);\n\tif (!need_switch_win\n\t       || switch_win(&switchwin, win, tp, TRUE) == OK)\n\t{\n\t    if (*varname == '&')\n\t\tset_option_from_tv(varname + 1, varp);\n\t    else\n\t    {\n\t\twinvarname = alloc(STRLEN(varname) + 3);\n\t\tif (winvarname != NULL)\n\t\t{\n\t\t    STRCPY(winvarname, \"w:\");\n\t\t    STRCPY(winvarname + 2, varname);\n\t\t    set_var(winvarname, varp, TRUE);\n\t\t    vim_free(winvarname);\n\t\t}\n\t    }\n\t}\n\tif (need_switch_win)\n\t    restore_win(&switchwin, TRUE);\n    }\n}\n\n/*\n * reset v:option_new, v:option_old, v:option_oldlocal, v:option_oldglobal,\n * v:option_type, and v:option_command.\n */\n    void\nreset_v_option_vars(void)\n{\n    set_vim_var_string(VV_OPTION_NEW,  NULL, -1);\n    set_vim_var_string(VV_OPTION_OLD,  NULL, -1);\n    set_vim_var_string(VV_OPTION_OLDLOCAL, NULL, -1);\n    set_vim_var_string(VV_OPTION_OLDGLOBAL, NULL, -1);\n    set_vim_var_string(VV_OPTION_TYPE, NULL, -1);\n    set_vim_var_string(VV_OPTION_COMMAND, NULL, -1);\n}\n\n/*\n * Add an assert error to v:errors.\n */\n    void\nassert_error(garray_T *gap)\n{\n    struct vimvar   *vp = &vimvars[VV_ERRORS];\n\n    if (vp->vv_tv_type != VAR_LIST || vimvars[VV_ERRORS].vv_list == NULL)\n\t// Make sure v:errors is a list.\n\tset_vim_var_list(VV_ERRORS, list_alloc());\n    list_append_string(vimvars[VV_ERRORS].vv_list, gap->ga_data, gap->ga_len);\n}\n\n    int\nvar_exists(char_u *var)\n{\n    char_u\t*arg = var;\n    char_u\t*name;\n    char_u\t*tofree;\n    typval_T    tv;\n    int\t\tlen = 0;\n    int\t\tn = FALSE;\n\n    // get_name_len() takes care of expanding curly braces\n    name = var;\n    len = get_name_len(&arg, &tofree, TRUE, FALSE);\n    if (len > 0)\n    {\n\tif (tofree != NULL)\n\t    name = tofree;\n\tn = (eval_variable(name, len, 0, &tv, NULL,\n\t\t\t\t EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT) == OK);\n\tif (n)\n\t{\n\t    // handle d.key, l[idx], f(expr)\n\t    arg = skipwhite(arg);\n\t    n = (handle_subscript(&arg, name, &tv, &EVALARG_EVALUATE,\n\t\t\t\t\t\t\t\t FALSE) == OK);\n\t    if (n)\n\t\tclear_tv(&tv);\n\t}\n    }\n    if (*arg != NUL)\n\tn = FALSE;\n\n    vim_free(tofree);\n    return n;\n}\n\nstatic lval_T\t*redir_lval = NULL;\n#define EVALCMD_BUSY (redir_lval == (lval_T *)&redir_lval)\nstatic garray_T redir_ga;\t// only valid when redir_lval is not NULL\nstatic char_u\t*redir_endp = NULL;\nstatic char_u\t*redir_varname = NULL;\n\n    int\nalloc_redir_lval(void)\n{\n    redir_lval = ALLOC_CLEAR_ONE(lval_T);\n    if (redir_lval == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n    void\nclear_redir_lval(void)\n{\n    VIM_CLEAR(redir_lval);\n}\n\n    void\ninit_redir_ga(void)\n{\n    ga_init2(&redir_ga, sizeof(char), 500);\n}\n\n/*\n * Start recording command output to a variable\n * When \"append\" is TRUE append to an existing variable.\n * Returns OK if successfully completed the setup.  FAIL otherwise.\n */\n    int\nvar_redir_start(char_u *name, int append)\n{\n    int\t\tcalled_emsg_before;\n    typval_T\ttv;\n\n    // Catch a bad name early.\n    if (!eval_isnamec1(*name))\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    // Make a copy of the name, it is used in redir_lval until redir ends.\n    redir_varname = vim_strsave(name);\n    if (redir_varname == NULL)\n\treturn FAIL;\n\n    if (alloc_redir_lval() == FAIL)\n    {\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    // The output is stored in growarray \"redir_ga\" until redirection ends.\n    init_redir_ga();\n\n    // Parse the variable name (can be a dict or list entry).\n    redir_endp = get_lval(redir_varname, NULL, redir_lval, FALSE, FALSE, 0,\n\t\t\t\t\t\t\t     FNE_CHECK_START);\n    if (redir_endp == NULL || redir_lval->ll_name == NULL || *redir_endp != NUL)\n    {\n\tclear_lval(redir_lval);\n\tif (redir_endp != NULL && *redir_endp != NUL)\n\t    // Trailing characters are present after the variable name\n\t    semsg(_(e_trailing_characters_str), redir_endp);\n\telse\n\t    semsg(_(e_invalid_argument_str), name);\n\tredir_endp = NULL;  // don't store a value, only cleanup\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    // check if we can write to the variable: set it to or append an empty\n    // string\n    called_emsg_before = called_emsg;\n    tv.v_type = VAR_STRING;\n    tv.vval.v_string = (char_u *)\"\";\n    if (append)\n\tset_var_lval(redir_lval, redir_endp, &tv, TRUE,\n\t\t\t\t\t     ASSIGN_NO_DECL, (char_u *)\".\", 0);\n    else\n\tset_var_lval(redir_lval, redir_endp, &tv, TRUE,\n\t\t\t\t\t     ASSIGN_NO_DECL, (char_u *)\"=\", 0);\n    clear_lval(redir_lval);\n    if (called_emsg > called_emsg_before)\n    {\n\tredir_endp = NULL;  // don't store a value, only cleanup\n\tvar_redir_stop();\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Append \"value[value_len]\" to the variable set by var_redir_start().\n * The actual appending is postponed until redirection ends, because the value\n * appended may in fact be the string we write to, changing it may cause freed\n * memory to be used:\n *   :redir => foo\n *   :let foo\n *   :redir END\n */\n    void\nvar_redir_str(char_u *value, int value_len)\n{\n    int\t\tlen;\n\n    if (redir_lval == NULL)\n\treturn;\n\n    if (value_len == -1)\n\tlen = (int)STRLEN(value);\t// Append the entire string\n    else\n\tlen = value_len;\t\t// Append only \"value_len\" characters\n\n    if (ga_grow(&redir_ga, len) == OK)\n    {\n\tmch_memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, len);\n\tredir_ga.ga_len += len;\n    }\n    else\n\tvar_redir_stop();\n}\n\n/*\n * Stop redirecting command output to a variable.\n * Frees the allocated memory.\n */\n    void\nvar_redir_stop(void)\n{\n    typval_T\ttv;\n\n    if (EVALCMD_BUSY)\n    {\n\tredir_lval = NULL;\n\treturn;\n    }\n\n    if (redir_lval != NULL)\n    {\n\t// If there was no error: assign the text to the variable.\n\tif (redir_endp != NULL)\n\t{\n\t    ga_append(&redir_ga, NUL);  // Append the trailing NUL.\n\t    tv.v_type = VAR_STRING;\n\t    tv.vval.v_string = redir_ga.ga_data;\n\t    // Call get_lval() again, if it's inside a Dict or List it may\n\t    // have changed.\n\t    redir_endp = get_lval(redir_varname, NULL, redir_lval,\n\t\t\t\t\tFALSE, FALSE, 0, FNE_CHECK_START);\n\t    if (redir_endp != NULL && redir_lval->ll_name != NULL)\n\t\tset_var_lval(redir_lval, redir_endp, &tv, FALSE, 0,\n\t\t\t\t\t\t\t     (char_u *)\".\", 0);\n\t    clear_lval(redir_lval);\n\t}\n\n\t// free the collected output\n\tVIM_CLEAR(redir_ga.ga_data);\n\n\tVIM_CLEAR(redir_lval);\n    }\n    VIM_CLEAR(redir_varname);\n}\n\n/*\n * Get the collected redirected text and clear redir_ga.\n */\n    char_u *\nget_clear_redir_ga(void)\n{\n    char_u *res;\n\n    ga_append(&redir_ga, NUL);  // Append the trailing NUL.\n    res = redir_ga.ga_data;\n    redir_ga.ga_data = NULL;\n    return res;\n}\n\n/*\n * \"gettabvar()\" function\n */\n    void\nf_gettabvar(typval_T *argvars, typval_T *rettv)\n{\n    switchwin_T\tswitchwin;\n    tabpage_T\t*tp;\n    dictitem_T\t*v;\n    char_u\t*varname;\n    int\t\tdone = FALSE;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    if (tp != NULL && varname != NULL)\n    {\n\t// Set tp to be our tabpage, temporarily.  Also set the window to the\n\t// first window in the tabpage, otherwise the window is not valid.\n\tif (switch_win(&switchwin,\n\t\ttp == curtab || tp->tp_firstwin == NULL ? firstwin\n\t\t\t\t\t    : tp->tp_firstwin, tp, TRUE) == OK)\n\t{\n\t    // look up the variable\n\t    // Let gettabvar({nr}, \"\") return the \"t:\" dictionary.\n\t    v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't', varname, FALSE);\n\t    if (v != NULL)\n\t    {\n\t\tcopy_tv(&v->di_tv, rettv);\n\t\tdone = TRUE;\n\t    }\n\t}\n\n\t// restore previous notion of curwin\n\trestore_win(&switchwin, TRUE);\n    }\n\n    if (!done && argvars[2].v_type != VAR_UNKNOWN)\n\tcopy_tv(&argvars[2], rettv);\n}\n\n/*\n * \"gettabwinvar()\" function\n */\n    void\nf_gettabwinvar(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    getwinvar(argvars, rettv, 1);\n}\n\n/*\n * \"getwinvar()\" function\n */\n    void\nf_getwinvar(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    getwinvar(argvars, rettv, 0);\n}\n\n/*\n * \"getbufvar()\" function\n */\n    void\nf_getbufvar(typval_T *argvars, typval_T *rettv)\n{\n    buf_T\t*buf;\n    char_u\t*varname;\n    dictitem_T\t*v;\n    int\t\tdone = FALSE;\n\n    if (in_vim9script()\n\t    && (check_for_buffer_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf_from_arg(&argvars[0]);\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n\n    if (buf != NULL && varname != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    buf_T\t*save_curbuf = curbuf;\n\n\t    // set curbuf to be our buf, temporarily\n\t    curbuf = buf;\n\n\t    if (varname[1] == NUL)\n\t    {\n\t\t// get all buffer-local options in a dict\n\t\tdict_T\t*opts = get_winbuf_options(TRUE);\n\n\t\tif (opts != NULL)\n\t\t{\n\t\t    rettv_dict_set(rettv, opts);\n\t\t    done = TRUE;\n\t\t}\n\t    }\n\t    else if (eval_option(&varname, rettv, TRUE) == OK)\n\t\t// buffer-local-option\n\t\tdone = TRUE;\n\n\t    // restore previous notion of curbuf\n\t    curbuf = save_curbuf;\n\t}\n\telse\n\t{\n\t    // Look up the variable.\n\t    if (*varname == NUL)\n\t\t// Let getbufvar({nr}, \"\") return the \"b:\" dictionary.\n\t\tv = &buf->b_bufvar;\n\t    else\n\t\tv = find_var_in_ht(&buf->b_vars->dv_hashtab, 'b',\n\t\t\t\t\t\t\t       varname, FALSE);\n\t    if (v != NULL)\n\t    {\n\t\tcopy_tv(&v->di_tv, rettv);\n\t\tdone = TRUE;\n\t    }\n\t}\n    }\n\n    if (!done && argvars[2].v_type != VAR_UNKNOWN)\n\t// use the default value\n\tcopy_tv(&argvars[2], rettv);\n}\n\n/*\n * \"settabvar()\" function\n */\n    void\nf_settabvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc(STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t// Restore current tabpage\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}\n\n/*\n * \"settabwinvar()\" function\n */\n    void\nf_settabwinvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_string_arg(argvars, 2) == FAIL))\n\treturn;\n\n    setwinvar(argvars, 1);\n}\n\n/*\n * \"setwinvar()\" function\n */\n    void\nf_setwinvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    setwinvar(argvars, 0);\n}\n\n/*\n * \"setbufvar()\" function\n */\n    void\nf_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf;\n    char_u\t*varname, *bufvarname;\n    typval_T\t*varp;\n\n    if (check_secure())\n\treturn;\n\n    if (in_vim9script()\n\t    && (check_for_buffer_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL))\n\treturn;\n\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf_from_arg(&argvars[0]);\n    varp = &argvars[2];\n\n    if (buf != NULL && varname != NULL && varp != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    aco_save_T\taco;\n\n\t    // set curbuf to be our buf, temporarily\n\t    aucmd_prepbuf(&aco, buf);\n\n\t    set_option_from_tv(varname + 1, varp);\n\n\t    // reset notion of buffer\n\t    aucmd_restbuf(&aco);\n\t}\n\telse\n\t{\n\t    bufvarname = alloc(STRLEN(varname) + 3);\n\t    if (bufvarname != NULL)\n\t    {\n\t\tbuf_T *save_curbuf = curbuf;\n\n\t\tcurbuf = buf;\n\t\tSTRCPY(bufvarname, \"b:\");\n\t\tSTRCPY(bufvarname + 2, varname);\n\t\tset_var(bufvarname, varp, TRUE);\n\t\tvim_free(bufvarname);\n\t\tcurbuf = save_curbuf;\n\t    }\n\t}\n    }\n}\n\n/*\n * Get a callback from \"arg\".  It can be a Funcref or a function name.\n * When \"arg\" is zero return an empty string.\n * \"cb_name\" is not allocated.\n * \"cb_name\" is set to NULL for an invalid argument.\n */\n    callback_T\nget_callback(typval_T *arg)\n{\n    callback_T  res;\n    int\t\tr = OK;\n\n    res.cb_free_name = FALSE;\n    if (arg->v_type == VAR_PARTIAL && arg->vval.v_partial != NULL)\n    {\n\tres.cb_partial = arg->vval.v_partial;\n\t++res.cb_partial->pt_refcount;\n\tres.cb_name = partial_name(res.cb_partial);\n    }\n    else\n    {\n\tres.cb_partial = NULL;\n\tif (arg->v_type == VAR_STRING && arg->vval.v_string != NULL\n\t\t\t\t\t       && isdigit(*arg->vval.v_string))\n\t    r = FAIL;\n\telse if (arg->v_type == VAR_FUNC || arg->v_type == VAR_STRING)\n\t{\n\t    if (arg->v_type == VAR_STRING)\n\t    {\n\t\tchar_u *name;\n\n\t\tname = get_scriptlocal_funcname(arg->vval.v_string);\n\t\tif (name != NULL)\n\t\t{\n\t\t    vim_free(arg->vval.v_string);\n\t\t    arg->vval.v_string = name;\n\t\t}\n\t    }\n\n\t    res.cb_name = arg->vval.v_string;\n\t    func_ref(res.cb_name);\n\t}\n\telse if (arg->v_type == VAR_NUMBER && arg->vval.v_number == 0)\n\t    res.cb_name = (char_u *)\"\";\n\telse\n\t    r = FAIL;\n\n\tif (r == FAIL)\n\t{\n\t    emsg(_(e_invalid_callback_argument));\n\t    res.cb_name = NULL;\n\t}\n    }\n    return res;\n}\n\n/*\n * Copy a callback into a typval_T.\n */\n    void\nput_callback(callback_T *cb, typval_T *tv)\n{\n    if (cb->cb_partial != NULL)\n    {\n\ttv->v_type = VAR_PARTIAL;\n\ttv->vval.v_partial = cb->cb_partial;\n\t++tv->vval.v_partial->pt_refcount;\n    }\n    else\n    {\n\ttv->v_type = VAR_FUNC;\n\ttv->vval.v_string = vim_strsave(cb->cb_name);\n\tfunc_ref(cb->cb_name);\n    }\n}\n\n/*\n * Make a copy of \"src\" into \"dest\", allocating the function name if needed,\n * without incrementing the refcount.\n */\n    void\nset_callback(callback_T *dest, callback_T *src)\n{\n    if (src->cb_partial == NULL)\n    {\n\t// just a function name, make a copy\n\tdest->cb_name = vim_strsave(src->cb_name);\n\tdest->cb_free_name = TRUE;\n    }\n    else\n    {\n\t// cb_name is a pointer into cb_partial\n\tdest->cb_name = src->cb_name;\n\tdest->cb_free_name = FALSE;\n    }\n    dest->cb_partial = src->cb_partial;\n}\n\n/*\n * Copy callback from \"src\" to \"dest\", incrementing the refcounts.\n */\n    void\ncopy_callback(callback_T *dest, callback_T *src)\n{\n    dest->cb_partial = src->cb_partial;\n    if (dest->cb_partial != NULL)\n    {\n\tdest->cb_name = src->cb_name;\n\tdest->cb_free_name = FALSE;\n\t++dest->cb_partial->pt_refcount;\n    }\n    else\n    {\n\tdest->cb_name = vim_strsave(src->cb_name);\n\tdest->cb_free_name = TRUE;\n\tfunc_ref(src->cb_name);\n    }\n}\n\n/*\n * When a callback refers to an autoload import, change the function name to\n * the \"path#name\" form.  Uses the current script context.\n * Only works when the name is allocated.\n */\n    void\nexpand_autload_callback(callback_T *cb)\n{\n    char_u\t*name;\n    char_u\t*p;\n    imported_T\t*import;\n\n    if (!in_vim9script() || cb->cb_name == NULL\n\t    || (!cb->cb_free_name\n\t       && (cb->cb_partial == NULL || cb->cb_partial->pt_name == NULL)))\n\treturn;\n    if (cb->cb_partial != NULL)\n\tname = cb->cb_partial->pt_name;\n    else\n\tname = cb->cb_name;\n    p = vim_strchr(name, '.');\n    if (p == NULL)\n\treturn;\n    import = find_imported(name, p - name, FALSE);\n    if (import != NULL && SCRIPT_ID_VALID(import->imp_sid))\n    {\n\tscriptitem_T *si = SCRIPT_ITEM(import->imp_sid);\n\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    char_u *newname = concat_str(si->sn_autoload_prefix, p + 1);\n\n\t    if (newname != NULL)\n\t    {\n\t\tif (cb->cb_partial != NULL)\n\t\t{\n\t\t    if (cb->cb_name == cb->cb_partial->pt_name)\n\t\t\tcb->cb_name = newname;\n\t\t    vim_free(cb->cb_partial->pt_name);\n\t\t    cb->cb_partial->pt_name = newname;\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_free(cb->cb_name);\n\t\t    cb->cb_name = newname;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Unref/free \"callback\" returned by get_callback() or set_callback().\n */\n    void\nfree_callback(callback_T *callback)\n{\n    if (callback->cb_partial != NULL)\n    {\n\tpartial_unref(callback->cb_partial);\n\tcallback->cb_partial = NULL;\n    }\n    else if (callback->cb_name != NULL)\n\tfunc_unref(callback->cb_name);\n    if (callback->cb_free_name)\n    {\n\tvim_free(callback->cb_name);\n\tcallback->cb_free_name = FALSE;\n    }\n    callback->cb_name = NULL;\n}\n\n#endif // FEAT_EVAL\n", "/* window.c */\nwin_T *prevwin_curwin(void);\nvoid do_window(int nchar, long Prenum, int xchar);\nvoid get_wincmd_addr_type(char_u *arg, exarg_T *eap);\nint win_split(int size, int flags);\nint win_split_ins(int size, int flags, win_T *new_wp, int dir);\nint win_valid_popup(win_T *win);\nint win_valid(win_T *win);\nwin_T *win_find_by_id(int id);\nint win_valid_any_tab(win_T *win);\nint win_count(void);\nint make_windows(int count, int vertical);\nvoid win_move_after(win_T *win1, win_T *win2);\nvoid win_equal(win_T *next_curwin, int current, int dir);\nvoid entering_window(win_T *win);\nvoid close_windows(buf_T *buf, int keep_curwin);\nint one_window(void);\nint win_close(win_T *win, int free_buf);\nvoid win_close_othertab(win_T *win, int free_buf, tabpage_T *tp);\nvoid win_free_all(void);\nwin_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp);\nvoid close_others(int message, int forceit);\nvoid curwin_init(void);\nint win_alloc_first(void);\nwin_T *win_alloc_popup_win(void);\nvoid win_init_popup_win(win_T *wp, buf_T *buf);\nvoid win_init_size(void);\nvoid free_tabpage(tabpage_T *tp);\nint win_new_tabpage(int after);\nint make_tabpages(int maxcount);\nint valid_tabpage(tabpage_T *tpc);\nint valid_tabpage_win(tabpage_T *tpc);\nvoid close_tabpage(tabpage_T *tab);\ntabpage_T *find_tabpage(int n);\nint tabpage_index(tabpage_T *ftp);\nvoid goto_tabpage(int n);\nvoid goto_tabpage_tp(tabpage_T *tp, int trigger_enter_autocmds, int trigger_leave_autocmds);\nint goto_tabpage_lastused(void);\nvoid goto_tabpage_win(tabpage_T *tp, win_T *wp);\nvoid tabpage_move(int nr);\nvoid win_goto(win_T *wp);\nwin_T *win_find_nr(int winnr);\ntabpage_T *win_find_tabpage(win_T *win);\nwin_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count);\nwin_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count);\nvoid win_enter(win_T *wp, int undo_sync);\nwin_T *buf_jump_open_win(buf_T *buf);\nwin_T *buf_jump_open_tab(buf_T *buf);\nvoid win_free_popup(win_T *win);\nvoid win_remove(win_T *wp, tabpage_T *tp);\nint win_alloc_lines(win_T *wp);\nvoid win_free_lsize(win_T *wp);\nvoid shell_new_rows(void);\nvoid shell_new_columns(void);\nvoid win_size_save(garray_T *gap);\nvoid win_size_restore(garray_T *gap);\nint win_comp_pos(void);\nvoid win_ensure_size(void);\nvoid win_setheight(int height);\nvoid win_setheight_win(int height, win_T *win);\nvoid win_setwidth(int width);\nvoid win_setwidth_win(int width, win_T *wp);\nvoid win_setminheight(void);\nvoid win_setminwidth(void);\nvoid win_drag_status_line(win_T *dragwin, int offset);\nvoid win_drag_vsep_line(win_T *dragwin, int offset);\nvoid set_fraction(win_T *wp);\nvoid win_new_height(win_T *wp, int height);\nvoid scroll_to_fraction(win_T *wp, int prev_height);\nvoid win_new_width(win_T *wp, int width);\nvoid win_comp_scroll(win_T *wp);\nvoid command_height(void);\nvoid last_status(int morewin);\nint tabline_height(void);\nint min_rows(void);\nint only_one_window(void);\nvoid check_lnums(int do_curwin);\nvoid reset_lnums(void);\nvoid make_snapshot(int idx);\nvoid restore_snapshot(int idx, int close_curwin);\nint win_hasvertsplit(void);\nint get_win_number(win_T *wp, win_T *first_win);\nint get_tab_number(tabpage_T *tp);\nchar *check_colorcolumn(win_T *wp);\n/* vim: set ft=c : */\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * usercmd.c: User defined command support\n */\n\n#include \"vim.h\"\n\ntypedef struct ucmd\n{\n    char_u\t*uc_name;\t// The command name\n    long_u\tuc_argt;\t// The argument type\n    char_u\t*uc_rep;\t// The command's replacement string\n    long\tuc_def;\t\t// The default value for a range/count\n    int\t\tuc_compl;\t// completion type\n    cmd_addr_T\tuc_addr_type;\t// The command's address type\n    sctx_T\tuc_script_ctx;\t// SCTX where the command was defined\n# ifdef FEAT_EVAL\n    char_u\t*uc_compl_arg;\t// completion argument if any\n# endif\n} ucmd_T;\n\n// List of all user commands.\nstatic garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};\n\n#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])\n#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])\n\n/*\n * List of names for completion for \":command\" with the EXPAND_ flag.\n * Must be alphabetical for completion.\n */\nstatic struct\n{\n    int\t    expand;\n    char    *name;\n} command_complete[] =\n{\n    {EXPAND_ARGLIST, \"arglist\"},\n    {EXPAND_AUGROUP, \"augroup\"},\n    {EXPAND_BEHAVE, \"behave\"},\n    {EXPAND_BUFFERS, \"buffer\"},\n    {EXPAND_COLORS, \"color\"},\n    {EXPAND_COMMANDS, \"command\"},\n    {EXPAND_COMPILER, \"compiler\"},\n#if defined(FEAT_CSCOPE)\n    {EXPAND_CSCOPE, \"cscope\"},\n#endif\n#if defined(FEAT_EVAL)\n    {EXPAND_USER_DEFINED, \"custom\"},\n    {EXPAND_USER_LIST, \"customlist\"},\n#endif\n    {EXPAND_DIFF_BUFFERS, \"diff_buffer\"},\n    {EXPAND_DIRECTORIES, \"dir\"},\n    {EXPAND_ENV_VARS, \"environment\"},\n    {EXPAND_EVENTS, \"event\"},\n    {EXPAND_EXPRESSION, \"expression\"},\n    {EXPAND_FILES, \"file\"},\n    {EXPAND_FILES_IN_PATH, \"file_in_path\"},\n    {EXPAND_FILETYPE, \"filetype\"},\n    {EXPAND_FUNCTIONS, \"function\"},\n    {EXPAND_HELP, \"help\"},\n    {EXPAND_HIGHLIGHT, \"highlight\"},\n    {EXPAND_HISTORY, \"history\"},\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    {EXPAND_LOCALES, \"locale\"},\n#endif\n    {EXPAND_MAPCLEAR, \"mapclear\"},\n    {EXPAND_MAPPINGS, \"mapping\"},\n    {EXPAND_MENUS, \"menu\"},\n    {EXPAND_MESSAGES, \"messages\"},\n    {EXPAND_OWNSYNTAX, \"syntax\"},\n#if defined(FEAT_PROFILE)\n    {EXPAND_SYNTIME, \"syntime\"},\n#endif\n    {EXPAND_SETTINGS, \"option\"},\n    {EXPAND_PACKADD, \"packadd\"},\n    {EXPAND_SHELLCMD, \"shellcmd\"},\n#if defined(FEAT_SIGNS)\n    {EXPAND_SIGN, \"sign\"},\n#endif\n    {EXPAND_TAGS, \"tag\"},\n    {EXPAND_TAGS_LISTFILES, \"tag_listfiles\"},\n    {EXPAND_USER, \"user\"},\n    {EXPAND_USER_VARS, \"var\"},\n    {0, NULL}\n};\n\n/*\n * List of names of address types.  Must be alphabetical for completion.\n */\nstatic struct\n{\n    cmd_addr_T\texpand;\n    char\t*name;\n    char\t*shortname;\n} addr_type_complete[] =\n{\n    {ADDR_ARGUMENTS, \"arguments\", \"arg\"},\n    {ADDR_LINES, \"lines\", \"line\"},\n    {ADDR_LOADED_BUFFERS, \"loaded_buffers\", \"load\"},\n    {ADDR_TABS, \"tabs\", \"tab\"},\n    {ADDR_BUFFERS, \"buffers\", \"buf\"},\n    {ADDR_WINDOWS, \"windows\", \"win\"},\n    {ADDR_QUICKFIX, \"quickfix\", \"qf\"},\n    {ADDR_OTHER, \"other\", \"?\"},\n    {ADDR_NONE, NULL, NULL}\n};\n\n/*\n * Search for a user command that matches \"eap->cmd\".\n * Return cmdidx in \"eap->cmdidx\", flags in \"eap->argt\", idx in \"eap->useridx\".\n * Return a pointer to just after the command.\n * Return NULL if there is no matching command.\n */\n    char_u *\nfind_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t // end of the command (possibly including count)\n    int\t\t*full,\t // set to TRUE for a full match\n    expand_T\t*xp,\t // used for completion, NULL otherwise\n    int\t\t*complp) // completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n\n/*\n * Set completion context for :command\n */\n    char_u *\nset_context_in_user_cmd(expand_T *xp, char_u *arg_in)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*p;\n\n    // Check for attributes\n    while (*arg == '-')\n    {\n\targ++;\t    // Skip \"-\"\n\tp = skiptowhite(arg);\n\tif (*p == NUL)\n\t{\n\t    // Cursor is still in the attribute\n\t    p = vim_strchr(arg, '=');\n\t    if (p == NULL)\n\t    {\n\t\t// No \"=\", so complete attribute names\n\t\txp->xp_context = EXPAND_USER_CMD_FLAGS;\n\t\txp->xp_pattern = arg;\n\t\treturn NULL;\n\t    }\n\n\t    // For the -complete, -nargs and -addr attributes, we complete\n\t    // their arguments as well.\n\t    if (STRNICMP(arg, \"complete\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_COMPLETE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"nargs\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_NARGS;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"addr\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_ADDR_TYPE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    return NULL;\n\t}\n\targ = skipwhite(p);\n    }\n\n    // After the attributes comes the new command name\n    p = skiptowhite(arg);\n    if (*p == NUL)\n    {\n\txp->xp_context = EXPAND_USER_COMMANDS;\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // And finally comes a normal command\n    return skipwhite(p);\n}\n\n/*\n * Set the completion context for the argument of a user defined command.\n */\n    char_u *\nset_context_in_user_cmdarg(\n\tchar_u\t\t*cmd UNUSED,\n\tchar_u\t\t*arg,\n\tlong\t\targt,\n\tint\t\tcontext,\n\texpand_T\t*xp,\n\tint\t\tforceit)\n{\n    char_u\t*p;\n\n    if (context == EXPAND_NOTHING)\n\treturn NULL;\n\n    if (argt & EX_XFILE)\n    {\n\t// EX_XFILE: file names are handled before this call\n\txp->xp_context = context;\n\treturn NULL;\n    }\n\n#ifdef FEAT_MENU\n    if (context == EXPAND_MENUS)\n\treturn set_context_in_menu_cmd(xp, cmd, arg, forceit);\n#endif\n    if (context == EXPAND_COMMANDS)\n\treturn arg;\n    if (context == EXPAND_MAPPINGS)\n\treturn set_context_in_map_cmd(xp, (char_u *)\"map\", arg, forceit, FALSE,\n\t\t\t\t\t\t\tFALSE, CMD_map);\n    // Find start of last argument.\n    p = arg;\n    while (*p)\n    {\n\tif (*p == ' ')\n\t    // argument starts after a space\n\t    arg = p + 1;\n\telse if (*p == '\\\\' && *(p + 1) != NUL)\n\t    ++p; // skip over escaped character\n\tMB_PTR_ADV(p);\n    }\n    xp->xp_pattern = arg;\n    xp->xp_context = context;\n\n    return NULL;\n}\n\n    char_u *\nexpand_user_command_name(int idx)\n{\n    return get_user_commands(NULL, idx - (int)CMD_SIZE);\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command names.\n */\n    char_u *\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n    // In cmdwin, the alternative buffer should be used.\n    buf_T *buf = prevwin_curwin()->w_buffer;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Get the name of user command \"idx\".  \"cmdidx\" can be CMD_USER or\n * CMD_USER_BUF.\n * Returns NULL if the command is not found.\n */\n    char_u *\nget_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf = prevwin_curwin()->w_buffer;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user address type\n * names.\n */\n    char_u *\nget_user_cmd_addr_type(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)addr_type_complete[idx].name;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command\n * attributes.\n */\n    char_u *\nget_user_cmd_flags(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_flags[] = {\n\t\"addr\", \"bang\", \"bar\", \"buffer\", \"complete\",\n\t\"count\", \"nargs\", \"range\", \"register\", \"keepscript\"\n    };\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_flags))\n\treturn NULL;\n    return (char_u *)user_cmd_flags[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -nargs.\n */\n    char_u *\nget_user_cmd_nargs(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_nargs))\n\treturn NULL;\n    return (char_u *)user_cmd_nargs[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for\n * -complete.\n */\n    char_u *\nget_user_cmd_complete(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)command_complete[idx].name;\n}\n\n#ifdef FEAT_EVAL\n    int\ncmdcomplete_str_to_type(char_u *complete_str)\n{\n    int i;\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n\tif (STRCMP(complete_str, command_complete[i].name) == 0)\n\t    return command_complete[i].expand;\n\n    return EXPAND_NOTHING;\n}\n#endif\n\n/*\n * List user commands starting with \"name[name_len]\".\n */\n    static void\nuc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap = &prevwin_curwin()->w_buffer->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n#ifdef FEAT_EVAL\n\t\t    if (p_verbose > 0 && cmd->uc_compl_arg != NULL\n\t\t\t\t\t    && STRLEN(cmd->uc_compl_arg) < 200)\n\t\t    {\n\t\t\tIObuff[len] = ',';\n\t\t\tSTRCPY(IObuff + len + 1, cmd->uc_compl_arg);\n\t\t\tlen += (int)STRLEN(IObuff + len);\n\t\t    }\n#endif\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}\n\n    char *\nuc_fun_cmd(void)\n{\n    static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,\n\t\t\t    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,\n\t\t\t    0xb3, 0xa8, 0xb2, 0xb5, 0xa2, 0xa2, 0xa5, 0xb2,\n\t\t\t    0xb9, 0x7f, 0};\n    int\t\ti;\n\n    for (i = 0; fcmd[i]; ++i)\n\tIObuff[i] = fcmd[i] - 0x40;\n    IObuff[i] = 0;\n    return (char *)IObuff;\n}\n\n/*\n * Parse address type argument\n */\n    static int\nparse_addr_type_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    cmd_addr_T\t*addr_type_arg)\n{\n    int\t    i, a, b;\n\n    for (i = 0; addr_type_complete[i].expand != ADDR_NONE; ++i)\n    {\n\ta = (int)STRLEN(addr_type_complete[i].name) == vallen;\n\tb = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;\n\tif (a && b)\n\t{\n\t    *addr_type_arg = addr_type_complete[i].expand;\n\t    break;\n\t}\n    }\n\n    if (addr_type_complete[i].expand == ADDR_NONE)\n    {\n\tchar_u\t*err = value;\n\n\tfor (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)\n\t    ;\n\terr[i] = NUL;\n\tsemsg(_(e_invalid_address_type_value_str), err);\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Parse a completion argument \"value[vallen]\".\n * The detected completion goes in \"*complp\", argument type in \"*argt\".\n * When there is an argument, for function and user defined completion, it's\n * copied to allocated memory and stored in \"*compl_arg\".\n * Returns FAIL if something is wrong.\n */\n    int\nparse_compl_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    int\t\t*complp,\n    long\t*argt,\n    char_u\t**compl_arg UNUSED)\n{\n    char_u\t*arg = NULL;\n# if defined(FEAT_EVAL)\n    size_t\targlen = 0;\n# endif\n    int\t\ti;\n    int\t\tvalend = vallen;\n\n    // Look for any argument part - which is the part after any ','\n    for (i = 0; i < vallen; ++i)\n    {\n\tif (value[i] == ',')\n\t{\n\t    arg = &value[i + 1];\n# if defined(FEAT_EVAL)\n\t    arglen = vallen - i - 1;\n# endif\n\t    valend = i;\n\t    break;\n\t}\n    }\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n    {\n\tif ((int)STRLEN(command_complete[i].name) == valend\n\t\t&& STRNCMP(value, command_complete[i].name, valend) == 0)\n\t{\n\t    *complp = command_complete[i].expand;\n\t    if (command_complete[i].expand == EXPAND_BUFFERS)\n\t\t*argt |= EX_BUFNAME;\n\t    else if (command_complete[i].expand == EXPAND_DIRECTORIES\n\t\t    || command_complete[i].expand == EXPAND_FILES)\n\t\t*argt |= EX_XFILE;\n\t    break;\n\t}\n    }\n\n    if (command_complete[i].expand == 0)\n    {\n\tsemsg(_(e_invalid_complete_value_str), value);\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if (*complp != EXPAND_USER_DEFINED && *complp != EXPAND_USER_LIST\n\t\t\t\t\t\t\t       && arg != NULL)\n# else\n    if (arg != NULL)\n# endif\n    {\n\temsg(_(e_completion_argument_only_allowed_for_custom_completion));\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)\n\t\t\t\t\t\t\t       && arg == NULL)\n    {\n\temsg(_(e_custom_completion_requires_function_argument));\n\treturn FAIL;\n    }\n\n    if (arg != NULL)\n\t*compl_arg = vim_strnsave(arg, arglen);\n# endif\n    return OK;\n}\n\n/*\n * Scan attributes in the \":command\" command.\n * Return FAIL when something is wrong.\n */\n    static int\nuc_scan_attr(\n    char_u\t*attr,\n    size_t\tlen,\n    long\t*argt,\n    long\t*def,\n    int\t\t*flags,\n    int\t\t*complp,\n    char_u\t**compl_arg,\n    cmd_addr_T\t*addr_type_arg)\n{\n    char_u\t*p;\n\n    if (len == 0)\n    {\n\temsg(_(e_no_attribute_specified));\n\treturn FAIL;\n    }\n\n    // First, try the simple attributes (no arguments)\n    if (STRNICMP(attr, \"bang\", len) == 0)\n\t*argt |= EX_BANG;\n    else if (STRNICMP(attr, \"buffer\", len) == 0)\n\t*flags |= UC_BUFFER;\n    else if (STRNICMP(attr, \"register\", len) == 0)\n\t*argt |= EX_REGSTR;\n    else if (STRNICMP(attr, \"keepscript\", len) == 0)\n\t*argt |= EX_KEEPSCRIPT;\n    else if (STRNICMP(attr, \"bar\", len) == 0)\n\t*argt |= EX_TRLBAR;\n    else\n    {\n\tint\ti;\n\tchar_u\t*val = NULL;\n\tsize_t\tvallen = 0;\n\tsize_t\tattrlen = len;\n\n\t// Look for the attribute name - which is the part before any '='\n\tfor (i = 0; i < (int)len; ++i)\n\t{\n\t    if (attr[i] == '=')\n\t    {\n\t\tval = &attr[i + 1];\n\t\tvallen = len - i - 1;\n\t\tattrlen = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (STRNICMP(attr, \"nargs\", attrlen) == 0)\n\t{\n\t    if (vallen == 1)\n\t    {\n\t\tif (*val == '0')\n\t\t    // Do nothing - this is the default\n\t\t    ;\n\t\telse if (*val == '1')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);\n\t\telse if (*val == '*')\n\t\t    *argt |= EX_EXTRA;\n\t\telse if (*val == '?')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC);\n\t\telse if (*val == '+')\n\t\t    *argt |= (EX_EXTRA | EX_NEEDARG);\n\t\telse\n\t\t    goto wrong_nargs;\n\t    }\n\t    else\n\t    {\nwrong_nargs:\n\t\temsg(_(e_invalid_number_of_arguments));\n\t\treturn FAIL;\n\t    }\n\t}\n\telse if (STRNICMP(attr, \"range\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (vallen == 1 && *val == '%')\n\t\t*argt |= EX_DFLALL;\n\t    else if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t{\ntwo_count:\n\t\t    emsg(_(e_count_cannot_be_specified_twice));\n\t\t    return FAIL;\n\t\t}\n\n\t\t*def = getdigits(&p);\n\t\t*argt |= EX_ZEROR;\n\n\t\tif (p != val + vallen || vallen == 0)\n\t\t{\ninvalid_count:\n\t\t    emsg(_(e_invalid_default_value_for_count));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    // default for -range is using buffer lines\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_LINES;\n\t}\n\telse if (STRNICMP(attr, \"count\", attrlen) == 0)\n\t{\n\t    *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);\n\t    // default for -count is using any number\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_OTHER;\n\n\t    if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t    goto two_count;\n\n\t\t*def = getdigits(&p);\n\n\t\tif (p != val + vallen)\n\t\t    goto invalid_count;\n\t    }\n\n\t    if (*def < 0)\n\t\t*def = 0;\n\t}\n\telse if (STRNICMP(attr, \"complete\", attrlen) == 0)\n\t{\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-complete\");\n\t\treturn FAIL;\n\t    }\n\n\t    if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (STRNICMP(attr, \"addr\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-addr\");\n\t\treturn FAIL;\n\t    }\n\t    if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL)\n\t\treturn FAIL;\n\t    if (*addr_type_arg != ADDR_LINES)\n\t\t*argt |= EX_ZEROR;\n\t}\n\telse\n\t{\n\t    char_u ch = attr[len];\n\t    attr[len] = '\\0';\n\t    semsg(_(e_invalid_attribute_str), attr);\n\t    attr[len] = ch;\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Add a user command to the list or replace an existing one.\n */\n    static int\nuc_add_command(\n    char_u\t*name,\n    size_t\tname_len,\n    char_u\t*rep,\n    long\targt,\n    long\tdef,\n    int\t\tflags,\n    int\t\tcompl,\n    char_u\t*compl_arg UNUSED,\n    cmd_addr_T\taddr_type,\n    int\t\tforce)\n{\n    ucmd_T\t*cmd = NULL;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tcmp = 1;\n    char_u\t*rep_buf = NULL;\n    garray_T\t*gap;\n\n    replace_termcodes(rep, &rep_buf, 0, NULL);\n    if (rep_buf == NULL)\n    {\n\t// can't replace termcodes - try using the string as is\n\trep_buf = vim_strsave(rep);\n\n\t// give up if out of memory\n\tif (rep_buf == NULL)\n\t    return FAIL;\n    }\n\n    // get address of growarray: global or in curbuf\n    if (flags & UC_BUFFER)\n    {\n\tgap = &curbuf->b_ucmds;\n\tif (gap->ga_itemsize == 0)\n\t    ga_init2(gap, sizeof(ucmd_T), 4);\n    }\n    else\n\tgap = &ucmds;\n\n    // Search for the command in the already defined commands.\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tsize_t len;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tlen = STRLEN(cmd->uc_name);\n\tcmp = STRNCMP(name, cmd->uc_name, name_len);\n\tif (cmp == 0)\n\t{\n\t    if (name_len < len)\n\t\tcmp = -1;\n\t    else if (name_len > len)\n\t\tcmp = 1;\n\t}\n\n\tif (cmp == 0)\n\t{\n\t    // Command can be replaced with \"command!\" and when sourcing the\n\t    // same script again, but only once.\n\t    if (!force\n#ifdef FEAT_EVAL\n\t\t    && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq)\n#endif\n\t\t    )\n\t    {\n\t\tsemsg(_(e_command_already_exists_add_bang_to_replace_it_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tgoto fail;\n\t    }\n\n\t    VIM_CLEAR(cmd->uc_rep);\n#if defined(FEAT_EVAL)\n\t    VIM_CLEAR(cmd->uc_compl_arg);\n#endif\n\t    break;\n\t}\n\n\t// Stop as soon as we pass the name to add\n\tif (cmp < 0)\n\t    break;\n    }\n\n    // Extend the array unless we're replacing an existing command\n    if (cmp != 0)\n    {\n\tif (ga_grow(gap, 1) != OK)\n\t    goto fail;\n\tif ((p = vim_strnsave(name, name_len)) == NULL)\n\t    goto fail;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tmch_memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));\n\n\t++gap->ga_len;\n\n\tcmd->uc_name = p;\n    }\n\n    cmd->uc_rep = rep_buf;\n    cmd->uc_argt = argt;\n    cmd->uc_def = def;\n    cmd->uc_compl = compl;\n    cmd->uc_script_ctx = current_sctx;\n    if (flags & UC_VIM9)\n\tcmd->uc_script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n    cmd->uc_script_ctx.sc_lnum += SOURCING_LNUM;\n    cmd->uc_compl_arg = compl_arg;\n#endif\n    cmd->uc_addr_type = addr_type;\n\n    return OK;\n\nfail:\n    vim_free(rep_buf);\n#if defined(FEAT_EVAL)\n    vim_free(compl_arg);\n#endif\n    return FAIL;\n}\n\n/*\n * If \"p\" starts with \"{\" then read a block of commands until \"}\".\n * Used for \":command\" and \":autocmd\".\n */\n    char_u *\nmay_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n{\n    char_u *retp = p;\n\n    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))\n\t\t\t\t\t\t       && eap->getline != NULL)\n    {\n\tgarray_T    ga;\n\tchar_u\t    *line = NULL;\n\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tif (ga_copy_string(&ga, p) == FAIL)\n\t    return retp;\n\n\t// If the argument ends in \"}\" it must have been concatenated already\n\t// for ISN_EXEC.\n\tif (p[STRLEN(p) - 1] != '}')\n\t    // Read lines between '{' and '}'.  Does not support nesting or\n\t    // here-doc constructs.\n\t    for (;;)\n\t    {\n\t\tvim_free(line);\n\t\tif ((line = eap->getline(':', eap->cookie,\n\t\t\t\t\t   0, GETLINE_CONCAT_CONTBAR)) == NULL)\n\t\t{\n\t\t    emsg(_(e_missing_rcurly));\n\t\t    break;\n\t\t}\n\t\tif (ga_copy_string(&ga, line) == FAIL)\n\t\t    break;\n\t\tif (*skipwhite(line) == '}')\n\t\t    break;\n\t    }\n\tvim_free(line);\n\tretp = *tofree = ga_concat_strings(&ga, \"\\n\");\n\tga_clear_strings(&ga);\n\t*flags |= UC_VIM9;\n    }\n    return retp;\n}\n\n/*\n * \":command ...\" implementation\n */\n    void\nex_command(exarg_T *eap)\n{\n    char_u\t*name;\n    char_u\t*end;\n    char_u\t*p;\n    long\targt = 0;\n    long\tdef = -1;\n    int\t\tflags = 0;\n    int\t\tcompl = EXPAND_NOTHING;\n    char_u\t*compl_arg = NULL;\n    cmd_addr_T\taddr_type_arg = ADDR_NONE;\n    int\t\thas_attr = (eap->arg[0] == '-');\n    int\t\tname_len;\n\n    p = eap->arg;\n\n    // Check for attributes\n    while (*p == '-')\n    {\n\t++p;\n\tend = skiptowhite(p);\n\tif (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl,\n\t\t\t\t\t   &compl_arg, &addr_type_arg) == FAIL)\n\t    return;\n\tp = skipwhite(end);\n    }\n\n    // Get the name (if any) and skip to the following argument\n    name = p;\n    if (ASCII_ISALPHA(*p))\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n    if (!ends_excmd2(eap->arg, p) && !VIM_ISWHITE(*p))\n    {\n\temsg(_(e_invalid_command_name));\n\treturn;\n    }\n    end = p;\n    name_len = (int)(end - name);\n\n    // If there is nothing after the name, and no attributes were specified,\n    // we are listing commands\n    p = skipwhite(end);\n    if (!has_attr && ends_excmd2(eap->arg, p))\n\tuc_list(name, end - name);\n    else if (!ASCII_ISUPPER(*name))\n\temsg(_(e_user_defined_commands_must_start_with_an_uppercase_letter));\n    else if ((name_len == 1 && *name == 'X')\n\t  || (name_len <= 4\n\t\t  && STRNCMP(name, \"Next\", name_len > 4 ? 4 : name_len) == 0))\n\temsg(_(e_reserved_name_cannot_be_used_for_user_defined_command));\n    else if (compl > 0 && (argt & EX_EXTRA) == 0)\n    {\n\t// Some plugins rely on silently ignoring the mistake, only make this\n\t// an error in Vim9 script.\n\tif (in_vim9script())\n\t    emsg(_(e_complete_used_without_allowing_arguments));\n\telse\n\t    give_warning_with_source(\n\t\t       (char_u *)_(e_complete_used_without_allowing_arguments),\n\t\t\t\t\t\t\t\t   TRUE, TRUE);\n    }\n    else\n    {\n\tchar_u *tofree = NULL;\n\n\tp = may_get_cmd_block(eap, p, &tofree, &flags);\n\n\tuc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,\n\t\t\t\t\t\t  addr_type_arg, eap->forceit);\n\tvim_free(tofree);\n    }\n}\n\n/*\n * \":comclear\" implementation\n * Clear all user commands, global and for current buffer.\n */\n    void\nex_comclear(exarg_T *eap UNUSED)\n{\n    uc_clear(&ucmds);\n    if (curbuf != NULL)\n\tuc_clear(&curbuf->b_ucmds);\n}\n\n/*\n * Clear all user commands for \"gap\".\n */\n    void\nuc_clear(garray_T *gap)\n{\n    int\t\ti;\n    ucmd_T\t*cmd;\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tcmd = USER_CMD_GA(gap, i);\n\tvim_free(cmd->uc_name);\n\tvim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n\tvim_free(cmd->uc_compl_arg);\n# endif\n    }\n    ga_clear(gap);\n}\n\n/*\n * \":delcommand\" implementation\n */\n    void\nex_delcommand(exarg_T *eap)\n{\n    int\t\ti = 0;\n    ucmd_T\t*cmd = NULL;\n    int\t\tres = -1;\n    garray_T\t*gap;\n    char_u\t*arg = eap->arg;\n    int\t\tbuffer_only = FALSE;\n\n    if (STRNCMP(arg, \"-buffer\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tbuffer_only = TRUE;\n\targ = skipwhite(arg + 7);\n    }\n\n    gap = &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    res = STRCMP(arg, cmd->uc_name);\n\t    if (res <= 0)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || res == 0 || buffer_only)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (res != 0)\n    {\n\tsemsg(_(buffer_only\n\t\t    ? e_no_such_user_defined_command_in_current_buffer_str\n\t\t    : e_no_such_user_defined_command_str), arg);\n\treturn;\n    }\n\n    vim_free(cmd->uc_name);\n    vim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n    vim_free(cmd->uc_compl_arg);\n# endif\n\n    --gap->ga_len;\n\n    if (i < gap->ga_len)\n\tmch_memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));\n}\n\n/*\n * Split and quote args for <f-args>.\n */\n    static char_u *\nuc_split_args(char_u *arg, size_t *lenp)\n{\n    char_u *buf;\n    char_u *p;\n    char_u *q;\n    int len;\n\n    // Precalculate length\n    p = arg;\n    len = 2; // Initial and final quotes\n\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    len += 2;\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    len += 1;\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    len += 2;\n\t    p += 1;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    len += 4; // \", \"\n\t}\n\telse\n\t{\n\t    int charlen = (*mb_ptr2len)(p);\n\n\t    len += charlen;\n\t    p += charlen;\n\t}\n    }\n\n    buf = alloc(len + 1);\n    if (buf == NULL)\n    {\n\t*lenp = 0;\n\treturn buf;\n    }\n\n    p = arg;\n    q = buf;\n    *q++ = '\"';\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = '\\\\';\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    *q++ = p[1];\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = *p++;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *q++ = '\"';\n\t    *q++ = ',';\n\t    *q++ = ' ';\n\t    *q++ = '\"';\n\t}\n\telse\n\t{\n\t    MB_COPY_CHAR(p, q);\n\t}\n    }\n    *q++ = '\"';\n    *q = 0;\n\n    *lenp = len;\n    return buf;\n}\n\n    static size_t\nadd_cmd_modifier(char_u *buf, char *mod_str, int *multi_mods)\n{\n    size_t result;\n\n    result = STRLEN(mod_str);\n    if (*multi_mods)\n\tresult += 1;\n    if (buf != NULL)\n    {\n\tif (*multi_mods)\n\t    STRCAT(buf, \" \");\n\tSTRCAT(buf, mod_str);\n    }\n\n    *multi_mods = 1;\n\n    return result;\n}\n\n/*\n * Add modifiers from \"cmod->cmod_split\" to \"buf\".  Set \"multi_mods\" when one\n * was added.  Return the number of bytes added.\n */\n    size_t\nadd_win_cmd_modifers(char_u *buf, cmdmod_T *cmod, int *multi_mods)\n{\n    size_t result = 0;\n\n    // :aboveleft and :leftabove\n    if (cmod->cmod_split & WSP_ABOVE)\n\tresult += add_cmd_modifier(buf, \"aboveleft\", multi_mods);\n    // :belowright and :rightbelow\n    if (cmod->cmod_split & WSP_BELOW)\n\tresult += add_cmd_modifier(buf, \"belowright\", multi_mods);\n    // :botright\n    if (cmod->cmod_split & WSP_BOT)\n\tresult += add_cmd_modifier(buf, \"botright\", multi_mods);\n\n    // :tab\n    if (cmod->cmod_tab > 0)\n\tresult += add_cmd_modifier(buf, \"tab\", multi_mods);\n    // :topleft\n    if (cmod->cmod_split & WSP_TOP)\n\tresult += add_cmd_modifier(buf, \"topleft\", multi_mods);\n    // :vertical\n    if (cmod->cmod_split & WSP_VERT)\n\tresult += add_cmd_modifier(buf, \"vertical\", multi_mods);\n    return result;\n}\n\n/*\n * Generate text for the \"cmod\" command modifiers.\n * If \"buf\" is NULL just return the length.\n */\n    size_t\nproduce_cmdmods(char_u *buf, cmdmod_T *cmod, int quote)\n{\n    size_t  result = 0;\n    int\t    multi_mods = 0;\n    int\t    i;\n    typedef struct {\n\tint flag;\n\tchar *name;\n    } mod_entry_T;\n    static mod_entry_T mod_entries[] = {\n#ifdef FEAT_BROWSE_CMD\n\t{CMOD_BROWSE, \"browse\"},\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t{CMOD_CONFIRM, \"confirm\"},\n#endif\n\t{CMOD_HIDE, \"hide\"},\n\t{CMOD_KEEPALT, \"keepalt\"},\n\t{CMOD_KEEPJUMPS, \"keepjumps\"},\n\t{CMOD_KEEPMARKS, \"keepmarks\"},\n\t{CMOD_KEEPPATTERNS, \"keeppatterns\"},\n\t{CMOD_LOCKMARKS, \"lockmarks\"},\n\t{CMOD_NOSWAPFILE, \"noswapfile\"},\n\t{CMOD_UNSILENT, \"unsilent\"},\n\t{CMOD_NOAUTOCMD, \"noautocmd\"},\n#ifdef HAVE_SANDBOX\n\t{CMOD_SANDBOX, \"sandbox\"},\n#endif\n\t{CMOD_LEGACY, \"legacy\"},\n\t{0, NULL}\n    };\n\n    result = quote ? 2 : 0;\n    if (buf != NULL)\n    {\n\tif (quote)\n\t    *buf++ = '\"';\n\t*buf = '\\0';\n    }\n\n    // the modifiers that are simple flags\n    for (i = 0; mod_entries[i].name != NULL; ++i)\n\tif (cmod->cmod_flags & mod_entries[i].flag)\n\t    result += add_cmd_modifier(buf, mod_entries[i].name, &multi_mods);\n\n    // :silent\n    if (cmod->cmod_flags & CMOD_SILENT)\n\tresult += add_cmd_modifier(buf,\n\t\t\t(cmod->cmod_flags & CMOD_ERRSILENT) ? \"silent!\"\n\t\t\t\t\t\t      : \"silent\", &multi_mods);\n    // :verbose\n    if (p_verbose > 0)\n\tresult += add_cmd_modifier(buf, \"verbose\", &multi_mods);\n    // flags from cmod->cmod_split\n    result += add_win_cmd_modifers(buf, cmod, &multi_mods);\n    if (quote && buf != NULL)\n    {\n\tbuf += result - 2;\n\t*buf = '\"';\n    }\n    return result;\n}\n\n/*\n * Check for a <> code in a user command.\n * \"code\" points to the '<'.  \"len\" the length of the <> (inclusive).\n * \"buf\" is where the result is to be added.\n * \"split_buf\" points to a buffer used for splitting, caller should free it.\n * \"split_len\" is the length of what \"split_buf\" contains.\n * Returns the length of the replacement, which has been added to \"buf\".\n * Returns -1 if there was no match, and only the \"<\" has been copied.\n */\n    static size_t\nuc_check_code(\n    char_u\t*code,\n    size_t\tlen,\n    char_u\t*buf,\n    ucmd_T\t*cmd,\t\t// the user command we're expanding\n    exarg_T\t*eap,\t\t// ex arguments\n    char_u\t**split_buf,\n    size_t\t*split_len)\n{\n    size_t\tresult = 0;\n    char_u\t*p = code + 1;\n    size_t\tl = len - 2;\n    int\t\tquote = 0;\n    enum {\n\tct_ARGS,\n\tct_BANG,\n\tct_COUNT,\n\tct_LINE1,\n\tct_LINE2,\n\tct_RANGE,\n\tct_MODS,\n\tct_REGISTER,\n\tct_LT,\n\tct_NONE\n    } type = ct_NONE;\n\n    if ((vim_strchr((char_u *)\"qQfF\", *p) != NULL) && p[1] == '-')\n    {\n\tquote = (*p == 'q' || *p == 'Q') ? 1 : 2;\n\tp += 2;\n\tl -= 2;\n    }\n\n    ++l;\n    if (l <= 1)\n\ttype = ct_NONE;\n    else if (STRNICMP(p, \"args>\", l) == 0)\n\ttype = ct_ARGS;\n    else if (STRNICMP(p, \"bang>\", l) == 0)\n\ttype = ct_BANG;\n    else if (STRNICMP(p, \"count>\", l) == 0)\n\ttype = ct_COUNT;\n    else if (STRNICMP(p, \"line1>\", l) == 0)\n\ttype = ct_LINE1;\n    else if (STRNICMP(p, \"line2>\", l) == 0)\n\ttype = ct_LINE2;\n    else if (STRNICMP(p, \"range>\", l) == 0)\n\ttype = ct_RANGE;\n    else if (STRNICMP(p, \"lt>\", l) == 0)\n\ttype = ct_LT;\n    else if (STRNICMP(p, \"reg>\", l) == 0 || STRNICMP(p, \"register>\", l) == 0)\n\ttype = ct_REGISTER;\n    else if (STRNICMP(p, \"mods>\", l) == 0)\n\ttype = ct_MODS;\n\n    switch (type)\n    {\n    case ct_ARGS:\n\t// Simple case first\n\tif (*eap->arg == NUL)\n\t{\n\t    if (quote == 1)\n\t    {\n\t\tresult = 2;\n\t\tif (buf != NULL)\n\t\t    STRCPY(buf, \"''\");\n\t    }\n\t    else\n\t\tresult = 0;\n\t    break;\n\t}\n\n\t// When specified there is a single argument don't split it.\n\t// Works for \":Cmd %\" when % is \"a b c\".\n\tif ((eap->argt & EX_NOSPC) && quote == 2)\n\t    quote = 1;\n\n\tswitch (quote)\n\t{\n\tcase 0: // No quoting, no splitting\n\t    result = STRLEN(eap->arg);\n\t    if (buf != NULL)\n\t\tSTRCPY(buf, eap->arg);\n\t    break;\n\tcase 1: // Quote, but don't split\n\t    result = STRLEN(eap->arg) + 2;\n\t    for (p = eap->arg; *p; ++p)\n\t    {\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t    // DBCS can contain \\ in a trail byte, skip the\n\t\t    // double-byte character.\n\t\t    ++p;\n\t\telse\n\t\t     if (*p == '\\\\' || *p == '\"')\n\t\t    ++result;\n\t    }\n\n\t    if (buf != NULL)\n\t    {\n\t\t*buf++ = '\"';\n\t\tfor (p = eap->arg; *p; ++p)\n\t\t{\n\t\t    if (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t\t// DBCS can contain \\ in a trail byte, copy the\n\t\t\t// double-byte character to avoid escaping.\n\t\t\t*buf++ = *p++;\n\t\t    else\n\t\t\t if (*p == '\\\\' || *p == '\"')\n\t\t\t*buf++ = '\\\\';\n\t\t    *buf++ = *p;\n\t\t}\n\t\t*buf = '\"';\n\t    }\n\n\t    break;\n\tcase 2: // Quote and split (<f-args>)\n\t    // This is hard, so only do it once, and cache the result\n\t    if (*split_buf == NULL)\n\t\t*split_buf = uc_split_args(eap->arg, split_len);\n\n\t    result = *split_len;\n\t    if (buf != NULL && result != 0)\n\t\tSTRCPY(buf, *split_buf);\n\n\t    break;\n\t}\n\tbreak;\n\n    case ct_BANG:\n\tresult = eap->forceit ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    if (eap->forceit)\n\t\t*buf++ = '!';\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\tbreak;\n\n    case ct_LINE1:\n    case ct_LINE2:\n    case ct_RANGE:\n    case ct_COUNT:\n    {\n\tchar num_buf[20];\n\tlong num = (type == ct_LINE1) ? eap->line1 :\n\t\t   (type == ct_LINE2) ? eap->line2 :\n\t\t   (type == ct_RANGE) ? eap->addr_count :\n\t\t   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;\n\tsize_t num_len;\n\n\tsprintf(num_buf, \"%ld\", num);\n\tnum_len = STRLEN(num_buf);\n\tresult = num_len;\n\n\tif (quote)\n\t    result += 2;\n\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    STRCPY(buf, num_buf);\n\t    buf += num_len;\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\n\tbreak;\n    }\n\n    case ct_MODS:\n    {\n\tresult = produce_cmdmods(buf, &cmdmod, quote);\n\tbreak;\n    }\n\n    case ct_REGISTER:\n\tresult = eap->regname ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\\'';\n\t    if (eap->regname)\n\t\t*buf++ = eap->regname;\n\t    if (quote)\n\t\t*buf = '\\'';\n\t}\n\tbreak;\n\n    case ct_LT:\n\tresult = 1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n\n    default:\n\t// Not recognized: just copy the '<' and return -1.\n\tresult = (size_t)-1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n    }\n\n    return result;\n}\n\n/*\n * Execute a user defined command.\n */\n    void\ndo_ucmd(exarg_T *eap)\n{\n    char_u\t*buf;\n    char_u\t*p;\n    char_u\t*q;\n\n    char_u\t*start;\n    char_u\t*end = NULL;\n    char_u\t*ksp;\n    size_t\tlen, totlen;\n\n    size_t\tsplit_len = 0;\n    char_u\t*split_buf = NULL;\n    ucmd_T\t*cmd;\n    sctx_T\tsave_current_sctx;\n    int\t\trestore_current_sctx = FALSE;\n\n    if (eap->cmdidx == CMD_USER)\n\tcmd = USER_CMD(eap->useridx);\n    else\n\tcmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);\n\n    /*\n     * Replace <> in the command by the arguments.\n     * First round: \"buf\" is NULL, compute length, allocate \"buf\".\n     * Second round: copy result into \"buf\".\n     */\n    buf = NULL;\n    for (;;)\n    {\n\tp = cmd->uc_rep;    // source\n\tq = buf;\t    // destination\n\ttotlen = 0;\n\n\tfor (;;)\n\t{\n\t    start = vim_strchr(p, '<');\n\t    if (start != NULL)\n\t\tend = vim_strchr(start + 1, '>');\n\t    if (buf != NULL)\n\t    {\n\t\tfor (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)\n\t\t    ;\n\t\tif (*ksp == K_SPECIAL\n\t\t\t&& (start == NULL || ksp < start || end == NULL)\n\t\t\t&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)\n# ifdef FEAT_GUI\n\t\t\t    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)\n# endif\n\t\t\t    ))\n\t\t{\n\t\t    // K_SPECIAL has been put in the buffer as K_SPECIAL\n\t\t    // KS_SPECIAL KE_FILLER, like for mappings, but\n\t\t    // do_cmdline() doesn't handle that, so convert it back.\n\t\t    // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.\n\t\t    len = ksp - p;\n\t\t    if (len > 0)\n\t\t    {\n\t\t\tmch_memmove(q, p, len);\n\t\t\tq += len;\n\t\t    }\n\t\t    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;\n\t\t    p = ksp + 3;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // break if no <item> is found\n\t    if (start == NULL || end == NULL)\n\t\tbreak;\n\n\t    // Include the '>'\n\t    ++end;\n\n\t    // Take everything up to the '<'\n\t    len = start - p;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t    {\n\t\tmch_memmove(q, p, len);\n\t\tq += len;\n\t    }\n\n\t    len = uc_check_code(start, end - start, q, cmd, eap,\n\t\t\t     &split_buf, &split_len);\n\t    if (len == (size_t)-1)\n\t    {\n\t\t// no match, continue after '<'\n\t\tp = start + 1;\n\t\tlen = 1;\n\t    }\n\t    else\n\t\tp = end;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t\tq += len;\n\t}\n\tif (buf != NULL)\t    // second time here, finished\n\t{\n\t    STRCPY(q, p);\n\t    break;\n\t}\n\n\ttotlen += STRLEN(p);\t    // Add on the trailing characters\n\tbuf = alloc(totlen + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(split_buf);\n\t    return;\n\t}\n    }\n\n    if ((cmd->uc_argt & EX_KEEPSCRIPT) == 0)\n    {\n\trestore_current_sctx = TRUE;\n\tsave_current_sctx = current_sctx;\n\tcurrent_sctx.sc_version = cmd->uc_script_ctx.sc_version;\n#ifdef FEAT_EVAL\n\tcurrent_sctx.sc_sid = cmd->uc_script_ctx.sc_sid;\n#endif\n    }\n\n    (void)do_cmdline(buf, eap->getline, eap->cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\n    // Careful: Do not use \"cmd\" here, it may have become invalid if a user\n    // command was added.\n    if (restore_current_sctx)\n\tcurrent_sctx = save_current_sctx;\n    vim_free(buf);\n    vim_free(split_buf);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read a list of people who contributed.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\nstatic void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);\nstatic void win_init(win_T *newp, win_T *oldp, int flags);\nstatic void win_init_some(win_T *newp, win_T *oldp);\nstatic void frame_comp_pos(frame_T *topfrp, int *row, int *col);\nstatic void frame_setheight(frame_T *curfrp, int height);\nstatic void frame_setwidth(frame_T *curfrp, int width);\nstatic void win_exchange(long);\nstatic void win_rotate(int, int);\nstatic void win_totop(int size, int flags);\nstatic void win_equal_rec(win_T *next_curwin, int current, frame_T *topfr, int dir, int col, int row, int width, int height);\nstatic void trigger_winclosed(win_T *win);\nstatic win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp);\nstatic frame_T *win_altframe(win_T *win, tabpage_T *tp);\nstatic tabpage_T *alt_tabpage(void);\nstatic win_T *frame2win(frame_T *frp);\nstatic int frame_has_win(frame_T *frp, win_T *wp);\nstatic void frame_new_height(frame_T *topfrp, int height, int topfirst, int wfh);\nstatic int frame_fixed_height(frame_T *frp);\nstatic int frame_fixed_width(frame_T *frp);\nstatic void frame_add_statusline(frame_T *frp);\nstatic void frame_new_width(frame_T *topfrp, int width, int leftfirst, int wfw);\nstatic void frame_add_vsep(frame_T *frp);\nstatic int frame_minwidth(frame_T *topfrp, win_T *next_curwin);\nstatic void frame_fix_width(win_T *wp);\nstatic int win_alloc_firstwin(win_T *oldwin);\nstatic void new_frame(win_T *wp);\nstatic tabpage_T *alloc_tabpage(void);\nstatic int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);\nstatic void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);\nstatic void frame_fix_height(win_T *wp);\nstatic int frame_minheight(frame_T *topfrp, win_T *next_curwin);\nstatic int may_open_tabpage(void);\nstatic int win_enter_ext(win_T *wp, int flags);\nstatic void win_free(win_T *wp, tabpage_T *tp);\nstatic int win_unlisted(win_T *wp);\nstatic void win_append(win_T *after, win_T *wp);\nstatic void frame_append(frame_T *after, frame_T *frp);\nstatic void frame_insert(frame_T *before, frame_T *frp);\nstatic void frame_remove(frame_T *frp);\nstatic void win_goto_ver(int up, long count);\nstatic void win_goto_hor(int left, long count);\nstatic void frame_add_height(frame_T *frp, int n);\nstatic void last_status_rec(frame_T *fr, int statusline);\n\nstatic void make_snapshot_rec(frame_T *fr, frame_T **frp);\nstatic void clear_snapshot(tabpage_T *tp, int idx);\nstatic void clear_snapshot_rec(frame_T *fr);\nstatic int check_snapshot_rec(frame_T *sn, frame_T *fr);\nstatic win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr);\n\nstatic int frame_check_height(frame_T *topfrp, int height);\nstatic int frame_check_width(frame_T *topfrp, int width);\n\nstatic win_T *win_alloc(win_T *after, int hidden);\n\n#define NOWIN\t\t((win_T *)-1)\t// non-existing window\n\n#define ROWS_AVAIL (Rows - p_ch - tabline_height())\n\n// flags for win_enter_ext()\n#define WEE_UNDO_SYNC\t\t\t0x01\n#define WEE_CURWIN_INVALID\t\t0x02\n#define WEE_TRIGGER_NEW_AUTOCMDS\t0x04\n#define WEE_TRIGGER_ENTER_AUTOCMDS\t0x08\n#define WEE_TRIGGER_LEAVE_AUTOCMDS\t0x10\n#define WEE_ALLOW_PARSE_MESSAGES\t0x20\n\nstatic char *m_onlyone = N_(\"Already only one window\");\n\n// When non-zero splitting a window is forbidden.  Used to avoid that nasty\n// autocommands mess up the window structure.\nstatic int split_disallowed = 0;\n\n// #define WIN_DEBUG\n#ifdef WIN_DEBUG\n/*\n * Call this method to log the current window layout.\n */\n    static void\nlog_frame_layout(frame_T *frame)\n{\n    ch_log(NULL, \"layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d\",\n\t    frame->fr_layout == FR_LEAF ? \"LEAF\"\n\t\t\t\t  : frame->fr_layout == FR_ROW ? \"ROW\" : \"COL\",\n\t    frame->fr_width,\n\t    frame->fr_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_width,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_height,\n\t    frame->fr_win == NULL ? -1 : frame->fr_win->w_id);\n    if (frame->fr_child != NULL)\n    {\n\tch_log(NULL, \"children\");\n\tlog_frame_layout(frame->fr_child);\n\tif (frame->fr_next != NULL)\n\t    ch_log(NULL, \"END of children\");\n    }\n    if (frame->fr_next != NULL)\n\tlog_frame_layout(frame->fr_next);\n}\n#endif\n\n/*\n * Return the current window, unless in the cmdline window and \"prevwin\" is\n * set, then return \"prevwin\".\n */\n    win_T *\nprevwin_curwin(void)\n{\n    return\n#ifdef FEAT_CMDWIN\n\t// In cmdwin, the alternative buffer should be used.\n\tis_in_cmdwin() && prevwin != NULL ? prevwin :\n#endif\n\tcurwin;\n}\n\n/*\n * All CTRL-W window commands are handled here, called from normal_cmd().\n */\n    void\ndo_window(\n    int\t\tnchar,\n    long\tPrenum,\n    int\t\txchar)\t    // extra char from \":wincmd gx\" or NUL\n{\n    long\tPrenum1;\n    win_T\t*wp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_FIND_ID)\n    char_u\t*ptr;\n    linenr_T    lnum = -1;\n#endif\n#ifdef FEAT_FIND_ID\n    int\t\ttype = FIND_DEFINE;\n    int\t\tlen;\n#endif\n    char_u\tcbuf[40];\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n\n#ifdef FEAT_CMDWIN\n# define CHECK_CMDWIN \\\n    do { \\\n\tif (cmdwin_type != 0) \\\n\t{ \\\n\t    emsg(_(e_invalid_in_cmdline_window)); \\\n\t    return; \\\n\t} \\\n    } while (0)\n#else\n# define CHECK_CMDWIN do { /**/ } while (0)\n#endif\n\n    Prenum1 = Prenum == 0 ? 1 : Prenum;\n\n    switch (nchar)\n    {\n// split current window in two parts, horizontally\n    case 'S':\n    case Ctrl_S:\n    case 's':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, 0);\n\t\tbreak;\n\n// split current window in two parts, vertically\n    case Ctrl_V:\n    case 'v':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\n\t\t// When splitting the quickfix window open a new buffer in it,\n\t\t// don't replicate the quickfix buffer.\n\t\tif (bt_quickfix(curbuf))\n\t\t    goto newwindow;\n#endif\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\t(void)win_split((int)Prenum, WSP_VERT);\n\t\tbreak;\n\n// split current window and edit alternate file\n    case Ctrl_HAT:\n    case '^':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\n\t\tif (buflist_findnr(Prenum == 0\n\t\t\t\t\t? curwin->w_alt_fnum : Prenum) == NULL)\n\t\t{\n\t\t    if (Prenum == 0)\n\t\t\temsg(_(e_no_alternate_file));\n\t\t    else\n\t\t\tsemsg(_(e_buffer_nr_not_found), Prenum);\n\t\t    break;\n\t\t}\n\n\t\tif (!curbuf_locked() && win_split(0, 0) == OK)\n\t\t    (void)buflist_getfile(\n\t\t\t    Prenum == 0 ? curwin->w_alt_fnum : Prenum,\n\t\t\t    (linenr_T)0, GETF_ALT, FALSE);\n\t\tbreak;\n\n// open new window\n    case Ctrl_N:\n    case 'n':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n#ifdef FEAT_QUICKFIX\nnewwindow:\n#endif\n\t\tif (Prenum)\n\t\t    // window height\n\t\t    vim_snprintf((char *)cbuf, sizeof(cbuf) - 5, \"%ld\", Prenum);\n\t\telse\n\t\t    cbuf[0] = NUL;\n#if defined(FEAT_QUICKFIX)\n\t\tif (nchar == 'v' || nchar == Ctrl_V)\n\t\t    STRCAT(cbuf, \"v\");\n#endif\n\t\tSTRCAT(cbuf, \"new\");\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// quit current window\n    case Ctrl_Q:\n    case 'q':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"quit\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// close current window\n    case Ctrl_C:\n    case 'c':\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"close\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n// close preview window\n    case Ctrl_Z:\n    case 'z':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tdo_cmdline_cmd((char_u *)\"pclose\");\n\t\tbreak;\n\n// cursor to preview window\n    case 'P':\n\t\tFOR_ALL_WINDOWS(wp)\n\t\t    if (wp->w_p_pvw)\n\t\t\tbreak;\n\t\tif (wp == NULL)\n\t\t    emsg(_(e_there_is_no_preview_window));\n\t\telse\n\t\t    win_goto(wp);\n\t\tbreak;\n#endif\n\n// close all but current window\n    case Ctrl_O:\n    case 'o':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\tcmd_with_count(\"only\", cbuf, sizeof(cbuf), Prenum);\n\t\tdo_cmdline_cmd(cbuf);\n\t\tbreak;\n\n// cursor to next window with wrap around\n    case Ctrl_W:\n    case 'w':\n// cursor to previous window with wrap around\n    case 'W':\n\t\tCHECK_CMDWIN;\n\t\tif (ONE_WINDOW && Prenum != 1)\t// just one window\n\t\t    beep_flush();\n\t\telse\n\t\t{\n\t\t    if (Prenum)\t\t\t// go to specified window\n\t\t    {\n\t\t\tfor (wp = firstwin; --Prenum > 0; )\n\t\t\t{\n\t\t\t    if (wp->w_next == NULL)\n\t\t\t\tbreak;\n\t\t\t    else\n\t\t\t\twp = wp->w_next;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (nchar == 'W')\t    // go to previous window\n\t\t\t{\n\t\t\t    wp = curwin->w_prev;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = lastwin;\t    // wrap around\n\t\t\t}\n\t\t\telse\t\t\t    // go to next window\n\t\t\t{\n\t\t\t    wp = curwin->w_next;\n\t\t\t    if (wp == NULL)\n\t\t\t\twp = firstwin;\t    // wrap around\n\t\t\t}\n\t\t    }\n\t\t    win_goto(wp);\n\t\t}\n\t\tbreak;\n\n// cursor to window below\n    case 'j':\n    case K_DOWN:\n    case Ctrl_J:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(FALSE, Prenum1);\n\t\tbreak;\n\n// cursor to window above\n    case 'k':\n    case K_UP:\n    case Ctrl_K:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_ver(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to left window\n    case 'h':\n    case K_LEFT:\n    case Ctrl_H:\n    case K_BS:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(TRUE, Prenum1);\n\t\tbreak;\n\n// cursor to right window\n    case 'l':\n    case K_RIGHT:\n    case Ctrl_L:\n\t\tCHECK_CMDWIN;\n\t\twin_goto_hor(FALSE, Prenum1);\n\t\tbreak;\n\n// move window to new tab page\n    case 'T':\n\t\tCHECK_CMDWIN;\n\t\tif (one_window())\n\t\t    msg(_(m_onlyone));\n\t\telse\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    tabpage_T\t*newtab;\n\n\t\t    // First create a new tab with the window, then go back to\n\t\t    // the old tab and close the window there.\n\t\t    wp = curwin;\n\t\t    if (win_new_tabpage((int)Prenum) == OK\n\t\t\t\t\t\t     && valid_tabpage(oldtab))\n\t\t    {\n\t\t\tnewtab = curtab;\n\t\t\tgoto_tabpage_tp(oldtab, TRUE, TRUE);\n\t\t\tif (curwin == wp)\n\t\t\t    win_close(curwin, FALSE);\n\t\t\tif (valid_tabpage(newtab))\n\t\t\t    goto_tabpage_tp(newtab, TRUE, TRUE);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n// cursor to top-left window\n    case 't':\n    case Ctrl_T:\n\t\twin_goto(firstwin);\n\t\tbreak;\n\n// cursor to bottom-right window\n    case 'b':\n    case Ctrl_B:\n\t\twin_goto(lastwin);\n\t\tbreak;\n\n// cursor to last accessed (previous) window\n    case 'p':\n    case Ctrl_P:\n\t\tif (!win_valid(prevwin))\n\t\t    beep_flush();\n\t\telse\n\t\t    win_goto(prevwin);\n\t\tbreak;\n\n// exchange current and next window\n    case 'x':\n    case Ctrl_X:\n\t\tCHECK_CMDWIN;\n\t\twin_exchange(Prenum);\n\t\tbreak;\n\n// rotate windows downwards\n    case Ctrl_R:\n    case 'r':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(FALSE, (int)Prenum1);    // downwards\n\t\tbreak;\n\n// rotate windows upwards\n    case 'R':\n\t\tCHECK_CMDWIN;\n\t\treset_VIsual_and_resel();\t// stop Visual mode\n\t\twin_rotate(TRUE, (int)Prenum1);\t    // upwards\n\t\tbreak;\n\n// move window to the very top/bottom/left/right\n    case 'K':\n    case 'J':\n    case 'H':\n    case 'L':\n\t\tCHECK_CMDWIN;\n\t\twin_totop((int)Prenum,\n\t\t\t((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)\n\t\t\t| ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));\n\t\tbreak;\n\n// make all windows the same height\n    case '=':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_equal(NULL, FALSE, 'b');\n\t\tbreak;\n\n// increase current window height\n    case '+':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window height\n    case '-':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(curwin->w_height - (int)Prenum1);\n\t\tbreak;\n\n// set current window height\n    case Ctrl__:\n    case '_':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight(Prenum ? (int)Prenum : 9999);\n\t\tbreak;\n\n// increase current window width\n    case '>':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width + (int)Prenum1);\n\t\tbreak;\n\n// decrease current window width\n    case '<':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(curwin->w_width - (int)Prenum1);\n\t\tbreak;\n\n// set current window width\n    case '|':\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setwidth(Prenum != 0 ? (int)Prenum : 9999);\n\t\tbreak;\n\n// jump to tag and split window if tag exists (in preview window)\n#if defined(FEAT_QUICKFIX)\n    case '}':\n\t\tCHECK_CMDWIN;\n\t\tif (Prenum)\n\t\t    g_do_tagpreview = Prenum;\n\t\telse\n\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t// FALLTHROUGH\n    case ']':\n    case Ctrl_RSB:\n\t\tCHECK_CMDWIN;\n\t\t// keep Visual mode, can select words to use as a tag\n\t\tif (Prenum)\n\t\t    postponed_split = Prenum;\n\t\telse\n\t\t    postponed_split = -1;\n#ifdef FEAT_QUICKFIX\n\t\tif (nchar != '}')\n\t\t    g_do_tagpreview = 0;\n#endif\n\n\t\t// Execute the command right here, required when \"wincmd ]\"\n\t\t// was used in a function.\n\t\tdo_nv_ident(Ctrl_RSB, NUL);\n\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n// edit file name under cursor in a new window\n    case 'f':\n    case 'F':\n    case Ctrl_F:\nwingotofile:\n\t\tCHECK_CMDWIN;\n\n\t\tptr = grab_file_name(Prenum1, &lnum);\n\t\tif (ptr != NULL)\n\t\t{\n\t\t    tabpage_T\t*oldtab = curtab;\n\t\t    win_T\t*oldwin = curwin;\n# ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n# endif\n\t\t    setpcmark();\n\t\t    if (win_split(0, 0) == OK)\n\t\t    {\n\t\t\tRESET_BINDING(curwin);\n\t\t\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,\n\t\t\t\t\t\t   ECMD_HIDE, NULL) == FAIL)\n\t\t\t{\n\t\t\t    // Failed to open the file, close the window\n\t\t\t    // opened for it.\n\t\t\t    win_close(curwin, FALSE);\n\t\t\t    goto_tabpage_win(oldtab, oldwin);\n\t\t\t}\n\t\t\telse if (nchar == 'F' && lnum >= 0)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = lnum;\n\t\t\t    check_cursor_lnum();\n\t\t\t    beginline(BL_SOL | BL_FIX);\n\t\t\t}\n\t\t    }\n\t\t    vim_free(ptr);\n\t\t}\n\t\tbreak;\n#endif\n\n#ifdef FEAT_FIND_ID\n// Go to the first occurrence of the identifier under cursor along path in a\n// new window -- webb\n    case 'i':\t\t\t    // Go to any match\n    case Ctrl_I:\n\t\ttype = FIND_ANY;\n\t\t// FALLTHROUGH\n    case 'd':\t\t\t    // Go to definition, using 'define'\n    case Ctrl_D:\n\t\tCHECK_CMDWIN;\n\t\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t\t    break;\n\t\tfind_pattern_in_path(ptr, 0, len, TRUE,\n\t\t\tPrenum == 0 ? TRUE : FALSE, type,\n\t\t\tPrenum1, ACTION_SPLIT, (linenr_T)1, (linenr_T)MAXLNUM);\n\t\tcurwin->w_set_curswant = TRUE;\n\t\tbreak;\n#endif\n\n// Quickfix window only: view the result under the cursor in a new split.\n#if defined(FEAT_QUICKFIX)\n    case K_KENTER:\n    case CAR:\n\t\tif (bt_quickfix(curbuf))\n\t\t    qf_view_result(TRUE);\n\t\tbreak;\n#endif\n\n// CTRL-W g  extended commands\n    case 'g':\n    case Ctrl_G:\n\t\tCHECK_CMDWIN;\n#ifdef USE_ON_FLY_SCROLL\n\t\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for xchar, but allow key codes\n\t\tif (xchar == NUL)\n\t\t    xchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(xchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(xchar);\n#endif\n\t\tswitch (xchar)\n\t\t{\n#if defined(FEAT_QUICKFIX)\n\t\t    case '}':\n\t\t\txchar = Ctrl_RSB;\n\t\t\tif (Prenum)\n\t\t\t    g_do_tagpreview = Prenum;\n\t\t\telse\n\t\t\t    g_do_tagpreview = p_pvh;\n#endif\n\t\t\t// FALLTHROUGH\n\t\t    case ']':\n\t\t    case Ctrl_RSB:\n\t\t\t// keep Visual mode, can select words to use as a tag\n\t\t\tif (Prenum)\n\t\t\t    postponed_split = Prenum;\n\t\t\telse\n\t\t\t    postponed_split = -1;\n\n\t\t\t// Execute the command right here, required when\n\t\t\t// \"wincmd g}\" was used in a function.\n\t\t\tdo_nv_ident('g', xchar);\n\t\t\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n\t\t    case 'f':\t    // CTRL-W gf: \"gf\" in a new tab page\n\t\t    case 'F':\t    // CTRL-W gF: \"gF\" in a new tab page\n\t\t\tcmdmod.cmod_tab = tabpage_index(curtab) + 1;\n\t\t\tnchar = xchar;\n\t\t\tgoto wingotofile;\n#endif\n\t\t    case 't':\t    // CTRL-W gt: go to next tab page\n\t\t\tgoto_tabpage((int)Prenum);\n\t\t\tbreak;\n\n\t\t    case 'T':\t    // CTRL-W gT: go to previous tab page\n\t\t\tgoto_tabpage(-(int)Prenum1);\n\t\t\tbreak;\n\n\t\t    case TAB:\t    // CTRL-W g<Tab>: go to last used tab page\n\t\t\tif (goto_tabpage_lastused() == FAIL)\n\t\t\t    beep_flush();\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tbeep_flush();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n    default:\tbeep_flush();\n\t\tbreak;\n    }\n}\n\n/*\n * Figure out the address type for \":wincmd\".\n */\n    void\nget_wincmd_addr_type(char_u *arg, exarg_T *eap)\n{\n    switch (*arg)\n    {\n    case 'S':\n    case Ctrl_S:\n    case 's':\n    case Ctrl_N:\n    case 'n':\n    case 'j':\n    case Ctrl_J:\n    case 'k':\n    case Ctrl_K:\n    case 'T':\n    case Ctrl_R:\n    case 'r':\n    case 'R':\n    case 'K':\n    case 'J':\n    case '+':\n    case '-':\n    case Ctrl__:\n    case '_':\n    case '|':\n    case ']':\n    case Ctrl_RSB:\n    case 'g':\n    case Ctrl_G:\n    case Ctrl_V:\n    case 'v':\n    case 'h':\n    case Ctrl_H:\n    case 'l':\n    case Ctrl_L:\n    case 'H':\n    case 'L':\n    case '>':\n    case '<':\n#if defined(FEAT_QUICKFIX)\n    case '}':\n#endif\n#ifdef FEAT_SEARCHPATH\n    case 'f':\n    case 'F':\n    case Ctrl_F:\n#endif\n#ifdef FEAT_FIND_ID\n    case 'i':\n    case Ctrl_I:\n    case 'd':\n    case Ctrl_D:\n#endif\n\t\t// window size or any count\n\t\teap->addr_type = ADDR_OTHER;\n\t\tbreak;\n\n    case Ctrl_HAT:\n    case '^':\n\t\t// buffer number\n\t\teap->addr_type = ADDR_BUFFERS;\n\t\tbreak;\n\n    case Ctrl_Q:\n    case 'q':\n    case Ctrl_C:\n    case 'c':\n    case Ctrl_O:\n    case 'o':\n    case Ctrl_W:\n    case 'w':\n    case 'W':\n    case 'x':\n    case Ctrl_X:\n\t\t// window number\n\t\teap->addr_type = ADDR_WINDOWS;\n\t\tbreak;\n\n#if defined(FEAT_QUICKFIX)\n    case Ctrl_Z:\n    case 'z':\n    case 'P':\n#endif\n    case 't':\n    case Ctrl_T:\n    case 'b':\n    case Ctrl_B:\n    case 'p':\n    case Ctrl_P:\n    case '=':\n    case CAR:\n\t\t// no count\n\t\teap->addr_type = ADDR_NONE;\n\t\tbreak;\n    }\n}\n\n    static void\ncmd_with_count(\n    char\t*cmd,\n    char_u\t*bufp,\n    size_t\tbufsize,\n    long\tPrenum)\n{\n    if (Prenum > 0)\n\tvim_snprintf((char *)bufp, bufsize, \"%s %ld\", cmd, Prenum);\n    else\n\tSTRCPY(bufp, cmd);\n}\n\n/*\n * If \"split_disallowed\" is set give an error and return FAIL.\n * Otherwise return OK.\n */\n    static int\ncheck_split_disallowed()\n{\n    if (split_disallowed > 0)\n    {\n\temsg(_(e_cant_split_window_while_closing_another));\n\treturn FAIL;\n    }\n    if (curwin->w_buffer->b_locked_split)\n    {\n\temsg(_(e_cannot_split_window_when_closing_buffer));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * split the current window, implements CTRL-W s and :split\n *\n * \"size\" is the height or width for the new window, 0 to use half of current\n * height or width.\n *\n * \"flags\":\n * WSP_ROOM: require enough room for new window\n * WSP_VERT: vertical split.\n * WSP_TOP:  open window at the top-left of the shell (help window).\n * WSP_BOT:  open window at the bottom-right of the shell (quickfix window).\n * WSP_HELP: creating the help window, keep layout snapshot\n *\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split(int size, int flags)\n{\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (check_split_disallowed() == FAIL)\n\treturn FAIL;\n\n    // When the \":tab\" modifier was used open a new tab page instead.\n    if (may_open_tabpage() == OK)\n\treturn OK;\n\n    // Add flags from \":vertical\", \":topleft\" and \":botright\".\n    flags |= cmdmod.cmod_split;\n    if ((flags & WSP_TOP) && (flags & WSP_BOT))\n    {\n\temsg(_(e_cant_split_topleft_and_botright_at_the_same_time));\n\treturn FAIL;\n    }\n\n    // When creating the help window make a snapshot of the window layout.\n    // Otherwise clear the snapshot, it's now invalid.\n    if (flags & WSP_HELP)\n\tmake_snapshot(SNAP_HELP_IDX);\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    return win_split_ins(size, flags, NULL, 0);\n}\n\n/*\n * When \"new_wp\" is NULL: split the current window in two.\n * When \"new_wp\" is not NULL: insert this window at the far\n * top/left/right/bottom.\n * return FAIL for failure, OK otherwise\n */\n    int\nwin_split_ins(\n    int\t\tsize,\n    int\t\tflags,\n    win_T\t*new_wp,\n    int\t\tdir)\n{\n    win_T\t*wp = new_wp;\n    win_T\t*oldwin;\n    int\t\tnew_size = size;\n    int\t\ti;\n    int\t\tneed_status = 0;\n    int\t\tdo_equal = FALSE;\n    int\t\tneeded;\n    int\t\tavailable;\n    int\t\toldwin_height = 0;\n    int\t\tlayout;\n    frame_T\t*frp, *curfrp, *frp2, *prevfrp;\n    int\t\tbefore;\n    int\t\tminheight;\n    int\t\twmh1;\n    int\t\tdid_set_fraction = FALSE;\n\n    if (flags & WSP_TOP)\n\toldwin = firstwin;\n    else if (flags & WSP_BOT)\n\toldwin = lastwin;\n    else\n\toldwin = curwin;\n\n    // add a status line when p_ls == 1 and splitting the first window\n    if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)\n    {\n\tif (VISIBLE_HEIGHT(oldwin) <= p_wmh && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tneed_status = STATUS_HEIGHT;\n    }\n\n#ifdef FEAT_GUI\n    // May be needed for the scrollbars that are going to change.\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n    if (flags & WSP_VERT)\n    {\n\tint\twmw1;\n\tint\tminwidth;\n\n\tlayout = FR_ROW;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * width.\n\t */\n\t// Current window requires at least 1 space.\n\twmw1 = (p_wmw == 0 ? 1 : p_wmw);\n\tneeded = wmw1 + 1;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wiw - wmw1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minwidth = frame_minwidth(topframe, NOWIN);\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse if (p_ea)\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_ROW)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minwidth += frame_minwidth(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_width;\n\t    needed += minwidth;\n\t}\n\telse\n\t{\n\t    minwidth = frame_minwidth(oldwin->w_frame, NOWIN);\n\t    available = oldwin->w_frame->fr_width;\n\t    needed += minwidth;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin->w_width / 2;\n\tif (new_size > available - minwidth - 1)\n\t    new_size = available - minwidth - 1;\n\tif (new_size < wmw1)\n\t    new_size = wmw1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin->w_width - new_size - 1 < p_wmw)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixwidth' window.  Take them from a window to the left or right\n\t// instead, if possible. Add one for the separator.\n\tif (oldwin->w_p_wfw)\n\t    win_setwidth_win(oldwin->w_width + new_size + 1, oldwin);\n\n\t// Only make all windows the same width if one of them (except oldwin)\n\t// is wider than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'v'\n\t\t\t\t\t && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_width > new_size\n\t\t\t    || frp->fr_win->w_width > oldwin->w_width\n\t\t\t\t\t\t\t      - new_size - 1))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n    else\n    {\n\tlayout = FR_COL;\n\n\t/*\n\t * Check if we are able to split the current window and compute its\n\t * height.\n\t */\n\t// Current window requires at least 1 space.\n\twmh1 = (p_wmh == 0 ? 1 : p_wmh) + WINBAR_HEIGHT(curwin);\n\tneeded = wmh1 + STATUS_HEIGHT;\n\tif (flags & WSP_ROOM)\n\t    needed += p_wh - wmh1;\n\tif (flags & (WSP_BOT | WSP_TOP))\n\t{\n\t    minheight = frame_minheight(topframe, NOWIN) + need_status;\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse if (p_ea)\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    prevfrp = oldwin->w_frame;\n\t    for (frp = oldwin->w_frame->fr_parent; frp != NULL;\n\t\t\t\t\t\t\tfrp = frp->fr_parent)\n\t    {\n\t\tif (frp->fr_layout == FR_COL)\n\t\t    FOR_ALL_FRAMES(frp2, frp->fr_child)\n\t\t\tif (frp2 != prevfrp)\n\t\t\t    minheight += frame_minheight(frp2, NOWIN);\n\t\tprevfrp = frp;\n\t    }\n\t    available = topframe->fr_height;\n\t    needed += minheight;\n\t}\n\telse\n\t{\n\t    minheight = frame_minheight(oldwin->w_frame, NOWIN) + need_status;\n\t    available = oldwin->w_frame->fr_height;\n\t    needed += minheight;\n\t}\n\tif (available < needed && new_wp == NULL)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    return FAIL;\n\t}\n\toldwin_height = oldwin->w_height;\n\tif (need_status)\n\t{\n\t    oldwin->w_status_height = STATUS_HEIGHT;\n\t    oldwin_height -= STATUS_HEIGHT;\n\t}\n\tif (new_size == 0)\n\t    new_size = oldwin_height / 2;\n\tif (new_size > available - minheight - STATUS_HEIGHT)\n\t    new_size = available - minheight - STATUS_HEIGHT;\n\tif (new_size < wmh1)\n\t    new_size = wmh1;\n\n\t// if it doesn't fit in the current window, need win_equal()\n\tif (oldwin_height - new_size - STATUS_HEIGHT < p_wmh)\n\t    do_equal = TRUE;\n\n\t// We don't like to take lines for the new window from a\n\t// 'winfixheight' window.  Take them from a window above or below\n\t// instead, if possible.\n\tif (oldwin->w_p_wfh)\n\t{\n\t    // Set w_fraction now so that the cursor keeps the same relative\n\t    // vertical position using the old height.\n\t    set_fraction(oldwin);\n\t    did_set_fraction = TRUE;\n\n\t    win_setheight_win(oldwin->w_height + new_size + STATUS_HEIGHT,\n\t\t\t\t\t\t\t\t      oldwin);\n\t    oldwin_height = oldwin->w_height;\n\t    if (need_status)\n\t\toldwin_height -= STATUS_HEIGHT;\n\t}\n\n\t// Only make all windows the same height if one of them (except oldwin)\n\t// is higher than one of the split windows.\n\tif (!do_equal && p_ea && size == 0 && *p_ead != 'h'\n\t   && oldwin->w_frame->fr_parent != NULL)\n\t{\n\t    frp = oldwin->w_frame->fr_parent->fr_child;\n\t    while (frp != NULL)\n\t    {\n\t\tif (frp->fr_win != oldwin && frp->fr_win != NULL\n\t\t\t&& (frp->fr_win->w_height > new_size\n\t\t\t    || frp->fr_win->w_height > oldwin_height - new_size\n\t\t\t\t\t\t\t      - STATUS_HEIGHT))\n\t\t{\n\t\t    do_equal = TRUE;\n\t\t    break;\n\t\t}\n\t\tfrp = frp->fr_next;\n\t    }\n\t}\n    }\n\n    /*\n     * allocate new window structure and link it in the window list\n     */\n    if ((flags & WSP_TOP) == 0\n\t    && ((flags & WSP_BOT)\n\t\t|| (flags & WSP_BELOW)\n\t\t|| (!(flags & WSP_ABOVE)\n\t\t    && ( (flags & WSP_VERT) ? p_spr : p_sb))))\n    {\n\t// new window below/right of current one\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin, FALSE);\n\telse\n\t    win_append(oldwin, wp);\n    }\n    else\n    {\n\tif (new_wp == NULL)\n\t    wp = win_alloc(oldwin->w_prev, FALSE);\n\telse\n\t    win_append(oldwin->w_prev, wp);\n    }\n\n    if (new_wp == NULL)\n    {\n\tif (wp == NULL)\n\t    return FAIL;\n\n\tnew_frame(wp);\n\tif (wp->w_frame == NULL)\n\t{\n\t    win_free(wp, NULL);\n\t    return FAIL;\n\t}\n\n\t// make the contents of the new window the same as the current one\n\twin_init(wp, curwin, flags);\n    }\n\n    /*\n     * Reorganise the tree of frames to insert the new window.\n     */\n    if (flags & (WSP_TOP | WSP_BOT))\n    {\n\tif ((topframe->fr_layout == FR_COL && (flags & WSP_VERT) == 0)\n\t    || (topframe->fr_layout == FR_ROW && (flags & WSP_VERT) != 0))\n\t{\n\t    curfrp = topframe->fr_child;\n\t    if (flags & WSP_BOT)\n\t\twhile (curfrp->fr_next != NULL)\n\t\t    curfrp = curfrp->fr_next;\n\t}\n\telse\n\t    curfrp = topframe;\n\tbefore = (flags & WSP_TOP);\n    }\n    else\n    {\n\tcurfrp = oldwin->w_frame;\n\tif (flags & WSP_BELOW)\n\t    before = FALSE;\n\telse if (flags & WSP_ABOVE)\n\t    before = TRUE;\n\telse if (flags & WSP_VERT)\n\t    before = !p_spr;\n\telse\n\t    before = !p_sb;\n    }\n    if (curfrp->fr_parent == NULL || curfrp->fr_parent->fr_layout != layout)\n    {\n\t// Need to create a new frame in the tree to make a branch.\n\tfrp = ALLOC_CLEAR_ONE(frame_T);\n\t*frp = *curfrp;\n\tcurfrp->fr_layout = layout;\n\tfrp->fr_parent = curfrp;\n\tfrp->fr_next = NULL;\n\tfrp->fr_prev = NULL;\n\tcurfrp->fr_child = frp;\n\tcurfrp->fr_win = NULL;\n\tcurfrp = frp;\n\tif (frp->fr_win != NULL)\n\t    oldwin->w_frame = frp;\n\telse\n\t    FOR_ALL_FRAMES(frp, frp->fr_child)\n\t\tfrp->fr_parent = curfrp;\n    }\n\n    if (new_wp == NULL)\n\tfrp = wp->w_frame;\n    else\n\tfrp = new_wp->w_frame;\n    frp->fr_parent = curfrp->fr_parent;\n\n    // Insert the new frame at the right place in the frame list.\n    if (before)\n\tframe_insert(curfrp, frp);\n    else\n\tframe_append(curfrp, frp);\n\n    // Set w_fraction now so that the cursor keeps the same relative\n    // vertical position.\n    if (!did_set_fraction)\n\tset_fraction(oldwin);\n    wp->w_fraction = oldwin->w_fraction;\n\n    if (flags & WSP_VERT)\n    {\n\twp->w_p_scr = curwin->w_p_scr;\n\n\tif (need_status)\n\t{\n\t    win_new_height(oldwin, oldwin->w_height - 1);\n\t    oldwin->w_status_height = need_status;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    // set height and row of new window to full height\n\t    wp->w_winrow = tabline_height();\n\t    win_new_height(wp, curfrp->fr_height - (p_ls > 0)\n\t\t\t\t\t\t\t  - WINBAR_HEIGHT(wp));\n\t    wp->w_status_height = (p_ls > 0);\n\t}\n\telse\n\t{\n\t    // height and row of new window is same as current window\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    win_new_height(wp, VISIBLE_HEIGHT(oldwin));\n\t    wp->w_status_height = oldwin->w_status_height;\n\t}\n\tfrp->fr_height = curfrp->fr_height;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one column for the vertical separator\n\twin_new_width(wp, new_size);\n\tif (before)\n\t    wp->w_vsep_width = 1;\n\telse\n\t{\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t    oldwin->w_vsep_width = 1;\n\t}\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    if (flags & WSP_BOT)\n\t\tframe_add_vsep(curfrp);\n\t    // Set width of neighbor frame\n\t    frame_new_width(curfrp, curfrp->fr_width\n\t\t     - (new_size + ((flags & WSP_TOP) != 0)), flags & WSP_TOP,\n\t\t\t\t\t\t\t\t       FALSE);\n\t}\n\telse\n\t    win_new_width(oldwin, oldwin->w_width - (new_size + 1));\n\tif (before)\t// new window left of current one\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    oldwin->w_wincol += new_size + 1;\n\t}\n\telse\t\t// new window right of current one\n\t    wp->w_wincol = oldwin->w_wincol + oldwin->w_width + 1;\n\tframe_fix_width(oldwin);\n\tframe_fix_width(wp);\n    }\n    else\n    {\n\t// width and column of new window is same as current window\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    wp->w_wincol = 0;\n\t    win_new_width(wp, Columns);\n\t    wp->w_vsep_width = 0;\n\t}\n\telse\n\t{\n\t    wp->w_wincol = oldwin->w_wincol;\n\t    win_new_width(wp, oldwin->w_width);\n\t    wp->w_vsep_width = oldwin->w_vsep_width;\n\t}\n\tfrp->fr_width = curfrp->fr_width;\n\n\t// \"new_size\" of the current window goes to the new window, use\n\t// one row for the status line\n\twin_new_height(wp, new_size);\n\tif (flags & (WSP_TOP | WSP_BOT))\n\t{\n\t    int new_fr_height = curfrp->fr_height - new_size\n\t\t\t\t\t\t\t  + WINBAR_HEIGHT(wp) ;\n\n\t    if (!((flags & WSP_BOT) && p_ls == 0))\n\t\tnew_fr_height -= STATUS_HEIGHT;\n\t    frame_new_height(curfrp, new_fr_height, flags & WSP_TOP, FALSE);\n\t}\n\telse\n\t    win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));\n\tif (before)\t// new window above current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t    oldwin->w_winrow += wp->w_height + STATUS_HEIGHT;\n\t}\n\telse\t\t// new window below current one\n\t{\n\t    wp->w_winrow = oldwin->w_winrow + VISIBLE_HEIGHT(oldwin)\n\t\t\t\t\t\t\t       + STATUS_HEIGHT;\n\t    wp->w_status_height = oldwin->w_status_height;\n\t    if (!(flags & WSP_BOT))\n\t\toldwin->w_status_height = STATUS_HEIGHT;\n\t}\n\tif (flags & WSP_BOT)\n\t    frame_add_statusline(curfrp);\n\tframe_fix_height(wp);\n\tframe_fix_height(oldwin);\n    }\n\n    if (flags & (WSP_TOP | WSP_BOT))\n\t(void)win_comp_pos();\n\n     // Both windows need redrawing.  Update all status lines, in case they\n     // show something related to the window count or position.\n    redraw_win_later(wp, NOT_VALID);\n    redraw_win_later(oldwin, NOT_VALID);\n    status_redraw_all();\n\n    if (need_status)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = sc_col;\n\tmsg_clr_eos_force();\t// Old command/ruler may still be there\n\tcomp_col();\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\t// put position back at start of line\n    }\n\n    /*\n     * equalize the window sizes.\n     */\n    if (do_equal || dir != 0)\n\twin_equal(wp, TRUE,\n\t\t(flags & WSP_VERT) ? (dir == 'v' ? 'b' : 'h')\n\t\t: dir == 'h' ? 'b' : 'v');\n\n    // Don't change the window height/width to 'winheight' / 'winwidth' if a\n    // size was given.\n    if (flags & WSP_VERT)\n    {\n\ti = p_wiw;\n\tif (size != 0)\n\t    p_wiw = size;\n\n# ifdef FEAT_GUI\n\t// When 'guioptions' includes 'L' or 'R' may have to add scrollbars.\n\tif (gui.in_use)\n\t    gui_init_which_components(NULL);\n# endif\n    }\n    else\n    {\n\ti = p_wh;\n\tif (size != 0)\n\t    p_wh = size;\n    }\n\n    // Keep same changelist position in new window.\n    wp->w_changelistidx = oldwin->w_changelistidx;\n\n    /*\n     * make the new window the current window\n     */\n    (void)win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n    if (flags & WSP_VERT)\n\tp_wiw = i;\n    else\n\tp_wh = i;\n\n    return OK;\n}\n\n\n/*\n * Initialize window \"newp\" from window \"oldp\".\n * Used when splitting a window and when creating a new tab page.\n * The windows will both edit the same buffer.\n * WSP_NEWLOC may be specified in flags to prevent the location list from\n * being copied.\n */\n    static void\nwin_init(win_T *newp, win_T *oldp, int flags UNUSED)\n{\n    int\t\ti;\n\n    newp->w_buffer = oldp->w_buffer;\n#ifdef FEAT_SYN_HL\n    newp->w_s = &(oldp->w_buffer->b_s);\n#endif\n    oldp->w_buffer->b_nwindows++;\n    newp->w_cursor = oldp->w_cursor;\n    newp->w_valid = 0;\n    newp->w_curswant = oldp->w_curswant;\n    newp->w_set_curswant = oldp->w_set_curswant;\n    newp->w_topline = oldp->w_topline;\n#ifdef FEAT_DIFF\n    newp->w_topfill = oldp->w_topfill;\n#endif\n    newp->w_leftcol = oldp->w_leftcol;\n    newp->w_pcmark = oldp->w_pcmark;\n    newp->w_prev_pcmark = oldp->w_prev_pcmark;\n    newp->w_alt_fnum = oldp->w_alt_fnum;\n    newp->w_wrow = oldp->w_wrow;\n    newp->w_fraction = oldp->w_fraction;\n    newp->w_prev_fraction_row = oldp->w_prev_fraction_row;\n    copy_jumplist(oldp, newp);\n#ifdef FEAT_QUICKFIX\n    if (flags & WSP_NEWLOC)\n    {\n\t// Don't copy the location list.\n\tnewp->w_llist = NULL;\n\tnewp->w_llist_ref = NULL;\n    }\n    else\n\tcopy_loclist_stack(oldp, newp);\n#endif\n    newp->w_localdir = (oldp->w_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_localdir);\n    newp->w_prevdir = (oldp->w_prevdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(oldp->w_prevdir);\n\n    // copy tagstack and folds\n    for (i = 0; i < oldp->w_tagstacklen; i++)\n    {\n\ttaggy_T\t*tag = &newp->w_tagstack[i];\n\t*tag = oldp->w_tagstack[i];\n\tif (tag->tagname != NULL)\n\t    tag->tagname = vim_strsave(tag->tagname);\n\tif (tag->user_data != NULL)\n\t    tag->user_data = vim_strsave(tag->user_data);\n    }\n    newp->w_tagstackidx = oldp->w_tagstackidx;\n    newp->w_tagstacklen = oldp->w_tagstacklen;\n#ifdef FEAT_FOLDING\n    copyFoldingState(oldp, newp);\n#endif\n\n    win_init_some(newp, oldp);\n#ifdef FEAT_TERMINAL\n    term_update_wincolor(newp);\n#endif\n}\n\n/*\n * Initialize window \"newp\" from window \"old\".\n * Only the essential things are copied.\n */\n    static void\nwin_init_some(win_T *newp, win_T *oldp)\n{\n    // Use the same argument list.\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n\n    // copy options from existing window\n    win_copy_options(oldp, newp);\n}\n\n/*\n * Return TRUE if \"win\" is a global popup or a popup in the current tab page.\n */\n    int\nwin_valid_popup(win_T *win UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    win_T\t*wp;\n\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp == win)\n\t    return TRUE;\n#endif\n    return FALSE;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in the current tab page.\n */\n    int\nwin_valid(win_T *win)\n{\n    win_T\t*wp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp == win)\n\t    return TRUE;\n    return win_valid_popup(win);\n}\n\n/*\n * Find window \"id\" in the current tab page.\n * Also find popup windows.\n * Return NULL if not found.\n */\n    win_T *\nwin_find_by_id(int id)\n{\n    win_T   *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tif (wp->w_id == id)\n\t    return wp;\n    FOR_ALL_POPUPWINS_IN_TAB(curtab, wp)\n\tif (wp->w_id == id)\n\t    return wp;\n#endif\n    return NULL;\n}\n\n/*\n * Check if \"win\" is a pointer to an existing window in any tab page.\n */\n    int\nwin_valid_any_tab(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    if (win == NULL)\n\treturn FALSE;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tFOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t{\n\t    if (wp == win)\n\t\treturn TRUE;\n\t}\n#ifdef FEAT_PROP_POPUP\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t    if (wp == win)\n\t\treturn TRUE;\n#endif\n    }\n    return win_valid_popup(win);\n}\n\n/*\n * Return the number of windows.\n */\n    int\nwin_count(void)\n{\n    win_T\t*wp;\n    int\t\tcount = 0;\n\n    FOR_ALL_WINDOWS(wp)\n\t++count;\n    return count;\n}\n\n/*\n * Make \"count\" windows on the screen.\n * Return actual number of windows on the screen.\n * Must be called when there is just one window, filling the whole screen\n * (excluding the command line).\n */\n    int\nmake_windows(\n    int\t\tcount,\n    int\t\tvertical UNUSED)  // split windows vertically if TRUE\n{\n    int\t\tmaxcount;\n    int\t\ttodo;\n\n    if (vertical)\n    {\n\t// Each window needs at least 'winminwidth' lines and a separator\n\t// column.\n\tmaxcount = (curwin->w_width + curwin->w_vsep_width\n\t\t\t\t\t     - (p_wiw - p_wmw)) / (p_wmw + 1);\n    }\n    else\n    {\n\t// Each window needs at least 'winminheight' lines and a status line.\n\tmaxcount = (VISIBLE_HEIGHT(curwin) + curwin->w_status_height\n\t\t\t\t  - (p_wh - p_wmh)) / (p_wmh + STATUS_HEIGHT);\n    }\n\n    if (maxcount < 2)\n\tmaxcount = 2;\n    if (count > maxcount)\n\tcount = maxcount;\n\n    /*\n     * add status line now, otherwise first window will be too big\n     */\n    if (count > 1)\n\tlast_status(TRUE);\n\n    /*\n     * Don't execute autocommands while creating the windows.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    // todo is number of windows left to create\n    for (todo = count - 1; todo > 0; --todo)\n\tif (vertical)\n\t{\n\t    if (win_split(curwin->w_width - (curwin->w_width - todo)\n\t\t\t/ (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    if (win_split(curwin->w_height - (curwin->w_height - todo\n\t\t\t    * STATUS_HEIGHT) / (todo + 1)\n\t\t\t- STATUS_HEIGHT, WSP_ABOVE) == FAIL)\n\t\tbreak;\n\t}\n\n    unblock_autocmds();\n\n    // return actual number of windows\n    return (count - todo);\n}\n\n/*\n * Exchange current and next window\n */\n    static void\nwin_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    // just one window\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * find window to exchange with\n     */\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t// Swap with next\n\tfrp = curwin->w_frame->fr_next;\n    else    // Swap last window in row/col with previous\n\tfrp = curwin->w_frame->fr_prev;\n\n    // We can only exchange a window with another window, not with a frame\n    // containing windows.\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n\n/*\n * 1. remove curwin from the list. Remember after which window it was in wp2\n * 2. insert curwin before wp in the list\n * if wp != wp2\n *    3. remove wp from the list\n *    4. insert wp after wp2\n * 5. exchange the status line height and vsep width.\n */\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n\n    (void)win_comp_pos();\t\t// recompute window positions\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * rotate windows: if upwards TRUE the second window becomes the first one\n *\t\t   if upwards FALSE the first window becomes the second one\n */\n    static void\nwin_rotate(int upwards, int count)\n{\n    win_T\t*wp1;\n    win_T\t*wp2;\n    frame_T\t*frp;\n    int\t\tn;\n\n    if (ONE_WINDOW)\t\t// nothing to do\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Check if all frames in this row/col have one window.\n    FOR_ALL_FRAMES(frp, curwin->w_frame->fr_parent->fr_child)\n\tif (frp->fr_win == NULL)\n\t{\n\t    emsg(_(e_cannot_rotate_when_another_window_is_split));\n\t    return;\n\t}\n\n    while (count--)\n    {\n\tif (upwards)\t\t// first window becomes last window\n\t{\n\t    // remove first window/frame from the list\n\t    frp = curwin->w_frame->fr_parent->fr_child;\n\t    wp1 = frp->fr_win;\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // find last frame and append removed window/frame after it\n\t    for ( ; frp->fr_next != NULL; frp = frp->fr_next)\n\t\t;\n\t    win_append(frp->fr_win, wp1);\n\t    frame_append(frp, wp1->w_frame);\n\n\t    wp2 = frp->fr_win;\t\t// previously last window\n\t}\n\telse\t\t\t// last window becomes first window\n\t{\n\t    // find last window/frame in the list and remove it\n\t    for (frp = curwin->w_frame; frp->fr_next != NULL;\n\t\t\t\t\t\t\t   frp = frp->fr_next)\n\t\t;\n\t    wp1 = frp->fr_win;\n\t    wp2 = wp1->w_prev;\t\t    // will become last window\n\t    win_remove(wp1, NULL);\n\t    frame_remove(frp);\n\n\t    // append the removed window/frame before the first in the list\n\t    win_append(frp->fr_parent->fr_child->fr_win->w_prev, wp1);\n\t    frame_insert(frp->fr_parent->fr_child, frp);\n\t}\n\n\t// exchange status height and vsep width of old and new last window\n\tn = wp2->w_status_height;\n\twp2->w_status_height = wp1->w_status_height;\n\twp1->w_status_height = n;\n\tframe_fix_height(wp1);\n\tframe_fix_height(wp2);\n\tn = wp2->w_vsep_width;\n\twp2->w_vsep_width = wp1->w_vsep_width;\n\twp1->w_vsep_width = n;\n\tframe_fix_width(wp1);\n\tframe_fix_width(wp2);\n\n\t// recompute w_winrow and w_wincol for all windows\n\t(void)win_comp_pos();\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Move the current window to the very top/bottom/left/right of the screen.\n */\n    static void\nwin_totop(int size, int flags)\n{\n    int\t\tdir;\n    int\t\theight = curwin->w_height;\n\n    if (ONE_WINDOW)\n    {\n\tbeep_flush();\n\treturn;\n    }\n    if (check_split_disallowed() == FAIL)\n\treturn;\n\n    // Remove the window and frame from the tree of frames.\n    (void)winframe_remove(curwin, &dir, NULL);\n    win_remove(curwin, NULL);\n    last_status(FALSE);\t    // may need to remove last status line\n    (void)win_comp_pos();   // recompute window positions\n\n    // Split a window on the desired side and put the window there.\n    (void)win_split_ins(size, flags, curwin, dir);\n    if (!(flags & WSP_VERT))\n    {\n\twin_setheight(height);\n\tif (p_ea)\n\t    win_equal(curwin, TRUE, 'v');\n    }\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n}\n\n/*\n * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current\n * window.  Only works within the same frame!\n */\n    void\nwin_move_after(win_T *win1, win_T *win2)\n{\n    int\t\theight;\n\n    // check if the arguments are reasonable\n    if (win1 == win2)\n\treturn;\n\n    // check if there is something to do\n    if (win2->w_next != win1)\n    {\n\tif (win1->w_frame->fr_parent != win2->w_frame->fr_parent)\n\t{\n\t    iemsg(\"INTERNAL: trying to move a window into another frame\");\n\t    return;\n\t}\n\n\t// may need to move the status line/vertical separator of the last\n\t// window\n\tif (win1 == lastwin)\n\t{\n\t    height = win1->w_prev->w_status_height;\n\t    win1->w_prev->w_status_height = win1->w_status_height;\n\t    win1->w_status_height = height;\n\t    if (win1->w_prev->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from the last-but-one window,\n\t\t// add it to the last window.  Adjust the frame widths.\n\t\twin1->w_prev->w_vsep_width = 0;\n\t\twin1->w_prev->w_frame->fr_width -= 1;\n\t\twin1->w_vsep_width = 1;\n\t\twin1->w_frame->fr_width += 1;\n\t    }\n\t}\n\telse if (win2 == lastwin)\n\t{\n\t    height = win1->w_status_height;\n\t    win1->w_status_height = win2->w_status_height;\n\t    win2->w_status_height = height;\n\t    if (win1->w_vsep_width == 1)\n\t    {\n\t\t// Remove the vertical separator from win1, add it to the last\n\t\t// window, win2.  Adjust the frame widths.\n\t\twin2->w_vsep_width = 1;\n\t\twin2->w_frame->fr_width += 1;\n\t\twin1->w_vsep_width = 0;\n\t\twin1->w_frame->fr_width -= 1;\n\t    }\n\t}\n\twin_remove(win1, NULL);\n\tframe_remove(win1->w_frame);\n\twin_append(win2, win1);\n\tframe_append(win2->w_frame, win1->w_frame);\n\n\t(void)win_comp_pos();\t// recompute w_winrow for all windows\n\tredraw_later(NOT_VALID);\n    }\n    win_enter(win1, FALSE);\n}\n\n/*\n * Make all windows the same height.\n * 'next_curwin' will soon be the current window, make sure it has enough\n * rows.\n */\n    void\nwin_equal(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    int\t\tdir)\t\t// 'v' for vertically, 'h' for horizontally,\n\t\t\t\t// 'b' for both, 0 for using p_ead\n{\n    if (dir == 0)\n\tdir = *p_ead;\n    win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,\n\t\t      topframe, dir, 0, tabline_height(),\n\t\t\t\t\t   (int)Columns, topframe->fr_height);\n}\n\n/*\n * Set a frame to a new position and height, spreading the available room\n * equally over contained frames.\n * The window \"next_curwin\" (if not NULL) should at least get the size from\n * 'winheight' and 'winwidth' if possible.\n */\n    static void\nwin_equal_rec(\n    win_T\t*next_curwin,\t// pointer to current window to be or NULL\n    int\t\tcurrent,\t// do only frame with current window\n    frame_T\t*topfr,\t\t// frame to set size off\n    int\t\tdir,\t\t// 'v', 'h' or 'b', see win_equal()\n    int\t\tcol,\t\t// horizontal position for frame\n    int\t\trow,\t\t// vertical position for frame\n    int\t\twidth,\t\t// new width of frame\n    int\t\theight)\t\t// new height of frame\n{\n    int\t\tn, m;\n    int\t\textra_sep = 0;\n    int\t\twincount, totwincount = 0;\n    frame_T\t*fr;\n    int\t\tnext_curwin_size = 0;\n    int\t\troom = 0;\n    int\t\tnew_size;\n    int\t\thas_next_curwin = 0;\n    int\t\thnc;\n\n    if (topfr->fr_layout == FR_LEAF)\n    {\n\t// Set the width/height of this frame.\n\t// Redraw when size or position changes\n\tif (topfr->fr_height != height || topfr->fr_win->w_winrow != row\n\t\t|| topfr->fr_width != width || topfr->fr_win->w_wincol != col\n\t   )\n\t{\n\t    topfr->fr_win->w_winrow = row;\n\t    frame_new_height(topfr, height, FALSE, FALSE);\n\t    topfr->fr_win->w_wincol = col;\n\t    frame_new_width(topfr, width, FALSE, FALSE);\n\t    redraw_all_later(NOT_VALID);\n\t}\n    }\n    else if (topfr->fr_layout == FR_ROW)\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'v')\t\t\t// equalize frame widths\n\t{\n\t    // Compute the maximum number of windows horizontally in this\n\t    // frame.\n\t    n = frame_minwidth(topfr, NOWIN);\n\t    // add one for the rightmost window, it doesn't have a separator\n\t    if (col + width == Columns)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmw + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute width for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal width when counting p_wiw for \"next_curwin\".\n\t     */\n\t    m = frame_minwidth(topfr, next_curwin);\n\t    room = width - m;\n\t    if (room < 0)\n\t    {\n\t\tnext_curwin_size = p_wiw + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixwidth' set keep the window width if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_width(fr))\n\t\t    {\n\t\t\tn = frame_minwidth(fr, NOWIN);\n\t\t\tnew_size = fr->fr_width;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wiw - p_wmw;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wiw)\n\t\t\t\tnew_size = p_wiw;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmw + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newwidth = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t  / (totwincount - 1) > p_wiw)\n\t\t    {\n\t\t\t// Can make all windows wider than 'winwidth', spread\n\t\t\t// the room equally.\n\t\t\tnext_curwin_size = (room + p_wiw\n\t\t\t\t\t    + (totwincount - 1) * p_wmw\n\t\t\t\t\t    + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wiw;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wiw;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = width;\n\t    else if (dir == 'v')\n\t\tnew_size = fr->fr_width;\n\t    else if (frame_fixed_width(fr))\n\t    {\n\t\tnew_size = fr->fr_newwidth;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows horiz. in \"fr\".\n\t\tn = frame_minwidth(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmw + 1);\n\t\tm = frame_minwidth(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wiw - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'v' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_width)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t    new_size, height);\n\t    col += new_size;\n\t    width -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n    else // topfr->fr_layout == FR_COL\n    {\n\ttopfr->fr_width = width;\n\ttopfr->fr_height = height;\n\n\tif (dir != 'h')\t\t\t// equalize frame heights\n\t{\n\t    // Compute maximum number of windows vertically in this frame.\n\t    n = frame_minheight(topfr, NOWIN);\n\t    // add one for the bottom window if it doesn't have a statusline\n\t    if (row + height == cmdline_row && p_ls == 0)\n\t\textra_sep = 1;\n\t    else\n\t\textra_sep = 0;\n\t    totwincount = (n + extra_sep) / (p_wmh + 1);\n\t    has_next_curwin = frame_has_win(topfr, next_curwin);\n\n\t    /*\n\t     * Compute height for \"next_curwin\" window and room available for\n\t     * other windows.\n\t     * \"m\" is the minimal height when counting p_wh for \"next_curwin\".\n\t     */\n\t    m = frame_minheight(topfr, next_curwin);\n\t    room = height - m;\n\t    if (room < 0)\n\t    {\n\t\t// The room is less than 'winheight', use all space for the\n\t\t// current window.\n\t\tnext_curwin_size = p_wh + room;\n\t\troom = 0;\n\t    }\n\t    else\n\t    {\n\t\tnext_curwin_size = -1;\n\t\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t\t{\n\t\t    // If 'winfixheight' set keep the window height if\n\t\t    // possible.\n\t\t    // Watch out for this window being the next_curwin.\n\t\t    if (frame_fixed_height(fr))\n\t\t    {\n\t\t\tn = frame_minheight(fr, NOWIN);\n\t\t\tnew_size = fr->fr_height;\n\t\t\tif (frame_has_win(fr, next_curwin))\n\t\t\t{\n\t\t\t    room += p_wh - p_wmh;\n\t\t\t    next_curwin_size = 0;\n\t\t\t    if (new_size < p_wh)\n\t\t\t\tnew_size = p_wh;\n\t\t\t}\n\t\t\telse\n\t\t\t    // These windows don't use up room.\n\t\t\t    totwincount -= (n + (fr->fr_next == NULL\n\t\t\t\t\t      ? extra_sep : 0)) / (p_wmh + 1);\n\t\t\troom -= new_size - n;\n\t\t\tif (room < 0)\n\t\t\t{\n\t\t\t    new_size += room;\n\t\t\t    room = 0;\n\t\t\t}\n\t\t\tfr->fr_newheight = new_size;\n\t\t    }\n\t\t}\n\t\tif (next_curwin_size == -1)\n\t\t{\n\t\t    if (!has_next_curwin)\n\t\t\tnext_curwin_size = 0;\n\t\t    else if (totwincount > 1\n\t\t\t    && (room + (totwincount - 2))\n\t\t\t\t\t\t   / (totwincount - 1) > p_wh)\n\t\t    {\n\t\t\t// can make all windows higher than 'winheight',\n\t\t\t// spread the room equally.\n\t\t\tnext_curwin_size = (room + p_wh\n\t\t\t\t\t   + (totwincount - 1) * p_wmh\n\t\t\t\t\t   + (totwincount - 1)) / totwincount;\n\t\t\troom -= next_curwin_size - p_wh;\n\t\t    }\n\t\t    else\n\t\t\tnext_curwin_size = p_wh;\n\t\t}\n\t    }\n\n\t    if (has_next_curwin)\n\t\t--totwincount;\t\t// don't count curwin\n\t}\n\n\tFOR_ALL_FRAMES(fr, topfr->fr_child)\n\t{\n\t    wincount = 1;\n\t    if (fr->fr_next == NULL)\n\t\t// last frame gets all that remains (avoid roundoff error)\n\t\tnew_size = height;\n\t    else if (dir == 'h')\n\t\tnew_size = fr->fr_height;\n\t    else if (frame_fixed_height(fr))\n\t    {\n\t\tnew_size = fr->fr_newheight;\n\t\twincount = 0;\t    // doesn't count as a sizeable window\n\t    }\n\t    else\n\t    {\n\t\t// Compute the maximum number of windows vert. in \"fr\".\n\t\tn = frame_minheight(fr, NOWIN);\n\t\twincount = (n + (fr->fr_next == NULL ? extra_sep : 0))\n\t\t\t\t\t\t\t\t/ (p_wmh + 1);\n\t\tm = frame_minheight(fr, next_curwin);\n\t\tif (has_next_curwin)\n\t\t    hnc = frame_has_win(fr, next_curwin);\n\t\telse\n\t\t    hnc = FALSE;\n\t\tif (hnc)\t    // don't count next_curwin\n\t\t    --wincount;\n\t\tif (totwincount == 0)\n\t\t    new_size = room;\n\t\telse\n\t\t    new_size = (wincount * room + ((unsigned)totwincount >> 1))\n\t\t\t\t\t\t\t\t/ totwincount;\n\t\tif (hnc)\t    // add next_curwin size\n\t\t{\n\t\t    next_curwin_size -= p_wh - (m - n);\n\t\t    new_size += next_curwin_size;\n\t\t    room -= new_size - next_curwin_size;\n\t\t}\n\t\telse\n\t\t    room -= new_size;\n\t\tnew_size += n;\n\t    }\n\t    // Skip frame that is full width when splitting or closing a\n\t    // window, unless equalizing all frames.\n\t    if (!current || dir != 'h' || topfr->fr_parent != NULL\n\t\t    || (new_size != fr->fr_height)\n\t\t    || frame_has_win(fr, next_curwin))\n\t\twin_equal_rec(next_curwin, current, fr, dir, col, row,\n\t\t\t\t\t\t\t     width, new_size);\n\t    row += new_size;\n\t    height -= new_size;\n\t    totwincount -= wincount;\n\t}\n    }\n}\n\n#ifdef FEAT_JOB_CHANNEL\n    static void\nleaving_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When leaving a prompt window stop Insert mode and perhaps restart\n    // it when entering that window again.\n    win->w_buffer->b_prompt_insert = restart_edit;\n    if (restart_edit != 0 && mode_displayed)\n\tclear_cmdline = TRUE;\t\t// unshow mode later\n    restart_edit = NUL;\n\n    // When leaving the window (or closing the window) was done from a\n    // callback we need to break out of the Insert mode loop and restart Insert\n    // mode when entering the window again.\n    if (State & INSERT)\n    {\n\tstop_insert_mode = TRUE;\n\tif (win->w_buffer->b_prompt_insert == NUL)\n\t    win->w_buffer->b_prompt_insert = 'A';\n    }\n}\n\n    void\nentering_window(win_T *win)\n{\n    // Only matters for a prompt window.\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n\n    // When switching to a prompt buffer that was in Insert mode, don't stop\n    // Insert mode, it may have been set in leaving_window().\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n\n    // When entering the prompt window restart Insert mode if we were in Insert\n    // mode when we left it and not already in Insert mode.\n    if ((State & INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}\n#endif\n\n/*\n * Close all windows for buffer \"buf\".\n */\n    void\nclose_windows(\n    buf_T\t*buf,\n    int\t\tkeep_curwin)\t    // don't close \"curwin\"\n{\n    win_T\t*wp;\n    tabpage_T   *tp, *nexttp;\n    int\t\th = tabline_height();\n    int\t\tcount = tabpage_index(NULL);\n\n    ++RedrawingDisabled;\n\n    for (wp = firstwin; wp != NULL && !ONE_WINDOW; )\n    {\n\tif (wp->w_buffer == buf && (!keep_curwin || wp != curwin)\n\t\t&& !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t{\n\t    if (win_close(wp, FALSE) == FAIL)\n\t\t// If closing the window fails give up, to avoid looping\n\t\t// forever.\n\t\tbreak;\n\n\t    // Start all over, autocommands may change the window layout.\n\t    wp = firstwin;\n\t}\n\telse\n\t    wp = wp->w_next;\n    }\n\n    // Also check windows in other tab pages.\n    for (tp = first_tabpage; tp != NULL; tp = nexttp)\n    {\n\tnexttp = tp->tp_next;\n\tif (tp != curtab)\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0))\n\t\t{\n\t\t    win_close_othertab(wp, FALSE, tp);\n\n\t\t    // Start all over, the tab page may be closed and\n\t\t    // autocommands may change the window layout.\n\t\t    nexttp = first_tabpage;\n\t\t    break;\n\t\t}\n    }\n\n    --RedrawingDisabled;\n\n    if (count != tabpage_index(NULL))\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\n    redraw_tabline = TRUE;\n    if (h != tabline_height())\n\tshell_new_rows();\n}\n\n/*\n * Return TRUE if the current window is the only window that exists (ignoring\n * \"aucmd_win\").\n * Returns FALSE if there is a window, possibly in another tab page.\n */\n    static int\nlast_window(void)\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}\n\n/*\n * Return TRUE if there is only one window other than \"aucmd_win\" in the\n * current tab page.\n */\n    int\none_window(void)\n{\n    win_T\t*wp;\n    int\t\tseen_one = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (wp != aucmd_win)\n\t{\n\t    if (seen_one)\n\t\treturn FALSE;\n\t    seen_one = TRUE;\n\t}\n    }\n    return TRUE;\n}\n\n/*\n * Close the possibly last window in a tab page.\n * Returns TRUE when the window was closed already.\n */\n    static int\nclose_last_window_tabpage(\n    win_T\t*win,\n    int\t\tfree_buf,\n    tabpage_T   *prev_curtab)\n{\n    if (ONE_WINDOW)\n    {\n\tbuf_T\t*old_curbuf = curbuf;\n\n\t/*\n\t * Closing the last window in a tab page.  First go to another tab\n\t * page and then close the window and the tab page.  This avoids that\n\t * curwin and curtab are invalid while we are freeing memory, they may\n\t * be used in GUI events.\n\t * Don't trigger autocommands yet, they may use wrong values, so do\n\t * that below.\n\t */\n\tgoto_tabpage_tp(alt_tabpage(), FALSE, TRUE);\n\tredraw_tabline = TRUE;\n\n\t// Safety check: Autocommands may have closed the window when jumping\n\t// to the other tab page.\n\tif (valid_tabpage(prev_curtab) && prev_curtab->tp_firstwin == win)\n\t{\n\t    int\t    h = tabline_height();\n\n\t    win_close_othertab(win, free_buf, prev_curtab);\n\t    if (h != tabline_height())\n\t\tshell_new_rows();\n\t}\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\t// Since goto_tabpage_tp above did not trigger *Enter autocommands, do\n\t// that now.\n\tapply_autocmds(EVENT_TABCLOSED, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Close the buffer of \"win\" and unload it if \"action\" is DOBUF_UNLOAD.\n * \"action\" can also be zero (do nothing) or DOBUF_WIPE.\n * \"abort_if_last\" is passed to close_buffer(): abort closing if all other\n * windows are closed.\n */\n    static void\nwin_close_buffer(win_T *win, int action, int abort_if_last)\n{\n#ifdef FEAT_SYN_HL\n    // Free independent synblock before the buffer is freed.\n    if (win->w_buffer != NULL)\n\treset_synblock(win);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    // When a quickfix/location list window is closed and the buffer is\n    // displayed in only one window, then unlist the buffer.\n    if (win->w_buffer != NULL && bt_quickfix(win->w_buffer)\n\t\t\t\t\t&& win->w_buffer->b_nwindows == 1)\n\twin->w_buffer->b_p_bl = FALSE;\n#endif\n\n    // Close the link to the buffer.\n    if (win->w_buffer != NULL)\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, curbuf);\n\twin->w_closing = TRUE;\n\tclose_buffer(win, win->w_buffer, action, abort_if_last, FALSE);\n\tif (win_valid_any_tab(win))\n\t    win->w_closing = FALSE;\n\t// Make sure curbuf is valid. It can become invalid if 'bufhidden' is\n\t// \"wipe\".\n\tif (!bufref_valid(&bufref))\n\t    curbuf = firstbuf;\n    }\n}\n\n/*\n * Close window \"win\".  Only works for the current tab page.\n * If \"free_buf\" is TRUE related buffer may be unloaded.\n *\n * Called by :quit, :close, :xit, :wq and findtag().\n * Returns FAIL when the window was not closed.\n */\n    int\nwin_close(win_T *win, int free_buf)\n{\n    win_T\t*wp;\n    int\t\tother_buffer = FALSE;\n    int\t\tclose_curwin = FALSE;\n    int\t\tdir;\n    int\t\thelp_window = FALSE;\n    tabpage_T   *prev_curtab = curtab;\n    frame_T\t*win_frame = win->w_frame->fr_parent;\n#ifdef FEAT_DIFF\n    int\t\thad_diffmode = win->w_p_diff;\n#endif\n#ifdef MESSAGE_QUEUE\n    int\t\tdid_decrement = FALSE;\n#endif\n\n#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)\n    // Can close a popup window with a terminal if the job has finished.\n    if (may_close_term_popup() == OK)\n\treturn OK;\n#endif\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn FAIL;\n\n    if (last_window())\n    {\n\temsg(_(e_cannot_close_last_window));\n\treturn FAIL;\n    }\n\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn FAIL; // window is already being closed\n    if (win_unlisted(win))\n    {\n\temsg(_(e_cannot_close_autocmd_or_popup_window));\n\treturn FAIL;\n    }\n    if ((firstwin == aucmd_win || lastwin == aucmd_win) && one_window())\n    {\n\temsg(_(e_cannot_close_window_only_autocmd_window_would_remain));\n\treturn FAIL;\n    }\n\n    // When closing the last window in a tab page first go to another tab page\n    // and then close the window and the tab page to avoid that curwin and\n    // curtab are invalid while we are freeing memory.\n    if (close_last_window_tabpage(win, free_buf, prev_curtab))\n      return FAIL;\n\n    // When closing the help window, try restoring a snapshot after closing\n    // the window.  Otherwise clear the snapshot, it's now invalid.\n    if (bt_help(win->w_buffer))\n\thelp_window = TRUE;\n    else\n\tclear_snapshot(curtab, SNAP_HELP_IDX);\n\n    if (win == curwin)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tleaving_window(curwin);\n#endif\n\t/*\n\t * Guess which window is going to be the new current window.\n\t * This may change because of the autocommands (sigh).\n\t */\n\twp = frame2win(win_altframe(win, NULL));\n\n\t/*\n\t * Be careful: If autocommands delete the window or cause this window\n\t * to be the last one left, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    other_buffer = TRUE;\n\t    win->w_closing = TRUE;\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (!win_valid(win))\n\t\treturn FAIL;\n\t    win->w_closing = FALSE;\n\t    if (last_window())\n\t\treturn FAIL;\n\t}\n\twin->w_closing = TRUE;\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(win))\n\t    return FAIL;\n\twin->w_closing = FALSE;\n\tif (last_window())\n\t    return FAIL;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FAIL;\n#endif\n    }\n\n#ifdef FEAT_GUI\n    // Avoid trouble with scrollbars that are going to be deleted in\n    // win_free().\n    if (gui.in_use)\n\tout_flush();\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_win_closed(win) && !win_valid(win))\n\treturn FAIL;\n#endif\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn OK;\n\n    win_close_buffer(win, free_buf ? DOBUF_UNLOAD : 0, TRUE);\n\n    if (only_one_window() && win_valid(win) && win->w_buffer == NULL\n\t    && (last_window() || curtab != prev_curtab\n\t\t|| close_last_window_tabpage(win, free_buf, prev_curtab)))\n    {\n\t// Autocommands have closed all windows, quit now.  Restore\n\t// curwin->w_buffer, otherwise writing viminfo may fail.\n\tif (curwin->w_buffer == NULL)\n\t    curwin->w_buffer = curbuf;\n\tgetout(0);\n    }\n\n    // Autocommands may have moved to another tab page.\n    if (curtab != prev_curtab && win_valid_any_tab(win)\n\t\t\t\t\t\t      && win->w_buffer == NULL)\n    {\n\t// Need to close the window anyway, since the buffer is NULL.\n\twin_close_othertab(win, FALSE, prev_curtab);\n\treturn FAIL;\n    }\n\n    // Autocommands may have closed the window already or closed the only\n    // other window.\n    if (!win_valid(win) || last_window()\n\t    || close_last_window_tabpage(win, free_buf, prev_curtab))\n\treturn FAIL;\n\n    // Now we are really going to close the window.  Disallow any autocommand\n    // to split a window to avoid trouble.\n    // Also bail out of parse_queued_messages() to avoid it tries to update the\n    // screen.\n    ++split_disallowed;\n#ifdef MESSAGE_QUEUE\n    ++dont_parse_messages;\n#endif\n\n    // Free the memory used for the window and get the window that received\n    // the screen space.\n    wp = win_free_mem(win, &dir, NULL);\n\n    // Make sure curwin isn't invalid.  It can cause severe trouble when\n    // printing an error message.  For win_equal() curbuf needs to be valid\n    // too.\n    if (win == curwin)\n    {\n\tcurwin = wp;\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw || bt_quickfix(wp->w_buffer))\n\t{\n\t    /*\n\t     * If the cursor goes to the preview or the quickfix window, try\n\t     * finding another window to go to.\n\t     */\n\t    for (;;)\n\t    {\n\t\tif (wp->w_next == NULL)\n\t\t    wp = firstwin;\n\t\telse\n\t\t    wp = wp->w_next;\n\t\tif (wp == curwin)\n\t\t    break;\n\t\tif (!wp->w_p_pvw && !bt_quickfix(wp->w_buffer))\n\t\t{\n\t\t    curwin = wp;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n#endif\n\tcurbuf = curwin->w_buffer;\n\tclose_curwin = TRUE;\n\n\t// The cursor position may be invalid if the buffer changed after last\n\t// using the window.\n\tcheck_cursor();\n    }\n    if (p_ea && (*p_ead == 'b' || *p_ead == dir))\n\t// If the frame of the closed window contains the new current window,\n\t// only resize that frame.  Otherwise resize all windows.\n\twin_equal(curwin, curwin->w_frame->fr_parent == win_frame, dir);\n    else\n\twin_comp_pos();\n    if (close_curwin)\n    {\n\t// Pass WEE_ALLOW_PARSE_MESSAGES to decrement dont_parse_messages\n\t// before autocommands.\n#ifdef MESSAGE_QUEUE\n\tdid_decrement =\n#else\n\t(void)\n#endif\n\t    win_enter_ext(wp,\n\t\tWEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS\n\t\t      | WEE_TRIGGER_LEAVE_AUTOCMDS | WEE_ALLOW_PARSE_MESSAGES);\n\tif (other_buffer)\n\t    // careful: after this wp and win may be invalid!\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    --split_disallowed;\n#ifdef MESSAGE_QUEUE\n    if (!did_decrement)\n\t--dont_parse_messages;\n#endif\n\n    /*\n     * If last window has a status line now and we don't want one,\n     * remove the status line.\n     */\n    last_status(FALSE);\n\n    // After closing the help window, try restoring the window layout from\n    // before it was opened.\n    if (help_window)\n\trestore_snapshot(SNAP_HELP_IDX, close_curwin);\n\n#ifdef FEAT_DIFF\n    // If the window had 'diff' set and now there is only one window left in\n    // the tab page with 'diff' set, and \"closeoff\" is in 'diffopt', then\n    // execute \":diffoff!\".\n    if (diffopt_closeoff() && had_diffmode && curtab == prev_curtab)\n    {\n\tint\tdiffcount = 0;\n\twin_T\t*dwin;\n\n\tFOR_ALL_WINDOWS(dwin)\n\t    if (dwin->w_p_diff)\n\t\t++diffcount;\n\tif (diffcount == 1)\n\t    do_cmdline_cmd((char_u *)\"diffoff!\");\n    }\n#endif\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove scrollbars.\n    if (gui.in_use && !win_hasvertsplit())\n\tgui_init_which_components(NULL);\n#endif\n\n    redraw_all_later(NOT_VALID);\n    return OK;\n}\n\n    static void\ntrigger_winclosed(win_T *win)\n{\n    static int\trecursive = FALSE;\n    char_u\twinid[NUMBUFLEN];\n\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n    vim_snprintf((char *)winid, sizeof(winid), \"%i\", win->w_id);\n    apply_autocmds(EVENT_WINCLOSED, winid, winid, FALSE, win->w_buffer);\n    recursive = FALSE;\n}\n\n/*\n * Close window \"win\" in tab page \"tp\", which is not the current tab page.\n * This may be the last window in that tab page and result in closing the tab,\n * thus \"tp\" may become invalid!\n * Caller must check if buffer is hidden and whether the tabline needs to be\n * updated.\n */\n    void\nwin_close_othertab(win_T *win, int free_buf, tabpage_T *tp)\n{\n    win_T\t*wp;\n    int\t\tdir;\n    tabpage_T   *ptp = NULL;\n    int\t\tfree_tp = FALSE;\n\n    // Get here with win->w_buffer == NULL when win_close() detects the tab\n    // page changed.\n    if (win->w_closing || (win->w_buffer != NULL\n\t\t\t\t\t       && win->w_buffer->b_locked > 0))\n\treturn; // window is already being closed\n\n    // Trigger WinClosed just before starting to free window-related resources.\n    trigger_winclosed(win);\n    // autocmd may have freed the window already.\n    if (!win_valid_any_tab(win))\n\treturn;\n\n    if (win->w_buffer != NULL)\n\t// Close the link to the buffer.\n\tclose_buffer(win, win->w_buffer, free_buf ? DOBUF_UNLOAD : 0,\n\t\t\t\t\t\t\t\t FALSE, FALSE);\n\n    // Careful: Autocommands may have closed the tab page or made it the\n    // current tab page.\n    for (ptp = first_tabpage; ptp != NULL && ptp != tp; ptp = ptp->tp_next)\n\t;\n    if (ptp == NULL || tp == curtab)\n\treturn;\n\n    // Autocommands may have closed the window already.\n    for (wp = tp->tp_firstwin; wp != NULL && wp != win; wp = wp->w_next)\n\t;\n    if (wp == NULL)\n\treturn;\n\n    // When closing the last window in a tab page remove the tab page.\n    if (tp->tp_firstwin == tp->tp_lastwin)\n    {\n\tif (tp == first_tabpage)\n\t    first_tabpage = tp->tp_next;\n\telse\n\t{\n\t    for (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tp;\n\t\t\t\t\t\t\t   ptp = ptp->tp_next)\n\t\t;\n\t    if (ptp == NULL)\n\t    {\n\t\tinternal_error(\"win_close_othertab()\");\n\t\treturn;\n\t    }\n\t    ptp->tp_next = tp->tp_next;\n\t}\n\tfree_tp = TRUE;\n    }\n\n    // Free the memory used for the window.\n    win_free_mem(win, &dir, tp);\n\n    if (free_tp)\n\tfree_tabpage(tp);\n}\n\n/*\n * Free the memory used for a window.\n * Returns a pointer to the window that got the freed up space.\n */\n    static win_T *\nwin_free_mem(\n    win_T\t*win,\n    int\t\t*dirp,\t\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    win_T\t*wp;\n    tabpage_T\t*win_tp = tp == NULL ? curtab : tp;\n\n    // Remove the window and its frame from the tree of frames.\n    frp = win->w_frame;\n    wp = winframe_remove(win, dirp, tp);\n    vim_free(frp);\n    win_free(win, tp);\n\n    // When deleting the current window in the tab, select a new current\n    // window.\n    if (win == win_tp->tp_curwin)\n\twin_tp->tp_curwin = wp;\n\n    return wp;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nwin_free_all(void)\n{\n    int\t\tdummy;\n\n    while (first_tabpage->tp_next != NULL)\n\ttabpage_close(TRUE);\n\n    if (aucmd_win != NULL)\n    {\n\t(void)win_free_mem(aucmd_win, &dummy, NULL);\n\taucmd_win = NULL;\n    }\n\n    while (firstwin != NULL)\n\t(void)win_free_mem(firstwin, &dummy, NULL);\n\n    // No window should be used after this. Set curwin to NULL to crash\n    // instead of using freed memory.\n    curwin = NULL;\n}\n#endif\n\n/*\n * Remove a window and its frame from the tree of frames.\n * Returns a pointer to the window that got the freed up space.\n */\n    win_T *\nwinframe_remove(\n    win_T\t*win,\n    int\t\t*dirp UNUSED,\t// set to 'v' or 'h' for direction if 'ea'\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp, *frp2, *frp3;\n    frame_T\t*frp_close = win->w_frame;\n    win_T\t*wp;\n\n    /*\n     * If there is only one window there is nothing to remove.\n     */\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn NULL;\n\n    /*\n     * Remove the window from its frame.\n     */\n    frp2 = win_altframe(win, tp);\n    wp = frame2win(frp2);\n\n    // Remove this frame from the list of frames.\n    frame_remove(frp_close);\n\n    if (frp_close->fr_parent->fr_layout == FR_COL)\n    {\n\t// When 'winfixheight' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the height\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfh)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_height(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfh)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_height(frp2, frp2->fr_height + frp_close->fr_height,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'v';\n    }\n    else\n    {\n\t// When 'winfixwidth' is set, try to find another frame in the column\n\t// (as close to the closed frame as possible) to distribute the width\n\t// to.\n\tif (frp2->fr_win != NULL && frp2->fr_win->w_p_wfw)\n\t{\n\t    frp = frp_close->fr_prev;\n\t    frp3 = frp_close->fr_next;\n\t    while (frp != NULL || frp3 != NULL)\n\t    {\n\t\tif (frp != NULL)\n\t\t{\n\t\t    if (!frame_fixed_width(frp))\n\t\t    {\n\t\t\tfrp2 = frp;\n\t\t\twp = frame2win(frp2);\n\t\t\tbreak;\n\t\t    }\n\t\t    frp = frp->fr_prev;\n\t\t}\n\t\tif (frp3 != NULL)\n\t\t{\n\t\t    if (frp3->fr_win != NULL && !frp3->fr_win->w_p_wfw)\n\t\t    {\n\t\t\tfrp2 = frp3;\n\t\t\twp = frp3->fr_win;\n\t\t\tbreak;\n\t\t    }\n\t\t    frp3 = frp3->fr_next;\n\t\t}\n\t    }\n\t}\n\tframe_new_width(frp2, frp2->fr_width + frp_close->fr_width,\n\t\t\t    frp2 == frp_close->fr_next ? TRUE : FALSE, FALSE);\n\t*dirp = 'h';\n    }\n\n    // If rows/columns go to a window below/right its positions need to be\n    // updated.  Can only be done after the sizes have been updated.\n    if (frp2 == frp_close->fr_next)\n    {\n\tint row = win->w_winrow;\n\tint col = win->w_wincol;\n\n\tframe_comp_pos(frp2, &row, &col);\n    }\n\n    if (frp2->fr_next == NULL && frp2->fr_prev == NULL)\n    {\n\t// There is no other frame in this list, move its info to the parent\n\t// and remove it.\n\tfrp2->fr_parent->fr_layout = frp2->fr_layout;\n\tfrp2->fr_parent->fr_child = frp2->fr_child;\n\tFOR_ALL_FRAMES(frp, frp2->fr_child)\n\t    frp->fr_parent = frp2->fr_parent;\n\tfrp2->fr_parent->fr_win = frp2->fr_win;\n\tif (frp2->fr_win != NULL)\n\t    frp2->fr_win->w_frame = frp2->fr_parent;\n\tfrp = frp2->fr_parent;\n\tif (topframe->fr_child == frp2)\n\t    topframe->fr_child = frp;\n\tvim_free(frp2);\n\n\tfrp2 = frp->fr_parent;\n\tif (frp2 != NULL && frp2->fr_layout == frp->fr_layout)\n\t{\n\t    // The frame above the parent has the same layout, have to merge\n\t    // the frames into this list.\n\t    if (frp2->fr_child == frp)\n\t\tfrp2->fr_child = frp->fr_child;\n\t    frp->fr_child->fr_prev = frp->fr_prev;\n\t    if (frp->fr_prev != NULL)\n\t\tfrp->fr_prev->fr_next = frp->fr_child;\n\t    for (frp3 = frp->fr_child; ; frp3 = frp3->fr_next)\n\t    {\n\t\tfrp3->fr_parent = frp2;\n\t\tif (frp3->fr_next == NULL)\n\t\t{\n\t\t    frp3->fr_next = frp->fr_next;\n\t\t    if (frp->fr_next != NULL)\n\t\t\tfrp->fr_next->fr_prev = frp3;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (topframe->fr_child == frp)\n\t\ttopframe->fr_child = frp2;\n\t    vim_free(frp);\n\t}\n    }\n\n    return wp;\n}\n\n/*\n * Return a pointer to the frame that will receive the empty screen space that\n * is left over after \"win\" is closed.\n *\n * If 'splitbelow' or 'splitright' is set, the space goes above or to the left\n * by default.  Otherwise, the free space goes below or to the right.  The\n * result is that opening a window and then immediately closing it will\n * preserve the initial window layout.  The 'wfh' and 'wfw' settings are\n * respected when possible.\n */\n    static frame_T *\nwin_altframe(\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    frame_T\t*frp;\n    frame_T\t*other_fr, *target_fr;\n\n    if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)\n\treturn alt_tabpage()->tp_curwin->w_frame;\n\n    frp = win->w_frame;\n\n    if (frp->fr_prev == NULL)\n\treturn frp->fr_next;\n    if (frp->fr_next == NULL)\n\treturn frp->fr_prev;\n\n    // By default the next window will get the space that was abandoned by this\n    // window\n    target_fr = frp->fr_next;\n    other_fr  = frp->fr_prev;\n\n    // If this is part of a column of windows and 'splitbelow' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_COL && p_sb)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If this is part of a row of windows, and 'splitright' is true then the\n    // previous window will get the space.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW && p_spr)\n    {\n\ttarget_fr = frp->fr_prev;\n\tother_fr  = frp->fr_next;\n    }\n\n    // If 'wfh' or 'wfw' is set for the target and not for the alternate\n    // window, reverse the selection.\n    if (frp->fr_parent != NULL && frp->fr_parent->fr_layout == FR_ROW)\n    {\n\tif (frame_fixed_width(target_fr) && !frame_fixed_width(other_fr))\n\t    target_fr = other_fr;\n    }\n    else\n    {\n\tif (frame_fixed_height(target_fr) && !frame_fixed_height(other_fr))\n\t    target_fr = other_fr;\n    }\n\n    return target_fr;\n}\n\n/*\n * Return the tabpage that will be used if the current one is closed.\n */\n    static tabpage_T *\nalt_tabpage(void)\n{\n    tabpage_T\t*tp;\n\n    // Use the next tab page if possible.\n    if (curtab->tp_next != NULL)\n\treturn curtab->tp_next;\n\n    // Find the last but one tab page.\n    for (tp = first_tabpage; tp->tp_next != curtab; tp = tp->tp_next)\n\t;\n    return tp;\n}\n\n/*\n * Find the left-upper window in frame \"frp\".\n */\n    static win_T *\nframe2win(frame_T *frp)\n{\n    while (frp->fr_win == NULL)\n\tfrp = frp->fr_child;\n    return frp->fr_win;\n}\n\n/*\n * Return TRUE if frame \"frp\" contains window \"wp\".\n */\n    static int\nframe_has_win(frame_T *frp, win_T *wp)\n{\n    frame_T\t*p;\n\n    if (frp->fr_layout == FR_LEAF)\n\treturn frp->fr_win == wp;\n\n    FOR_ALL_FRAMES(p, frp->fr_child)\n\tif (frame_has_win(p, wp))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Set a new height for a frame.  Recursively sets the height for contained\n * frames and windows.  Caller must take care of positions.\n */\n    static void\nframe_new_height(\n    frame_T\t*topfrp,\n    int\t\theight,\n    int\t\ttopfirst,\t// resize topmost contained frame first\n    int\t\twfh)\t\t// obey 'winfixheight' when there is a choice;\n\t\t\t\t// may cause the height not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_lines;\n    int\t\th;\n\n    if (topfrp->fr_win != NULL)\n    {\n\t// Simple case: just one window.\n\twin_new_height(topfrp->fr_win,\n\t\t\t\t    height - topfrp->fr_win->w_status_height\n\t\t\t\t\t      - WINBAR_HEIGHT(topfrp->fr_win));\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\tdo\n\t{\n\t    // All frames in this row get the same new height.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_height(frp, height, topfirst, wfh);\n\t\tif (frp->fr_height > height)\n\t\t{\n\t\t    // Could not fit the windows, make the whole row higher.\n\t\t    height = frp->fr_height;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\twhile (frp != NULL);\n    }\n    else    // fr_layout == FR_COL\n    {\n\t// Complicated case: Resize a column of frames.  Resize the bottom\n\t// frame first, frames above that when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfh)\n\t    // Advance past frames with one window with 'wfh' set.\n\t    while (frame_fixed_height(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfh', give up\n\t    }\n\tif (!topfirst)\n\t{\n\t    // Find the bottom frame of this column\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfh)\n\t\t// Advance back for frames with one window with 'wfh' set.\n\t\twhile (frame_fixed_height(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_lines = height - topfrp->fr_height;\n\tif (extra_lines < 0)\n\t{\n\t    // reduce height of contained frames, bottom or top frame first\n\t    while (frp != NULL)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (frp->fr_height + extra_lines < h)\n\t\t{\n\t\t    extra_lines += frp->fr_height - h;\n\t\t    frame_new_height(frp, h, topfirst, wfh);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_height(frp, frp->fr_height + extra_lines,\n\t\t\t\t\t\t\t       topfirst, wfh);\n\t\t    break;\n\t\t}\n\t\tif (topfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfh && frp != NULL && frame_fixed_height(frp));\n\t\t}\n\t\t// Increase \"height\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    height -= extra_lines;\n\t    }\n\t}\n\telse if (extra_lines > 0)\n\t{\n\t    // increase height of bottom or top frame\n\t    frame_new_height(frp, frp->fr_height + extra_lines, topfirst, wfh);\n\t}\n    }\n    topfrp->fr_height = height;\n}\n\n/*\n * Return TRUE if height of frame \"frp\" should not be changed because of\n * the 'winfixheight' option.\n */\n    static int\nframe_fixed_height(frame_T *frp)\n{\n    // frame with one window: fixed height if 'winfixheight' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfh;\n\n    if (frp->fr_layout == FR_ROW)\n    {\n\t// The frame is fixed height if one of the frames in the row is fixed\n\t// height.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_height(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_COL: The frame is fixed height if all of the\n    // frames in the row are fixed height.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_height(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Return TRUE if width of frame \"frp\" should not be changed because of\n * the 'winfixwidth' option.\n */\n    static int\nframe_fixed_width(frame_T *frp)\n{\n    // frame with one window: fixed width if 'winfixwidth' set.\n    if (frp->fr_win != NULL)\n\treturn frp->fr_win->w_p_wfw;\n\n    if (frp->fr_layout == FR_COL)\n    {\n\t// The frame is fixed width if one of the frames in the row is fixed\n\t// width.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    if (frame_fixed_width(frp))\n\t\treturn TRUE;\n\treturn FALSE;\n    }\n\n    // frp->fr_layout == FR_ROW: The frame is fixed width if all of the\n    // frames in the row are fixed width.\n    FOR_ALL_FRAMES(frp, frp->fr_child)\n\tif (!frame_fixed_width(frp))\n\t    return FALSE;\n    return TRUE;\n}\n\n/*\n * Add a status line to windows at the bottom of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_statusline(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_status_height == 0)\n\t{\n\t    if (wp->w_height > 0)\t// don't make it negative\n\t\t--wp->w_height;\n\t    wp->w_status_height = STATUS_HEIGHT;\n\t}\n    }\n    else if (frp->fr_layout == FR_ROW)\n    {\n\t// Handle all the frames in the row.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_statusline(frp);\n    }\n    else // frp->fr_layout == FR_COL\n    {\n\t// Only need to handle the last frame in the column.\n\tfor (frp = frp->fr_child; frp->fr_next != NULL; frp = frp->fr_next)\n\t    ;\n\tframe_add_statusline(frp);\n    }\n}\n\n/*\n * Set width of a frame.  Handles recursively going through contained frames.\n * May remove separator line for windows at the right side (for win_close()).\n */\n    static void\nframe_new_width(\n    frame_T\t*topfrp,\n    int\t\twidth,\n    int\t\tleftfirst,\t// resize leftmost contained frame first\n    int\t\twfw)\t\t// obey 'winfixwidth' when there is a choice;\n\t\t\t\t// may cause the width not to be set\n{\n    frame_T\t*frp;\n    int\t\textra_cols;\n    int\t\tw;\n    win_T\t*wp;\n\n    if (topfrp->fr_layout == FR_LEAF)\n    {\n\t// Simple case: just one window.\n\twp = topfrp->fr_win;\n\t// Find out if there are any windows right of this one.\n\tfor (frp = topfrp; frp->fr_parent != NULL; frp = frp->fr_parent)\n\t    if (frp->fr_parent->fr_layout == FR_ROW && frp->fr_next != NULL)\n\t\tbreak;\n\tif (frp->fr_parent == NULL)\n\t    wp->w_vsep_width = 0;\n\twin_new_width(wp, width - wp->w_vsep_width);\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\tdo\n\t{\n\t    // All frames in this column get the same new width.\n\t    FOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    {\n\t\tframe_new_width(frp, width, leftfirst, wfw);\n\t\tif (frp->fr_width > width)\n\t\t{\n\t\t    // Could not fit the windows, make whole column wider.\n\t\t    width = frp->fr_width;\n\t\t    break;\n\t\t}\n\t    }\n\t} while (frp != NULL);\n    }\n    else    // fr_layout == FR_ROW\n    {\n\t// Complicated case: Resize a row of frames.  Resize the rightmost\n\t// frame first, frames left of it when needed.\n\n\tfrp = topfrp->fr_child;\n\tif (wfw)\n\t    // Advance past frames with one window with 'wfw' set.\n\t    while (frame_fixed_width(frp))\n\t    {\n\t\tfrp = frp->fr_next;\n\t\tif (frp == NULL)\n\t\t    return;\t    // no frame without 'wfw', give up\n\t    }\n\tif (!leftfirst)\n\t{\n\t    // Find the rightmost frame of this row\n\t    while (frp->fr_next != NULL)\n\t\tfrp = frp->fr_next;\n\t    if (wfw)\n\t\t// Advance back for frames with one window with 'wfw' set.\n\t\twhile (frame_fixed_width(frp))\n\t\t    frp = frp->fr_prev;\n\t}\n\n\textra_cols = width - topfrp->fr_width;\n\tif (extra_cols < 0)\n\t{\n\t    // reduce frame width, rightmost frame first\n\t    while (frp != NULL)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (frp->fr_width + extra_cols < w)\n\t\t{\n\t\t    extra_cols += frp->fr_width - w;\n\t\t    frame_new_width(frp, w, leftfirst, wfw);\n\t\t}\n\t\telse\n\t\t{\n\t\t    frame_new_width(frp, frp->fr_width + extra_cols,\n\t\t\t\t\t\t\t      leftfirst, wfw);\n\t\t    break;\n\t\t}\n\t\tif (leftfirst)\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_next;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\telse\n\t\t{\n\t\t    do\n\t\t\tfrp = frp->fr_prev;\n\t\t    while (wfw && frp != NULL && frame_fixed_width(frp));\n\t\t}\n\t\t// Increase \"width\" if we could not reduce enough frames.\n\t\tif (frp == NULL)\n\t\t    width -= extra_cols;\n\t    }\n\t}\n\telse if (extra_cols > 0)\n\t{\n\t    // increase width of rightmost frame\n\t    frame_new_width(frp, frp->fr_width + extra_cols, leftfirst, wfw);\n\t}\n    }\n    topfrp->fr_width = width;\n}\n\n/*\n * Add the vertical separator to windows at the right side of \"frp\".\n * Note: Does not check if there is room!\n */\n    static void\nframe_add_vsep(frame_T *frp)\n{\n    win_T\t*wp;\n\n    if (frp->fr_layout == FR_LEAF)\n    {\n\twp = frp->fr_win;\n\tif (wp->w_vsep_width == 0)\n\t{\n\t    if (wp->w_width > 0)\t// don't make it negative\n\t\t--wp->w_width;\n\t    wp->w_vsep_width = 1;\n\t}\n    }\n    else if (frp->fr_layout == FR_COL)\n    {\n\t// Handle all the frames in the column.\n\tFOR_ALL_FRAMES(frp, frp->fr_child)\n\t    frame_add_vsep(frp);\n    }\n    else // frp->fr_layout == FR_ROW\n    {\n\t// Only need to handle the last frame in the row.\n\tfrp = frp->fr_child;\n\twhile (frp->fr_next != NULL)\n\t    frp = frp->fr_next;\n\tframe_add_vsep(frp);\n    }\n}\n\n/*\n * Set frame width from the window it contains.\n */\n    static void\nframe_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}\n\n/*\n * Set frame height from the window it contains.\n */\n    static void\nframe_fix_height(win_T *wp)\n{\n    wp->w_frame->fr_height = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n}\n\n/*\n * Compute the minimal height for frame \"topfrp\".\n * Uses the 'winminheight' option.\n * When \"next_curwin\" isn't NULL, use p_wh for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one line for the current\n * window.\n */\n    static int\nframe_minheight(frame_T *topfrp, win_T *next_curwin)\n{\n    frame_T\t*frp;\n    int\t\tm;\n    int\t\tn;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wh + topfrp->fr_win->w_status_height;\n\telse\n\t{\n\t    // window: minimal height of the window plus status line\n\t    m = p_wmh + topfrp->fr_win->w_status_height;\n\t    if (topfrp->fr_win == curwin && next_curwin == NULL)\n\t    {\n\t\t// Current window is minimal one line high and WinBar is\n\t\t// visible.\n\t\tif (p_wmh == 0)\n\t\t    ++m;\n\t\tm += WINBAR_HEIGHT(curwin);\n\t    }\n\t}\n    }\n    else if (topfrp->fr_layout == FR_ROW)\n    {\n\t// get the minimal height from each frame in this row\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minheight(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal heights for all frames in this column.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minheight(frp, next_curwin);\n    }\n\n    return m;\n}\n\n/*\n * Compute the minimal width for frame \"topfrp\".\n * When \"next_curwin\" isn't NULL, use p_wiw for this window.\n * When \"next_curwin\" is NOWIN, don't use at least one column for the current\n * window.\n */\n    static int\nframe_minwidth(\n    frame_T\t*topfrp,\n    win_T\t*next_curwin)\t// use p_wh and p_wiw for next_curwin\n{\n    frame_T\t*frp;\n    int\t\tm, n;\n\n    if (topfrp->fr_win != NULL)\n    {\n\tif (topfrp->fr_win == next_curwin)\n\t    m = p_wiw + topfrp->fr_win->w_vsep_width;\n\telse\n\t{\n\t    // window: minimal width of the window plus separator column\n\t    m = p_wmw + topfrp->fr_win->w_vsep_width;\n\t    // Current window is minimal one column wide\n\t    if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL)\n\t\t++m;\n\t}\n    }\n    else if (topfrp->fr_layout == FR_COL)\n    {\n\t// get the minimal width from each frame in this column\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    n = frame_minwidth(frp, next_curwin);\n\t    if (n > m)\n\t\tm = n;\n\t}\n    }\n    else\n    {\n\t// Add up the minimal widths for all frames in this row.\n\tm = 0;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    m += frame_minwidth(frp, next_curwin);\n    }\n\n    return m;\n}\n\n\n/*\n * Try to close all windows except current one.\n * Buffers in the other windows become hidden if 'hidden' is set, or '!' is\n * used and the buffer was modified.\n *\n * Used by \":bdel\" and \":only\".\n */\n    void\nclose_others(\n    int\t\tmessage,\n    int\t\tforceit)\t    // always hide all other windows\n{\n    win_T\t*wp;\n    win_T\t*nextwp;\n    int\t\tr;\n\n    if (one_window())\n    {\n\tif (message && !autocmd_busy)\n\t    msg(_(m_onlyone));\n\treturn;\n    }\n\n    // Be very careful here: autocommands may change the window layout.\n    for (wp = firstwin; win_valid(wp); wp = nextwp)\n    {\n\tnextwp = wp->w_next;\n\tif (wp != curwin)\t\t// don't close current window\n\t{\n\n\t    // Check if it's allowed to abandon this window\n\t    r = can_abandon(wp->w_buffer, forceit);\n\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t    {\n\t\tnextwp = firstwin;\n\t\tcontinue;\n\t    }\n\t    if (!r)\n\t    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t\tif (message && (p_confirm\n\t\t\t     || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t\t{\n\t\t    dialog_changed(wp->w_buffer, FALSE);\n\t\t    if (!win_valid(wp))\t\t// autocommands messed wp up\n\t\t    {\n\t\t\tnextwp = firstwin;\n\t\t\tcontinue;\n\t\t    }\n\t\t}\n\t\tif (bufIsChanged(wp->w_buffer))\n#endif\n\t\t    continue;\n\t    }\n\t    win_close(wp, !buf_hide(wp->w_buffer)\n\t\t\t\t\t       && !bufIsChanged(wp->w_buffer));\n\t}\n    }\n\n    if (message && !ONE_WINDOW)\n\temsg(_(e_other_window_contains_changes));\n}\n\n    static void\nwin_init_empty(win_T *wp)\n{\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_lines_valid = 0;\n    wp->w_cursor.lnum = 1;\n    wp->w_curswant = wp->w_cursor.col = 0;\n    wp->w_cursor.coladd = 0;\n    wp->w_pcmark.lnum = 1;\t// pcmark not cleared but set to line 1\n    wp->w_pcmark.col = 0;\n    wp->w_prev_pcmark.lnum = 0;\n    wp->w_prev_pcmark.col = 0;\n    wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    wp->w_topfill = 0;\n#endif\n    wp->w_botline = 2;\n#if defined(FEAT_SYN_HL) || defined(FEAT_SPELL)\n    wp->w_s = &wp->w_buffer->b_s;\n#endif\n#ifdef FEAT_TERMINAL\n    term_reset_wincolor(wp);\n#endif\n}\n\n/*\n * Init the current window \"curwin\".\n * Called when a new file is being edited.\n */\n    void\ncurwin_init(void)\n{\n    win_init_empty(curwin);\n}\n\n/*\n * Allocate the first window and put an empty buffer in it.\n * Called from main().\n * Return FAIL when something goes wrong (out of memory).\n */\n    int\nwin_alloc_first(void)\n{\n    if (win_alloc_firstwin(NULL) == FAIL)\n\treturn FAIL;\n\n    first_tabpage = alloc_tabpage();\n    if (first_tabpage == NULL)\n\treturn FAIL;\n    first_tabpage->tp_topframe = topframe;\n    curtab = first_tabpage;\n    curtab->tp_firstwin = firstwin;\n    curtab->tp_lastwin = lastwin;\n    curtab->tp_curwin = curwin;\n\n    return OK;\n}\n\n/*\n * Allocate and init a window that is not a regular window.\n * This can only be done after the first window is fully initialized, thus it\n * can't be in win_alloc_first().\n */\n    win_T *\nwin_alloc_popup_win(void)\n{\n    win_T *wp;\n\n    wp = win_alloc(NULL, TRUE);\n    if (wp != NULL)\n    {\n\t// We need to initialize options with something, using the current\n\t// window makes most sense.\n\twin_init_some(wp, curwin);\n\n\tRESET_BINDING(wp);\n\tnew_frame(wp);\n    }\n    return wp;\n}\n\n/*\n * Initialize window \"wp\" to display buffer \"buf\".\n */\n    void\nwin_init_popup_win(win_T *wp, buf_T *buf)\n{\n    wp->w_buffer = buf;\n    ++buf->b_nwindows;\n    win_init_empty(wp); // set cursor and topline to safe values\n\n    // Make sure w_localdir and globaldir are NULL to avoid a chdir() in\n    // win_enter_ext().\n    VIM_CLEAR(wp->w_localdir);\n}\n\n/*\n * Allocate the first window or the first window in a new tab page.\n * When \"oldwin\" is NULL create an empty buffer for it.\n * When \"oldwin\" is not NULL copy info from it to the new window.\n * Return FAIL when something goes wrong (out of memory).\n */\n    static int\nwin_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (oldwin == NULL)\n    {\n\t// Very first window, need to create an empty buffer for it and\n\t// initialize from scratch.\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t// there is one window\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t// init current window\n    }\n    else\n    {\n\t// First window in new tab page, initialize it from \"oldwin\".\n\twin_init(curwin, oldwin, 0);\n\n\t// We don't want cursor- and scroll-binding in the first window.\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}\n\n/*\n * Create a frame for window \"wp\".\n */\n    static void\nnew_frame(win_T *wp)\n{\n    frame_T *frp = ALLOC_CLEAR_ONE(frame_T);\n\n    wp->w_frame = frp;\n    if (frp != NULL)\n    {\n\tfrp->fr_layout = FR_LEAF;\n\tfrp->fr_win = wp;\n    }\n}\n\n/*\n * Initialize the window and frame size to the maximum.\n */\n    void\nwin_init_size(void)\n{\n    firstwin->w_height = ROWS_AVAIL;\n    topframe->fr_height = ROWS_AVAIL;\n    firstwin->w_width = Columns;\n    topframe->fr_width = Columns;\n}\n\n/*\n * Allocate a new tabpage_T and init the values.\n * Returns NULL when out of memory.\n */\n    static tabpage_T *\nalloc_tabpage(void)\n{\n    tabpage_T\t*tp;\n# ifdef FEAT_GUI\n    int\t\ti;\n# endif\n\n\n    tp = ALLOC_CLEAR_ONE(tabpage_T);\n    if (tp == NULL)\n\treturn NULL;\n\n# ifdef FEAT_EVAL\n    // init t: variables\n    tp->tp_vars = dict_alloc();\n    if (tp->tp_vars == NULL)\n    {\n\tvim_free(tp);\n\treturn NULL;\n    }\n    init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);\n# endif\n\n# ifdef FEAT_GUI\n    for (i = 0; i < 3; i++)\n\ttp->tp_prev_which_scrollbars[i] = -1;\n# endif\n# ifdef FEAT_DIFF\n    tp->tp_diff_invalid = TRUE;\n# endif\n    tp->tp_ch_used = p_ch;\n\n    return tp;\n}\n\n    void\nfree_tabpage(tabpage_T *tp)\n{\n    int idx;\n\n# ifdef FEAT_DIFF\n    diff_clear(tp);\n# endif\n# ifdef FEAT_PROP_POPUP\n    while (tp->tp_first_popupwin != NULL)\n\tpopup_close_tabpage(tp, tp->tp_first_popupwin->w_id, TRUE);\n#endif\n    for (idx = 0; idx < SNAP_COUNT; ++idx)\n\tclear_snapshot(tp, idx);\n#ifdef FEAT_EVAL\n    vars_clear(&tp->tp_vars->dv_hashtab);\t// free all t: variables\n    hash_init(&tp->tp_vars->dv_hashtab);\n    unref_var_dict(tp->tp_vars);\n#endif\n\n    if (tp == lastused_tabpage)\n\tlastused_tabpage = NULL;\n\n    vim_free(tp->tp_localdir);\n    vim_free(tp->tp_prevdir);\n\n#ifdef FEAT_PYTHON\n    python_tabpage_free(tp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_tabpage_free(tp);\n#endif\n\n    vim_free(tp);\n}\n\n/*\n * Create a new Tab page with one window.\n * It will edit the current buffer, like after \":split\".\n * When \"after\" is 0 put it just after the current Tab page.\n * Otherwise put it just before tab page \"after\".\n * Return FAIL or OK.\n */\n    int\nwin_new_tabpage(int after)\n{\n    tabpage_T\t*tp = curtab;\n    tabpage_T\t*prev_tp = curtab;\n    tabpage_T\t*newtp;\n    int\t\tn;\n\n#ifdef FEAT_CMDWIN\n    if (cmdwin_type != 0)\n    {\n\temsg(_(e_invalid_in_cmdline_window));\n\treturn FAIL;\n    }\n#endif\n\n    newtp = alloc_tabpage();\n    if (newtp == NULL)\n\treturn FAIL;\n\n    // Remember the current windows in this Tab page.\n    if (leave_tabpage(curbuf, TRUE) == FAIL)\n    {\n\tvim_free(newtp);\n\treturn FAIL;\n    }\n    curtab = newtp;\n\n    newtp->tp_localdir = (tp->tp_localdir == NULL)\n\t\t\t\t    ? NULL : vim_strsave(tp->tp_localdir);\n    // Create a new empty window.\n    if (win_alloc_firstwin(tp->tp_curwin) == OK)\n    {\n\t// Make the new Tab page the new topframe.\n\tif (after == 1)\n\t{\n\t    // New tab page becomes the first one.\n\t    newtp->tp_next = first_tabpage;\n\t    first_tabpage = newtp;\n\t}\n\telse\n\t{\n\t    if (after > 0)\n\t    {\n\t\t// Put new tab page before tab page \"after\".\n\t\tn = 2;\n\t\tfor (tp = first_tabpage; tp->tp_next != NULL\n\t\t\t\t\t       && n < after; tp = tp->tp_next)\n\t\t    ++n;\n\t    }\n\t    newtp->tp_next = tp->tp_next;\n\t    tp->tp_next = newtp;\n\t}\n\tnewtp->tp_firstwin = newtp->tp_lastwin = newtp->tp_curwin = curwin;\n\n\twin_init_size();\n\tfirstwin->w_winrow = tabline_height();\n\twin_comp_scroll(curwin);\n\n\tnewtp->tp_topframe = topframe;\n\tlast_status(FALSE);\n\n\tlastused_tabpage = prev_tp;\n\n#if defined(FEAT_GUI)\n\t// When 'guioptions' includes 'L' or 'R' may have to remove or add\n\t// scrollbars.  Have to update them anyway.\n\tgui_may_update_scrollbars();\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\tentering_window(curwin);\n#endif\n\n\tredraw_all_later(NOT_VALID);\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABNEW, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\treturn OK;\n    }\n\n    // Failed, get back the previous Tab page\n    enter_tabpage(curtab, curbuf, TRUE, TRUE);\n    return FAIL;\n}\n\n/*\n * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,\n * like with \":split\".\n * Returns OK if a new tab page was created, FAIL otherwise.\n */\n    static int\nmay_open_tabpage(void)\n{\n    int\t\tn = (cmdmod.cmod_tab == 0)\n\t\t\t\t       ? postponed_split_tab : cmdmod.cmod_tab;\n\n    if (n != 0)\n    {\n\tcmdmod.cmod_tab = 0;\t    // reset it to avoid doing it twice\n\tpostponed_split_tab = 0;\n\treturn win_new_tabpage(n);\n    }\n    return FAIL;\n}\n\n/*\n * Create up to \"maxcount\" tabpages with empty windows.\n * Returns the number of resulting tab pages.\n */\n    int\nmake_tabpages(int maxcount)\n{\n    int\t\tcount = maxcount;\n    int\t\ttodo;\n\n    // Limit to 'tabpagemax' tabs.\n    if (count > p_tpm)\n\tcount = p_tpm;\n\n    /*\n     * Don't execute autocommands while creating the tab pages.  Must do that\n     * when putting the buffers in the windows.\n     */\n    block_autocmds();\n\n    for (todo = count - 1; todo > 0; --todo)\n\tif (win_new_tabpage(0) == FAIL)\n\t    break;\n\n    unblock_autocmds();\n\n    // return actual number of tab pages\n    return (count - todo);\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page.\n */\n    int\nvalid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Return TRUE when \"tpc\" points to a valid tab page and at least one window is\n * valid.\n */\n    int\nvalid_tabpage_win(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\tif (tp == tpc)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t    {\n\t\tif (win_valid_any_tab(wp))\n\t\t    return TRUE;\n\t    }\n\t    return FALSE;\n\t}\n    }\n    // shouldn't happen\n    return FALSE;\n}\n\n/*\n * Close tabpage \"tab\", assuming it has no windows in it.\n * There must be another tabpage or this will crash.\n */\n    void\nclose_tabpage(tabpage_T *tab)\n{\n    tabpage_T\t*ptp;\n\n    if (tab == first_tabpage)\n    {\n\tfirst_tabpage = tab->tp_next;\n\tptp = first_tabpage;\n    }\n    else\n    {\n\tfor (ptp = first_tabpage; ptp != NULL && ptp->tp_next != tab;\n\t\t\t\t\t\t\t    ptp = ptp->tp_next)\n\t    ;\n\tassert(ptp != NULL);\n\tptp->tp_next = tab->tp_next;\n    }\n\n    goto_tabpage_tp(ptp, FALSE, FALSE);\n    free_tabpage(tab);\n}\n\n/*\n * Find tab page \"n\" (first one is 1).  Returns NULL when not found.\n */\n    tabpage_T *\nfind_tabpage(int n)\n{\n    tabpage_T\t*tp;\n    int\t\ti = 1;\n\n    if (n == 0)\n\treturn curtab;\n\n    for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next)\n\t++i;\n    return tp;\n}\n\n/*\n * Get index of tab page \"tp\".  First one has index 1.\n * When not found returns number of tab pages plus one.\n */\n    int\ntabpage_index(tabpage_T *ftp)\n{\n    int\t\ti = 1;\n    tabpage_T\t*tp;\n\n    for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next)\n\t++i;\n    return i;\n}\n\n/*\n * Prepare for leaving the current tab page.\n * When autocommands change \"curtab\" we don't leave the tab page and return\n * FAIL.\n * Careful: When OK is returned need to get a new tab page very very soon!\n */\n    static int\nleave_tabpage(\n    buf_T\t*new_curbuf UNUSED,    // what is going to be the new curbuf,\n\t\t\t\t       // NULL if unknown\n    int\t\ttrigger_leave_autocmds UNUSED)\n{\n    tabpage_T\t*tp = curtab;\n\n#ifdef FEAT_JOB_CHANNEL\n    leaving_window(curwin);\n#endif\n    reset_VIsual_and_resel();\t// stop Visual mode\n    if (trigger_leave_autocmds)\n    {\n\tif (new_curbuf != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    if (curtab != tp)\n\t\treturn FAIL;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n\tapply_autocmds(EVENT_TABLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (curtab != tp)\n\t    return FAIL;\n    }\n#if defined(FEAT_GUI)\n    // Remove the scrollbars.  They may be added back later.\n    if (gui.in_use)\n\tgui_remove_scrollbars();\n#endif\n    tp->tp_curwin = curwin;\n    tp->tp_prevwin = prevwin;\n    tp->tp_firstwin = firstwin;\n    tp->tp_lastwin = lastwin;\n    tp->tp_old_Rows = Rows;\n    if (tp->tp_old_Columns != -1)\n\ttp->tp_old_Columns = Columns;\n    firstwin = NULL;\n    lastwin = NULL;\n    return OK;\n}\n\n/*\n * Start using tab page \"tp\".\n * Only to be used after leave_tabpage() or freeing the current tab page.\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n */\n    static void\nenter_tabpage(\n    tabpage_T\t*tp,\n    buf_T\t*old_curbuf UNUSED,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    int\t\trow;\n    int\t\told_off = tp->tp_firstwin->w_winrow;\n    win_T\t*next_prevwin = tp->tp_prevwin;\n    tabpage_T\t*last_tab = curtab;\n\n    curtab = tp;\n    firstwin = tp->tp_firstwin;\n    lastwin = tp->tp_lastwin;\n    topframe = tp->tp_topframe;\n\n    // We would like doing the TabEnter event first, but we don't have a\n    // valid current window yet, which may break some commands.\n    // This triggers autocommands, thus may make \"tp\" invalid.\n    (void)win_enter_ext(tp->tp_curwin, WEE_CURWIN_INVALID\n\t\t  | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)\n\t\t  | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));\n    prevwin = next_prevwin;\n\n    last_status(FALSE);\t\t// status line may appear or disappear\n    row = win_comp_pos();\t// recompute w_winrow for all windows\n#ifdef FEAT_DIFF\n    diff_need_scrollbind = TRUE;\n#endif\n\n    // The tabpage line may have appeared or disappeared, may need to resize\n    // the frames for that.  When the Vim window was resized need to update\n    // frame sizes too.  Use the stored value of p_ch, so that it can be\n    // different for each tab page.\n    if (p_ch != curtab->tp_ch_used)\n\tclear_cmdline = TRUE;\n    p_ch = curtab->tp_ch_used;\n\n    // When cmdheight is changed in a tab page with '<C-w>-', cmdline_row is\n    // changed but p_ch and tp_ch_used are not changed. Thus we also need to\n    // check cmdline_row.\n    if ((row < cmdline_row) && (cmdline_row <= Rows - p_ch))\n\tclear_cmdline = TRUE;\n\n    if (curtab->tp_old_Rows != Rows || (old_off != firstwin->w_winrow\n#ifdef FEAT_GUI_TABLINE\n\t\t\t    && !gui_use_tabline()\n#endif\n\t\t))\n\tshell_new_rows();\n    if (curtab->tp_old_Columns != Columns)\n    {\n\tif (starting == 0)\n\t{\n\t    shell_new_columns();\t// update window widths\n\t    curtab->tp_old_Columns = Columns;\n\t}\n\telse\n\t    curtab->tp_old_Columns = -1;  // update window widths later\n    }\n\n    lastused_tabpage = last_tab;\n\n#if defined(FEAT_GUI)\n    // When 'guioptions' includes 'L' or 'R' may have to remove or add\n    // scrollbars.  Have to update them anyway.\n    gui_may_update_scrollbars();\n#endif\n\n    // Apply autocommands after updating the display, when 'rows' and\n    // 'columns' have been set correctly.\n    if (trigger_enter_autocmds)\n    {\n\tapply_autocmds(EVENT_TABENTER, NULL, NULL, FALSE, curbuf);\n\tif (old_curbuf != curbuf)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Go to tab page \"n\".  For \":tab N\" and \"Ngt\".\n * When \"n\" is 9999 go to the last tab page.\n */\n    void\ngoto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  // shut up compiler\n    tabpage_T\t*ttp;\n    int\t\ti;\n\n    if (text_locked())\n    {\n\t// Not allowed when editing the command line.\n\ttext_locked_msg();\n\treturn;\n    }\n    CHECK_CMDWIN;\n\n    // If there is only one it can't work.\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n\n    if (n == 0)\n    {\n\t// No count, go to next tab page, wrap around end.\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\t// \"gT\": go to previous tab page, wrap around end.  \"N gT\" repeats\n\t// this N times.\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\t// Go to last tab page.\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\t// Go to tab page \"n\".\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n\n    goto_tabpage_tp(tp, TRUE, TRUE);\n\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}\n\n/*\n * Go to tabpage \"tp\".\n * Only trigger *Enter autocommands when trigger_enter_autocmds is TRUE.\n * Only trigger *Leave autocommands when trigger_leave_autocmds is TRUE.\n * Note: doesn't update the GUI tab.\n */\n    void\ngoto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    CHECK_CMDWIN;\n\n    // Don't repeat a message in another tab page.\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}\n\n/*\n * Go to the last accessed tab page, if there is one.\n * Return OK or FAIL\n */\n    int\ngoto_tabpage_lastused(void)\n{\n    if (valid_tabpage(lastused_tabpage))\n    {\n\tgoto_tabpage_tp(lastused_tabpage, TRUE, TRUE);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Enter window \"wp\" in tab page \"tp\".\n * Also updates the GUI tab.\n */\n    void\ngoto_tabpage_win(tabpage_T *tp, win_T *wp)\n{\n    goto_tabpage_tp(tp, TRUE, TRUE);\n    if (curtab == tp && win_valid(wp))\n    {\n\twin_enter(wp, TRUE);\n# ifdef FEAT_GUI_TABLINE\n\tif (gui_use_tabline())\n\t    gui_mch_set_curtab(tabpage_index(curtab));\n# endif\n    }\n}\n\n/*\n * Move the current tab page to after tab page \"nr\".\n */\n    void\ntabpage_move(int nr)\n{\n    int\t\tn = 1;\n    tabpage_T\t*tp, *tp_dst;\n\n    if (first_tabpage->tp_next == NULL)\n\treturn;\n\n    for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next)\n\t++n;\n\n    if (tp == curtab || (nr > 0 && tp->tp_next != NULL\n\t\t\t\t\t\t    && tp->tp_next == curtab))\n\treturn;\n\n    tp_dst = tp;\n\n    // Remove the current tab page from the list of tab pages.\n    if (curtab == first_tabpage)\n\tfirst_tabpage = curtab->tp_next;\n    else\n    {\n\tFOR_ALL_TABPAGES(tp)\n\t    if (tp->tp_next == curtab)\n\t\tbreak;\n\tif (tp == NULL)\t// \"cannot happen\"\n\t    return;\n\ttp->tp_next = curtab->tp_next;\n    }\n\n    // Re-insert it at the specified position.\n    if (nr <= 0)\n    {\n\tcurtab->tp_next = first_tabpage;\n\tfirst_tabpage = curtab;\n    }\n    else\n    {\n\tcurtab->tp_next = tp_dst->tp_next;\n\ttp_dst->tp_next = curtab;\n    }\n\n    // Need to redraw the tabline.  Tab page contents doesn't change.\n    redraw_tabline = TRUE;\n}\n\n\n/*\n * Go to another window.\n * When jumping to another buffer, stop Visual mode.  Do this before\n * changing windows so we can yank the selection into the '*' register.\n * When jumping to another window on the same buffer, adjust its cursor\n * position to keep the same Visual area.\n */\n    void\nwin_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_and_win_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    // Conceal cursor line in previous window, unconceal in current window.\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}\n\n#if defined(FEAT_PERL) || defined(PROTO)\n/*\n * Find window number \"winnr\" (counting top to bottom).\n */\n    win_T *\nwin_find_nr(int winnr)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (--winnr == 0)\n\t    break;\n    return wp;\n}\n#endif\n\n#if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)\n/*\n * Find the tabpage for window \"win\".\n */\n    tabpage_T *\nwin_find_tabpage(win_T *win)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t    if (wp == win)\n\t\treturn tp;\n    return NULL;\n}\n#endif\n\n/*\n * Get the above or below neighbor window of the specified window.\n *   up - TRUE for the above neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a upwards or\n\t * downwards neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the bottom or top frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to window above or below \"count\" times.\n */\n    static void\nwin_goto_ver(\n    int\t\tup,\t\t// TRUE to go to win above\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_vert_neighbor(curtab, curwin, up, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Get the left or right neighbor window of the specified window.\n *   left - TRUE for the left neighbor\n *   count - nth neighbor window\n * Returns the specified window if the neighbor is not found.\n */\n    win_T *\nwin_horz_neighbor(tabpage_T *tp, win_T *wp, int left, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n\n#ifdef FEAT_PROP_POPUP\n    if (popup_is_popup(wp))\n\t// popups don't have neighbors.\n\treturn NULL;\n#endif\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\t/*\n\t * First go upwards in the tree of frames until we find a left or\n\t * right neighbor.\n\t */\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (left)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_ROW && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\n\t/*\n\t * Now go downwards to find the leftmost or rightmost frame in it.\n\t */\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_COL)\n\t    {\n\t\t// Find the frame at the cursor row.\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_winrow + fr->fr_height\n\t\t\t\t\t <= wp->w_winrow + wp->w_wrow)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_ROW && left)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}\n\n/*\n * Move to left or right window.\n */\n    static void\nwin_goto_hor(\n    int\t\tleft,\t\t// TRUE to go to left win\n    long\tcount)\n{\n    win_T\t*win;\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n    win = win_horz_neighbor(curtab, curwin, left, count);\n    if (win != NULL)\n\twin_goto(win);\n}\n\n/*\n * Make window \"wp\" the current window.\n */\n    void\nwin_enter(win_T *wp, int undo_sync)\n{\n    (void)win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)\n\t\t    | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);\n}\n\n/*\n * Used after making another window the current one: change directory if\n * needed.\n */\n    static void\nfix_current_dir(void)\n{\n#ifdef FEAT_AUTOCHDIR\n    if (p_acd)\n\tdo_autochdir();\n    else\n#endif\n    if (curwin->w_localdir != NULL || curtab->tp_localdir != NULL)\n    {\n\tchar_u\t*dirname;\n\n\t// Window or tab has a local directory: Save current directory as\n\t// global directory (unless that was done already) and change to the\n\t// local directory.\n\tif (globaldir == NULL)\n\t{\n\t    char_u\tcwd[MAXPATHL];\n\n\t    if (mch_dirname(cwd, MAXPATHL) == OK)\n\t\tglobaldir = vim_strsave(cwd);\n\t}\n\tif (curwin->w_localdir != NULL)\n\t    dirname = curwin->w_localdir;\n\telse\n\t    dirname = curtab->tp_localdir;\n\n\tif (mch_chdir((char *)dirname) == 0)\n\t{\n\t    last_chdir_reason = NULL;\n\t    shorten_fnames(TRUE);\n\t}\n    }\n    else if (globaldir != NULL)\n    {\n\t// Window doesn't have a local directory and we are not in the global\n\t// directory: Change to the global directory.\n\tvim_ignored = mch_chdir((char *)globaldir);\n\tVIM_CLEAR(globaldir);\n\tlast_chdir_reason = NULL;\n\tshorten_fnames(TRUE);\n    }\n}\n\n/*\n * Make window \"wp\" the current window.\n * Can be called with \"flags\" containing WEE_CURWIN_INVALID, which means that\n * curwin has just been closed and isn't valid.\n * Returns TRUE when dont_parse_messages was decremented.\n */\n    static int\nwin_enter_ext(win_T *wp, int flags)\n{\n    int\t\tother_buffer = FALSE;\n    int\t\tcurwin_invalid = (flags & WEE_CURWIN_INVALID);\n    int\t\tdid_decrement = FALSE;\n\n    if (wp == curwin && !curwin_invalid)\t// nothing to do\n\treturn FALSE;\n\n#ifdef FEAT_JOB_CHANNEL\n    if (!curwin_invalid)\n\tleaving_window(curwin);\n#endif\n\n    if (!curwin_invalid && (flags & WEE_TRIGGER_LEAVE_AUTOCMDS))\n    {\n\t/*\n\t * Be careful: If autocommands delete the window, return now.\n\t */\n\tif (wp->w_buffer != curbuf)\n\t{\n\t    apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf);\n\t    other_buffer = TRUE;\n\t    if (!win_valid(wp))\n\t\treturn FALSE;\n\t}\n\tapply_autocmds(EVENT_WINLEAVE, NULL, NULL, FALSE, curbuf);\n\tif (!win_valid(wp))\n\t    return FALSE;\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // sync undo before leaving the current buffer\n    if ((flags & WEE_UNDO_SYNC) && curbuf != wp->w_buffer)\n\tu_sync(FALSE);\n\n    // Might need to scroll the old window before switching, e.g., when the\n    // cursor was moved.\n    update_topline();\n\n    // may have to copy the buffer options when 'cpo' contains 'S'\n    if (wp->w_buffer != curbuf)\n\tbuf_copy_options(wp->w_buffer, BCO_ENTER | BCO_NOHELP);\n    if (!curwin_invalid)\n    {\n\tprevwin = curwin;\t// remember for CTRL-W p\n\tcurwin->w_redr_status = TRUE;\n    }\n    curwin = wp;\n    curbuf = wp->w_buffer;\n    check_cursor();\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    changed_line_abv_curs();\t// assume cursor position needs updating\n\n    // Now it is OK to parse messages again, which may be needed in\n    // autocommands.\n#ifdef MESSAGE_QUEUE\n    if (flags & WEE_ALLOW_PARSE_MESSAGES)\n    {\n\t--dont_parse_messages;\n\tdid_decrement = TRUE;\n    }\n#endif\n\n    fix_current_dir();\n\n#ifdef FEAT_JOB_CHANNEL\n    entering_window(curwin);\n#endif\n    // Careful: autocommands may close the window and make \"wp\" invalid\n    if (flags & WEE_TRIGGER_NEW_AUTOCMDS)\n\tapply_autocmds(EVENT_WINNEW, NULL, NULL, FALSE, curbuf);\n    if (flags & WEE_TRIGGER_ENTER_AUTOCMDS)\n    {\n\tapply_autocmds(EVENT_WINENTER, NULL, NULL, FALSE, curbuf);\n\tif (other_buffer)\n\t    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    maketitle();\n    curwin->w_redr_status = TRUE;\n#ifdef FEAT_TERMINAL\n    if (bt_terminal(curwin->w_buffer))\n\t// terminal is likely in another mode\n\tredraw_mode = TRUE;\n#endif\n    redraw_tabline = TRUE;\n    if (restart_edit)\n\tredraw_later(VALID);\t// causes status line redraw\n\n    // set window height to desired minimal value\n    if (curwin->w_height < p_wh && !curwin->w_p_wfh\n#ifdef FEAT_PROP_POPUP\n\t    && !popup_is_popup(curwin)\n#endif\n\t    )\n\twin_setheight((int)p_wh);\n    else if (curwin->w_height == 0)\n\twin_setheight(1);\n\n    // set window width to desired minimal value\n    if (curwin->w_width < p_wiw && !curwin->w_p_wfw)\n\twin_setwidth((int)p_wiw);\n\n    setmouse();\t\t\t// in case jumped to/from help buffer\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n    return did_decrement;\n}\n\n/*\n * Jump to the first open window that contains buffer \"buf\", if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_win(buf_T *buf)\n{\n    win_T\t*wp = NULL;\n\n    if (curwin->w_buffer == buf)\n\twp = curwin;\n    else\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t\tbreak;\n    if (wp != NULL)\n\twin_enter(wp, FALSE);\n    return wp;\n}\n\n/*\n * Jump to the first open window in any tab page that contains buffer \"buf\",\n * if one exists.\n * Returns a pointer to the window found, otherwise NULL.\n */\n    win_T *\nbuf_jump_open_tab(buf_T *buf)\n{\n    win_T\t*wp = buf_jump_open_win(buf);\n    tabpage_T\t*tp;\n\n    if (wp != NULL)\n\treturn wp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp != curtab)\n\t{\n\t    FOR_ALL_WINDOWS_IN_TAB(tp, wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    if (wp != NULL)\n\t    {\n\t\tgoto_tabpage_win(tp, wp);\n\t\tif (curwin != wp)\n\t\t    wp = NULL;\t// something went wrong\n\t\tbreak;\n\t    }\n\t}\n    return wp;\n}\n\nstatic int last_win_id = LOWEST_WIN_ID - 1;\n\n/*\n * Allocate a window structure and link it in the window list when \"hidden\" is\n * FALSE.\n */\n    static win_T *\nwin_alloc(win_T *after UNUSED, int hidden UNUSED)\n{\n    win_T\t*new_wp;\n\n    /*\n     * allocate window structure and linesizes arrays\n     */\n    new_wp = ALLOC_CLEAR_ONE(win_T);\n    if (new_wp == NULL)\n\treturn NULL;\n\n    if (win_alloc_lines(new_wp) == FAIL)\n    {\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n\n    new_wp->w_id = ++last_win_id;\n\n#ifdef FEAT_EVAL\n    // init w: variables\n    new_wp->w_vars = dict_alloc();\n    if (new_wp->w_vars == NULL)\n    {\n\twin_free_lsize(new_wp);\n\tvim_free(new_wp);\n\treturn NULL;\n    }\n    init_var_dict(new_wp->w_vars, &new_wp->w_winvar, VAR_SCOPE);\n#endif\n\n    // Don't execute autocommands while the window is not properly\n    // initialized yet.  gui_create_scrollbar() may trigger a FocusGained\n    // event.\n    block_autocmds();\n\n    /*\n     * link the window in the window list\n     */\n    if (!hidden)\n\twin_append(after, new_wp);\n    new_wp->w_wincol = 0;\n    new_wp->w_width = Columns;\n\n    // position the display and the cursor at the top of the file.\n    new_wp->w_topline = 1;\n#ifdef FEAT_DIFF\n    new_wp->w_topfill = 0;\n#endif\n    new_wp->w_botline = 2;\n    new_wp->w_cursor.lnum = 1;\n    new_wp->w_scbind_pos = 1;\n\n    // use global option value for global-local options\n    new_wp->w_p_so = -1;\n    new_wp->w_p_siso = -1;\n\n    // We won't calculate w_fraction until resizing the window\n    new_wp->w_fraction = 0;\n    new_wp->w_prev_fraction_row = -1;\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_LEFT],\n\t\tSBAR_LEFT, new_wp);\n\tgui_create_scrollbar(&new_wp->w_scrollbars[SBAR_RIGHT],\n\t\tSBAR_RIGHT, new_wp);\n    }\n#endif\n#ifdef FEAT_FOLDING\n    foldInitWin(new_wp);\n#endif\n    unblock_autocmds();\n#ifdef FEAT_SEARCH_EXTRA\n    new_wp->w_match_head = NULL;\n    new_wp->w_next_match_id = 4;\n#endif\n    return new_wp;\n}\n\n/*\n * Remove window 'wp' from the window list and free the structure.\n */\n    static void\nwin_free(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    int\t\ti;\n    buf_T\t*buf;\n    wininfo_T\t*wip;\n\n#ifdef FEAT_FOLDING\n    clearFolding(wp);\n#endif\n\n    // reduce the reference count to the argument list.\n    alist_unlink(wp->w_alist);\n\n    // Don't execute autocommands while the window is halfway being deleted.\n    // gui_mch_destroy_scrollbar() may trigger a FocusGained event.\n    block_autocmds();\n\n#ifdef FEAT_LUA\n    lua_window_free(wp);\n#endif\n\n#ifdef FEAT_MZSCHEME\n    mzscheme_window_free(wp);\n#endif\n\n#ifdef FEAT_PERL\n    perl_win_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON\n    python_window_free(wp);\n#endif\n\n#ifdef FEAT_PYTHON3\n    python3_window_free(wp);\n#endif\n\n#ifdef FEAT_TCL\n    tcl_window_free(wp);\n#endif\n\n#ifdef FEAT_RUBY\n    ruby_window_free(wp);\n#endif\n\n    clear_winopt(&wp->w_onebuf_opt);\n    clear_winopt(&wp->w_allbuf_opt);\n\n    vim_free(wp->w_lcs_chars.multispace);\n\n#ifdef FEAT_EVAL\n    vars_clear(&wp->w_vars->dv_hashtab);\t// free all w: variables\n    hash_init(&wp->w_vars->dv_hashtab);\n    unref_var_dict(wp->w_vars);\n#endif\n\n    {\n\ttabpage_T\t*ttp;\n\n\tif (prevwin == wp)\n\t    prevwin = NULL;\n\tFOR_ALL_TABPAGES(ttp)\n\t    if (ttp->tp_prevwin == wp)\n\t\tttp->tp_prevwin = NULL;\n    }\n    win_free_lsize(wp);\n\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n    {\n\tvim_free(wp->w_tagstack[i].tagname);\n\tvim_free(wp->w_tagstack[i].user_data);\n    }\n    vim_free(wp->w_localdir);\n    vim_free(wp->w_prevdir);\n\n    // Remove the window from the b_wininfo lists, it may happen that the\n    // freed memory is re-used for another window.\n    FOR_ALL_BUFFERS(buf)\n\tFOR_ALL_BUF_WININFO(buf, wip)\n\t    if (wip->wi_win == wp)\n\t    {\n\t\twininfo_T\t*wip2;\n\n\t\t// If there already is an entry with \"wi_win\" set to NULL it\n\t\t// must be removed, it would never be used.\n\t\t// Skip \"wip\" itself, otherwise Coverity complains.\n\t\tfor (wip2 = buf->b_wininfo; wip2 != NULL; wip2 = wip2->wi_next)\n\t\t    if (wip2 != wip && wip2->wi_win == NULL)\n\t\t    {\n\t\t\tif (wip2->wi_next != NULL)\n\t\t\t    wip2->wi_next->wi_prev = wip2->wi_prev;\n\t\t\tif (wip2->wi_prev == NULL)\n\t\t\t    buf->b_wininfo = wip2->wi_next;\n\t\t\telse\n\t\t\t    wip2->wi_prev->wi_next = wip2->wi_next;\n\t\t\tfree_wininfo(wip2);\n\t\t\tbreak;\n\t\t    }\n\n\t\twip->wi_win = NULL;\n\t    }\n\n#ifdef FEAT_SEARCH_EXTRA\n    clear_matches(wp);\n#endif\n\n    free_jumplist(wp);\n\n#ifdef FEAT_QUICKFIX\n    qf_free_all(wp);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_LEFT]);\n\tgui_mch_destroy_scrollbar(&wp->w_scrollbars[SBAR_RIGHT]);\n    }\n#endif // FEAT_GUI\n\n#ifdef FEAT_MENU\n    remove_winbar(wp);\n#endif\n#ifdef FEAT_PROP_POPUP\n    free_callback(&wp->w_close_cb);\n    free_callback(&wp->w_filter_cb);\n    for (i = 0; i < 4; ++i)\n\tVIM_CLEAR(wp->w_border_highlight[i]);\n    vim_free(wp->w_scrollbar_highlight);\n    vim_free(wp->w_thumb_highlight);\n    vim_free(wp->w_popup_title);\n    list_unref(wp->w_popup_mask);\n    vim_free(wp->w_popup_mask_cells);\n#endif\n\n#ifdef FEAT_SYN_HL\n    vim_free(wp->w_p_cc_cols);\n#endif\n\n    if (win_valid_any_tab(wp))\n\twin_remove(wp, tp);\n    if (autocmd_busy)\n    {\n\twp->w_next = au_pending_free_win;\n\tau_pending_free_win = wp;\n    }\n    else\n\tvim_free(wp);\n\n    unblock_autocmds();\n}\n\n/*\n * Return TRUE if \"wp\" is not in the list of windows: the autocmd window or a\n * popup window.\n */\n    static int\nwin_unlisted(win_T *wp)\n{\n    return wp == aucmd_win || WIN_IS_POPUP(wp);\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Free a popup window.  This does not take the window out of the window list\n * and assumes there is only one toplevel frame, no split.\n */\n    void\nwin_free_popup(win_T *win)\n{\n    if (bt_popup(win->w_buffer))\n\twin_close_buffer(win, DOBUF_WIPE_REUSE, FALSE);\n    else\n\tclose_buffer(win, win->w_buffer, 0, FALSE, FALSE);\n# if defined(FEAT_TIMERS)\n    if (win->w_popup_timer != NULL)\n\tstop_timer(win->w_popup_timer);\n# endif\n    vim_free(win->w_frame);\n    win_free(win, NULL);\n}\n#endif\n\n/*\n * Append window \"wp\" in the window list after window \"after\".\n */\n    static void\nwin_append(win_T *after, win_T *wp)\n{\n    win_T\t*before;\n\n    if (after == NULL)\t    // after NULL is in front of the first\n\tbefore = firstwin;\n    else\n\tbefore = after->w_next;\n\n    wp->w_next = before;\n    wp->w_prev = after;\n    if (after == NULL)\n\tfirstwin = wp;\n    else\n\tafter->w_next = wp;\n    if (before == NULL)\n\tlastwin = wp;\n    else\n\tbefore->w_prev = wp;\n}\n\n/*\n * Remove a window from the window list.\n */\n    void\nwin_remove(\n    win_T\t*wp,\n    tabpage_T\t*tp)\t\t// tab page \"win\" is in, NULL for current\n{\n    if (wp->w_prev != NULL)\n\twp->w_prev->w_next = wp->w_next;\n    else if (tp == NULL)\n\tfirstwin = curtab->tp_firstwin = wp->w_next;\n    else\n\ttp->tp_firstwin = wp->w_next;\n\n    if (wp->w_next != NULL)\n\twp->w_next->w_prev = wp->w_prev;\n    else if (tp == NULL)\n\tlastwin = curtab->tp_lastwin = wp->w_prev;\n    else\n\ttp->tp_lastwin = wp->w_prev;\n}\n\n/*\n * Append frame \"frp\" in a frame list after frame \"after\".\n */\n    static void\nframe_append(frame_T *after, frame_T *frp)\n{\n    frp->fr_next = after->fr_next;\n    after->fr_next = frp;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp;\n    frp->fr_prev = after;\n}\n\n/*\n * Insert frame \"frp\" in a frame list before frame \"before\".\n */\n    static void\nframe_insert(frame_T *before, frame_T *frp)\n{\n    frp->fr_next = before;\n    frp->fr_prev = before->fr_prev;\n    before->fr_prev = frp;\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp;\n    else\n\tfrp->fr_parent->fr_child = frp;\n}\n\n/*\n * Remove a frame from a frame list.\n */\n    static void\nframe_remove(frame_T *frp)\n{\n    if (frp->fr_prev != NULL)\n\tfrp->fr_prev->fr_next = frp->fr_next;\n    else\n\tfrp->fr_parent->fr_child = frp->fr_next;\n    if (frp->fr_next != NULL)\n\tfrp->fr_next->fr_prev = frp->fr_prev;\n}\n\n/*\n * Allocate w_lines[] for window \"wp\".\n * Return FAIL for failure, OK for success.\n */\n    int\nwin_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * free lsize arrays for a window\n */\n    void\nwin_free_lsize(win_T *wp)\n{\n    // TODO: why would wp be NULL here?\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}\n\n/*\n * Called from win_new_shellsize() after Rows changed.\n * This only does the current tab page, others must be done when made active.\n */\n    void\nshell_new_rows(void)\n{\n    int\t\th = (int)ROWS_AVAIL;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n    if (h < frame_minheight(topframe, NULL))\n\th = frame_minheight(topframe, NULL);\n\n    // First try setting the heights of windows with 'winfixheight'.  If\n    // that doesn't result in the right height, forget about that option.\n    frame_new_height(topframe, h, FALSE, TRUE);\n    if (!frame_check_height(topframe, h))\n\tframe_new_height(topframe, h, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n    compute_cmdrow();\n    curtab->tp_ch_used = p_ch;\n\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'v');\n#endif\n}\n\n/*\n * Called from win_new_shellsize() after Columns changed.\n */\n    void\nshell_new_columns(void)\n{\n    if (firstwin == NULL)\t// not initialized yet\n\treturn;\n\n    // First try setting the widths of windows with 'winfixwidth'.  If that\n    // doesn't result in the right width, forget about that option.\n    frame_new_width(topframe, (int)Columns, FALSE, TRUE);\n    if (!frame_check_width(topframe, Columns))\n\tframe_new_width(topframe, (int)Columns, FALSE, FALSE);\n\n    (void)win_comp_pos();\t\t// recompute w_winrow and w_wincol\n#if 0\n    // Disabled: don't want making the screen smaller make a window larger.\n    if (p_ea)\n\twin_equal(curwin, FALSE, 'h');\n#endif\n}\n\n#if defined(FEAT_CMDWIN) || defined(PROTO)\n/*\n * Save the size of all windows in \"gap\".\n */\n    void\nwin_size_save(garray_T *gap)\n\n{\n    win_T\t*wp;\n\n    ga_init2(gap, sizeof(int), 1);\n    if (ga_grow(gap, win_count() * 2 + 1) == OK)\n    {\n\t// first entry is value of 'lines'\n\t((int *)gap->ga_data)[gap->ga_len++] = Rows;\n\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    ((int *)gap->ga_data)[gap->ga_len++] =\n\t\t\t\t\t       wp->w_width + wp->w_vsep_width;\n\t    ((int *)gap->ga_data)[gap->ga_len++] = wp->w_height;\n\t}\n    }\n}\n\n/*\n * Restore window sizes, but only if the number of windows is still the same\n * and 'lines' didn't change.\n * Does not free the growarray.\n */\n    void\nwin_size_restore(garray_T *gap)\n{\n    win_T\t*wp;\n    int\t\ti, j;\n\n    if (win_count() * 2 + 1 == gap->ga_len\n\t    && ((int *)gap->ga_data)[0] == Rows)\n    {\n\t// The order matters, because frames contain other frames, but it's\n\t// difficult to get right. The easy way out is to do it twice.\n\tfor (j = 0; j < 2; ++j)\n\t{\n\t    i = 1;\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tframe_setwidth(wp->w_frame, ((int *)gap->ga_data)[i++]);\n\t\twin_setheight_win(((int *)gap->ga_data)[i++], wp);\n\t    }\n\t}\n\t// recompute the window positions\n\t(void)win_comp_pos();\n    }\n}\n#endif // FEAT_CMDWIN\n\n/*\n * Update the position for all windows, using the width and height of the\n * frames.\n * Returns the row just after the last window.\n */\n    int\nwin_comp_pos(void)\n{\n    int\t\trow = tabline_height();\n    int\t\tcol = 0;\n\n    frame_comp_pos(topframe, &row, &col);\n    return row;\n}\n\n/*\n * Update the position of the windows in frame \"topfrp\", using the width and\n * height of the frames.\n * \"*row\" and \"*col\" are the top-left position of the frame.  They are updated\n * to the bottom-right position plus one.\n */\n    static void\nframe_comp_pos(frame_T *topfrp, int *row, int *col)\n{\n    win_T\t*wp;\n    frame_T\t*frp;\n    int\t\tstartcol;\n    int\t\tstartrow;\n    int\t\th;\n\n    wp = topfrp->fr_win;\n    if (wp != NULL)\n    {\n\tif (wp->w_winrow != *row || wp->w_wincol != *col)\n\t{\n\t    // position changed, redraw\n\t    wp->w_winrow = *row;\n\t    wp->w_wincol = *col;\n\t    redraw_win_later(wp, NOT_VALID);\n\t    wp->w_redr_status = TRUE;\n\t}\n\t// WinBar will not show if the window height is zero\n\th = VISIBLE_HEIGHT(wp) + wp->w_status_height;\n\t*row += h > topfrp->fr_height ? topfrp->fr_height : h;\n\t*col += wp->w_width + wp->w_vsep_width;\n    }\n    else\n    {\n\tstartrow = *row;\n\tstartcol = *col;\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t{\n\t    if (topfrp->fr_layout == FR_ROW)\n\t\t*row = startrow;\t// all frames are at the same row\n\t    else\n\t\t*col = startcol;\t// all frames are at the same col\n\t    frame_comp_pos(frp, row, col);\n\t}\n    }\n}\n\n/*\n * Make the current window show at least one line and one column.\n */\n    void\nwin_ensure_size()\n{\n    if (curwin->w_height == 0)\n\twin_setheight(1);\n    if (curwin->w_width == 0)\n\twin_setwidth(1);\n}\n\n/*\n * Set current window height and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setheight(int height)\n{\n    win_setheight_win(height, curwin);\n}\n\n/*\n * Set the window height of window \"win\" and take care of repositioning other\n * windows to fit around it.\n */\n    void\nwin_setheight_win(int height, win_T *win)\n{\n    int\t\trow;\n\n    if (win == curwin)\n    {\n\t// Always keep current window at least one line high, even when\n\t// 'winminheight' is zero.\n\tif (height < p_wmh)\n\t    height = p_wmh;\n\tif (height == 0)\n\t    height = 1;\n\theight += WINBAR_HEIGHT(curwin);\n    }\n\n    frame_setheight(win->w_frame, height + win->w_status_height);\n\n    // recompute the window positions\n    row = win_comp_pos();\n\n    /*\n     * If there is extra space created between the last window and the command\n     * line, clear it.\n     */\n    if (full_screen && msg_scrolled == 0 && row < cmdline_row)\n\tscreen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    msg_row = row;\n    msg_col = 0;\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the height of a frame to \"height\" and take care that all frames and\n * windows inside it are resized.  Also resize frames on the left and right if\n * the are in the same FR_ROW frame.\n *\n * Strategy:\n * If the frame is part of a FR_COL frame, try fitting the frame in that\n * frame.  If that doesn't work (the FR_COL frame is too small), recursively\n * go to containing frames to resize them and make room.\n * If the frame is part of a FR_ROW frame, all frames must be resized as well.\n * Check for the minimal height of the FR_ROW frame.\n * At the top level we can also use change the command line height.\n */\n    static void\nframe_setheight(frame_T *curfrp, int height)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\troom_cmdline;\t// lines available from cmdline\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\th;\n    int\t\troom_reserved;\n\n    // If the height already is the desired value, nothing to do.\n    if (curfrp->fr_height == height)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n    {\n\t// topframe: can only change the command line\n\tif (height > ROWS_AVAIL)\n\t    height = ROWS_AVAIL;\n\tif (height > 0)\n\t    frame_new_height(curfrp, height, FALSE, FALSE);\n    }\n    else if (curfrp->fr_parent->fr_layout == FR_ROW)\n    {\n\t// Row of frames: Also need to resize frames left and right of this\n\t// one.  First check for the minimal height of these.\n\th = frame_minheight(curfrp->fr_parent, NULL);\n\tif (height < h)\n\t    height = h;\n\tframe_setheight(curfrp->fr_parent, height);\n    }\n    else\n    {\n\t/*\n\t * Column of frames: try to change only frames in this column.\n\t */\n\t/*\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the height to it.\n\t * Try not to reduce the height of a window with 'winfixheight' set.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t    room_reserved += frp->fr_height;\n\t\troom += frp->fr_height;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minheight(frp, NULL);\n\t    }\n\t    if (curfrp->fr_width != Columns)\n\t\troom_cmdline = 0;\n\t    else\n\t    {\n\t\troom_cmdline = Rows - p_ch - (lastwin->w_winrow\n\t\t\t\t\t\t+ VISIBLE_HEIGHT(lastwin)\n\t\t\t\t\t\t+ lastwin->w_status_height);\n\t\tif (room_cmdline < 0)\n\t\t    room_cmdline = 0;\n\t    }\n\n\t    if (height <= room + room_cmdline)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_width == Columns)\n\t    {\n\t\tif (height > room + room_cmdline)\n\t\t    height = room + room_cmdline;\n\t\tbreak;\n\t    }\n\t    frame_setheight(curfrp->fr_parent, height\n\t\t+ frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = height - curfrp->fr_height;\n\n\t// If there is not enough room, also reduce the height of a window\n\t// with 'winfixheight' set.\n\tif (height > room + room_cmdline - room_reserved)\n\t    room_reserved = room + room_cmdline - height;\n\t// If there is only a 'winfixheight' window and making the\n\t// window smaller, need to make the other window taller.\n\tif (take < 0 && room - curfrp->fr_height < room_reserved)\n\t    room_reserved = 0;\n\n\tif (take > 0 && room_cmdline > 0)\n\t{\n\t    // use lines from cmdline first\n\t    if (take < room_cmdline)\n\t\troom_cmdline = take;\n\t    take -= room_cmdline;\n\t    topframe->fr_height += room_cmdline;\n\t}\n\n\t/*\n\t * set the current frame to the new height\n\t */\n\tframe_new_height(curfrp, height, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames after the current frame.  If\n\t * that is not enough, takes lines from frames above the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\th = frame_minheight(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfh)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_height)\n\t\t\troom_reserved -= frp->fr_height;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_height - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_height - take;\n\t\t\ttake -= frp->fr_height - room_reserved;\n\t\t\tframe_new_height(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_height - take < h)\n\t\t    {\n\t\t\ttake -= frp->fr_height - h;\n\t\t\tframe_new_height(frp, h, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_height(frp, frp->fr_height - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Set current window width and take care of repositioning other windows to\n * fit around it.\n */\n    void\nwin_setwidth(int width)\n{\n    win_setwidth_win(width, curwin);\n}\n\n    void\nwin_setwidth_win(int width, win_T *wp)\n{\n    // Always keep current window at least one column wide, even when\n    // 'winminwidth' is zero.\n    if (wp == curwin)\n    {\n\tif (width < p_wmw)\n\t    width = p_wmw;\n\tif (width == 0)\n\t    width = 1;\n    }\n    else if (width < 0)\n\twidth = 0;\n\n    frame_setwidth(wp->w_frame, width + wp->w_vsep_width);\n\n    // recompute the window positions\n    (void)win_comp_pos();\n\n    redraw_all_later(NOT_VALID);\n}\n\n/*\n * Set the width of a frame to \"width\" and take care that all frames and\n * windows inside it are resized.  Also resize frames above and below if the\n * are in the same FR_ROW frame.\n *\n * Strategy is similar to frame_setheight().\n */\n    static void\nframe_setwidth(frame_T *curfrp, int width)\n{\n    int\t\troom;\t\t// total number of lines available\n    int\t\ttake;\t\t// number of lines taken from other windows\n    int\t\trun;\n    frame_T\t*frp;\n    int\t\tw;\n    int\t\troom_reserved;\n\n    // If the width already is the desired value, nothing to do.\n    if (curfrp->fr_width == width)\n\treturn;\n\n    if (curfrp->fr_parent == NULL)\n\t// topframe: can't change width\n\treturn;\n\n    if (curfrp->fr_parent->fr_layout == FR_COL)\n    {\n\t// Column of frames: Also need to resize frames above and below of\n\t// this one.  First check for the minimal width of these.\n\tw = frame_minwidth(curfrp->fr_parent, NULL);\n\tif (width < w)\n\t    width = w;\n\tframe_setwidth(curfrp->fr_parent, width);\n    }\n    else\n    {\n\t/*\n\t * Row of frames: try to change only frames in this row.\n\t *\n\t * Do this twice:\n\t * 1: compute room available, if it's not enough try resizing the\n\t *    containing frame.\n\t * 2: compute the room available and adjust the width to it.\n\t */\n\tfor (run = 1; run <= 2; ++run)\n\t{\n\t    room = 0;\n\t    room_reserved = 0;\n\t    FOR_ALL_FRAMES(frp, curfrp->fr_parent->fr_child)\n\t    {\n\t\tif (frp != curfrp\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t    room_reserved += frp->fr_width;\n\t\troom += frp->fr_width;\n\t\tif (frp != curfrp)\n\t\t    room -= frame_minwidth(frp, NULL);\n\t    }\n\n\t    if (width <= room)\n\t\tbreak;\n\t    if (run == 2 || curfrp->fr_height >= ROWS_AVAIL)\n\t    {\n\t\tif (width > room)\n\t\t    width = room;\n\t\tbreak;\n\t    }\n\t    frame_setwidth(curfrp->fr_parent, width\n\t\t + frame_minwidth(curfrp->fr_parent, NOWIN) - (int)p_wmw - 1);\n\t}\n\n\t/*\n\t * Compute the number of lines we will take from others frames (can be\n\t * negative!).\n\t */\n\ttake = width - curfrp->fr_width;\n\n\t// If there is not enough room, also reduce the width of a window\n\t// with 'winfixwidth' set.\n\tif (width > room - room_reserved)\n\t    room_reserved = room - width;\n\t// If there is only a 'winfixwidth' window and making the\n\t// window smaller, need to make the other window narrower.\n\tif (take < 0 && room - curfrp->fr_width < room_reserved)\n\t    room_reserved = 0;\n\n\t/*\n\t * set the current frame to the new width\n\t */\n\tframe_new_width(curfrp, width, FALSE, FALSE);\n\n\t/*\n\t * First take lines from the frames right of the current frame.  If\n\t * that is not enough, takes lines from frames left of the current\n\t * frame.\n\t */\n\tfor (run = 0; run < 2; ++run)\n\t{\n\t    if (run == 0)\n\t\tfrp = curfrp->fr_next;\t// 1st run: start with next window\n\t    else\n\t\tfrp = curfrp->fr_prev;\t// 2nd run: start with prev window\n\t    while (frp != NULL && take != 0)\n\t    {\n\t\tw = frame_minwidth(frp, NULL);\n\t\tif (room_reserved > 0\n\t\t\t&& frp->fr_win != NULL\n\t\t\t&& frp->fr_win->w_p_wfw)\n\t\t{\n\t\t    if (room_reserved >= frp->fr_width)\n\t\t\troom_reserved -= frp->fr_width;\n\t\t    else\n\t\t    {\n\t\t\tif (frp->fr_width - room_reserved > take)\n\t\t\t    room_reserved = frp->fr_width - take;\n\t\t\ttake -= frp->fr_width - room_reserved;\n\t\t\tframe_new_width(frp, room_reserved, FALSE, FALSE);\n\t\t\troom_reserved = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (frp->fr_width - take < w)\n\t\t    {\n\t\t\ttake -= frp->fr_width - w;\n\t\t\tframe_new_width(frp, w, FALSE, FALSE);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tframe_new_width(frp, frp->fr_width - take,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t\ttake = 0;\n\t\t    }\n\t\t}\n\t\tif (run == 0)\n\t\t    frp = frp->fr_next;\n\t\telse\n\t\t    frp = frp->fr_prev;\n\t    }\n\t}\n    }\n}\n\n/*\n * Check 'winminheight' for a valid value and reduce it if needed.\n */\n    void\nwin_setminheight(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmh > 0)\n    {\n\troom = Rows - p_ch;\n\tneeded = min_rows() - 1;  // 1 was added for the cmdline\n\tif (room >= needed)\n\t    break;\n\t--p_wmh;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Check 'winminwidth' for a valid value and reduce it if needed.\n */\n    void\nwin_setminwidth(void)\n{\n    int\t\troom;\n    int\t\tneeded;\n    int\t\tfirst = TRUE;\n\n    // loop until there is a 'winminheight' that is possible\n    while (p_wmw > 0)\n    {\n\troom = Columns;\n\tneeded = frame_minwidth(topframe, NULL);\n\tif (room >= needed)\n\t    break;\n\t--p_wmw;\n\tif (first)\n\t{\n\t    emsg(_(e_not_enough_room));\n\t    first = FALSE;\n\t}\n    }\n}\n\n/*\n * Status line of dragwin is dragged \"offset\" lines down (negative is up).\n */\n    void\nwin_drag_status_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\trow;\n    int\t\tup;\t// if TRUE, drag status line up, otherwise down\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    curfr = fr;\n    if (fr != topframe)\t\t// more than one window\n    {\n\tfr = fr->fr_parent;\n\t// When the parent frame is not a column of frames, its parent should\n\t// be.\n\tif (fr->fr_layout != FR_COL)\n\t{\n\t    curfr = fr;\n\t    if (fr != topframe)\t// only a row of windows, may drag statusline\n\t\tfr = fr->fr_parent;\n\t}\n    }\n\n    // If this is the last frame in a column, may want to resize the parent\n    // frame instead (go two up to skip a row of frames).\n    while (curfr != topframe && curfr->fr_next == NULL)\n    {\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n\tcurfr = fr;\n\tif (fr != topframe)\n\t    fr = fr->fr_parent;\n    }\n\n    if (offset < 0) // drag up\n    {\n\tup = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and above it\n\tif (fr == curfr)\n\t{\n\t    // only one window\n\t    room = fr->fr_height - frame_minheight(fr, NULL);\n\t}\n\telse\n\t{\n\t    room = 0;\n\t    for (fr = fr->fr_child; ; fr = fr->fr_next)\n\t    {\n\t\troom += fr->fr_height - frame_minheight(fr, NULL);\n\t\tif (fr == curfr)\n\t\t    break;\n\t    }\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag down\n    {\n\tup = FALSE;\n\t/*\n\t * Only dragging the last status line can reduce p_ch.\n\t */\n\troom = Rows - cmdline_row;\n\tif (curfr->fr_next == NULL)\n\t    room -= 1;\n\telse\n\t    room -= p_ch;\n\tif (room < 0)\n\t    room = 0;\n\t// sum up the room of frames below of the current one\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_height - frame_minheight(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\n\treturn;\n\n    /*\n     * Grow frame fr by \"offset\" lines.\n     * Doesn't happen when dragging the last status line up.\n     */\n    if (fr != NULL)\n\tframe_new_height(fr, fr->fr_height + offset, up, FALSE);\n\n    if (up)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    /*\n     * Now make the other frames smaller.\n     */\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minheight(fr, NULL);\n\tif (fr->fr_height - offset <= n)\n\t{\n\t    offset -= fr->fr_height - n;\n\t    frame_new_height(fr, n, !up, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_height(fr, fr->fr_height - offset, !up, FALSE);\n\t    break;\n\t}\n\tif (up)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    row = win_comp_pos();\n    screen_fill(row, cmdline_row, 0, (int)Columns, ' ', ' ', 0);\n    cmdline_row = row;\n    p_ch = Rows - cmdline_row;\n    if (p_ch < 1)\n\tp_ch = 1;\n    curtab->tp_ch_used = p_ch;\n    redraw_all_later(SOME_VALID);\n    showmode();\n}\n\n/*\n * Separator line of dragwin is dragged \"offset\" lines right (negative is left).\n */\n    void\nwin_drag_vsep_line(win_T *dragwin, int offset)\n{\n    frame_T\t*curfr;\n    frame_T\t*fr;\n    int\t\troom;\n    int\t\tleft;\t// if TRUE, drag separator line left, otherwise right\n    int\t\tn;\n\n    fr = dragwin->w_frame;\n    if (fr == topframe)\t\t// only one window (cannot happen?)\n\treturn;\n    curfr = fr;\n    fr = fr->fr_parent;\n    // When the parent frame is not a row of frames, its parent should be.\n    if (fr->fr_layout != FR_ROW)\n    {\n\tif (fr == topframe)\t// only a column of windows (cannot happen?)\n\t    return;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n    }\n\n    // If this is the last frame in a row, may want to resize a parent\n    // frame instead.\n    while (curfr->fr_next == NULL)\n    {\n\tif (fr == topframe)\n\t    break;\n\tcurfr = fr;\n\tfr = fr->fr_parent;\n\tif (fr != topframe)\n\t{\n\t    curfr = fr;\n\t    fr = fr->fr_parent;\n\t}\n    }\n\n    if (offset < 0) // drag left\n    {\n\tleft = TRUE;\n\toffset = -offset;\n\t// sum up the room of the current frame and left of it\n\troom = 0;\n\tfor (fr = fr->fr_child; ; fr = fr->fr_next)\n\t{\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\t    if (fr == curfr)\n\t\tbreak;\n\t}\n\tfr = curfr->fr_next;\t\t// put fr at frame that grows\n    }\n    else    // drag right\n    {\n\tleft = FALSE;\n\t// sum up the room of frames right of the current one\n\troom = 0;\n\tFOR_ALL_FRAMES(fr, curfr->fr_next)\n\t    room += fr->fr_width - frame_minwidth(fr, NULL);\n\tfr = curfr;\t\t\t// put fr at window that grows\n    }\n\n    if (room < offset)\t\t// Not enough room\n\toffset = room;\t\t// Move as far as we can\n    if (offset <= 0)\t\t// No room at all, quit.\n\treturn;\n    if (fr == NULL)\n\t// This can happen when calling win_move_separator() on the rightmost\n\t// window.  Just don't do anything.\n\treturn;\t\t\t\n\n    // grow frame fr by offset lines\n    frame_new_width(fr, fr->fr_width + offset, left, FALSE);\n\n    // shrink other frames: current and at the left or at the right\n    if (left)\n\tfr = curfr;\t\t// current frame gets smaller\n    else\n\tfr = curfr->fr_next;\t// next frame gets smaller\n\n    while (fr != NULL && offset > 0)\n    {\n\tn = frame_minwidth(fr, NULL);\n\tif (fr->fr_width - offset <= n)\n\t{\n\t    offset -= fr->fr_width - n;\n\t    frame_new_width(fr, n, !left, FALSE);\n\t}\n\telse\n\t{\n\t    frame_new_width(fr, fr->fr_width - offset, !left, FALSE);\n\t    break;\n\t}\n\tif (left)\n\t    fr = fr->fr_prev;\n\telse\n\t    fr = fr->fr_next;\n    }\n    (void)win_comp_pos();\n    redraw_all_later(NOT_VALID);\n}\n\n#define FRACTION_MULT\t16384L\n\n/*\n * Set wp->w_fraction for the current w_wrow and w_height.\n * Has no effect when the window is less than two lines.\n */\n    void\nset_fraction(win_T *wp)\n{\n    if (wp->w_height > 1)\n\t// When cursor is in the first line the percentage is computed as if\n\t// it's halfway that line.  Thus with two lines it is 25%, with three\n\t// lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.\n\twp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT\n\t\t\t\t     + FRACTION_MULT / 2) / (long)wp->w_height;\n}\n\n/*\n * Set the height of a window.\n * \"height\" excludes any window toolbar.\n * This takes care of the things inside the window, not what happens to the\n * window position, the frame or to other windows.\n */\n    void\nwin_new_height(win_T *wp, int height)\n{\n    int\t\tprev_height = wp->w_height;\n\n    // Don't want a negative height.  Happens when splitting a tiny window.\n    // Will equalize heights soon to fix it.\n    if (height < 0)\n\theight = 0;\n    if (wp->w_height == height)\n\treturn;\t    // nothing to do\n\n    if (wp->w_height > 0)\n    {\n\tif (wp == curwin)\n\t    // w_wrow needs to be valid. When setting 'laststatus' this may\n\t    // call win_new_height() recursively.\n\t    validate_cursor();\n\tif (wp->w_height != prev_height)\n\t    return;  // Recursive call already changed the size, bail out here\n\t\t     //\tto avoid the following to mess things up.\n\tif (wp->w_wrow != wp->w_prev_fraction_row)\n\t    set_fraction(wp);\n    }\n\n    wp->w_height = height;\n    wp->w_skipcol = 0;\n\n    // There is no point in adjusting the scroll position when exiting.  Some\n    // values might be invalid.\n    if (!exiting)\n\tscroll_to_fraction(wp, prev_height);\n}\n\n    void\nscroll_to_fraction(win_T *wp, int prev_height)\n{\n    linenr_T\tlnum;\n    int\t\tsline, line_size;\n    int\t\theight = wp->w_height;\n\n    // Don't change w_topline in any of these cases:\n    // - window height is 0\n    // - 'scrollbind' is set and this isn't the current window\n    // - window height is sufficient to display the whole buffer and first line\n    //   is visible.\n    if (height > 0\n        && (!wp->w_p_scb || wp == curwin)\n        && (height < wp->w_buffer->b_ml.ml_line_count || wp->w_topline > 1))\n    {\n\t/*\n\t * Find a value for w_topline that shows the cursor at the same\n\t * relative position in the window as before (more or less).\n\t */\n\tlnum = wp->w_cursor.lnum;\n\tif (lnum < 1)\t\t// can happen when starting up\n\t    lnum = 1;\n\twp->w_wrow = ((long)wp->w_fraction * (long)height - 1L)\n\t\t\t\t\t\t\t       / FRACTION_MULT;\n\tline_size = plines_win_col(wp, lnum, (long)(wp->w_cursor.col)) - 1;\n\tsline = wp->w_wrow - line_size;\n\n\tif (sline >= 0)\n\t{\n\t    // Make sure the whole cursor line is visible, if possible.\n\t    int rows = plines_win(wp, lnum, FALSE);\n\n\t    if (sline > wp->w_height - rows)\n\t    {\n\t\tsline = wp->w_height - rows;\n\t\twp->w_wrow -= rows - line_size;\n\t    }\n\t}\n\n\tif (sline < 0)\n\t{\n\t    /*\n\t     * Cursor line would go off top of screen if w_wrow was this high.\n\t     * Make cursor line the first line in the window.  If not enough\n\t     * room use w_skipcol;\n\t     */\n\t    wp->w_wrow = line_size;\n\t    if (wp->w_wrow >= wp->w_height\n\t\t\t\t       && (wp->w_width - win_col_off(wp)) > 0)\n\t    {\n\t\twp->w_skipcol += wp->w_width - win_col_off(wp);\n\t\t--wp->w_wrow;\n\t\twhile (wp->w_wrow >= wp->w_height)\n\t\t{\n\t\t    wp->w_skipcol += wp->w_width - win_col_off(wp)\n\t\t\t\t\t\t\t   + win_col_off2(wp);\n\t\t    --wp->w_wrow;\n\t\t}\n\t    }\n\t}\n\telse if (sline > 0)\n\t{\n\t    while (sline > 0 && lnum > 1)\n\t    {\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\tif (lnum == 1)\n\t\t{\n\t\t    // first line in buffer is folded\n\t\t    line_size = 1;\n\t\t    --sline;\n\t\t    break;\n\t\t}\n#endif\n\t\t--lnum;\n#ifdef FEAT_DIFF\n\t\tif (lnum == wp->w_topline)\n\t\t    line_size = plines_win_nofill(wp, lnum, TRUE)\n\t\t\t\t\t\t\t      + wp->w_topfill;\n\t\telse\n#endif\n\t\t    line_size = plines_win(wp, lnum, TRUE);\n\t\tsline -= line_size;\n\t    }\n\n\t    if (sline < 0)\n\t    {\n\t\t/*\n\t\t * Line we want at top would go off top of screen.  Use next\n\t\t * line instead.\n\t\t */\n#ifdef FEAT_FOLDING\n\t\thasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n#endif\n\t\tlnum++;\n\t\twp->w_wrow -= line_size + sline;\n\t    }\n\t    else if (sline > 0)\n\t    {\n\t\t// First line of file reached, use that as topline.\n\t\tlnum = 1;\n\t\twp->w_wrow -= sline;\n\t    }\n\t}\n\tset_topline(wp, lnum);\n    }\n\n    if (wp == curwin)\n    {\n\tif (get_scrolloff_value())\n\t    update_topline();\n\tcurs_columns(FALSE);\t// validate w_wrow\n    }\n    if (prev_height > 0)\n\twp->w_prev_fraction_row = wp->w_wrow;\n\n    win_comp_scroll(wp);\n    redraw_win_later(wp, SOME_VALID);\n    wp->w_redr_status = TRUE;\n    invalidate_botline_win(wp);\n}\n\n/*\n * Set the width of a window.\n */\n    void\nwin_new_width(win_T *wp, int width)\n{\n    wp->w_width = width;\n    wp->w_lines_valid = 0;\n    changed_line_abv_curs_win(wp);\n    invalidate_botline_win(wp);\n    if (wp == curwin)\n    {\n\tupdate_topline();\n\tcurs_columns(TRUE);\t// validate w_wrow\n    }\n    redraw_win_later(wp, NOT_VALID);\n    wp->w_redr_status = TRUE;\n}\n\n    void\nwin_comp_scroll(win_T *wp)\n{\n#if defined(FEAT_EVAL)\n    int old_w_p_scr = wp->w_p_scr;\n#endif\n\n    wp->w_p_scr = ((unsigned)wp->w_height >> 1);\n    if (wp->w_p_scr == 0)\n\twp->w_p_scr = 1;\n#if defined(FEAT_EVAL)\n    if (wp->w_p_scr != old_w_p_scr)\n    {\n\t// Used by \"verbose set scroll\".\n\twp->w_p_script_ctx[WV_SCROLL].sc_sid = SID_WINLAYOUT;\n\twp->w_p_script_ctx[WV_SCROLL].sc_lnum = 0;\n    }\n#endif\n}\n\n/*\n * command_height: called whenever p_ch has been changed\n */\n    void\ncommand_height(void)\n{\n    int\t\th;\n    frame_T\t*frp;\n    int\t\told_p_ch = curtab->tp_ch_used;\n\n    // Use the value of p_ch that we remembered.  This is needed for when the\n    // GUI starts up, we can't be sure in what order things happen.  And when\n    // p_ch was changed in another tab page.\n    curtab->tp_ch_used = p_ch;\n\n    // Find bottom frame with width of screen.\n    frp = lastwin->w_frame;\n    while (frp->fr_width != Columns && frp->fr_parent != NULL)\n\tfrp = frp->fr_parent;\n\n    // Avoid changing the height of a window with 'winfixheight' set.\n    while (frp->fr_prev != NULL && frp->fr_layout == FR_LEAF\n\t\t\t\t\t\t      && frp->fr_win->w_p_wfh)\n\tfrp = frp->fr_prev;\n\n    if (starting != NO_SCREEN)\n    {\n\tcmdline_row = Rows - p_ch;\n\n\tif (p_ch > old_p_ch)\t\t    // p_ch got bigger\n\t{\n\t    while (p_ch > old_p_ch)\n\t    {\n\t\tif (frp == NULL)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    p_ch = old_p_ch;\n\t\t    curtab->tp_ch_used = p_ch;\n\t\t    cmdline_row = Rows - p_ch;\n\t\t    break;\n\t\t}\n\t\th = frp->fr_height - frame_minheight(frp, NULL);\n\t\tif (h > p_ch - old_p_ch)\n\t\t    h = p_ch - old_p_ch;\n\t\told_p_ch += h;\n\t\tframe_add_height(frp, -h);\n\t\tfrp = frp->fr_prev;\n\t    }\n\n\t    // Recompute window positions.\n\t    (void)win_comp_pos();\n\n\t    // clear the lines added to cmdline\n\t    if (full_screen)\n\t\tscreen_fill(cmdline_row, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t    msg_row = cmdline_row;\n\t    redraw_cmdline = TRUE;\n\t    return;\n\t}\n\n\tif (msg_row < cmdline_row)\n\t    msg_row = cmdline_row;\n\tredraw_cmdline = TRUE;\n    }\n    frame_add_height(frp, (int)(old_p_ch - p_ch));\n\n    // Recompute window positions.\n    if (frp != lastwin->w_frame)\n\t(void)win_comp_pos();\n}\n\n/*\n * Resize frame \"frp\" to be \"n\" lines higher (negative for less high).\n * Also resize the frames it is contained in.\n */\n    static void\nframe_add_height(frame_T *frp, int n)\n{\n    frame_new_height(frp, frp->fr_height + n, FALSE, FALSE);\n    for (;;)\n    {\n\tfrp = frp->fr_parent;\n\tif (frp == NULL)\n\t    break;\n\tfrp->fr_height += n;\n    }\n}\n\n/*\n * Add or remove a status line for the bottom window(s), according to the\n * value of 'laststatus'.\n */\n    void\nlast_status(\n    int\t\tmorewin)\t// pretend there are two or more windows\n{\n    // Don't make a difference between horizontal or vertical split.\n    last_status_rec(topframe, (p_ls == 2\n\t\t\t  || (p_ls == 1 && (morewin || !ONE_WINDOW))));\n}\n\n    static void\nlast_status_rec(frame_T *fr, int statusline)\n{\n    frame_T\t*fp;\n    win_T\t*wp;\n\n    if (fr->fr_layout == FR_LEAF)\n    {\n\twp = fr->fr_win;\n\tif (wp->w_status_height != 0 && !statusline)\n\t{\n\t    // remove status line\n\t    win_new_height(wp, wp->w_height + 1);\n\t    wp->w_status_height = 0;\n\t    comp_col();\n\t}\n\telse if (wp->w_status_height == 0 && statusline)\n\t{\n\t    // Find a frame to take a line from.\n\t    fp = fr;\n\t    while (fp->fr_height <= frame_minheight(fp, NULL))\n\t    {\n\t\tif (fp == topframe)\n\t\t{\n\t\t    emsg(_(e_not_enough_room));\n\t\t    return;\n\t\t}\n\t\t// In a column of frames: go to frame above.  If already at\n\t\t// the top or in a row of frames: go to parent.\n\t\tif (fp->fr_parent->fr_layout == FR_COL && fp->fr_prev != NULL)\n\t\t    fp = fp->fr_prev;\n\t\telse\n\t\t    fp = fp->fr_parent;\n\t    }\n\t    wp->w_status_height = 1;\n\t    if (fp != fr)\n\t    {\n\t\tframe_new_height(fp, fp->fr_height - 1, FALSE, FALSE);\n\t\tframe_fix_height(wp);\n\t\t(void)win_comp_pos();\n\t    }\n\t    else\n\t\twin_new_height(wp, wp->w_height - 1);\n\t    comp_col();\n\t    redraw_all_later(SOME_VALID);\n\t}\n    }\n    else if (fr->fr_layout == FR_ROW)\n    {\n\t// vertically split windows, set status line for each one\n\tFOR_ALL_FRAMES(fp, fr->fr_child)\n\t    last_status_rec(fp, statusline);\n    }\n    else\n    {\n\t// horizontally split window, set status line for last one\n\tfor (fp = fr->fr_child; fp->fr_next != NULL; fp = fp->fr_next)\n\t    ;\n\tlast_status_rec(fp, statusline);\n    }\n}\n\n/*\n * Return the number of lines used by the tab page line.\n */\n    int\ntabline_height(void)\n{\n#ifdef FEAT_GUI_TABLINE\n    // When the GUI has the tabline then this always returns zero.\n    if (gui_use_tabline())\n\treturn 0;\n#endif\n    switch (p_stal)\n    {\n\tcase 0: return 0;\n\tcase 1: return (first_tabpage->tp_next == NULL) ? 0 : 1;\n    }\n    return 1;\n}\n\n/*\n * Return the minimal number of rows that is needed on the screen to display\n * the current number of windows.\n */\n    int\nmin_rows(void)\n{\n    int\t\ttotal;\n    tabpage_T\t*tp;\n    int\t\tn;\n\n    if (firstwin == NULL)\t// not initialized yet\n\treturn MIN_LINES;\n\n    total = 0;\n    FOR_ALL_TABPAGES(tp)\n    {\n\tn = frame_minheight(tp->tp_topframe, NULL);\n\tif (total < n)\n\t    total = n;\n    }\n    total += tabline_height();\n    total += 1;\t\t// count the room for the command line\n    return total;\n}\n\n/*\n * Return TRUE if there is only one window and only one tab page, not\n * counting a help or preview window, unless it is the current window.\n * Does not count unlisted windows.\n */\n    int\nonly_one_window(void)\n{\n    int\t\tcount = 0;\n    win_T\t*wp;\n\n#if defined(FEAT_PROP_POPUP)\n    // If the current window is a popup then there always is another window.\n    if (popup_is_popup(curwin))\n\treturn FALSE;\n#endif\n\n    // If there is another tab page there always is another window.\n    if (first_tabpage->tp_next != NULL)\n\treturn FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer != NULL\n\t\t&& (!((bt_help(wp->w_buffer) && !bt_help(curbuf))\n# ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n# endif\n\t     ) || wp == curwin) && wp != aucmd_win)\n\t    ++count;\n    return (count <= 1);\n}\n\n/*\n * Correct the cursor line number in other windows.  Used after changing the\n * current buffer, and before applying autocommands.\n * When \"do_curwin\" is TRUE, also check current window.\n */\n    void\ncheck_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}\n\n/*\n * Reset cursor and topline to its stored values from check_lnums().\n * check_lnums() must have been called first!\n */\n    void\nreset_lnums()\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer == curbuf)\n\t{\n\t    // Restore the value if the autocommand didn't change it.\n\t    if (EQUAL_POS(wp->w_save_cursor.w_cursor_corr, wp->w_cursor))\n\t\twp->w_cursor = wp->w_save_cursor.w_cursor_save;\n\t    if (wp->w_save_cursor.w_topline_corr == wp->w_topline)\n\t\twp->w_topline = wp->w_save_cursor.w_topline_save;\n\t}\n}\n\n/*\n * A snapshot of the window sizes, to restore them after closing the help\n * window.\n * Only these fields are used:\n * fr_layout\n * fr_width\n * fr_height\n * fr_next\n * fr_child\n * fr_win (only valid for the old curwin, NULL otherwise)\n */\n\n/*\n * Create a snapshot of the current frame sizes.\n */\n    void\nmake_snapshot(int idx)\n{\n    clear_snapshot(curtab, idx);\n    make_snapshot_rec(topframe, &curtab->tp_snapshot[idx]);\n}\n\n    static void\nmake_snapshot_rec(frame_T *fr, frame_T **frp)\n{\n    *frp = ALLOC_CLEAR_ONE(frame_T);\n    if (*frp == NULL)\n\treturn;\n    (*frp)->fr_layout = fr->fr_layout;\n    (*frp)->fr_width = fr->fr_width;\n    (*frp)->fr_height = fr->fr_height;\n    if (fr->fr_next != NULL)\n\tmake_snapshot_rec(fr->fr_next, &((*frp)->fr_next));\n    if (fr->fr_child != NULL)\n\tmake_snapshot_rec(fr->fr_child, &((*frp)->fr_child));\n    if (fr->fr_layout == FR_LEAF && fr->fr_win == curwin)\n\t(*frp)->fr_win = curwin;\n}\n\n/*\n * Remove any existing snapshot.\n */\n    static void\nclear_snapshot(tabpage_T *tp, int idx)\n{\n    clear_snapshot_rec(tp->tp_snapshot[idx]);\n    tp->tp_snapshot[idx] = NULL;\n}\n\n    static void\nclear_snapshot_rec(frame_T *fr)\n{\n    if (fr != NULL)\n    {\n\tclear_snapshot_rec(fr->fr_next);\n\tclear_snapshot_rec(fr->fr_child);\n\tvim_free(fr);\n    }\n}\n\n/*\n * Restore a previously created snapshot, if there is any.\n * This is only done if the screen size didn't change and the window layout is\n * still the same.\n */\n    void\nrestore_snapshot(\n    int\t\tidx,\n    int\t\tclose_curwin)\t    // closing current window\n{\n    win_T\t*wp;\n\n    if (curtab->tp_snapshot[idx] != NULL\n\t    && curtab->tp_snapshot[idx]->fr_width == topframe->fr_width\n\t    && curtab->tp_snapshot[idx]->fr_height == topframe->fr_height\n\t    && check_snapshot_rec(curtab->tp_snapshot[idx], topframe) == OK)\n    {\n\twp = restore_snapshot_rec(curtab->tp_snapshot[idx], topframe);\n\twin_comp_pos();\n\tif (wp != NULL && close_curwin)\n\t    win_goto(wp);\n\tredraw_all_later(NOT_VALID);\n    }\n    clear_snapshot(curtab, idx);\n}\n\n/*\n * Check if frames \"sn\" and \"fr\" have the same layout, same following frames\n * and same children.  And the window pointer is valid.\n */\n    static int\ncheck_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    if (sn->fr_layout != fr->fr_layout\n\t    || (sn->fr_next == NULL) != (fr->fr_next == NULL)\n\t    || (sn->fr_child == NULL) != (fr->fr_child == NULL)\n\t    || (sn->fr_next != NULL\n\t\t&& check_snapshot_rec(sn->fr_next, fr->fr_next) == FAIL)\n\t    || (sn->fr_child != NULL\n\t\t&& check_snapshot_rec(sn->fr_child, fr->fr_child) == FAIL)\n\t    || (sn->fr_win != NULL && !win_valid(sn->fr_win)))\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all\n * following frames and children.\n * Returns a pointer to the old current window, or NULL.\n */\n    static win_T *\nrestore_snapshot_rec(frame_T *sn, frame_T *fr)\n{\n    win_T\t*wp = NULL;\n    win_T\t*wp2;\n\n    fr->fr_height = sn->fr_height;\n    fr->fr_width = sn->fr_width;\n    if (fr->fr_layout == FR_LEAF)\n    {\n\tframe_new_height(fr, fr->fr_height, FALSE, FALSE);\n\tframe_new_width(fr, fr->fr_width, FALSE, FALSE);\n\twp = sn->fr_win;\n    }\n    if (sn->fr_next != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_next, fr->fr_next);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    if (sn->fr_child != NULL)\n    {\n\twp2 = restore_snapshot_rec(sn->fr_child, fr->fr_child);\n\tif (wp2 != NULL)\n\t    wp = wp2;\n    }\n    return wp;\n}\n\n#if defined(FEAT_GUI) || defined(PROTO)\n/*\n * Return TRUE if there is any vertically split window.\n */\n    int\nwin_hasvertsplit(void)\n{\n    frame_T\t*fr;\n\n    if (topframe->fr_layout == FR_ROW)\n\treturn TRUE;\n\n    if (topframe->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(fr, topframe->fr_child)\n\t    if (fr->fr_layout == FR_ROW)\n\t\treturn TRUE;\n\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    int\nget_win_number(win_T *wp, win_T *first_win)\n{\n    int\t\ti = 1;\n    win_T\t*w;\n\n    for (w = first_win; w != NULL && w != wp; w = W_NEXT(w))\n\t++i;\n\n    if (w == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n\n    int\nget_tab_number(tabpage_T *tp UNUSED)\n{\n    int\t\ti = 1;\n    tabpage_T\t*t;\n\n    for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)\n\t++i;\n\n    if (t == NULL)\n\treturn 0;\n    else\n\treturn i;\n}\n#endif\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right height.\n */\n    static int\nframe_check_height(frame_T *topfrp, int height)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_height != height)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_ROW)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_height != height)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Return TRUE if \"topfrp\" and its children are at the right width.\n */\n    static int\nframe_check_width(frame_T *topfrp, int width)\n{\n    frame_T *frp;\n\n    if (topfrp->fr_width != width)\n\treturn FALSE;\n\n    if (topfrp->fr_layout == FR_COL)\n\tFOR_ALL_FRAMES(frp, topfrp->fr_child)\n\t    if (frp->fr_width != width)\n\t\treturn FALSE;\n\n    return TRUE;\n}\n\n#if defined(FEAT_SYN_HL) || defined(PROTO)\n/*\n * Simple int comparison function for use with qsort()\n */\n    static int\nint_cmp(const void *a, const void *b)\n{\n    return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\n    char *\ncheck_colorcolumn(win_T *wp)\n{\n    char_u\t*s;\n    int\t\tcol;\n    int\t\tcount = 0;\n    int\t\tcolor_cols[256];\n    int\t\ti;\n    int\t\tj = 0;\n\n    if (wp->w_buffer == NULL)\n\treturn NULL;  // buffer was closed\n\n    for (s = wp->w_p_cc; *s != NUL && count < 255;)\n    {\n\tif (*s == '-' || *s == '+')\n\t{\n\t    // -N and +N: add to 'textwidth'\n\t    col = (*s == '-') ? -1 : 1;\n\t    ++s;\n\t    if (!VIM_ISDIGIT(*s))\n\t\treturn e_invalid_argument;\n\t    col = col * getdigits(&s);\n\t    if (wp->w_buffer->b_p_tw == 0)\n\t\tgoto skip;  // 'textwidth' not set, skip this item\n\t    col += wp->w_buffer->b_p_tw;\n\t    if (col < 0)\n\t\tgoto skip;\n\t}\n\telse if (VIM_ISDIGIT(*s))\n\t    col = getdigits(&s);\n\telse\n\t    return e_invalid_argument;\n\tcolor_cols[count++] = col - 1;  // 1-based to 0-based\nskip:\n\tif (*s == NUL)\n\t    break;\n\tif (*s != ',')\n\t    return e_invalid_argument;\n\tif (*++s == NUL)\n\t    return e_invalid_argument;  // illegal trailing comma as in \"set cc=80,\"\n    }\n\n    vim_free(wp->w_p_cc_cols);\n    if (count == 0)\n\twp->w_p_cc_cols = NULL;\n    else\n    {\n\twp->w_p_cc_cols = ALLOC_MULT(int, count + 1);\n\tif (wp->w_p_cc_cols != NULL)\n\t{\n\t    // sort the columns for faster usage on screen redraw inside\n\t    // win_line()\n\t    qsort(color_cols, count, sizeof(int), int_cmp);\n\n\t    for (i = 0; i < count; ++i)\n\t\t// skip duplicates\n\t\tif (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n\t\t    wp->w_p_cc_cols[j++] = color_cols[i];\n\t    wp->w_p_cc_cols[j] = -1;  // end marker\n\t}\n    }\n\n    return NULL;  // no error\n}\n#endif\n"], "filenames": ["src/evalvars.c", "src/proto/window.pro", "src/usercmd.c", "src/version.c", "src/window.c"], "buggy_code_start_loc": [2202, 1, 144, 752, 111], "buggy_code_end_loc": [2226, 1, 486, 752, 4370], "fixing_code_start_loc": [2202, 2, 144, 753, 112], "fixing_code_end_loc": [2216, 3, 470, 755, 4397], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428.", "other": {"cve": {"id": "CVE-2022-0696", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-21T20:15:08.230", "lastModified": "2022-11-29T22:12:33.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 8.2.4428."}, {"lang": "es", "value": "Derivaci\u00f3n de puntero nulo en el repositorio de GitHub vim/vim anterior a 8.2.4428"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.2, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4428", "matchCriteriaId": "AEC28CB4-95A1-4DD9-9E08-288BC0AC2BAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7416c2cb-1809-4834-8989-e84ff033f15f", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/11/msg00032.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7ZLEHVP4LNAGER4ZDGUDS5V5YVQD6INF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/0f6e28f686dbb59ab3b562408ab9b2234797b9b1"}}