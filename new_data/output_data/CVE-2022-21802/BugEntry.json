{"buggy_code": ["import { View } from '../../common';\nimport State from '../model/State';\n\nconst inputProp = 'contentEditable';\n\nexport default class ClassTagView extends View<State> {\n  template() {\n    const { pfx, model, config } = this;\n    const label = model.get('label') || '';\n\n    return `\n      <span id=\"${pfx}checkbox\" class=\"${pfx}tag-status\" data-tag-status></span>\n      <span id=\"${pfx}tag-label\" data-tag-name>${label}</span>\n      <span id=\"${pfx}close\" class=\"${pfx}tag-close\" data-tag-remove>\n        ${config.iconTagRemove}\n      </span>\n    `;\n  }\n\n  events() {\n    return {\n      'click [data-tag-remove]': 'removeTag',\n      'click [data-tag-status]': 'changeStatus',\n      'dblclick [data-tag-name]': 'startEditTag',\n      'focusout [data-tag-name]': 'endEditTag',\n    };\n  }\n  config: any;\n  module: any;\n  coll: any;\n  pfx: any;\n  ppfx: any;\n  em: any;\n  inputEl?: HTMLElement;\n\n  constructor(o: any = {}) {\n    super(o);\n    const config = o.config || {};\n    this.config = config;\n    this.module = o.module;\n    this.coll = o.coll || null;\n    this.pfx = config.stylePrefix || '';\n    this.ppfx = config.pStylePrefix || '';\n    this.em = config.em;\n    this.listenTo(this.model, 'change:active', this.updateStatus);\n  }\n\n  /**\n   * Returns the element which containes the anme of the tag\n   * @return {HTMLElement}\n   */\n  getInputEl() {\n    if (!this.inputEl) {\n      this.inputEl = this.el.querySelector('[data-tag-name]') as HTMLElement;\n    }\n\n    return this.inputEl;\n  }\n\n  /**\n   * Start editing tag\n   * @private\n   */\n  startEditTag() {\n    const { em } = this;\n    const inputEl = this.getInputEl();\n    inputEl;\n    inputEl[inputProp] = 'true';\n    inputEl.focus();\n    em && em.setEditing(1);\n  }\n\n  /**\n   * End editing tag. If the class typed already exists the\n   * old one will be restored otherwise will be changed\n   * @private\n   */\n  endEditTag() {\n    const model = this.model;\n    const inputEl = this.getInputEl();\n    const label = inputEl.textContent;\n    const em = this.em;\n    const sm = em && em.get('SelectorManager');\n    inputEl[inputProp] = 'false';\n    em && em.setEditing(0);\n\n    if (sm) {\n      const name = sm.escapeName(label);\n\n      if (sm.get(name)) {\n        inputEl.innerText = model.get('label');\n      } else {\n        model.set({ name, label });\n      }\n    }\n  }\n\n  /**\n   * Update status of the tag\n   * @private\n   */\n  changeStatus() {\n    const { model } = this;\n    model.set('active', !model.get('active'));\n  }\n\n  /**\n   * Remove tag from the selected component\n   * @param {Object} e\n   * @private\n   */\n  removeTag() {\n    this.module.removeSelected(this.model);\n  }\n\n  /**\n   * Update status of the checkbox\n   * @private\n   */\n  updateStatus() {\n    const { model, $el, config } = this;\n    const { iconTagOn, iconTagOff } = config;\n    const $chk = $el.find('[data-tag-status]');\n\n    if (model.get('active')) {\n      $chk.html(iconTagOn);\n      $el.removeClass('opac50');\n    } else {\n      $chk.html(iconTagOff);\n      $el.addClass('opac50');\n    }\n  }\n\n  render() {\n    const pfx = this.pfx;\n    const ppfx = this.ppfx;\n    this.$el.html(this.template());\n    this.$el.attr('class', `${pfx}tag ${ppfx}three-bg`);\n    this.updateStatus();\n    return this;\n  }\n}\n", "import { isEmpty, isArray, isString, debounce } from 'underscore';\nimport { View } from '../../common';\nimport ClassTagView from './ClassTagView';\nimport html from '../../utils/html';\nimport EditorModel from '../../editor/model/Editor';\nimport SelectorManager from '..';\nimport State from '../model/State';\nimport Component from '../../dom_components/model/Component';\nimport Selector from '../model/Selector';\nimport Selectors from '../model/Selectors';\n\nexport default class ClassTagsView extends View<Selector> {\n  template({ labelInfo, labelHead, iconSync, iconAdd, pfx, ppfx }: any) {\n    return `\n    <div id=\"${pfx}up\" class=\"${pfx}header\">\n      <div id=\"${pfx}label\" class=\"${pfx}header-label\">${labelHead}</div>\n      <div id=\"${pfx}status-c\" class=\"${pfx}header-status\">\n        <span id=\"${pfx}input-c\" data-states-c>\n          <div class=\"${ppfx}field ${ppfx}select\">\n            <span id=\"${ppfx}input-holder\">\n              <select id=\"${pfx}states\" data-states></select>\n            </span>\n            <div class=\"${ppfx}sel-arrow\">\n              <div class=\"${ppfx}d-s-arrow\"></div>\n            </div>\n          </div>\n        </span>\n      </div>\n    </div>\n    <div id=\"${pfx}tags-field\" class=\"${ppfx}field\">\n      <div id=\"${pfx}tags-c\" data-selectors></div>\n      <input id=\"${pfx}new\" data-input/>\n      <span id=\"${pfx}add-tag\" class=\"${pfx}tags-btn ${pfx}tags-btn__add\" data-add>\n        ${iconAdd}\n      </span>\n      <span class=\"${pfx}tags-btn ${pfx}tags-btn__sync\" style=\"display: none\" data-sync-style>\n        ${iconSync}\n      </span>\n    </div>\n    <div class=\"${pfx}sels-info\">\n      <div class=\"${pfx}label-sel\">${labelInfo}:</div>\n      <div class=\"${pfx}sels\" data-selected></div>\n    </div>`;\n  }\n\n  events() {\n    return {\n      'change [data-states]': 'stateChanged',\n      'click [data-add]': 'startNewTag',\n      'focusout [data-input]': 'endNewTag',\n      'keyup [data-input]': 'onInputKeyUp',\n      'click [data-sync-style]': 'syncStyle',\n    };\n  }\n\n  $input?: JQuery<HTMLElement>;\n  $addBtn?: JQuery<HTMLElement>;\n  $classes?: JQuery<HTMLElement>;\n  $btnSyncEl?: JQuery<HTMLElement>;\n  $states?: JQuery<HTMLElement>;\n  $statesC?: JQuery<HTMLElement>;\n  em: EditorModel;\n  target: EditorModel;\n  module: SelectorManager;\n\n  pfx: string;\n  ppfx: string;\n  stateInputId: string;\n  stateInputC: string;\n  config: any;\n  states: State[];\n\n  constructor(o: any = {}) {\n    super(o);\n    this.config = o.config || {};\n    this.pfx = this.config.stylePrefix || '';\n    this.ppfx = this.config.pStylePrefix || '';\n    this.className = this.pfx + 'tags';\n    this.stateInputId = this.pfx + 'states';\n    this.stateInputC = this.pfx + 'input-c';\n    this.states = this.config.states || [];\n    const { em } = this.config;\n    const coll = this.collection;\n    this.target = em;\n    const md = em.get('SelectorManager');\n    this.module = md;\n    this.em = em;\n    this.componentChanged = debounce(this.componentChanged.bind(this), 0);\n    this.checkSync = debounce(this.checkSync.bind(this), 0);\n    const toList = 'component:toggled component:update:classes';\n    const toListCls = 'component:update:classes change:state';\n    this.listenTo(em, toList, this.componentChanged);\n    this.listenTo(em, 'styleManager:update', this.componentChanged);\n    this.listenTo(em, toListCls, this.__handleStateChange);\n    this.listenTo(em, 'styleable:change change:device', this.checkSync); // component:styleUpdate\n    this.listenTo(coll, 'add', this.addNew);\n    this.listenTo(coll, 'reset', this.renderClasses);\n    this.listenTo(coll, 'remove', this.tagRemoved);\n    this.listenTo(\n      md.getAll(),\n      md.events.state,\n      debounce(() => this.renderStates(), 0)\n    );\n    this.delegateEvents();\n  }\n\n  syncStyle() {\n    const { em } = this;\n    const target = this.getTarget();\n    const cssC = em.get('CssComposer');\n    const opts = { noDisabled: 1 };\n    const selectors = this.getCommonSelectors({ opts });\n    const state = em.get('state');\n    const mediaText = em.getCurrentMedia();\n    const ruleComponents: CSSRule[] = [];\n    const rule = cssC.get(selectors, state, mediaText) || cssC.add(selectors, state, mediaText);\n    let style;\n\n    this.getTargets().forEach(target => {\n      const ruleComponent = cssC.getIdRule(target.getId(), {\n        state,\n        mediaText,\n      });\n      style = ruleComponent.getStyle();\n      ruleComponent.setStyle({});\n      ruleComponents.push(ruleComponent);\n    });\n\n    style && rule.addStyle(style);\n    em.trigger('component:toggled');\n    em.trigger('component:sync-style', {\n      component: target,\n      selectors,\n      mediaText,\n      rule,\n      ruleComponents,\n      state,\n    });\n  }\n\n  /**\n   * Triggered when a tag is removed from collection\n   * @param {Object} model Removed model\n   * @private\n   */\n  tagRemoved(model?: State) {\n    this.updateStateVis();\n  }\n\n  /**\n   * Add new model\n   * @param {Object} model\n   * @private\n   */\n  addNew(model: State) {\n    this.addToClasses(model);\n  }\n\n  /**\n   * Start tag creation\n   * @param {Object} e\n   * @private\n   */\n  startNewTag() {\n    this.$addBtn?.css({ display: 'none' });\n    this.$input?.show().focus();\n  }\n\n  /**\n   * End tag creation\n   * @param {Object} e\n   * @private\n   */\n  endNewTag() {\n    this.$addBtn?.css({ display: '' });\n    this.$input?.hide().val('');\n  }\n\n  /**\n   * Checks what to do on keyup event\n   * @param  {Object} e\n   * @private\n   */\n  onInputKeyUp(e: KeyboardEvent) {\n    if (e.keyCode === 13) {\n      e.preventDefault();\n      this.addNewTag(this.$input?.val());\n    } else if (e.keyCode === 27) {\n      this.endNewTag();\n    }\n  }\n\n  checkStates() {\n    const state = this.em.getState();\n    const statesEl = this.getStates();\n    statesEl && statesEl.val(state);\n  }\n\n  /**\n   * Triggered when component is changed\n   * @param  {Object} e\n   * @public\n   */\n  componentChanged({ targets }: any = {}) {\n    this.updateSelection(targets);\n  }\n\n  updateSelection(targets: Component | Component[]) {\n    let trgs = targets || this.getTargets();\n    trgs = isArray(trgs) ? trgs : [trgs];\n    let selectors: Selector[] = [];\n\n    if (trgs && trgs.length) {\n      selectors = this.getCommonSelectors({ targets: trgs });\n      //@ts-ignore TODO This parameters are not in use why do we have them?\n      this.checkSync({ validSelectors: selectors });\n    }\n\n    this.collection.reset(selectors);\n    this.updateStateVis(trgs);\n    this.module.__trgCustom();\n    return selectors;\n  }\n\n  getCommonSelectors({ targets, opts = {} }: any = {}) {\n    const trgs = targets || this.getTargets();\n    return this.module.__getCommonSelectors(trgs, opts);\n  }\n\n  _commonSelectors(...args: any) {\n    return this.module.__common(...args);\n  }\n\n  checkSync() {\n    const { $btnSyncEl, config, collection } = this;\n    const target = this.getTarget();\n    let hasStyle;\n\n    if (target && config.componentFirst && collection.length) {\n      const style = target.getStyle();\n      hasStyle = !isEmpty(style);\n    }\n\n    $btnSyncEl && $btnSyncEl[hasStyle ? 'show' : 'hide']();\n  }\n\n  getTarget() {\n    return this.target.getSelected();\n  }\n\n  getTargets() {\n    return this.target.getSelectedAll();\n  }\n\n  /**\n   * Update states visibility. Hides states in case there is no tags\n   * inside collection\n   * @private\n   */\n  updateStateVis(targets?: Component[] | Component) {\n    const em = this.em;\n    const avoidInline = em && em.getConfig().avoidInlineStyle;\n    const display = this.collection.length || avoidInline ? '' : 'none';\n    this.getStatesC().css('display', display);\n    this.updateSelector(targets);\n  }\n\n  __handleStateChange() {\n    this.updateSelector(this.getTargets());\n  }\n\n  /**\n   * Update selector helper\n   * @return {this}\n   * @private\n   */\n  updateSelector(targets?: Component[] | Component) {\n    const elSel = this.el.querySelector('[data-selected]');\n    const result: string[] = [];\n    let trgs = targets || this.getTargets();\n    trgs = isArray(trgs) ? trgs : [trgs];\n\n    trgs.forEach(target => result.push(this.__getName(target)));\n    elSel && (elSel.innerHTML = result.join(', '));\n    this.checkStates();\n  }\n\n  __getName(target: Component): string {\n    const { pfx, config, em } = this;\n    const { selectedName, componentFirst } = config;\n    let result;\n\n    if (isString(target)) {\n      result = html`<span class=\"${pfx}sel-gen\">${target}</span>`;\n    } else {\n      const sel = target?.getSelectors();\n      if (!sel) return '';\n      const selectors = sel.getStyleable();\n      const state = em.get('state');\n      const idRes = target.getId\n        ? html`<span class=\"${pfx}sel-cmp\">${target.getName()}</span>\n            <span class=\"${pfx}sel-id\">#${target.getId()}</span>`\n        : '';\n      result = (this.collection as Selectors).getFullString(selectors);\n      result = result ? html`<span class=\"${pfx}sel-rule\">${result}</span>` : target.get('selectorsAdd') || idRes;\n      result = componentFirst && idRes ? idRes : result;\n      result += state ? html`<span class=\"${pfx}sel-state\">:${state}</span>` : '';\n      result = selectedName ? selectedName({ result, state, target }) : result;\n    }\n\n    return result && `<span class=\"${pfx}sel\">${result}</span>`;\n  }\n\n  /**\n   * Triggered when the select with states is changed\n   * @param  {Object} e\n   * @private\n   */\n  stateChanged(ev: any) {\n    const { em } = this;\n    const { value } = ev.target;\n    em.set('state', value);\n  }\n\n  /**\n   * Add new tag to collection, if possible, and to the component\n   * @param  {Object} e\n   * @private\n   */\n  addNewTag(value: any) {\n    const label = value.trim();\n    if (!label) return;\n    this.module.addSelected({ label });\n    this.endNewTag();\n    // this.updateStateVis(); // Check if required\n  }\n\n  /**\n   * Add new object to collection\n   * @param   {Object} model  Model\n   * @param   {Object} fragmentEl   Fragment collection\n   * @return {Object} Object created\n   * @private\n   * */\n  addToClasses(model: State, fragmentEl?: DocumentFragment) {\n    const fragment = fragmentEl;\n    const classes = this.getClasses();\n    const rendered = new ClassTagView({\n      model,\n      config: this.config,\n      coll: this.collection,\n      module: this.module,\n    }).render().el;\n\n    fragment ? fragment.appendChild(rendered) : classes.append(rendered);\n\n    return rendered;\n  }\n\n  /**\n   * Render the collection of classes\n   * @private\n   */\n  renderClasses() {\n    const frag = document.createDocumentFragment();\n    const classes = this.getClasses();\n    classes.empty();\n    this.collection.each(model => this.addToClasses(model, frag));\n    classes.append(frag);\n  }\n\n  /**\n   * Return classes element\n   * @return {HTMLElement}\n   * @private\n   */\n  getClasses() {\n    return this.$el.find('[data-selectors]');\n  }\n\n  /**\n   * Return states element\n   * @return {HTMLElement}\n   * @private\n   */\n  getStates() {\n    if (!this.$states) {\n      const el = this.$el.find('[data-states]');\n      this.$states = el[0] && el;\n    }\n    return this.$states;\n  }\n\n  /**\n   * Return states container element\n   * @return {HTMLElement}\n   * @private\n   */\n  getStatesC() {\n    if (!this.$statesC) this.$statesC = this.$el.find('#' + this.stateInputC);\n    return this.$statesC;\n  }\n\n  renderStates() {\n    const { module, em } = this;\n    const labelStates = em.t('selectorManager.emptyState');\n    const options = module\n      .getStates()\n      .map(state => {\n        const label = em.t(`selectorManager.states.${state.id}`) || state.getLabel() || state.id;\n        return `<option value=\"${state.id}\">${label}</option>`;\n      })\n      .join('');\n\n    const statesEl = this.getStates();\n    statesEl && statesEl.html(`<option value=\"\">${labelStates}</option>${options}`);\n    this.checkStates();\n  }\n\n  render() {\n    const { em, pfx, ppfx, config, $el, el } = this;\n    const { render, iconSync, iconAdd } = config;\n    const tmpOpts = {\n      iconSync,\n      iconAdd,\n      labelHead: em.t('selectorManager.label'),\n      labelInfo: em.t('selectorManager.selected'),\n      ppfx,\n      pfx,\n      el,\n    };\n    $el.html(this.template(tmpOpts));\n    const renderRes = render && render(tmpOpts);\n    renderRes && renderRes !== el && $el.empty().append(renderRes);\n    this.$input = $el.find('[data-input]');\n    this.$addBtn = $el.find('[data-add]');\n    this.$classes = $el.find('#' + pfx + 'tags-c');\n    this.$btnSyncEl = $el.find('[data-sync-style]');\n    this.$input.hide();\n    this.renderStates();\n    this.renderClasses();\n    $el.attr('class', `${this.className} ${ppfx}one-bg ${ppfx}two-color`);\n    return this;\n  }\n}\n"], "fixing_code": ["import { View } from '../../common';\nimport State from '../model/State';\nimport html from '../../utils/html';\n\nconst inputProp = 'contentEditable';\n\nexport default class ClassTagView extends View<State> {\n  template() {\n    const { pfx, model, config } = this;\n    const label = model.get('label') || '';\n\n    return html`\n      <span id=\"${pfx}checkbox\" class=\"${pfx}tag-status\" data-tag-status></span>\n      <span id=\"${pfx}tag-label\" data-tag-name>${label}</span>\n      <span id=\"${pfx}close\" class=\"${pfx}tag-close\" data-tag-remove> $${config.iconTagRemove} </span>\n    `;\n  }\n\n  events() {\n    return {\n      'click [data-tag-remove]': 'removeTag',\n      'click [data-tag-status]': 'changeStatus',\n      'dblclick [data-tag-name]': 'startEditTag',\n      'focusout [data-tag-name]': 'endEditTag',\n    };\n  }\n  config: any;\n  module: any;\n  coll: any;\n  pfx: any;\n  ppfx: any;\n  em: any;\n  inputEl?: HTMLElement;\n\n  constructor(o: any = {}) {\n    super(o);\n    const config = o.config || {};\n    this.config = config;\n    this.module = o.module;\n    this.coll = o.coll || null;\n    this.pfx = config.stylePrefix || '';\n    this.ppfx = config.pStylePrefix || '';\n    this.em = config.em;\n    this.listenTo(this.model, 'change:active', this.updateStatus);\n  }\n\n  /**\n   * Returns the element which containes the anme of the tag\n   * @return {HTMLElement}\n   */\n  getInputEl() {\n    if (!this.inputEl) {\n      this.inputEl = this.el.querySelector('[data-tag-name]') as HTMLElement;\n    }\n\n    return this.inputEl;\n  }\n\n  /**\n   * Start editing tag\n   * @private\n   */\n  startEditTag() {\n    const { em } = this;\n    const inputEl = this.getInputEl();\n    inputEl;\n    inputEl[inputProp] = 'true';\n    inputEl.focus();\n    em && em.setEditing(1);\n  }\n\n  /**\n   * End editing tag. If the class typed already exists the\n   * old one will be restored otherwise will be changed\n   * @private\n   */\n  endEditTag() {\n    const model = this.model;\n    const inputEl = this.getInputEl();\n    const label = inputEl.textContent;\n    const em = this.em;\n    const sm = em && em.get('SelectorManager');\n    inputEl[inputProp] = 'false';\n    em && em.setEditing(0);\n\n    if (sm) {\n      const name = sm.escapeName(label);\n\n      if (sm.get(name)) {\n        inputEl.innerText = model.get('label');\n      } else {\n        model.set({ name, label });\n      }\n    }\n  }\n\n  /**\n   * Update status of the tag\n   * @private\n   */\n  changeStatus() {\n    const { model } = this;\n    model.set('active', !model.get('active'));\n  }\n\n  /**\n   * Remove tag from the selected component\n   * @param {Object} e\n   * @private\n   */\n  removeTag() {\n    this.module.removeSelected(this.model);\n  }\n\n  /**\n   * Update status of the checkbox\n   * @private\n   */\n  updateStatus() {\n    const { model, $el, config } = this;\n    const { iconTagOn, iconTagOff } = config;\n    const $chk = $el.find('[data-tag-status]');\n\n    if (model.get('active')) {\n      $chk.html(iconTagOn);\n      $el.removeClass('opac50');\n    } else {\n      $chk.html(iconTagOff);\n      $el.addClass('opac50');\n    }\n  }\n\n  render() {\n    const pfx = this.pfx;\n    const ppfx = this.ppfx;\n    this.$el.html(this.template());\n    this.$el.attr('class', `${pfx}tag ${ppfx}three-bg`);\n    this.updateStatus();\n    return this;\n  }\n}\n", "import { isEmpty, isArray, isString, debounce } from 'underscore';\nimport { View } from '../../common';\nimport ClassTagView from './ClassTagView';\nimport html from '../../utils/html';\nimport EditorModel from '../../editor/model/Editor';\nimport SelectorManager from '..';\nimport State from '../model/State';\nimport Component from '../../dom_components/model/Component';\nimport Selector from '../model/Selector';\nimport Selectors from '../model/Selectors';\n\nexport default class ClassTagsView extends View<Selector> {\n  template({ labelInfo, labelHead, iconSync, iconAdd, pfx, ppfx }: any) {\n    return html` <div id=\"${pfx}up\" class=\"${pfx}header\">\n        <div id=\"${pfx}label\" class=\"${pfx}header-label\">${labelHead}</div>\n        <div id=\"${pfx}status-c\" class=\"${pfx}header-status\">\n          <span id=\"${pfx}input-c\" data-states-c>\n            <div class=\"${ppfx}field ${ppfx}select\">\n              <span id=\"${ppfx}input-holder\">\n                <select id=\"${pfx}states\" data-states></select>\n              </span>\n              <div class=\"${ppfx}sel-arrow\">\n                <div class=\"${ppfx}d-s-arrow\"></div>\n              </div>\n            </div>\n          </span>\n        </div>\n      </div>\n      <div id=\"${pfx}tags-field\" class=\"${ppfx}field\">\n        <div id=\"${pfx}tags-c\" data-selectors></div>\n        <input id=\"${pfx}new\" data-input />\n        <span id=\"${pfx}add-tag\" class=\"${pfx}tags-btn ${pfx}tags-btn__add\" data-add> $${iconAdd} </span>\n        <span class=\"${pfx}tags-btn ${pfx}tags-btn__sync\" style=\"display: none\" data-sync-style> $${iconSync} </span>\n      </div>\n      <div class=\"${pfx}sels-info\">\n        <div class=\"${pfx}label-sel\">${labelInfo}:</div>\n        <div class=\"${pfx}sels\" data-selected></div>\n      </div>`;\n  }\n\n  events() {\n    return {\n      'change [data-states]': 'stateChanged',\n      'click [data-add]': 'startNewTag',\n      'focusout [data-input]': 'endNewTag',\n      'keyup [data-input]': 'onInputKeyUp',\n      'click [data-sync-style]': 'syncStyle',\n    };\n  }\n\n  $input?: JQuery<HTMLElement>;\n  $addBtn?: JQuery<HTMLElement>;\n  $classes?: JQuery<HTMLElement>;\n  $btnSyncEl?: JQuery<HTMLElement>;\n  $states?: JQuery<HTMLElement>;\n  $statesC?: JQuery<HTMLElement>;\n  em: EditorModel;\n  target: EditorModel;\n  module: SelectorManager;\n\n  pfx: string;\n  ppfx: string;\n  stateInputId: string;\n  stateInputC: string;\n  config: any;\n  states: State[];\n\n  constructor(o: any = {}) {\n    super(o);\n    this.config = o.config || {};\n    this.pfx = this.config.stylePrefix || '';\n    this.ppfx = this.config.pStylePrefix || '';\n    this.className = this.pfx + 'tags';\n    this.stateInputId = this.pfx + 'states';\n    this.stateInputC = this.pfx + 'input-c';\n    this.states = this.config.states || [];\n    const { em } = this.config;\n    const coll = this.collection;\n    this.target = em;\n    const md = em.get('SelectorManager');\n    this.module = md;\n    this.em = em;\n    this.componentChanged = debounce(this.componentChanged.bind(this), 0);\n    this.checkSync = debounce(this.checkSync.bind(this), 0);\n    const toList = 'component:toggled component:update:classes';\n    const toListCls = 'component:update:classes change:state';\n    this.listenTo(em, toList, this.componentChanged);\n    this.listenTo(em, 'styleManager:update', this.componentChanged);\n    this.listenTo(em, toListCls, this.__handleStateChange);\n    this.listenTo(em, 'styleable:change change:device', this.checkSync); // component:styleUpdate\n    this.listenTo(coll, 'add', this.addNew);\n    this.listenTo(coll, 'reset', this.renderClasses);\n    this.listenTo(coll, 'remove', this.tagRemoved);\n    this.listenTo(\n      md.getAll(),\n      md.events.state,\n      debounce(() => this.renderStates(), 0)\n    );\n    this.delegateEvents();\n  }\n\n  syncStyle() {\n    const { em } = this;\n    const target = this.getTarget();\n    const cssC = em.get('CssComposer');\n    const opts = { noDisabled: 1 };\n    const selectors = this.getCommonSelectors({ opts });\n    const state = em.get('state');\n    const mediaText = em.getCurrentMedia();\n    const ruleComponents: CSSRule[] = [];\n    const rule = cssC.get(selectors, state, mediaText) || cssC.add(selectors, state, mediaText);\n    let style;\n\n    this.getTargets().forEach(target => {\n      const ruleComponent = cssC.getIdRule(target.getId(), {\n        state,\n        mediaText,\n      });\n      style = ruleComponent.getStyle();\n      ruleComponent.setStyle({});\n      ruleComponents.push(ruleComponent);\n    });\n\n    style && rule.addStyle(style);\n    em.trigger('component:toggled');\n    em.trigger('component:sync-style', {\n      component: target,\n      selectors,\n      mediaText,\n      rule,\n      ruleComponents,\n      state,\n    });\n  }\n\n  /**\n   * Triggered when a tag is removed from collection\n   * @param {Object} model Removed model\n   * @private\n   */\n  tagRemoved(model?: State) {\n    this.updateStateVis();\n  }\n\n  /**\n   * Add new model\n   * @param {Object} model\n   * @private\n   */\n  addNew(model: State) {\n    this.addToClasses(model);\n  }\n\n  /**\n   * Start tag creation\n   * @param {Object} e\n   * @private\n   */\n  startNewTag() {\n    this.$addBtn?.css({ display: 'none' });\n    this.$input?.show().focus();\n  }\n\n  /**\n   * End tag creation\n   * @param {Object} e\n   * @private\n   */\n  endNewTag() {\n    this.$addBtn?.css({ display: '' });\n    this.$input?.hide().val('');\n  }\n\n  /**\n   * Checks what to do on keyup event\n   * @param  {Object} e\n   * @private\n   */\n  onInputKeyUp(e: KeyboardEvent) {\n    if (e.keyCode === 13) {\n      e.preventDefault();\n      this.addNewTag(this.$input?.val());\n    } else if (e.keyCode === 27) {\n      this.endNewTag();\n    }\n  }\n\n  checkStates() {\n    const state = this.em.getState();\n    const statesEl = this.getStates();\n    statesEl && statesEl.val(state);\n  }\n\n  /**\n   * Triggered when component is changed\n   * @param  {Object} e\n   * @public\n   */\n  componentChanged({ targets }: any = {}) {\n    this.updateSelection(targets);\n  }\n\n  updateSelection(targets: Component | Component[]) {\n    let trgs = targets || this.getTargets();\n    trgs = isArray(trgs) ? trgs : [trgs];\n    let selectors: Selector[] = [];\n\n    if (trgs && trgs.length) {\n      selectors = this.getCommonSelectors({ targets: trgs });\n      //@ts-ignore TODO This parameters are not in use why do we have them?\n      this.checkSync({ validSelectors: selectors });\n    }\n\n    this.collection.reset(selectors);\n    this.updateStateVis(trgs);\n    this.module.__trgCustom();\n    return selectors;\n  }\n\n  getCommonSelectors({ targets, opts = {} }: any = {}) {\n    const trgs = targets || this.getTargets();\n    return this.module.__getCommonSelectors(trgs, opts);\n  }\n\n  _commonSelectors(...args: any) {\n    return this.module.__common(...args);\n  }\n\n  checkSync() {\n    const { $btnSyncEl, config, collection } = this;\n    const target = this.getTarget();\n    let hasStyle;\n\n    if (target && config.componentFirst && collection.length) {\n      const style = target.getStyle();\n      hasStyle = !isEmpty(style);\n    }\n\n    $btnSyncEl && $btnSyncEl[hasStyle ? 'show' : 'hide']();\n  }\n\n  getTarget() {\n    return this.target.getSelected();\n  }\n\n  getTargets() {\n    return this.target.getSelectedAll();\n  }\n\n  /**\n   * Update states visibility. Hides states in case there is no tags\n   * inside collection\n   * @private\n   */\n  updateStateVis(targets?: Component[] | Component) {\n    const em = this.em;\n    const avoidInline = em && em.getConfig().avoidInlineStyle;\n    const display = this.collection.length || avoidInline ? '' : 'none';\n    this.getStatesC().css('display', display);\n    this.updateSelector(targets);\n  }\n\n  __handleStateChange() {\n    this.updateSelector(this.getTargets());\n  }\n\n  /**\n   * Update selector helper\n   * @return {this}\n   * @private\n   */\n  updateSelector(targets?: Component[] | Component) {\n    const elSel = this.el.querySelector('[data-selected]');\n    const result: string[] = [];\n    let trgs = targets || this.getTargets();\n    trgs = isArray(trgs) ? trgs : [trgs];\n\n    trgs.forEach(target => result.push(this.__getName(target)));\n    elSel && (elSel.innerHTML = result.join(', '));\n    this.checkStates();\n  }\n\n  __getName(target: Component): string {\n    const { pfx, config, em } = this;\n    const { selectedName, componentFirst } = config;\n    let result;\n\n    if (isString(target)) {\n      result = html`<span class=\"${pfx}sel-gen\">${target}</span>`;\n    } else {\n      const sel = target?.getSelectors();\n      if (!sel) return '';\n      const selectors = sel.getStyleable();\n      const state = em.get('state');\n      const idRes = target.getId\n        ? html`<span class=\"${pfx}sel-cmp\">${target.getName()}</span>\n            <span class=\"${pfx}sel-id\">#${target.getId()}</span>`\n        : '';\n      result = (this.collection as Selectors).getFullString(selectors);\n      result = result ? html`<span class=\"${pfx}sel-rule\">${result}</span>` : target.get('selectorsAdd') || idRes;\n      result = componentFirst && idRes ? idRes : result;\n      result += state ? html`<span class=\"${pfx}sel-state\">:${state}</span>` : '';\n      result = selectedName ? selectedName({ result, state, target }) : result;\n    }\n\n    return result && `<span class=\"${pfx}sel\">${result}</span>`;\n  }\n\n  /**\n   * Triggered when the select with states is changed\n   * @param  {Object} e\n   * @private\n   */\n  stateChanged(ev: any) {\n    const { em } = this;\n    const { value } = ev.target;\n    em.set('state', value);\n  }\n\n  /**\n   * Add new tag to collection, if possible, and to the component\n   * @param  {Object} e\n   * @private\n   */\n  addNewTag(value: any) {\n    const label = value.trim();\n    if (!label) return;\n    this.module.addSelected({ label });\n    this.endNewTag();\n    // this.updateStateVis(); // Check if required\n  }\n\n  /**\n   * Add new object to collection\n   * @param   {Object} model  Model\n   * @param   {Object} fragmentEl   Fragment collection\n   * @return {Object} Object created\n   * @private\n   * */\n  addToClasses(model: State, fragmentEl?: DocumentFragment) {\n    const fragment = fragmentEl;\n    const classes = this.getClasses();\n    const rendered = new ClassTagView({\n      model,\n      config: this.config,\n      coll: this.collection,\n      module: this.module,\n    }).render().el;\n\n    fragment ? fragment.appendChild(rendered) : classes.append(rendered);\n\n    return rendered;\n  }\n\n  /**\n   * Render the collection of classes\n   * @private\n   */\n  renderClasses() {\n    const frag = document.createDocumentFragment();\n    const classes = this.getClasses();\n    classes.empty();\n    this.collection.each(model => this.addToClasses(model, frag));\n    classes.append(frag);\n  }\n\n  /**\n   * Return classes element\n   * @return {HTMLElement}\n   * @private\n   */\n  getClasses() {\n    return this.$el.find('[data-selectors]');\n  }\n\n  /**\n   * Return states element\n   * @return {HTMLElement}\n   * @private\n   */\n  getStates() {\n    if (!this.$states) {\n      const el = this.$el.find('[data-states]');\n      this.$states = el[0] && el;\n    }\n    return this.$states;\n  }\n\n  /**\n   * Return states container element\n   * @return {HTMLElement}\n   * @private\n   */\n  getStatesC() {\n    if (!this.$statesC) this.$statesC = this.$el.find('#' + this.stateInputC);\n    return this.$statesC;\n  }\n\n  renderStates() {\n    const { module, em } = this;\n    const labelStates = em.t('selectorManager.emptyState');\n    const options = module\n      .getStates()\n      .map(state => {\n        const label = em.t(`selectorManager.states.${state.id}`) || state.getLabel() || state.id;\n        return `<option value=\"${state.id}\">${label}</option>`;\n      })\n      .join('');\n\n    const statesEl = this.getStates();\n    statesEl && statesEl.html(`<option value=\"\">${labelStates}</option>${options}`);\n    this.checkStates();\n  }\n\n  render() {\n    const { em, pfx, ppfx, config, $el, el } = this;\n    const { render, iconSync, iconAdd } = config;\n    const tmpOpts = {\n      iconSync,\n      iconAdd,\n      labelHead: em.t('selectorManager.label'),\n      labelInfo: em.t('selectorManager.selected'),\n      ppfx,\n      pfx,\n      el,\n    };\n    $el.html(this.template(tmpOpts));\n    const renderRes = render && render(tmpOpts);\n    renderRes && renderRes !== el && $el.empty().append(renderRes);\n    this.$input = $el.find('[data-input]');\n    this.$addBtn = $el.find('[data-add]');\n    this.$classes = $el.find('#' + pfx + 'tags-c');\n    this.$btnSyncEl = $el.find('[data-sync-style]');\n    this.$input.hide();\n    this.renderStates();\n    this.renderClasses();\n    $el.attr('class', `${this.className} ${ppfx}one-bg ${ppfx}two-color`);\n    return this;\n  }\n}\n"], "filenames": ["src/selector_manager/view/ClassTagView.ts", "src/selector_manager/view/ClassTagsView.ts"], "buggy_code_start_loc": [2, 14], "buggy_code_end_loc": [17, 44], "fixing_code_start_loc": [3, 14], "fixing_code_end_loc": [16, 39], "type": "CWE-79", "message": "The package grapesjs before 0.19.5 are vulnerable to Cross-site Scripting (XSS) due to an improper sanitization of the class name in Selector Manager.", "other": {"cve": {"id": "CVE-2022-21802", "sourceIdentifier": "report@snyk.io", "published": "2022-07-25T14:15:10.817", "lastModified": "2022-07-27T19:30:42.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package grapesjs before 0.19.5 are vulnerable to Cross-site Scripting (XSS) due to an improper sanitization of the class name in Selector Manager."}, {"lang": "es", "value": "El paquete grapesjs versiones anteriores a 0.19.5, es vulnerable a un ataque de tipo Cross-site Scripting (XSS) debido a un saneamiento inapropiado del nombre de la clase en el Selector Manager"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grapesjs:grapesjs:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.19.5", "matchCriteriaId": "E6B41B38-278B-4B3D-9F4B-4BDD6D9466CD"}]}]}], "references": [{"url": "https://github.com/artf/grapesjs/commit/13e85d152d486b968265c4b8017e8901e7d89ff3", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/artf/grapesjs/issues/4411%23issuecomment-1167202709", "source": "report@snyk.io", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/artf/grapesjs/releases/tag/v0.19.5", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-2936781", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-GRAPESJS-2935960", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/artf/grapesjs/commit/13e85d152d486b968265c4b8017e8901e7d89ff3"}}