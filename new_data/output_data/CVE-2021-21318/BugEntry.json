{"buggy_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl;\n\nimport static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSerializer;\nimport org.opencastproject.metadata.api.StaticMetadataService;\nimport org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;\nimport org.opencastproject.search.api.SearchException;\nimport org.opencastproject.search.api.SearchQuery;\nimport org.opencastproject.search.api.SearchResult;\nimport org.opencastproject.search.api.SearchService;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabase;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;\nimport org.opencastproject.search.impl.solr.SolrIndexManager;\nimport org.opencastproject.search.impl.solr.SolrRequester;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.AuthorizationService;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.StaticFileAuthorization;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.solr.SolrServerFactory;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\nimport org.opencastproject.workspace.api.Workspace;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.solr.client.solrj.SolrServer;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.osgi.framework.ServiceException;\nimport org.osgi.service.cm.ConfigurationException;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A Solr-based {@link SearchService} implementation.\n */\npublic final class SearchServiceImpl extends AbstractJobProducer implements SearchService, ManagedService,\n    StaticFileAuthorization {\n\n  /** Log facility */\n  private static final Logger logger = LoggerFactory.getLogger(SearchServiceImpl.class);\n\n  /** Configuration key for a remote solr server */\n  public static final String CONFIG_SOLR_URL = \"org.opencastproject.search.solr.url\";\n\n  /** Configuration key for an embedded solr configuration and data directory */\n  public static final String CONFIG_SOLR_ROOT = \"org.opencastproject.search.solr.dir\";\n\n  /** The job type */\n  public static final String JOB_TYPE = \"org.opencastproject.search\";\n\n  /** The load introduced on the system by creating an add job */\n  public static final float DEFAULT_ADD_JOB_LOAD = 0.1f;\n\n  /** The load introduced on the system by creating a delete job */\n  public static final float DEFAULT_DELETE_JOB_LOAD = 0.1f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_ADD_JOB_LOAD} */\n  public static final String ADD_JOB_LOAD_KEY = \"job.load.add\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_DELETE_JOB_LOAD} */\n  public static final String DELETE_JOB_LOAD_KEY = \"job.load.delete\";\n\n  /** The load introduced on the system by creating an add job */\n  private float addJobLoad = DEFAULT_ADD_JOB_LOAD;\n\n  /** The load introduced on the system by creating a delete job */\n  private float deleteJobLoad = DEFAULT_DELETE_JOB_LOAD;\n\n  /** counter how often the index has already been tried to populate */\n  private int retriesToPopulateIndex = 0;\n\n  /** List of available operations on jobs */\n  private enum Operation {\n    Add, Delete\n  };\n\n  /** Solr server */\n  private SolrServer solrServer;\n\n  private SolrRequester solrRequester;\n\n  private SolrIndexManager indexManager;\n\n  private List<StaticMetadataService> mdServices = new ArrayList<StaticMetadataService>();\n\n  private Mpeg7CatalogService mpeg7CatalogService;\n\n  private SeriesService seriesService;\n\n  /** The local workspace */\n  private Workspace workspace;\n\n  /** The security service */\n  private SecurityService securityService;\n\n  /** The authorization service */\n  private AuthorizationService authorizationService;\n\n  /** The service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** Persistent storage */\n  private SearchServiceDatabase persistence;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectory = null;\n\n  /** The optional Mediapackage serializer */\n  protected MediaPackageSerializer serializer = null;\n\n  private LoadingCache<Tuple<User, String>, Boolean> cache = null;\n\n  private static final Pattern staticFilePattern = Pattern.compile(\"^/([^/]+)/engage-player/([^/]+)/.*$\");\n\n  /**\n   * Creates a new instance of the search service.\n   */\n  public SearchServiceImpl() {\n    super(JOB_TYPE);\n\n    cache = CacheBuilder.newBuilder()\n        .maximumSize(2048)\n        .expireAfterWrite(1, TimeUnit.MINUTES)\n        .build(new CacheLoader<Tuple<User, String>, Boolean>() {\n          @Override\n          public Boolean load(Tuple<User, String> key) {\n            return loadUrlAccess(key.getB());\n          }\n        });\n  }\n\n  /**\n   * Return the solr index manager\n   *\n   * @return indexManager\n   */\n  public SolrIndexManager getSolrIndexManager() {\n    return indexManager;\n  }\n\n  /**\n   * Service activator, called via declarative services configuration. If the solr server url is configured, we try to\n   * connect to it. If not, the solr data directory with an embedded Solr server is used.\n   *\n   * @param cc\n   *          the component context\n   */\n  @Override\n  public void activate(final ComponentContext cc) throws IllegalStateException {\n    super.activate(cc);\n    final String solrServerUrlConfig = StringUtils.trimToNull(cc.getBundleContext().getProperty(CONFIG_SOLR_URL));\n\n    logger.info(\"Setting up solr server\");\n\n    solrServer = new Object() {\n      SolrServer create() {\n        if (solrServerUrlConfig != null) {\n          /* Use external SOLR server */\n          try {\n            logger.info(\"Setting up solr server at {}\", solrServerUrlConfig);\n            URL solrServerUrl = new URL(solrServerUrlConfig);\n            return setupSolr(solrServerUrl);\n          } catch (MalformedURLException e) {\n            throw connectError(solrServerUrlConfig, e);\n          }\n        } else {\n          /* Set-up embedded SOLR */\n          String solrRoot = SolrServerFactory.getEmbeddedDir(cc, CONFIG_SOLR_ROOT, \"search\");\n\n          try {\n            logger.debug(\"Setting up solr server at {}\", solrRoot);\n            return setupSolr(new File(solrRoot));\n          } catch (IOException e) {\n            throw connectError(solrServerUrlConfig, e);\n          } catch (SolrServerException e) {\n            throw connectError(solrServerUrlConfig, e);\n          }\n        }\n      }\n\n      IllegalStateException connectError(String target, Exception e) {\n        logger.error(\"Unable to connect to solr at {}: {}\", target, e.getMessage());\n        return new IllegalStateException(\"Unable to connect to solr at \" + target, e);\n      }\n      // CHECKSTYLE:OFF\n    }.create();\n    // CHECKSTYLE:ON\n\n    solrRequester = new SolrRequester(solrServer, securityService, serializer);\n    indexManager = new SolrIndexManager(solrServer, workspace, mdServices, seriesService, mpeg7CatalogService,\n            securityService);\n\n    String systemUserName = cc.getBundleContext().getProperty(SecurityUtil.PROPERTY_KEY_SYS_USER);\n    populateIndex(systemUserName);\n  }\n\n  /**\n   * Service deactivator, called via declarative services configuration.\n   */\n  public void deactivate() {\n    SolrServerFactory.shutdown(solrServer);\n  }\n\n  /**\n   * Prepares the embedded solr environment.\n   *\n   * @param solrRoot\n   *          the solr root directory\n   */\n  static SolrServer setupSolr(File solrRoot) throws IOException, SolrServerException {\n    logger.info(\"Setting up solr search index at {}\", solrRoot);\n    File solrConfigDir = new File(solrRoot, \"conf\");\n\n    // Create the config directory\n    if (solrConfigDir.exists()) {\n      logger.info(\"solr search index found at {}\", solrConfigDir);\n    } else {\n      logger.info(\"solr config directory doesn't exist.  Creating {}\", solrConfigDir);\n      FileUtils.forceMkdir(solrConfigDir);\n    }\n\n    // Make sure there is a configuration in place\n    copyClasspathResourceToFile(\"/solr/conf/protwords.txt\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/schema.xml\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/scripts.conf\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/solrconfig.xml\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/stopwords.txt\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/synonyms.txt\", solrConfigDir);\n\n    // Test for the existence of a data directory\n    File solrDataDir = new File(solrRoot, \"data\");\n    if (!solrDataDir.exists()) {\n      FileUtils.forceMkdir(solrDataDir);\n    }\n\n    // Test for the existence of the index. Note that an empty index directory will prevent solr from\n    // completing normal setup.\n    File solrIndexDir = new File(solrDataDir, \"index\");\n    if (solrIndexDir.isDirectory() && solrIndexDir.list().length == 0) {\n      FileUtils.deleteDirectory(solrIndexDir);\n    }\n\n    return SolrServerFactory.newEmbeddedInstance(solrRoot, solrDataDir);\n  }\n\n  /**\n   * Prepares the embedded solr environment.\n   *\n   * @param url\n   *          the url of the remote solr server\n   */\n  static SolrServer setupSolr(URL url) {\n    logger.info(\"Connecting to solr search index at {}\", url);\n    return SolrServerFactory.newRemoteInstance(url);\n  }\n\n  // TODO: generalize this method\n  static void copyClasspathResourceToFile(String classpath, File dir) {\n    InputStream in = null;\n    FileOutputStream fos = null;\n    try {\n      in = SearchServiceImpl.class.getResourceAsStream(classpath);\n      File file = new File(dir, FilenameUtils.getName(classpath));\n      logger.debug(\"copying \" + classpath + \" to \" + file);\n      fos = new FileOutputStream(file);\n      IOUtils.copy(in, fos);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error copying solr classpath resource to the filesystem\", e);\n    } finally {\n      IOUtils.closeQuietly(in);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getByQuery(java.lang.String, int, int)\n   */\n  public SearchResult getByQuery(String query, int limit, int offset) throws SearchException {\n    try {\n      logger.debug(\"Searching index using custom query '\" + query + \"'\");\n      return solrRequester.getByQuery(query, limit, offset);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#add(org.opencastproject.mediapackage.MediaPackage)\n   */\n  public Job add(MediaPackage mediaPackage) throws SearchException, MediaPackageException, IllegalArgumentException,\n          UnauthorizedException, ServiceRegistryException {\n    try {\n      return serviceRegistry.createJob(JOB_TYPE, Operation.Add.toString(),\n              Arrays.asList(MediaPackageParser.getAsXml(mediaPackage)), addJobLoad);\n    } catch (ServiceRegistryException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Immediately adds the mediapackage to the search index.\n   *\n   * @param mediaPackage\n   *          the media package\n   * @throws SearchException\n   *           if the media package cannot be added to the search index\n   * @throws MediaPackageException\n   *           if the mediapckage is invalid\n   * @throws IllegalArgumentException\n   *           if the mediapackage is <code>null</code>\n   * @throws UnauthorizedException\n   *           if the user does not have the rights to add the mediapackage\n   */\n  public void addSynchronously(MediaPackage mediaPackage) throws SearchException, MediaPackageException,\n          IllegalArgumentException, UnauthorizedException {\n    if (mediaPackage == null) {\n      throw new IllegalArgumentException(\"Unable to add a null mediapackage\");\n    }\n    logger.debug(\"Attempting to add mediapackage {} to search index\", mediaPackage.getIdentifier());\n    AccessControlList acl = authorizationService.getActiveAcl(mediaPackage).getA();\n\n    Date now = new Date();\n\n    try {\n      if (indexManager.add(mediaPackage, acl, now)) {\n        logger.info(\"Added mediapackage `{}` to the search index, using ACL `{}`\", mediaPackage, acl);\n      } else {\n        logger.warn(\"Failed to add mediapackage {} to the search index\", mediaPackage.getIdentifier());\n      }\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n\n    try {\n      persistence.storeMediaPackage(mediaPackage, acl, now);\n    } catch (SearchServiceDatabaseException e) {\n      logger.error(\"Could not store media package to search database {}: {}\", mediaPackage.getIdentifier(), e);\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#delete(java.lang.String)\n   */\n  public Job delete(String mediaPackageId) throws SearchException, UnauthorizedException, NotFoundException {\n    try {\n      return serviceRegistry.createJob(JOB_TYPE, Operation.Delete.toString(), Arrays.asList(mediaPackageId), deleteJobLoad);\n    } catch (ServiceRegistryException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Immediately removes the given mediapackage from the search service.\n   *\n   * @param mediaPackageId\n   *          the mediapackage\n   * @return <code>true</code> if the mediapackage was deleted\n   * @throws SearchException\n   *           if deletion failed\n   * @throws UnauthorizedException\n   *           if the user did not have access to the media package\n   * @throws NotFoundException\n   *           if the mediapackage did not exist\n   */\n  public boolean deleteSynchronously(String mediaPackageId) throws SearchException, UnauthorizedException,\n          NotFoundException {\n    SearchResult result;\n    try {\n      result = solrRequester.getForWrite(new SearchQuery().withId(mediaPackageId));\n      if (result.getItems().length == 0) {\n        logger.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                mediaPackageId);\n        return false;\n      }\n      logger.info(\"Removing mediapackage {} from search index\", mediaPackageId);\n\n      Date now = new Date();\n      try {\n        persistence.deleteMediaPackage(mediaPackageId, now);\n        logger.info(\"Removed mediapackage {} from search persistence\", mediaPackageId);\n      } catch (NotFoundException e) {\n        // even if mp not found in persistence, it might still exist in search index.\n        logger.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                mediaPackageId);\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Could not delete media package with id {} from persistence storage\", mediaPackageId);\n        throw new SearchException(e);\n      }\n\n      return indexManager.delete(mediaPackageId, now);\n    } catch (SolrServerException e) {\n      logger.info(\"Could not delete media package with id {} from search index\", mediaPackageId);\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Clears the complete solr index.\n   *\n   * @throws SearchException\n   *           if clearing the index fails\n   */\n  public void clear() throws SearchException {\n    try {\n      logger.info(\"Clearing the search index\");\n      indexManager.clear();\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getByQuery(org.opencastproject.search.api.SearchQuery)\n   */\n  public SearchResult getByQuery(SearchQuery q) throws SearchException {\n    try {\n      logger.debug(\"Searching index using query object '\" + q + \"'\");\n      return solrRequester.getForRead(q);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getForAdministrativeRead(org.opencastproject.search.api.SearchQuery)\n   */\n  @Override\n  public SearchResult getForAdministrativeRead(SearchQuery q) throws SearchException, UnauthorizedException {\n    User user = securityService.getUser();\n    if (!user.hasRole(GLOBAL_ADMIN_ROLE) && !user.hasRole(user.getOrganization().getAdminRole()))\n      throw new UnauthorizedException(user, getClass().getName() + \".getForAdministrativeRead\");\n\n    try {\n      return solrRequester.getForAdministrativeRead(q);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  protected void populateIndex(String systemUserName) {\n    long instancesInSolr = 0L;\n\n    try {\n      instancesInSolr = indexManager.count();\n    } catch (Exception e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (instancesInSolr > 0) {\n      logger.debug(\"Search index found\");\n      return;\n    }\n\n    if (instancesInSolr == 0L) {\n      logger.info(\"No search index found\");\n      Iterator<Tuple<MediaPackage, String>> mediaPackages;\n      int total = 0;\n      try {\n        total = persistence.countMediaPackages();\n        logger.info(\"Starting population of search index from {} items in database\", total);\n        mediaPackages = persistence.getAllMediaPackages();\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Unable to load the search entries: {}\", e.getMessage());\n        throw new ServiceException(e.getMessage());\n      }\n      int errors = 0;\n      int current = 0;\n      while (mediaPackages.hasNext()) {\n        current++;\n        try {\n          Tuple<MediaPackage, String> mediaPackage = mediaPackages.next();\n\n          String mediaPackageId = mediaPackage.getA().getIdentifier().toString();\n\n          Organization organization = organizationDirectory.getOrganization(mediaPackage.getB());\n          securityService.setOrganization(organization);\n          securityService.setUser(SecurityUtil.createSystemUser(systemUserName, organization));\n\n          AccessControlList acl = persistence.getAccessControlList(mediaPackageId);\n          Date modificationDate = persistence.getModificationDate(mediaPackageId);\n          Date deletionDate = persistence.getDeletionDate(mediaPackageId);\n\n          indexManager.add(mediaPackage.getA(), acl, deletionDate, modificationDate);\n        } catch (Exception e) {\n          logger.error(\"Unable to index search instances:\", e);\n          if (retryToPopulateIndex(systemUserName)) {\n            logger.warn(\"Trying to re-index search index later. Aborting for now.\");\n            return;\n          }\n          errors++;\n        } finally {\n          securityService.setOrganization(null);\n          securityService.setUser(null);\n        }\n\n        // log progress\n        if (current % 100 == 0) {\n          logger.info(\"Indexing search {}/{} ({} percent done)\", current, total, current * 100 / total);\n        }\n      }\n      if (errors > 0)\n        logger.error(\"Skipped {} erroneous search entries while populating the search index\", errors);\n      logger.info(\"Finished populating search index\");\n    }\n  }\n\n  private boolean retryToPopulateIndex(final String systemUserName) {\n    if (retriesToPopulateIndex > 0) {\n      return false;\n    }\n\n    long instancesInSolr = 0L;\n\n    try {\n      instancesInSolr = indexManager.count();\n    } catch (Exception e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (instancesInSolr > 0) {\n      logger.debug(\"Search index found, other files could be indexed. No retry needed.\");\n      return false;\n    }\n\n    retriesToPopulateIndex++;\n\n      new Thread() {\n        public void run() {\n          try {\n            Thread.sleep(30000);\n          } catch (InterruptedException ex) {\n          }\n          populateIndex(systemUserName);\n        }\n      }.start();\n    return true;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    Operation op = null;\n    String operation = job.getOperation();\n    List<String> arguments = job.getArguments();\n    try {\n      op = Operation.valueOf(operation);\n      switch (op) {\n        case Add:\n          MediaPackage mediaPackage = MediaPackageParser.getFromXml(arguments.get(0));\n          addSynchronously(mediaPackage);\n          return null;\n        case Delete:\n          String mediapackageId = arguments.get(0);\n          boolean deleted = deleteSynchronously(mediapackageId);\n          return Boolean.toString(deleted);\n        default:\n          throw new IllegalStateException(\"Don't know how to handle operation '\" + operation + \"'\");\n      }\n    } catch (IllegalArgumentException e) {\n      throw new ServiceRegistryException(\"This service can't handle operations of type '\" + op + \"'\", e);\n    } catch (IndexOutOfBoundsException e) {\n      throw new ServiceRegistryException(\"This argument list for operation '\" + op + \"' does not meet expectations\", e);\n    } catch (Exception e) {\n      throw new ServiceRegistryException(\"Error handling operation '\" + op + \"'\", e);\n    }\n  }\n\n  /** For testing purposes only! */\n  void testSetup(SolrServer server, SolrRequester requester, SolrIndexManager manager) {\n    this.solrServer = server;\n    this.solrRequester = requester;\n    this.indexManager = manager;\n  }\n\n  /** Dynamic reference. */\n  public void setStaticMetadataService(StaticMetadataService mdService) {\n    this.mdServices.add(mdService);\n    if (indexManager != null)\n      indexManager.setStaticMetadataServices(mdServices);\n  }\n\n  public void unsetStaticMetadataService(StaticMetadataService mdService) {\n    this.mdServices.remove(mdService);\n    if (indexManager != null)\n      indexManager.setStaticMetadataServices(mdServices);\n  }\n\n  public void setMpeg7CatalogService(Mpeg7CatalogService mpeg7CatalogService) {\n    this.mpeg7CatalogService = mpeg7CatalogService;\n  }\n\n  public void setPersistence(SearchServiceDatabase persistence) {\n    this.persistence = persistence;\n  }\n\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  public void setWorkspace(Workspace workspace) {\n    this.workspace = workspace;\n  }\n\n  public void setAuthorizationService(AuthorizationService authorizationService) {\n    this.authorizationService = authorizationService;\n  }\n\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    this.organizationDirectory = organizationDirectory;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectory;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * Sets the optional MediaPackage serializer.\n   *\n   * @param serializer\n   *          the serializer\n   */\n  protected void setMediaPackageSerializer(MediaPackageSerializer serializer) {\n    this.serializer = serializer;\n    if (solrRequester != null)\n      solrRequester.setMediaPackageSerializer(serializer);\n  }\n\n  @Override\n  public void updated(@SuppressWarnings(\"rawtypes\") Dictionary properties) throws ConfigurationException {\n    addJobLoad = LoadUtil.getConfiguredLoadValue(properties, ADD_JOB_LOAD_KEY, DEFAULT_ADD_JOB_LOAD, serviceRegistry);\n    deleteJobLoad = LoadUtil.getConfiguredLoadValue(properties, DELETE_JOB_LOAD_KEY, DEFAULT_DELETE_JOB_LOAD, serviceRegistry);\n  }\n\n  @Override\n  public List<Pattern> getProtectedUrlPattern() {\n    return Collections.singletonList(staticFilePattern);\n  }\n\n  private boolean loadUrlAccess(final String mediaPackageId) {\n    logger.debug(\"Check if user `{}` has access to media package `{}`\", securityService.getUser(), mediaPackageId);\n    final SearchQuery query = new SearchQuery()\n        .withId(mediaPackageId)\n        .includeEpisodes(true)\n        .includeSeries(false);\n    return getByQuery(query).size() > 0;\n  }\n\n  @Override\n  public boolean verifyUrlAccess(final String path) {\n    // Always allow access for admin\n    final User user = securityService.getUser();\n    if (user.hasRole(GLOBAL_ADMIN_ROLE)) {\n      logger.debug(\"Allow access for admin `{}`\", user);\n      return true;\n    }\n\n    // Check pattern\n    final Matcher m = staticFilePattern.matcher(path);\n    if (!m.matches()) {\n      logger.debug(\"Path does not match pattern. Preventing access.\");\n      return false;\n    }\n\n    // Check organization\n    final String organizationId = m.group(1);\n    if (!securityService.getOrganization().getId().equals(organizationId)) {\n      logger.debug(\"The user's organization does not match. Preventing access.\");\n      return false;\n    }\n\n    // Check search index/cache\n    final String mediaPackageId = m.group(2);\n    final boolean access = cache.getUnchecked(Tuple.tuple(user, mediaPackageId));\n    logger.debug(\"Check if user `{}` has access to media package `{}` using cache: {}\", user, mediaPackageId, access);\n    return access;\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.impl.jpa.JpaOrganization;\n\nimport java.util.Date;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.Index;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.Lob;\nimport javax.persistence.NamedQueries;\nimport javax.persistence.NamedQuery;\nimport javax.persistence.OneToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\n\n/**\n * Entity object for storing search in persistence storage. Media package id is stored as primary key.\n */\n@Entity(name = \"SearchEntity\")\n@Table(name = \"oc_search\", indexes = {\n    @Index(name = \"IX_oc_search_series\", columnList = (\"series_id\")),\n    @Index(name = \"IX_oc_search_organization\", columnList = (\"organization\")) })\n@NamedQueries({\n    @NamedQuery(name = \"Search.findAll\", query = \"SELECT s FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.getCount\", query = \"SELECT COUNT(s) FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.findById\", query = \"SELECT s FROM SearchEntity s WHERE s.mediaPackageId=:mediaPackageId\"),\n    @NamedQuery(name = \"Search.findBySeriesId\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId=:seriesId\"),\n    @NamedQuery(name = \"Search.getNoSeries\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId IS NULL\")})\npublic class SearchEntity {\n\n  /** media package id, primary key */\n  @Id\n  @Column(name = \"id\", length = 128)\n  private String mediaPackageId;\n\n  @Column(name = \"series_id\", length = 128)\n  protected String seriesId;\n\n  /** Organization id */\n  @OneToOne(targetEntity = JpaOrganization.class)\n  @JoinColumn(name = \"organization\", referencedColumnName = \"id\")\n  protected JpaOrganization organization;\n\n  /** The media package deleted */\n  @Column(name = \"deletion_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date deletionDate;\n\n  /** The media package deleted */\n  @Column(name = \"modification_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date modificationDate;\n\n  /** Serialized media package */\n  @Lob\n  @Column(name = \"mediapackage_xml\", length = 65535)\n  private String mediaPackageXML;\n\n  /** Serialized access control */\n  @Lob\n  @Column(name = \"access_control\", length = 65535)\n  protected String accessControl;\n\n  /**\n   * Default constructor without any import.\n   */\n  public SearchEntity() {\n  }\n\n  /**\n   * Returns media package id.\n   *\n   * @return media package id\n   */\n  public String getMediaPackageId() {\n    return mediaPackageId;\n  }\n\n  /**\n   * Sets media package id. Id length limit is 128 charachters.\n   *\n   * @param mediaPackageId\n   */\n  public void setMediaPackageId(String mediaPackageId) {\n    this.mediaPackageId = mediaPackageId;\n  }\n\n  /**\n   * Returns serialized media package.\n   *\n   * @return serialized media package\n   */\n  public String getMediaPackageXML() {\n    return mediaPackageXML;\n  }\n\n  /**\n   * Sets serialized media package\n   *\n   * @param mediaPackageXML\n   */\n  public void setMediaPackageXML(String mediaPackageXML) {\n    this.mediaPackageXML = mediaPackageXML;\n  }\n\n  /**\n   * Returns serialized access control\n   *\n   * @return serialized access control\n   */\n  public String getAccessControl() {\n    return accessControl;\n  }\n\n  /**\n   * Sets serialized access control.\n   *\n   * @param accessControl\n   *          serialized access control\n   */\n  public void setAccessControl(String accessControl) {\n    this.accessControl = accessControl;\n  }\n\n  /**\n   * @return the organization\n   */\n  public JpaOrganization getOrganization() {\n    return organization;\n  }\n\n  /**\n   * @param organization\n   *          the organization to set\n   */\n  public void setOrganization(Organization organization) {\n    if (organization instanceof JpaOrganization) {\n      this.organization = (JpaOrganization) organization;\n    } else {\n      this.organization = new JpaOrganization(organization.getId(), organization.getName(), organization.getServers(),\n          organization.getAdminRole(), organization.getAnonymousRole(), organization.getProperties());\n    }\n  }\n\n  /**\n   * @return the deletion date\n   */\n  public Date getDeletionDate() {\n    return deletionDate;\n  }\n\n  /**\n   * Sets the deletion date\n   *\n   * @param deletionDate\n   *          the deletion date\n   */\n  public void setDeletionDate(Date deletionDate) {\n    this.deletionDate = deletionDate;\n  }\n\n  /**\n   * @return the modification date\n   */\n  public Date getModificationDate() {\n    return modificationDate;\n  }\n\n  /**\n   * Sets the modification date\n   *\n   * @param modificationDate\n   *          the modification date\n   */\n  public void setModificationDate(Date modificationDate) {\n    this.modificationDate = modificationDate;\n  }\n\n  /**\n   * @return the series Id for this search entry\n   */\n  public String getSeriesId() {\n    return seriesId;\n  }\n\n  /**\n   * Sets the series ID\n   *\n   * @param seriesId\n   *          the series ID\n   */\n  public void setSeriesId(String seriesId) {\n    this.seriesId = seriesId;\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\n\nimport java.util.Date;\nimport java.util.Iterator;\n\n/**\n * API that defines persistent storage of series.\n *\n */\npublic interface SearchServiceDatabase {\n\n  /**\n   * Returns all search entries in persistent storage.\n   *\n   * @return {@link Tuple} array representing stored media packages\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   */\n  Iterator<Tuple<MediaPackage, String>> getAllMediaPackages() throws SearchServiceDatabaseException;\n\n  /**\n   * Returns the organization id of the selected media package\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the organization id\n   * @throws NotFoundException\n   *           if media package with specified id and version does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  String getOrganizationId(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Returns the number of mediapackages in persistent storage, including deleted entries.\n   *\n   * @return the number of mediapackages in storage\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  int countMediaPackages() throws SearchServiceDatabaseException;\n\n  /**\n   * Gets a single media package by its identifier.\n   *\n   * @param mediaPackageId\n   *          the media package identifier\n   * @return the media package\n   * @throws NotFoundException\n   *           if there is no media package with this identifier\n   * @throws SearchServiceDatabaseException\n   *           if there is a problem communicating with the underlying data store\n   */\n  MediaPackage getMediaPackage(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Retrieves ACL for series with given ID.\n   *\n   * @param mediaPackageId\n   *          media package for which ACL will be retrieved\n   * @return {@link AccessControlList} of media package or null if media package does not have ACL associated with it\n   * @throws NotFoundException\n   *           if media package with given ID does not exist\n   * @throws SearchServiceDatabaseException\n   *           if exception occurred\n   */\n  AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n          SearchServiceDatabaseException;\n\n  /**\n   * Returns the modification date from the selected media package.\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the modification date\n   * @throws NotFoundException\n   *           if media package with specified id and version does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  Date getModificationDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Returns the deletion date from the selected media package.\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the deletion date\n   * @throws NotFoundException\n   *           if media package with specified id does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  Date getDeletionDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Removes media package from persistent storage.\n   *\n   * @param mediaPackageId\n   *          id of the media package to be removed\n   * @param deletionDate\n   *          the deletion date to set\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   * @throws NotFoundException\n   *           if media package with specified id is not found\n   */\n  void deleteMediaPackage(String mediaPackageId, Date deletionDate) throws SearchServiceDatabaseException,\n          NotFoundException;\n\n  /**\n   * Store (or update) media package.\n   *\n   * @param mediaPackage\n   *          {@link MediaPackage} to store\n   * @param acl\n   *          the acl of the media package\n   * @param now\n   *          the store date\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   * @throws UnauthorizedException\n   *           if the current user is not authorized to perform this action\n   */\n  void storeMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date now)\n          throws SearchServiceDatabaseException, UnauthorizedException;\n\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport static org.opencastproject.security.api.Permissions.Action.CONTRIBUTE;\nimport static org.opencastproject.security.api.Permissions.Action.READ;\nimport static org.opencastproject.security.api.Permissions.Action.WRITE;\n\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.AccessControlParser;\nimport org.opencastproject.security.api.AccessControlUtil;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.EntityTransaction;\nimport javax.persistence.NoResultException;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;\n\n/**\n * Implements {@link SearchServiceDatabase}. Defines permanent storage for series.\n */\npublic class SearchServiceDatabaseImpl implements SearchServiceDatabase {\n\n  /** JPA persistence unit name */\n  public static final String PERSISTENCE_UNIT = \"org.opencastproject.search.impl.persistence\";\n\n  /** Logging utilities */\n  private static final Logger logger = LoggerFactory.getLogger(SearchServiceDatabaseImpl.class);\n\n  /** Factory used to create {@link EntityManager}s for transactions */\n  protected EntityManagerFactory emf;\n\n  /** The security service */\n  protected SecurityService securityService;\n\n  /** OSGi DI */\n  public void setEntityManagerFactory(EntityManagerFactory emf) {\n    this.emf = emf;\n  }\n\n  /**\n   * Creates {@link EntityManagerFactory} using persistence provider and properties passed via OSGi.\n   *\n   * @param cc\n   * @throws SearchServiceDatabaseException\n   */\n  public void activate(ComponentContext cc) throws SearchServiceDatabaseException {\n    logger.info(\"Activating persistence manager for search service\");\n    this.populateSeriesData();\n  }\n\n  /**\n   * OSGi callback to set the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  private void populateSeriesData() throws SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      TypedQuery<SearchEntity> q = (TypedQuery<SearchEntity>) em.createNamedQuery(\"Search.getNoSeries\");\n      List<SearchEntity> seriesList = q.getResultList();\n      for (SearchEntity series : seriesList) {\n        String mpSeriesId = MediaPackageParser.getFromXml(series.getMediaPackageXML()).getSeries();\n        if (StringUtils.isNotBlank(mpSeriesId) && !mpSeriesId.equals(series.getSeriesId())) {\n          logger.info(\"Fixing missing series ID for episode {}, series is {}\", series.getMediaPackageId(), mpSeriesId);\n          series.setSeriesId(mpSeriesId);\n          em.merge(series);\n        }\n      }\n      tx.commit();\n    } catch (Exception e) {\n      logger.error(\"Could not update media package: {}\", e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#deleteMediaPackage(String, Date)\n   */\n  @Override\n  public void deleteMediaPackage(String mediaPackageId, Date deletionDate) throws SearchServiceDatabaseException,\n  NotFoundException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n\n      // Ensure this user is allowed to delete this episode\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, WRITE.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to delete media package \" + mediaPackageId);\n\n        searchEntity.setDeletionDate(deletionDate);\n        em.merge(searchEntity);\n      }\n      tx.commit();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not delete episode {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#countMediaPackages()\n   */\n  @Override\n  public int countMediaPackages() throws SearchServiceDatabaseException {\n    EntityManager em = emf.createEntityManager();\n    Query query = em.createNamedQuery(\"Search.getCount\");\n    try {\n      Long total = (Long) query.getSingleResult();\n      return total.intValue();\n    } catch (Exception e) {\n      logger.error(\"Could not find number of mediapackages\", e);\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getAllMediaPackages()\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public Iterator<Tuple<MediaPackage, String>> getAllMediaPackages() throws SearchServiceDatabaseException {\n    List<SearchEntity> searchEntities = null;\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      Query query = em.createNamedQuery(\"Search.findAll\");\n      searchEntities = (List<SearchEntity>) query.getResultList();\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve all episodes: {}\", e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n    List<Tuple<MediaPackage, String>> mediaPackageList = new LinkedList<Tuple<MediaPackage, String>>();\n    try {\n      for (SearchEntity entity : searchEntities) {\n        MediaPackage mediaPackage = MediaPackageParser.getFromXml(entity.getMediaPackageXML());\n        mediaPackageList.add(Tuple.tuple(mediaPackage, entity.getOrganization().getId()));\n      }\n    } catch (Exception e) {\n      logger.error(\"Could not parse series entity: {}\", e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    }\n    return mediaPackageList.iterator();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getAccessControlList(String)\n   */\n  @Override\n  public AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n  SearchServiceDatabaseException {\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        throw new NotFoundException(\"Could not found media package with ID \" + mediaPackageId);\n      }\n      if (entity.getAccessControl() == null) {\n        return null;\n      } else {\n        return AccessControlParser.parseAcl(entity.getAccessControl());\n      }\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve ACL {}: {}\", mediaPackageId, e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#storeMediaPackage(MediaPackage,\n   *      AccessControlList, Date)\n   */\n  @Override\n  public void storeMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date now)\n          throws SearchServiceDatabaseException, UnauthorizedException {\n    String mediaPackageXML = MediaPackageParser.getAsXml(mediaPackage);\n    String mediaPackageId = mediaPackage.getIdentifier().toString();\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        // Create new search entity\n        SearchEntity searchEntity = new SearchEntity();\n        searchEntity.setOrganization(securityService.getOrganization());\n        searchEntity.setMediaPackageId(mediaPackageId);\n        searchEntity.setMediaPackageXML(mediaPackageXML);\n        searchEntity.setAccessControl(AccessControlParser.toXml(acl));\n        searchEntity.setModificationDate(now);\n        searchEntity.setSeriesId(mediaPackage.getSeries());\n        em.persist(searchEntity);\n      } else {\n        // Ensure this user is allowed to update this media package\n        String accessControlXml = entity.getAccessControl();\n        if (accessControlXml != null) {\n          AccessControlList accessList = AccessControlParser.parseAcl(accessControlXml);\n          User currentUser = securityService.getUser();\n          Organization currentOrg = securityService.getOrganization();\n          if (!AccessControlUtil.isAuthorized(accessList, currentUser, currentOrg, WRITE.toString())) {\n            throw new UnauthorizedException(currentUser + \" is not authorized to update media package \"\n                    + mediaPackageId);\n          }\n        }\n        entity.setOrganization(securityService.getOrganization());\n        entity.setMediaPackageId(mediaPackageId);\n        entity.setMediaPackageXML(mediaPackageXML);\n        entity.setAccessControl(AccessControlParser.toXml(acl));\n        entity.setModificationDate(now);\n        entity.setDeletionDate(null);\n        entity.setSeriesId(mediaPackage.getSeries());\n        em.merge(entity);\n      }\n      tx.commit();\n    } catch (Exception e) {\n      logger.error(\"Could not update media package: {}\", e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getMediaPackage(String)\n   */\n  @Override\n  public MediaPackage getMediaPackage(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity episodeEntity = getSearchEntity(mediaPackageId, em);\n      if (episodeEntity == null)\n        throw new NotFoundException(\"No episode with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this episode\n      String accessControlXml = episodeEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        // There are several reasons a user may need to load a episode: to read content, to edit it, or add content\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString())\n                && !AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, CONTRIBUTE.toString())\n                && !AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, WRITE.toString())) {\n          throw new UnauthorizedException(currentUser + \" is not authorized to see episode \" + mediaPackageId);\n        }\n      }\n      return MediaPackageParser.getFromXml(episodeEntity.getMediaPackageXML());\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get episode {} from database: {} \", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getModificationDate(String)\n   */\n  @Override\n  public Date getModificationDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getModificationDate();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get modification date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getDeletionDate(String)\n   */\n  @Override\n  public Date getDeletionDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null) {\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      }\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getDeletionDate();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get deletion date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getOrganizationId(String)\n   */\n  @Override\n  public String getOrganizationId(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getOrganization().getId();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get deletion date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * Gets a search entity by it's id, using the current organizational context.\n   *\n   * @param id\n   *          the media package identifier\n   * @param em\n   *          an open entity manager\n   * @return the search entity, or null if not found\n   */\n  private SearchEntity getSearchEntity(String id, EntityManager em) {\n    Query q = em.createNamedQuery(\"Search.findById\").setParameter(\"mediaPackageId\", id);\n    try {\n      return (SearchEntity) q.getSingleResult();\n    } catch (NoResultException e) {\n      return null;\n    }\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.search.impl.solr;\n\nimport static org.opencastproject.security.api.Permissions.Action.READ;\nimport static org.opencastproject.security.api.Permissions.Action.WRITE;\nimport static org.opencastproject.util.RequireUtil.notNull;\nimport static org.opencastproject.util.data.Collections.flatMap;\nimport static org.opencastproject.util.data.Collections.head;\nimport static org.opencastproject.util.data.Collections.map;\nimport static org.opencastproject.util.data.Option.option;\n\nimport org.opencastproject.mediapackage.Attachment;\nimport org.opencastproject.mediapackage.Catalog;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageReference;\nimport org.opencastproject.metadata.api.MetadataValue;\nimport org.opencastproject.metadata.api.StaticMetadata;\nimport org.opencastproject.metadata.api.StaticMetadataService;\nimport org.opencastproject.metadata.api.util.Interval;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.metadata.dublincore.Temporal;\nimport org.opencastproject.metadata.mpeg7.AudioVisual;\nimport org.opencastproject.metadata.mpeg7.FreeTextAnnotation;\nimport org.opencastproject.metadata.mpeg7.KeywordAnnotation;\nimport org.opencastproject.metadata.mpeg7.MediaDuration;\nimport org.opencastproject.metadata.mpeg7.MediaTime;\nimport org.opencastproject.metadata.mpeg7.MediaTimePoint;\nimport org.opencastproject.metadata.mpeg7.Mpeg7Catalog;\nimport org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;\nimport org.opencastproject.metadata.mpeg7.MultimediaContent;\nimport org.opencastproject.metadata.mpeg7.MultimediaContentType;\nimport org.opencastproject.metadata.mpeg7.SpatioTemporalDecomposition;\nimport org.opencastproject.metadata.mpeg7.TextAnnotation;\nimport org.opencastproject.metadata.mpeg7.Video;\nimport org.opencastproject.metadata.mpeg7.VideoSegment;\nimport org.opencastproject.metadata.mpeg7.VideoText;\nimport org.opencastproject.search.api.SearchResultItem.SearchResultItemType;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;\nimport org.opencastproject.security.api.AccessControlEntry;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.series.api.SeriesException;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.SolrUtils;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.workspace.api.Workspace;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.SolrServer;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrInputDocument;\nimport org.apache.solr.common.params.SolrParams;\nimport org.apache.solr.servlet.SolrRequestParsers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * Utility class used to manage the search index.\n */\npublic class SolrIndexManager {\n\n  /** Logging facility */\n  private static final Logger logger = LoggerFactory.getLogger(SolrIndexManager.class);\n\n  /** Connection to the database */\n  private SolrServer solrServer = null;\n\n  /**\n   * Factor multiplied to fine tune relevance and confidence impact on important keyword decision. importance =\n   * RELEVANCE_BOOST * relevance + confidence\n   */\n  private static final double RELEVANCE_BOOST = 2.0;\n\n  /** Number of characters an important should have at least. */\n  private static final int MAX_CHAR = 3;\n\n  /** Maximum number of important keywords to detect. */\n  private static final int MAX_IMPORTANT_COUNT = 10;\n\n  /** List of metadata services sorted by priority in reverse order. */\n  private List<StaticMetadataService> mdServices;\n\n  private SeriesService seriesService;\n\n  private Mpeg7CatalogService mpeg7CatalogService;\n\n  private Workspace workspace;\n\n  private SecurityService securityService;\n\n  /** Convert a DublinCoreValue into a date. */\n  private static Function<DublinCoreValue, Option<Date>> toDateF = new Function<DublinCoreValue, Option<Date>>() {\n    @Override\n    public Option<Date> apply(DublinCoreValue v) {\n      return EncodingSchemeUtils.decodeTemporal(v).fold(new Temporal.Match<Option<Date>>() {\n        @Override\n        public Option<Date> period(DCMIPeriod period) {\n          return option(period.getStart());\n        }\n\n        @Override\n        public Option<Date> instant(Date instant) {\n          return Option.some(instant);\n        }\n\n        @Override\n        public Option<Date> duration(long duration) {\n          return Option.none();\n        }\n      });\n    }\n  };\n\n  /** Convert a DublinCoreValue into a duration (long). */\n  private static Function<DublinCoreValue, Option<Long>> toDurationF = new Function<DublinCoreValue, Option<Long>>() {\n    @Override\n    public Option<Long> apply(DublinCoreValue dublinCoreValue) {\n      return option(EncodingSchemeUtils.decodeDuration(dublinCoreValue));\n    }\n  };\n\n  /** Dynamic reference. */\n  public void setStaticMetadataServices(List<StaticMetadataService> mdServices) {\n    this.mdServices = new ArrayList<StaticMetadataService>(mdServices);\n    Collections.sort(this.mdServices, new Comparator<StaticMetadataService>() {\n      @Override\n      public int compare(StaticMetadataService a, StaticMetadataService b) {\n        return b.getPriority() - a.getPriority();\n      }\n    });\n  }\n\n  /**\n   * Creates a new management instance for the search index.\n   *\n   * @param connection\n   *          connection to the database\n   */\n  public SolrIndexManager(SolrServer connection, Workspace workspace, List<StaticMetadataService> mdServices,\n          SeriesService seriesService, Mpeg7CatalogService mpeg7CatalogService, SecurityService securityService) {\n\n    this.solrServer = notNull(connection, \"solr connection\");\n    this.workspace = notNull(workspace, \"workspace\");\n    this.seriesService = notNull(seriesService, \"series service\");\n    this.mpeg7CatalogService = notNull(mpeg7CatalogService, \"mpeg7 service\");\n    this.securityService = notNull(securityService, \"security service\");\n    setStaticMetadataServices(notNull(mdServices, \"metadata service\"));\n  }\n\n  /**\n   * Clears the search index. Make sure you know what you are doing.\n   *\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public void clear() throws SolrServerException {\n    try {\n      solrServer.deleteByQuery(\"*:*\");\n      solrServer.commit();\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Removes the entry with the given <code>id</code> from the database. The entry can either be a series or an episode.\n   *\n   * @param id\n   *          identifier of the series or episode to delete\n   * @param deletionDate\n   *          the deletion date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean delete(String id, Date deletionDate) throws SolrServerException {\n    try {\n      // Load the existing episode\n      QueryResponse solrResponse = null;\n      try {\n        SolrQuery query = new SolrQuery(Schema.ID + \":\" + ClientUtils.escapeQueryChars(id) + \" AND -\"\n                + Schema.OC_DELETED + \":[* TO *]\");\n        solrResponse = solrServer.query(query);\n      } catch (Exception e1) {\n        throw new SolrServerException(e1);\n      }\n\n      // Did we find the episode?\n      if (solrResponse.getResults().size() == 0) {\n        logger.warn(\"Trying to delete non-existing media package {} from the search index\", id);\n        return false;\n      }\n\n      // Use all existing fields\n      SolrDocument doc = solrResponse.getResults().get(0);\n      SolrInputDocument inputDocument = new SolrInputDocument();\n      for (String field : doc.getFieldNames()) {\n        inputDocument.setField(field, doc.get(field));\n      }\n\n      // Set the oc_deleted field to the current date, then update\n      Schema.setOcDeleted(inputDocument, deletionDate);\n      solrServer.add(inputDocument);\n      solrServer.commit();\n      return true;\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param now\n   *          current date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, Date now) throws SolrServerException,\n          UnauthorizedException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n      Schema.setOcModified(episodeDocument, now);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), acl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      // If neither an episode nor a series was contained, there is no point in trying to update\n      if (episodeDocument == null && seriesDocument == null) {\n        logger.warn(\"Neither episode nor series metadata found\");\n        return false;\n      }\n\n      // Post everything to the search index\n      if (episodeDocument != null)\n        solrServer.add(episodeDocument);\n      if (seriesDocument != null)\n        solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      logger.error(\"Unable to add mediapackage {} to index\", sourceMediaPackage.getIdentifier());\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param deletionDate\n   *          the deletion date\n   * @param modificationDate\n   *          the modification date\n   * @return <code>true</code> if successfully added\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, Date deletionDate, Date modificationDate)\n          throws SolrServerException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), acl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      Schema.setOcModified(episodeDocument, modificationDate);\n      if (deletionDate != null)\n        Schema.setOcDeleted(episodeDocument, deletionDate);\n\n      solrServer.add(episodeDocument);\n      solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      logger.error(\"Unable to add mediapackage {} to index\", sourceMediaPackage.getIdentifier());\n      try {\n        solrServer.rollback();\n      } catch (IOException e1) {\n        throw new SolrServerException(e1);\n      }\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the episode metadata of the media package.\n   *\n   * @param mediaPackage\n   *          the media package\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr\n   * @throws MediaPackageException\n   *           if serialization of the media package fails\n   */\n  private SolrInputDocument createEpisodeInputDocument(MediaPackage mediaPackage, AccessControlList acl)\n          throws MediaPackageException, IOException {\n\n    SolrInputDocument doc = new SolrInputDocument();\n    String mediaPackageId = mediaPackage.getIdentifier().toString();\n\n    // Fill the input document\n    Schema.setId(doc, mediaPackageId);\n    // /\n    // OC specific fields\n    Schema.setOcMediatype(doc, SearchResultItemType.AudioVisual.toString());\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediapackage(doc, MediaPackageParser.getAsXml(mediaPackage));\n    Schema.setOcElementtags(doc, tags(mediaPackage));\n    Schema.setOcElementflavors(doc, flavors(mediaPackage));\n    // Add cover\n    Attachment[] cover = mediaPackage.getAttachments(MediaPackageElements.MEDIAPACKAGE_COVER_FLAVOR);\n    if (cover != null && cover.length > 0) {\n      Schema.setOcCover(doc, cover[0].getURI().toString());\n    }\n\n    // /\n    // Add standard dublin core fields\n    // naive approach. works as long as only setters, not adders are available in the schema\n    for (StaticMetadata md : getMetadata(mdServices, mediaPackage))\n      addEpisodeMetadata(doc, md);\n\n    // /\n    // Add mpeg7\n    logger.debug(\"Looking for mpeg-7 catalogs containing segment texts\");\n    Catalog[] mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.TEXTS);\n    if (mpeg7Catalogs.length == 0) {\n      logger.debug(\"No text catalogs found, trying segments only\");\n      mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.SEGMENTS);\n    }\n    // TODO: merge the segments from each mpeg7 if there is more than one mpeg7 catalog\n    if (mpeg7Catalogs.length > 0) {\n      try {\n        Mpeg7Catalog mpeg7Catalog = loadMpeg7Catalog(mpeg7Catalogs[0]);\n        addMpeg7Metadata(doc, mediaPackage, mpeg7Catalog);\n      } catch (IOException e) {\n        logger.error(\"Error loading mpeg7 catalog. Skipping catalog\", e);\n      }\n    } else {\n      logger.debug(\"No segmentation catalog found\");\n    }\n\n    // /\n    // Add authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  static void addEpisodeMetadata(final SolrInputDocument doc, final StaticMetadata md) {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return md.getCreated();\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return md.getExtent();\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return md.getLanguage();\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return md.getIsPartOf();\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return md.getReplaces();\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return md.getType();\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(leftBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.none();\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.some(leftBound);\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.none();\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromMValue(md.getTitles());\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromMValue(md.getSubjects());\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromMValue(md.getCreators());\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromMValue(md.getPublishers());\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromMValue(md.getContributors());\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromMValue(md.getDescription());\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromMValue(md.getRightsHolders());\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromMValue(md.getSpatials());\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromMValue(md.getAccessRights());\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromMValue(md.getLicenses());\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n    });\n  }\n\n  static List<DField<String>> fromMValue(List<MetadataValue<String>> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<MetadataValue<String>, DField<String>>() {\n      @Override\n      public DField<String> apply(MetadataValue<String> v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  static List<DField<String>> fromDCValue(List<DublinCoreValue> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<DublinCoreValue, DField<String>>() {\n      @Override\n      public DField<String> apply(DublinCoreValue v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  /**\n   * Adds authorization fields to the solr document.\n   *\n   * @param doc\n   *          the solr document\n   * @param acl\n   *          the access control list\n   */\n  static void setAuthorization(SolrInputDocument doc, SecurityService securityService, AccessControlList acl) {\n    Map<String, List<String>> permissions = new HashMap<String, List<String>>();\n\n    // Define containers for common permissions\n    List<String> reads = new ArrayList<String>();\n    permissions.put(READ.toString(), reads);\n    List<String> writes = new ArrayList<String>();\n    permissions.put(WRITE.toString(), writes);\n\n    String adminRole = securityService.getOrganization().getAdminRole();\n\n    // The admin user can read and write\n    if (adminRole != null) {\n      reads.add(adminRole);\n      writes.add(adminRole);\n    }\n\n    for (AccessControlEntry entry : acl.getEntries()) {\n      if (!entry.isAllow()) {\n        logger.warn(\"Search service does not support denial via ACL, ignoring {}\", entry);\n        continue;\n      }\n      List<String> actionPermissions = permissions.get(entry.getAction());\n      /*\n       * MH-8353 a series could have a permission defined we don't know how to handle -DH\n       */\n      if (actionPermissions == null) {\n        logger.warn(\"Search service doesn't know how to handle action: \" + entry.getAction());\n        continue;\n      }\n      if (acl == null) {\n        actionPermissions = new ArrayList<String>();\n        permissions.put(entry.getAction(), actionPermissions);\n      }\n      actionPermissions.add(entry.getRole());\n\n    }\n\n    // Write the permissions to the solr document\n    for (Map.Entry<String, List<String>> entry : permissions.entrySet()) {\n      Schema.setOcAcl(doc, new DField<String>(mkString(entry.getValue(), \" \"), entry.getKey()));\n    }\n  }\n\n  static String mkString(Collection<?> as, String sep) {\n    StringBuffer b = new StringBuffer();\n    for (Object a : as) {\n      b.append(a).append(sep);\n    }\n    return b.substring(0, b.length() - sep.length());\n  }\n\n  private Mpeg7Catalog loadMpeg7Catalog(Catalog catalog) throws IOException {\n    try (InputStream in = workspace.read(catalog.getURI())) {\n      return mpeg7CatalogService.load(in);\n    } catch (NotFoundException e) {\n      throw new IOException(\"Unable to load metadata from mpeg7 catalog \" + catalog);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the series metadata of the media package.\n   *\n   * @param seriesId\n   *          the id of the series\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr or null\n   */\n  private SolrInputDocument createSeriesInputDocument(String seriesId, AccessControlList acl) throws IOException,\n          UnauthorizedException {\n\n    if (seriesId == null)\n      return null;\n    DublinCoreCatalog dc = null;\n    try {\n      dc = seriesService.getSeries(seriesId);\n    } catch (SeriesException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    } catch (NotFoundException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    }\n\n    SolrInputDocument doc = new SolrInputDocument();\n\n    // Populate document with existing data\n    try {\n      StringBuffer query = new StringBuffer(\"q=\");\n      query = query.append(Schema.ID).append(\":\").append(SolrUtils.clean(seriesId));\n      SolrParams params = SolrRequestParsers.parseQueryString(query.toString());\n      QueryResponse solrResponse = solrServer.query(params);\n      if (solrResponse.getResults().size() > 0) {\n        SolrDocument existingSolrDocument = solrResponse.getResults().get(0);\n        for (String fieldName : existingSolrDocument.getFieldNames()) {\n          doc.addField(fieldName, existingSolrDocument.getFieldValue(fieldName));\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error trying to load series \" + seriesId, e);\n    }\n\n    // Fill document\n    Schema.setId(doc, seriesId);\n\n    // OC specific fields\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediatype(doc, SearchResultItemType.Series.toString());\n    Schema.setOcModified(doc, new Date());\n\n    // DC fields\n    addSeriesMetadata(doc, dc);\n\n    // Authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  /**\n   * Add the standard dublin core fields to a series document.\n   *\n   * @param doc\n   *          the solr document to fill\n   * @param dc\n   *          the dublin core catalog to get the data from\n   */\n  static void addSeriesMetadata(final SolrInputDocument doc, final DublinCoreCatalog dc) throws IOException {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.some(dc.getFirst(DublinCore.PROPERTY_IDENTIFIER));\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return head(dc.get(DublinCore.PROPERTY_CREATED)).flatMap(toDateF);\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return head(dc.get(DublinCore.PROPERTY_EXTENT)).flatMap(toDurationF);\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return option(dc.getFirst(DublinCore.PROPERTY_LANGUAGE));\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return option(dc.getFirst(DublinCore.PROPERTY_IS_PART_OF));\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return option(dc.getFirst(DublinCore.PROPERTY_REPLACES));\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return option(dc.getFirst(DublinCore.PROPERTY_TYPE));\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getStart());\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getEnd());\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_TITLE));\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SUBJECT));\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CREATOR));\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_PUBLISHER));\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CONTRIBUTOR));\n\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_DESCRIPTION));\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_RIGHTS_HOLDER));\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SPATIAL));\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_ACCESS_RIGHTS));\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_LICENSE));\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none();\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST;\n      }\n    });\n  }\n\n  /**\n   * Add the mpeg 7 catalog data to the solr document.\n   *\n   * @param doc\n   *          the input document to the solr index\n   * @param mpeg7\n   *          the mpeg7 catalog\n   */\n  @SuppressWarnings(\"unchecked\")\n  static void addMpeg7Metadata(SolrInputDocument doc, MediaPackage mediaPackage, Mpeg7Catalog mpeg7) {\n\n    // Check for multimedia content\n    if (!mpeg7.multimediaContent().hasNext()) {\n      logger.warn(\"Mpeg-7 doesn't contain  multimedia content\");\n      return;\n    }\n\n    // Get the content duration by looking at the first content track. This\n    // of course assumes that all tracks are equally long.\n    MultimediaContent<? extends MultimediaContentType> mc = mpeg7.multimediaContent().next();\n    MultimediaContentType mct = mc.elements().next();\n    MediaTime mediaTime = mct.getMediaTime();\n    Schema.setDcExtent(doc, mediaTime.getMediaDuration().getDurationInMilliseconds());\n\n    // Check if the keywords have been filled by (manually) added dublin\n    // core data. If not, look for the most relevant fields in mpeg-7.\n    SortedSet<TextAnnotation> sortedAnnotations = null;\n    if (!\"\".equals(Schema.getOcKeywords(doc))) {\n      sortedAnnotations = new TreeSet<TextAnnotation>(new Comparator<TextAnnotation>() {\n        @Override\n        public int compare(TextAnnotation a1, TextAnnotation a2) {\n          if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) > (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return -1;\n          else if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) < (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return 1;\n          return 0;\n        }\n      });\n    }\n\n    // Iterate over the tracks and extract keywords and hints\n    Iterator<MultimediaContent<? extends MultimediaContentType>> mmIter = mpeg7.multimediaContent();\n    int segmentCount = 0;\n\n    while (mmIter.hasNext()) {\n      MultimediaContent<?> multimediaContent = mmIter.next();\n\n      // We need to process visual segments first, due to the way they are handled in the ui.\n      for (Iterator<?> iterator = multimediaContent.elements(); iterator.hasNext();) {\n\n        MultimediaContentType type = (MultimediaContentType) iterator.next();\n        if (!(type instanceof Video) && !(type instanceof AudioVisual))\n          continue;\n\n        // for every segment in the current multimedia content track\n\n        Video video = (Video) type;\n        Iterator<VideoSegment> vsegments = (Iterator<VideoSegment>) video.getTemporalDecomposition().segments();\n        while (vsegments.hasNext()) {\n          VideoSegment segment = vsegments.next();\n\n          StringBuffer segmentText = new StringBuffer();\n          StringBuffer hintField = new StringBuffer();\n\n          // Collect the video text elements to a segment text\n          SpatioTemporalDecomposition spt = segment.getSpatioTemporalDecomposition();\n          if (spt != null) {\n            for (VideoText videoText : spt.getVideoText()) {\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(videoText.getText().getText());\n              // TODO: Add hint on bounding box\n            }\n          }\n\n          // Add keyword annotations\n          Iterator<TextAnnotation> textAnnotations = segment.textAnnotations();\n          while (textAnnotations.hasNext()) {\n            TextAnnotation textAnnotation = textAnnotations.next();\n            Iterator<?> kwIter = textAnnotation.keywordAnnotations();\n            while (kwIter.hasNext()) {\n              KeywordAnnotation keywordAnnotation = (KeywordAnnotation) kwIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(keywordAnnotation.getKeyword());\n            }\n          }\n\n          // Add free text annotations\n          Iterator<TextAnnotation> freeIter = segment.textAnnotations();\n          if (freeIter.hasNext()) {\n            Iterator<FreeTextAnnotation> freeTextIter = freeIter.next().freeTextAnnotations();\n            while (freeTextIter.hasNext()) {\n              FreeTextAnnotation freeTextAnnotation = freeTextIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(freeTextAnnotation.getText());\n            }\n          }\n\n          // add segment text to solr document\n          Schema.setSegmentText(doc, new DField<String>(segmentText.toString(), Integer.toString(segmentCount)));\n\n          // get the segments time properties\n          MediaTimePoint timepoint = segment.getMediaTime().getMediaTimePoint();\n          MediaDuration duration = segment.getMediaTime().getMediaDuration();\n\n          // TODO: define a class with hint field constants\n          hintField.append(\"time=\" + timepoint.getTimeInMilliseconds() + \"\\n\");\n          hintField.append(\"duration=\" + duration.getDurationInMilliseconds() + \"\\n\");\n\n          // Look for preview images. Their characteristics are that they are\n          // attached as attachments with a flavor of preview/<something>.\n          String time = timepoint.toString();\n          for (Attachment slide : mediaPackage.getAttachments(MediaPackageElements.PRESENTATION_SEGMENT_PREVIEW)) {\n            MediaPackageReference ref = slide.getReference();\n            if (ref != null && time.equals(ref.getProperty(\"time\"))) {\n              hintField.append(\"preview\");\n              hintField.append(\".\");\n              hintField.append(ref.getIdentifier());\n              hintField.append(\"=\");\n              hintField.append(slide.getURI().toString());\n              hintField.append(\"\\n\");\n            }\n          }\n\n          logger.trace(\"Adding segment: \" + timepoint.toString());\n          Schema.setSegmentHint(doc, new DField<String>(hintField.toString(), Integer.toString(segmentCount)));\n\n          // increase segment counter\n          segmentCount++;\n        }\n      }\n    }\n\n    // Put the most important keywords into a special solr field\n    if (sortedAnnotations != null) {\n      Schema.setOcKeywords(doc, importantKeywordsString(sortedAnnotations).toString());\n    }\n  }\n\n  /**\n   * Generates a string with the most important kewords from the text annotation.\n   *\n   * @param sortedAnnotations\n   * @return The keyword string.\n   */\n  static StringBuffer importantKeywordsString(SortedSet<TextAnnotation> sortedAnnotations) {\n\n    // important keyword:\n    // - high relevance\n    // - high confidence\n    // - occur often\n    // - more than MAX_CHAR chars\n\n    // calculate keyword occurences (histogram) and importance\n    ArrayList<String> list = new ArrayList<String>();\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    TextAnnotation textAnnotation = null;\n    String keyword = null;\n\n    HashMap<String, Integer> histogram = new HashMap<String, Integer>();\n    HashMap<String, Double> importance = new HashMap<String, Double>();\n    int occ = 0;\n    double imp;\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation annotation = keywordAnnotations.next();\n        keyword = annotation.getKeyword().toLowerCase();\n        if (keyword.length() > MAX_CHAR) {\n          occ = 0;\n          if (histogram.keySet().contains(keyword)) {\n            occ = histogram.get(keyword);\n          }\n          histogram.put(keyword, occ + 1);\n\n          // here the importance value is calculated\n          // from relevance, confidence and frequency of occurence.\n          imp = (RELEVANCE_BOOST * getMaxRelevance(keyword, sortedAnnotations) + getMaxConfidence(keyword,\n                  sortedAnnotations)) * (occ + 1);\n          importance.put(keyword, imp);\n        }\n      }\n    }\n\n    // get the MAX_IMPORTANT_COUNT most important keywords\n    StringBuffer buf = new StringBuffer();\n\n    while (list.size() < MAX_IMPORTANT_COUNT && importance.size() > 0) {\n      double max = 0.0;\n      String maxKeyword = null;\n\n      // get maximum from importance list\n      for (Entry<String, Double> entry : importance.entrySet()) {\n        keyword = entry.getKey();\n        if (max < entry.getValue()) {\n          max = entry.getValue();\n          maxKeyword = keyword;\n        }\n      }\n\n      // pop maximum\n      importance.remove(maxKeyword);\n\n      // append keyword to string\n      if (buf.length() > 0)\n        buf.append(\" \");\n      buf.append(maxKeyword);\n    }\n\n    return buf;\n  }\n\n  /**\n   * Gets the maximum confidence for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum confidence value.\n   */\n  static double getMaxConfidence(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getConfidence()) {\n            max = textAnnotation.getConfidence();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Gets the maximum relevance for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum relevance value.\n   */\n  static double getMaxRelevance(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getRelevance()) {\n            max = textAnnotation.getRelevance();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Get metadata from all registered metadata services.\n   */\n  static List<StaticMetadata> getMetadata(final List<StaticMetadataService> mdServices, final MediaPackage mp) {\n    return flatMap(mdServices, new ArrayList<StaticMetadata>(),\n            new Function<StaticMetadataService, Collection<StaticMetadata>>() {\n              @Override\n              public Collection<StaticMetadata> apply(StaticMetadataService s) {\n                StaticMetadata md = s.getMetadata(mp);\n                return md != null ? Arrays.asList(md) : Collections.<StaticMetadata> emptyList();\n              }\n            });\n  }\n\n  /**\n   * Return all media package tags as a space separated string.\n   */\n  static String tags(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      for (String tag : element.getTags()) {\n        sb.append(tag);\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Return all media package flavors as a space separated string.\n   */\n  static String flavors(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (element.getFlavor() != null) {\n        sb.append(element.getFlavor().toString());\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Returns number of entries in search index, across all organizations.\n   *\n   * @return number of entries in search index\n   * @throws SearchServiceDatabaseException\n   *           if count cannot be retrieved\n   */\n  public long count() throws SearchServiceDatabaseException {\n    try {\n      QueryResponse response = solrServer.query(new SolrQuery(\"*:*\"));\n      return response.getResults().getNumFound();\n    } catch (SolrServerException e) {\n      throw new SearchServiceDatabaseException(e);\n    }\n  }\n}\n"], "fixing_code": ["/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl;\n\nimport static org.opencastproject.security.api.SecurityConstants.GLOBAL_ADMIN_ROLE;\n\nimport org.opencastproject.job.api.AbstractJobProducer;\nimport org.opencastproject.job.api.Job;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageSerializer;\nimport org.opencastproject.metadata.api.StaticMetadataService;\nimport org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;\nimport org.opencastproject.search.api.SearchException;\nimport org.opencastproject.search.api.SearchQuery;\nimport org.opencastproject.search.api.SearchResult;\nimport org.opencastproject.search.api.SearchService;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabase;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;\nimport org.opencastproject.search.impl.solr.SolrIndexManager;\nimport org.opencastproject.search.impl.solr.SolrRequester;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.AuthorizationService;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.OrganizationDirectoryService;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.StaticFileAuthorization;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.security.api.UserDirectoryService;\nimport org.opencastproject.security.util.SecurityUtil;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.serviceregistry.api.ServiceRegistry;\nimport org.opencastproject.serviceregistry.api.ServiceRegistryException;\nimport org.opencastproject.solr.SolrServerFactory;\nimport org.opencastproject.util.LoadUtil;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\nimport org.opencastproject.workspace.api.Workspace;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.solr.client.solrj.SolrServer;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.osgi.framework.ServiceException;\nimport org.osgi.service.cm.ConfigurationException;\nimport org.osgi.service.cm.ManagedService;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.Dictionary;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A Solr-based {@link SearchService} implementation.\n */\npublic final class SearchServiceImpl extends AbstractJobProducer implements SearchService, ManagedService,\n    StaticFileAuthorization {\n\n  /** Log facility */\n  private static final Logger logger = LoggerFactory.getLogger(SearchServiceImpl.class);\n\n  /** Configuration key for a remote solr server */\n  public static final String CONFIG_SOLR_URL = \"org.opencastproject.search.solr.url\";\n\n  /** Configuration key for an embedded solr configuration and data directory */\n  public static final String CONFIG_SOLR_ROOT = \"org.opencastproject.search.solr.dir\";\n\n  /** The job type */\n  public static final String JOB_TYPE = \"org.opencastproject.search\";\n\n  /** The load introduced on the system by creating an add job */\n  public static final float DEFAULT_ADD_JOB_LOAD = 0.1f;\n\n  /** The load introduced on the system by creating a delete job */\n  public static final float DEFAULT_DELETE_JOB_LOAD = 0.1f;\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_ADD_JOB_LOAD} */\n  public static final String ADD_JOB_LOAD_KEY = \"job.load.add\";\n\n  /** The key to look for in the service configuration file to override the {@link DEFAULT_DELETE_JOB_LOAD} */\n  public static final String DELETE_JOB_LOAD_KEY = \"job.load.delete\";\n\n  /** The load introduced on the system by creating an add job */\n  private float addJobLoad = DEFAULT_ADD_JOB_LOAD;\n\n  /** The load introduced on the system by creating a delete job */\n  private float deleteJobLoad = DEFAULT_DELETE_JOB_LOAD;\n\n  /** counter how often the index has already been tried to populate */\n  private int retriesToPopulateIndex = 0;\n\n  /** List of available operations on jobs */\n  private enum Operation {\n    Add, Delete\n  };\n\n  /** Solr server */\n  private SolrServer solrServer;\n\n  private SolrRequester solrRequester;\n\n  private SolrIndexManager indexManager;\n\n  private List<StaticMetadataService> mdServices = new ArrayList<StaticMetadataService>();\n\n  private Mpeg7CatalogService mpeg7CatalogService;\n\n  private SeriesService seriesService;\n\n  /** The local workspace */\n  private Workspace workspace;\n\n  /** The security service */\n  private SecurityService securityService;\n\n  /** The authorization service */\n  private AuthorizationService authorizationService;\n\n  /** The service registry */\n  private ServiceRegistry serviceRegistry;\n\n  /** Persistent storage */\n  private SearchServiceDatabase persistence;\n\n  /** The user directory service */\n  protected UserDirectoryService userDirectoryService = null;\n\n  /** The organization directory service */\n  protected OrganizationDirectoryService organizationDirectory = null;\n\n  /** The optional Mediapackage serializer */\n  protected MediaPackageSerializer serializer = null;\n\n  private LoadingCache<Tuple<User, String>, Boolean> cache = null;\n\n  private static final Pattern staticFilePattern = Pattern.compile(\"^/([^/]+)/engage-player/([^/]+)/.*$\");\n\n  /**\n   * Creates a new instance of the search service.\n   */\n  public SearchServiceImpl() {\n    super(JOB_TYPE);\n\n    cache = CacheBuilder.newBuilder()\n        .maximumSize(2048)\n        .expireAfterWrite(1, TimeUnit.MINUTES)\n        .build(new CacheLoader<Tuple<User, String>, Boolean>() {\n          @Override\n          public Boolean load(Tuple<User, String> key) {\n            return loadUrlAccess(key.getB());\n          }\n        });\n  }\n\n  /**\n   * Return the solr index manager\n   *\n   * @return indexManager\n   */\n  public SolrIndexManager getSolrIndexManager() {\n    return indexManager;\n  }\n\n  /**\n   * Service activator, called via declarative services configuration. If the solr server url is configured, we try to\n   * connect to it. If not, the solr data directory with an embedded Solr server is used.\n   *\n   * @param cc\n   *          the component context\n   */\n  @Override\n  public void activate(final ComponentContext cc) throws IllegalStateException {\n    super.activate(cc);\n    final String solrServerUrlConfig = StringUtils.trimToNull(cc.getBundleContext().getProperty(CONFIG_SOLR_URL));\n\n    logger.info(\"Setting up solr server\");\n\n    solrServer = new Object() {\n      SolrServer create() {\n        if (solrServerUrlConfig != null) {\n          /* Use external SOLR server */\n          try {\n            logger.info(\"Setting up solr server at {}\", solrServerUrlConfig);\n            URL solrServerUrl = new URL(solrServerUrlConfig);\n            return setupSolr(solrServerUrl);\n          } catch (MalformedURLException e) {\n            throw connectError(solrServerUrlConfig, e);\n          }\n        } else {\n          /* Set-up embedded SOLR */\n          String solrRoot = SolrServerFactory.getEmbeddedDir(cc, CONFIG_SOLR_ROOT, \"search\");\n\n          try {\n            logger.debug(\"Setting up solr server at {}\", solrRoot);\n            return setupSolr(new File(solrRoot));\n          } catch (IOException e) {\n            throw connectError(solrServerUrlConfig, e);\n          } catch (SolrServerException e) {\n            throw connectError(solrServerUrlConfig, e);\n          }\n        }\n      }\n\n      IllegalStateException connectError(String target, Exception e) {\n        logger.error(\"Unable to connect to solr at {}: {}\", target, e.getMessage());\n        return new IllegalStateException(\"Unable to connect to solr at \" + target, e);\n      }\n      // CHECKSTYLE:OFF\n    }.create();\n    // CHECKSTYLE:ON\n\n    solrRequester = new SolrRequester(solrServer, securityService, serializer);\n    indexManager = new SolrIndexManager(solrServer, workspace, mdServices, seriesService, mpeg7CatalogService,\n            securityService);\n\n    String systemUserName = cc.getBundleContext().getProperty(SecurityUtil.PROPERTY_KEY_SYS_USER);\n    populateIndex(systemUserName);\n  }\n\n  /**\n   * Service deactivator, called via declarative services configuration.\n   */\n  public void deactivate() {\n    SolrServerFactory.shutdown(solrServer);\n  }\n\n  /**\n   * Prepares the embedded solr environment.\n   *\n   * @param solrRoot\n   *          the solr root directory\n   */\n  static SolrServer setupSolr(File solrRoot) throws IOException, SolrServerException {\n    logger.info(\"Setting up solr search index at {}\", solrRoot);\n    File solrConfigDir = new File(solrRoot, \"conf\");\n\n    // Create the config directory\n    if (solrConfigDir.exists()) {\n      logger.info(\"solr search index found at {}\", solrConfigDir);\n    } else {\n      logger.info(\"solr config directory doesn't exist.  Creating {}\", solrConfigDir);\n      FileUtils.forceMkdir(solrConfigDir);\n    }\n\n    // Make sure there is a configuration in place\n    copyClasspathResourceToFile(\"/solr/conf/protwords.txt\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/schema.xml\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/scripts.conf\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/solrconfig.xml\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/stopwords.txt\", solrConfigDir);\n    copyClasspathResourceToFile(\"/solr/conf/synonyms.txt\", solrConfigDir);\n\n    // Test for the existence of a data directory\n    File solrDataDir = new File(solrRoot, \"data\");\n    if (!solrDataDir.exists()) {\n      FileUtils.forceMkdir(solrDataDir);\n    }\n\n    // Test for the existence of the index. Note that an empty index directory will prevent solr from\n    // completing normal setup.\n    File solrIndexDir = new File(solrDataDir, \"index\");\n    if (solrIndexDir.isDirectory() && solrIndexDir.list().length == 0) {\n      FileUtils.deleteDirectory(solrIndexDir);\n    }\n\n    return SolrServerFactory.newEmbeddedInstance(solrRoot, solrDataDir);\n  }\n\n  /**\n   * Prepares the embedded solr environment.\n   *\n   * @param url\n   *          the url of the remote solr server\n   */\n  static SolrServer setupSolr(URL url) {\n    logger.info(\"Connecting to solr search index at {}\", url);\n    return SolrServerFactory.newRemoteInstance(url);\n  }\n\n  // TODO: generalize this method\n  static void copyClasspathResourceToFile(String classpath, File dir) {\n    InputStream in = null;\n    FileOutputStream fos = null;\n    try {\n      in = SearchServiceImpl.class.getResourceAsStream(classpath);\n      File file = new File(dir, FilenameUtils.getName(classpath));\n      logger.debug(\"copying \" + classpath + \" to \" + file);\n      fos = new FileOutputStream(file);\n      IOUtils.copy(in, fos);\n    } catch (IOException e) {\n      throw new RuntimeException(\"Error copying solr classpath resource to the filesystem\", e);\n    } finally {\n      IOUtils.closeQuietly(in);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getByQuery(java.lang.String, int, int)\n   */\n  public SearchResult getByQuery(String query, int limit, int offset) throws SearchException {\n    try {\n      logger.debug(\"Searching index using custom query '\" + query + \"'\");\n      return solrRequester.getByQuery(query, limit, offset);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#add(org.opencastproject.mediapackage.MediaPackage)\n   */\n  public Job add(MediaPackage mediaPackage) throws SearchException, MediaPackageException, IllegalArgumentException,\n          UnauthorizedException, ServiceRegistryException {\n    try {\n      return serviceRegistry.createJob(JOB_TYPE, Operation.Add.toString(),\n              Arrays.asList(MediaPackageParser.getAsXml(mediaPackage)), addJobLoad);\n    } catch (ServiceRegistryException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Immediately adds the mediapackage to the search index.\n   *\n   * @param mediaPackage\n   *          the media package\n   * @throws SearchException\n   *           if the media package cannot be added to the search index\n   * @throws IllegalArgumentException\n   *           if the mediapackage is <code>null</code>\n   * @throws UnauthorizedException\n   *           if the user does not have the rights to add the mediapackage\n   */\n  public void addSynchronously(MediaPackage mediaPackage)\n      throws SearchException, IllegalArgumentException, UnauthorizedException, NotFoundException,\n      SearchServiceDatabaseException {\n    if (mediaPackage == null) {\n      throw new IllegalArgumentException(\"Unable to add a null mediapackage\");\n    }\n    final String mediaPackageId = mediaPackage.getIdentifier().toString();\n    logger.debug(\"Attempting to add media package {} to search index\", mediaPackageId);\n    AccessControlList acl = authorizationService.getActiveAcl(mediaPackage).getA();\n\n    AccessControlList seriesAcl = persistence.getAccessControlLists(mediaPackage.getSeries(), mediaPackageId).stream()\n        .reduce(new AccessControlList(acl.getEntries()), AccessControlList::mergeActions);\n    logger.debug(\"Updating series with merged access control list: {}\", seriesAcl);\n\n    Date now = new Date();\n\n    try {\n      if (indexManager.add(mediaPackage, acl, seriesAcl, now)) {\n        logger.info(\"Added media package `{}` to the search index, using ACL `{}`\", mediaPackageId, acl);\n      } else {\n        logger.warn(\"Failed to add media package {} to the search index\", mediaPackageId);\n      }\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n\n    try {\n      persistence.storeMediaPackage(mediaPackage, acl, now);\n    } catch (SearchServiceDatabaseException e) {\n      throw new SearchException(\n          String.format(\"Could not store media package to search database %s\", mediaPackageId), e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#delete(java.lang.String)\n   */\n  public Job delete(String mediaPackageId) throws SearchException, UnauthorizedException, NotFoundException {\n    try {\n      return serviceRegistry.createJob(JOB_TYPE, Operation.Delete.toString(), Arrays.asList(mediaPackageId), deleteJobLoad);\n    } catch (ServiceRegistryException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Immediately removes the given mediapackage from the search service.\n   *\n   * @param mediaPackageId\n   *          the mediapackage\n   * @return <code>true</code> if the mediapackage was deleted\n   * @throws SearchException\n   *           if deletion failed\n   */\n  public boolean deleteSynchronously(final String mediaPackageId) throws SearchException {\n    SearchResult result;\n    try {\n      result = solrRequester.getForWrite(new SearchQuery().withId(mediaPackageId));\n      if (result.getItems().length == 0) {\n        logger.warn(\n                \"Can not delete mediapackage {}, which is not available for the current user to delete from the search index.\",\n                mediaPackageId);\n        return false;\n      }\n      final String seriesId = result.getItems()[0].getDcIsPartOf();\n      logger.info(\"Removing media package {} from search index\", mediaPackageId);\n\n      Date now = new Date();\n      try {\n        persistence.deleteMediaPackage(mediaPackageId, now);\n        logger.info(\"Removed mediapackage {} from search persistence\", mediaPackageId);\n      } catch (NotFoundException e) {\n        // even if mp not found in persistence, it might still exist in search index.\n        logger.info(\"Could not find mediapackage with id {} in persistence, but will try remove it from index, anyway.\",\n                mediaPackageId);\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Could not delete media package with id {} from persistence storage\", mediaPackageId);\n        throw new SearchException(e);\n      }\n\n      final boolean success = indexManager.delete(mediaPackageId, now);\n\n      // Update series\n      if (seriesId != null) {\n        if (persistence.getMediaPackages(seriesId).size() > 0) {\n          // Update series acl if there are still episodes in the series\n          final AccessControlList seriesAcl = persistence.getAccessControlLists(seriesId).stream()\n              .reduce(new AccessControlList(), AccessControlList::mergeActions);\n          indexManager.addSeries(seriesId, seriesAcl);\n\n        } else {\n          // Remove series if there are no episodes in the series any longer\n          indexManager.delete(seriesId, now);\n        }\n      }\n\n      return success;\n    } catch (SolrServerException | SearchServiceDatabaseException e) {\n      logger.info(\"Could not delete media package with id {} from search index\", mediaPackageId);\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * Clears the complete solr index.\n   *\n   * @throws SearchException\n   *           if clearing the index fails\n   */\n  public void clear() throws SearchException {\n    try {\n      logger.info(\"Clearing the search index\");\n      indexManager.clear();\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getByQuery(org.opencastproject.search.api.SearchQuery)\n   */\n  public SearchResult getByQuery(SearchQuery q) throws SearchException {\n    try {\n      logger.debug(\"Searching index using query object '\" + q + \"'\");\n      return solrRequester.getForRead(q);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.api.SearchService#getForAdministrativeRead(org.opencastproject.search.api.SearchQuery)\n   */\n  @Override\n  public SearchResult getForAdministrativeRead(SearchQuery q) throws SearchException, UnauthorizedException {\n    User user = securityService.getUser();\n    if (!user.hasRole(GLOBAL_ADMIN_ROLE) && !user.hasRole(user.getOrganization().getAdminRole()))\n      throw new UnauthorizedException(user, getClass().getName() + \".getForAdministrativeRead\");\n\n    try {\n      return solrRequester.getForAdministrativeRead(q);\n    } catch (SolrServerException e) {\n      throw new SearchException(e);\n    }\n  }\n\n  protected void populateIndex(String systemUserName) {\n    long instancesInSolr = 0L;\n\n    try {\n      instancesInSolr = indexManager.count();\n    } catch (Exception e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (instancesInSolr > 0) {\n      logger.debug(\"Search index found\");\n      return;\n    }\n\n    if (instancesInSolr == 0L) {\n      logger.info(\"No search index found\");\n      Iterator<Tuple<MediaPackage, String>> mediaPackages;\n      int total = 0;\n      try {\n        total = persistence.countMediaPackages();\n        logger.info(\"Starting population of search index from {} items in database\", total);\n        mediaPackages = persistence.getAllMediaPackages();\n      } catch (SearchServiceDatabaseException e) {\n        logger.error(\"Unable to load the search entries: {}\", e.getMessage());\n        throw new ServiceException(e.getMessage());\n      }\n      int errors = 0;\n      int current = 0;\n      while (mediaPackages.hasNext()) {\n        current++;\n        try {\n          Tuple<MediaPackage, String> mediaPackage = mediaPackages.next();\n\n          String mediaPackageId = mediaPackage.getA().getIdentifier().toString();\n\n          Organization organization = organizationDirectory.getOrganization(mediaPackage.getB());\n          securityService.setOrganization(organization);\n          securityService.setUser(SecurityUtil.createSystemUser(systemUserName, organization));\n\n          AccessControlList acl = persistence.getAccessControlList(mediaPackageId);\n          Date modificationDate = persistence.getModificationDate(mediaPackageId);\n          Date deletionDate = persistence.getDeletionDate(mediaPackageId);\n\n          indexManager.add(mediaPackage.getA(), acl, deletionDate, modificationDate);\n        } catch (Exception e) {\n          logger.error(\"Unable to index search instances:\", e);\n          if (retryToPopulateIndex(systemUserName)) {\n            logger.warn(\"Trying to re-index search index later. Aborting for now.\");\n            return;\n          }\n          errors++;\n        } finally {\n          securityService.setOrganization(null);\n          securityService.setUser(null);\n        }\n\n        // log progress\n        if (current % 100 == 0) {\n          logger.info(\"Indexing search {}/{} ({} percent done)\", current, total, current * 100 / total);\n        }\n      }\n      if (errors > 0)\n        logger.error(\"Skipped {} erroneous search entries while populating the search index\", errors);\n      logger.info(\"Finished populating search index\");\n    }\n  }\n\n  private boolean retryToPopulateIndex(final String systemUserName) {\n    if (retriesToPopulateIndex > 0) {\n      return false;\n    }\n\n    long instancesInSolr = 0L;\n\n    try {\n      instancesInSolr = indexManager.count();\n    } catch (Exception e) {\n      throw new IllegalStateException(e);\n    }\n\n    if (instancesInSolr > 0) {\n      logger.debug(\"Search index found, other files could be indexed. No retry needed.\");\n      return false;\n    }\n\n    retriesToPopulateIndex++;\n\n      new Thread() {\n        public void run() {\n          try {\n            Thread.sleep(30000);\n          } catch (InterruptedException ex) {\n          }\n          populateIndex(systemUserName);\n        }\n      }.start();\n    return true;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#process(org.opencastproject.job.api.Job)\n   */\n  @Override\n  protected String process(Job job) throws Exception {\n    Operation op = null;\n    String operation = job.getOperation();\n    List<String> arguments = job.getArguments();\n    try {\n      op = Operation.valueOf(operation);\n      switch (op) {\n        case Add:\n          MediaPackage mediaPackage = MediaPackageParser.getFromXml(arguments.get(0));\n          addSynchronously(mediaPackage);\n          return null;\n        case Delete:\n          String mediapackageId = arguments.get(0);\n          boolean deleted = deleteSynchronously(mediapackageId);\n          return Boolean.toString(deleted);\n        default:\n          throw new IllegalStateException(\"Don't know how to handle operation '\" + operation + \"'\");\n      }\n    } catch (IllegalArgumentException e) {\n      throw new ServiceRegistryException(\"This service can't handle operations of type '\" + op + \"'\", e);\n    } catch (IndexOutOfBoundsException e) {\n      throw new ServiceRegistryException(\"This argument list for operation '\" + op + \"' does not meet expectations\", e);\n    } catch (Exception e) {\n      throw new ServiceRegistryException(\"Error handling operation '\" + op + \"'\", e);\n    }\n  }\n\n  /** For testing purposes only! */\n  void testSetup(SolrServer server, SolrRequester requester, SolrIndexManager manager) {\n    this.solrServer = server;\n    this.solrRequester = requester;\n    this.indexManager = manager;\n  }\n\n  /** Dynamic reference. */\n  public void setStaticMetadataService(StaticMetadataService mdService) {\n    this.mdServices.add(mdService);\n    if (indexManager != null)\n      indexManager.setStaticMetadataServices(mdServices);\n  }\n\n  public void unsetStaticMetadataService(StaticMetadataService mdService) {\n    this.mdServices.remove(mdService);\n    if (indexManager != null)\n      indexManager.setStaticMetadataServices(mdServices);\n  }\n\n  public void setMpeg7CatalogService(Mpeg7CatalogService mpeg7CatalogService) {\n    this.mpeg7CatalogService = mpeg7CatalogService;\n  }\n\n  public void setPersistence(SearchServiceDatabase persistence) {\n    this.persistence = persistence;\n  }\n\n  public void setSeriesService(SeriesService seriesService) {\n    this.seriesService = seriesService;\n  }\n\n  public void setWorkspace(Workspace workspace) {\n    this.workspace = workspace;\n  }\n\n  public void setAuthorizationService(AuthorizationService authorizationService) {\n    this.authorizationService = authorizationService;\n  }\n\n  public void setServiceRegistry(ServiceRegistry serviceRegistry) {\n    this.serviceRegistry = serviceRegistry;\n  }\n\n  /**\n   * Callback for setting the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  /**\n   * Callback for setting the user directory service.\n   *\n   * @param userDirectoryService\n   *          the userDirectoryService to set\n   */\n  public void setUserDirectoryService(UserDirectoryService userDirectoryService) {\n    this.userDirectoryService = userDirectoryService;\n  }\n\n  /**\n   * Sets a reference to the organization directory service.\n   *\n   * @param organizationDirectory\n   *          the organization directory\n   */\n  public void setOrganizationDirectoryService(OrganizationDirectoryService organizationDirectory) {\n    this.organizationDirectory = organizationDirectory;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getOrganizationDirectoryService()\n   */\n  @Override\n  protected OrganizationDirectoryService getOrganizationDirectoryService() {\n    return organizationDirectory;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getSecurityService()\n   */\n  @Override\n  protected SecurityService getSecurityService() {\n    return securityService;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getServiceRegistry()\n   */\n  @Override\n  protected ServiceRegistry getServiceRegistry() {\n    return serviceRegistry;\n  }\n\n  /**\n   * @see org.opencastproject.job.api.AbstractJobProducer#getUserDirectoryService()\n   */\n  @Override\n  protected UserDirectoryService getUserDirectoryService() {\n    return userDirectoryService;\n  }\n\n  /**\n   * Sets the optional MediaPackage serializer.\n   *\n   * @param serializer\n   *          the serializer\n   */\n  protected void setMediaPackageSerializer(MediaPackageSerializer serializer) {\n    this.serializer = serializer;\n    if (solrRequester != null)\n      solrRequester.setMediaPackageSerializer(serializer);\n  }\n\n  @Override\n  public void updated(@SuppressWarnings(\"rawtypes\") Dictionary properties) throws ConfigurationException {\n    addJobLoad = LoadUtil.getConfiguredLoadValue(properties, ADD_JOB_LOAD_KEY, DEFAULT_ADD_JOB_LOAD, serviceRegistry);\n    deleteJobLoad = LoadUtil.getConfiguredLoadValue(properties, DELETE_JOB_LOAD_KEY, DEFAULT_DELETE_JOB_LOAD, serviceRegistry);\n  }\n\n  @Override\n  public List<Pattern> getProtectedUrlPattern() {\n    return Collections.singletonList(staticFilePattern);\n  }\n\n  private boolean loadUrlAccess(final String mediaPackageId) {\n    logger.debug(\"Check if user `{}` has access to media package `{}`\", securityService.getUser(), mediaPackageId);\n    final SearchQuery query = new SearchQuery()\n        .withId(mediaPackageId)\n        .includeEpisodes(true)\n        .includeSeries(false);\n    return getByQuery(query).size() > 0;\n  }\n\n  @Override\n  public boolean verifyUrlAccess(final String path) {\n    // Always allow access for admin\n    final User user = securityService.getUser();\n    if (user.hasRole(GLOBAL_ADMIN_ROLE)) {\n      logger.debug(\"Allow access for admin `{}`\", user);\n      return true;\n    }\n\n    // Check pattern\n    final Matcher m = staticFilePattern.matcher(path);\n    if (!m.matches()) {\n      logger.debug(\"Path does not match pattern. Preventing access.\");\n      return false;\n    }\n\n    // Check organization\n    final String organizationId = m.group(1);\n    if (!securityService.getOrganization().getId().equals(organizationId)) {\n      logger.debug(\"The user's organization does not match. Preventing access.\");\n      return false;\n    }\n\n    // Check search index/cache\n    final String mediaPackageId = m.group(2);\n    final boolean access = cache.getUnchecked(Tuple.tuple(user, mediaPackageId));\n    logger.debug(\"Check if user `{}` has access to media package `{}` using cache: {}\", user, mediaPackageId, access);\n    return access;\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.impl.jpa.JpaOrganization;\n\nimport java.util.Date;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.Index;\nimport javax.persistence.JoinColumn;\nimport javax.persistence.Lob;\nimport javax.persistence.NamedQueries;\nimport javax.persistence.NamedQuery;\nimport javax.persistence.OneToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\n\n/**\n * Entity object for storing search in persistence storage. Media package id is stored as primary key.\n */\n@Entity(name = \"SearchEntity\")\n@Table(name = \"oc_search\", indexes = {\n    @Index(name = \"IX_oc_search_series\", columnList = (\"series_id\")),\n    @Index(name = \"IX_oc_search_organization\", columnList = (\"organization\")) })\n@NamedQueries({\n    @NamedQuery(name = \"Search.findAll\", query = \"SELECT s FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.getCount\", query = \"SELECT COUNT(s) FROM SearchEntity s\"),\n    @NamedQuery(name = \"Search.findById\", query = \"SELECT s FROM SearchEntity s WHERE s.mediaPackageId=:mediaPackageId\"),\n    @NamedQuery(name = \"Search.findBySeriesId\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId=:seriesId and \"\n        + \"s.deletionDate is null\"),\n    @NamedQuery(name = \"Search.getNoSeries\", query = \"SELECT s FROM SearchEntity s WHERE s.seriesId IS NULL\")})\npublic class SearchEntity {\n\n  /** media package id, primary key */\n  @Id\n  @Column(name = \"id\", length = 128)\n  private String mediaPackageId;\n\n  @Column(name = \"series_id\", length = 128)\n  protected String seriesId;\n\n  /** Organization id */\n  @OneToOne(targetEntity = JpaOrganization.class)\n  @JoinColumn(name = \"organization\", referencedColumnName = \"id\")\n  protected JpaOrganization organization;\n\n  /** The media package deleted */\n  @Column(name = \"deletion_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date deletionDate;\n\n  /** The media package deleted */\n  @Column(name = \"modification_date\")\n  @Temporal(TemporalType.TIMESTAMP)\n  private Date modificationDate;\n\n  /** Serialized media package */\n  @Lob\n  @Column(name = \"mediapackage_xml\", length = 65535)\n  private String mediaPackageXML;\n\n  /** Serialized access control */\n  @Lob\n  @Column(name = \"access_control\", length = 65535)\n  protected String accessControl;\n\n  /**\n   * Default constructor without any import.\n   */\n  public SearchEntity() {\n  }\n\n  /**\n   * Returns media package id.\n   *\n   * @return media package id\n   */\n  public String getMediaPackageId() {\n    return mediaPackageId;\n  }\n\n  /**\n   * Sets media package id. Id length limit is 128 charachters.\n   *\n   * @param mediaPackageId\n   */\n  public void setMediaPackageId(String mediaPackageId) {\n    this.mediaPackageId = mediaPackageId;\n  }\n\n  /**\n   * Returns serialized media package.\n   *\n   * @return serialized media package\n   */\n  public String getMediaPackageXML() {\n    return mediaPackageXML;\n  }\n\n  /**\n   * Sets serialized media package\n   *\n   * @param mediaPackageXML\n   */\n  public void setMediaPackageXML(String mediaPackageXML) {\n    this.mediaPackageXML = mediaPackageXML;\n  }\n\n  /**\n   * Returns serialized access control\n   *\n   * @return serialized access control\n   */\n  public String getAccessControl() {\n    return accessControl;\n  }\n\n  /**\n   * Sets serialized access control.\n   *\n   * @param accessControl\n   *          serialized access control\n   */\n  public void setAccessControl(String accessControl) {\n    this.accessControl = accessControl;\n  }\n\n  /**\n   * @return the organization\n   */\n  public JpaOrganization getOrganization() {\n    return organization;\n  }\n\n  /**\n   * @param organization\n   *          the organization to set\n   */\n  public void setOrganization(Organization organization) {\n    if (organization instanceof JpaOrganization) {\n      this.organization = (JpaOrganization) organization;\n    } else {\n      this.organization = new JpaOrganization(organization.getId(), organization.getName(), organization.getServers(),\n          organization.getAdminRole(), organization.getAnonymousRole(), organization.getProperties());\n    }\n  }\n\n  /**\n   * @return the deletion date\n   */\n  public Date getDeletionDate() {\n    return deletionDate;\n  }\n\n  /**\n   * Sets the deletion date\n   *\n   * @param deletionDate\n   *          the deletion date\n   */\n  public void setDeletionDate(Date deletionDate) {\n    this.deletionDate = deletionDate;\n  }\n\n  /**\n   * @return the modification date\n   */\n  public Date getModificationDate() {\n    return modificationDate;\n  }\n\n  /**\n   * Sets the modification date\n   *\n   * @param modificationDate\n   *          the modification date\n   */\n  public void setModificationDate(Date modificationDate) {\n    this.modificationDate = modificationDate;\n  }\n\n  /**\n   * @return the series Id for this search entry\n   */\n  public String getSeriesId() {\n    return seriesId;\n  }\n\n  /**\n   * Sets the series ID\n   *\n   * @param seriesId\n   *          the series ID\n   */\n  public void setSeriesId(String seriesId) {\n    this.seriesId = seriesId;\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\n\n/**\n * API that defines persistent storage of series.\n *\n */\npublic interface SearchServiceDatabase {\n\n  /**\n   * Returns all search entries in persistent storage.\n   *\n   * @return {@link Tuple} array representing stored media packages\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   */\n  Iterator<Tuple<MediaPackage, String>> getAllMediaPackages() throws SearchServiceDatabaseException;\n\n  /**\n   * Returns the organization id of the selected media package\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the organization id\n   * @throws NotFoundException\n   *           if media package with specified id and version does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  String getOrganizationId(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Returns the number of mediapackages in persistent storage, including deleted entries.\n   *\n   * @return the number of mediapackages in storage\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  int countMediaPackages() throws SearchServiceDatabaseException;\n\n  /**\n   * Gets a single media package by its identifier.\n   *\n   * @param mediaPackageId\n   *          the media package identifier\n   * @return the media package\n   * @throws NotFoundException\n   *           if there is no media package with this identifier\n   * @throws SearchServiceDatabaseException\n   *           if there is a problem communicating with the underlying data store\n   */\n  MediaPackage getMediaPackage(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Gets media packages from a specific series\n   *\n   * @param seriesId\n   *          the series identifier\n   * @return collection of media packages\n   * @throws SearchServiceDatabaseException\n   *           if there is a problem communicating with the underlying data store\n   */\n  Collection<MediaPackage> getMediaPackages(String seriesId) throws SearchServiceDatabaseException;\n\n  /**\n   * Retrieves ACL for episode with given ID.\n   *\n   * @param mediaPackageId\n   *          media package for which ACL will be retrieved\n   * @return {@link AccessControlList} of media package or null if media package does not have ACL associated with it\n   * @throws NotFoundException\n   *           if media package with given ID does not exist\n   * @throws SearchServiceDatabaseException\n   *           if exception occurred\n   */\n  AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n      SearchServiceDatabaseException;\n\n  /**\n   * Retrieves ACLs for series with given ID.\n   *\n   * @param seriesId\n   *          series identifier for which ACL will be retrieved\n   * @param excludeIds\n   *          list of media package identifier to exclude from the list\n   * @return Collection of {@link AccessControlList} of media packages from the series\n   * @throws SearchServiceDatabaseException\n   *           if exception occurred\n   */\n  Collection<AccessControlList> getAccessControlLists(String seriesId, String ... excludeIds)\n      throws SearchServiceDatabaseException;\n\n  /**\n   * Returns the modification date from the selected media package.\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the modification date\n   * @throws NotFoundException\n   *           if media package with specified id and version does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  Date getModificationDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Returns the deletion date from the selected media package.\n   *\n   * @param mediaPackageId\n   *          the media package id to select\n   * @return the deletion date\n   * @throws NotFoundException\n   *           if media package with specified id does not exist\n   * @throws SearchServiceDatabaseException\n   *           if an error occurs\n   */\n  Date getDeletionDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException;\n\n  /**\n   * Removes media package from persistent storage.\n   *\n   * @param mediaPackageId\n   *          id of the media package to be removed\n   * @param deletionDate\n   *          the deletion date to set\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   * @throws NotFoundException\n   *           if media package with specified id is not found\n   */\n  void deleteMediaPackage(String mediaPackageId, Date deletionDate) throws SearchServiceDatabaseException,\n          NotFoundException;\n\n  /**\n   * Store (or update) media package.\n   *\n   * @param mediaPackage\n   *          {@link MediaPackage} to store\n   * @param acl\n   *          the acl of the media package\n   * @param now\n   *          the store date\n   * @throws SearchServiceDatabaseException\n   *           if exception occurs\n   * @throws UnauthorizedException\n   *           if the current user is not authorized to perform this action\n   */\n  void storeMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date now)\n          throws SearchServiceDatabaseException, UnauthorizedException;\n\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\npackage org.opencastproject.search.impl.persistence;\n\nimport static org.opencastproject.security.api.Permissions.Action.CONTRIBUTE;\nimport static org.opencastproject.security.api.Permissions.Action.READ;\nimport static org.opencastproject.security.api.Permissions.Action.WRITE;\n\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.AccessControlParser;\nimport org.opencastproject.security.api.AccessControlParsingException;\nimport org.opencastproject.security.api.AccessControlUtil;\nimport org.opencastproject.security.api.Organization;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.security.api.User;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.data.Tuple;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.EntityTransaction;\nimport javax.persistence.NoResultException;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;\n\n/**\n * Implements {@link SearchServiceDatabase}. Defines permanent storage for series.\n */\npublic class SearchServiceDatabaseImpl implements SearchServiceDatabase {\n\n  /** JPA persistence unit name */\n  public static final String PERSISTENCE_UNIT = \"org.opencastproject.search.impl.persistence\";\n\n  /** Logging utilities */\n  private static final Logger logger = LoggerFactory.getLogger(SearchServiceDatabaseImpl.class);\n\n  /** Factory used to create {@link EntityManager}s for transactions */\n  protected EntityManagerFactory emf;\n\n  /** The security service */\n  protected SecurityService securityService;\n\n  /** OSGi DI */\n  public void setEntityManagerFactory(EntityManagerFactory emf) {\n    this.emf = emf;\n  }\n\n  /**\n   * Creates {@link EntityManagerFactory} using persistence provider and properties passed via OSGi.\n   *\n   * @param cc\n   * @throws SearchServiceDatabaseException\n   */\n  public void activate(ComponentContext cc) throws SearchServiceDatabaseException {\n    logger.info(\"Activating persistence manager for search service\");\n    this.populateSeriesData();\n  }\n\n  /**\n   * OSGi callback to set the security service.\n   *\n   * @param securityService\n   *          the securityService to set\n   */\n  public void setSecurityService(SecurityService securityService) {\n    this.securityService = securityService;\n  }\n\n  private void populateSeriesData() throws SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      TypedQuery<SearchEntity> q = (TypedQuery<SearchEntity>) em.createNamedQuery(\"Search.getNoSeries\");\n      List<SearchEntity> seriesList = q.getResultList();\n      for (SearchEntity series : seriesList) {\n        String mpSeriesId = MediaPackageParser.getFromXml(series.getMediaPackageXML()).getSeries();\n        if (StringUtils.isNotBlank(mpSeriesId) && !mpSeriesId.equals(series.getSeriesId())) {\n          logger.info(\"Fixing missing series ID for episode {}, series is {}\", series.getMediaPackageId(), mpSeriesId);\n          series.setSeriesId(mpSeriesId);\n          em.merge(series);\n        }\n      }\n      tx.commit();\n    } catch (Exception e) {\n      logger.error(\"Could not update media package: {}\", e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#deleteMediaPackage(String, Date)\n   */\n  @Override\n  public void deleteMediaPackage(String mediaPackageId, Date deletionDate) throws SearchServiceDatabaseException,\n  NotFoundException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n\n      // Ensure this user is allowed to delete this episode\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, WRITE.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to delete media package \" + mediaPackageId);\n\n        searchEntity.setDeletionDate(deletionDate);\n        em.merge(searchEntity);\n      }\n      tx.commit();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not delete episode {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#countMediaPackages()\n   */\n  @Override\n  public int countMediaPackages() throws SearchServiceDatabaseException {\n    EntityManager em = emf.createEntityManager();\n    Query query = em.createNamedQuery(\"Search.getCount\");\n    try {\n      Long total = (Long) query.getSingleResult();\n      return total.intValue();\n    } catch (Exception e) {\n      logger.error(\"Could not find number of mediapackages\", e);\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }\n\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getAllMediaPackages()\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public Iterator<Tuple<MediaPackage, String>> getAllMediaPackages() throws SearchServiceDatabaseException {\n    List<SearchEntity> searchEntities = null;\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      Query query = em.createNamedQuery(\"Search.findAll\");\n      searchEntities = (List<SearchEntity>) query.getResultList();\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve all episodes: {}\", e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n    List<Tuple<MediaPackage, String>> mediaPackageList = new LinkedList<Tuple<MediaPackage, String>>();\n    try {\n      for (SearchEntity entity : searchEntities) {\n        MediaPackage mediaPackage = MediaPackageParser.getFromXml(entity.getMediaPackageXML());\n        mediaPackageList.add(Tuple.tuple(mediaPackage, entity.getOrganization().getId()));\n      }\n    } catch (Exception e) {\n      logger.error(\"Could not parse series entity: {}\", e.getMessage());\n      throw new SearchServiceDatabaseException(e);\n    }\n    return mediaPackageList.iterator();\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getAccessControlList(String)\n   */\n  @Override\n  public AccessControlList getAccessControlList(String mediaPackageId) throws NotFoundException,\n  SearchServiceDatabaseException {\n    EntityManager em = null;\n    try {\n      em = emf.createEntityManager();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        throw new NotFoundException(\"Could not found media package with ID \" + mediaPackageId);\n      }\n      if (entity.getAccessControl() == null) {\n        return null;\n      } else {\n        return AccessControlParser.parseAcl(entity.getAccessControl());\n      }\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not retrieve ACL {}\", mediaPackageId, e);\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getAccessControlLists(String, String...)\n   */\n  @Override\n  public Collection<AccessControlList> getAccessControlLists(final String seriesId, String ... excludeIds)\n      throws SearchServiceDatabaseException {\n    List<String> excludes = Arrays.asList(excludeIds);\n    List<AccessControlList> accessControlLists = new ArrayList<>();\n    EntityManager em = emf.createEntityManager();\n    TypedQuery<SearchEntity> q = em.createNamedQuery(\"Search.findBySeriesId\", SearchEntity.class)\n        .setParameter(\"seriesId\", seriesId);\n    try {\n      for (SearchEntity entity: q.getResultList()) {\n        if (entity.getAccessControl() != null && !excludes.contains(entity.getMediaPackageId())) {\n          accessControlLists.add(AccessControlParser.parseAcl(entity.getAccessControl()));\n        }\n      }\n    } catch (IOException | AccessControlParsingException e) {\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n    return accessControlLists;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getMediaPackages(String)\n   */\n  @Override\n  public Collection<MediaPackage> getMediaPackages(final String seriesId)\n      throws SearchServiceDatabaseException {\n    List<MediaPackage> episodes = new ArrayList<>();\n    EntityManager em = emf.createEntityManager();\n    TypedQuery<SearchEntity> q = em.createNamedQuery(\"Search.findBySeriesId\", SearchEntity.class)\n        .setParameter(\"seriesId\", seriesId);\n    try {\n      for (SearchEntity entity: q.getResultList()) {\n        if (entity.getMediaPackageXML() != null) {\n          episodes.add(MediaPackageParser.getFromXml(entity.getMediaPackageXML()));\n        }\n      }\n    } catch (MediaPackageException e) {\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      em.close();\n    }\n    return episodes;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#storeMediaPackage(MediaPackage,\n   *      AccessControlList, Date)\n   */\n  @Override\n  public void storeMediaPackage(MediaPackage mediaPackage, AccessControlList acl, Date now)\n          throws SearchServiceDatabaseException, UnauthorizedException {\n    String mediaPackageXML = MediaPackageParser.getAsXml(mediaPackage);\n    String mediaPackageId = mediaPackage.getIdentifier().toString();\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity entity = getSearchEntity(mediaPackageId, em);\n      if (entity == null) {\n        // Create new search entity\n        SearchEntity searchEntity = new SearchEntity();\n        searchEntity.setOrganization(securityService.getOrganization());\n        searchEntity.setMediaPackageId(mediaPackageId);\n        searchEntity.setMediaPackageXML(mediaPackageXML);\n        searchEntity.setAccessControl(AccessControlParser.toXml(acl));\n        searchEntity.setModificationDate(now);\n        searchEntity.setSeriesId(mediaPackage.getSeries());\n        em.persist(searchEntity);\n      } else {\n        // Ensure this user is allowed to update this media package\n        String accessControlXml = entity.getAccessControl();\n        if (accessControlXml != null) {\n          AccessControlList accessList = AccessControlParser.parseAcl(accessControlXml);\n          User currentUser = securityService.getUser();\n          Organization currentOrg = securityService.getOrganization();\n          if (!AccessControlUtil.isAuthorized(accessList, currentUser, currentOrg, WRITE.toString())) {\n            throw new UnauthorizedException(currentUser + \" is not authorized to update media package \"\n                    + mediaPackageId);\n          }\n        }\n        entity.setOrganization(securityService.getOrganization());\n        entity.setMediaPackageId(mediaPackageId);\n        entity.setMediaPackageXML(mediaPackageXML);\n        entity.setAccessControl(AccessControlParser.toXml(acl));\n        entity.setModificationDate(now);\n        entity.setDeletionDate(null);\n        entity.setSeriesId(mediaPackage.getSeries());\n        em.merge(entity);\n      }\n      tx.commit();\n    } catch (Exception e) {\n      logger.error(\"Could not update media package: {}\", e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getMediaPackage(String)\n   */\n  @Override\n  public MediaPackage getMediaPackage(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity episodeEntity = getSearchEntity(mediaPackageId, em);\n      if (episodeEntity == null)\n        throw new NotFoundException(\"No episode with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this episode\n      String accessControlXml = episodeEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        // There are several reasons a user may need to load a episode: to read content, to edit it, or add content\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString())\n                && !AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, CONTRIBUTE.toString())\n                && !AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, WRITE.toString())) {\n          throw new UnauthorizedException(currentUser + \" is not authorized to see episode \" + mediaPackageId);\n        }\n      }\n      return MediaPackageParser.getFromXml(episodeEntity.getMediaPackageXML());\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get episode {} from database: {} \", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getModificationDate(String)\n   */\n  @Override\n  public Date getModificationDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getModificationDate();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get modification date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getDeletionDate(String)\n   */\n  @Override\n  public Date getDeletionDate(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null) {\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      }\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getDeletionDate();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get deletion date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * @see org.opencastproject.search.impl.persistence.SearchServiceDatabase#getOrganizationId(String)\n   */\n  @Override\n  public String getOrganizationId(String mediaPackageId) throws NotFoundException, SearchServiceDatabaseException {\n    EntityManager em = null;\n    EntityTransaction tx = null;\n    try {\n      em = emf.createEntityManager();\n      tx = em.getTransaction();\n      tx.begin();\n      SearchEntity searchEntity = getSearchEntity(mediaPackageId, em);\n      if (searchEntity == null)\n        throw new NotFoundException(\"No media package with id=\" + mediaPackageId + \" exists\");\n      // Ensure this user is allowed to read this media package\n      String accessControlXml = searchEntity.getAccessControl();\n      if (accessControlXml != null) {\n        AccessControlList acl = AccessControlParser.parseAcl(accessControlXml);\n        User currentUser = securityService.getUser();\n        Organization currentOrg = securityService.getOrganization();\n        if (!AccessControlUtil.isAuthorized(acl, currentUser, currentOrg, READ.toString()))\n          throw new UnauthorizedException(currentUser + \" is not authorized to read media package \" + mediaPackageId);\n      }\n      return searchEntity.getOrganization().getId();\n    } catch (NotFoundException e) {\n      throw e;\n    } catch (Exception e) {\n      logger.error(\"Could not get deletion date {}: {}\", mediaPackageId, e.getMessage());\n      if (tx.isActive()) {\n        tx.rollback();\n      }\n      throw new SearchServiceDatabaseException(e);\n    } finally {\n      if (em != null)\n        em.close();\n    }\n  }\n\n  /**\n   * Gets a search entity by it's id, using the current organizational context.\n   *\n   * @param id\n   *          the media package identifier\n   * @param em\n   *          an open entity manager\n   * @return the search entity, or null if not found\n   */\n  private SearchEntity getSearchEntity(String id, EntityManager em) {\n    Query q = em.createNamedQuery(\"Search.findById\").setParameter(\"mediaPackageId\", id);\n    try {\n      return (SearchEntity) q.getSingleResult();\n    } catch (NoResultException e) {\n      return null;\n    }\n  }\n}\n", "/**\n * Licensed to The Apereo Foundation under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n *\n * The Apereo Foundation licenses this file to you under the Educational\n * Community License, Version 2.0 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of the License\n * at:\n *\n *   http://opensource.org/licenses/ecl2.txt\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations under\n * the License.\n *\n */\n\n\npackage org.opencastproject.search.impl.solr;\n\nimport static org.opencastproject.security.api.Permissions.Action.READ;\nimport static org.opencastproject.security.api.Permissions.Action.WRITE;\nimport static org.opencastproject.util.RequireUtil.notNull;\nimport static org.opencastproject.util.data.Collections.flatMap;\nimport static org.opencastproject.util.data.Collections.head;\nimport static org.opencastproject.util.data.Collections.map;\nimport static org.opencastproject.util.data.Option.option;\n\nimport org.opencastproject.mediapackage.Attachment;\nimport org.opencastproject.mediapackage.Catalog;\nimport org.opencastproject.mediapackage.MediaPackage;\nimport org.opencastproject.mediapackage.MediaPackageElement;\nimport org.opencastproject.mediapackage.MediaPackageElements;\nimport org.opencastproject.mediapackage.MediaPackageException;\nimport org.opencastproject.mediapackage.MediaPackageParser;\nimport org.opencastproject.mediapackage.MediaPackageReference;\nimport org.opencastproject.metadata.api.MetadataValue;\nimport org.opencastproject.metadata.api.StaticMetadata;\nimport org.opencastproject.metadata.api.StaticMetadataService;\nimport org.opencastproject.metadata.api.util.Interval;\nimport org.opencastproject.metadata.dublincore.DCMIPeriod;\nimport org.opencastproject.metadata.dublincore.DublinCore;\nimport org.opencastproject.metadata.dublincore.DublinCoreCatalog;\nimport org.opencastproject.metadata.dublincore.DublinCoreValue;\nimport org.opencastproject.metadata.dublincore.EncodingSchemeUtils;\nimport org.opencastproject.metadata.dublincore.Temporal;\nimport org.opencastproject.metadata.mpeg7.AudioVisual;\nimport org.opencastproject.metadata.mpeg7.FreeTextAnnotation;\nimport org.opencastproject.metadata.mpeg7.KeywordAnnotation;\nimport org.opencastproject.metadata.mpeg7.MediaDuration;\nimport org.opencastproject.metadata.mpeg7.MediaTime;\nimport org.opencastproject.metadata.mpeg7.MediaTimePoint;\nimport org.opencastproject.metadata.mpeg7.Mpeg7Catalog;\nimport org.opencastproject.metadata.mpeg7.Mpeg7CatalogService;\nimport org.opencastproject.metadata.mpeg7.MultimediaContent;\nimport org.opencastproject.metadata.mpeg7.MultimediaContentType;\nimport org.opencastproject.metadata.mpeg7.SpatioTemporalDecomposition;\nimport org.opencastproject.metadata.mpeg7.TextAnnotation;\nimport org.opencastproject.metadata.mpeg7.Video;\nimport org.opencastproject.metadata.mpeg7.VideoSegment;\nimport org.opencastproject.metadata.mpeg7.VideoText;\nimport org.opencastproject.search.api.SearchResultItem.SearchResultItemType;\nimport org.opencastproject.search.impl.persistence.SearchServiceDatabaseException;\nimport org.opencastproject.security.api.AccessControlEntry;\nimport org.opencastproject.security.api.AccessControlList;\nimport org.opencastproject.security.api.SecurityService;\nimport org.opencastproject.security.api.UnauthorizedException;\nimport org.opencastproject.series.api.SeriesException;\nimport org.opencastproject.series.api.SeriesService;\nimport org.opencastproject.util.NotFoundException;\nimport org.opencastproject.util.SolrUtils;\nimport org.opencastproject.util.data.Function;\nimport org.opencastproject.util.data.Option;\nimport org.opencastproject.workspace.api.Workspace;\n\nimport org.apache.solr.client.solrj.SolrQuery;\nimport org.apache.solr.client.solrj.SolrServer;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.client.solrj.util.ClientUtils;\nimport org.apache.solr.common.SolrDocument;\nimport org.apache.solr.common.SolrInputDocument;\nimport org.apache.solr.common.params.SolrParams;\nimport org.apache.solr.servlet.SolrRequestParsers;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * Utility class used to manage the search index.\n */\npublic class SolrIndexManager {\n\n  /** Logging facility */\n  private static final Logger logger = LoggerFactory.getLogger(SolrIndexManager.class);\n\n  /** Connection to the database */\n  private SolrServer solrServer = null;\n\n  /**\n   * Factor multiplied to fine tune relevance and confidence impact on important keyword decision. importance =\n   * RELEVANCE_BOOST * relevance + confidence\n   */\n  private static final double RELEVANCE_BOOST = 2.0;\n\n  /** Number of characters an important should have at least. */\n  private static final int MAX_CHAR = 3;\n\n  /** Maximum number of important keywords to detect. */\n  private static final int MAX_IMPORTANT_COUNT = 10;\n\n  /** List of metadata services sorted by priority in reverse order. */\n  private List<StaticMetadataService> mdServices;\n\n  private SeriesService seriesService;\n\n  private Mpeg7CatalogService mpeg7CatalogService;\n\n  private Workspace workspace;\n\n  private SecurityService securityService;\n\n  /** Convert a DublinCoreValue into a date. */\n  private static Function<DublinCoreValue, Option<Date>> toDateF = new Function<DublinCoreValue, Option<Date>>() {\n    @Override\n    public Option<Date> apply(DublinCoreValue v) {\n      return EncodingSchemeUtils.decodeTemporal(v).fold(new Temporal.Match<Option<Date>>() {\n        @Override\n        public Option<Date> period(DCMIPeriod period) {\n          return option(period.getStart());\n        }\n\n        @Override\n        public Option<Date> instant(Date instant) {\n          return Option.some(instant);\n        }\n\n        @Override\n        public Option<Date> duration(long duration) {\n          return Option.none();\n        }\n      });\n    }\n  };\n\n  /** Convert a DublinCoreValue into a duration (long). */\n  private static Function<DublinCoreValue, Option<Long>> toDurationF = new Function<DublinCoreValue, Option<Long>>() {\n    @Override\n    public Option<Long> apply(DublinCoreValue dublinCoreValue) {\n      return option(EncodingSchemeUtils.decodeDuration(dublinCoreValue));\n    }\n  };\n\n  /** Dynamic reference. */\n  public void setStaticMetadataServices(List<StaticMetadataService> mdServices) {\n    this.mdServices = new ArrayList<StaticMetadataService>(mdServices);\n    Collections.sort(this.mdServices, new Comparator<StaticMetadataService>() {\n      @Override\n      public int compare(StaticMetadataService a, StaticMetadataService b) {\n        return b.getPriority() - a.getPriority();\n      }\n    });\n  }\n\n  /**\n   * Creates a new management instance for the search index.\n   *\n   * @param connection\n   *          connection to the database\n   */\n  public SolrIndexManager(SolrServer connection, Workspace workspace, List<StaticMetadataService> mdServices,\n          SeriesService seriesService, Mpeg7CatalogService mpeg7CatalogService, SecurityService securityService) {\n\n    this.solrServer = notNull(connection, \"solr connection\");\n    this.workspace = notNull(workspace, \"workspace\");\n    this.seriesService = notNull(seriesService, \"series service\");\n    this.mpeg7CatalogService = notNull(mpeg7CatalogService, \"mpeg7 service\");\n    this.securityService = notNull(securityService, \"security service\");\n    setStaticMetadataServices(notNull(mdServices, \"metadata service\"));\n  }\n\n  /**\n   * Clears the search index. Make sure you know what you are doing.\n   *\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public void clear() throws SolrServerException {\n    try {\n      solrServer.deleteByQuery(\"*:*\");\n      solrServer.commit();\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Removes the entry with the given <code>id</code> from the database. The entry can either be a series or an episode.\n   *\n   * @param id\n   *          identifier of the series or episode to delete\n   * @param deletionDate\n   *          the deletion date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean delete(String id, Date deletionDate) throws SolrServerException {\n    try {\n      // Load the existing episode\n      QueryResponse solrResponse = null;\n      try {\n        SolrQuery query = new SolrQuery(Schema.ID + \":\" + ClientUtils.escapeQueryChars(id) + \" AND -\"\n                + Schema.OC_DELETED + \":[* TO *]\");\n        solrResponse = solrServer.query(query);\n      } catch (Exception e1) {\n        throw new SolrServerException(e1);\n      }\n\n      // Did we find the episode?\n      if (solrResponse.getResults().size() == 0) {\n        logger.warn(\"Trying to delete non-existing media package {} from the search index\", id);\n        return false;\n      }\n\n      // Use all existing fields\n      SolrDocument doc = solrResponse.getResults().get(0);\n      SolrInputDocument inputDocument = new SolrInputDocument();\n      for (String field : doc.getFieldNames()) {\n        inputDocument.setField(field, doc.get(field));\n      }\n\n      // Set the oc_deleted field to the current date, then update\n      Schema.setOcDeleted(inputDocument, deletionDate);\n      solrServer.add(inputDocument);\n      solrServer.commit();\n      return true;\n    } catch (IOException e) {\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param now\n   *          current date\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, AccessControlList seriesAcl, Date now)\n      throws SolrServerException, UnauthorizedException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n      Schema.setOcModified(episodeDocument, now);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), seriesAcl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      // Post everything to the search index\n      solrServer.add(episodeDocument);\n      if (seriesDocument != null)\n        solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      throw new SolrServerException(\n          String.format(\"Unable to add media package %s to index\", sourceMediaPackage.getIdentifier()), e);\n    }\n  }\n\n  /**\n   * Posts a series to Solr. If the entry already exists, this will update the series.\n   *\n   * @param seriesId\n   *          the series to post\n   * @param acl\n   *          the access control list for this series\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public void addSeries(final String seriesId, final AccessControlList acl) throws SolrServerException {\n    try {\n      SolrInputDocument seriesDocument = createSeriesInputDocument(seriesId, acl);\n      if (seriesDocument != null) {\n        solrServer.add(seriesDocument);\n        solrServer.commit();\n      }\n    } catch (Exception e) {\n      throw new SolrServerException(String.format(\"Unable to add series %s to index\", seriesId), e);\n    }\n  }\n\n  /**\n   * Posts the media package to solr. Depending on what is referenced in the media package, the method might create one\n   * or two entries: one for the episode and one for the series that the episode belongs to.\n   *\n   * This implementation of the search service removes all references to non \"engage/download\" media tracks\n   *\n   * @param sourceMediaPackage\n   *          the media package to post\n   * @param acl\n   *          the access control list for this mediapackage\n   * @param deletionDate\n   *          the deletion date\n   * @param modificationDate\n   *          the modification date\n   * @return <code>true</code> if successfully added\n   * @throws SolrServerException\n   *           if an errors occurs while talking to solr\n   */\n  public boolean add(MediaPackage sourceMediaPackage, AccessControlList acl, Date deletionDate, Date modificationDate)\n          throws SolrServerException {\n    try {\n      SolrInputDocument episodeDocument = createEpisodeInputDocument(sourceMediaPackage, acl);\n\n      SolrInputDocument seriesDocument = createSeriesInputDocument(sourceMediaPackage.getSeries(), acl);\n      if (seriesDocument != null)\n        Schema.enrich(episodeDocument, seriesDocument);\n\n      Schema.setOcModified(episodeDocument, modificationDate);\n      if (deletionDate != null)\n        Schema.setOcDeleted(episodeDocument, deletionDate);\n\n      solrServer.add(episodeDocument);\n      solrServer.add(seriesDocument);\n      solrServer.commit();\n      return true;\n    } catch (Exception e) {\n      logger.error(\"Unable to add mediapackage {} to index\", sourceMediaPackage.getIdentifier());\n      try {\n        solrServer.rollback();\n      } catch (IOException e1) {\n        throw new SolrServerException(e1);\n      }\n      throw new SolrServerException(e);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the episode metadata of the media package.\n   *\n   * @param mediaPackage\n   *          the media package\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr\n   * @throws MediaPackageException\n   *           if serialization of the media package fails\n   */\n  private SolrInputDocument createEpisodeInputDocument(MediaPackage mediaPackage, AccessControlList acl)\n          throws MediaPackageException, IOException {\n\n    SolrInputDocument doc = new SolrInputDocument();\n    String mediaPackageId = mediaPackage.getIdentifier().toString();\n\n    // Fill the input document\n    Schema.setId(doc, mediaPackageId);\n    // /\n    // OC specific fields\n    Schema.setOcMediatype(doc, SearchResultItemType.AudioVisual.toString());\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediapackage(doc, MediaPackageParser.getAsXml(mediaPackage));\n    Schema.setOcElementtags(doc, tags(mediaPackage));\n    Schema.setOcElementflavors(doc, flavors(mediaPackage));\n    // Add cover\n    Attachment[] cover = mediaPackage.getAttachments(MediaPackageElements.MEDIAPACKAGE_COVER_FLAVOR);\n    if (cover != null && cover.length > 0) {\n      Schema.setOcCover(doc, cover[0].getURI().toString());\n    }\n\n    // /\n    // Add standard dublin core fields\n    // naive approach. works as long as only setters, not adders are available in the schema\n    for (StaticMetadata md : getMetadata(mdServices, mediaPackage))\n      addEpisodeMetadata(doc, md);\n\n    // /\n    // Add mpeg7\n    logger.debug(\"Looking for mpeg-7 catalogs containing segment texts\");\n    Catalog[] mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.TEXTS);\n    if (mpeg7Catalogs.length == 0) {\n      logger.debug(\"No text catalogs found, trying segments only\");\n      mpeg7Catalogs = mediaPackage.getCatalogs(MediaPackageElements.SEGMENTS);\n    }\n    // TODO: merge the segments from each mpeg7 if there is more than one mpeg7 catalog\n    if (mpeg7Catalogs.length > 0) {\n      try {\n        Mpeg7Catalog mpeg7Catalog = loadMpeg7Catalog(mpeg7Catalogs[0]);\n        addMpeg7Metadata(doc, mediaPackage, mpeg7Catalog);\n      } catch (IOException e) {\n        logger.error(\"Error loading mpeg7 catalog. Skipping catalog\", e);\n      }\n    } else {\n      logger.debug(\"No segmentation catalog found\");\n    }\n\n    // /\n    // Add authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  static void addEpisodeMetadata(final SolrInputDocument doc, final StaticMetadata md) {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return md.getCreated();\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return md.getExtent();\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return md.getLanguage();\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return md.getIsPartOf();\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return md.getReplaces();\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return md.getType();\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(leftBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.none();\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.some(leftBound);\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return md.getAvailable().flatMap(new Function<Interval, Option<Date>>() {\n          @Override\n          public Option<Date> apply(Interval interval) {\n            return interval.fold(new Interval.Match<Option<Date>>() {\n              @Override\n              public Option<Date> bounded(Date leftBound, Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> leftInfinite(Date rightBound) {\n                return Option.some(rightBound);\n              }\n\n              @Override\n              public Option<Date> rightInfinite(Date leftBound) {\n                return Option.none();\n              }\n            });\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromMValue(md.getTitles());\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromMValue(md.getSubjects());\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromMValue(md.getCreators());\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromMValue(md.getPublishers());\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromMValue(md.getContributors());\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromMValue(md.getDescription());\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromMValue(md.getRightsHolders());\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromMValue(md.getSpatials());\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromMValue(md.getAccessRights());\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromMValue(md.getLicenses());\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none(); // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST; // set elsewhere\n      }\n    });\n  }\n\n  static List<DField<String>> fromMValue(List<MetadataValue<String>> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<MetadataValue<String>, DField<String>>() {\n      @Override\n      public DField<String> apply(MetadataValue<String> v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  static List<DField<String>> fromDCValue(List<DublinCoreValue> as) {\n    return map(as, new ArrayList<DField<String>>(), new Function<DublinCoreValue, DField<String>>() {\n      @Override\n      public DField<String> apply(DublinCoreValue v) {\n        return new DField<String>(v.getValue(), v.getLanguage());\n      }\n    });\n  }\n\n  /**\n   * Adds authorization fields to the solr document.\n   *\n   * @param doc\n   *          the solr document\n   * @param acl\n   *          the access control list\n   */\n  static void setAuthorization(SolrInputDocument doc, SecurityService securityService, AccessControlList acl) {\n    Map<String, List<String>> permissions = new HashMap<String, List<String>>();\n\n    // Define containers for common permissions\n    List<String> reads = new ArrayList<String>();\n    permissions.put(READ.toString(), reads);\n    List<String> writes = new ArrayList<String>();\n    permissions.put(WRITE.toString(), writes);\n\n    String adminRole = securityService.getOrganization().getAdminRole();\n\n    // The admin user can read and write\n    if (adminRole != null) {\n      reads.add(adminRole);\n      writes.add(adminRole);\n    }\n\n    for (AccessControlEntry entry : acl.getEntries()) {\n      if (!entry.isAllow()) {\n        logger.warn(\"Search service does not support denial via ACL, ignoring {}\", entry);\n        continue;\n      }\n      List<String> actionPermissions = permissions.get(entry.getAction());\n      /*\n       * MH-8353 a series could have a permission defined we don't know how to handle -DH\n       */\n      if (actionPermissions == null) {\n        logger.warn(\"Search service doesn't know how to handle action: \" + entry.getAction());\n        continue;\n      }\n      if (acl == null) {\n        actionPermissions = new ArrayList<String>();\n        permissions.put(entry.getAction(), actionPermissions);\n      }\n      actionPermissions.add(entry.getRole());\n\n    }\n\n    // Write the permissions to the solr document\n    for (Map.Entry<String, List<String>> entry : permissions.entrySet()) {\n      Schema.setOcAcl(doc, new DField<String>(mkString(entry.getValue(), \" \"), entry.getKey()));\n    }\n  }\n\n  static String mkString(Collection<?> as, String sep) {\n    StringBuffer b = new StringBuffer();\n    for (Object a : as) {\n      b.append(a).append(sep);\n    }\n    return b.substring(0, b.length() - sep.length());\n  }\n\n  private Mpeg7Catalog loadMpeg7Catalog(Catalog catalog) throws IOException {\n    try (InputStream in = workspace.read(catalog.getURI())) {\n      return mpeg7CatalogService.load(in);\n    } catch (NotFoundException e) {\n      throw new IOException(\"Unable to load metadata from mpeg7 catalog \" + catalog);\n    }\n  }\n\n  /**\n   * Creates a solr input document for the series metadata of the media package.\n   *\n   * @param seriesId\n   *          the id of the series\n   * @param acl\n   *          the access control list for this mediapackage\n   * @return an input document ready to be posted to solr or null\n   */\n  private SolrInputDocument createSeriesInputDocument(String seriesId, AccessControlList acl) throws IOException,\n          UnauthorizedException {\n\n    if (seriesId == null)\n      return null;\n    DublinCoreCatalog dc = null;\n    try {\n      dc = seriesService.getSeries(seriesId);\n    } catch (SeriesException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    } catch (NotFoundException e) {\n      logger.debug(\"No series dublincore found for series id \" + seriesId);\n      return null;\n    }\n\n    SolrInputDocument doc = new SolrInputDocument();\n\n    // Populate document with existing data\n    try {\n      StringBuffer query = new StringBuffer(\"q=\");\n      query = query.append(Schema.ID).append(\":\").append(SolrUtils.clean(seriesId));\n      SolrParams params = SolrRequestParsers.parseQueryString(query.toString());\n      QueryResponse solrResponse = solrServer.query(params);\n      if (solrResponse.getResults().size() > 0) {\n        SolrDocument existingSolrDocument = solrResponse.getResults().get(0);\n        for (String fieldName : existingSolrDocument.getFieldNames()) {\n          doc.addField(fieldName, existingSolrDocument.getFieldValue(fieldName));\n        }\n      }\n    } catch (Exception e) {\n      logger.error(\"Error trying to load series \" + seriesId, e);\n    }\n\n    // Fill document\n    Schema.setId(doc, seriesId);\n\n    // OC specific fields\n    Schema.setOrganization(doc, securityService.getOrganization().getId());\n    Schema.setOcMediatype(doc, SearchResultItemType.Series.toString());\n    Schema.setOcModified(doc, new Date());\n\n    // DC fields\n    addSeriesMetadata(doc, dc);\n\n    // Authorization\n    setAuthorization(doc, securityService, acl);\n\n    return doc;\n  }\n\n  /**\n   * Add the standard dublin core fields to a series document.\n   *\n   * @param doc\n   *          the solr document to fill\n   * @param dc\n   *          the dublin core catalog to get the data from\n   */\n  static void addSeriesMetadata(final SolrInputDocument doc, final DublinCoreCatalog dc) throws IOException {\n    Schema.fill(doc, new Schema.FieldCollector() {\n      @Override\n      public Option<String> getId() {\n        return Option.some(dc.getFirst(DublinCore.PROPERTY_IDENTIFIER));\n      }\n\n      @Override\n      public Option<String> getOrganization() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getDcCreated() {\n        return head(dc.get(DublinCore.PROPERTY_CREATED)).flatMap(toDateF);\n      }\n\n      @Override\n      public Option<Long> getDcExtent() {\n        return head(dc.get(DublinCore.PROPERTY_EXTENT)).flatMap(toDurationF);\n      }\n\n      @Override\n      public Option<String> getDcLanguage() {\n        return option(dc.getFirst(DublinCore.PROPERTY_LANGUAGE));\n      }\n\n      @Override\n      public Option<String> getDcIsPartOf() {\n        return option(dc.getFirst(DublinCore.PROPERTY_IS_PART_OF));\n      }\n\n      @Override\n      public Option<String> getDcReplaces() {\n        return option(dc.getFirst(DublinCore.PROPERTY_REPLACES));\n      }\n\n      @Override\n      public Option<String> getDcType() {\n        return option(dc.getFirst(DublinCore.PROPERTY_TYPE));\n      }\n\n      @Override\n      public Option<Date> getDcAvailableFrom() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getStart());\n          }\n        });\n      }\n\n      @Override\n      public Option<Date> getDcAvailableTo() {\n        return option(dc.getFirst(DublinCore.PROPERTY_AVAILABLE)).flatMap(new Function<String, Option<Date>>() {\n          @Override\n          public Option<Date> apply(String s) {\n            return option(EncodingSchemeUtils.decodePeriod(s).getEnd());\n          }\n        });\n      }\n\n      @Override\n      public List<DField<String>> getDcTitle() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_TITLE));\n      }\n\n      @Override\n      public List<DField<String>> getDcSubject() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SUBJECT));\n      }\n\n      @Override\n      public List<DField<String>> getDcCreator() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CREATOR));\n      }\n\n      @Override\n      public List<DField<String>> getDcPublisher() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_PUBLISHER));\n      }\n\n      @Override\n      public List<DField<String>> getDcContributor() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_CONTRIBUTOR));\n\n      }\n\n      @Override\n      public List<DField<String>> getDcDescription() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_DESCRIPTION));\n      }\n\n      @Override\n      public List<DField<String>> getDcRightsHolder() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_RIGHTS_HOLDER));\n      }\n\n      @Override\n      public List<DField<String>> getDcSpatial() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_SPATIAL));\n      }\n\n      @Override\n      public List<DField<String>> getDcAccessRights() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_ACCESS_RIGHTS));\n      }\n\n      @Override\n      public List<DField<String>> getDcLicense() {\n        return fromDCValue(dc.get(DublinCore.PROPERTY_LICENSE));\n      }\n\n      @Override\n      public Option<String> getOcMediatype() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcMediapackage() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcKeywords() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcCover() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcModified() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<Date> getOcDeleted() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementtags() {\n        return Option.none();\n      }\n\n      @Override\n      public Option<String> getOcElementflavors() {\n        return Option.none();\n      }\n\n      @Override\n      public List<DField<String>> getOcAcl() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentText() {\n        return Collections.EMPTY_LIST;\n      }\n\n      @Override\n      public List<DField<String>> getSegmentHint() {\n        return Collections.EMPTY_LIST;\n      }\n    });\n  }\n\n  /**\n   * Add the mpeg 7 catalog data to the solr document.\n   *\n   * @param doc\n   *          the input document to the solr index\n   * @param mpeg7\n   *          the mpeg7 catalog\n   */\n  @SuppressWarnings(\"unchecked\")\n  static void addMpeg7Metadata(SolrInputDocument doc, MediaPackage mediaPackage, Mpeg7Catalog mpeg7) {\n\n    // Check for multimedia content\n    if (!mpeg7.multimediaContent().hasNext()) {\n      logger.warn(\"Mpeg-7 doesn't contain  multimedia content\");\n      return;\n    }\n\n    // Get the content duration by looking at the first content track. This\n    // of course assumes that all tracks are equally long.\n    MultimediaContent<? extends MultimediaContentType> mc = mpeg7.multimediaContent().next();\n    MultimediaContentType mct = mc.elements().next();\n    MediaTime mediaTime = mct.getMediaTime();\n    Schema.setDcExtent(doc, mediaTime.getMediaDuration().getDurationInMilliseconds());\n\n    // Check if the keywords have been filled by (manually) added dublin\n    // core data. If not, look for the most relevant fields in mpeg-7.\n    SortedSet<TextAnnotation> sortedAnnotations = null;\n    if (!\"\".equals(Schema.getOcKeywords(doc))) {\n      sortedAnnotations = new TreeSet<TextAnnotation>(new Comparator<TextAnnotation>() {\n        @Override\n        public int compare(TextAnnotation a1, TextAnnotation a2) {\n          if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) > (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return -1;\n          else if ((RELEVANCE_BOOST * a1.getRelevance() + a1.getConfidence()) < (RELEVANCE_BOOST * a2.getRelevance() + a2\n                  .getConfidence()))\n            return 1;\n          return 0;\n        }\n      });\n    }\n\n    // Iterate over the tracks and extract keywords and hints\n    Iterator<MultimediaContent<? extends MultimediaContentType>> mmIter = mpeg7.multimediaContent();\n    int segmentCount = 0;\n\n    while (mmIter.hasNext()) {\n      MultimediaContent<?> multimediaContent = mmIter.next();\n\n      // We need to process visual segments first, due to the way they are handled in the ui.\n      for (Iterator<?> iterator = multimediaContent.elements(); iterator.hasNext();) {\n\n        MultimediaContentType type = (MultimediaContentType) iterator.next();\n        if (!(type instanceof Video) && !(type instanceof AudioVisual))\n          continue;\n\n        // for every segment in the current multimedia content track\n\n        Video video = (Video) type;\n        Iterator<VideoSegment> vsegments = (Iterator<VideoSegment>) video.getTemporalDecomposition().segments();\n        while (vsegments.hasNext()) {\n          VideoSegment segment = vsegments.next();\n\n          StringBuffer segmentText = new StringBuffer();\n          StringBuffer hintField = new StringBuffer();\n\n          // Collect the video text elements to a segment text\n          SpatioTemporalDecomposition spt = segment.getSpatioTemporalDecomposition();\n          if (spt != null) {\n            for (VideoText videoText : spt.getVideoText()) {\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(videoText.getText().getText());\n              // TODO: Add hint on bounding box\n            }\n          }\n\n          // Add keyword annotations\n          Iterator<TextAnnotation> textAnnotations = segment.textAnnotations();\n          while (textAnnotations.hasNext()) {\n            TextAnnotation textAnnotation = textAnnotations.next();\n            Iterator<?> kwIter = textAnnotation.keywordAnnotations();\n            while (kwIter.hasNext()) {\n              KeywordAnnotation keywordAnnotation = (KeywordAnnotation) kwIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(keywordAnnotation.getKeyword());\n            }\n          }\n\n          // Add free text annotations\n          Iterator<TextAnnotation> freeIter = segment.textAnnotations();\n          if (freeIter.hasNext()) {\n            Iterator<FreeTextAnnotation> freeTextIter = freeIter.next().freeTextAnnotations();\n            while (freeTextIter.hasNext()) {\n              FreeTextAnnotation freeTextAnnotation = freeTextIter.next();\n              if (segmentText.length() > 0)\n                segmentText.append(\" \");\n              segmentText.append(freeTextAnnotation.getText());\n            }\n          }\n\n          // add segment text to solr document\n          Schema.setSegmentText(doc, new DField<String>(segmentText.toString(), Integer.toString(segmentCount)));\n\n          // get the segments time properties\n          MediaTimePoint timepoint = segment.getMediaTime().getMediaTimePoint();\n          MediaDuration duration = segment.getMediaTime().getMediaDuration();\n\n          // TODO: define a class with hint field constants\n          hintField.append(\"time=\" + timepoint.getTimeInMilliseconds() + \"\\n\");\n          hintField.append(\"duration=\" + duration.getDurationInMilliseconds() + \"\\n\");\n\n          // Look for preview images. Their characteristics are that they are\n          // attached as attachments with a flavor of preview/<something>.\n          String time = timepoint.toString();\n          for (Attachment slide : mediaPackage.getAttachments(MediaPackageElements.PRESENTATION_SEGMENT_PREVIEW)) {\n            MediaPackageReference ref = slide.getReference();\n            if (ref != null && time.equals(ref.getProperty(\"time\"))) {\n              hintField.append(\"preview\");\n              hintField.append(\".\");\n              hintField.append(ref.getIdentifier());\n              hintField.append(\"=\");\n              hintField.append(slide.getURI().toString());\n              hintField.append(\"\\n\");\n            }\n          }\n\n          logger.trace(\"Adding segment: \" + timepoint.toString());\n          Schema.setSegmentHint(doc, new DField<String>(hintField.toString(), Integer.toString(segmentCount)));\n\n          // increase segment counter\n          segmentCount++;\n        }\n      }\n    }\n\n    // Put the most important keywords into a special solr field\n    if (sortedAnnotations != null) {\n      Schema.setOcKeywords(doc, importantKeywordsString(sortedAnnotations).toString());\n    }\n  }\n\n  /**\n   * Generates a string with the most important kewords from the text annotation.\n   *\n   * @param sortedAnnotations\n   * @return The keyword string.\n   */\n  static StringBuffer importantKeywordsString(SortedSet<TextAnnotation> sortedAnnotations) {\n\n    // important keyword:\n    // - high relevance\n    // - high confidence\n    // - occur often\n    // - more than MAX_CHAR chars\n\n    // calculate keyword occurences (histogram) and importance\n    ArrayList<String> list = new ArrayList<String>();\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    TextAnnotation textAnnotation = null;\n    String keyword = null;\n\n    HashMap<String, Integer> histogram = new HashMap<String, Integer>();\n    HashMap<String, Double> importance = new HashMap<String, Double>();\n    int occ = 0;\n    double imp;\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation annotation = keywordAnnotations.next();\n        keyword = annotation.getKeyword().toLowerCase();\n        if (keyword.length() > MAX_CHAR) {\n          occ = 0;\n          if (histogram.keySet().contains(keyword)) {\n            occ = histogram.get(keyword);\n          }\n          histogram.put(keyword, occ + 1);\n\n          // here the importance value is calculated\n          // from relevance, confidence and frequency of occurence.\n          imp = (RELEVANCE_BOOST * getMaxRelevance(keyword, sortedAnnotations) + getMaxConfidence(keyword,\n                  sortedAnnotations)) * (occ + 1);\n          importance.put(keyword, imp);\n        }\n      }\n    }\n\n    // get the MAX_IMPORTANT_COUNT most important keywords\n    StringBuffer buf = new StringBuffer();\n\n    while (list.size() < MAX_IMPORTANT_COUNT && importance.size() > 0) {\n      double max = 0.0;\n      String maxKeyword = null;\n\n      // get maximum from importance list\n      for (Entry<String, Double> entry : importance.entrySet()) {\n        keyword = entry.getKey();\n        if (max < entry.getValue()) {\n          max = entry.getValue();\n          maxKeyword = keyword;\n        }\n      }\n\n      // pop maximum\n      importance.remove(maxKeyword);\n\n      // append keyword to string\n      if (buf.length() > 0)\n        buf.append(\" \");\n      buf.append(maxKeyword);\n    }\n\n    return buf;\n  }\n\n  /**\n   * Gets the maximum confidence for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum confidence value.\n   */\n  static double getMaxConfidence(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getConfidence()) {\n            max = textAnnotation.getConfidence();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Gets the maximum relevance for a given keyword in the text annotation.\n   *\n   * @param keyword\n   * @param sortedAnnotations\n   * @return The maximum relevance value.\n   */\n  static double getMaxRelevance(String keyword, SortedSet<TextAnnotation> sortedAnnotations) {\n    double max = 0.0;\n    String needle = null;\n    TextAnnotation textAnnotation = null;\n    Iterator<TextAnnotation> textAnnotations = sortedAnnotations.iterator();\n    while (textAnnotations.hasNext()) {\n      textAnnotation = textAnnotations.next();\n      Iterator<KeywordAnnotation> keywordAnnotations = textAnnotation.keywordAnnotations();\n      while (keywordAnnotations.hasNext()) {\n        KeywordAnnotation ann = keywordAnnotations.next();\n        needle = ann.getKeyword().toLowerCase();\n        if (keyword.equals(needle)) {\n          if (max < textAnnotation.getRelevance()) {\n            max = textAnnotation.getRelevance();\n          }\n        }\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Get metadata from all registered metadata services.\n   */\n  static List<StaticMetadata> getMetadata(final List<StaticMetadataService> mdServices, final MediaPackage mp) {\n    return flatMap(mdServices, new ArrayList<StaticMetadata>(),\n            new Function<StaticMetadataService, Collection<StaticMetadata>>() {\n              @Override\n              public Collection<StaticMetadata> apply(StaticMetadataService s) {\n                StaticMetadata md = s.getMetadata(mp);\n                return md != null ? Arrays.asList(md) : Collections.<StaticMetadata> emptyList();\n              }\n            });\n  }\n\n  /**\n   * Return all media package tags as a space separated string.\n   */\n  static String tags(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      for (String tag : element.getTags()) {\n        sb.append(tag);\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Return all media package flavors as a space separated string.\n   */\n  static String flavors(MediaPackage mp) {\n    StringBuilder sb = new StringBuilder();\n    for (MediaPackageElement element : mp.getElements()) {\n      if (element.getFlavor() != null) {\n        sb.append(element.getFlavor().toString());\n        sb.append(\" \");\n      }\n    }\n    return sb.toString();\n  }\n\n  /**\n   * Returns number of entries in search index, across all organizations.\n   *\n   * @return number of entries in search index\n   * @throws SearchServiceDatabaseException\n   *           if count cannot be retrieved\n   */\n  public long count() throws SearchServiceDatabaseException {\n    try {\n      QueryResponse response = solrServer.query(new SolrQuery(\"*:*\"));\n      return response.getResults().getNumFound();\n    } catch (SolrServerException e) {\n      throw new SearchServiceDatabaseException(e);\n    }\n  }\n}\n"], "filenames": ["modules/search-service-impl/src/main/java/org/opencastproject/search/impl/SearchServiceImpl.java", "modules/search-service-impl/src/main/java/org/opencastproject/search/impl/persistence/SearchEntity.java", "modules/search-service-impl/src/main/java/org/opencastproject/search/impl/persistence/SearchServiceDatabase.java", "modules/search-service-impl/src/main/java/org/opencastproject/search/impl/persistence/SearchServiceDatabaseImpl.java", "modules/search-service-impl/src/main/java/org/opencastproject/search/impl/solr/SolrIndexManager.java"], "buggy_code_start_loc": [376, 53, 29, 28, 276], "buggy_code_end_loc": [465, 54, 96, 257, 302], "fixing_code_start_loc": [375, 53, 30, 29, 276], "fixing_code_end_loc": [481, 55, 122, 317, 317], "type": "CWE-863", "message": "Opencast is a free, open-source platform to support the management of educational audio and video content. In Opencast before version 9.2 there is a vulnerability in which publishing an episode with strict access rules will overwrite the currently set series access. This allows for an easy denial of access for all users without superuser privileges, effectively hiding the series. Access to series and series metadata on the search service (shown in media module and player) depends on the events published which are part of the series. Publishing an event will automatically publish a series and update access to it. Removing an event or republishing the event should do the same. Affected versions of Opencast may not update the series access or remove a published series if an event is being removed. On removal of an episode, this may lead to an access control list for series metadata with broader access rules than the merged access rules of all remaining events, or the series metadata still being available although all episodes of that series have been removed. This problem is fixed in Opencast 9.2.", "other": {"cve": {"id": "CVE-2021-21318", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-18T18:15:11.490", "lastModified": "2021-02-26T04:04:04.403", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Opencast is a free, open-source platform to support the management of educational audio and video content. In Opencast before version 9.2 there is a vulnerability in which publishing an episode with strict access rules will overwrite the currently set series access. This allows for an easy denial of access for all users without superuser privileges, effectively hiding the series. Access to series and series metadata on the search service (shown in media module and player) depends on the events published which are part of the series. Publishing an event will automatically publish a series and update access to it. Removing an event or republishing the event should do the same. Affected versions of Opencast may not update the series access or remove a published series if an event is being removed. On removal of an episode, this may lead to an access control list for series metadata with broader access rules than the merged access rules of all remaining events, or the series metadata still being available although all episodes of that series have been removed. This problem is fixed in Opencast 9.2."}, {"lang": "es", "value": "Opencast es una plataforma gratuita de c\u00f3digo abierto para respaldar la administraci\u00f3n de contenido educativo de audio y video.&#xa0;En Opencast versiones anteriores a 9.2, se presenta una vulnerabilidad en la que la publicaci\u00f3n de un episodio con reglas de acceso estrictas sobrescribir\u00e1 el acceso a la serie configurada actualmente.&#xa0;Esto permite una f\u00e1cil denegaci\u00f3n de acceso para todos los usuarios sin privilegios de superusuario, ocultando efectivamente la serie.&#xa0;El acceso a series y metadatos de series en el servicio de b\u00fasqueda (mostrado en m\u00f3dulo multimedia y reproductor) depende de los eventos publicados que forman parte de la serie.&#xa0;La publicaci\u00f3n de un evento publicar\u00e1 autom\u00e1ticamente una serie y actualizar\u00e1 el acceso a ella.&#xa0;Eliminar un evento o volver a publicarlo deber\u00eda hacer lo mismo.&#xa0;Es posible que las versiones afectadas de Opencast no actualicen el acceso a la serie ni eliminen una serie publicada si un evento ha sido eliminado.&#xa0;Al eliminar un episodio,&#xa0;esto puede conllevar a una lista de control de acceso para los metadatos de la serie con reglas de acceso m\u00e1s amplias que las reglas de acceso combinadas de todos los eventos restantes, o que los metadatos de la serie sigan estando disponibles aunque todos los episodios de esa serie hayan sido eliminados.&#xa0;Este problema se corrigi\u00f3 en Opencast versi\u00f3n 9.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apereo:opencast:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2", "matchCriteriaId": "0BD75109-ECB3-42D8-AC2E-F6AB4E080C14"}]}]}], "references": [{"url": "https://github.com/opencast/opencast/commit/b18c6a7f81f08ed14884592a6c14c9ab611ad450", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencast/opencast/security/advisories/GHSA-vpc2-3wcv-qj4w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencast/opencast/commit/b18c6a7f81f08ed14884592a6c14c9ab611ad450"}}