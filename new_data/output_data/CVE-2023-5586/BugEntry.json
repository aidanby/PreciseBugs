{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / RAW PCM reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_RFPCM\n\ntypedef struct\n{\n\t//opts\n\tu32 framelen, safmt, sr, ch;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tBool file_loaded, is_playing, initial_play_done;\n\tu64 cts;\n\tu32 frame_size, nb_bytes_in_frame, Bps;\n\tu64 filepos, total_frames, layout;\n\tGF_FilterPacket *out_pck;\n\tu8 *out_data;\n\tBool reverse_play, done;\n\n\tu32 probe_wave, wav_hdr_size;\n\tBool init_skip;\n\tu8 *probe_data;\n\tu32 probe_data_size;\n} GF_PCMReframeCtx;\n\n\n\n\nGF_Err pcmreframe_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_EXT);\n\tif (!ctx->safmt) {\n\t\tif (p && p->value.string) ctx->safmt = gf_audio_fmt_parse(p->value.string);\n\t}\n\tif (!ctx->safmt) {\n\t\tctx->probe_wave = 1;\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio sample rate, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio ch, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->Bps = gf_audio_fmt_bit_depth(ctx->safmt) / 8;\n\t}\n\tif (!ctx->framelen) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio framelen, using 1024\\n\"));\n\t\tctx->framelen = 1024;\n\t}\n\n\tctx->frame_size = ctx->framelen * ctx->Bps * ctx->ch;\n\n\tif (!ctx->opid)\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_FALSE);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(ctx->ch));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(ctx->framelen));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(ctx->safmt));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, &PROP_BOOL(GF_TRUE));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CHANNEL_LAYOUT, ctx->layout ? &PROP_LONGUINT(ctx->layout) : NULL);\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->sr * ctx->Bps * ctx->ch));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\tif (p && p->value.longuint) {\n\t\tu64 nb_frames = p->value.longuint;\n\t\tif (ctx->probe_wave) nb_frames -= ctx->wav_hdr_size;\n\t\tnb_frames /= ctx->Bps * ctx->ch;\n\t\tctx->total_frames = p->value.longuint;\n\t\tctx->total_frames /= ctx->frame_size;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(nb_frames, ctx->sr));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool pcmreframe_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 nb_frames;\n\tGF_FilterEvent fevt;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->done = GF_FALSE;\n\n\t\tif (!ctx->total_frames)\n\t\t\treturn GF_TRUE;\n\n\t\tif (evt->play.start_range>=0) {\n\t\t\tctx->cts = (u64) (evt->play.start_range * ctx->sr);\n\t\t} else {\n\t\t\tctx->cts = (ctx->total_frames-1) * ctx->framelen;\n\t\t}\n\t\tnb_frames = (u32) (ctx->cts / ctx->framelen);\n\t\tif (nb_frames==ctx->total_frames) {\n\t\t\tif (evt->play.speed>=0) {\n\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tnb_frames--;\n\t\t\tctx->cts = nb_frames * ctx->framelen;\n\t\t}\n\n\t\tctx->filepos = nb_frames * ctx->frame_size;\n\t\tctx->reverse_play =  (evt->play.speed<0) ? GF_TRUE : GF_FALSE;\n\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->filepos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->out_pck) {\n\t\t\tgf_filter_pck_discard(ctx->out_pck);\n\t\t\tctx->out_pck = NULL;\n\t\t}\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nvoid pcmreframe_flush_packet(GF_PCMReframeCtx *ctx)\n{\n\tif (ctx->reverse_play) {\n\t\tu32 i, nb_bytes_in_sample, nb_samples = ctx->nb_bytes_in_frame / ctx->Bps / ctx->ch;\n\t\tnb_bytes_in_sample = ctx->Bps * ctx->ch;\n\t\tfor (i=0; i<nb_samples/2; i++) {\n\t\t\tchar store[100];\n\t\t\tmemcpy(store, ctx->out_data + i*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + i*nb_bytes_in_sample, ctx->out_data + (nb_samples - i - 1)*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + (nb_samples-i-1)*nb_bytes_in_sample, store, nb_bytes_in_sample);\n\t\t}\n\t}\n\tgf_filter_pck_send(ctx->out_pck);\n\tctx->out_pck = NULL;\n}\nGF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tcsize-=16;\n\t\t\tif (ctx->ch==1) ctx->layout = GF_AUDIO_CH_FRONT_CENTER;\n\t\t\telse if (ctx->ch==2) ctx->layout = GF_AUDIO_CH_FRONT_LEFT|GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\telse ctx->layout = 0;\n\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else if (bps==64) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_DBL;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if ((atype==1) || (atype==0xFFFE))  {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (atype==0xFFFE) {\n\t\t\t\tgf_bs_read_u16_le(bs); //cbSize\n\t\t\t\tgf_bs_read_u16_le(bs); //Samples\n\t\t\t\tu32 ch_mask = gf_bs_read_u32_le(bs); //channel mask\n\t\t\t\tcsize-=8;\n\t\t\t\tctx->layout = 0;\n\t\t\t\tif (ch_mask & 0x1) ctx->layout |= GF_AUDIO_CH_FRONT_LEFT;\n\t\t\t\tif (ch_mask & 0x2) ctx->layout |= GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\t\tif (ch_mask & 0x4) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER;\n\t\t\t\tif (ch_mask & 0x8) ctx->layout |= GF_AUDIO_CH_LFE;\n\t\t\t\tif (ch_mask & 0x10) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x20) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x40) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_LEFT;\n\t\t\t\tif (ch_mask & 0x80) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_RIGHT;\n\t\t\t\tif (ch_mask & 0x100) ctx->layout |= GF_AUDIO_CH_REAR_CENTER;\n\t\t\t\tif (ch_mask & 0x200) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x400) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x800) ctx->layout |= GF_AUDIO_CH_CENTER_SURROUND_TOP;\n\t\t\t\tif (ch_mask & 0x1000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x2000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_CENTER;\n\t\t\t\tif (ch_mask & 0x4000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_RIGHT;\n\t\t\t\tif (ch_mask & 0x8000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x10000) ctx->layout |= GF_AUDIO_CH_REAR_CENTER_TOP;\n\t\t\t\tif (ch_mask & 0x20000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_RIGHT;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tctx->init_skip = GF_TRUE;\n\t\tbyte_offset = 0;\n\t\tif (!ctx->is_playing) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (ctx->init_skip) {\n\t\tdata+=ctx->wav_hdr_size;\n\t\tpck_size-=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t\tctx->init_skip = GF_FALSE;\n\t}\n\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}\n\nstatic const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (size<20) return NULL;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tu32 code = gf_bs_read_u32(bs);\n\tif (code == GF_4CC('R', 'I', 'F', 'F')) {\n\t\tgf_bs_read_u32(bs);\n\t\tcode = gf_bs_read_u32(bs);\n\t\tif (code == GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\t*score = GF_FPROBE_SUPPORTED;\n\t\t\tgf_bs_del(bs);\n\t\t\treturn \"audio/wav\";\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t*score = GF_FPROBE_EXT_MATCH;\n\treturn gf_audio_fmt_all_shortnames();\n}\n\n\nstatic void pcmreframe_finalize(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->out_pck) gf_filter_pck_discard(ctx->out_pck);\n\tif (ctx->probe_data) gf_free(ctx->probe_data);\n}\n\nstatic GF_FilterCapability PCMReframeCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"pcm\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-pcm\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"wav\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/wav\"),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_PCMReframeCtx, _n)\nstatic GF_FilterArgs PCMReframeArgs[] =\n{\n\t{ OFFS(sr), \"sample rate\", GF_PROP_UINT, \"44100\", NULL, 0},\n\t{ OFFS(safmt), \"audio format\", GF_PROP_PCMFMT, \"none\", NULL, 0},\n\t{ OFFS(ch), \"number of channels\", GF_PROP_UINT, \"2\", NULL, 0},\n\t{ OFFS(framelen), \"number of samples to put in one audio frame. For planar formats, indicate plane size in samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister PCMReframeRegister = {\n\t.name = \"rfpcm\",\n\tGF_FS_SET_DESCRIPTION(\"PCM reframer\")\n\tGF_FS_SET_HELP(\"This filter parses raw PCM file/data or WAVE files and outputs corresponding raw audio PID and frames.\")\n\t.private_size = sizeof(GF_PCMReframeCtx),\n\t.args = PCMReframeArgs,\n\tSETCAPS(PCMReframeCaps),\n\t.finalize = pcmreframe_finalize,\n\t.configure_pid = pcmreframe_configure_pid,\n\t.process = pcmreframe_process,\n\t.process_event = pcmreframe_process_event,\n\t.probe_data = pcmreframe_probe_data\n};\n\n\nconst GF_FilterRegister *rfpcm_register(GF_FilterSession *session)\n{\n\tPCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();\n\tPCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();\n\treturn &PCMReframeRegister;\n}\n#else\nconst GF_FilterRegister *rfpcm_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //GPAC_DISABLE_RFPCM\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / RAW PCM reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n\n#ifndef GPAC_DISABLE_RFPCM\n\ntypedef struct\n{\n\t//opts\n\tu32 framelen, safmt, sr, ch;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tBool file_loaded, is_playing, initial_play_done;\n\tu64 cts;\n\tu32 frame_size, nb_bytes_in_frame, Bps;\n\tu64 filepos, total_frames, layout;\n\tGF_FilterPacket *out_pck;\n\tu8 *out_data;\n\tBool reverse_play, done;\n\n\tu32 probe_wave, wav_hdr_size;\n\tBool init_skip;\n\tu8 *probe_data;\n\tu32 probe_data_size;\n} GF_PCMReframeCtx;\n\n\n\n\nGF_Err pcmreframe_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_EXT);\n\tif (!ctx->safmt) {\n\t\tif (p && p->value.string) ctx->safmt = gf_audio_fmt_parse(p->value.string);\n\t}\n\tif (!ctx->safmt) {\n\t\tctx->probe_wave = 1;\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\tgf_filter_pid_send_event(pid, &evt);\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio sample rate, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio ch, cannot parse\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->Bps = gf_audio_fmt_bit_depth(ctx->safmt) / 8;\n\t}\n\tif (!ctx->framelen) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Missing audio framelen, using 1024\\n\"));\n\t\tctx->framelen = 1024;\n\t}\n\n\tctx->frame_size = ctx->framelen * ctx->Bps * ctx->ch;\n\n\tif (!ctx->opid)\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_framing_mode(ctx->ipid, GF_FALSE);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(ctx->ch));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(ctx->framelen));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(ctx->safmt));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->sr));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, &PROP_BOOL(GF_TRUE));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CHANNEL_LAYOUT, ctx->layout ? &PROP_LONGUINT(ctx->layout) : NULL);\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tif (!gf_sys_is_test_mode() ) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->sr * ctx->Bps * ctx->ch));\n\t}\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\tif (p && p->value.longuint) {\n\t\tu64 nb_frames = p->value.longuint;\n\t\tif (ctx->probe_wave) nb_frames -= ctx->wav_hdr_size;\n\t\tnb_frames /= ctx->Bps * ctx->ch;\n\t\tctx->total_frames = p->value.longuint;\n\t\tctx->total_frames /= ctx->frame_size;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(nb_frames, ctx->sr));\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool pcmreframe_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 nb_frames;\n\tGF_FilterEvent fevt;\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tctx->done = GF_FALSE;\n\n\t\tif (!ctx->total_frames)\n\t\t\treturn GF_TRUE;\n\n\t\tif (evt->play.start_range>=0) {\n\t\t\tctx->cts = (u64) (evt->play.start_range * ctx->sr);\n\t\t} else {\n\t\t\tctx->cts = (ctx->total_frames-1) * ctx->framelen;\n\t\t}\n\t\tnb_frames = (u32) (ctx->cts / ctx->framelen);\n\t\tif (nb_frames==ctx->total_frames) {\n\t\t\tif (evt->play.speed>=0) {\n\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tnb_frames--;\n\t\t\tctx->cts = nb_frames * ctx->framelen;\n\t\t}\n\n\t\tctx->filepos = nb_frames * ctx->frame_size;\n\t\tctx->reverse_play =  (evt->play.speed<0) ? GF_TRUE : GF_FALSE;\n\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!ctx->filepos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\tif (ctx->out_pck) {\n\t\t\tgf_filter_pck_discard(ctx->out_pck);\n\t\t\tctx->out_pck = NULL;\n\t\t}\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nvoid pcmreframe_flush_packet(GF_PCMReframeCtx *ctx)\n{\n\tif (ctx->reverse_play) {\n\t\tu32 i, nb_bytes_in_sample, nb_samples = ctx->nb_bytes_in_frame / ctx->Bps / ctx->ch;\n\t\tnb_bytes_in_sample = ctx->Bps * ctx->ch;\n\t\tfor (i=0; i<nb_samples/2; i++) {\n\t\t\tchar store[100];\n\t\t\tmemcpy(store, ctx->out_data + i*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + i*nb_bytes_in_sample, ctx->out_data + (nb_samples - i - 1)*nb_bytes_in_sample, nb_bytes_in_sample);\n\t\t\tmemcpy(ctx->out_data + (nb_samples-i-1)*nb_bytes_in_sample, store, nb_bytes_in_sample);\n\t\t}\n\t}\n\tgf_filter_pck_send(ctx->out_pck);\n\tctx->out_pck = NULL;\n}\nGF_Err pcmreframe_process(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tu64 byte_offset;\n\tu8 *data;\n\tu32 pck_size;\n\n\tif (ctx->done) return GF_EOS;\n\n\tif (!ctx->is_playing && ctx->opid) return GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid) && !ctx->reverse_play) {\n\t\t\tif (ctx->out_pck) {\n\t\t\t\tgf_filter_pck_truncate(ctx->out_pck, ctx->nb_bytes_in_frame);\n\t\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->nb_bytes_in_frame/ctx->Bps/ctx->ch);\n\t\t\t\tpcmreframe_flush_packet(ctx);\n\t\t\t}\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\tbyte_offset = gf_filter_pck_get_byte_offset(pck);\n\n\tif (ctx->probe_wave==1) {\n\t\tBool wav_ok = GF_TRUE;\n\t\tBool hdr_found = GF_FALSE;\n\t\tGF_BitStream *bs;\n\t\tif (ctx->probe_data) {\n\t\t\tctx->probe_data = gf_realloc(ctx->probe_data, ctx->probe_data_size+pck_size);\n\t\t\tmemcpy(ctx->probe_data + ctx->probe_data_size, data, pck_size);\n\t\t\tctx->probe_data_size += pck_size;\n\t\t\tbs = gf_bs_new(ctx->probe_data, ctx->probe_data_size, GF_BITSTREAM_READ);\n\t\t} else {\n\t\t\tbs = gf_bs_new(data, pck_size, GF_BITSTREAM_READ);\n\t\t}\n\t\tu32 type = gf_bs_read_u32(bs);\n\t\tif (type!=GF_4CC('R', 'I', 'F', 'F')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tgf_bs_read_u32(bs);\n\t\tu32 wtype = gf_bs_read_u32(bs);\n\t\tif (wtype!=GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\twhile (gf_bs_available(bs)) {\n\t\t\ttype = gf_bs_read_u32(bs);\n\t\t\tu32 csize = gf_bs_read_u32_le(bs); //subchunk size\n\t\t\tif (type==GF_4CC('d', 'a', 't', 'a')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (type!=GF_4CC('f', 'm', 't', ' ')) {\n\t\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//parse fmt\n\t\t\thdr_found = GF_TRUE;\n\t\t\tu16 atype = gf_bs_read_u16_le(bs);\n\t\t\tctx->ch = gf_bs_read_u16_le(bs);\n\t\t\tctx->sr = gf_bs_read_u32_le(bs);\n\t\t\tgf_bs_read_u32_le(bs); //byte rate\n\t\t\tgf_bs_read_u16_le(bs); // block align\n\t\t\tu32 bps = gf_bs_read_u16_le(bs);\n\t\t\tcsize-=16;\n\t\t\tif (ctx->ch==1) ctx->layout = GF_AUDIO_CH_FRONT_CENTER;\n\t\t\telse if (ctx->ch==2) ctx->layout = GF_AUDIO_CH_FRONT_LEFT|GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\telse ctx->layout = 0;\n\n\t\t\tif (atype==3) {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_FLT;\n\t\t\t\t} else if (bps==64) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_DBL;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t} else if ((atype==1) || (atype==0xFFFE))  {\n\t\t\t\tif (bps==32) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S32;\n\t\t\t\t} else if (bps==24) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S24;\n\t\t\t\t} else if (bps==16) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_S16;\n\t\t\t\t} else if (bps==8) {\n\t\t\t\t\tctx->safmt = GF_AUDIO_FMT_U8;\n\t\t\t\t} else {\n\t\t\t\t\twav_ok = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (atype==0xFFFE) {\n\t\t\t\tgf_bs_read_u16_le(bs); //cbSize\n\t\t\t\tgf_bs_read_u16_le(bs); //Samples\n\t\t\t\tu32 ch_mask = gf_bs_read_u32_le(bs); //channel mask\n\t\t\t\tcsize-=8;\n\t\t\t\tctx->layout = 0;\n\t\t\t\tif (ch_mask & 0x1) ctx->layout |= GF_AUDIO_CH_FRONT_LEFT;\n\t\t\t\tif (ch_mask & 0x2) ctx->layout |= GF_AUDIO_CH_FRONT_RIGHT;\n\t\t\t\tif (ch_mask & 0x4) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER;\n\t\t\t\tif (ch_mask & 0x8) ctx->layout |= GF_AUDIO_CH_LFE;\n\t\t\t\tif (ch_mask & 0x10) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x20) ctx->layout |= GF_AUDIO_CH_REAR_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x40) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_LEFT;\n\t\t\t\tif (ch_mask & 0x80) ctx->layout |= GF_AUDIO_CH_FRONT_CENTER_RIGHT;\n\t\t\t\tif (ch_mask & 0x100) ctx->layout |= GF_AUDIO_CH_REAR_CENTER;\n\t\t\t\tif (ch_mask & 0x200) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_LEFT;\n\t\t\t\tif (ch_mask & 0x400) ctx->layout |= GF_AUDIO_CH_SIDE_SURROUND_RIGHT;\n\t\t\t\tif (ch_mask & 0x800) ctx->layout |= GF_AUDIO_CH_CENTER_SURROUND_TOP;\n\t\t\t\tif (ch_mask & 0x1000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x2000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_CENTER;\n\t\t\t\tif (ch_mask & 0x4000) ctx->layout |= GF_AUDIO_CH_FRONT_TOP_RIGHT;\n\t\t\t\tif (ch_mask & 0x8000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_LEFT;\n\t\t\t\tif (ch_mask & 0x10000) ctx->layout |= GF_AUDIO_CH_REAR_CENTER_TOP;\n\t\t\t\tif (ch_mask & 0x20000) ctx->layout |= GF_AUDIO_CH_SURROUND_TOP_RIGHT;\n\t\t\t}\n\t\t\tgf_bs_skip_bytes(bs, csize);\n\t\t}\n\t\tif (gf_bs_is_overflow(bs)) {\n\t\t\tif (!ctx->probe_data) {\n\t\t\t\tctx->probe_data = gf_malloc(pck_size);\n\t\t\t\tmemcpy(ctx->probe_data, data, pck_size);\n\t\t\t\tctx->probe_data_size = pck_size;\n\t\t\t}\n\t\t\tif (!hdr_found) {\n\t\t\t\tif (ctx->probe_data_size<=10000) {\n\t\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[PCMReframe] Cannot find wave data chunk after %d bytes, aborting\\n\", ctx->probe_data_size));\n\t\t\t}\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->ch) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Channel count %d invalid in wave\\n\", ctx->ch));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\t\tif (!ctx->sr) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Samplerate %d invalid in wave\\n\", ctx->sr));\n\t\t\twav_ok = GF_FALSE;\n\t\t}\n\n\t\tctx->wav_hdr_size = (u32) gf_bs_get_position(bs);\n\n\t\tgf_bs_del(bs);\n\t\tif (!wav_ok) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[PCMReframe] Invalid or unsupported WAVE header, aborting\\n\", ctx->probe_data_size));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tctx->probe_wave = 2;\n\t\tpcmreframe_configure_pid(filter, ctx->ipid, GF_FALSE);\n\t\tif (ctx->probe_data) {\n\t\t\tpck_size = ctx->probe_data_size;\n\t\t\tdata = ctx->probe_data;\n\t\t}\n\t\tctx->init_skip = GF_TRUE;\n\t\tbyte_offset = 0;\n\t\tif (!ctx->is_playing) {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (ctx->init_skip) {\n\t\tdata+=ctx->wav_hdr_size;\n\t\tpck_size-=ctx->wav_hdr_size;\n\t\tbyte_offset = 0;\n\t\tctx->init_skip = GF_FALSE;\n\t}\n\n\tbyte_offset+= ctx->wav_hdr_size;\n\n\twhile (pck_size) {\n\t\tif (!ctx->out_pck) {\n\t\t\tctx->out_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->frame_size, &ctx->out_data);\n\t\t\tif (!ctx->out_pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_cts(ctx->out_pck, ctx->cts);\n\t\t\tgf_filter_pck_set_sap(ctx->out_pck, GF_FILTER_SAP_1);\n\t\t\tgf_filter_pck_set_duration(ctx->out_pck, ctx->framelen);\n\t\t\tgf_filter_pck_set_byte_offset(ctx->out_pck, byte_offset);\n\t\t}\n\n\t\tif (pck_size + ctx->nb_bytes_in_frame < ctx->frame_size) {\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, pck_size);\n\t\t\tctx->nb_bytes_in_frame += pck_size;\n\t\t\tpck_size = 0;\n\t\t} else {\n\t\t\tu32 remain = ctx->frame_size - ctx->nb_bytes_in_frame;\n\t\t\tmemcpy(ctx->out_data + ctx->nb_bytes_in_frame, data, remain);\n\t\t\tctx->nb_bytes_in_frame = ctx->frame_size;\n\t\t\tpcmreframe_flush_packet(ctx);\n\n\t\t\tpck_size -= remain;\n\t\t\tdata += remain;\n\t\t\tbyte_offset += remain;\n\t\t\tctx->out_pck = NULL;\n\t\t\tctx->nb_bytes_in_frame = 0;\n\n\t\t\t//reverse playback, the remaining data is for the next frame, we want the previous one.\n\t\t\t//Trash packet and seek to previous frame\n\t\t\tif (ctx->reverse_play) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\tif (!ctx->cts) {\n\t\t\t\t\tif (ctx->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_STOP, ctx->ipid);\n\t\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\t\tctx->done = GF_TRUE;\n\t\t\t\t\treturn GF_EOS;\n\t\t\t\t}\n\t\t\t\tctx->cts -= ctx->framelen;\n\t\t\t\tctx->filepos -= ctx->frame_size;\n\t\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\t\t//post a seek, this will trash remaining packets in buffers\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->filepos + ctx->wav_hdr_size;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tctx->cts += ctx->framelen;\n\t\t}\n\t}\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\n\tif (ctx->probe_data) {\n\t\tgf_free(ctx->probe_data);\n\t\tctx->probe_data = NULL;\n\t\tctx->probe_data_size = 0;\n\t}\n\treturn GF_OK;\n}\n\nstatic const char *pcmreframe_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tif (size<20) return NULL;\n\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tu32 code = gf_bs_read_u32(bs);\n\tif (code == GF_4CC('R', 'I', 'F', 'F')) {\n\t\tgf_bs_read_u32(bs);\n\t\tcode = gf_bs_read_u32(bs);\n\t\tif (code == GF_4CC('W', 'A', 'V', 'E')) {\n\t\t\t*score = GF_FPROBE_SUPPORTED;\n\t\t\tgf_bs_del(bs);\n\t\t\treturn \"audio/wav\";\n\t\t}\n\t}\n\tgf_bs_del(bs);\n\t*score = GF_FPROBE_EXT_MATCH;\n\treturn gf_audio_fmt_all_shortnames();\n}\n\n\nstatic void pcmreframe_finalize(GF_Filter *filter)\n{\n\tGF_PCMReframeCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->out_pck) gf_filter_pck_discard(ctx->out_pck);\n\tif (ctx->probe_data) gf_free(ctx->probe_data);\n}\n\nstatic GF_FilterCapability PCMReframeCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"pcm\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/x-pcm\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"wav\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"audio/wav\"),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_PCMReframeCtx, _n)\nstatic GF_FilterArgs PCMReframeArgs[] =\n{\n\t{ OFFS(sr), \"sample rate\", GF_PROP_UINT, \"44100\", NULL, 0},\n\t{ OFFS(safmt), \"audio format\", GF_PROP_PCMFMT, \"none\", NULL, 0},\n\t{ OFFS(ch), \"number of channels\", GF_PROP_UINT, \"2\", NULL, 0},\n\t{ OFFS(framelen), \"number of samples to put in one audio frame. For planar formats, indicate plane size in samples\", GF_PROP_UINT, \"1024\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\n\nGF_FilterRegister PCMReframeRegister = {\n\t.name = \"rfpcm\",\n\tGF_FS_SET_DESCRIPTION(\"PCM reframer\")\n\tGF_FS_SET_HELP(\"This filter parses raw PCM file/data or WAVE files and outputs corresponding raw audio PID and frames.\")\n\t.private_size = sizeof(GF_PCMReframeCtx),\n\t.args = PCMReframeArgs,\n\tSETCAPS(PCMReframeCaps),\n\t.finalize = pcmreframe_finalize,\n\t.configure_pid = pcmreframe_configure_pid,\n\t.process = pcmreframe_process,\n\t.process_event = pcmreframe_process_event,\n\t.probe_data = pcmreframe_probe_data\n};\n\n\nconst GF_FilterRegister *rfpcm_register(GF_FilterSession *session)\n{\n\tPCMReframeArgs[1].min_max_enum = gf_audio_fmt_all_names();\n\tPCMReframeCaps[1].val.value.string = (char *) gf_audio_fmt_all_shortnames();\n\treturn &PCMReframeRegister;\n}\n#else\nconst GF_FilterRegister *rfpcm_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif //GPAC_DISABLE_RFPCM\n"], "filenames": ["src/filters/reframe_rawpcm.c"], "buggy_code_start_loc": [362], "buggy_code_end_loc": [362], "fixing_code_start_loc": [363], "fixing_code_end_loc": [371], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3.0-DEV.", "other": {"cve": {"id": "CVE-2023-5586", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-15T01:15:09.100", "lastModified": "2023-10-19T01:10:36.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3.0-DEV."}, {"lang": "es", "value": "Eliminaci\u00f3n de referencia del puntero NULL en el repositorio de GitHub gpac/gpac anterior a 2.3.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "8427BDFE-346D-45C9-B0BD-1F06E8825368"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/ca1b48f0abe71bf81a58995d7d75dc27f5a17ddc", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/d2a6ea71-3555-47a6-9b18-35455d103740", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/ca1b48f0abe71bf81a58995d7d75dc27f5a17ddc"}}