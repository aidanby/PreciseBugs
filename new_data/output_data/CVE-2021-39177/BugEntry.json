{"buggy_code": ["pipeline {\n    agent any\n    tools {\n        maven 'Maven 3'\n        jdk 'Java 16'\n    }\n    options {\n        buildDiscarder(logRotator(artifactNumToKeepStr: '20'))\n    }\n    stages {\n        stage ('Build') {\n            steps {\n                sh 'git submodule update --init --recursive'\n                sh 'mvn clean package'\n            }\n            post {\n                success {\n                    archiveArtifacts artifacts: 'bootstrap/**/target/*.jar', excludes: 'bootstrap/**/target/original-*.jar', fingerprint: true\n                }\n            }\n        }\n\n        /*stage ('Deploy') {\n            when {\n                branch \"master\"\n            }\n\n            steps {\n                rtMavenDeployer(\n                        id: \"maven-deployer\",\n                        serverId: \"opencollab-artifactory\",\n                        releaseRepo: \"maven-releases\",\n                        snapshotRepo: \"maven-snapshots\"\n                )\n                rtMavenResolver(\n                        id: \"maven-resolver\",\n                        serverId: \"opencollab-artifactory\",\n                        releaseRepo: \"maven-deploy-release\",\n                        snapshotRepo: \"maven-deploy-snapshot\"\n                )\n                rtMavenRun(\n                        pom: 'pom.xml',\n                        goals: 'javadoc:jar source:jar install -DskipTests',\n                        deployerId: \"maven-deployer\",\n                        resolverId: \"maven-resolver\"\n                )\n                rtPublishBuildInfo(\n                        serverId: \"opencollab-artifactory\"\n                )\n            }\n        }*/\n    }\n\n    post {\n        always {\n            script {\n                def changeLogSets = currentBuild.changeSets\n                def message = \"**Changes:**\"\n\n                if (changeLogSets.size() == 0) {\n                    message += \"\\n*No changes.*\"\n                } else {\n                    def repositoryUrl = scm.userRemoteConfigs[0].url.replace(\".git\", \"\")\n                    def count = 0;\n                    def extra = 0;\n                    for (int i = 0; i < changeLogSets.size(); i++) {\n                        def entries = changeLogSets[i].items\n                        for (int j = 0; j < entries.length; j++) {\n                            if (count <= 10) {\n                                def entry = entries[j]\n                                def commitId = entry.commitId.substring(0, 6)\n                                message += \"\\n   - [`${commitId}`](${repositoryUrl}/commit/${entry.commitId}) ${entry.msg}\"\n                                count++\n                            } else {\n                                extra++;\n                            }\n                        }\n                    }\n                    \n                    if (extra != 0) {\n                        message += \"\\n   - ${extra} more commits\"\n                    }\n                }\n\n                env.changes = message\n            }\n            deleteDir()\n            withCredentials([string(credentialsId: 'geyser-discord-webhook', variable: 'DISCORD_WEBHOOK')]) {\n                discordSend description: \"**Build:** [${currentBuild.id}](${env.BUILD_URL})\\n**Status:** [${currentBuild.currentResult}](${env.BUILD_URL})\\n${changes}\\n\\n[**Artifacts on Jenkins**](https://ci.opencollab.dev/job/GeyserMC/job/Geyser)\", footer: 'Open Collaboration Jenkins', link: env.BUILD_URL, successful: currentBuild.resultIsBetterOrEqualTo('SUCCESS'), title: \"${env.JOB_NAME} #${currentBuild.id}\", webhookURL: DISCORD_WEBHOOK\n            }\n        }\n        success {\n            script {\n                if (env.BRANCH_NAME == 'master') {\n                    build propagate: false, wait: false, job: 'GeyserMC/Geyser-Fabric/java-1.17', parameters: [booleanParam(name: 'SKIP_DISCORD', value: true)]\n                    build propagate: false, wait: false, job: 'GeyserMC/GeyserConnect/master', parameters: [booleanParam(name: 'SKIP_DISCORD', value: true)]\n                }\n            }\n        }\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n\n    <artifactId>ap</artifactId>\n    <version>1.4.1-SNAPSHOT</version>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-bungeecord</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Used for better working with internals without reflection -->\n        <dependency>\n            <groupId>com.github.SpigotMC.BungeeCord</groupId>\n            <artifactId>bungeecord-proxy</artifactId>\n            <version>a7c6ede</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-BungeeCord</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.bungeecord.GeyserBungeeMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>net.md_5.bungee.jni</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.jni</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <!-- This is not used because relocating breaks natives, but we must include it\n                                     or else we get ClassDefNotFound -->\n                                    <pattern>io.netty.channel.kqueue</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.io.netty.channel.kqueue</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.kyori</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-parent</artifactId>\n    <packaging>pom</packaging>\n\n    <repositories>\n        <repository>\n            <id>spigot-public</id>\n            <url>https://hub.spigotmc.org/nexus/content/repositories/public/</url>\n        </repository>\n        <repository>\n            <id>sponge-repo</id>\n            <url>https://repo.spongepowered.org/repository/maven-public/</url>\n        </repository>\n        <repository>\n            <id>bungeecord-repo</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n        </repository>\n        <repository>\n            <id>velocity-repo</id>\n            <url>https://repo.velocitypowered.com/snapshots/</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>ap</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n    <modules>\n        <module>bungeecord</module>\n        <module>spigot</module>\n        <module>sponge</module>\n        <module>standalone</module>\n        <module>velocity</module>\n    </modules>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-spigot</artifactId>\n\n    <repositories>\n        <repository>\n            <id>viaversion-repo</id>\n            <url>https://repo.viaversion.com</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.spigotmc</groupId>\n            <artifactId>spigot-api</artifactId>\n            <version>1.15.2-R0.1-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.viaversion</groupId>\n            <artifactId>viaversion</artifactId>\n            <version>4.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.geysermc.geyser.adapters</groupId>\n            <artifactId>spigot-all</artifactId>\n            <version>1.2-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Spigot</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.spigot.GeyserSpigotMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.kyori</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>org.objectweb.asm</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.asm</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <!-- We cannot shade Netty, or else native libraries will not load -->\n                            <!-- Needed because older Spigot builds do not provide the haproxy module -->\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-transport-native-kqueue:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-codec-dns:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns-native-macos:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-sponge</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.spongepowered</groupId>\n            <artifactId>spongeapi</artifactId>\n            <version>7.1.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Sponge</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.sponge.GeyserSpongeMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>io.netty</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.netty</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.kyori</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <exclude>org.slf4j:*</exclude>\n                            <exclude>org.ow2.asm:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-standalone</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.minecrell</groupId>\n            <artifactId>terminalconsoleappender</artifactId>\n            <version>1.2.0</version>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.apache.logging.log4j</groupId>\n                    <artifactId>log4j-core</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-reader</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-terminal-jna</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-terminal</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-terminal</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-terminal-jna</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-reader</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-api</artifactId>\n            <version>2.13.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-core</artifactId>\n            <version>2.13.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-slf4j18-impl</artifactId>\n            <version>2.13.1</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}</finalName>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.standalone.GeyserStandaloneBootstrap</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <dependencies>\n                    <dependency>\n                        <groupId>com.github.edwgiz</groupId>\n                        <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</artifactId>\n                        <version>2.8.1</version>\n                    </dependency>\n                </dependencies>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <minimizeJar>false</minimizeJar>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <filters>\n                        <filter>\n                            <artifact>*:*</artifact>\n                            <excludes>\n                                <exclude>META-INF/versions/9/module-info.class</exclude>\n                            </excludes>\n                        </filter>\n                    </filters>\n                    <transformers>\n                        <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                            <mainClass>org.geysermc.platform.standalone.GeyserStandaloneBootstrap</mainClass>\n                            <manifestEntries>\n                                <Multi-Release>true</Multi-Release>\n                            </manifestEntries>\n                        </transformer>\n                        <transformer\n                                implementation=\"com.github.edwgiz.mavenShadePlugin.log4j2CacheTransformer.PluginsCacheFileTransformer\">\n                        </transformer>\n                    </transformers>\n                    <dependencyReducedPomLocation>${project.build.directory}/dependency-reduced-pom.xml</dependencyReducedPomLocation>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-velocity</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.velocitypowered</groupId>\n            <artifactId>velocity-api</artifactId>\n            <version>3.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Velocity</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.velocity.GeyserVelocityMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori.adventure.text.serializer.gson.legacyimpl</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.kyori.legacyimpl</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <!-- Needed because Velocity provides every dependency except netty-resolver-dns -->\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-transport-native-kqueue:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-codec-haproxy:*</exclude>\n                            <exclude>org.slf4j:*</exclude>\n                            <exclude>org.ow2.asm:*</exclude>\n                            <!-- Exclude all Kyori dependencies except the legacy NBT serializer -->\n                            <exclude>net.kyori:adventure-api:*</exclude>\n                            <exclude>net.kyori:examination-api:*</exclude>\n                            <exclude>net.kyori:examination-string:*</exclude>\n                            <exclude>net.kyori:adventure-text-serializer-gson:*</exclude>\n                            <exclude>net.kyori:adventure-text-serializer-legacy:*</exclude>\n                            <exclude>net.kyori:adventure-nbt:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>common</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc.cumulus</groupId>\n            <artifactId>cumulus</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.8.6</version>\n        </dependency>\n    </dependencies>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.1-SNAPSHOT</version>\n    </parent>\n    <artifactId>connector</artifactId>\n\n    <properties>\n        <adventure.version>4.8.0</adventure.version>\n        <fastutil.version>8.5.2</fastutil.version>\n        <jackson.version>2.12.4</jackson.version>\n        <netty.version>4.1.66.Final</netty.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>ap</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>common</artifactId>\n            <version>1.4.1-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Jackson JSON and YAML serialization -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.dataformat</groupId>\n            <artifactId>jackson-dataformat-yaml</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.google.guava</groupId>\n            <artifactId>guava</artifactId>\n            <version>29.0-jre</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- fastutil maps -->\n        <dependency>\n            <groupId>com.nukkitx</groupId>\n            <artifactId>nbt</artifactId>\n            <!-- Used for key/value interning -->\n            <version>2.1.0</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-int-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-long-long-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-byte-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-boolean-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-object-int-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-object-object-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Network libraries -->\n        <dependency>\n            <groupId>org.java-websocket</groupId>\n            <artifactId>Java-WebSocket</artifactId>\n            <version>1.5.1</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.github.CloudburstMC.Protocol</groupId>\n            <artifactId>bedrock-v448</artifactId>\n            <version>690a545d</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>com.nukkitx.network</groupId>\n                    <artifactId>raknet</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.nukkitx</groupId>\n                    <artifactId>nbt</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.network</groupId>\n            <artifactId>raknet</artifactId>\n            <version>1.6.26-20210217.205834-2</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>io.netty</groupId>\n                    <artifactId>*</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>MCAuthLib</artifactId>\n            <version>0e48a094f2</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>MCProtocolLib</artifactId>\n            <version>e17787a</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>net.kyori</groupId>\n                    <artifactId>adventure-text-serializer-gson</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.github.steveice10</groupId>\n                    <artifactId>packetlib</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.github.steveice10</groupId>\n                    <artifactId>mcauthlib</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>PacketLib</artifactId>\n            <version>86c9c38</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>io.netty</groupId>\n                    <artifactId>netty-all</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-resolver-dns</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-resolver-dns-native-macos</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>osx-x86_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-codec-haproxy</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Network dependencies we are updating ourselves -->\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-handler</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-epoll</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>linux-x86_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-epoll</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>linux-aarch_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-kqueue</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>osx-x86_64</classifier>\n        </dependency>\n        <!-- Adventure text serialization -->\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-api</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-gson</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-legacy</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-gson-legacy-impl</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Other -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <excludes>\n                        <exclude>**/services/javax.annotation.processing.Processor</exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>pl.project13.maven</groupId>\n                <artifactId>git-commit-id-plugin</artifactId>\n                <version>4.0.0</version>\n                <executions>\n                    <execution>\n                        <id>get-the-git-infos</id>\n                        <goals>\n                            <goal>revision</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <generateGitPropertiesFile>true</generateGitPropertiesFile>\n                    <generateGitPropertiesFilename>${project.build.outputDirectory}/git.properties</generateGitPropertiesFilename>\n                    <format>properties</format>\n                    <failOnNoGitDirectory>false</failOnNoGitDirectory>\n                    <failOnUnableToExtractRepoInfo>false</failOnUnableToExtractRepoInfo>\n                    <runOnlyOnce>false</runOnlyOnce>\n                    <verbose>true</verbose>\n                    <skipPoms>false</skipPoms>\n                    <excludeProperties>\n                        <excludeProperty>git.user.*</excludeProperty>\n                        <excludeProperty>git.*.user.*</excludeProperty>\n                        <excludeProperty>git.closest.*</excludeProperty>\n                        <excludeProperty>git.commit.id.describe</excludeProperty>\n                        <excludeProperty>git.commit.id.describe-short</excludeProperty>\n                        <excludeProperty>git.commit.message.short</excludeProperty>\n                    </excludeProperties>\n                    <commitIdGenerationMode>flat</commitIdGenerationMode>\n                    <gitDescribe>\n                        <always>true</always>\n                    </gitDescribe>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>com.google.code.maven-replacer-plugin</groupId>\n                <artifactId>replacer</artifactId>\n                <version>1.5.3</version>\n                <executions>\n                    <execution>\n                        <id>add-version</id>\n                        <phase>process-sources</phase>\n                        <goals>\n                            <goal>replace</goal>\n                        </goals>\n                        <configuration>\n                            <includes>\n                                <include>${project.basedir}/src/main/java/org/geysermc/connector/GeyserConnector.java</include>\n                            </includes>\n                            <replacements>\n                                <replacement>\n                                    <token>String VERSION = \".*\"</token>\n                                    <value>String VERSION = \"${project.version} (\" + GIT_VERSION + \")\"</value>\n                                </replacement>\n                                <replacement>\n                                    <token>String GIT_VERSION = \".*\"</token>\n                                    <!--suppress UnresolvedMavenProperty -->\n                                    <value>String GIT_VERSION = \"git-${git.branch}-${git.commit.id.abbrev}\"</value>\n                                </replacement>\n                            </replacements>\n                        </configuration>\n                    </execution>\n\n                    <execution>\n                        <id>remove-version</id>\n                        <phase>process-classes</phase>\n                        <goals>\n                            <goal>replace</goal>\n                        </goals>\n                        <configuration>\n                            <includes>\n                                <include>${project.basedir}/src/main/java/org/geysermc/connector/GeyserConnector.java</include>\n                            </includes>\n                            <replacements>\n                                <replacement>\n                                    <token>String VERSION = \".*\"</token>\n                                    <value>String VERSION = \"DEV\"</value>\n                                </replacement>\n                                <replacement>\n                                    <token>String GIT_VERSION = \".*\"</token>\n                                    <value>String GIT_VERSION = \"DEV\"</value>\n                                </replacement>\n                            </replacements>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.0</version>\n                <configuration>\n                    <!-- Force the right file encoding during unit testing -->\n                    <argLine>-Dfile.encoding=${project.build.sourceEncoding}</argLine>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network;\n\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport com.nukkitx.protocol.bedrock.BedrockPacketCodec;\nimport com.nukkitx.protocol.bedrock.data.ExperimentData;\nimport com.nukkitx.protocol.bedrock.data.ResourcePackType;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.configuration.GeyserConfiguration;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslatorRegistry;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.utils.*;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\npublic class UpstreamPacketHandler extends LoggingPacketHandler {\n\n    public UpstreamPacketHandler(GeyserConnector connector, GeyserSession session) {\n        super(connector, session);\n    }\n\n    private boolean translateAndDefault(BedrockPacket packet) {\n        return PacketTranslatorRegistry.BEDROCK_TRANSLATOR.translate(packet.getClass(), packet, session);\n    }\n\n    @Override\n    boolean defaultHandler(BedrockPacket packet) {\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(LoginPacket loginPacket) {\n        BedrockPacketCodec packetCodec = BedrockProtocol.getBedrockCodec(loginPacket.getProtocolVersion());\n        if (packetCodec == null) {\n            String supportedVersions = BedrockProtocol.getAllSupportedVersions();\n            if (loginPacket.getProtocolVersion() > BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {\n                // Too early to determine session locale\n                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));\n                return true;\n            } else if (loginPacket.getProtocolVersion() < BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {\n                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));\n                return true;\n            }\n        }\n\n        session.getUpstream().getSession().setPacketCodec(packetCodec);\n\n        // Set the block translation based off of version\n        session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));\n        session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));\n\n        LoginEncryptionUtils.encryptPlayerConnection(connector, session, loginPacket);\n\n        PlayStatusPacket playStatus = new PlayStatusPacket();\n        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        session.sendUpstreamPacket(playStatus);\n\n        ResourcePacksInfoPacket resourcePacksInfo = new ResourcePacksInfoPacket();\n        for(ResourcePack resourcePack : ResourcePack.PACKS.values()) {\n            ResourcePackManifest.Header header = resourcePack.getManifest().getHeader();\n            resourcePacksInfo.getResourcePackInfos().add(new ResourcePacksInfoPacket.Entry(\n                    header.getUuid().toString(), header.getVersionString(), resourcePack.getFile().length(),\n                            \"\", \"\", \"\", false, false));\n        }\n        resourcePacksInfo.setForcedToAccept(GeyserConnector.getInstance().getConfig().isForceResourcePacks());\n        session.sendUpstreamPacket(resourcePacksInfo);\n        return true;\n    }\n\n    @Override\n    public boolean handle(ResourcePackClientResponsePacket packet) {\n        switch (packet.getStatus()) {\n            case COMPLETED:\n                session.connect();\n                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.connect\", session.getAuthData().getName()));\n                break;\n\n            case SEND_PACKS:\n                for(String id : packet.getPackIds()) {\n                    ResourcePackDataInfoPacket data = new ResourcePackDataInfoPacket();\n                    String[] packID = id.split(\"_\");\n                    ResourcePack pack = ResourcePack.PACKS.get(packID[0]);\n                    ResourcePackManifest.Header header = pack.getManifest().getHeader();\n\n                    data.setPackId(header.getUuid());\n                    int chunkCount = (int) Math.ceil((int) pack.getFile().length() / (double) ResourcePack.CHUNK_SIZE);\n                    data.setChunkCount(chunkCount);\n                    data.setCompressedPackSize(pack.getFile().length());\n                    data.setMaxChunkSize(ResourcePack.CHUNK_SIZE);\n                    data.setHash(pack.getSha256());\n                    data.setPackVersion(packID[1]);\n                    data.setPremium(false);\n                    data.setType(ResourcePackType.RESOURCE);\n\n                    session.sendUpstreamPacket(data);\n                }\n                break;\n\n            case HAVE_ALL_PACKS:\n                ResourcePackStackPacket stackPacket = new ResourcePackStackPacket();\n                stackPacket.setExperimentsPreviouslyToggled(false);\n                stackPacket.setForcedToAccept(false); // Leaving this as false allows the player to choose to download or not\n                stackPacket.setGameVersion(session.getClientData().getGameVersion());\n\n                for (ResourcePack pack : ResourcePack.PACKS.values()) {\n                    ResourcePackManifest.Header header = pack.getManifest().getHeader();\n                    stackPacket.getResourcePacks().add(new ResourcePackStackPacket.Entry(header.getUuid().toString(), header.getVersionString(), \"\"));\n                }\n\n                if (session.getItemMappings().getFurnaceMinecartData() != null) {\n                    // Allow custom items to work\n                    stackPacket.getExperiments().add(new ExperimentData(\"data_driven_items\", true));\n                }\n\n                if (session.getConnector().getConfig().isExtendedWorldHeight()) {\n                    // Allow extended world height in the overworld to work\n                    stackPacket.getExperiments().add(new ExperimentData(\"caves_and_cliffs\", true));\n                }\n\n                session.sendUpstreamPacket(stackPacket);\n                break;\n\n            default:\n                session.disconnect(\"disconnectionScreen.resourcePack\");\n                break;\n        }\n\n        return true;\n    }\n\n    @Override\n    public boolean handle(ModalFormResponsePacket packet) {\n        session.executeInEventLoop(() -> session.getFormCache().handleResponse(packet));\n        return true;\n    }\n\n    private boolean couldLoginUserByName(String bedrockUsername) {\n        if (connector.getConfig().getUserAuths() != null) {\n            GeyserConfiguration.IUserAuthenticationInfo info = connector.getConfig().getUserAuths().get(bedrockUsername);\n\n            if (info != null) {\n                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.auth.stored_credentials\", session.getAuthData().getName()));\n                session.setMicrosoftAccount(info.isMicrosoftAccount());\n                session.authenticate(info.getEmail(), info.getPassword());\n\n                // TODO send a message to bedrock user telling them they are connected (if nothing like a motd\n                //      somes from the Java server w/in a few seconds)\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean handle(SetLocalPlayerAsInitializedPacket packet) {\n        LanguageUtils.loadGeyserLocale(session.getLocale());\n\n        if (!session.isLoggedIn() && !session.isLoggingIn() && session.getRemoteAuthType() == AuthType.ONLINE) {\n            // TODO it is safer to key authentication on something that won't change (UUID, not username)\n            if (!couldLoginUserByName(session.getAuthData().getName())) {\n                LoginEncryptionUtils.buildAndShowLoginWindow(session);\n            }\n            // else we were able to log the user in\n        }\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(MovePlayerPacket packet) {\n        if (session.isLoggingIn()) {\n            SetTitlePacket titlePacket = new SetTitlePacket();\n            titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n            titlePacket.setText(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.wait\", session.getLocale()));\n            titlePacket.setFadeInTime(0);\n            titlePacket.setFadeOutTime(1);\n            titlePacket.setStayTime(2);\n            titlePacket.setXuid(\"\");\n            titlePacket.setPlatformOnlineId(\"\");\n            session.sendUpstreamPacket(titlePacket);\n        }\n\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(ResourcePackChunkRequestPacket packet) {\n        ResourcePackChunkDataPacket data = new ResourcePackChunkDataPacket();\n        ResourcePack pack = ResourcePack.PACKS.get(packet.getPackId().toString());\n\n        data.setChunkIndex(packet.getChunkIndex());\n        data.setProgress(packet.getChunkIndex() * ResourcePack.CHUNK_SIZE);\n        data.setPackVersion(packet.getPackVersion());\n        data.setPackId(packet.getPackId());\n\n        int offset = packet.getChunkIndex() * ResourcePack.CHUNK_SIZE;\n        byte[] packData = new byte[(int) MathUtils.constrain(pack.getFile().length() - offset, 0, ResourcePack.CHUNK_SIZE)];\n\n        try (InputStream inputStream = new FileInputStream(pack.getFile())) {\n            inputStream.skip(offset);\n            inputStream.read(packData, 0, packData.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        data.setData(packData);\n\n        session.sendUpstreamPacket(data);\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators;\n\nimport org.geysermc.connector.network.session.GeyserSession;\n\npublic abstract class PacketTranslator<T> {\n\n    public abstract void translate(T packet, GeyserSession session);\n\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListDataPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateLightPacket;\nimport com.github.steveice10.packetlib.packet.Packet;\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport io.netty.channel.EventLoop;\nimport it.unimi.dsi.fastutil.objects.ObjectArrayList;\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.utils.FileUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\npublic class PacketTranslatorRegistry<T> {\n    private final Map<Class<? extends T>, PacketTranslator<? extends T>> translators = new IdentityHashMap<>();\n\n    public static final PacketTranslatorRegistry<Packet> JAVA_TRANSLATOR = new PacketTranslatorRegistry<>();\n    public static final PacketTranslatorRegistry<BedrockPacket> BEDROCK_TRANSLATOR = new PacketTranslatorRegistry<>();\n\n    private static final ObjectArrayList<Class<?>> IGNORED_PACKETS = new ObjectArrayList<>();\n\n    static {\n        for (Class<?> clazz : FileUtils.getGeneratedClassesForAnnotation(Translator.class)) {\n            Class<?> packet = clazz.getAnnotation(Translator.class).packet();\n\n            GeyserConnector.getInstance().getLogger().debug(\"Found annotated translator: \" + clazz.getCanonicalName() + \" : \" + packet.getSimpleName());\n\n            try {\n                if (Packet.class.isAssignableFrom(packet)) {\n                    Class<? extends Packet> targetPacket = (Class<? extends Packet>) packet;\n                    PacketTranslator<? extends Packet> translator = (PacketTranslator<? extends Packet>) clazz.newInstance();\n\n                    JAVA_TRANSLATOR.translators.put(targetPacket, translator);\n                } else if (BedrockPacket.class.isAssignableFrom(packet)) {\n                    Class<? extends BedrockPacket> targetPacket = (Class<? extends BedrockPacket>) packet;\n                    PacketTranslator<? extends BedrockPacket> translator = (PacketTranslator<? extends BedrockPacket>) clazz.newInstance();\n\n                    BEDROCK_TRANSLATOR.translators.put(targetPacket, translator);\n                } else {\n                    GeyserConnector.getInstance().getLogger().error(\"Class \" + clazz.getCanonicalName() + \" is annotated as a translator but has an invalid target packet.\");\n                }\n            } catch (InstantiationException | IllegalAccessException e) {\n                GeyserConnector.getInstance().getLogger().error(\"Could not instantiate annotated translator \" + clazz.getCanonicalName());\n            }\n        }\n\n        IGNORED_PACKETS.add(ServerUpdateLightPacket.class); // Light is handled on Bedrock for us\n        IGNORED_PACKETS.add(ServerPlayerListDataPacket.class); // Cant be implemented in bedrock\n    }\n\n    private PacketTranslatorRegistry() {\n    }\n\n    public static void init() {\n        // no-op\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <P extends T> boolean translate(Class<? extends P> clazz, P packet, GeyserSession session) {\n        if (!session.getUpstream().isClosed() && !session.isClosed()) {\n            PacketTranslator<P> translator = (PacketTranslator<P>) translators.get(clazz);\n            if (translator != null) {\n                EventLoop eventLoop = session.getEventLoop();\n                if (eventLoop.inEventLoop()) {\n                    translate0(session, translator, packet);\n                } else {\n                    eventLoop.execute(() -> translate0(session, translator, packet));\n                }\n                return true;\n            } else {\n                if ((GeyserConnector.getInstance().getPlatformType() != PlatformType.STANDALONE || !(packet instanceof BedrockPacket)) && !IGNORED_PACKETS.contains(clazz)) {\n                    // Other debug logs already take care of Bedrock packets for us if on standalone\n                    GeyserConnector.getInstance().getLogger().debug(\"Could not find packet for \" + (packet.toString().length() > 25 ? packet.getClass().getSimpleName() : packet));\n                }\n            }\n        }\n        return false;\n    }\n\n    private <P extends T> void translate0(GeyserSession session, PacketTranslator<P> translator, P packet) {\n        if (session.isClosed()) {\n            return;\n        }\n\n        try {\n            translator.translate(packet, session);\n        } catch (Throwable ex) {\n            GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.packet.failed\", packet.getClass().getSimpleName()), ex);\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerAbilitiesPacket;\nimport com.nukkitx.protocol.bedrock.data.AdventureSetting;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.AdventureSettingsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = AdventureSettingsPacket.class)\npublic class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {\n\n    @Override\n    public void translate(AdventureSettingsPacket packet, GeyserSession session) {\n        boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);\n        if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {\n            // We should always be flying in spectator mode\n            session.sendAdventureSettings();\n            return;\n        }\n\n        session.setFlying(isFlying);\n        ClientPlayerAbilitiesPacket abilitiesPacket = new ClientPlayerAbilitiesPacket(isFlying);\n        session.sendDownstreamPacket(abilitiesPacket);\n\n        if (isFlying && session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.SWIMMING)) {\n            // Bedrock can fly and swim at the same time? Make sure that can't happen\n            session.setSwimming(false);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerSwingArmPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerBoatPacket;\nimport com.nukkitx.protocol.bedrock.packet.AnimatePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = AnimatePacket.class)\npublic class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {\n\n    @Override\n    public void translate(AnimatePacket packet, GeyserSession session) {\n        // Stop the player sending animations before they have fully spawned into the server\n        if (!session.isSpawned()) {\n            return;\n        }\n\n        switch (packet.getAction()) {\n            case SWING_ARM:\n                // Delay so entity damage can be processed first\n                session.scheduleInEventLoop(() ->\n                        session.sendDownstreamPacket(new ClientPlayerSwingArmPacket(Hand.MAIN_HAND)),\n                        25,\n                        TimeUnit.MILLISECONDS\n                );\n                break;\n            // These two might need to be flipped, but my recommendation is getting moving working first\n            case ROW_LEFT:\n                // Packet value is a float of how long one has been rowing, so we convert that into a boolean\n                session.setSteeringLeft(packet.getRowingTime() > 0.0);\n                ClientSteerBoatPacket steerLeftPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());\n                session.sendDownstreamPacket(steerLeftPacket);\n                break;\n            case ROW_RIGHT:\n                session.setSteeringRight(packet.getRowingTime() > 0.0);\n                ClientSteerBoatPacket steerRightPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());\n                session.sendDownstreamPacket(steerRightPacket);\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateJigsawBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientUpdateSignPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.SignUtils;\n\n@Translator(packet = BlockEntityDataPacket.class)\npublic class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {\n\n    @Override\n    public void translate(BlockEntityDataPacket packet, GeyserSession session) {\n        NbtMap tag = packet.getData();\n        if (tag.getString(\"id\").equals(\"Sign\")) {\n            // This is the reason why this all works - Bedrock sends packets every time you update the sign, Java only wants the final packet\n            // But Bedrock sends one final packet when you're done editing the sign, which should be equal to the last message since there's no edits\n            // So if the latest update does not match the last cached update then it's still being edited\n            if (!tag.getString(\"Text\").equals(session.getLastSignMessage())) {\n                session.setLastSignMessage(tag.getString(\"Text\"));\n                return;\n            }\n            // Otherwise the two messages are identical and we can get to work deconstructing\n            StringBuilder newMessage = new StringBuilder();\n            // While Bedrock's sign lines are one string, Java's is an array of each line\n            // (Initialized all with empty strings because it complains about null)\n            String[] lines = new String[] {\"\", \"\", \"\", \"\"};\n            int iterator = 0;\n            // Keep track of the width of each character\n            // If it goes over the maximum, we need to start a new line to match Java\n            int widthCount = 0;\n            // This converts the message into the array'd message Java wants\n            for (char character : tag.getString(\"Text\").toCharArray()) {\n                widthCount += SignUtils.getCharacterWidth(character);\n                // If we get a return in Bedrock, or go over the character width max, that signals to use the next line.\n                if (character == '\\n' || widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX) {\n                    // We need to apply some more logic if we went over the character width max\n                    boolean wentOverMax = widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX && character != '\\n';\n                    widthCount = 0;\n                    // Saves if we're moving a word to the next line\n                    String word = null;\n                    if (wentOverMax && iterator < lines.length - 1) {\n                        // If we went over the max, we want to try to wrap properly like Bedrock does.\n                        // So we look for a space in the Bedrock user's text to imply a word.\n                        int index = newMessage.lastIndexOf(\" \");\n                        if (index != -1) {\n                            // There is indeed a space in this line; let's get it\n                            word = newMessage.substring(index + 1);\n                            // 'Delete' that word from the string builder\n                            newMessage.delete(index, newMessage.length());\n                        }\n                    }\n                    lines[iterator] = newMessage.toString();\n                    iterator++;\n                    // Bedrock, for whatever reason, can hold a message out of the bounds of the four lines\n                    // We don't care about that so we discard that\n                    if (iterator > lines.length - 1) {\n                        break;\n                    }\n                    newMessage = new StringBuilder();\n                    if (wentOverMax) {\n                        // Apply the wrapped word to the new line\n                        if (word != null) {\n                            newMessage.append(word);\n                            // And apply the width count\n                            for (char wordCharacter : word.toCharArray()) {\n                                widthCount += SignUtils.getCharacterWidth(wordCharacter);\n                            }\n                        }\n                        // If we went over the max, we want to append the character to the new line.\n                        newMessage.append(character);\n                        widthCount += SignUtils.getCharacterWidth(character);\n                    }\n                } else newMessage.append(character);\n            }\n            // Put the final line on since it isn't done in the for loop\n            if (iterator < lines.length) lines[iterator] = newMessage.toString();\n            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));\n            ClientUpdateSignPacket clientUpdateSignPacket = new ClientUpdateSignPacket(pos, lines);\n            session.sendDownstreamPacket(clientUpdateSignPacket);\n\n            // We set the sign text cached in the session to null to indicate there is no work-in-progress sign\n            session.setLastSignMessage(null);\n\n        } else if (tag.getString(\"id\").equals(\"JigsawBlock\")) {\n            // Client has just sent a jigsaw block update\n            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));\n            String name = tag.getString(\"name\");\n            String target = tag.getString(\"target\");\n            String pool = tag.getString(\"target_pool\");\n            String finalState = tag.getString(\"final_state\");\n            String joint = tag.getString(\"joint\");\n            ClientUpdateJigsawBlockPacket jigsawPacket = new ClientUpdateJigsawBlockPacket(pos, name, target, pool,\n                    finalState, joint);\n            session.sendDownstreamPacket(jigsawPacket);\n        }\n\n    }\n}\n", "/*\r\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n * @author GeyserMC\r\n * @link https://github.com/GeyserMC/Geyser\r\n */\r\n\r\npackage org.geysermc.connector.network.translators.bedrock;\r\n\r\nimport com.nukkitx.math.vector.Vector3i;\r\nimport com.nukkitx.protocol.bedrock.packet.BlockPickRequestPacket;\r\nimport org.geysermc.connector.entity.ItemFrameEntity;\r\nimport org.geysermc.connector.entity.type.EntityType;\r\nimport org.geysermc.connector.network.session.GeyserSession;\r\nimport org.geysermc.connector.network.translators.PacketTranslator;\r\nimport org.geysermc.connector.network.translators.Translator;\r\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\r\nimport org.geysermc.connector.registry.BlockRegistries;\r\nimport org.geysermc.connector.utils.InventoryUtils;\r\n\r\n@Translator(packet = BlockPickRequestPacket.class)\r\npublic class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {\r\n\r\n    @Override\r\n    public void translate(BlockPickRequestPacket packet, GeyserSession session) {\r\n        Vector3i vector = packet.getBlockPosition();\r\n        int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());\r\n        \r\n        // Block is air - chunk caching is probably off\r\n        if (blockToPick == BlockStateValues.JAVA_AIR_ID) {\r\n            // Check for an item frame since the client thinks that's a block when it's an entity in Java\r\n            ItemFrameEntity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\r\n            if (entity != null) {\r\n                // Check to see if the item frame has an item in it first\r\n                if (entity.getHeldItem() != null && entity.getHeldItem().getId() != 0) {\r\n                    // Grab the item in the frame\r\n                    InventoryUtils.findOrCreateItem(session, entity.getHeldItem());\r\n                } else {\r\n                    // Grab the frame as the item\r\n                    InventoryUtils.findOrCreateItem(session, entity.getEntityType() == EntityType.GLOW_ITEM_FRAME ? \"minecraft:glow_item_frame\" : \"minecraft:item_frame\");\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        InventoryUtils.findOrCreateItem(session, BlockRegistries.JAVA_BLOCKS.get(blockToPick).getPickItem());\r\n    }\r\n}\r\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientEditBookPacket;\nimport com.github.steveice10.opennbt.tag.builtin.CompoundTag;\nimport com.github.steveice10.opennbt.tag.builtin.ListTag;\nimport com.github.steveice10.opennbt.tag.builtin.StringTag;\nimport com.github.steveice10.opennbt.tag.builtin.Tag;\nimport com.nukkitx.protocol.bedrock.packet.BookEditPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n@Translator(packet = BookEditPacket.class)\npublic class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket> {\n    private static final int MAXIMUM_PAGE_LENGTH = 8192 * 4;\n    private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;\n\n    @Override\n    public void translate(BookEditPacket packet, GeyserSession session) {\n        if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {\n            session.getConnector().getLogger().warning(\"Page length greater than server allowed!\");\n            return;\n        }\n\n        GeyserItemStack itemStack = session.getPlayerInventory().getItemInHand();\n        if (itemStack != null) {\n            CompoundTag tag = itemStack.getNbt() != null ? itemStack.getNbt() : new CompoundTag(\"\");\n            ItemStack bookItem = new ItemStack(itemStack.getJavaId(), itemStack.getAmount(), tag);\n            List<Tag> pages = tag.contains(\"pages\") ? new LinkedList<>(((ListTag) tag.get(\"pages\")).getValue()) : new LinkedList<>();\n\n            int page = packet.getPageNumber();\n            switch (packet.getAction()) {\n                case ADD_PAGE: {\n                    // Add empty pages in between\n                    for (int i = pages.size(); i < page; i++) {\n                        pages.add(i, new StringTag(\"\", \"\"));\n                    }\n                    pages.add(page, new StringTag(\"\", packet.getText()));\n                    break;\n                }\n                // Called whenever a page is modified\n                case REPLACE_PAGE: {\n                    if (page < pages.size()) {\n                        pages.set(page, new StringTag(\"\", packet.getText()));\n                    } else {\n                        // Add empty pages in between\n                        for (int i = pages.size(); i < page; i++) {\n                            pages.add(i, new StringTag(\"\", \"\"));\n                        }\n                        pages.add(page, new StringTag(\"\", packet.getText()));\n                    }\n                    break;\n                }\n                case DELETE_PAGE: {\n                    if (page < pages.size()) {\n                        pages.remove(page);\n                    }\n                    break;\n                }\n                case SWAP_PAGES: {\n                    int page2 = packet.getSecondaryPageNumber();\n                    if (page < pages.size() && page2 < pages.size()) {\n                        Collections.swap(pages, page, page2);\n                    }\n                    break;\n                }\n                case SIGN_BOOK: {\n                    tag.put(new StringTag(\"author\", packet.getAuthor()));\n                    tag.put(new StringTag(\"title\", packet.getTitle()));\n                    break;\n                }\n                default:\n                    return;\n            }\n            // Remove empty pages at the end\n            while (pages.size() > 0) {\n                StringTag currentPage = (StringTag) pages.get(pages.size() - 1);\n                if (currentPage.getValue() == null || currentPage.getValue().isEmpty()) {\n                    pages.remove(pages.size() - 1);\n                } else {\n                    break;\n                }\n            }\n            tag.put(new ListTag(\"pages\", pages));\n            // Update local copy\n            session.getPlayerInventory().setItem(36 + session.getPlayerInventory().getHeldItemSlot(), GeyserItemStack.from(bookItem), session);\n            session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());\n\n            List<String> networkPages = new ArrayList<>();\n            for (Tag pageTag : pages) {\n                networkPages.add(((StringTag) pageTag).getValue());\n            }\n\n            String title;\n            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {\n                // Add title to packet so the server knows we're signing\n                if (packet.getTitle().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_TITLE_LENGTH) {\n                    session.getConnector().getLogger().warning(\"Book title larger than server allows!\");\n                    return;\n                }\n\n                title = packet.getTitle();\n            } else {\n                title = null;\n            }\n\n            session.getBookEditCache().setPacket(new ClientEditBookPacket(session.getPlayerInventory().getHeldItemSlot(), networkPages, title));\n            // There won't be any more book updates after this, so we can try sending the edit packet immediately\n            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {\n                session.getBookEditCache().checkForSend();\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.world.block.CommandBlockMode;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockMinecartPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockPacket;\nimport com.nukkitx.protocol.bedrock.packet.CommandBlockUpdatePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = CommandBlockUpdatePacket.class)\npublic class BedrockCommandBlockUpdateTranslator extends PacketTranslator<CommandBlockUpdatePacket> {\n\n    @Override\n    public void translate(CommandBlockUpdatePacket packet, GeyserSession session) {\n        String command = packet.getCommand();\n        boolean outputTracked = packet.isOutputTracked();\n        if (packet.isBlock()) {\n            CommandBlockMode mode;\n            switch (packet.getMode()) {\n                case CHAIN: // The green one\n                    mode = CommandBlockMode.SEQUENCE;\n                    break;\n                case REPEATING: // The purple one\n                    mode = CommandBlockMode.AUTO;\n                    break;\n                default: // NORMAL, the orange one\n                    mode = CommandBlockMode.REDSTONE;\n                    break;\n            }\n            boolean isConditional = packet.isConditional();\n            boolean automatic = !packet.isRedstoneMode(); // Automatic = Always Active option in Java\n            ClientUpdateCommandBlockPacket commandBlockPacket = new ClientUpdateCommandBlockPacket(\n                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                    command, mode, outputTracked, isConditional, automatic);\n            session.sendDownstreamPacket(commandBlockPacket);\n        } else {\n            ClientUpdateCommandBlockMinecartPacket commandMinecartPacket = new ClientUpdateCommandBlockMinecartPacket(\n                    (int) session.getEntityCache().getEntityByGeyserId(packet.getMinecartRuntimeEntityId()).getEntityId(),\n                    command, outputTracked\n            );\n            session.sendDownstreamPacket(commandMinecartPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.command.CommandManager;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.CommandRequestPacket;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = CommandRequestPacket.class)\npublic class BedrockCommandRequestTranslator extends PacketTranslator<CommandRequestPacket> {\n\n    @Override\n    public void translate(CommandRequestPacket packet, GeyserSession session) {\n        String command = packet.getCommand().replace(\"/\", \"\");\n        CommandManager commandManager = GeyserConnector.getInstance().getCommandManager();\n        if (session.getConnector().getPlatformType() == PlatformType.STANDALONE && command.trim().startsWith(\"geyser \") && commandManager.getCommands().containsKey(command.split(\" \")[1])) {\n            commandManager.runCommand(session, command);\n        } else {\n            String message = packet.getCommand().trim();\n\n            if (MessageTranslator.isTooLong(message, session)) {\n                return;\n            }\n\n            ClientChatPacket chatPacket = new ClientChatPacket(message);\n            session.sendDownstreamPacket(chatPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.nukkitx.protocol.bedrock.packet.ContainerClosePacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ContainerClosePacket.class)\npublic class BedrockContainerCloseTranslator extends PacketTranslator<ContainerClosePacket> {\n\n    @Override\n    public void translate(ContainerClosePacket packet, GeyserSession session) {\n        byte windowId = packet.getId();\n\n        //Client wants close confirmation\n        session.sendUpstreamPacket(packet);\n        session.setClosingInventory(false);\n\n        if (windowId == -1 && session.getOpenInventory() instanceof MerchantContainer) {\n            // 1.16.200 - window ID is always -1 sent from Bedrock\n            windowId = (byte) session.getOpenInventory().getId();\n        }\n\n        Inventory openInventory = session.getOpenInventory();\n        if (openInventory != null) {\n            if (windowId == openInventory.getId()) {\n                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(windowId);\n                session.sendDownstreamPacket(closeWindowPacket);\n                InventoryUtils.closeInventory(session, windowId, false);\n            } else if (openInventory.isPending()) {\n                InventoryUtils.displayInventory(session, openInventory);\n                openInventory.setPending(false);\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.EmoteListPacket;\nimport org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = EmoteListPacket.class)\npublic class BedrockEmoteListTranslator extends PacketTranslator<EmoteListPacket> {\n\n    @Override\n    public void translate(EmoteListPacket packet, GeyserSession session) {\n        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {\n            return;\n        }\n\n        session.refreshEmotes(packet.getPieceIds());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.EntityPickRequestPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n/**\n * Called when the Bedrock user uses the pick block button on an entity\n */\n@Translator(packet = EntityPickRequestPacket.class)\npublic class BedrockEntityPickRequestTranslator extends PacketTranslator<EntityPickRequestPacket> {\n\n    @Override\n    public void translate(EntityPickRequestPacket packet, GeyserSession session) {\n        if (session.getGameMode() != GameMode.CREATIVE) return; // Apparently Java behavior\n        Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n        if (entity == null) return;\n\n        // Get the corresponding item\n        String itemName;\n        switch (entity.getEntityType()) {\n            case BOAT:\n                // Include type of boat in the name\n                int variant = entity.getMetadata().getInt(EntityData.VARIANT);\n                String typeOfBoat;\n                switch (variant) {\n                    case 1:\n                        typeOfBoat = \"spruce\";\n                        break;\n                    case 2:\n                        typeOfBoat = \"birch\";\n                        break;\n                    case 3:\n                        typeOfBoat = \"jungle\";\n                        break;\n                    case 4:\n                        typeOfBoat = \"acacia\";\n                        break;\n                    case 5:\n                        typeOfBoat = \"dark_oak\";\n                        break;\n                    default:\n                        typeOfBoat = \"oak\";\n                        break;\n                }\n                itemName = typeOfBoat + \"_boat\";\n                break;\n            case LEASH_KNOT:\n                itemName = \"lead\";\n                break;\n            case MINECART_CHEST:\n            case MINECART_COMMAND_BLOCK:\n            case MINECART_FURNACE:\n            case MINECART_HOPPER:\n            case MINECART_TNT:\n                // Move MINECART to the end of the name\n                itemName = entity.getEntityType().toString().toLowerCase().replace(\"minecart_\", \"\") + \"_minecart\";\n                break;\n            case MINECART_SPAWNER:\n                // Turns into a normal minecart\n                itemName = \"minecart\";\n                break;\n            case ARMOR_STAND:\n            case END_CRYSTAL:\n            //case ITEM_FRAME: Not an entity in Bedrock Edition\n            //case GLOW_ITEM_FRAME:\n            case MINECART:\n            case PAINTING:\n                // No spawn egg, just an item\n                itemName = entity.getEntityType().toString().toLowerCase();\n                break;\n            default:\n                itemName = entity.getEntityType().toString().toLowerCase() + \"_spawn_egg\";\n                break;\n        }\n\n        String fullItemName = \"minecraft:\" + itemName;\n        ItemMapping mapping = session.getItemMappings().getMapping(fullItemName);\n        // Verify it is, indeed, an item\n        if (mapping == null) return;\n\n        InventoryUtils.findOrCreateItem(session, fullItemName);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientRenameItemPacket;\nimport com.nukkitx.protocol.bedrock.packet.FilterTextPacket;\nimport org.geysermc.connector.inventory.AnvilContainer;\nimport org.geysermc.connector.inventory.CartographyContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Used to send strings to the server and filter out unwanted words.\n * Java doesn't care, so we don't care, and we approve all strings.\n */\n@Translator(packet = FilterTextPacket.class)\npublic class BedrockFilterTextTranslator extends PacketTranslator<FilterTextPacket> {\n\n    @Override\n    public void translate(FilterTextPacket packet, GeyserSession session) {\n        if (session.getOpenInventory() instanceof CartographyContainer) {\n            // We don't want to be able to rename in the cartography table\n            return;\n        }\n        packet.setFromServer(true);\n        session.sendUpstreamPacket(packet);\n\n        if (session.getOpenInventory() instanceof AnvilContainer) {\n            // Java Edition sends a packet every time an item is renamed even slightly in GUI. Fortunately, this works out for us now\n            ClientRenameItemPacket renameItemPacket = new ClientRenameItemPacket(packet.getText());\n            session.sendDownstreamPacket(renameItemPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.*;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.CommandBlockMinecartEntity;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.sound.EntitySoundInteractionHandler;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.registry.type.ItemMappings;\nimport org.geysermc.connector.utils.BlockUtils;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * BedrockInventoryTransactionTranslator handles most interactions between the client and the world,\n * or the client and their inventory.\n */\n@Translator(packet = InventoryTransactionPacket.class)\npublic class BedrockInventoryTransactionTranslator extends PacketTranslator<InventoryTransactionPacket> {\n\n    private static final float MAXIMUM_BLOCK_PLACING_DISTANCE = 64f;\n    private static final int CREATIVE_EYE_HEIGHT_PLACE_DISTANCE = 49;\n    private static final int SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE = 36;\n    private static final float MAXIMUM_BLOCK_DESTROYING_DISTANCE = 36f;\n\n    @Override\n    public void translate(InventoryTransactionPacket packet, GeyserSession session) {\n        // Send book updates before opening inventories\n        session.getBookEditCache().checkForSend();\n\n        ItemMappings mappings = session.getItemMappings();\n\n        switch (packet.getTransactionType()) {\n            case NORMAL:\n                if (packet.getActions().size() == 2) {\n                    InventoryActionData worldAction = packet.getActions().get(0);\n                    InventoryActionData containerAction = packet.getActions().get(1);\n                    if (worldAction.getSource().getType() == InventorySource.Type.WORLD_INTERACTION\n                            && worldAction.getSource().getFlag() == InventorySource.Flag.DROP_ITEM) {\n                        if (session.getPlayerInventory().getHeldItemSlot() != containerAction.getSlot() ||\n                                session.getPlayerInventory().getItemInHand().isEmpty()) {\n                            return;\n                        }\n\n                        boolean dropAll = worldAction.getToItem().getCount() > 1;\n                        ClientPlayerActionPacket dropAllPacket = new ClientPlayerActionPacket(\n                                dropAll ? PlayerAction.DROP_ITEM_STACK : PlayerAction.DROP_ITEM,\n                                BlockUtils.POSITION_ZERO,\n                                BlockFace.DOWN\n                        );\n                        session.sendDownstreamPacket(dropAllPacket);\n\n                        if (dropAll) {\n                            session.getPlayerInventory().setItemInHand(GeyserItemStack.EMPTY);\n                        } else {\n                            session.getPlayerInventory().getItemInHand().sub(1);\n                        }\n                    }\n                }\n                break;\n            case INVENTORY_MISMATCH:\n                break;\n            case ITEM_USE:\n                switch (packet.getActionType()) {\n                    case 0:\n                        // Check to make sure the client isn't spamming interaction\n                        // Based on Nukkit 1.0, with changes to ensure holding down still works\n                        boolean hasAlreadyClicked = System.currentTimeMillis() - session.getLastInteractionTime() < 110.0 &&\n                                packet.getBlockPosition().distanceSquared(session.getLastInteractionBlockPosition()) < 0.00001;\n                        session.setLastInteractionBlockPosition(packet.getBlockPosition());\n                        session.setLastInteractionPlayerPosition(session.getPlayerEntity().getPosition());\n                        if (hasAlreadyClicked) {\n                            break;\n                        } else {\n                            // Only update the interaction time if it's valid - that way holding down still works.\n                            session.setLastInteractionTime(System.currentTimeMillis());\n                        }\n\n                        // Bedrock sends block interact code for a Java entity so we send entity code back to Java\n                        if (session.getBlockMappings().isItemFrame(packet.getBlockRuntimeId())) {\n                            Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                            if (itemFrameEntity != null) {\n                                int entityId = (int) itemFrameEntity.getEntityId();\n                                Vector3f vector = packet.getClickPosition();\n                                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket(entityId,\n                                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                                ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket(entityId,\n                                        InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());\n                                session.sendDownstreamPacket(interactPacket);\n                                session.sendDownstreamPacket(interactAtPacket);\n                                break;\n                            }\n                        }\n\n                        Vector3i blockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getBlockFace());\n                        /*\n                        Checks to ensure that the range will be accepted by the server.\n                        \"Not in range\" doesn't refer to how far a vanilla client goes (that's a whole other mess),\n                        but how much a server will accept from the client maximum\n                         */\n                        // CraftBukkit+ check - see https://github.com/PaperMC/Paper/blob/458db6206daae76327a64f4e2a17b67a7e38b426/Spigot-Server-Patches/0532-Move-range-check-for-block-placing-up.patch\n                        Vector3f playerPosition = session.getPlayerEntity().getPosition();\n\n                        // Adjust position for current eye height\n                        switch (session.getPose()) {\n                            case SNEAKING:\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 1.27f), 0);\n                                break;\n                            case SWIMMING:\n                            case FALL_FLYING: // Elytra\n                            case SPIN_ATTACK: // Trident spin attack\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.4f), 0);\n                                break;\n                            case SLEEPING:\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.2f), 0);\n                                break;\n                        } // else, we don't have to modify the position\n\n                        float diffX = playerPosition.getX() - packet.getBlockPosition().getX();\n                        float diffY = playerPosition.getY() - packet.getBlockPosition().getY();\n                        float diffZ = playerPosition.getZ() - packet.getBlockPosition().getZ();\n                        if (((diffX * diffX) + (diffY * diffY) + (diffZ * diffZ)) >\n                                (session.getGameMode().equals(GameMode.CREATIVE) ? CREATIVE_EYE_HEIGHT_PLACE_DISTANCE : SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE)) {\n                            restoreCorrectBlock(session, blockPos, packet);\n                            return;\n                        }\n\n                        // Vanilla check\n                        if (!(session.getPlayerEntity().getPosition().sub(0, EntityType.PLAYER.getOffset(), 0)\n                                .distanceSquared(packet.getBlockPosition().toFloat().add(0.5f, 0.5f, 0.5f)) < MAXIMUM_BLOCK_PLACING_DISTANCE)) {\n                            // The client thinks that its blocks have been successfully placed. Restore the server's blocks instead.\n                            restoreCorrectBlock(session, blockPos, packet);\n                            return;\n                        }\n                        /*\n                        Block place checks end - client is good to go\n                         */\n\n                        if (packet.getItemInHand() != null && session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {\n                            int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());\n                            if (blockState == BlockStateValues.JAVA_WATER_ID) {\n                                // Otherwise causes multiple mobs to spawn - just send a use item packet\n                                // TODO when we fix mobile bucket rotation, use it for this, too\n                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                session.sendDownstreamPacket(itemPacket);\n                                break;\n                            }\n                        }\n\n                        ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(\n                                new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                                BlockFace.values()[packet.getBlockFace()],\n                                Hand.MAIN_HAND,\n                                packet.getClickPosition().getX(), packet.getClickPosition().getY(), packet.getClickPosition().getZ(),\n                                false);\n                        session.sendDownstreamPacket(blockPacket);\n\n                        if (packet.getItemInHand() != null) {\n                            // Otherwise boats will not be able to be placed in survival and buckets won't work on mobile\n                            if (session.getItemMappings().getBoatIds().contains(packet.getItemInHand().getId())) {\n                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                session.sendDownstreamPacket(itemPacket);\n                            } else if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId())) {\n                                // Let the server decide if the bucket item should change, not the client, and revert the changes the client made\n                                InventorySlotPacket slotPacket = new InventorySlotPacket();\n                                slotPacket.setContainerId(ContainerId.INVENTORY);\n                                slotPacket.setSlot(packet.getHotbarSlot());\n                                slotPacket.setItem(packet.getItemInHand());\n                                session.sendUpstreamPacket(slotPacket);\n                                // Don't send ClientPlayerUseItemPacket for powder snow buckets\n                                if (packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().powderSnowBucket().getBedrockId()) {\n                                    // Special check for crafting tables since clients don't send BLOCK_INTERACT when interacting\n                                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());\n                                    if (session.isSneaking() || blockState != BlockRegistries.JAVA_IDENTIFIERS.get(\"minecraft:crafting_table\")) {\n                                        // Delay the interaction in case the client doesn't intend to actually use the bucket\n                                        // See BedrockActionTranslator.java\n                                        session.setBucketScheduledFuture(session.scheduleInEventLoop(() -> {\n                                            ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                            session.sendDownstreamPacket(itemPacket);\n                                        }, 5, TimeUnit.MILLISECONDS));\n                                    }\n                                }\n                            }\n                        }\n\n                        if (packet.getActions().isEmpty()) {\n                            if (session.getOpPermissionLevel() >= 2 && session.getGameMode() == GameMode.CREATIVE) {\n                                // Otherwise insufficient permissions\n                                int blockState = session.getBlockMappings().getJavaBlockState(packet.getBlockRuntimeId());\n                                String blockName = BlockRegistries.JAVA_IDENTIFIERS.get().getOrDefault(blockState, \"\");\n                                // In the future this can be used for structure blocks too, however not all elements\n                                // are available in each GUI\n                                if (blockName.contains(\"jigsaw\")) {\n                                    ContainerOpenPacket openPacket = new ContainerOpenPacket();\n                                    openPacket.setBlockPosition(packet.getBlockPosition());\n                                    openPacket.setId((byte) 1);\n                                    openPacket.setType(ContainerType.JIGSAW_EDITOR);\n                                    openPacket.setUniqueEntityId(-1);\n                                    session.sendUpstreamPacket(openPacket);\n                                }\n                            }\n                        }\n\n                        ItemMapping handItem = mappings.getMapping(packet.getItemInHand());\n                        if (handItem.isBlock()) {\n                            session.setLastBlockPlacePosition(blockPos);\n                            session.setLastBlockPlacedId(handItem.getJavaIdentifier());\n                        }\n                        session.setInteracting(true);\n                        break;\n                    case 1:\n                        if (packet.getActions().size() == 1 && packet.getLegacySlots().size() > 0) {\n                            InventoryActionData actionData = packet.getActions().get(0);\n                            LegacySetItemSlotData slotData = packet.getLegacySlots().get(0);\n                            if (slotData.getContainerId() == 6 && actionData.getToItem().getId() != 0) {\n                                // The player is trying to swap out an armor piece that already has an item in it\n                                // Java Edition does not allow this; let's revert it\n                                session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());\n                            }\n                        }\n\n                        // Handled when sneaking\n                        if (session.getPlayerInventory().getItemInHand().getJavaId() == mappings.getStoredItems().shield().getJavaId()) {\n                            break;\n                        }\n\n                        // Handled in ITEM_USE if the item is not milk\n                        if (packet.getItemInHand() != null) {\n                            if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId()) &&\n                                    packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().milkBucket().getBedrockId()) {\n                                // Handled in case 0 if the item is not milk\n                                break;\n                            } else if (session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {\n                                // Handled in case 0\n                                break;\n                            }\n                        }\n\n                        ClientPlayerUseItemPacket useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                        session.sendDownstreamPacket(useItemPacket);\n                        break;\n                    case 2:\n                        int blockState = session.getGameMode() == GameMode.CREATIVE ?\n                                session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition()) : session.getBreakingBlock();\n\n                        session.setLastBlockPlacedId(null);\n                        session.setLastBlockPlacePosition(null);\n\n                        // Same deal with vanilla block placing as above.\n                        // This is working out the distance using 3d Pythagoras and the extra value added to the Y is the sneaking height of a java player.\n                        playerPosition = session.getPlayerEntity().getPosition();\n                        Vector3f floatBlockPosition = packet.getBlockPosition().toFloat();\n                        diffX = playerPosition.getX() - (floatBlockPosition.getX() + 0.5f);\n                        diffY = (playerPosition.getY() - EntityType.PLAYER.getOffset()) - (floatBlockPosition.getY() + 0.5f) + 1.5f;\n                        diffZ = playerPosition.getZ() - (floatBlockPosition.getZ() + 0.5f);\n                        float distanceSquared = diffX * diffX + diffY * diffY + diffZ * diffZ;\n                        if (distanceSquared > MAXIMUM_BLOCK_DESTROYING_DISTANCE) {\n                            restoreCorrectBlock(session, packet.getBlockPosition(), packet);\n                            return;\n                        }\n\n                        LevelEventPacket blockBreakPacket = new LevelEventPacket();\n                        blockBreakPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);\n                        blockBreakPacket.setPosition(packet.getBlockPosition().toFloat());\n                        blockBreakPacket.setData(session.getBlockMappings().getBedrockBlockId(blockState));\n                        session.sendUpstreamPacket(blockBreakPacket);\n                        session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n\n                        Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                        if (itemFrameEntity != null) {\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                            break;\n                        }\n\n                        PlayerAction action = session.getGameMode() == GameMode.CREATIVE ? PlayerAction.START_DIGGING : PlayerAction.FINISH_DIGGING;\n                        Position pos = new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ());\n                        ClientPlayerActionPacket breakPacket = new ClientPlayerActionPacket(action, pos, BlockFace.values()[packet.getBlockFace()]);\n                        session.sendDownstreamPacket(breakPacket);\n                        break;\n                }\n                break;\n            case ITEM_RELEASE:\n                if (packet.getActionType() == 0) {\n                    // Followed to the Minecraft Protocol specification outlined at wiki.vg\n                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO,\n                            BlockFace.DOWN);\n                    session.sendDownstreamPacket(releaseItemPacket);\n                }\n                break;\n            case ITEM_USE_ON_ENTITY:\n                Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n                if (entity == null)\n                    return;\n\n                //https://wiki.vg/Protocol#Interact_Entity\n                switch (packet.getActionType()) {\n                    case 0: //Interact\n                        if (entity instanceof CommandBlockMinecartEntity) {\n                            // The UI is handled client-side on Java Edition\n                            // Ensure OP permission level and gamemode is appropriate\n                            if (session.getOpPermissionLevel() < 2 || session.getGameMode() != GameMode.CREATIVE) return;\n                            ContainerOpenPacket openPacket = new ContainerOpenPacket();\n                            openPacket.setBlockPosition(Vector3i.ZERO);\n                            openPacket.setId((byte) 1);\n                            openPacket.setType(ContainerType.COMMAND_BLOCK);\n                            openPacket.setUniqueEntityId(entity.getGeyserId());\n                            session.sendUpstreamPacket(openPacket);\n                            break;\n                        }\n                        Vector3f vector = packet.getClickPosition().sub(entity.getPosition());\n                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                        ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());\n                        session.sendDownstreamPacket(interactPacket);\n                        session.sendDownstreamPacket(interactAtPacket);\n\n                        EntitySoundInteractionHandler.handleEntityInteraction(session, packet.getClickPosition(), entity);\n                        break;\n                    case 1: //Attack\n                        if (entity.getEntityType() == EntityType.ENDER_DRAGON) {\n                            // Redirects the attack to its body entity, this only happens when\n                            // attacking the underbelly of the ender dragon\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId() + 3,\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                        } else {\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                        }\n                        break;\n                }\n                break;\n        }\n    }\n\n    /**\n     * Restore the correct block state from the server without updating the chunk cache.\n     *\n     * @param session the session of the Bedrock client\n     * @param blockPos the block position to restore\n     */\n    private void restoreCorrectBlock(GeyserSession session, Vector3i blockPos, InventoryTransactionPacket packet) {\n        int javaBlockState = session.getConnector().getWorldManager().getBlockAt(session, blockPos);\n        UpdateBlockPacket updateBlockPacket = new UpdateBlockPacket();\n        updateBlockPacket.setDataLayer(0);\n        updateBlockPacket.setBlockPosition(blockPos);\n        updateBlockPacket.setRuntimeId(session.getBlockMappings().getBedrockBlockId(javaBlockState));\n        updateBlockPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);\n        session.sendUpstreamPacket(updateBlockPacket);\n\n        UpdateBlockPacket updateWaterPacket = new UpdateBlockPacket();\n        updateWaterPacket.setDataLayer(1);\n        updateWaterPacket.setBlockPosition(blockPos);\n        updateWaterPacket.setRuntimeId(BlockRegistries.WATERLOGGED.get().contains(javaBlockState) ? session.getBlockMappings().getBedrockWaterId() : session.getBlockMappings().getBedrockAirId());\n        updateWaterPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);\n        session.sendUpstreamPacket(updateWaterPacket);\n\n        // Reset the item in hand to prevent \"missing\" blocks\n        InventorySlotPacket slotPacket = new InventorySlotPacket();\n        slotPacket.setContainerId(ContainerId.INVENTORY);\n        slotPacket.setSlot(packet.getHotbarSlot());\n        slotPacket.setItem(packet.getItemInHand());\n        session.sendUpstreamPacket(slotPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.nukkitx.protocol.bedrock.packet.ItemFrameDropItemPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Pre-1.16.210: used for both survival and creative item frame item removal\n *\n * 1.16.210: only used in creative.\n */\n@Translator(packet = ItemFrameDropItemPacket.class)\npublic class BedrockItemFrameDropItemTranslator extends PacketTranslator<ItemFrameDropItemPacket> {\n\n    @Override\n    public void translate(ItemFrameDropItemPacket packet, GeyserSession session) {\n        Entity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n        if (entity != null) {\n            ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                    InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n            session.sendDownstreamPacket(interactPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ItemStackRequestPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\n\n/**\n * The packet sent for server-authoritative-style inventory transactions.\n */\n@Translator(packet = ItemStackRequestPacket.class)\npublic class BedrockItemStackRequestTranslator extends PacketTranslator<ItemStackRequestPacket> {\n\n    @Override\n    public void translate(ItemStackRequestPacket packet, GeyserSession session) {\n        Inventory inventory = session.getOpenInventory();\n        if (inventory == null)\n            return;\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        translator.translateRequests(session, inventory, packet.getRequests());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientClickWindowButtonPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.nukkitx.protocol.bedrock.packet.LecternUpdatePacket;\nimport org.geysermc.connector.inventory.LecternContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n/**\n * Used to translate moving pages, or closing the inventory\n */\n@Translator(packet = LecternUpdatePacket.class)\npublic class BedrockLecternUpdateTranslator extends PacketTranslator<LecternUpdatePacket> {\n\n    @Override\n    public void translate(LecternUpdatePacket packet, GeyserSession session) {\n        if (packet.isDroppingBook()) {\n            // Bedrock drops the book outside of the GUI. Java drops it in the GUI\n            // So, we enter the GUI and then drop it! :)\n            session.setDroppingLecternBook(true);\n\n            // Emulate an interact packet\n            ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(\n                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                    BlockFace.DOWN,\n                    Hand.MAIN_HAND,\n                    0, 0, 0, // Java doesn't care about these when dealing with a lectern\n                    false);\n            session.sendDownstreamPacket(blockPacket);\n        } else {\n            // Bedrock wants to either move a page or exit\n            if (!(session.getOpenInventory() instanceof LecternContainer)) {\n                session.getConnector().getLogger().debug(\"Expected lectern but it wasn't open!\");\n                return;\n            }\n\n            LecternContainer lecternContainer = (LecternContainer) session.getOpenInventory();\n            if (lecternContainer.getCurrentBedrockPage() == packet.getPage()) {\n                // The same page means Bedrock is closing the window\n                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(lecternContainer.getId());\n                session.sendDownstreamPacket(closeWindowPacket);\n                InventoryUtils.closeInventory(session, lecternContainer.getId(), false);\n            } else {\n                // Each \"page\" Bedrock gives to us actually represents two pages (think opening a book and seeing two pages)\n                // Each \"page\" on Java is just one page (think a spiral notebook folded back to only show one page)\n                int newJavaPage = (packet.getPage() * 2);\n                int currentJavaPage = (lecternContainer.getCurrentBedrockPage() * 2);\n\n                // Send as many click button packets as we need to\n                // Java has the option to specify exact page numbers by adding 100 to the number, but buttonId variable\n                // is a byte when transmitted over the network and therefore this stops us at 128\n                if (newJavaPage > currentJavaPage) {\n                    for (int i = currentJavaPage; i < newJavaPage; i++) {\n                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 2);\n                        session.sendDownstreamPacket(clickButtonPacket);\n                    }\n                } else {\n                    for (int i = currentJavaPage; i > newJavaPage; i--) {\n                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 1);\n                        session.sendDownstreamPacket(clickButtonPacket);\n                    }\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.MapInfoRequestPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = MapInfoRequestPacket.class)\npublic class BedrockMapInfoRequestTranslator extends PacketTranslator<MapInfoRequestPacket> {\n\n    @Override\n    public void translate(MapInfoRequestPacket packet, GeyserSession session) {\n        long mapId = packet.getUniqueMapId();\n\n        ClientboundMapItemDataPacket mapPacket = session.getStoredMaps().remove(mapId);\n        if (mapPacket != null) {\n            // Delay the packet 100ms to prevent the client from ignoring the packet\n            GeyserConnector.getInstance().getGeneralThreadPool().schedule(() -> session.sendUpstreamPacket(mapPacket),\n                    100, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerChangeHeldItemPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerId;\nimport com.nukkitx.protocol.bedrock.packet.MobEquipmentPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.CooldownUtils;\nimport org.geysermc.connector.utils.InteractiveTagManager;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = MobEquipmentPacket.class)\npublic class BedrockMobEquipmentTranslator extends PacketTranslator<MobEquipmentPacket> {\n\n    @Override\n    public void translate(MobEquipmentPacket packet, GeyserSession session) {\n        if (!session.isSpawned() || packet.getHotbarSlot() > 8 ||\n                packet.getContainerId() != ContainerId.INVENTORY || session.getPlayerInventory().getHeldItemSlot() == packet.getHotbarSlot()) {\n            // For the last condition - Don't update the slot if the slot is the same - not Java Edition behavior and messes with plugins such as Grief Prevention\n            return;\n        }\n\n        // Send book update before switching hotbar slot\n        session.getBookEditCache().checkForSend();\n\n        session.getPlayerInventory().setHeldItemSlot(packet.getHotbarSlot());\n\n        ClientPlayerChangeHeldItemPacket changeHeldItemPacket = new ClientPlayerChangeHeldItemPacket(packet.getHotbarSlot());\n        session.sendDownstreamPacket(changeHeldItemPacket);\n\n        if (session.isSneaking() && session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {\n            // Activate shield since we are already sneaking\n            // (No need to send a release item packet - Java doesn't do this when swapping items)\n            // Required to do it a tick later or else it doesn't register\n            session.getConnector().getGeneralThreadPool().schedule(() -> session.sendDownstreamPacket(new ClientPlayerUseItemPacket(Hand.MAIN_HAND)),\n                    50, TimeUnit.MILLISECONDS);\n        }\n\n        // Java sends a cooldown indicator whenever you switch an item\n        CooldownUtils.sendCooldown(session);\n\n        // Update the interactive tag, if an entity is present\n        if (session.getMouseoverEntity() != null) {\n            InteractiveTagManager.updateTag(session, session.getMouseoverEntity());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;\nimport com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;\nimport org.geysermc.connector.entity.BoatEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Sent by the client when moving a horse.\n */\n@Translator(packet = MoveEntityAbsolutePacket.class)\npublic class BedrockMoveEntityAbsoluteTranslator extends PacketTranslator<MoveEntityAbsolutePacket> {\n\n    @Override\n    public void translate(MoveEntityAbsolutePacket packet, GeyserSession session) {\n        session.setLastVehicleMoveTimestamp(System.currentTimeMillis());\n\n        float y = packet.getPosition().getY();\n        if (session.getRidingVehicleEntity() instanceof BoatEntity) {\n            // Remove the offset to prevents boats from looking like they're floating in water\n            y -= EntityType.BOAT.getOffset();\n        }\n        ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(\n                packet.getPosition().getX(), y, packet.getPosition().getZ(),\n                packet.getRotation().getY() - 90, packet.getRotation().getX()\n        );\n        session.sendDownstreamPacket(clientVehicleMovePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientKeepAlivePacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.floodgate.util.DeviceOs;\n\nimport java.util.Collections;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Used to send the forwarded keep alive packet back to the server\n */\n@Translator(packet = NetworkStackLatencyPacket.class)\npublic class BedrockNetworkStackLatencyTranslator extends PacketTranslator<NetworkStackLatencyPacket> {\n\n    @Override\n    public void translate(NetworkStackLatencyPacket packet, GeyserSession session) {\n        long pingId;\n        // so apparently, as of 1.16.200\n        // PS4 divides the network stack latency timestamp FOR US!!!\n        // WTF\n        if (session.getClientData().getDeviceOs().equals(DeviceOs.PS4)) {\n            pingId = packet.getTimestamp();\n        } else {\n            pingId = packet.getTimestamp() / 1000;\n        }\n\n        // negative timestamps are used as hack to fix the url image loading bug\n        if (packet.getTimestamp() > 0) {\n            if (session.getConnector().getConfig().isForwardPlayerPing()) {\n                ClientKeepAlivePacket keepAlivePacket = new ClientKeepAlivePacket(pingId);\n                session.sendDownstreamPacket(keepAlivePacket);\n            }\n            return;\n        }\n\n        // Hack to fix the url image loading bug\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n\n        AttributeData attribute = session.getPlayerEntity().getAttributes().get(GeyserAttributeType.EXPERIENCE_LEVEL);\n        if (attribute != null) {\n            attributesPacket.setAttributes(Collections.singletonList(attribute));\n        } else {\n            attributesPacket.setAttributes(Collections.singletonList(GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(0)));\n        }\n\n        session.getConnector().getGeneralThreadPool().schedule(\n                () -> session.sendUpstreamPacket(attributesPacket),\n                500, TimeUnit.MILLISECONDS);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.PacketViolationWarningPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = PacketViolationWarningPacket.class)\npublic class BedrockPacketViolationWarningTranslator extends PacketTranslator<PacketViolationWarningPacket> {\n\n    @Override\n    public void translate(PacketViolationWarningPacket packet, GeyserSession session) {\n        // Not translated since this is something that the developers need to know\n        session.getConnector().getLogger().error(\"Packet violation warning sent from client! \" + packet.toString());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerVehiclePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.PlayerInputPacket;\nimport org.geysermc.connector.entity.BoatEntity;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.entity.living.animal.horse.LlamaEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Sent by the client for minecarts and boats.\n */\n@Translator(packet = PlayerInputPacket.class)\npublic class BedrockPlayerInputTranslator extends PacketTranslator<PlayerInputPacket> {\n\n    @Override\n    public void translate(PlayerInputPacket packet, GeyserSession session) {\n        ClientSteerVehiclePacket clientSteerVehiclePacket = new ClientSteerVehiclePacket(\n                packet.getInputMotion().getX(), packet.getInputMotion().getY(), packet.isJumping(), packet.isSneaking()\n        );\n\n        session.sendDownstreamPacket(clientSteerVehiclePacket);\n\n        // Bedrock only sends movement vehicle packets while moving\n        // This allows horses to take damage while standing on magma\n        Entity vehicle = session.getRidingVehicleEntity();\n        boolean sendMovement = false;\n        if (vehicle instanceof AbstractHorseEntity && !(vehicle instanceof LlamaEntity)) {\n            sendMovement = vehicle.isOnGround();\n        } else if (vehicle instanceof BoatEntity) {\n            if (vehicle.getPassengers().size() == 1) {\n                // The player is the only rider\n                sendMovement = true;\n            } else {\n                // Check if the player is the front rider\n                Vector3f seatPos = session.getPlayerEntity().getMetadata().getVector3f(EntityData.RIDER_SEAT_POSITION, null);\n                if (seatPos != null && seatPos.getX() > 0) {\n                    sendMovement = true;\n                }\n            }\n        }\n        if (sendMovement) {\n            long timeSinceVehicleMove = System.currentTimeMillis() - session.getLastVehicleMoveTimestamp();\n            if (timeSinceVehicleMove >= 100) {\n                Vector3f vehiclePosition = vehicle.getPosition();\n                Vector3f vehicleRotation = vehicle.getRotation();\n\n                if (vehicle instanceof BoatEntity) {\n                    // Remove some Y position to prevents boats flying up\n                    vehiclePosition = vehiclePosition.down(EntityType.BOAT.getOffset());\n                }\n\n                ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(\n                        vehiclePosition.getX(), vehiclePosition.getY(), vehiclePosition.getZ(),\n                        vehicleRotation.getX() - 90, vehicleRotation.getY()\n                );\n                session.sendDownstreamPacket(clientVehicleMovePacket);\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.packet.PositionTrackingDBClientRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.PositionTrackingDBServerBroadcastPacket;\nimport it.unimi.dsi.fastutil.ints.IntArrayList;\nimport it.unimi.dsi.fastutil.ints.IntList;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.LoadstoneTracker;\n\n@Translator(packet = PositionTrackingDBClientRequestPacket.class)\npublic class BedrockPositionTrackingDBClientRequestTranslator extends PacketTranslator<PositionTrackingDBClientRequestPacket> {\n\n    @Override\n    public void translate(PositionTrackingDBClientRequestPacket packet, GeyserSession session) {\n        PositionTrackingDBServerBroadcastPacket broadcastPacket = new PositionTrackingDBServerBroadcastPacket();\n        broadcastPacket.setTrackingId(packet.getTrackingId());\n\n        // Fetch the stored Loadstone\n        LoadstoneTracker.LoadstonePos pos = LoadstoneTracker.getPos(packet.getTrackingId());\n\n        // If we don't have data for that ID tell the client its not found\n        if (pos == null) {\n            broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.NOT_FOUND);\n            session.sendUpstreamPacket(broadcastPacket);\n            return;\n        }\n\n        broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.UPDATE);\n\n        // Build the nbt data for the update\n        NbtMapBuilder builder = NbtMap.builder();\n        builder.putInt(\"dim\", DimensionUtils.javaToBedrock(pos.getDimension()));\n        builder.putString(\"id\", String.format(\"%08X\", packet.getTrackingId()));\n\n        builder.putByte(\"version\", (byte) 1); // Not sure what this is for\n        builder.putByte(\"status\", (byte) 0); // Not sure what this is for\n\n        // Build the position for the update\n        IntList posList = new IntArrayList();\n        posList.add(pos.getX());\n        posList.add(pos.getY());\n        posList.add(pos.getZ());\n        builder.putList(\"pos\", NbtType.INT, posList);\n        broadcastPacket.setTag(builder.build());\n\n        session.sendUpstreamPacket(broadcastPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport com.nukkitx.protocol.bedrock.packet.RespawnPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = RespawnPacket.class)\npublic class BedrockRespawnTranslator extends PacketTranslator<RespawnPacket> {\n\n    @Override\n    public void translate(RespawnPacket packet, GeyserSession session) {\n        if (packet.getState() == RespawnPacket.State.CLIENT_READY) {\n            // Previously we only sent the respawn packet before the server finished loading\n            // The message included was 'Otherwise when immediate respawn is on the client never loads'\n            // But I assume the new if statement below fixes that problem\n            RespawnPacket respawnPacket = new RespawnPacket();\n            respawnPacket.setRuntimeEntityId(0);\n            respawnPacket.setPosition(Vector3f.ZERO);\n            respawnPacket.setState(RespawnPacket.State.SERVER_READY);\n            session.sendUpstreamPacket(respawnPacket);\n\n            if (session.isSpawned()) {\n                // Client might be stuck; resend spawn information\n                PlayerEntity entity = session.getPlayerEntity();\n                if (entity == null) return;\n                SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n                entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n                entityDataPacket.getMetadata().putAll(entity.getMetadata());\n                session.sendUpstreamPacket(entityDataPacket);\n\n                MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                movePlayerPacket.setPosition(entity.getPosition());\n                movePlayerPacket.setRotation(entity.getBedrockRotation());\n                movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);\n                session.sendUpstreamPacket(movePlayerPacket);\n            }\n\n            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n            session.sendDownstreamPacket(javaRespawnPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ServerSettingsRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.ServerSettingsResponsePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.SettingsUtils;\nimport org.geysermc.cumulus.CustomForm;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerSettingsRequestPacket.class)\npublic class BedrockServerSettingsRequestTranslator extends PacketTranslator<ServerSettingsRequestPacket> {\n    @Override\n    public void translate(ServerSettingsRequestPacket packet, GeyserSession session) {\n        CustomForm window = SettingsUtils.buildForm(session);\n        int windowId = session.getFormCache().addForm(window);\n\n        // Fixes https://bugs.mojang.com/browse/MCPE-94012 because of the delay\n        session.getConnector().getGeneralThreadPool().schedule(() -> {\n            ServerSettingsResponsePacket serverSettingsResponsePacket = new ServerSettingsResponsePacket();\n            serverSettingsResponsePacket.setFormData(window.getJsonData());\n            serverSettingsResponsePacket.setFormId(windowId);\n            session.sendUpstreamPacket(serverSettingsResponsePacket);\n        }, 1, TimeUnit.SECONDS);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.SetLocalPlayerAsInitializedPacket;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\nimport org.geysermc.connector.skin.SkullSkinManager;\n\n@Translator(packet = SetLocalPlayerAsInitializedPacket.class)\npublic class BedrockSetLocalPlayerAsInitializedTranslator extends PacketTranslator<SetLocalPlayerAsInitializedPacket> {\n    @Override\n    public void translate(SetLocalPlayerAsInitializedPacket packet, GeyserSession session) {\n        if (session.getPlayerEntity().getGeyserId() == packet.getRuntimeEntityId()) {\n            if (!session.getUpstream().isInitialized()) {\n                session.getUpstream().setInitialized(true);\n                session.login();\n\n                for (PlayerEntity entity : session.getEntityCache().getEntitiesByType(PlayerEntity.class)) {\n                    if (!entity.isValid()) {\n                        SkinManager.requestAndHandleSkinAndCape(entity, session, null);\n                        entity.sendPlayer(session);\n                    }\n                }\n\n                // Send Skulls\n                for (PlayerEntity entity : session.getSkullCache().values()) {\n                    entity.spawnEntity(session);\n\n                    SkullSkinManager.requestAndHandleSkin(entity, session, (skin) ->  {\n                        entity.getMetadata().getFlags().setFlag(EntityFlag.INVISIBLE, false);\n                        entity.updateBedrockMetadata(session);\n                    });\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.ShowCreditsPacket;\n\n@Translator(packet = ShowCreditsPacket.class)\npublic class BedrockShowCreditsTranslator extends PacketTranslator<ShowCreditsPacket> {\n\n    @Override\n    public void translate(ShowCreditsPacket packet, GeyserSession session) {\n        if (packet.getStatus() == ShowCreditsPacket.Status.END_CREDITS) {\n            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n            session.sendDownstreamPacket(javaRespawnPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = TextPacket.class)\npublic class BedrockTextTranslator extends PacketTranslator<TextPacket> {\n\n    @Override\n    public void translate(TextPacket packet, GeyserSession session) {\n        String message = packet.getMessage();\n\n        if (MessageTranslator.isTooLong(message, session)) {\n            return;\n        }\n\n        ClientChatPacket chatPacket = new ClientChatPacket(message);\n        session.sendDownstreamPacket(chatPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity;\n\nimport com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientSelectTradePacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.EntityEventPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = EntityEventPacket.class)\npublic class BedrockEntityEventTranslator extends PacketTranslator<EntityEventPacket> {\n\n    @Override\n    public void translate(EntityEventPacket packet, GeyserSession session) {\n        switch (packet.getType()) {\n            case EATING_ITEM:\n                // Resend the packet so we get the eating sounds\n                session.sendUpstreamPacket(packet);\n                return;\n            case COMPLETE_TRADE:\n                ClientSelectTradePacket selectTradePacket = new ClientSelectTradePacket(packet.getData());\n                session.sendDownstreamPacket(selectTradePacket);\n\n                session.scheduleInEventLoop(() -> {\n                    Entity villager = session.getPlayerEntity();\n                    Inventory openInventory = session.getOpenInventory();\n                    if (openInventory instanceof MerchantContainer) {\n                        MerchantContainer merchantInventory = (MerchantContainer) openInventory;\n                        VillagerTrade[] trades = merchantInventory.getVillagerTrades();\n                        if (trades != null && packet.getData() >= 0 && packet.getData() < trades.length) {\n                            VillagerTrade trade = merchantInventory.getVillagerTrades()[packet.getData()];\n                            openInventory.setItem(2, GeyserItemStack.from(trade.getOutput()), session);\n                            villager.getMetadata().put(EntityData.TRADE_XP, trade.getXp() + villager.getMetadata().getInt(EntityData.TRADE_XP));\n                            villager.updateBedrockMetadata(session);\n                        }\n                    }\n                }, 100, TimeUnit.MILLISECONDS);\n                return;\n        }\n        session.getConnector().getLogger().debug(\"Did not translate incoming EntityEventPacket: \" + packet.toString());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.*;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.*;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.PlayerActionType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.inventory.PlayerInventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.BlockUtils;\n\nimport java.util.ArrayList;\n\n@Translator(packet = PlayerActionPacket.class)\npublic class BedrockActionTranslator extends PacketTranslator<PlayerActionPacket> {\n\n    @Override\n    public void translate(PlayerActionPacket packet, GeyserSession session) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        // Send book update before any player action\n        if (packet.getAction() != PlayerActionType.RESPAWN) {\n            session.getBookEditCache().checkForSend();\n        }\n\n        Vector3i vector = packet.getBlockPosition();\n        Position position = new Position(vector.getX(), vector.getY(), vector.getZ());\n\n        switch (packet.getAction()) {\n            case RESPAWN:\n                // Respawn process is finished and the server and client are both OK with respawning.\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setRuntimeEntityId(entity.getGeyserId());\n                eventPacket.setType(EntityEventType.RESPAWN);\n                eventPacket.setData(0);\n                session.sendUpstreamPacket(eventPacket);\n                // Resend attributes or else in rare cases the user can think they're not dead when they are, upon joining the server\n                UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n                attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));\n                session.sendUpstreamPacket(attributesPacket);\n                break;\n            case START_SWIMMING:\n                ClientPlayerStatePacket startSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);\n                session.sendDownstreamPacket(startSwimPacket);\n\n                session.setSwimming(true);\n                break;\n            case STOP_SWIMMING:\n                ClientPlayerStatePacket stopSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);\n                session.sendDownstreamPacket(stopSwimPacket);\n\n                session.setSwimming(false);\n                break;\n            case START_GLIDE:\n                // Otherwise gliding will not work in creative\n                ClientPlayerAbilitiesPacket playerAbilitiesPacket = new ClientPlayerAbilitiesPacket(false);\n                session.sendDownstreamPacket(playerAbilitiesPacket);\n            case STOP_GLIDE:\n                ClientPlayerStatePacket glidePacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_ELYTRA_FLYING);\n                session.sendDownstreamPacket(glidePacket);\n                break;\n            case START_SNEAK:\n                ClientPlayerStatePacket startSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);\n                session.sendDownstreamPacket(startSneakPacket);\n\n                // Toggle the shield, if relevant\n                PlayerInventory playerInv = session.getPlayerInventory();\n                ItemMapping shield = session.getItemMappings().getMapping(\"minecraft:shield\");\n                if ((playerInv.getItemInHand().getJavaId() == shield.getJavaId()) ||\n                        (playerInv.getOffhand().getJavaId() == shield.getJavaId())) {\n                    ClientPlayerUseItemPacket useItemPacket;\n                    if (playerInv.getItemInHand().getJavaId() == shield.getJavaId()) {\n                        useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                    } else {\n                        // Else we just assume it's the offhand, to simplify logic and to assure the packet gets sent\n                        useItemPacket = new ClientPlayerUseItemPacket(Hand.OFF_HAND);\n                    }\n                    session.sendDownstreamPacket(useItemPacket);\n                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, true);\n                    // metadata will be updated when sneaking\n                }\n\n                session.setSneaking(true);\n                break;\n            case STOP_SNEAK:\n                ClientPlayerStatePacket stopSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SNEAKING);\n                session.sendDownstreamPacket(stopSneakPacket);\n\n                // Stop shield, if necessary\n                if (session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.BLOCKING)) {\n                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO, BlockFace.DOWN);\n                    session.sendDownstreamPacket(releaseItemPacket);\n                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, false);\n                    // metadata will be updated when sneaking\n                }\n\n                session.setSneaking(false);\n                break;\n            case START_SPRINT:\n                ClientPlayerStatePacket startSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);\n                session.sendDownstreamPacket(startSprintPacket);\n                session.setSprinting(true);\n                break;\n            case STOP_SPRINT:\n                ClientPlayerStatePacket stopSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);\n                session.sendDownstreamPacket(stopSprintPacket);\n                session.setSprinting(false);\n                break;\n            case DROP_ITEM:\n                ClientPlayerActionPacket dropItemPacket = new ClientPlayerActionPacket(PlayerAction.DROP_ITEM, position, BlockFace.values()[packet.getFace()]);\n                session.sendDownstreamPacket(dropItemPacket);\n                break;\n            case STOP_SLEEP:\n                ClientPlayerStatePacket stopSleepingPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.LEAVE_BED);\n                session.sendDownstreamPacket(stopSleepingPacket);\n                break;\n            case BLOCK_INTERACT:\n                // Client means to interact with a block; cancel bucket interaction, if any\n                if (session.getBucketScheduledFuture() != null) {\n                    session.getBucketScheduledFuture().cancel(true);\n                    session.setBucketScheduledFuture(null);\n                }\n                // Otherwise handled in BedrockInventoryTransactionTranslator\n                break;\n            case START_BREAK:\n                // Start the block breaking animation\n                if (session.getGameMode() != GameMode.CREATIVE) {\n                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, vector);\n                    LevelEventPacket startBreak = new LevelEventPacket();\n                    startBreak.setType(LevelEventType.BLOCK_START_BREAK);\n                    startBreak.setPosition(vector.toFloat());\n                    double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(blockState)) * 20;\n                    startBreak.setData((int) (65535 / breakTime));\n                    session.setBreakingBlock(blockState);\n                    session.sendUpstreamPacket(startBreak);\n                }\n\n                // Account for fire - the client likes to hit the block behind.\n                Vector3i fireBlockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getFace());\n                int blockUp = session.getConnector().getWorldManager().getBlockAt(session, fireBlockPos);\n                String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(blockUp);\n                if (identifier.startsWith(\"minecraft:fire\") || identifier.startsWith(\"minecraft:soul_fire\")) {\n                    ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, new Position(fireBlockPos.getX(),\n                            fireBlockPos.getY(), fireBlockPos.getZ()), BlockFace.values()[packet.getFace()]);\n                    session.sendDownstreamPacket(startBreakingPacket);\n                    if (session.getGameMode() == GameMode.CREATIVE) {\n                        break;\n                    }\n                }\n\n                ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, position, BlockFace.values()[packet.getFace()]);\n                session.sendDownstreamPacket(startBreakingPacket);\n                break;\n            case CONTINUE_BREAK:\n                if (session.getGameMode() == GameMode.CREATIVE) {\n                    break;\n                }\n                Vector3f vectorFloat = vector.toFloat();\n                LevelEventPacket continueBreakPacket = new LevelEventPacket();\n                continueBreakPacket.setType(LevelEventType.PARTICLE_CRACK_BLOCK);\n                continueBreakPacket.setData((session.getBlockMappings().getBedrockBlockId(session.getBreakingBlock())) | (packet.getFace() << 24));\n                continueBreakPacket.setPosition(vectorFloat);\n                session.sendUpstreamPacket(continueBreakPacket);\n\n                // Update the break time in the event that player conditions changed (jumping, effects applied)\n                LevelEventPacket updateBreak = new LevelEventPacket();\n                updateBreak.setType(LevelEventType.BLOCK_UPDATE_BREAK);\n                updateBreak.setPosition(vectorFloat);\n                double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(session.getBreakingBlock())) * 20;\n                updateBreak.setData((int) (65535 / breakTime));\n                session.sendUpstreamPacket(updateBreak);\n                break;\n            case ABORT_BREAK:\n                if (session.getGameMode() != GameMode.CREATIVE) {\n                    // As of 1.16.210: item frame items are taken out here.\n                    // Survival also sends START_BREAK, but by attaching our process here adventure mode also works\n                    Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                    if (itemFrameEntity != null) {\n                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),\n                                InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n                        session.sendDownstreamPacket(interactPacket);\n                        break;\n                    }\n                }\n\n                ClientPlayerActionPacket abortBreakingPacket = new ClientPlayerActionPacket(PlayerAction.CANCEL_DIGGING, position, BlockFace.DOWN);\n                session.sendDownstreamPacket(abortBreakingPacket);\n                LevelEventPacket stopBreak = new LevelEventPacket();\n                stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);\n                stopBreak.setPosition(vector.toFloat());\n                stopBreak.setData(0);\n                session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n                session.sendUpstreamPacket(stopBreak);\n                break;\n            case STOP_BREAK:\n                // Handled in BedrockInventoryTransactionTranslator\n                break;\n            case DIMENSION_CHANGE_SUCCESS:\n                //sometimes the client doesn't feel like loading\n                PlayStatusPacket spawnPacket = new PlayStatusPacket();\n                spawnPacket.setStatus(PlayStatusPacket.Status.PLAYER_SPAWN);\n                session.sendUpstreamPacket(spawnPacket);\n\n                attributesPacket = new UpdateAttributesPacket();\n                attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));\n                session.sendUpstreamPacket(attributesPacket);\n\n                session.getEntityCache().updateBossBars();\n                break;\n            case JUMP:\n                entity.setOnGround(false); // Increase block break time while jumping\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;\nimport com.nukkitx.protocol.bedrock.packet.EmotePacket;\nimport org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.BlockUtils;\n\n@Translator(packet = EmotePacket.class)\npublic class BedrockEmoteTranslator extends PacketTranslator<EmotePacket> {\n\n    @Override\n    public void translate(EmotePacket packet, GeyserSession session) {\n        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() != EmoteOffhandWorkaroundOption.DISABLED) {\n            // Activate the workaround - we should trigger the offhand now\n            ClientPlayerActionPacket swapHandsPacket = new ClientPlayerActionPacket(PlayerAction.SWAP_HANDS, BlockUtils.POSITION_ZERO,\n                    BlockFace.DOWN);\n            session.sendDownstreamPacket(swapHandsPacket);\n\n            if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {\n                return;\n            }\n        }\n\n        long javaId = session.getPlayerEntity().getEntityId();\n        for (GeyserSession otherSession : session.getConnector().getPlayers()) {\n            if (otherSession != session) {\n                if (otherSession.isClosed()) continue;\n                if (otherSession.getEventLoop().inEventLoop()) {\n                    playEmote(otherSession, javaId, packet.getEmoteId());\n                } else {\n                    session.executeInEventLoop(() -> playEmote(otherSession, javaId, packet.getEmoteId()));\n                }\n            }\n        }\n    }\n\n    private void playEmote(GeyserSession otherSession, long javaId, String emoteId) {\n        Entity otherEntity = otherSession.getEntityCache().getEntityByJavaId(javaId); // Must be ran on same thread\n        if (otherEntity == null) return;\n        EmotePacket otherEmotePacket = new EmotePacket();\n        otherEmotePacket.setEmoteId(emoteId);\n        otherEmotePacket.setRuntimeEntityId(otherEntity.getGeyserId());\n        otherSession.sendUpstreamPacket(otherEmotePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;\nimport com.nukkitx.protocol.bedrock.packet.InteractPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InteractiveTagManager;\n\n@Translator(packet = InteractPacket.class)\npublic class BedrockInteractTranslator extends PacketTranslator<InteractPacket> {\n\n    @Override\n    public void translate(InteractPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getRuntimeEntityId() == session.getPlayerEntity().getGeyserId()) {\n            //Player is not in entity cache\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n        }\n        if (entity == null)\n            return;\n\n        switch (packet.getAction()) {\n            case INTERACT:\n                if (session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {\n                    break;\n                }\n                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                session.sendDownstreamPacket(interactPacket);\n                break;\n            case DAMAGE:\n                ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                        InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n                session.sendDownstreamPacket(attackPacket);\n                break;\n            case LEAVE_VEHICLE:\n                ClientPlayerStatePacket sneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);\n                session.sendDownstreamPacket(sneakPacket);\n                session.setRidingVehicleEntity(null);\n                break;\n            case MOUSEOVER:\n                // Handle the buttons for mobile - \"Mount\", etc; and the suggestions for console - \"ZL: Mount\", etc\n                if (packet.getRuntimeEntityId() != 0) {\n                    Entity interactEntity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n                    session.setMouseoverEntity(interactEntity);\n                    if (interactEntity == null) {\n                        return;\n                    }\n\n                    InteractiveTagManager.updateTag(session, interactEntity);\n                } else {\n                    if (session.getMouseoverEntity() != null) {\n                        // No interactive tag should be sent\n                        session.setMouseoverEntity(null);\n                        session.getPlayerEntity().getMetadata().put(EntityData.INTERACTIVE_TAG, \"\");\n                        session.getPlayerEntity().updateBedrockMetadata(session);\n                    }\n                }\n                break;\n            case OPEN_INVENTORY:\n                if (session.getOpenInventory() == null) {\n                    Entity ridingEntity = session.getRidingVehicleEntity();\n                    if (ridingEntity instanceof AbstractHorseEntity) {\n                        if (ridingEntity.getMetadata().getFlags().getFlag(EntityFlag.TAMED)) {\n                            // We should request to open the horse inventory instead\n                            ClientPlayerStatePacket openHorseWindowPacket = new ClientPlayerStatePacket((int) session.getPlayerEntity().getEntityId(), PlayerState.OPEN_HORSE_INVENTORY);\n                            session.sendDownstreamPacket(openHorseWindowPacket);\n                        }\n                    } else {\n                        session.setOpenInventory(session.getPlayerInventory());\n\n                        ContainerOpenPacket containerOpenPacket = new ContainerOpenPacket();\n                        containerOpenPacket.setId((byte) 0);\n                        containerOpenPacket.setType(ContainerType.INVENTORY);\n                        containerOpenPacket.setUniqueEntityId(-1);\n                        containerOpenPacket.setBlockPosition(entity.getPosition().toInt());\n                        session.sendUpstreamPacket(containerOpenPacket);\n                    }\n                }\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionRotationPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerRotationPacket;\nimport com.github.steveice10.packetlib.packet.Packet;\nimport com.nukkitx.math.vector.Vector3d;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.common.ChatColor;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = MovePlayerPacket.class)\npublic class BedrockMovePlayerTranslator extends PacketTranslator<MovePlayerPacket> {\n    /* The upper and lower bounds to check for the void floor that only exists in Bedrock */\n    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y;\n    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y;\n\n    static {\n        BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight() ? -104 : -40;\n        BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y = BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y + 2;\n    }\n\n    @Override\n    public void translate(MovePlayerPacket packet, GeyserSession session) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n        if (!session.isSpawned()) return;\n\n        if (!session.getUpstream().isInitialized()) {\n            MoveEntityAbsolutePacket moveEntityBack = new MoveEntityAbsolutePacket();\n            moveEntityBack.setRuntimeEntityId(entity.getGeyserId());\n            moveEntityBack.setPosition(entity.getPosition());\n            moveEntityBack.setRotation(entity.getBedrockRotation());\n            moveEntityBack.setTeleported(true);\n            moveEntityBack.setOnGround(true);\n            session.sendUpstreamPacketImmediately(moveEntityBack);\n            return;\n        }\n\n        session.setLastMovementTimestamp(System.currentTimeMillis());\n\n        // Send book update before the player moves\n        session.getBookEditCache().checkForSend();\n\n        session.confirmTeleport(packet.getPosition().toDouble().sub(0, EntityType.PLAYER.getOffset(), 0));\n        // head yaw, pitch, head yaw\n        Vector3f rotation = Vector3f.from(packet.getRotation().getY(), packet.getRotation().getX(), packet.getRotation().getY());\n\n        boolean positionChanged = !entity.getPosition().equals(packet.getPosition());\n        boolean rotationChanged = !entity.getRotation().equals(rotation);\n\n        // If only the pitch and yaw changed\n        // This isn't needed, but it makes the packets closer to vanilla\n        // It also means you can't \"lag back\" while only looking, in theory\n        if (!positionChanged && rotationChanged) {\n            ClientPlayerRotationPacket playerRotationPacket = new ClientPlayerRotationPacket(\n                    packet.isOnGround(), packet.getRotation().getY(), packet.getRotation().getX());\n\n            entity.setRotation(rotation);\n            entity.setOnGround(packet.isOnGround());\n\n            session.sendDownstreamPacket(playerRotationPacket);\n        } else {\n            Vector3d position = session.getCollisionManager().adjustBedrockPosition(packet.getPosition(), packet.isOnGround());\n            if (position != null) { // A null return value cancels the packet\n                if (isValidMove(session, packet.getMode(), entity.getPosition(), packet.getPosition())) {\n                    Packet movePacket;\n                    if (rotationChanged) {\n                        // Send rotation updates as well\n                        movePacket = new ClientPlayerPositionRotationPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ(),\n                                packet.getRotation().getY(), packet.getRotation().getX());\n                        entity.setRotation(rotation);\n                    } else {\n                        // Rotation did not change; don't send an update with rotation\n                        movePacket = new ClientPlayerPositionPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ());\n                    }\n\n                    // Compare positions here for void floor fix below before the player's position variable is set to the packet position\n                    boolean notMovingUp = entity.getPosition().getY() >= packet.getPosition().getY();\n\n                    entity.setPositionManual(packet.getPosition());\n                    entity.setOnGround(packet.isOnGround());\n\n                    // Send final movement changes\n                    session.sendDownstreamPacket(movePacket);\n\n                    if (notMovingUp) {\n                        int floorY = position.getFloorY();\n                        // If the client believes the world has extended height, then it also believes the void floor\n                        // still exists, just at a lower spot\n                        boolean extendedWorld = session.getChunkCache().isExtendedHeight();\n                        if (floorY <= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y : -38)\n                                && floorY >= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y : -40)) {\n                            // Work around there being a floor at the bottom of the world and teleport the player below it\n                            // Moving from below to above the void floor works fine\n                            entity.setPosition(entity.getPosition().sub(0, 4f, 0));\n                            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                            movePlayerPacket.setPosition(entity.getPosition());\n                            movePlayerPacket.setRotation(entity.getBedrockRotation());\n                            movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                            movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.BEHAVIOR);\n                            session.sendUpstreamPacket(movePlayerPacket);\n                        }\n                    }\n                } else {\n                    // Not a valid move\n                    session.getConnector().getLogger().debug(\"Recalculating position...\");\n                    session.getCollisionManager().recalculatePosition();\n                }\n            }\n        }\n\n        // Move parrots to match if applicable\n        if (entity.getLeftParrot() != null) {\n            entity.getLeftParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);\n        }\n        if (entity.getRightParrot() != null) {\n            entity.getRightParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);\n        }\n    }\n\n    private boolean isValidMove(GeyserSession session, MovePlayerPacket.Mode mode, Vector3f currentPosition, Vector3f newPosition) {\n        if (mode != MovePlayerPacket.Mode.NORMAL)\n            return true;\n\n        double xRange = newPosition.getX() - currentPosition.getX();\n        double yRange = newPosition.getY() - currentPosition.getY();\n        double zRange = newPosition.getZ() - currentPosition.getZ();\n\n        if (xRange < 0)\n            xRange = -xRange;\n        if (yRange < 0)\n            yRange = -yRange;\n        if (zRange < 0)\n            zRange = -zRange;\n\n        if ((xRange + yRange + zRange) > 100) {\n            session.getConnector().getLogger().debug(ChatColor.RED + session.getName() + \" moved too quickly.\" +\n                    \" current position: \" + currentPosition + \", new position: \" + newPosition);\n\n            return false;\n        }\n\n        return true;\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;\nimport com.nukkitx.protocol.bedrock.packet.RiderJumpPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = RiderJumpPacket.class)\npublic class BedrockRiderJumpTranslator extends PacketTranslator<RiderJumpPacket> {\n    @Override\n    public void translate(RiderJumpPacket packet, GeyserSession session) {\n        Entity vehicle = session.getRidingVehicleEntity();\n        if (vehicle instanceof AbstractHorseEntity) {\n            ClientPlayerStatePacket playerStatePacket = new ClientPlayerStatePacket((int) vehicle.getEntityId(),  PlayerState.START_HORSE_JUMP, packet.getJumpStrength());\n            session.sendDownstreamPacket(playerStatePacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * In vanilla Bedrock, if you have operator status, this sets the player's gamemode without confirmation from the server.\n * Since we have a custom server option to request the gamemode, we just reset the gamemode and ignore this.\n */\n@Translator(packet = SetPlayerGameTypePacket.class)\npublic class BedrockSetPlayerGameTypeTranslator extends PacketTranslator<SetPlayerGameTypePacket> {\n\n    @Override\n    public void translate(SetPlayerGameTypePacket packet, GeyserSession session) {\n        // no\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(session.getGameMode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.world;\n\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.CooldownUtils;\n\n@Translator(packet = LevelSoundEventPacket.class)\npublic class BedrockLevelSoundEventTranslator extends PacketTranslator<LevelSoundEventPacket> {\n\n    @Override\n    public void translate(LevelSoundEventPacket packet, GeyserSession session) {\n        // lol what even :thinking:\n        session.sendUpstreamPacket(packet);\n\n        // Yes, what even, but thankfully we can hijack this packet to send the cooldown\n        if (packet.getSound() == SoundEvent.ATTACK_NODAMAGE || packet.getSound() == SoundEvent.ATTACK || packet.getSound() == SoundEvent.ATTACK_STRONG) {\n            // Send a faux cooldown since Bedrock has no cooldown support\n            // Sent here because Java still sends a cooldown if the player doesn't hit anything but Bedrock always sends a sound\n            CooldownUtils.sendCooldown(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementTabPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.AdvancementsCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Indicates that the client should open a particular advancement tab\n */\n@Translator(packet = ServerAdvancementTabPacket.class)\npublic class JavaAdvancementsTabTranslator extends PacketTranslator<ServerAdvancementTabPacket> {\n    @Override\n    public void translate(ServerAdvancementTabPacket packet, GeyserSession session) {\n        AdvancementsCache advancementsCache = session.getAdvancementsCache();\n        advancementsCache.setCurrentAdvancementCategoryId(packet.getTabId());\n        advancementsCache.buildAndShowListForm();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.advancement.Advancement;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementsPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\nimport org.geysermc.connector.network.session.cache.AdvancementsCache;\nimport org.geysermc.connector.utils.GeyserAdvancement;\nimport org.geysermc.connector.utils.LocaleUtils;\n\nimport java.util.Map;\n\n@Translator(packet = ServerAdvancementsPacket.class)\npublic class JavaAdvancementsTranslator extends PacketTranslator<ServerAdvancementsPacket> {\n\n    @Override\n    public void translate(ServerAdvancementsPacket packet, GeyserSession session) {\n        AdvancementsCache advancementsCache = session.getAdvancementsCache();\n        if (packet.isReset()) {\n            advancementsCache.getStoredAdvancements().clear();\n            advancementsCache.getStoredAdvancementProgress().clear();\n        }\n\n        // Removes removed advancements from player's stored advancements\n        for (String removedAdvancement : packet.getRemovedAdvancements()) {\n            advancementsCache.getStoredAdvancements().remove(removedAdvancement);\n        }\n\n        advancementsCache.getStoredAdvancementProgress().putAll(packet.getProgress());\n\n        sendToolbarAdvancementUpdates(session, packet);\n\n        // Adds advancements to the player's stored advancements when advancements are sent\n        for (Advancement advancement : packet.getAdvancements()) {\n            if (advancement.getDisplayData() != null && !advancement.getDisplayData().isHidden()) {\n                GeyserAdvancement geyserAdvancement = GeyserAdvancement.from(advancement);\n                advancementsCache.getStoredAdvancements().put(advancement.getId(), geyserAdvancement);\n            } else {\n                advancementsCache.getStoredAdvancements().remove(advancement.getId());\n            }\n        }\n    }\n\n    /**\n     * Handle all advancements progress updates\n     */\n    public void sendToolbarAdvancementUpdates(GeyserSession session, ServerAdvancementsPacket packet) {\n        if (packet.isReset()) {\n            // Advancements are being cleared, so they can't be granted\n            return;\n        }\n        for (Map.Entry<String, Map<String, Long>> progress : packet.getProgress().entrySet()) {\n            GeyserAdvancement advancement = session.getAdvancementsCache().getStoredAdvancements().get(progress.getKey());\n            if (advancement != null && advancement.getDisplayData() != null) {\n                if (session.getAdvancementsCache().isEarned(advancement)) {\n                    // Java uses some pink color for toast challenge completes\n                    String color = advancement.getDisplayData().getFrameType() == Advancement.DisplayData.FrameType.CHALLENGE ?\n                            \"\u00a7d\" : \"\u00a7a\";\n                    String advancementName = MessageTranslator.convertMessage(advancement.getDisplayData().getTitle(), session.getLocale());\n\n                    // Send an action bar message stating they earned an achievement\n                    // Sent for instances where broadcasting advancements through chat are disabled\n                    SetTitlePacket titlePacket = new SetTitlePacket();\n                    titlePacket.setText(color + \"[\" + LocaleUtils.getLocaleString(\"advancements.toast.\" +\n                            advancement.getDisplayData().getFrameType().toString().toLowerCase(), session.getLocale()) + \"]\u00a7f \" + advancementName);\n                    titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n                    titlePacket.setFadeOutTime(3);\n                    titlePacket.setFadeInTime(3);\n                    titlePacket.setStayTime(3);\n                    titlePacket.setXuid(\"\");\n                    titlePacket.setPlatformOnlineId(\"\");\n                    session.sendUpstreamPacket(titlePacket);\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.BossBar;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerBossBarPacket;\n\n@Translator(packet = ServerBossBarPacket.class)\npublic class JavaBossBarTranslator extends PacketTranslator<ServerBossBarPacket> {\n    @Override\n    public void translate(ServerBossBarPacket packet, GeyserSession session) {\n        BossBar bossBar = session.getEntityCache().getBossBar(packet.getUuid());\n        switch (packet.getAction()) {\n            case ADD:\n                long entityId = session.getEntityCache().getNextEntityId().incrementAndGet();\n                bossBar = new BossBar(session, entityId, packet.getTitle(), packet.getHealth(), 0, 1, 0);\n                session.getEntityCache().addBossBar(packet.getUuid(), bossBar);\n                break;\n            case UPDATE_TITLE:\n                if (bossBar != null) bossBar.updateTitle(packet.getTitle());\n                break;\n            case UPDATE_HEALTH:\n                if (bossBar != null) bossBar.updateHealth(packet.getHealth());\n                break;\n            case REMOVE:\n                session.getEntityCache().removeBossBar(packet.getUuid());\n                break;\n            case UPDATE_STYLE:\n            case UPDATE_FLAGS:\n                //todo\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerChatPacket.class)\npublic class JavaChatTranslator extends PacketTranslator<ServerChatPacket> {\n\n    @Override\n    public void translate(ServerChatPacket packet, GeyserSession session) {\n        TextPacket textPacket = new TextPacket();\n        textPacket.setPlatformChatId(\"\");\n        textPacket.setSourceName(\"\");\n        textPacket.setXuid(session.getAuthData().getXboxUUID());\n        switch (packet.getType()) {\n            case CHAT:\n                textPacket.setType(TextPacket.Type.CHAT);\n                break;\n            case SYSTEM:\n                textPacket.setType(TextPacket.Type.SYSTEM);\n                break;\n            case NOTIFICATION:\n                textPacket.setType(TextPacket.Type.TIP);\n                break;\n            default:\n                textPacket.setType(TextPacket.Type.RAW);\n                break;\n        }\n\n        textPacket.setNeedsTranslation(false);\n        textPacket.setMessage(MessageTranslator.convertMessage(packet.getMessage(), session.getLocale()));\n\n        session.sendUpstreamPacket(textPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.command.CommandNode;\nimport com.github.steveice10.mc.protocol.data.game.command.CommandParser;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareCommandsPacket;\nimport com.nukkitx.protocol.bedrock.data.command.CommandData;\nimport com.nukkitx.protocol.bedrock.data.command.CommandEnumData;\nimport com.nukkitx.protocol.bedrock.data.command.CommandParam;\nimport com.nukkitx.protocol.bedrock.data.command.CommandParamData;\nimport com.nukkitx.protocol.bedrock.packet.AvailableCommandsPacket;\nimport it.unimi.dsi.fastutil.Hash;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectMap;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\nimport it.unimi.dsi.fastutil.ints.IntOpenHashSet;\nimport it.unimi.dsi.fastutil.ints.IntSet;\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;\nimport lombok.Getter;\nimport lombok.ToString;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.Enchantment;\nimport org.geysermc.connector.registry.BlockRegistries;\n\nimport java.util.*;\n\n@Translator(packet = ServerDeclareCommandsPacket.class)\npublic class JavaDeclareCommandsTranslator extends PacketTranslator<ServerDeclareCommandsPacket> {\n\n    private static final String[] ENUM_BOOLEAN = {\"true\", \"false\"};\n    private static final String[] VALID_COLORS;\n    private static final String[] VALID_SCOREBOARD_SLOTS;\n\n    private static final Hash.Strategy<CommandParamData[][]> PARAM_STRATEGY = new Hash.Strategy<CommandParamData[][]>() {\n        @Override\n        public int hashCode(CommandParamData[][] o) {\n            return Arrays.deepHashCode(o);\n        }\n\n        @Override\n        public boolean equals(CommandParamData[][] a, CommandParamData[][] b) {\n            if (a == b) return true;\n            if (a == null || b == null) return false;\n            if (a.length != b.length) return false;\n            for (int i = 0; i < a.length; i++) {\n                CommandParamData[] a1 = a[i];\n                CommandParamData[] b1 = b[i];\n                if (a1.length != b1.length) return false;\n\n                for (int j = 0; j < a1.length; j++) {\n                    if (!a1[j].equals(b1[j])) return false;\n                }\n            }\n            return true;\n        }\n    };\n\n    static {\n        List<String> validColors = new ArrayList<>(NamedTextColor.NAMES.keys());\n        validColors.add(\"reset\");\n        VALID_COLORS = validColors.toArray(new String[0]);\n\n        List<String> teamOptions = new ArrayList<>(Arrays.asList(\"list\", \"sidebar\", \"belowName\"));\n        for (String color : NamedTextColor.NAMES.keys()) {\n            teamOptions.add(\"sidebar.team.\" + color);\n        }\n        VALID_SCOREBOARD_SLOTS = teamOptions.toArray(new String[0]);\n    }\n\n    @Override\n    public void translate(ServerDeclareCommandsPacket packet, GeyserSession session) {\n        // Don't send command suggestions if they are disabled\n        if (!session.getConnector().getConfig().isCommandSuggestions()) {\n            session.getConnector().getLogger().debug(\"Not sending translated command suggestions as they are disabled.\");\n\n            // Send an empty packet so Bedrock doesn't override /help with its own, built-in help command.\n            AvailableCommandsPacket emptyPacket = new AvailableCommandsPacket();\n            session.sendUpstreamPacket(emptyPacket);\n            return;\n        }\n\n        CommandNode[] nodes = packet.getNodes();\n        List<CommandData> commandData = new ArrayList<>();\n        IntSet commandNodes = new IntOpenHashSet();\n        Set<String> knownAliases = new HashSet<>();\n        Map<CommandParamData[][], Set<String>> commands = new Object2ObjectOpenCustomHashMap<>(PARAM_STRATEGY);\n        Int2ObjectMap<List<CommandNode>> commandArgs = new Int2ObjectOpenHashMap<>();\n\n        // Get the first node, it should be a root node\n        CommandNode rootNode = nodes[packet.getFirstNodeIndex()];\n\n        // Loop through the root nodes to get all commands\n        for (int nodeIndex : rootNode.getChildIndices()) {\n            CommandNode node = nodes[nodeIndex];\n\n            // Make sure we don't have duplicated commands (happens if there is more than 1 root node)\n            if (!commandNodes.add(nodeIndex) || !knownAliases.add(node.getName().toLowerCase())) continue;\n\n            // Get and update the commandArgs list with the found arguments\n            if (node.getChildIndices().length >= 1) {\n                for (int childIndex : node.getChildIndices()) {\n                    commandArgs.computeIfAbsent(nodeIndex, ArrayList::new).add(nodes[childIndex]);\n                }\n            }\n\n            // Get and parse all params\n            CommandParamData[][] params = getParams(session, nodes[nodeIndex], nodes);\n\n            // Insert the alias name into the command list\n            commands.computeIfAbsent(params, index -> new HashSet<>()).add(node.getName().toLowerCase());\n        }\n\n        // The command flags, not sure what these do apart from break things\n        List<CommandData.Flag> flags = Collections.emptyList();\n\n        // Loop through all the found commands\n\n        for (Map.Entry<CommandParamData[][], Set<String>> entry : commands.entrySet()) {\n            String commandName = entry.getValue().iterator().next(); // We know this has a value\n\n            // Create a basic alias\n            CommandEnumData aliases = new CommandEnumData(commandName + \"Aliases\", entry.getValue().toArray(new String[0]), false);\n\n            // Build the completed command and add it to the final list\n            CommandData data = new CommandData(commandName, session.getConnector().getCommandManager().getDescription(commandName), flags, (byte) 0, aliases, entry.getKey());\n            commandData.add(data);\n        }\n\n        // Add our commands to the AvailableCommandsPacket for the bedrock client\n        AvailableCommandsPacket availableCommandsPacket = new AvailableCommandsPacket();\n        availableCommandsPacket.getCommands().addAll(commandData);\n\n        session.getConnector().getLogger().debug(\"Sending command packet of \" + commandData.size() + \" commands\");\n\n        // Finally, send the commands to the client\n        session.sendUpstreamPacket(availableCommandsPacket);\n    }\n\n    /**\n     * Build the command parameter array for the given command\n     *\n     * @param session the session\n     * @param commandNode The command to build the parameters for\n     * @param allNodes    Every command node\n     * @return An array of parameter option arrays\n     */\n    private static CommandParamData[][] getParams(GeyserSession session, CommandNode commandNode, CommandNode[] allNodes) {\n        // Check if the command is an alias and redirect it\n        if (commandNode.getRedirectIndex() != -1) {\n            GeyserConnector.getInstance().getLogger().debug(\"Redirecting command \" + commandNode.getName() + \" to \" + allNodes[commandNode.getRedirectIndex()].getName());\n            commandNode = allNodes[commandNode.getRedirectIndex()];\n        }\n\n        if (commandNode.getChildIndices().length >= 1) {\n            // Create the root param node and build all the children\n            ParamInfo rootParam = new ParamInfo(commandNode, null);\n            rootParam.buildChildren(session, allNodes);\n\n            List<CommandParamData[]> treeData = rootParam.getTree();\n\n            return treeData.toArray(new CommandParamData[0][]);\n        }\n\n        return new CommandParamData[0][0];\n    }\n\n    /**\n     * Convert Java edition command types to Bedrock edition\n     *\n     * @param session the session\n     * @param parser Command type to convert\n     * @return Bedrock parameter data type\n     */\n    private static Object mapCommandType(GeyserSession session, CommandParser parser) {\n        if (parser == null) {\n            return CommandParam.STRING;\n        }\n\n        switch (parser) {\n            case FLOAT:\n            case ROTATION:\n            case DOUBLE:\n                return CommandParam.FLOAT;\n\n            case INTEGER:\n            case LONG:\n                return CommandParam.INT;\n\n            case ENTITY:\n            case GAME_PROFILE:\n                return CommandParam.TARGET;\n\n            case BLOCK_POS:\n                return CommandParam.BLOCK_POSITION;\n\n            case COLUMN_POS:\n            case VEC3:\n                return CommandParam.POSITION;\n\n            case MESSAGE:\n                return CommandParam.MESSAGE;\n\n            case NBT:\n            case NBT_COMPOUND_TAG:\n            case NBT_TAG:\n            case NBT_PATH:\n                return CommandParam.JSON;\n\n            case RESOURCE_LOCATION:\n            case FUNCTION:\n                return CommandParam.FILE_PATH;\n\n            case BOOL:\n                return ENUM_BOOLEAN;\n\n            case OPERATION: // \">=\", \"==\", etc\n                return CommandParam.OPERATOR;\n\n            case BLOCK_STATE:\n                return BlockRegistries.JAVA_TO_BEDROCK_IDENTIFIERS.get().keySet().toArray(new String[0]);\n\n            case ITEM_STACK:\n                return session.getItemMappings().getItemNames();\n\n            case ITEM_ENCHANTMENT:\n                return Enchantment.JavaEnchantment.ALL_JAVA_IDENTIFIERS;\n\n            case ENTITY_SUMMON:\n                return EntityType.ALL_JAVA_IDENTIFIERS;\n\n            case COLOR:\n                return VALID_COLORS;\n\n            case SCOREBOARD_SLOT:\n                return VALID_SCOREBOARD_SLOTS;\n\n            default:\n                return CommandParam.STRING;\n        }\n    }\n\n    @Getter\n    @ToString\n    private static class ParamInfo {\n        private final CommandNode paramNode;\n        private final CommandParamData paramData;\n        private final List<ParamInfo> children;\n\n        /**\n         * Create a new parameter info object\n         *\n         * @param paramNode CommandNode the parameter is for\n         * @param paramData The existing parameters for the command\n         */\n        public ParamInfo(CommandNode paramNode, CommandParamData paramData) {\n            this.paramNode = paramNode;\n            this.paramData = paramData;\n            this.children = new ArrayList<>();\n        }\n\n        /**\n         * Build the array of all the child parameters (recursive)\n         *\n         * @param session the session\n         * @param allNodes Every command node\n         */\n        public void buildChildren(GeyserSession session, CommandNode[] allNodes) {\n            for (int paramID : paramNode.getChildIndices()) {\n                CommandNode paramNode = allNodes[paramID];\n\n                if (paramNode == this.paramNode) {\n                    // Fixes a StackOverflowError when an argument has itself as a child\n                    continue;\n                }\n\n                if (paramNode.getParser() == null) {\n                    boolean foundCompatible = false;\n                    for (int i = 0; i < children.size(); i++) {\n                        ParamInfo enumParamInfo = children.get(i);\n                        // Check to make sure all descending nodes of this command are compatible - otherwise, create a new overload\n                        if (isCompatible(allNodes, enumParamInfo.getParamNode(), paramNode)) {\n                            foundCompatible = true;\n                            // Extend the current list of enum values\n                            String[] enumOptions = Arrays.copyOf(enumParamInfo.getParamData().getEnumData().getValues(), enumParamInfo.getParamData().getEnumData().getValues().length + 1);\n                            enumOptions[enumOptions.length - 1] = paramNode.getName();\n\n                            // Re-create the command using the updated values\n                            CommandEnumData enumData = new CommandEnumData(enumParamInfo.getParamData().getEnumData().getName(), enumOptions, false);\n                            children.set(i, new ParamInfo(enumParamInfo.getParamNode(), new CommandParamData(enumParamInfo.getParamData().getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));\n                            break;\n                        }\n                    }\n\n                    if (!foundCompatible) {\n                        // Create a new subcommand with this exact type\n                        CommandEnumData enumData = new CommandEnumData(paramNode.getName(), new String[]{paramNode.getName()}, false);\n\n                        // On setting optional:\n                        // isExecutable is defined as a node \"constitutes a valid command.\"\n                        // Therefore, any children of the parameter must simply be optional.\n                        children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));\n                    }\n                } else {\n                    // Put the non-enum param into the list\n                    Object mappedType = mapCommandType(session, paramNode.getParser());\n                    CommandEnumData enumData = null;\n                    CommandParam type = null;\n                    if (mappedType instanceof String[]) {\n                        enumData = new CommandEnumData(paramNode.getParser().name().toLowerCase(), (String[]) mappedType, false);\n                    } else {\n                        type = (CommandParam) mappedType;\n                    }\n                    // IF enumData != null:\n                    // In game, this will show up like <paramNode.getName(): enumData.getName()>\n                    // So if paramNode.getName() == \"value\" and enumData.getName() == \"bool\": <value: bool>\n                    children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, type, null, Collections.emptyList())));\n                }\n            }\n\n            // Recursively build all child options\n            for (ParamInfo child : children) {\n                child.buildChildren(session, allNodes);\n            }\n        }\n\n        /**\n         * Comparing CommandNode type a and b, determine if they are in the same overload.\n         * <p>\n         * Take the <code>gamerule</code> command, and let's present three \"subcommands\" you can perform:\n         *\n         * <ul>\n         *     <li><code>gamerule doDaylightCycle true</code></li>\n         *     <li><code>gamerule announceAdvancements false</code></li>\n         *     <li><code>gamerule randomTickSpeed 3</code></li>\n         * </ul>\n         *\n         * While all three of them are indeed part of the same command, the command setting randomTickSpeed parses an int,\n         * while the others use boolean. In Bedrock, this should be presented as a separate overload to indicate that this\n         * does something a little different.\n         * <p>\n         * Therefore, this function will return <code>true</code> if the first two are compared, as they use the same\n         * parsers. If the third is compared with either of the others, this function will return <code>false</code>.\n         * <p>\n         * Here's an example of how the above would be presented to Bedrock (as of 1.16.200). Notice how the top two <code>CommandParamData</code>\n         * classes of each array are identical in type, but the following class is different:\n         * <pre>\n         *     overloads=[\n         *         [\n         *            CommandParamData(name=doDaylightCycle, optional=false, enumData=CommandEnumData(name=announceAdvancements, values=[announceAdvancements, doDaylightCycle], isSoft=false), type=STRING, postfix=null, options=[])\n         *            CommandParamData(name=value, optional=false, enumData=CommandEnumData(name=value, values=[true, false], isSoft=false), type=null, postfix=null, options=[])\n         *         ]\n         *         [\n         *            CommandParamData(name=randomTickSpeed, optional=false, enumData=CommandEnumData(name=randomTickSpeed, values=[randomTickSpeed], isSoft=false), type=STRING, postfix=null, options=[])\n         *            CommandParamData(name=value, optional=false, enumData=null, type=INT, postfix=null, options=[])\n         *         ]\n         *     ]\n         * </pre>\n         *\n         * @return if these two can be merged into one overload.\n         */\n        private boolean isCompatible(CommandNode[] allNodes, CommandNode a, CommandNode b) {\n            if (a == b) return true;\n            if (a.getParser() != b.getParser()) return false;\n            if (a.getChildIndices().length != b.getChildIndices().length) return false;\n\n            for (int i = 0; i < a.getChildIndices().length; i++) {\n                boolean hasSimilarity = false;\n                CommandNode a1 = allNodes[a.getChildIndices()[i]];\n                // Search \"b\" until we find a child that matches this one\n                for (int j = 0; j < b.getChildIndices().length; j++) {\n                    if (isCompatible(allNodes, a1, allNodes[b.getChildIndices()[j]])) {\n                        hasSimilarity = true;\n                        break;\n                    }\n                }\n\n                if (!hasSimilarity) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Get the tree of every parameter node (recursive)\n         *\n         * @return List of parameter options arrays for the command\n         */\n        public List<CommandParamData[]> getTree() {\n            List<CommandParamData[]> treeParamData = new ArrayList<>();\n\n            for (ParamInfo child : children) {\n                // Get the tree from the child\n                List<CommandParamData[]> childTree = child.getTree();\n\n                // Un-pack the tree append the child node to it and push into the list\n                for (CommandParamData[] subChild : childTree) {\n                    CommandParamData[] tmpTree = new CommandParamData[subChild.length + 1];\n                    tmpTree[0] = child.getParamData();\n                    System.arraycopy(subChild, 0, tmpTree, 1, subChild.length);\n\n                    treeParamData.add(tmpTree);\n                }\n\n                // If we have no more child parameters just the child\n                if (childTree.size() == 0) {\n                    treeParamData.add(new CommandParamData[] { child.getParamData() });\n                }\n            }\n\n            return treeParamData;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Recipe;\nimport com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.StoneCuttingRecipeData;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareRecipesPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.data.inventory.CraftingData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;\nimport it.unimi.dsi.fastutil.ints.*;\nimport lombok.AllArgsConstructor;\nimport lombok.EqualsAndHashCode;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.geysermc.connector.utils.InventoryUtils.LAST_RECIPE_NET_ID;\n\n/**\n * Used to send all valid recipes from Java to Bedrock.\n *\n * Bedrock REQUIRES a CraftingDataPacket to be sent in order to craft anything.\n */\n@Translator(packet = ServerDeclareRecipesPacket.class)\npublic class JavaDeclareRecipesTranslator extends PacketTranslator<ServerDeclareRecipesPacket> {\n    /**\n     * Required to use the specified cartography table recipes\n     */\n    private static final List<CraftingData> CARTOGRAPHY_RECIPES = Arrays.asList(\n            CraftingData.fromMulti(UUID.fromString(\"8b36268c-1829-483c-a0f1-993b7156a8f2\"), ++LAST_RECIPE_NET_ID), // Map extending\n            CraftingData.fromMulti(UUID.fromString(\"442d85ed-8272-4543-a6f1-418f90ded05d\"), ++LAST_RECIPE_NET_ID), // Map cloning\n            CraftingData.fromMulti(UUID.fromString(\"98c84b38-1085-46bd-b1ce-dd38c159e6cc\"), ++LAST_RECIPE_NET_ID), // Map upgrading\n            CraftingData.fromMulti(UUID.fromString(\"602234e4-cac1-4353-8bb7-b1ebff70024b\"), ++LAST_RECIPE_NET_ID) // Map locking\n    );\n\n    @Override\n    public void translate(ServerDeclareRecipesPacket packet, GeyserSession session) {\n        Map<RecipeType, List<CraftingData>> recipeTypes = Registries.CRAFTING_DATA.forVersion(session.getUpstream().getProtocolVersion());\n        // Get the last known network ID (first used for the pregenerated recipes) and increment from there.\n        int netId = InventoryUtils.LAST_RECIPE_NET_ID + 1;\n\n        Int2ObjectMap<Recipe> recipeMap = new Int2ObjectOpenHashMap<>(Registries.RECIPES.forVersion(session.getUpstream().getProtocolVersion()));\n        Int2ObjectMap<List<StoneCuttingRecipeData>> unsortedStonecutterData = new Int2ObjectOpenHashMap<>();\n        CraftingDataPacket craftingDataPacket = new CraftingDataPacket();\n        craftingDataPacket.setCleanRecipes(true);\n        for (Recipe recipe : packet.getRecipes()) {\n            switch (recipe.getType()) {\n                case CRAFTING_SHAPELESS: {\n                    ShapelessRecipeData shapelessRecipeData = (ShapelessRecipeData) recipe.getData();\n                    ItemData output = ItemTranslator.translateToBedrock(session, shapelessRecipeData.getResult());\n                    // Strip NBT - tools won't appear in the recipe book otherwise\n                    output = output.toBuilder().tag(null).build();\n                    ItemData[][] inputCombinations = combinations(session, shapelessRecipeData.getIngredients());\n                    for (ItemData[] inputs : inputCombinations) {\n                        UUID uuid = UUID.randomUUID();\n                        craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),\n                                Arrays.asList(inputs), Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));\n                        recipeMap.put(netId++, recipe);\n                    }\n                    break;\n                }\n                case CRAFTING_SHAPED: {\n                    ShapedRecipeData shapedRecipeData = (ShapedRecipeData) recipe.getData();\n                    ItemData output = ItemTranslator.translateToBedrock(session, shapedRecipeData.getResult());\n                    // See above\n                    output = output.toBuilder().tag(null).build();\n                    ItemData[][] inputCombinations = combinations(session, shapedRecipeData.getIngredients());\n                    for (ItemData[] inputs : inputCombinations) {\n                        UUID uuid = UUID.randomUUID();\n                        craftingDataPacket.getCraftingData().add(CraftingData.fromShaped(uuid.toString(),\n                                shapedRecipeData.getWidth(), shapedRecipeData.getHeight(), Arrays.asList(inputs),\n                                        Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));\n                        recipeMap.put(netId++, recipe);\n                    }\n                    break;\n                }\n                case STONECUTTING: {\n                    StoneCuttingRecipeData stoneCuttingData = (StoneCuttingRecipeData) recipe.getData();\n                    ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];\n                    List<StoneCuttingRecipeData> data = unsortedStonecutterData.get(ingredient.getId());\n                    if (data == null) {\n                        data = new ArrayList<>();\n                        unsortedStonecutterData.put(ingredient.getId(), data);\n                    }\n                    data.add(stoneCuttingData);\n                    // Save for processing after all recipes have been received\n                    break;\n                }\n                default: {\n                    List<CraftingData> craftingData = recipeTypes.get(recipe.getType());\n                    if (craftingData != null) {\n                        craftingDataPacket.getCraftingData().addAll(craftingData);\n                    }\n                    break;\n                }\n            }\n        }\n        craftingDataPacket.getCraftingData().addAll(CARTOGRAPHY_RECIPES);\n        craftingDataPacket.getPotionMixData().addAll(Registries.POTION_MIXES.get());\n\n        Int2ObjectMap<IntList> stonecutterRecipeMap = new Int2ObjectOpenHashMap<>();\n        for (Int2ObjectMap.Entry<List<StoneCuttingRecipeData>> data : unsortedStonecutterData.int2ObjectEntrySet()) {\n            // Sort the list by each output item's Java identifier - this is how it's sorted on Java, and therefore\n            // We can get the correct order for button pressing\n            data.getValue().sort(Comparator.comparing((stoneCuttingRecipeData ->\n                    session.getItemMappings().getItems().get(stoneCuttingRecipeData.getResult().getId()).getJavaIdentifier())));\n\n            // Now that it's sorted, let's translate these recipes\n            for (StoneCuttingRecipeData stoneCuttingData : data.getValue()) {\n                // As of 1.16.4, all stonecutter recipes have one ingredient option\n                ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];\n                ItemData input = ItemTranslator.translateToBedrock(session, ingredient);\n                ItemData output = ItemTranslator.translateToBedrock(session, stoneCuttingData.getResult());\n                UUID uuid = UUID.randomUUID();\n\n                // We need to register stonecutting recipes so they show up on Bedrock\n                craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),\n                        Collections.singletonList(input), Collections.singletonList(output), uuid, \"stonecutter\", 0, netId++));\n\n                // Save the recipe list for reference when crafting\n                IntList outputs = stonecutterRecipeMap.get(ingredient.getId());\n                if (outputs == null) {\n                    outputs = new IntArrayList();\n                    // Add the ingredient as the key and all possible values as the value\n                    stonecutterRecipeMap.put(ingredient.getId(), outputs);\n                }\n                outputs.add(stoneCuttingData.getResult().getId());\n            }\n        }\n\n        session.sendUpstreamPacket(craftingDataPacket);\n        session.setCraftingRecipes(recipeMap);\n        session.getUnlockedRecipes().clear();\n        session.setStonecutterRecipes(stonecutterRecipeMap);\n        session.getLastRecipeNetId().set(netId);\n    }\n\n    //TODO: rewrite\n    /**\n     * The Java server sends an array of items for each ingredient you can use per slot in the crafting grid.\n     * Bedrock recipes take only one ingredient per crafting grid slot.\n     *\n     * @return the Java ingredient list as an array that Bedrock can understand\n     */\n    private ItemData[][] combinations(GeyserSession session, Ingredient[] ingredients) {\n        Map<Set<ItemData>, IntSet> squashedOptions = new HashMap<>();\n        for (int i = 0; i < ingredients.length; i++) {\n            if (ingredients[i].getOptions().length == 0) {\n                squashedOptions.computeIfAbsent(Collections.singleton(ItemData.AIR), k -> new IntOpenHashSet()).add(i);\n                continue;\n            }\n            Ingredient ingredient = ingredients[i];\n            Map<GroupedItem, List<ItemData>> groupedByIds = Arrays.stream(ingredient.getOptions())\n                    .map(item -> ItemTranslator.translateToBedrock(session, item))\n                    .collect(Collectors.groupingBy(item -> new GroupedItem(item.getId(), item.getCount(), item.getTag())));\n            Set<ItemData> optionSet = new HashSet<>(groupedByIds.size());\n            for (Map.Entry<GroupedItem, List<ItemData>> entry : groupedByIds.entrySet()) {\n                if (entry.getValue().size() > 1) {\n                    GroupedItem groupedItem = entry.getKey();\n                    int idCount = 0;\n                    //not optimal\n                    for (ItemMapping mapping : session.getItemMappings().getItems().values()) {\n                        if (mapping.getBedrockId() == groupedItem.id) {\n                            idCount++;\n                        }\n                    }\n                    if (entry.getValue().size() < idCount) {\n                        optionSet.addAll(entry.getValue());\n                    } else {\n                        optionSet.add(ItemData.builder()\n                                .id(groupedItem.id)\n                                .damage(Short.MAX_VALUE)\n                                .count(groupedItem.count)\n                                .tag(groupedItem.tag).build());\n                    }\n                } else {\n                    ItemData item = entry.getValue().get(0);\n                    optionSet.add(item);\n                }\n            }\n            squashedOptions.computeIfAbsent(optionSet, k -> new IntOpenHashSet()).add(i);\n        }\n        int totalCombinations = 1;\n        for (Set<ItemData> optionSet : squashedOptions.keySet()) {\n            totalCombinations *= optionSet.size();\n        }\n        if (totalCombinations > 500) {\n            ItemData[] translatedItems = new ItemData[ingredients.length];\n            for (int i = 0; i < ingredients.length; i++) {\n                if (ingredients[i].getOptions().length > 0) {\n                    translatedItems[i] = ItemTranslator.translateToBedrock(session, ingredients[i].getOptions()[0]);\n                } else {\n                    translatedItems[i] = ItemData.AIR;\n                }\n            }\n            return new ItemData[][]{translatedItems};\n        }\n        List<Set<ItemData>> sortedSets = new ArrayList<>(squashedOptions.keySet());\n        sortedSets.sort(Comparator.comparing(Set::size, Comparator.reverseOrder()));\n        ItemData[][] combinations = new ItemData[totalCombinations][ingredients.length];\n        int x = 1;\n        for (Set<ItemData> set : sortedSets) {\n            IntSet slotSet = squashedOptions.get(set);\n            int i = 0;\n            for (ItemData item : set) {\n                for (int j = 0; j < totalCombinations / set.size(); j++) {\n                    final int comboIndex = (i * x) + (j % x) + ((j / x) * set.size() * x);\n                    for (int slot : slotSet) {\n                        combinations[comboIndex][slot] = item;\n                    }\n                }\n                i++;\n            }\n            x *= set.size();\n        }\n        return combinations;\n    }\n\n    @EqualsAndHashCode\n    @AllArgsConstructor\n    private static class GroupedItem {\n        int id;\n        int count;\n        NbtMap tag;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareTagsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerDeclareTagsPacket.class)\npublic class JavaDeclareTagsTranslator extends PacketTranslator<ServerDeclareTagsPacket> {\n\n    @Override\n    public void translate(ServerDeclareTagsPacket packet, GeyserSession session) {\n        session.getTagCache().loadPacket(packet);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDifficultyPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetDifficultyPacket;\n\n@Translator(packet = ServerDifficultyPacket.class)\npublic class JavaDifficultyTranslator extends PacketTranslator<ServerDifficultyPacket> {\n\n    @Override\n    public void translate(ServerDifficultyPacket packet, GeyserSession session) {\n        SetDifficultyPacket setDifficultyPacket = new SetDifficultyPacket();\n        setDifficultyPacket.setDifficulty(packet.getDifficulty().ordinal());\n        session.sendUpstreamPacket(setDifficultyPacket);\n\n        session.getWorldCache().setDifficulty(packet.getDifficulty());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDisconnectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerDisconnectPacket.class)\npublic class JavaDisconnectPacket extends PacketTranslator<ServerDisconnectPacket> {\n\n    @Override\n    public void translate(ServerDisconnectPacket packet, GeyserSession session) {\n        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.HandPreference;\nimport com.github.steveice10.mc.protocol.data.game.setting.ChatVisibility;\nimport com.github.steveice10.mc.protocol.data.game.setting.SkinPart;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientSettingsPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerJoinGamePacket;\nimport com.nukkitx.protocol.bedrock.data.GameRuleData;\nimport com.nukkitx.protocol.bedrock.data.PlayerPermission;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.BiomeTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.PluginMessageUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@Translator(packet = ServerJoinGamePacket.class)\npublic class JavaJoinGameTranslator extends PacketTranslator<ServerJoinGamePacket> {\n    private static final List<SkinPart> SKIN_PART_VALUES = Arrays.asList(SkinPart.values());\n\n    @Override\n    public void translate(ServerJoinGamePacket packet, GeyserSession session) {\n        PlayerEntity entity = session.getPlayerEntity();\n        entity.setEntityId(packet.getEntityId());\n\n        // If the player is already initialized and a join game packet is sent, they\n        // are swapping servers\n        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());\n        if (session.isSpawned()) {\n            String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);\n            DimensionUtils.switchDimension(session, fakeDim);\n\n            session.getWorldCache().removeScoreboard();\n        }\n        session.setWorldName(packet.getWorldName());\n\n        BiomeTranslator.loadServerBiomes(session, packet.getDimensionCodec());\n        session.getTagCache().clear();\n\n        AdventureSettingsPacket bedrockPacket = new AdventureSettingsPacket();\n        bedrockPacket.setUniqueEntityId(session.getPlayerEntity().getGeyserId());\n        bedrockPacket.setPlayerPermission(PlayerPermission.MEMBER);\n        session.sendUpstreamPacket(bedrockPacket);\n\n        PlayStatusPacket playStatus = new PlayStatusPacket();\n        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        // session.sendPacket(playStatus);\n\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(packet.getGameMode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n        session.setGameMode(packet.getGameMode());\n\n        SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n        entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n        entityDataPacket.getMetadata().putAll(entity.getMetadata());\n        session.sendUpstreamPacket(entityDataPacket);\n\n        // Send if client should show respawn screen\n        GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();\n        gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\", !packet.isEnableRespawnScreen()));\n        session.sendUpstreamPacket(gamerulePacket);\n\n        session.setReducedDebugInfo(packet.isReducedDebugInfo());\n\n        session.setRenderDistance(packet.getViewDistance());\n\n        // We need to send our skin parts to the server otherwise java sees us with no hat, jacket etc\n        String locale = session.getLocale();\n        ClientSettingsPacket clientSettingsPacket = new ClientSettingsPacket(locale, (byte) session.getRenderDistance(), ChatVisibility.FULL, true, SKIN_PART_VALUES, HandPreference.RIGHT_HAND, false);\n        session.sendDownstreamPacket(clientSettingsPacket);\n\n        session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:brand\", PluginMessageUtils.getGeyserBrandData()));\n\n        // register the plugin messaging channels used in Floodgate\n        if (session.getRemoteAuthType() == AuthType.FLOODGATE) {\n            session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:register\", PluginMessageUtils.getFloodgateRegisterData()));\n        }\n\n        if (!newDimension.equals(session.getDimension())) {\n            DimensionUtils.switchDimension(session, newDimension);\n        }\n\n        ChunkUtils.applyDimensionHeight(session, packet.getDimension());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerKeepAlivePacket;\nimport com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Used to forward the keep alive packet to the client in order to get back a reliable ping.\n */\n@Translator(packet = ServerKeepAlivePacket.class)\npublic class JavaKeepAliveTranslator extends PacketTranslator<ServerKeepAlivePacket> {\n\n    @Override\n    public void translate(ServerKeepAlivePacket packet, GeyserSession session) {\n        if (!session.getConnector().getConfig().isForwardPlayerPing()) {\n            return;\n        }\n        NetworkStackLatencyPacket latencyPacket = new NetworkStackLatencyPacket();\n        latencyPacket.setFromServer(true);\n        latencyPacket.setTimestamp(packet.getPingId() * 1000);\n        session.sendUpstreamPacket(latencyPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginDisconnectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = LoginDisconnectPacket.class)\npublic class JavaLoginDisconnectTranslator extends PacketTranslator<LoginDisconnectPacket> {\n\n    @Override\n    public void translate(LoginDisconnectPacket packet, GeyserSession session) {\n        // The client doesn't manually get disconnected so we have to do it ourselves\n        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.login.client.LoginPluginResponsePacket;\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginPluginRequestPacket;\n\n@Translator(packet = LoginPluginRequestPacket.class)\npublic class JavaLoginPluginRequestTranslator extends PacketTranslator<LoginPluginRequestPacket> {\n    @Override\n    public void translate(LoginPluginRequestPacket packet, GeyserSession session) {\n        // A vanilla client doesn't know any PluginMessage in the Login state, so we don't know any either.\n        // Note: Fabric Networking API v1 will not let the client log in without sending this\n        session.sendDownstreamPacket(\n                new LoginPluginResponsePacket(packet.getMessageId(), null)\n        );\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.auth.data.GameProfile;\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginSuccessPacket;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = LoginSuccessPacket.class)\npublic class JavaLoginSuccessTranslator extends PacketTranslator<LoginSuccessPacket> {\n\n    @Override\n    public void translate(LoginSuccessPacket packet, GeyserSession session) {\n        PlayerEntity playerEntity = session.getPlayerEntity();\n        AuthType remoteAuthType = session.getRemoteAuthType();\n\n        // Required, or else Floodgate players break with Spigot chunk caching\n        GameProfile profile = packet.getProfile();\n        playerEntity.setUsername(profile.getName());\n        playerEntity.setUuid(profile.getId());\n\n        // Check if they are not using a linked account\n        if (remoteAuthType == AuthType.OFFLINE || playerEntity.getUuid().getMostSignificantBits() == 0) {\n            SkinManager.handleBedrockSkin(playerEntity, session.getClientData());\n        }\n\n        if (remoteAuthType == AuthType.FLOODGATE) {\n            // We'll send the skin upload a bit after the handshake packet (aka this packet),\n            // because otherwise the global server returns the data too fast.\n            session.getAuthData().upload(session.getConnector());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPongPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPingPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n// Why does this packet exist? Whatever, we better implement it\n@Translator(packet = ServerPingPacket.class)\npublic class JavaPingPacket extends PacketTranslator<ServerPingPacket> {\n\n    @Override\n    public void translate(ServerPingPacket packet, GeyserSession session) {\n        session.sendDownstreamPacket(new ClientPongPacket(packet.getId()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2020 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPluginMessagePacket;\nimport com.google.common.base.Charsets;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.cumulus.Form;\nimport org.geysermc.cumulus.Forms;\nimport org.geysermc.cumulus.util.FormType;\n\nimport java.nio.charset.StandardCharsets;\n\n@Translator(packet = ServerPluginMessagePacket.class)\npublic class JavaPluginMessageTranslator extends PacketTranslator<ServerPluginMessagePacket> {\n    @Override\n    public void translate(ServerPluginMessagePacket packet, GeyserSession session) {\n        // The only plugin messages it has to listen for are Floodgate plugin messages\n        if (session.getRemoteAuthType() != AuthType.FLOODGATE) {\n            return;\n        }\n\n        String channel = packet.getChannel();\n\n        if (channel.equals(\"floodgate:form\")) {\n            byte[] data = packet.getData();\n\n            // receive: first byte is form type, second and third are the id, remaining is the form data\n            // respond: first and second byte id, remaining is form response data\n\n            FormType type = FormType.getByOrdinal(data[0]);\n            if (type == null) {\n                throw new NullPointerException(\n                        \"Got type \" + data[0] + \" which isn't a valid form type!\");\n            }\n\n            String dataString = new String(data, 3, data.length - 3, Charsets.UTF_8);\n\n            Form form = Forms.fromJson(dataString, type);\n            form.setResponseHandler(response -> {\n                byte[] raw = response.getBytes(StandardCharsets.UTF_8);\n                byte[] finalData = new byte[raw.length + 2];\n\n                finalData[0] = data[1];\n                finalData[1] = data[2];\n                System.arraycopy(raw, 0, finalData, 2, raw.length);\n\n                session.sendDownstreamPacket(new ClientPluginMessagePacket(channel, finalData));\n            });\n            session.sendForm(form);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerRespawnPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerRespawnPacket.class)\npublic class JavaRespawnTranslator extends PacketTranslator<ServerRespawnPacket> {\n\n    @Override\n    public void translate(ServerRespawnPacket packet, GeyserSession session) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        entity.setHealth(entity.getMaxHealth());\n        entity.getAttributes().put(GeyserAttributeType.HEALTH, entity.createHealthAttribute());\n\n        session.setInventoryTranslator(InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR);\n        session.setOpenInventory(null);\n        session.setClosingInventory(false);\n\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(packet.getGamemode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n        session.setGameMode(packet.getGamemode());\n\n        if (session.isRaining()) {\n            LevelEventPacket stopRainPacket = new LevelEventPacket();\n            stopRainPacket.setType(LevelEventType.STOP_RAINING);\n            stopRainPacket.setData(0);\n            stopRainPacket.setPosition(Vector3f.ZERO);\n            session.sendUpstreamPacket(stopRainPacket);\n            session.setRaining(false);\n        }\n\n        if (session.isThunder()) {\n            LevelEventPacket stopThunderPacket = new LevelEventPacket();\n            stopThunderPacket.setType(LevelEventType.STOP_THUNDERSTORM);\n            stopThunderPacket.setData(0);\n            stopThunderPacket.setPosition(Vector3f.ZERO);\n            session.sendUpstreamPacket(stopThunderPacket);\n            session.setThunder(false);\n        }\n\n        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());\n        if (!session.getDimension().equals(newDimension) || !packet.getWorldName().equals(session.getWorldName())) {\n            // Switching to a new world (based off the world name change); send a fake dimension change\n            if (!packet.getWorldName().equals(session.getWorldName()) && (session.getDimension().equals(newDimension)\n                    // Ensure that the player never ever dimension switches to the same dimension - BAD\n                    // Can likely be removed if the Above Bedrock Nether Building option can be removed\n                    || DimensionUtils.javaToBedrock(session.getDimension()) == DimensionUtils.javaToBedrock(newDimension))) {\n                String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);\n                DimensionUtils.switchDimension(session, fakeDim);\n            }\n            session.setWorldName(packet.getWorldName());\n            DimensionUtils.switchDimension(session, newDimension);\n        }\n\n        ChunkUtils.applyDimensionHeight(session, packet.getDimension());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerStatisticsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.StatisticsUtils;\n\n@Translator(packet = ServerStatisticsPacket.class)\npublic class JavaStatisticsTranslator extends PacketTranslator<ServerStatisticsPacket> {\n\n    @Override\n    public void translate(ServerStatisticsPacket packet, GeyserSession session) {\n        session.updateStatistics(packet.getStatistics());\n\n        if (session.isWaitingForStatistics()) {\n            session.setWaitingForStatistics(false);\n            StatisticsUtils.buildAndSendStatisticsMenu(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.UnlockRecipesAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerUnlockRecipesPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Arrays;\n\n/**\n * Used to list recipes that we can definitely use the recipe book for (and therefore save on packet usage)\n */\n@Translator(packet = ServerUnlockRecipesPacket.class)\npublic class JavaUnlockRecipesTranslator extends PacketTranslator<ServerUnlockRecipesPacket> {\n\n    @Override\n    public void translate(ServerUnlockRecipesPacket packet, GeyserSession session) {\n        if (packet.getAction() == UnlockRecipesAction.REMOVE) {\n            session.getUnlockedRecipes().removeAll(Arrays.asList(packet.getRecipes()));\n        } else {\n            session.getUnlockedRecipes().addAll(Arrays.asList(packet.getRecipes()));\n        }\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAnimationPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.AnimateEntityPacket;\nimport com.nukkitx.protocol.bedrock.packet.AnimatePacket;\nimport com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerEntityAnimationPacket.class)\npublic class JavaEntityAnimationTranslator extends PacketTranslator<ServerEntityAnimationPacket> {\n\n    @Override\n    public void translate(ServerEntityAnimationPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        AnimatePacket animatePacket = new AnimatePacket();\n        animatePacket.setRuntimeEntityId(entity.getGeyserId());\n        switch (packet.getAnimation()) {\n            case SWING_ARM:\n                animatePacket.setAction(AnimatePacket.Action.SWING_ARM);\n                break;\n            case EAT_FOOD: // ACTUALLY SWING OFF HAND\n                // Use the OptionalPack to trigger the animation\n                AnimateEntityPacket offHandPacket = new AnimateEntityPacket();\n                offHandPacket.setAnimation(\"animation.player.attack.rotations.offhand\");\n                offHandPacket.setNextState(\"default\");\n                offHandPacket.setBlendOutTime(0.0f);\n                offHandPacket.setStopExpression(\"query.any_animation_finished\");\n                offHandPacket.setController(\"__runtime_controller\");\n                offHandPacket.getRuntimeEntityIds().add(entity.getGeyserId());\n\n                session.sendUpstreamPacket(offHandPacket);\n                return;\n            case CRITICAL_HIT:\n                animatePacket.setAction(AnimatePacket.Action.CRITICAL_HIT);\n                break;\n            case ENCHANTMENT_CRITICAL_HIT:\n                animatePacket.setAction(AnimatePacket.Action.MAGIC_CRITICAL_HIT); // Unsure if this does anything\n                // Spawn custom particle\n                SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();\n                stringPacket.setIdentifier(\"geyseropt:enchanted_hit_multiple\");\n                stringPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n                stringPacket.setPosition(Vector3f.ZERO);\n                stringPacket.setUniqueEntityId(entity.getGeyserId());\n                session.sendUpstreamPacket(stringPacket);\n                break;\n            case LEAVE_BED:\n                animatePacket.setAction(AnimatePacket.Action.WAKE_UP);\n                break;\n            default:\n                // Unknown Animation\n                return;\n        }\n\n        session.sendUpstreamPacket(animatePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAttachPacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.EntityEventPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Called when a leash is attached, removed or updated from an entity\n */\n@Translator(packet = ServerEntityAttachPacket.class)\npublic class JavaEntityAttachTranslator extends PacketTranslator<ServerEntityAttachPacket> {\n\n    @Override\n    public void translate(ServerEntityAttachPacket packet, GeyserSession session) {\n\n        Entity holderId;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            holderId = session.getPlayerEntity();\n        } else {\n            holderId = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n            if (holderId == null) {\n                return;\n            }\n        }\n\n        Entity attachedToId;\n        if (packet.getAttachedToId() == session.getPlayerEntity().getEntityId()) {\n            attachedToId = session.getPlayerEntity();\n        } else {\n            attachedToId = session.getEntityCache().getEntityByJavaId(packet.getAttachedToId());\n            if ((attachedToId == null || packet.getAttachedToId() == 0)) {\n                // Is not being leashed\n                holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, false);\n                holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, -1L);\n                holderId.updateBedrockMetadata(session);\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setRuntimeEntityId(holderId.getGeyserId());\n                eventPacket.setType(EntityEventType.REMOVE_LEASH);\n                eventPacket.setData(0);\n                session.sendUpstreamPacket(eventPacket);\n                return;\n            }\n        }\n\n        holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, true);\n        holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, attachedToId.getGeyserId());\n        holderId.updateBedrockMetadata(session);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityCollectItemPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.TakeItemEntityPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ExpOrbEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * This packet is called whenever a player picks up an item.\n * In Java, this is called for item entities, experience orbs and arrows\n * Bedrock uses it for arrows and item entities, but not experience orbs.\n */\n@Translator(packet = ServerEntityCollectItemPacket.class)\npublic class JavaEntityCollectItemTranslator extends PacketTranslator<ServerEntityCollectItemPacket> {\n\n    @Override\n    public void translate(ServerEntityCollectItemPacket packet, GeyserSession session) {\n        // Collected entity is the other entity\n        Entity collectedEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectedEntityId());\n        if (collectedEntity == null) return;\n        // Collector is the entity 'picking up' the item\n        Entity collectorEntity;\n        if (packet.getCollectorEntityId() == session.getPlayerEntity().getEntityId()) {\n            collectorEntity = session.getPlayerEntity();\n        } else {\n            collectorEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectorEntityId());\n        }\n        if (collectorEntity == null) return;\n        if (collectedEntity instanceof ExpOrbEntity) {\n            // Player just picked up an experience orb\n            LevelEventPacket xpPacket = new LevelEventPacket();\n            xpPacket.setType(LevelEventType.SOUND_EXPERIENCE_ORB_PICKUP);\n            xpPacket.setPosition(collectedEntity.getPosition());\n            xpPacket.setData(0);\n            session.sendUpstreamPacket(xpPacket);\n        } else {\n            // Item is being picked up (visual only)\n            TakeItemEntityPacket takeItemEntityPacket = new TakeItemEntityPacket();\n            takeItemEntityPacket.setRuntimeEntityId(collectorEntity.getGeyserId());\n            takeItemEntityPacket.setItemRuntimeEntityId(collectedEntity.getGeyserId());\n            session.sendUpstreamPacket(takeItemEntityPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEffectPacket;\nimport com.nukkitx.protocol.bedrock.packet.MobEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\n@Translator(packet = ServerEntityEffectPacket.class)\npublic class JavaEntityEffectTranslator extends PacketTranslator<ServerEntityEffectPacket> {\n\n    @Override\n    public void translate(ServerEntityEffectPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        MobEffectPacket mobEffectPacket = new MobEffectPacket();\n        mobEffectPacket.setAmplifier(packet.getAmplifier());\n        mobEffectPacket.setDuration(packet.getDuration());\n        mobEffectPacket.setEvent(MobEffectPacket.Event.ADD);\n        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());\n        mobEffectPacket.setParticles(packet.isShowParticles());\n        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));\n        session.sendUpstreamPacket(mobEffectPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Equipment;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEquipmentPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\n\n@Translator(packet = ServerEntityEquipmentPacket.class)\npublic class JavaEntityEquipmentTranslator extends PacketTranslator<ServerEntityEquipmentPacket> {\n\n    @Override\n    public void translate(ServerEntityEquipmentPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n\n        if (entity == null)\n            return;\n\n        if (!(entity instanceof LivingEntity)) {\n            session.getConnector().getLogger().debug(\"Attempted to add armor to a non-living entity type (\" +\n                    entity.getEntityType().name() + \").\");\n            return;\n        }\n\n        boolean armorUpdated = false;\n        boolean mainHandUpdated = false;\n        boolean offHandUpdated = false;\n        LivingEntity livingEntity = (LivingEntity) entity;\n        for (Equipment equipment : packet.getEquipment()) {\n            ItemData item = ItemTranslator.translateToBedrock(session, equipment.getItem());\n            switch (equipment.getSlot()) {\n                case HELMET:\n                    livingEntity.setHelmet(item);\n                    armorUpdated = true;\n                    break;\n                case CHESTPLATE:\n                    livingEntity.setChestplate(item);\n                    armorUpdated = true;\n                    break;\n                case LEGGINGS:\n                    livingEntity.setLeggings(item);\n                    armorUpdated = true;\n                    break;\n                case BOOTS:\n                    livingEntity.setBoots(item);\n                    armorUpdated = true;\n                    break;\n                case MAIN_HAND:\n                    livingEntity.setHand(item);\n                    mainHandUpdated = true;\n                    break;\n                case OFF_HAND:\n                    livingEntity.setOffHand(item);\n                    offHandUpdated = true;\n                    break;\n            }\n        }\n\n        if (armorUpdated) {\n            livingEntity.updateArmor(session);\n        }\n        if (mainHandUpdated) {\n            livingEntity.updateMainHand(session);\n        }\n        if (offHandUpdated) {\n            livingEntity.updateOffHand(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityHeadLookPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityHeadLookPacket.class)\npublic class JavaEntityHeadLookTranslator extends PacketTranslator<ServerEntityHeadLookPacket> {\n\n    @Override\n    public void translate(ServerEntityHeadLookPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n\n        if (entity == null) return;\n\n        entity.updateHeadLookRotation(session, packet.getHeadYaw());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.EntityMetadata;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityMetadataPacket;\nimport org.geysermc.connector.utils.InteractiveTagManager;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerEntityMetadataPacket.class)\npublic class JavaEntityMetadataTranslator extends PacketTranslator<ServerEntityMetadataPacket> {\n\n    @Override\n    public void translate(ServerEntityMetadataPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null) return;\n\n        for (EntityMetadata metadata : packet.getMetadata()) {\n            try {\n                entity.updateBedrockMetadata(metadata, session);\n            } catch (ClassCastException e) {\n                // Class cast exceptions are really the only ones we're going to get in normal gameplay\n                // Because some entity rewriters forget about some values\n                // Any other errors are actual bugs\n                session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.metadata.failed\", metadata, entity.getEntityType()));\n                session.getConnector().getLogger().debug(\"Entity Java ID: \" + entity.getEntityId() + \", Geyser ID: \" + entity.getGeyserId());\n                if (session.getConnector().getConfig().isDebugMode()) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        entity.updateBedrockMetadata(session);\n\n        // Update the interactive tag, if necessary\n        if (session.getMouseoverEntity() != null && session.getMouseoverEntity().getEntityId() == entity.getEntityId()) {\n            InteractiveTagManager.updateTag(session, entity);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionRotationPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPositionRotationPacket.class)\npublic class JavaEntityPositionRotationTranslator extends PacketTranslator<ServerEntityPositionRotationPacket> {\n\n    @Override\n    public void translate(ServerEntityPositionRotationPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.updatePositionAndRotation(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPositionPacket.class)\npublic class JavaEntityPositionTranslator extends PacketTranslator<ServerEntityPositionPacket> {\n\n    @Override\n    public void translate(ServerEntityPositionPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.moveRelative(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), entity.getRotation(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPropertiesPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPropertiesPacket.class)\npublic class JavaEntityPropertiesTranslator extends PacketTranslator<ServerEntityPropertiesPacket> {\n\n    @Override\n    public void translate(ServerEntityPropertiesPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (!(entity instanceof LivingEntity)) return;\n\n        ((LivingEntity) entity).updateBedrockAttributes(session, packet.getAttributes());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRemoveEffectPacket;\nimport com.nukkitx.protocol.bedrock.packet.MobEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\n@Translator(packet = ServerEntityRemoveEffectPacket.class)\npublic class JavaEntityRemoveEffectTranslator extends PacketTranslator<ServerEntityRemoveEffectPacket> {\n\n    @Override\n    public void translate(ServerEntityRemoveEffectPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n            session.getEffectCache().removeEffect(packet.getEffect());\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        MobEffectPacket mobEffectPacket = new MobEffectPacket();\n        mobEffectPacket.setEvent(MobEffectPacket.Event.REMOVE);\n        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());\n        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));\n        session.sendUpstreamPacket(mobEffectPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRotationPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityRotationPacket.class)\npublic class JavaEntityRotationTranslator extends PacketTranslator<ServerEntityRotationPacket> {\n\n    @Override\n    public void translate(ServerEntityRotationPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.updateRotation(session, packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntitySetPassengersPacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;\nimport it.unimi.dsi.fastutil.longs.LongOpenHashSet;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\nimport java.util.Arrays;\n\n@Translator(packet = ServerEntitySetPassengersPacket.class)\npublic class JavaEntitySetPassengersTranslator extends PacketTranslator<ServerEntitySetPassengersPacket> {\n\n    @Override\n    public void translate(ServerEntitySetPassengersPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n\n        if (entity == null) return;\n\n        LongOpenHashSet passengers = entity.getPassengers().clone();\n        boolean rider = true;\n        for (long passengerId : packet.getPassengerIds()) {\n            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);\n            if (passengerId == session.getPlayerEntity().getEntityId()) {\n                passenger = session.getPlayerEntity();\n                session.setRidingVehicleEntity(entity);\n                // We need to confirm teleports before entering a vehicle, or else we will likely exit right out\n                session.confirmTeleport(passenger.getPosition().sub(0, EntityType.PLAYER.getOffset(), 0).toDouble());\n            }\n            // Passenger hasn't loaded in (likely since we're waiting for a skin response)\n            // and entity link needs to be set later\n            if (passenger == null && passengerId != 0) {\n                session.getEntityCache().addCachedPlayerEntityLink(passengerId, packet.getEntityId());\n            }\n            if (passenger == null) {\n                continue;\n            }\n\n            EntityLinkData.Type type = rider ? EntityLinkData.Type.RIDER : EntityLinkData.Type.PASSENGER;\n            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n            linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), type, false));\n            session.sendUpstreamPacket(linkPacket);\n            passengers.add(passengerId);\n\n            // Head rotation on boats\n            if (entity.getEntityType() == EntityType.BOAT) {\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 1);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 90f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 1f);\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, -90f);\n            } else {\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n            }\n\n            passenger.updateBedrockMetadata(session);\n            rider = false;\n        }\n\n        entity.setPassengers(passengers);\n\n        for (long passengerId : entity.getPassengers()) {\n            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);\n            if (passengerId == session.getPlayerEntity().getEntityId()) {\n                passenger = session.getPlayerEntity();\n            }\n            if (passenger == null) {\n                continue;\n            }\n            if (Arrays.stream(packet.getPassengerIds()).noneMatch(id -> id == passengerId)) {\n                SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n                linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), EntityLinkData.Type.REMOVE, false));\n                session.sendUpstreamPacket(linkPacket);\n                passengers.remove(passenger.getEntityId());\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);\n\n                EntityUtils.updateMountOffset(passenger, entity, session, false, false, (packet.getPassengerIds().length > 1));\n            } else {\n                EntityUtils.updateMountOffset(passenger, entity, session, (packet.getPassengerIds()[0] == passengerId), true, (packet.getPassengerIds().length > 1));\n            }\n\n            // Force an update to the passenger metadata\n            passenger.updateBedrockMetadata(session);\n        }\n\n        switch (entity.getEntityType()) {\n            case HORSE:\n            case SKELETON_HORSE:\n            case DONKEY:\n            case MULE:\n            case RAVAGER:\n                entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 181.0f);\n                entity.updateBedrockMetadata(session);\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityStatusPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityStatusPacket.class)\npublic class JavaEntityStatusTranslator extends PacketTranslator<ServerEntityStatusPacket> {\n\n    @Override\n    public void translate(ServerEntityStatusPacket packet, GeyserSession session) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        EntityEventPacket entityEventPacket = new EntityEventPacket();\n        entityEventPacket.setRuntimeEntityId(entity.getGeyserId());\n        switch (packet.getStatus()) {\n            case PLAYER_ENABLE_REDUCED_DEBUG:\n                session.setReducedDebugInfo(true);\n                return;\n            case PLAYER_DISABLE_REDUCED_DEBUG:\n                session.setReducedDebugInfo(false);\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_0:\n                session.setOpPermissionLevel(0);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_1:\n                session.setOpPermissionLevel(1);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_2:\n                session.setOpPermissionLevel(2);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_3:\n                session.setOpPermissionLevel(3);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_4:\n                session.setOpPermissionLevel(4);\n                session.sendAdventureSettings();\n                return;\n\n            // EntityEventType.HURT sends extra data depending on the type of damage. However this appears to have no visual changes\n            case LIVING_BURN:\n            case LIVING_DROWN:\n            case LIVING_HURT:\n            case LIVING_HURT_SWEET_BERRY_BUSH:\n            case LIVING_HURT_THORNS:\n            case LIVING_FREEZE:\n                entityEventPacket.setType(EntityEventType.HURT);\n                break;\n            case LIVING_DEATH:\n                entityEventPacket.setType(EntityEventType.DEATH);\n                if (entity.getEntityType() == EntityType.THROWN_EGG) {\n                    LevelEventPacket particlePacket = new LevelEventPacket();\n                    particlePacket.setType(LevelEventType.PARTICLE_ITEM_BREAK);\n                    particlePacket.setData(session.getItemMappings().getStoredItems().egg().getBedrockId() << 16);\n                    particlePacket.setPosition(entity.getPosition());\n                    for (int i = 0; i < 6; i++) {\n                        session.sendUpstreamPacket(particlePacket);\n                    }\n                } else if (entity.getEntityType() == EntityType.SNOWBALL) {\n                    LevelEventPacket particlePacket = new LevelEventPacket();\n                    particlePacket.setType(LevelEventType.PARTICLE_SNOWBALL_POOF);\n                    particlePacket.setPosition(entity.getPosition());\n                    for (int i = 0; i < 8; i++) {\n                        session.sendUpstreamPacket(particlePacket);\n                    }\n                }\n                break;\n            case WOLF_SHAKE_WATER:\n                entityEventPacket.setType(EntityEventType.SHAKE_WETNESS);\n                break;\n            case PLAYER_FINISH_USING_ITEM:\n                entityEventPacket.setType(EntityEventType.USE_ITEM);\n                break;\n            case FISHING_HOOK_PULL_PLAYER:\n                // Player is pulled from a fishing rod\n                // The physics of this are clientside on Java\n                long pulledById = entity.getMetadata().getLong(EntityData.TARGET_EID);\n                if (session.getPlayerEntity().getGeyserId() == pulledById) {\n                    Entity hookOwner = session.getEntityCache().getEntityByGeyserId(entity.getMetadata().getLong(EntityData.OWNER_EID));\n                    if (hookOwner != null) {\n                        // https://minecraft.gamepedia.com/Fishing_Rod#Hooking_mobs_and_other_entities\n                        SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();\n                        motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n                        motionPacket.setMotion(hookOwner.getPosition().sub(session.getPlayerEntity().getPosition()).mul(0.1f));\n                        session.sendUpstreamPacket(motionPacket);\n                    }\n                }\n                return;\n            case TAMEABLE_TAMING_FAILED:\n                entityEventPacket.setType(EntityEventType.TAME_FAILED);\n                break;\n            case TAMEABLE_TAMING_SUCCEEDED:\n                entityEventPacket.setType(EntityEventType.TAME_SUCCEEDED);\n                break;\n            case ZOMBIE_VILLAGER_CURE: // Played when a zombie bites the golden apple\n                LevelSoundEvent2Packet soundPacket = new LevelSoundEvent2Packet();\n                soundPacket.setSound(SoundEvent.REMEDY);\n                soundPacket.setPosition(entity.getPosition());\n                soundPacket.setExtraData(-1);\n                soundPacket.setIdentifier(\"\");\n                soundPacket.setRelativeVolumeDisabled(false);\n                session.sendUpstreamPacket(soundPacket);\n                return;\n            case ANIMAL_EMIT_HEARTS:\n                entityEventPacket.setType(EntityEventType.LOVE_PARTICLES);\n                break;\n            case FIREWORK_EXPLODE:\n                entityEventPacket.setType(EntityEventType.FIREWORK_EXPLODE);\n                break;\n            case WITCH_EMIT_PARTICLES:\n                entityEventPacket.setType(EntityEventType.WITCH_HAT_MAGIC); //TODO: CHECK\n                break;\n            case TOTEM_OF_UNDYING_MAKE_SOUND:\n                entityEventPacket.setType(EntityEventType.CONSUME_TOTEM);\n                break;\n            case SHEEP_GRAZE_OR_TNT_CART_EXPLODE:\n                if (entity.getEntityType() == EntityType.SHEEP) {\n                    entityEventPacket.setType(EntityEventType.EAT_GRASS);\n                } else {\n                    entityEventPacket.setType(EntityEventType.PRIME_TNT_MINECART);\n                }\n                break;\n            case IRON_GOLEM_HOLD_POPPY:\n                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_OFFER);\n                break;\n            case IRON_GOLEM_EMPTY_HAND:\n                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_WITHDRAW);\n                break;\n            case IRON_GOLEM_ATTACK:\n                if (entity.getEntityType() == EntityType.IRON_GOLEM) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_START);\n                }\n                break;\n            case RABBIT_JUMP_OR_MINECART_SPAWNER_DELAY_RESET:\n                if (entity.getEntityType() == EntityType.RABBIT) {\n                    // This doesn't match vanilla Bedrock behavior but I'm unsure how to make it better\n                    // I assume part of the problem is that Bedrock uses a duration and Java just says the rabbit is jumping\n                    SetEntityDataPacket dataPacket = new SetEntityDataPacket();\n                    dataPacket.getMetadata().put(EntityData.JUMP_DURATION, (byte) 3);\n                    dataPacket.setRuntimeEntityId(entity.getGeyserId());\n                    session.sendUpstreamPacket(dataPacket);\n                    return;\n                }\n                break;\n            case LIVING_EQUIPMENT_BREAK_HEAD:\n            case LIVING_EQUIPMENT_BREAK_CHEST:\n            case LIVING_EQUIPMENT_BREAK_LEGS:\n            case LIVING_EQUIPMENT_BREAK_FEET:\n            case LIVING_EQUIPMENT_BREAK_MAIN_HAND:\n            case LIVING_EQUIPMENT_BREAK_OFF_HAND:\n                LevelSoundEvent2Packet equipmentBreakPacket = new LevelSoundEvent2Packet();\n                equipmentBreakPacket.setSound(SoundEvent.BREAK);\n                equipmentBreakPacket.setPosition(entity.getPosition());\n                equipmentBreakPacket.setExtraData(-1);\n                equipmentBreakPacket.setIdentifier(\"\");\n                session.sendUpstreamPacket(equipmentBreakPacket);\n                return;\n            case PLAYER_SWAP_SAME_ITEM: // Not just used for players\n                if (entity instanceof LivingEntity) {\n                    LivingEntity livingEntity = (LivingEntity) entity;\n                    ItemData newMainHand = livingEntity.getOffHand();\n                    livingEntity.setOffHand(livingEntity.getHand());\n                    livingEntity.setHand(newMainHand);\n\n                    livingEntity.updateMainHand(session);\n                    livingEntity.updateOffHand(session);\n                } else {\n                    session.getConnector().getLogger().debug(\"Got status message to swap hands for a non-living entity.\");\n                }\n                return;\n            case GOAT_LOWERING_HEAD:\n                if (entity.getEntityType() == EntityType.GOAT) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_START);\n                }\n                break;\n            case GOAT_STOP_LOWERING_HEAD:\n                if (entity.getEntityType() == EntityType.GOAT) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_STOP);\n                }\n                break;\n            case MAKE_POOF_PARTICLES:\n                if (entity instanceof LivingEntity) {\n                    entityEventPacket.setType(EntityEventType.DEATH_SMOKE_CLOUD);\n                }\n                break;\n        }\n\n        if (entityEventPacket.getType() != null) {\n            session.sendUpstreamPacket(entityEventPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityTeleportPacket;\nimport com.nukkitx.math.vector.Vector3f;\n\n@Translator(packet = ServerEntityTeleportPacket.class)\npublic class JavaEntityTeleportTranslator extends PacketTranslator<ServerEntityTeleportPacket> {\n\n    @Override\n    public void translate(ServerEntityTeleportPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.teleport(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemEntity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityVelocityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;\n\n@Translator(packet = ServerEntityVelocityPacket.class)\npublic class JavaEntityVelocityTranslator extends PacketTranslator<ServerEntityVelocityPacket> {\n\n    @Override\n    public void translate(ServerEntityVelocityPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.setMotion(Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ()));\n\n        if (entity == session.getRidingVehicleEntity() && entity instanceof AbstractHorseEntity) {\n            // Horses for some reason teleport back when a SetEntityMotionPacket is sent while\n            // a player is riding on them. Java clients seem to ignore it anyways.\n            return;\n        }\n\n        if (entity instanceof ItemEntity) {\n            // Don't bother sending entity motion packets for items\n            // since the client doesn't seem to care\n            return;\n        }\n\n        SetEntityMotionPacket entityMotionPacket = new SetEntityMotionPacket();\n        entityMotionPacket.setRuntimeEntityId(entity.getGeyserId());\n        entityMotionPacket.setMotion(entity.getMotion());\n\n        session.sendUpstreamPacket(entityMotionPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerRemoveEntitiesPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerRemoveEntitiesPacket.class)\npublic class JavaRemoveEntitiesTranslator extends PacketTranslator<ServerRemoveEntitiesPacket> {\n\n    @Override\n    public void translate(ServerRemoveEntitiesPacket packet, GeyserSession session) {\n        for (int entityId : packet.getEntityIds()) {\n            Entity entity = session.getEntityCache().getEntityByJavaId(entityId);\n            if (entity != null) {\n                session.getEntityCache().removeEntity(entity, false);\n            }\n        }\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerAbilitiesPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerPlayerAbilitiesPacket.class)\npublic class JavaPlayerAbilitiesTranslator extends PacketTranslator<ServerPlayerAbilitiesPacket> {\n\n    @Override\n    public void translate(ServerPlayerAbilitiesPacket packet, GeyserSession session) {\n        session.setCanFly(packet.isCanFly());\n        session.setFlying(packet.isFlying());\n        session.sendAdventureSettings();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerActionAckPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerPlayerActionAckPacket.class)\npublic class JavaPlayerActionAckTranslator extends PacketTranslator<ServerPlayerActionAckPacket> {\n\n    @Override\n    public void translate(ServerPlayerActionAckPacket packet, GeyserSession session) {\n        ChunkUtils.updateBlock(session, packet.getNewState(), packet.getPosition());\n        if (packet.getAction() == PlayerAction.START_DIGGING && !packet.isSuccessful()) {\n            LevelEventPacket stopBreak = new LevelEventPacket();\n            stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);\n            stopBreak.setPosition(Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n            stopBreak.setData(0);\n            session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n            session.sendUpstreamPacket(stopBreak);\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerChangeHeldItemPacket;\nimport com.nukkitx.protocol.bedrock.packet.PlayerHotbarPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerPlayerChangeHeldItemPacket.class)\npublic class JavaPlayerChangeHeldItemTranslator extends PacketTranslator<ServerPlayerChangeHeldItemPacket> {\n\n    @Override\n    public void translate(ServerPlayerChangeHeldItemPacket packet, GeyserSession session) {\n        PlayerHotbarPacket hotbarPacket = new PlayerHotbarPacket();\n        hotbarPacket.setContainerId(0);\n        hotbarPacket.setSelectedHotbarSlot(packet.getSlot());\n        hotbarPacket.setSelectHotbarSlot(true);\n        session.sendUpstreamPacket(hotbarPacket);\n\n        session.getPlayerInventory().setHeldItemSlot(packet.getSlot());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerHealthPacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.SetHealthPacket;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.List;\n\n@Translator(packet = ServerPlayerHealthPacket.class)\npublic class JavaPlayerHealthTranslator extends PacketTranslator<ServerPlayerHealthPacket> {\n\n    @Override\n    public void translate(ServerPlayerHealthPacket packet, GeyserSession session) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        int health = (int) Math.ceil(packet.getHealth());\n        SetHealthPacket setHealthPacket = new SetHealthPacket();\n        setHealthPacket.setHealth(health);\n        session.sendUpstreamPacket(setHealthPacket);\n\n        entity.setHealth(packet.getHealth());\n\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        List<AttributeData> attributes = attributesPacket.getAttributes();\n\n        AttributeData healthAttribute = entity.createHealthAttribute();\n        entity.getAttributes().put(GeyserAttributeType.HEALTH, healthAttribute);\n        attributes.add(healthAttribute);\n\n        AttributeData hungerAttribute = GeyserAttributeType.HUNGER.getAttribute(packet.getFood());\n        entity.getAttributes().put(GeyserAttributeType.HUNGER, hungerAttribute);\n        attributes.add(hungerAttribute);\n\n        AttributeData saturationAttribute = GeyserAttributeType.SATURATION.getAttribute(packet.getSaturation());\n        entity.getAttributes().put(GeyserAttributeType.SATURATION, saturationAttribute);\n        attributes.add(saturationAttribute);\n\n        attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n        session.sendUpstreamPacket(attributesPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.PlayerListEntry;\nimport com.github.steveice10.mc.protocol.data.game.PlayerListEntryAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListEntryPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.PlayerListPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = ServerPlayerListEntryPacket.class)\npublic class JavaPlayerListEntryTranslator extends PacketTranslator<ServerPlayerListEntryPacket> {\n    @Override\n    public void translate(ServerPlayerListEntryPacket packet, GeyserSession session) {\n        if (packet.getAction() != PlayerListEntryAction.ADD_PLAYER && packet.getAction() != PlayerListEntryAction.REMOVE_PLAYER)\n            return;\n\n        PlayerListPacket translate = new PlayerListPacket();\n        translate.setAction(packet.getAction() == PlayerListEntryAction.ADD_PLAYER ? PlayerListPacket.Action.ADD : PlayerListPacket.Action.REMOVE);\n\n        for (PlayerListEntry entry : packet.getEntries()) {\n            switch (packet.getAction()) {\n                case ADD_PLAYER:\n                    PlayerEntity playerEntity;\n                    boolean self = entry.getProfile().getId().equals(session.getPlayerEntity().getUuid());\n\n                    if (self) {\n                        // Entity is ourself\n                        playerEntity = session.getPlayerEntity();\n                    } else {\n                        playerEntity = session.getEntityCache().getPlayerEntity(entry.getProfile().getId());\n                    }\n\n                    if (playerEntity == null) {\n                        // It's a new player\n                        playerEntity = new PlayerEntity(\n                                entry.getProfile(),\n                                -1,\n                                session.getEntityCache().getNextEntityId().incrementAndGet(),\n                                Vector3f.ZERO,\n                                Vector3f.ZERO,\n                                Vector3f.ZERO\n                        );\n\n                        session.getEntityCache().addPlayerEntity(playerEntity);\n                    } else {\n                        playerEntity.setProfile(entry.getProfile());\n                    }\n\n                    playerEntity.setPlayerList(true);\n\n                    // We'll send our own PlayerListEntry in requestAndHandleSkinAndCape\n                    // But we need to send other player's entries so they show up in the player list\n                    // without processing their skin information - that'll be processed when they spawn in\n                    if (self) {\n                        SkinManager.requestAndHandleSkinAndCape(playerEntity, session, skinAndCape ->\n                                GeyserConnector.getInstance().getLogger().debug(\"Loaded Local Bedrock Java Skin Data for \" + session.getClientData().getUsername()));\n                    } else {\n                        playerEntity.setValid(true);\n                        PlayerListPacket.Entry playerListEntry = SkinManager.buildCachedEntry(session, playerEntity);\n\n                        translate.getEntries().add(playerListEntry);\n                    }\n                    break;\n                case REMOVE_PLAYER:\n                    // As the player entity is no longer present, we can remove the entry\n                    PlayerEntity entity = session.getEntityCache().removePlayerEntity(entry.getProfile().getId());\n                    if (entity != null) {\n                        // Just remove the entity's player list status\n                        // Don't despawn the entity - the Java server will also take care of that.\n                        entity.setPlayerList(false);\n                    }\n                    if (entity == session.getPlayerEntity()) {\n                        // If removing ourself we use our AuthData UUID\n                        translate.getEntries().add(new PlayerListPacket.Entry(session.getAuthData().getUUID()));\n                    } else {\n                        translate.getEntries().add(new PlayerListPacket.Entry(entry.getProfile().getId()));\n                    }\n                    break;\n            }\n        }\n\n        if (!translate.getEntries().isEmpty() && (packet.getAction() == PlayerListEntryAction.REMOVE_PLAYER || session.getUpstream().isInitialized())) {\n            session.sendUpstreamPacket(translate);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PositionElement;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientTeleportConfirmPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerPositionRotationPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport com.nukkitx.protocol.bedrock.packet.RespawnPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.TeleportCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerPlayerPositionRotationPacket.class)\npublic class JavaPlayerPositionRotationTranslator extends PacketTranslator<ServerPlayerPositionRotationPacket> {\n\n    @Override\n    public void translate(ServerPlayerPositionRotationPacket packet, GeyserSession session) {\n        if (!session.isLoggedIn())\n            return;\n\n        PlayerEntity entity = session.getPlayerEntity();\n\n        if (!session.isSpawned()) {\n            Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n            entity.setPosition(pos);\n            entity.setRotation(Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw()));\n\n            RespawnPacket respawnPacket = new RespawnPacket();\n            respawnPacket.setRuntimeEntityId(0); // Bedrock server behavior\n            respawnPacket.setPosition(entity.getPosition());\n            respawnPacket.setState(RespawnPacket.State.SERVER_READY);\n            session.sendUpstreamPacket(respawnPacket);\n\n            SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n            entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n            entityDataPacket.getMetadata().putAll(entity.getMetadata());\n            session.sendUpstreamPacket(entityDataPacket);\n\n            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n            movePlayerPacket.setPosition(entity.getPosition());\n            movePlayerPacket.setRotation(Vector3f.from(packet.getPitch(), packet.getYaw(), 0));\n            movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);\n\n            session.sendUpstreamPacket(movePlayerPacket);\n            session.setSpawned(true);\n\n            ClientTeleportConfirmPacket teleportConfirmPacket = new ClientTeleportConfirmPacket(packet.getTeleportId());\n            session.sendDownstreamPacket(teleportConfirmPacket);\n\n            ChunkUtils.updateChunkPosition(session, pos.toInt());\n\n            session.getConnector().getLogger().debug(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.spawn\", packet.getX(), packet.getY(), packet.getZ()));\n            return;\n        }\n\n        session.setSpawned(true);\n\n        if (packet.isDismountVehicle() && session.getRidingVehicleEntity() != null) {\n            Entity vehicle = session.getRidingVehicleEntity();\n            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n            linkPacket.setEntityLink(new EntityLinkData(vehicle.getGeyserId(), entity.getGeyserId(), EntityLinkData.Type.REMOVE, false, false));\n            session.sendUpstreamPacket(linkPacket);\n            vehicle.getPassengers().remove(entity.getEntityId());\n            entity.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n            entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n            entity.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n            entity.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);\n            session.setRidingVehicleEntity(null);\n            entity.updateBedrockMetadata(session);\n\n            EntityUtils.updateMountOffset(entity, vehicle, session, false, false, entity.getPassengers().size() > 1);\n        }\n\n        // If coordinates are relative, then add to the existing coordinate\n        double newX = packet.getX() +\n                (packet.getRelative().contains(PositionElement.X) ? entity.getPosition().getX() : 0);\n        double newY = packet.getY() +\n                (packet.getRelative().contains(PositionElement.Y) ? entity.getPosition().getY() - EntityType.PLAYER.getOffset() : 0);\n        double newZ = packet.getZ() +\n                (packet.getRelative().contains(PositionElement.Z) ? entity.getPosition().getZ() : 0);\n\n        float newPitch = packet.getPitch() +\n                (packet.getRelative().contains(PositionElement.PITCH) ? entity.getBedrockRotation().getX() : 0);\n        float newYaw = packet.getYaw() +\n                (packet.getRelative().contains(PositionElement.YAW) ? entity.getBedrockRotation().getY() : 0);\n\n        session.getConnector().getLogger().debug(\"Teleport from \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());\n\n        session.addTeleport(new TeleportCache(newX, newY, newZ, newPitch, newYaw, packet.getTeleportId()));\n\n        Vector3f lastPlayerPosition = entity.getPosition().down(EntityType.PLAYER.getOffset());\n        float lastPlayerPitch = entity.getBedrockRotation().getX();\n        Vector3f teleportDestination = Vector3f.from(newX, newY, newZ);\n        entity.moveAbsolute(session, teleportDestination, newYaw, newPitch, true, true);\n\n        session.getConnector().getLogger().debug(\"to \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());\n\n        // Bedrock ignores teleports that are extremely close to the player's original position and orientation,\n        // so check if we can immediately confirm the teleport\n        if (lastPlayerPosition.distanceSquared(teleportDestination) < 0.001 && Math.abs(newPitch - lastPlayerPitch) < 5) {\n            session.confirmTeleport(lastPlayerPosition.toDouble());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerSetExperiencePacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Arrays;\n\n@Translator(packet = ServerPlayerSetExperiencePacket.class)\npublic class JavaPlayerSetExperienceTranslator extends PacketTranslator<ServerPlayerSetExperiencePacket> {\n\n    @Override\n    public void translate(ServerPlayerSetExperiencePacket packet, GeyserSession session) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        AttributeData experience = GeyserAttributeType.EXPERIENCE.getAttribute(packet.getExperience());\n        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE, experience);\n        AttributeData experienceLevel = GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(packet.getLevel());\n        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE_LEVEL, experienceLevel);\n\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n        attributesPacket.setAttributes(Arrays.asList(experience, experienceLevel));\n        session.sendUpstreamPacket(attributesPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.object.FallingBlockData;\nimport com.github.steveice10.mc.protocol.data.game.entity.object.HangingDirection;\nimport com.github.steveice10.mc.protocol.data.game.entity.object.ProjectileData;\nimport com.github.steveice10.mc.protocol.data.game.entity.type.EntityType;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnEntityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.*;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n@Translator(packet = ServerSpawnEntityPacket.class)\npublic class JavaSpawnEntityTranslator extends PacketTranslator<ServerSpawnEntityPacket> {\n\n    @Override\n    public void translate(ServerSpawnEntityPacket packet, GeyserSession session) {\n\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), 0);\n\n        org.geysermc.connector.entity.type.EntityType type = EntityUtils.toBedrockEntity(packet.getType());\n        if (type == null) {\n            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));\n            return;\n        }\n\n        Class<? extends Entity> entityClass = type.getEntityClass();\n        try {\n            Entity entity;\n            if (packet.getType() == EntityType.FALLING_BLOCK) {\n                entity = new FallingBlockEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation, ((FallingBlockData) packet.getData()).getId());\n            } else if (packet.getType() == EntityType.ITEM_FRAME || packet.getType() == EntityType.GLOW_ITEM_FRAME) {\n                // Item frames need the hanging direction\n                entity = new ItemFrameEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation, (HangingDirection) packet.getData());\n            } else if (packet.getType() == EntityType.FISHING_BOBBER) {\n                // Fishing bobbers need the owner for the line\n                int ownerEntityId = ((ProjectileData) packet.getData()).getOwnerId();\n                Entity owner = session.getEntityCache().getEntityByJavaId(ownerEntityId);\n                if (owner == null && session.getPlayerEntity().getEntityId() == ownerEntityId) {\n                    owner = session.getPlayerEntity();\n                }\n                // Java clients only spawn fishing hooks with a player as its owner\n                if (owner instanceof PlayerEntity) {\n                    entity = new FishingHookEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                            type, position, motion, rotation, (PlayerEntity) owner);\n                } else {\n                    return;\n                }\n            } else if (packet.getType() == EntityType.BOAT) {\n                // Initial rotation is incorrect\n                entity = new BoatEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, Vector3f.from(packet.getYaw(), 0, packet.getYaw()));\n            } else {\n                Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, org.geysermc.connector.entity.type.EntityType.class,\n                        Vector3f.class, Vector3f.class, Vector3f.class);\n\n                entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation\n                );\n            }\n            session.getEntityCache().spawnEntity(entity);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ExpOrbEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnExpOrbPacket;\nimport com.nukkitx.math.vector.Vector3f;\n\n@Translator(packet = ServerSpawnExpOrbPacket.class)\npublic class JavaSpawnExpOrbTranslator extends PacketTranslator<ServerSpawnExpOrbPacket> {\n\n    @Override\n    public void translate(ServerSpawnExpOrbPacket packet, GeyserSession session) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n\n        Entity entity = new ExpOrbEntity(\n                packet.getExp(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                EntityType.EXPERIENCE_ORB, position, Vector3f.ZERO, Vector3f.ZERO\n        );\n\n        session.getEntityCache().spawnEntity(entity);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnLivingEntityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n@Translator(packet = ServerSpawnLivingEntityPacket.class)\npublic class JavaSpawnLivingEntityTranslator extends PacketTranslator<ServerSpawnLivingEntityPacket> {\n\n    @Override\n    public void translate(ServerSpawnLivingEntityPacket packet, GeyserSession session) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getHeadYaw());\n\n        EntityType type = EntityUtils.toBedrockEntity(packet.getType());\n        if (type == null) {\n            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));\n            return;\n        }\n\n        Class<? extends Entity> entityClass = type.getEntityClass();\n        try {\n            Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, EntityType.class,\n                    Vector3f.class, Vector3f.class, Vector3f.class);\n\n            Entity entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                    type, position, motion, rotation\n            );\n            session.getEntityCache().spawnEntity(entity);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPaintingPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.PaintingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.PaintingType;\n\n@Translator(packet = ServerSpawnPaintingPacket.class)\npublic class JavaSpawnPaintingTranslator extends PacketTranslator<ServerSpawnPaintingPacket> {\n\n    @Override\n    public void translate(ServerSpawnPaintingPacket packet, GeyserSession session) {\n        Vector3f position = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n\n        PaintingEntity entity = new PaintingEntity(packet.getEntityId(),\n                session.getEntityCache().getNextEntityId().incrementAndGet(),\n                position, PaintingType.getByPaintingType(packet.getPaintingType()), packet.getDirection().ordinal());\n\n        session.getEntityCache().spawnEntity(entity);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPlayerPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.LanguageUtils;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = ServerSpawnPlayerPacket.class)\npublic class JavaSpawnPlayerTranslator extends PacketTranslator<ServerSpawnPlayerPacket> {\n\n    @Override\n    public void translate(ServerSpawnPlayerPacket packet, GeyserSession session) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw());\n\n        PlayerEntity entity;\n        if (packet.getUuid().equals(session.getPlayerEntity().getUuid())) {\n            // Server is sending a fake version of the current player\n            entity = new PlayerEntity(session.getPlayerEntity().getProfile(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(), position, Vector3f.ZERO, rotation);\n        } else {\n            entity = session.getEntityCache().getPlayerEntity(packet.getUuid());\n            if (entity == null) {\n                GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.failed_list\", packet.getUuid()));\n                return;\n            }\n\n            entity.setEntityId(packet.getEntityId());\n            entity.setPosition(position);\n            entity.setRotation(rotation);\n        }\n        session.getEntityCache().cacheEntity(entity);\n\n        entity.sendPlayer(session);\n        SkinManager.requestAndHandleSkinAndCape(entity, session, null);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerDisplayScoreboardPacket;\n\n@Translator(packet = ServerDisplayScoreboardPacket.class)\npublic class JavaDisplayScoreboardTranslator extends PacketTranslator<ServerDisplayScoreboardPacket> {\n\n    @Override\n    public void translate(ServerDisplayScoreboardPacket packet, GeyserSession session) {\n        session.getWorldCache().getScoreboard()\n                .displayObjective(packet.getName(), packet.getPosition());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.WorldCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Objective;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\nimport com.github.steveice10.mc.protocol.data.game.scoreboard.ObjectiveAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerScoreboardObjectivePacket;\n\n@Translator(packet = ServerScoreboardObjectivePacket.class)\npublic class JavaScoreboardObjectiveTranslator extends PacketTranslator<ServerScoreboardObjectivePacket> {\n\n    @Override\n    public void translate(ServerScoreboardObjectivePacket packet, GeyserSession session) {\n        WorldCache worldCache = session.getWorldCache();\n        Scoreboard scoreboard = worldCache.getScoreboard();\n        Objective objective = scoreboard.getObjective(packet.getName());\n        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();\n\n        if (objective == null && packet.getAction() != ObjectiveAction.REMOVE) {\n            objective = scoreboard.registerNewObjective(packet.getName(), false);\n        }\n\n        switch (packet.getAction()) {\n            case ADD:\n            case UPDATE:\n                objective.setDisplayName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setType(packet.getType().ordinal());\n                break;\n            case REMOVE:\n                scoreboard.unregisterObjective(packet.getName());\n                break;\n        }\n\n        if (objective == null || !objective.isActive()) {\n            return;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerTeamPacket;\nimport it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.GeyserLogger;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.scoreboard.Team;\nimport org.geysermc.connector.scoreboard.UpdateType;\nimport org.geysermc.connector.utils.LanguageUtils;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\nimport java.util.Arrays;\nimport java.util.Set;\n\n@Translator(packet = ServerTeamPacket.class)\npublic class JavaTeamTranslator extends PacketTranslator<ServerTeamPacket> {\n    private static final GeyserLogger LOGGER = GeyserConnector.getInstance().getLogger();\n\n    @Override\n    public void translate(ServerTeamPacket packet, GeyserSession session) {\n        if (LOGGER.isDebug()) {\n            LOGGER.debug(\"Team packet \" + packet.getTeamName() + \" \" + packet.getAction() + \" \" + Arrays.toString(packet.getPlayers()));\n        }\n\n        int pps = session.getWorldCache().increaseAndGetScoreboardPacketsPerSecond();\n\n        Scoreboard scoreboard = session.getWorldCache().getScoreboard();\n        Team team = scoreboard.getTeam(packet.getTeamName());\n        switch (packet.getAction()) {\n            case CREATE:\n                scoreboard.registerNewTeam(packet.getTeamName(), toPlayerSet(packet.getPlayers()))\n                        .setName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setColor(packet.getColor())\n                        .setNameTagVisibility(packet.getNameTagVisibility())\n                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))\n                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()));\n                break;\n            case UPDATE:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n\n                team.setName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setColor(packet.getColor())\n                        .setNameTagVisibility(packet.getNameTagVisibility())\n                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))\n                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()))\n                        .setUpdateType(UpdateType.UPDATE);\n                break;\n            case ADD_PLAYER:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n                team.addEntities(packet.getPlayers());\n                break;\n            case REMOVE_PLAYER:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n                team.removeEntities(packet.getPlayers());\n                break;\n            case REMOVE:\n                scoreboard.removeTeam(packet.getTeamName());\n                break;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n\n    private Set<String> toPlayerSet(String[] players) {\n        return new ObjectOpenHashSet<>(players);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport com.github.steveice10.mc.protocol.data.game.scoreboard.ScoreboardAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerUpdateScorePacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.GeyserLogger;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.WorldCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Objective;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerUpdateScorePacket.class)\npublic class JavaUpdateScoreTranslator extends PacketTranslator<ServerUpdateScorePacket> {\n    private final GeyserLogger logger;\n\n    public JavaUpdateScoreTranslator() {\n        logger = GeyserConnector.getInstance().getLogger();\n    }\n\n    @Override\n    public void translate(ServerUpdateScorePacket packet, GeyserSession session) {\n        WorldCache worldCache = session.getWorldCache();\n        Scoreboard scoreboard = worldCache.getScoreboard();\n        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();\n\n        Objective objective = scoreboard.getObjective(packet.getObjective());\n        if (objective == null && packet.getAction() != ScoreboardAction.REMOVE) {\n            logger.info(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.score.failed_objective\", packet.getObjective()));\n            return;\n        }\n\n        switch (packet.getAction()) {\n            case ADD_OR_UPDATE:\n                objective.setScore(packet.getEntry(), packet.getValue());\n                break;\n            case REMOVE:\n                if (objective != null) {\n                    objective.removeScore(packet.getEntry());\n                } else {\n                    for (Objective objective1 : scoreboard.getObjectives().values()) {\n                        objective1.removeScore(packet.getEntry());\n                    }\n                }\n                break;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerClearTitlesPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerClearTitlesPacket.class)\npublic class JavaClearTitlesTranslator extends PacketTranslator<ServerClearTitlesPacket> {\n\n    @Override\n    public void translate(ServerClearTitlesPacket packet, GeyserSession session) {\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        // TODO handle packet.isResetTimes()\n        titlePacket.setType(SetTitlePacket.Type.CLEAR);\n        titlePacket.setText(\"\");\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetActionBarTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetActionBarTextPacket.class)\npublic class JavaSetActionBarTextTranslator extends PacketTranslator<ServerSetActionBarTextPacket> {\n\n    @Override\n    public void translate(ServerSetActionBarTextPacket packet, GeyserSession session) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetSubtitleTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetSubtitleTextPacket.class)\npublic class JavaSetSubtitleTextTranslator extends PacketTranslator<ServerSetSubtitleTextPacket> {\n\n    @Override\n    public void translate(ServerSetSubtitleTextPacket packet, GeyserSession session) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.SUBTITLE);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitleTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetTitleTextPacket.class)\npublic class JavaSetTitleTextTranslator extends PacketTranslator<ServerSetTitleTextPacket> {\n\n    @Override\n    public void translate(ServerSetTitleTextPacket packet, GeyserSession session) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.TITLE);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitlesAnimationPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerSetTitlesAnimationPacket.class)\npublic class JavaSetTitlesAnimationTranslator extends PacketTranslator<ServerSetTitlesAnimationPacket> {\n\n    @Override\n    public void translate(ServerSetTitlesAnimationPacket packet, GeyserSession session) {\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.TIMES);\n        titlePacket.setText(\"\");\n        titlePacket.setFadeInTime(packet.getFadeIn());\n        titlePacket.setFadeOutTime(packet.getFadeOut());\n        titlePacket.setStayTime(packet.getStay());\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerCloseWindowPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerCloseWindowPacket.class)\npublic class JavaCloseWindowTranslator extends PacketTranslator<ServerCloseWindowPacket> {\n\n    @Override\n    public void translate(ServerCloseWindowPacket packet, GeyserSession session) {\n        // Sometimes the server can request a window close of ID 0... when the window isn't even open\n        // Don't confirm in this instance\n        InventoryUtils.closeInventory(session, packet.getWindowId(), (session.getOpenInventory() != null && session.getOpenInventory().getId() == packet.getWindowId()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenHorseWindowPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.UpdateEquipPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.ChestedHorseEntity;\nimport org.geysermc.connector.entity.living.animal.horse.LlamaEntity;\nimport org.geysermc.connector.inventory.Container;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.DonkeyInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.HorseInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.LlamaInventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Translator(packet = ServerOpenHorseWindowPacket.class)\npublic class JavaOpenHorseWindowTranslator extends PacketTranslator<ServerOpenHorseWindowPacket> {\n\n    private static final NbtMap ARMOR_SLOT;\n    private static final NbtMap CARPET_SLOT;\n    private static final NbtMap SADDLE_SLOT;\n\n    static {\n        // Build the NBT mappings that Bedrock wants to lay out the GUI\n        String[] acceptedHorseArmorIdentifiers = new String[] {\"minecraft:horsearmorleather\", \"minecraft:horsearmoriron\",\n                \"minecraft:horsearmorgold\", \"minecraft:horsearmordiamond\"};\n        NbtMapBuilder armorBuilder = NbtMap.builder();\n        List<NbtMap> acceptedArmors = new ArrayList<>(4);\n        for (String identifier : acceptedHorseArmorIdentifiers) {\n            NbtMapBuilder acceptedItemBuilder = NbtMap.builder()\n                    .putShort(\"Aux\", Short.MAX_VALUE)\n                    .putString(\"Name\", identifier);\n            acceptedArmors.add(NbtMap.builder().putCompound(\"slotItem\", acceptedItemBuilder.build()).build());\n        }\n        armorBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedArmors);\n        NbtMapBuilder armorItem = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:horsearmoriron\");\n        armorBuilder.putCompound(\"item\", armorItem.build());\n        armorBuilder.putInt(\"slotNumber\", 1);\n        ARMOR_SLOT = armorBuilder.build();\n\n        NbtMapBuilder carpetBuilder = NbtMap.builder();\n        NbtMapBuilder carpetItem = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:carpet\");\n        List<NbtMap> acceptedCarpet = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", carpetItem.build()).build());\n        carpetBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedCarpet);\n        carpetBuilder.putCompound(\"item\", carpetItem.build());\n        carpetBuilder.putInt(\"slotNumber\", 1);\n        CARPET_SLOT = carpetBuilder.build();\n\n        NbtMapBuilder saddleBuilder = NbtMap.builder();\n        NbtMapBuilder acceptedSaddle = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:saddle\");\n        List<NbtMap> acceptedItem = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", acceptedSaddle.build()).build());\n        saddleBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedItem);\n        saddleBuilder.putCompound(\"item\", acceptedSaddle.build());\n        saddleBuilder.putInt(\"slotNumber\", 0);\n        SADDLE_SLOT = saddleBuilder.build();\n    }\n\n    @Override\n    public void translate(ServerOpenHorseWindowPacket packet, GeyserSession session) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (entity == null) {\n            return;\n        }\n\n        UpdateEquipPacket updateEquipPacket = new UpdateEquipPacket();\n        updateEquipPacket.setWindowId((short) packet.getWindowId());\n        updateEquipPacket.setWindowType((short) ContainerType.HORSE.getId());\n        updateEquipPacket.setUniqueEntityId(entity.getGeyserId());\n\n        NbtMapBuilder builder = NbtMap.builder();\n        List<NbtMap> slots = new ArrayList<>();\n\n        InventoryTranslator inventoryTranslator;\n        if (entity instanceof LlamaEntity) {\n            inventoryTranslator = new LlamaInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(CARPET_SLOT);\n        } else if (entity instanceof ChestedHorseEntity) {\n            inventoryTranslator = new DonkeyInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(SADDLE_SLOT);\n        } else {\n            inventoryTranslator = new HorseInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(SADDLE_SLOT);\n            slots.add(ARMOR_SLOT);\n        }\n\n        // Build the NbtMap that sets the icons for Bedrock (e.g. sets the saddle outline on the saddle slot)\n        builder.putList(\"slots\", NbtType.COMPOUND, slots);\n\n        updateEquipPacket.setTag(builder.build());\n        session.sendUpstreamPacket(updateEquipPacket);\n\n        session.setInventoryTranslator(inventoryTranslator);\n        InventoryUtils.openInventory(session, new Container(entity.getMetadata().getString(EntityData.NAMETAG), packet.getWindowId(), packet.getNumberOfSlots(), null, session.getPlayerInventory()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenWindowPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\nimport org.geysermc.connector.utils.LocaleUtils;\n\n@Translator(packet = ServerOpenWindowPacket.class)\npublic class JavaOpenWindowTranslator extends PacketTranslator<ServerOpenWindowPacket> {\n\n    @Override\n    public void translate(ServerOpenWindowPacket packet, GeyserSession session) {\n        if (packet.getWindowId() == 0) {\n            return;\n        }\n\n        InventoryTranslator newTranslator = InventoryTranslator.INVENTORY_TRANSLATORS.get(packet.getType());\n        Inventory openInventory = session.getOpenInventory();\n        //No translator exists for this window type. Close all windows and return.\n        if (newTranslator == null) {\n            if (openInventory != null) {\n                InventoryUtils.closeInventory(session, openInventory.getId(), true);\n            }\n            ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(packet.getWindowId());\n            session.sendDownstreamPacket(closeWindowPacket);\n            return;\n        }\n\n        String name = MessageTranslator.convertMessageLenient(packet.getName(), session.getLocale());\n        name = LocaleUtils.getLocaleString(name, session.getLocale());\n\n        Inventory newInventory = newTranslator.createInventory(name, packet.getWindowId(), packet.getType(), session.getPlayerInventory());\n        if (openInventory != null) {\n            // If the window type is the same, don't close.\n            // In rare cases, inventories can do funny things where it keeps the same window type up but change the contents.\n            if (openInventory.getWindowType() != packet.getType()) {\n                // Sometimes the server can double-open an inventory with the same ID - don't confirm in that instance.\n                InventoryUtils.closeInventory(session, openInventory.getId(), openInventory.getId() != packet.getWindowId());\n            }\n        }\n\n        session.setInventoryTranslator(newTranslator);\n        InventoryUtils.openInventory(session, newInventory);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Recipe;\nimport com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerSetSlotPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerId;\nimport com.nukkitx.protocol.bedrock.data.inventory.CraftingData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.InventorySlotPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.CraftingInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerSetSlotPacket.class)\npublic class JavaSetSlotTranslator extends PacketTranslator<ServerSetSlotPacket> {\n\n    @Override\n    public void translate(ServerSetSlotPacket packet, GeyserSession session) {\n        if (packet.getWindowId() == 255) { //cursor\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());\n            session.getPlayerInventory().setCursor(newItem, session);\n            InventoryUtils.updateCursor(session);\n            return;\n        }\n\n        //TODO: support window id -2, should update player inventory\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        inventory.setStateId(packet.getStateId());\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            if (session.getCraftingGridFuture() != null) {\n                session.getCraftingGridFuture().cancel(false);\n            }\n            session.setCraftingGridFuture(session.scheduleInEventLoop(() -> updateCraftingGrid(session, packet, inventory, translator), 150, TimeUnit.MILLISECONDS));\n\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());\n            if (packet.getWindowId() == 0 && !(translator instanceof PlayerInventoryTranslator)) {\n                // In rare cases, the window ID can still be 0 but Java treats it as valid\n                session.getPlayerInventory().setItem(packet.getSlot(), newItem, session);\n                InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR.updateSlot(session, session.getPlayerInventory(), packet.getSlot());\n            } else {\n                inventory.setItem(packet.getSlot(), newItem, session);\n                translator.updateSlot(session, inventory, packet.getSlot());\n            }\n        }\n    }\n\n    private static void updateCraftingGrid(GeyserSession session, ServerSetSlotPacket packet, Inventory inventory, InventoryTranslator translator) {\n        if (packet.getSlot() == 0) {\n            int gridSize;\n            if (translator instanceof PlayerInventoryTranslator) {\n                gridSize = 4;\n            } else if (translator instanceof CraftingInventoryTranslator) {\n                gridSize = 9;\n            } else {\n                return;\n            }\n\n            if (packet.getItem() == null || packet.getItem().getId() == 0) {\n                return;\n            }\n\n            int offset = gridSize == 4 ? 28 : 32;\n            int gridDimensions = gridSize == 4 ? 2 : 3;\n            int firstRow = -1, height = -1;\n            int firstCol = -1, width = -1;\n            for (int row = 0; row < gridDimensions; row++) {\n                for (int col = 0; col < gridDimensions; col++) {\n                    if (!inventory.getItem(col + (row * gridDimensions) + 1).isEmpty()) {\n                        if (firstRow == -1) {\n                            firstRow = row;\n                            firstCol = col;\n                        } else {\n                            firstCol = Math.min(firstCol, col);\n                        }\n                        height = Math.max(height, row);\n                        width = Math.max(width, col);\n                    }\n                }\n            }\n\n            //empty grid\n            if (firstRow == -1) {\n                return;\n            }\n\n            height += -firstRow + 1;\n            width += -firstCol + 1;\n\n            recipes:\n            for (Recipe recipe : session.getCraftingRecipes().values()) {\n                if (recipe.getType() == RecipeType.CRAFTING_SHAPED) {\n                    ShapedRecipeData data = (ShapedRecipeData) recipe.getData();\n                    if (!data.getResult().equals(packet.getItem())) {\n                        continue;\n                    }\n                    if (data.getWidth() != width || data.getHeight() != height || width * height != data.getIngredients().length) {\n                        continue;\n                    }\n\n                    Ingredient[] ingredients = data.getIngredients();\n                    if (!testShapedRecipe(ingredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {\n                        Ingredient[] mirroredIngredients = new Ingredient[data.getIngredients().length];\n                        for (int row = 0; row < height; row++) {\n                            for (int col = 0; col < width; col++) {\n                                mirroredIngredients[col + (row * width)] = ingredients[(width - 1 - col) + (row * width)];\n                            }\n                        }\n\n                        if (Arrays.equals(ingredients, mirroredIngredients) ||\n                                !testShapedRecipe(mirroredIngredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {\n                            continue;\n                        }\n                    }\n                    // Recipe is had, don't sent packet\n                    return;\n                } else if (recipe.getType() == RecipeType.CRAFTING_SHAPELESS) {\n                    ShapelessRecipeData data = (ShapelessRecipeData) recipe.getData();\n                    if (!data.getResult().equals(packet.getItem())) {\n                        continue;\n                    }\n                    for (int i = 0; i < data.getIngredients().length; i++) {\n                        Ingredient ingredient = data.getIngredients()[i];\n                        for (ItemStack itemStack : ingredient.getOptions()) {\n                            boolean inventoryHasItem = false;\n                            for (int j = 0; j < inventory.getSize(); j++) {\n                                GeyserItemStack geyserItemStack = inventory.getItem(j);\n                                if (geyserItemStack.isEmpty()) {\n                                    inventoryHasItem = itemStack == null || itemStack.getId() == 0;\n                                    if (inventoryHasItem) {\n                                        break;\n                                    }\n                                } else if (itemStack.equals(geyserItemStack.getItemStack(1))) {\n                                    inventoryHasItem = true;\n                                    break;\n                                }\n                            }\n                            if (!inventoryHasItem) {\n                                continue recipes;\n                            }\n                        }\n                    }\n                    // Recipe is had, don't sent packet\n                    return;\n                }\n            }\n\n            UUID uuid = UUID.randomUUID();\n            int newRecipeId = session.getLastRecipeNetId().incrementAndGet();\n\n            ItemData[] ingredients = new ItemData[height * width];\n            //construct ingredient list and clear slots on client\n            Ingredient[] javaIngredients = new Ingredient[height * width];\n            int index = 0;\n            for (int row = firstRow; row < height + firstRow; row++) {\n                for (int col = firstCol; col < width + firstCol; col++) {\n                    GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);\n                    ingredients[index] = geyserItemStack.getItemData(session);\n                    ItemStack[] itemStacks = new ItemStack[] {geyserItemStack.isEmpty() ? null : geyserItemStack.getItemStack(1)};\n                    javaIngredients[index] = new Ingredient(itemStacks);\n\n                    InventorySlotPacket slotPacket = new InventorySlotPacket();\n                    slotPacket.setContainerId(ContainerId.UI);\n                    slotPacket.setSlot(col + (row * gridDimensions) + offset);\n                    slotPacket.setItem(ItemData.AIR);\n                    session.sendUpstreamPacket(slotPacket);\n                    index++;\n                }\n            }\n\n            ShapedRecipeData data = new ShapedRecipeData(width, height, \"\", javaIngredients, packet.getItem());\n            // Cache this recipe so we know the client has received it\n            session.getCraftingRecipes().put(newRecipeId, new Recipe(RecipeType.CRAFTING_SHAPED, uuid.toString(), data));\n\n            CraftingDataPacket craftPacket = new CraftingDataPacket();\n            craftPacket.getCraftingData().add(CraftingData.fromShaped(\n                    uuid.toString(),\n                    width,\n                    height,\n                    Arrays.asList(ingredients),\n                    Collections.singletonList(ItemTranslator.translateToBedrock(session, packet.getItem())),\n                    uuid,\n                    \"crafting_table\",\n                    0,\n                    newRecipeId\n            ));\n            craftPacket.setCleanRecipes(false);\n            session.sendUpstreamPacket(craftPacket);\n\n            index = 0;\n            for (int row = firstRow; row < height + firstRow; row++) {\n                for (int col = firstCol; col < width + firstCol; col++) {\n                    InventorySlotPacket slotPacket = new InventorySlotPacket();\n                    slotPacket.setContainerId(ContainerId.UI);\n                    slotPacket.setSlot(col + (row * gridDimensions) + offset);\n                    slotPacket.setItem(ingredients[index]);\n                    session.sendUpstreamPacket(slotPacket);\n                    index++;\n                }\n            }\n        }\n    }\n\n    private static boolean testShapedRecipe(Ingredient[] ingredients, Inventory inventory, int gridDimensions, int firstRow, int height, int firstCol, int width) {\n        int ingredientIndex = 0;\n        for (int row = firstRow; row < height + firstRow; row++) {\n            for (int col = firstCol; col < width + firstCol; col++) {\n                GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);\n                Ingredient ingredient = ingredients[ingredientIndex++];\n                if (ingredient.getOptions().length == 0) {\n                    if (!geyserItemStack.isEmpty()) {\n                        return false;\n                    }\n                } else {\n                    boolean inventoryHasItem = false;\n                    for (ItemStack item : ingredient.getOptions()) {\n                        if (Objects.equals(geyserItemStack.getItemStack(1), item)) {\n                            inventoryHasItem = true;\n                            break;\n                        }\n                    }\n                    if (!inventoryHasItem) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowItemsPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerWindowItemsPacket.class)\npublic class JavaWindowItemsTranslator extends PacketTranslator<ServerWindowItemsPacket> {\n\n    @Override\n    public void translate(ServerWindowItemsPacket packet, GeyserSession session) {\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        inventory.setStateId(packet.getStateId());\n\n        for (int i = 0; i < packet.getItems().length; i++) {\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItems()[i]);\n            inventory.setItem(i, newItem, session);\n        }\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            translator.updateInventory(session, inventory);\n        }\n\n        session.getPlayerInventory().setCursor(GeyserItemStack.from(packet.getCarriedItem()), session);\n        InventoryUtils.updateCursor(session);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowPropertyPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerWindowPropertyPacket.class)\npublic class JavaWindowPropertyTranslator extends PacketTranslator<ServerWindowPropertyPacket> {\n\n    @Override\n    public void translate(ServerWindowPropertyPacket packet, GeyserSession session) {\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            translator.updateProperty(session, inventory, packet.getRawProperty(), packet.getValue());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockBreakAnimPacket;\nimport com.github.steveice10.opennbt.tag.builtin.CompoundTag;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.BlockUtils;\n\n@Translator(packet = ServerBlockBreakAnimPacket.class)\npublic class JavaBlockBreakAnimTranslator extends PacketTranslator<ServerBlockBreakAnimPacket> {\n\n    @Override\n    public void translate(ServerBlockBreakAnimPacket packet, GeyserSession session) {\n        int state = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n        int breakTime = (int) (65535 / Math.ceil(BlockUtils.getBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(state), ItemMapping.AIR, new CompoundTag(\"\"), false) * 20));\n        LevelEventPacket levelEventPacket = new LevelEventPacket();\n        levelEventPacket.setPosition(Vector3f.from(\n                packet.getPosition().getX(),\n                packet.getPosition().getY(),\n                packet.getPosition().getZ()\n        ));\n        levelEventPacket.setType(LevelEventType.BLOCK_START_BREAK);\n\n        switch (packet.getStage()) {\n            case STAGE_1:\n                levelEventPacket.setData(breakTime);\n                break;\n            case STAGE_2:\n                levelEventPacket.setData(breakTime * 2);\n                break;\n            case STAGE_3:\n                levelEventPacket.setData(breakTime * 3);\n                break;\n            case STAGE_4:\n                levelEventPacket.setData(breakTime * 4);\n                break;\n            case STAGE_5:\n                levelEventPacket.setData(breakTime * 5);\n                break;\n            case STAGE_6:\n                levelEventPacket.setData(breakTime * 6);\n                break;\n            case STAGE_7:\n                levelEventPacket.setData(breakTime * 7);\n                break;\n            case STAGE_8:\n                levelEventPacket.setData(breakTime * 8);\n                break;\n            case STAGE_9:\n                levelEventPacket.setData(breakTime * 9);\n                break;\n            case STAGE_10:\n                levelEventPacket.setData(breakTime * 10);\n                break;\n            case RESET:\n                levelEventPacket.setType(LevelEventType.BLOCK_STOP_BREAK);\n                levelEventPacket.setData(0);\n                break;\n        }\n        session.sendUpstreamPacket(levelEventPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockChangePacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.sound.BlockSoundInteractionHandler;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerBlockChangePacket.class)\npublic class JavaBlockChangeTranslator extends PacketTranslator<ServerBlockChangePacket> {\n\n    @Override\n    public void translate(ServerBlockChangePacket packet, GeyserSession session) {\n        Position pos = packet.getRecord().getPosition();\n        boolean updatePlacement = session.getConnector().getPlatformType() != PlatformType.SPIGOT && // Spigot simply listens for the block place event\n                session.getConnector().getWorldManager().getBlockAt(session, pos) != packet.getRecord().getBlock();\n        ChunkUtils.updateBlock(session, packet.getRecord().getBlock(), pos);\n        if (updatePlacement) {\n            this.checkPlace(session, packet);\n        }\n        this.checkInteract(session, packet);\n    }\n\n    private boolean checkPlace(GeyserSession session, ServerBlockChangePacket packet) {\n        Vector3i lastPlacePos = session.getLastBlockPlacePosition();\n        if (lastPlacePos == null) {\n            return false;\n        }\n        if ((lastPlacePos.getX() != packet.getRecord().getPosition().getX()\n                || lastPlacePos.getY() != packet.getRecord().getPosition().getY()\n                || lastPlacePos.getZ() != packet.getRecord().getPosition().getZ())) {\n            return false;\n        }\n\n        // We need to check if the identifier is the same, else a packet with the sound of what the\n        // player has in their hand is played, despite if the block is being placed or not\n        boolean contains = false;\n        String identifier = BlockRegistries.JAVA_BLOCKS.get(packet.getRecord().getBlock()).getItemIdentifier();\n        if (identifier.equals(session.getLastBlockPlacedId())) {\n            contains = true;\n        }\n\n        if (!contains) {\n            session.setLastBlockPlacePosition(null);\n            session.setLastBlockPlacedId(null);\n            return false;\n        }\n\n        // This is not sent from the server, so we need to send it this way\n        LevelSoundEventPacket placeBlockSoundPacket = new LevelSoundEventPacket();\n        placeBlockSoundPacket.setSound(SoundEvent.PLACE);\n        placeBlockSoundPacket.setPosition(lastPlacePos.toFloat());\n        placeBlockSoundPacket.setBabySound(false);\n        placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(packet.getRecord().getBlock()));\n        placeBlockSoundPacket.setIdentifier(\":\");\n        session.sendUpstreamPacket(placeBlockSoundPacket);\n        session.setLastBlockPlacePosition(null);\n        session.setLastBlockPlacedId(null);\n        return true;\n    }\n\n    private void checkInteract(GeyserSession session, ServerBlockChangePacket packet) {\n        Vector3i lastInteractPos = session.getLastInteractionBlockPosition();\n        if (lastInteractPos == null || !session.isInteracting()) {\n            return;\n        }\n        if ((lastInteractPos.getX() != packet.getRecord().getPosition().getX()\n                || lastInteractPos.getY() != packet.getRecord().getPosition().getY()\n                || lastInteractPos.getZ() != packet.getRecord().getPosition().getZ())) {\n            return;\n        }\n        String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(packet.getRecord().getBlock());\n        session.setInteracting(false);\n        BlockSoundInteractionHandler.handleBlockInteraction(session, lastInteractPos.toFloat(), identifier);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.world.block.value.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockValuePacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.BlockEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.network.translators.world.block.entity.NoteblockBlockEntityTranslator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerBlockValuePacket.class)\npublic class JavaBlockValueTranslator extends PacketTranslator<ServerBlockValuePacket> {\n\n    @Override\n    public void translate(ServerBlockValuePacket packet, GeyserSession session) {\n        BlockEventPacket blockEventPacket = new BlockEventPacket();\n        blockEventPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(),\n                packet.getPosition().getY(), packet.getPosition().getZ()));\n        if (packet.getValue() instanceof ChestValue) {\n            ChestValue value = (ChestValue) packet.getValue() ;\n            blockEventPacket.setEventType(1);\n            blockEventPacket.setEventData(value.getViewers() > 0 ? 1 : 0);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof EndGatewayValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof NoteBlockValue) {\n            NoteblockBlockEntityTranslator.translate(session, packet.getPosition());\n        } else if (packet.getValue() instanceof PistonValue) {\n            PistonValueType type = (PistonValueType) packet.getType();\n\n            // Unlike everything else, pistons need a block entity packet to convey motion\n            // TODO: Doesn't register on chunk load; needs to be interacted with first\n            Vector3i position = Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n            if (type == PistonValueType.PUSHING) {\n                extendPiston(session, position, 0.0f, 0.0f);\n            } else {\n                retractPiston(session, position, 1.0f, 1.0f);\n            }\n        } else if (packet.getValue() instanceof MobSpawnerValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof EndGatewayValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof GenericBlockValue && packet.getBlockId() == BlockStateValues.JAVA_BELL_ID) {\n            // Bells - needed to show ring from other players\n            GenericBlockValue bellValue = (GenericBlockValue) packet.getValue();\n            Position position = packet.getPosition();\n\n            BlockEntityDataPacket blockEntityPacket = new BlockEntityDataPacket();\n            blockEntityPacket.setBlockPosition(Vector3i.from(position.getX(), position.getY(), position.getZ()));\n\n            NbtMapBuilder builder = NbtMap.builder();\n            builder.putInt(\"x\", position.getX());\n            builder.putInt(\"y\", position.getY());\n            builder.putInt(\"z\", position.getZ());\n            builder.putString(\"id\", \"Bell\");\n            int bedrockRingDirection;\n            switch (bellValue.getValue()) {\n                case 3: // north\n                    bedrockRingDirection = 0;\n                    break;\n                case 4: // east\n                    bedrockRingDirection = 1;\n                    break;\n                case 5: // west\n                    bedrockRingDirection = 3;\n                    break;\n                default: // south (2) is identical\n                    bedrockRingDirection = bellValue.getValue();\n            }\n            builder.putInt(\"Direction\", bedrockRingDirection);\n            builder.putByte(\"Ringing\", (byte) 1);\n            builder.putInt(\"Ticks\", 0);\n            \n            blockEntityPacket.setData(builder.build());\n            session.sendUpstreamPacket(blockEntityPacket);\n        }\n    }\n\n    /**\n     * Emulating a piston extending\n     * @param session GeyserSession\n     * @param position Block position\n     * @param progress How far the piston is\n     * @param lastProgress How far the piston last was\n     */\n    private void extendPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {\n        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();\n        blockEntityDataPacket.setBlockPosition(position);\n        byte state = (byte) ((progress == 1.0f && lastProgress == 1.0f) ? 2 : 1);\n        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));\n        session.sendUpstreamPacket(blockEntityDataPacket);\n        if (lastProgress != 1.0f) {\n            session.getConnector().getGeneralThreadPool().schedule(() ->\n                            extendPiston(session, position, (progress >= 1.0f) ? 1.0f : progress + 0.5f, progress),\n                    20, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    /**\n     * Emulate a piston retracting.\n     * @param session GeyserSession\n     * @param position Block position\n     * @param progress Current progress of piston\n     * @param lastProgress Last progress of piston\n     */\n    private void retractPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {\n        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();\n        blockEntityDataPacket.setBlockPosition(position);\n        byte state = (byte) ((progress == 0.0f && lastProgress == 0.0f) ? 0 : 3);\n        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));\n        session.sendUpstreamPacket(blockEntityDataPacket);\n        if (lastProgress != 0.0f) {\n            session.getConnector().getGeneralThreadPool().schedule(() ->\n                            retractPiston(session, position, (progress <= 0.0f) ? 0.0f : progress - 0.5f, progress),\n                    20, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    /**\n     * Build a piston tag\n     * @param position Piston position\n     * @param progress Current progress of piston\n     * @param lastProgress Last progress of piston\n     * @param state\n     * @return Bedrock CompoundTag of piston\n     */\n    private NbtMap buildPistonTag(Vector3i position, float progress, float lastProgress, byte state) {\n        NbtMapBuilder builder = NbtMap.builder()\n                .putInt(\"x\", position.getX())\n                .putInt(\"y\", position.getY())\n                .putInt(\"z\", position.getZ())\n                .putFloat(\"Progress\", progress)\n                .putFloat(\"LastProgress\", lastProgress)\n                .putString(\"id\", \"PistonArm\")\n                .putByte(\"NewState\", state)\n                .putByte(\"State\", state);\n        return builder.build();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.chunk.Column;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerChunkDataPacket;\nimport com.nukkitx.nbt.NBTOutputStream;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtUtils;\nimport com.nukkitx.network.VarInts;\nimport com.nukkitx.protocol.bedrock.packet.LevelChunkPacket;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufOutputStream;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.chunk.ChunkSection;\nimport org.geysermc.connector.network.translators.world.BiomeTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT;\nimport static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT_OVERWORLD;\n\n@Translator(packet = ServerChunkDataPacket.class)\npublic class JavaChunkDataTranslator extends PacketTranslator<ServerChunkDataPacket> {\n    // Caves and cliffs supports 3D biomes by implementing a very similar palette system to blocks\n    private static final boolean NEW_BIOME_WRITE = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight();\n\n    @Override\n    public void translate(ServerChunkDataPacket packet, GeyserSession session) {\n        if (session.isSpawned()) {\n            ChunkUtils.updateChunkPosition(session, session.getPlayerEntity().getPosition().toInt());\n        }\n\n        session.getChunkCache().addToCache(packet.getColumn());\n        Column column = packet.getColumn();\n\n        // Ensure that, if the player is using lower world heights, the position is not offset\n        int yOffset = session.getChunkCache().getChunkMinY();\n\n        GeyserConnector.getInstance().getGeneralThreadPool().execute(() -> {\n            try {\n                if (session.isClosed()) {\n                    return;\n                }\n                ChunkUtils.ChunkData chunkData = ChunkUtils.translateToBedrock(session, column, yOffset);\n                ChunkSection[] sections = chunkData.getSections();\n\n                // Find highest section\n                int sectionCount = sections.length - 1;\n                while (sectionCount >= 0 && sections[sectionCount] == null) {\n                    sectionCount--;\n                }\n                sectionCount++;\n\n                // Estimate chunk size\n                int size = 0;\n                for (int i = 0; i < sectionCount; i++) {\n                    ChunkSection section = sections[i];\n                    size += (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).estimateNetworkSize();\n                }\n                if (NEW_BIOME_WRITE) {\n                    size += ChunkUtils.EMPTY_CHUNK_DATA.length; // Consists only of biome data\n                } else {\n                    size += 256; // Biomes pre-1.18\n                }\n                size += 1; // Border blocks\n                size += 1; // Extra data length (always 0)\n                size += chunkData.getBlockEntities().length * 64; // Conservative estimate of 64 bytes per tile entity\n\n                // Allocate output buffer\n                ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(size);\n                byte[] payload;\n                try {\n                    for (int i = 0; i < sectionCount; i++) {\n                        ChunkSection section = sections[i];\n                        (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).writeToNetwork(byteBuf);\n                    }\n\n                    if (NEW_BIOME_WRITE) {\n                        // At this point we're dealing with Bedrock chunk sections\n                        boolean overworld = session.getChunkCache().isExtendedHeight();\n                        int dimensionOffset = (overworld ? MINIMUM_ACCEPTED_HEIGHT_OVERWORLD : MINIMUM_ACCEPTED_HEIGHT) >> 4;\n                        for (int i = 0; i < sectionCount; i++) {\n                            int biomeYOffset = dimensionOffset + i;\n                            if (biomeYOffset < yOffset) {\n                                // Ignore this biome section since it goes below the height of the Java world\n                                byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);\n                                continue;\n                            }\n                            BiomeTranslator.toNewBedrockBiome(session, column.getBiomeData(), i + (dimensionOffset - yOffset)).writeToNetwork(byteBuf);\n                        }\n\n                        // As of 1.17.10, Bedrock hardcodes to always read 32 biome sections\n                        int remainingEmptyBiomes = 32 - sectionCount;\n                        for (int i = 0; i < remainingEmptyBiomes; i++) {\n                            byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);\n                        }\n                    } else {\n                        byteBuf.writeBytes(BiomeTranslator.toBedrockBiome(session, column.getBiomeData())); // Biomes - 256 bytes\n                    }\n                    byteBuf.writeByte(0); // Border blocks - Edu edition only\n                    VarInts.writeUnsignedInt(byteBuf, 0); // extra data length, 0 for now\n\n                    // Encode tile entities into buffer\n                    NBTOutputStream nbtStream = NbtUtils.createNetworkWriter(new ByteBufOutputStream(byteBuf));\n                    for (NbtMap blockEntity : chunkData.getBlockEntities()) {\n                        nbtStream.writeTag(blockEntity);\n                    }\n\n                    // Copy data into byte[], because the protocol lib really likes things that are s l o w\n                    byteBuf.readBytes(payload = new byte[byteBuf.readableBytes()]);\n                } finally {\n                    byteBuf.release(); // Release buffer to allow buffer pooling to be useful\n                }\n\n                LevelChunkPacket levelChunkPacket = new LevelChunkPacket();\n                levelChunkPacket.setSubChunksLength(sectionCount);\n                levelChunkPacket.setCachingEnabled(false);\n                levelChunkPacket.setChunkX(column.getX());\n                levelChunkPacket.setChunkZ(column.getZ());\n                levelChunkPacket.setData(payload);\n                session.sendUpstreamPacket(levelChunkPacket);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        });\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.block.ExplodedBlockRecord;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerExplosionPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerExplosionPacket.class)\npublic class JavaExplosionTranslator extends PacketTranslator<ServerExplosionPacket> {\n\n    @Override\n    public void translate(ServerExplosionPacket packet, GeyserSession session) {\n        for (ExplodedBlockRecord record : packet.getExploded()) {\n            Vector3f pos = Vector3f.from(packet.getX() + record.getX(), packet.getY() + record.getY(), packet.getZ() + record.getZ());\n            ChunkUtils.updateBlock(session, BlockStateValues.JAVA_AIR_ID, pos.toInt());\n        }\n\n        Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        // Since bedrock does not play an explosion sound and particles sound, we have to manually do so\n        LevelEventPacket levelEventPacket = new LevelEventPacket();\n        levelEventPacket.setType(packet.getRadius() >= 2.0f ? LevelEventType.PARTICLE_HUGE_EXPLODE : LevelEventType.PARTICLE_EXPLOSION);\n        levelEventPacket.setData(0);\n        levelEventPacket.setPosition(pos.toFloat());\n        session.sendUpstreamPacket(levelEventPacket);\n\n        LevelSoundEventPacket levelSoundEventPacket = new LevelSoundEventPacket();\n        levelSoundEventPacket.setRelativeVolumeDisabled(false);\n        levelSoundEventPacket.setBabySound(false);\n        levelSoundEventPacket.setExtraData(-1);\n        levelSoundEventPacket.setSound(SoundEvent.EXPLODE);\n        levelSoundEventPacket.setIdentifier(\":\");\n        levelSoundEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        session.sendUpstreamPacket(levelSoundEventPacket);\n\n        if (packet.getPushX() > 0f || packet.getPushY() > 0f || packet.getPushZ() > 0f) {\n            SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();\n            motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n            motionPacket.setMotion(Vector3f.from(packet.getPushX(), packet.getPushY(), packet.getPushZ()));\n            session.sendUpstreamPacket(motionPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.map.MapData;\nimport com.github.steveice10.mc.protocol.data.game.world.map.MapIcon;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMapDataPacket;\nimport com.nukkitx.protocol.bedrock.data.MapDecoration;\nimport com.nukkitx.protocol.bedrock.data.MapTrackedObject;\nimport com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.BedrockMapIcon;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.MapColor;\n\n@Translator(packet = ServerMapDataPacket.class)\npublic class JavaMapDataTranslator extends PacketTranslator<ServerMapDataPacket> {\n    @Override\n    public void translate(ServerMapDataPacket packet, GeyserSession session) {\n        ClientboundMapItemDataPacket mapItemDataPacket = new ClientboundMapItemDataPacket();\n        boolean shouldStore = false;\n\n        mapItemDataPacket.setUniqueMapId(packet.getMapId());\n        mapItemDataPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n        mapItemDataPacket.setLocked(packet.isLocked());\n        mapItemDataPacket.setScale(packet.getScale());\n\n        MapData data = packet.getData();\n        if (data != null) {\n            mapItemDataPacket.setXOffset(data.getX());\n            mapItemDataPacket.setYOffset(data.getY());\n            mapItemDataPacket.setWidth(data.getColumns());\n            mapItemDataPacket.setHeight(data.getRows());\n\n            // We have a full map image, this usually only happens on spawn for the initial image\n            if (mapItemDataPacket.getWidth() == 128 && mapItemDataPacket.getHeight() == 128) {\n                shouldStore = true;\n            }\n\n            // Every int entry is an ABGR color\n            int[] colors = new int[data.getData().length];\n\n            int idx = 0;\n            for (byte colorId : data.getData()) {\n                colors[idx++] = MapColor.fromId(colorId & 0xFF).toABGR();\n            }\n\n            mapItemDataPacket.setColors(colors);\n        }\n\n        // Bedrock needs an entity id to display an icon\n        int id = 0;\n        for (MapIcon icon : packet.getIcons()) {\n            BedrockMapIcon bedrockMapIcon = BedrockMapIcon.fromType(icon.getIconType());\n\n            mapItemDataPacket.getTrackedObjects().add(new MapTrackedObject(id));\n            mapItemDataPacket.getDecorations().add(new MapDecoration(bedrockMapIcon.getIconID(), icon.getIconRotation(), icon.getCenterX(), icon.getCenterZ(), \"\", bedrockMapIcon.toARGB()));\n            id++;\n        }\n\n        // Store the map to send when the client requests it, as bedrock expects the data after a MapInfoRequestPacket\n        if (shouldStore) {\n            session.getStoredMaps().put(mapItemDataPacket.getUniqueMapId(), mapItemDataPacket);\n        }\n\n        // Send anyway just in case\n        session.sendUpstreamPacket(mapItemDataPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockChangeRecord;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMultiBlockChangePacket;\n\n@Translator(packet = ServerMultiBlockChangePacket.class)\npublic class JavaMultiBlockChangeTranslator extends PacketTranslator<ServerMultiBlockChangePacket> {\n\n    @Override\n    public void translate(ServerMultiBlockChangePacket packet, GeyserSession session) {\n        for (BlockChangeRecord record : packet.getRecords()) {\n            ChunkUtils.updateBlock(session, record.getBlock(), record.getPosition());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.EnterCreditsValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.RainStrengthValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.RespawnScreenValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.ThunderStrengthValue;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerNotifyClientPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.GameRuleData;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;\nimport org.geysermc.connector.utils.LocaleUtils;\n\n@Translator(packet = ServerNotifyClientPacket.class)\npublic class JavaNotifyClientTranslator extends PacketTranslator<ServerNotifyClientPacket> {\n\n    @Override\n    public void translate(ServerNotifyClientPacket packet, GeyserSession session) {\n        PlayerEntity entity = session.getPlayerEntity();\n\n        switch (packet.getNotification()) {\n            case START_RAIN:\n                LevelEventPacket startRainPacket = new LevelEventPacket();\n                startRainPacket.setType(LevelEventType.START_RAINING);\n                startRainPacket.setData(Integer.MAX_VALUE);\n                startRainPacket.setPosition(Vector3f.ZERO);\n                session.sendUpstreamPacket(startRainPacket);\n                session.setRaining(true);\n                break;\n            case STOP_RAIN:\n                LevelEventPacket stopRainPacket = new LevelEventPacket();\n                stopRainPacket.setType(LevelEventType.STOP_RAINING);\n                stopRainPacket.setData(0);\n                stopRainPacket.setPosition(Vector3f.ZERO);\n                session.sendUpstreamPacket(stopRainPacket);\n                session.setRaining(false);\n                break;\n            case RAIN_STRENGTH:\n                // While the above values are used, they CANNOT BE TRUSTED on a vanilla server as they are swapped around\n                // Spigot and forks implement it correctly\n                // Rain strength is your best way for determining if there is any rain\n                RainStrengthValue value = (RainStrengthValue) packet.getValue();\n                boolean isCurrentlyRaining = value.getStrength() > 0f;\n                // Java sends the rain level. Bedrock doesn't care, so we don't care if it's already raining.\n                if (isCurrentlyRaining != session.isRaining()) {\n                    LevelEventPacket changeRainPacket = new LevelEventPacket();\n                    changeRainPacket.setType(isCurrentlyRaining ? LevelEventType.START_RAINING : LevelEventType.STOP_RAINING);\n                    changeRainPacket.setData(Integer.MAX_VALUE); // Dunno what this does; used to be implemented with ThreadLocalRandom\n                    changeRainPacket.setPosition(Vector3f.ZERO);\n                    session.sendUpstreamPacket(changeRainPacket);\n                    session.setRaining(isCurrentlyRaining);\n                }\n                break;\n            case THUNDER_STRENGTH:\n                // See above, same process\n                ThunderStrengthValue thunderValue = (ThunderStrengthValue) packet.getValue();\n                boolean isCurrentlyThundering = thunderValue.getStrength() > 0f;\n                if (isCurrentlyThundering != session.isThunder()) {\n                    LevelEventPacket changeThunderPacket = new LevelEventPacket();\n                    changeThunderPacket.setType(isCurrentlyThundering ? LevelEventType.START_THUNDERSTORM : LevelEventType.STOP_THUNDERSTORM);\n                    changeThunderPacket.setData(Integer.MAX_VALUE);\n                    changeThunderPacket.setPosition(Vector3f.ZERO);\n                    session.sendUpstreamPacket(changeThunderPacket);\n                    session.setThunder(isCurrentlyThundering);\n                }\n                break;\n            case CHANGE_GAMEMODE:\n                GameMode gameMode = (GameMode) packet.getValue();\n\n                SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n                playerGameTypePacket.setGamemode(gameMode.ordinal());\n                session.sendUpstreamPacket(playerGameTypePacket);\n                session.setGameMode(gameMode);\n\n                session.sendAdventureSettings();\n\n                if (session.getPlayerEntity().isOnGround() && gameMode == GameMode.SPECTATOR) {\n                    // Fix a bug where the player has glitched movement and thinks they are still on the ground\n                    MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                    movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                    movePlayerPacket.setPosition(entity.getPosition());\n                    movePlayerPacket.setRotation(entity.getBedrockRotation());\n                    movePlayerPacket.setOnGround(false);\n                    movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                    movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);\n                    session.sendUpstreamPacket(movePlayerPacket);\n                }\n\n                // Update the crafting grid to add/remove barriers for creative inventory\n                PlayerInventoryTranslator.updateCraftingGrid(session, session.getPlayerInventory());\n                break;\n            case ENTER_CREDITS:\n                switch ((EnterCreditsValue) packet.getValue()) {\n                    case SEEN_BEFORE:\n                        ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n                        session.sendDownstreamPacket(javaRespawnPacket);\n                        break;\n                    case FIRST_TIME:\n                        ShowCreditsPacket showCreditsPacket = new ShowCreditsPacket();\n                        showCreditsPacket.setStatus(ShowCreditsPacket.Status.START_CREDITS);\n                        showCreditsPacket.setRuntimeEntityId(entity.getGeyserId());\n                        session.sendUpstreamPacket(showCreditsPacket);\n                        break;\n                }\n                break;\n            case AFFECTED_BY_ELDER_GUARDIAN:\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setType(EntityEventType.ELDER_GUARDIAN_CURSE);\n                eventPacket.setData(0);\n                eventPacket.setRuntimeEntityId(entity.getGeyserId());\n                session.sendUpstreamPacket(eventPacket);\n                break;\n            case ENABLE_RESPAWN_SCREEN:\n                GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();\n                gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\",\n                        packet.getValue() == RespawnScreenValue.IMMEDIATE_RESPAWN));\n                session.sendUpstreamPacket(gamerulePacket);\n                break;\n            case INVALID_BED:\n                // Not sent as a proper message? Odd.\n                session.sendMessage(LocaleUtils.getLocaleString(\"block.minecraft.spawn.not_valid\",\n                        session.getLocale()));\n                break;\n            case ARROW_HIT_PLAYER:\n                PlaySoundPacket arrowSoundPacket = new PlaySoundPacket();\n                arrowSoundPacket.setSound(\"random.orb\");\n                arrowSoundPacket.setPitch(0.5f);\n                arrowSoundPacket.setVolume(0.5f);\n                arrowSoundPacket.setPosition(entity.getPosition());\n                session.sendUpstreamPacket(arrowSoundPacket);\n                break;\n            default:\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayBuiltinSoundPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.utils.SoundUtils;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerPlayBuiltinSoundPacket.class)\npublic class JavaPlayBuiltinSoundTranslator extends PacketTranslator<ServerPlayBuiltinSoundPacket> {\n\n    @Override\n    public void translate(ServerPlayBuiltinSoundPacket packet, GeyserSession session) {\n        String packetSound = packet.getSound().getName();\n\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound);\n        if (soundMapping == null) {\n            session.getConnector().getLogger().debug(\"[Builtin] Sound mapping \" + packetSound + \" not found - \" + packet.toString());\n            return;\n        }\n\n        if (soundMapping.isLevelEvent()) {\n            LevelEventPacket levelEventPacket = new LevelEventPacket();\n            levelEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n            levelEventPacket.setData(0);\n            levelEventPacket.setType(LevelEventType.valueOf(soundMapping.getBedrock()));\n            session.sendUpstreamPacket(levelEventPacket);\n            return;\n        }\n        LevelSoundEventPacket soundPacket = new LevelSoundEventPacket();\n        SoundEvent sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());\n        if (sound == null) {\n            sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());\n        }\n        if (sound == null) {\n            sound = SoundUtils.toSoundEvent(packetSound);\n        }\n        if (sound == null) {\n            session.getConnector().getLogger().debug(\"[Builtin] Sound for original \" + packetSound + \" to mappings \" + soundPacket\n                            + \" was not a playable level sound, or has yet to be mapped to an enum in \"\n                            + \"NukkitX SoundEvent \");\n            return;\n        }\n\n        soundPacket.setSound(sound);\n        soundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        soundPacket.setIdentifier(soundMapping.getIdentifier());\n        if (sound == SoundEvent.NOTE) {\n            // Minecraft Wiki: 2^(x/12) = Java pitch where x is -12 to 12\n            // Java sends the note value as above starting with -12 and ending at 12\n            // Bedrock has a number for each type of note, then proceeds up the scale by adding to that number\n            soundPacket.setExtraData(soundMapping.getExtraData() + (int)(Math.round((Math.log10(packet.getPitch()) / Math.log10(2)) * 12)) + 12);\n        } else if (sound == SoundEvent.PLACE && soundMapping.getExtraData() == -1) {\n            if (!soundMapping.getIdentifier().equals(\":\")) {\n                soundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(\n                        BlockRegistries.JAVA_IDENTIFIERS.getOrDefault(soundMapping.getIdentifier(), BlockStateValues.JAVA_AIR_ID)));\n            } else {\n                session.getConnector().getLogger().debug(\"PLACE sound mapping identifier was invalid! Please report: \" + packet.toString());\n            }\n            soundPacket.setIdentifier(\":\");\n        } else {\n            soundPacket.setExtraData(soundMapping.getExtraData());\n        }\n\n\n        soundPacket.setBabySound(false); // might need to adjust this in the future\n        soundPacket.setRelativeVolumeDisabled(false);\n        session.sendUpstreamPacket(soundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.effect.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayEffectPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.effect.Effect;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.utils.LocaleUtils;\n\nimport java.util.Collections;\nimport java.util.Locale;\n\n@Translator(packet = ServerPlayEffectPacket.class)\npublic class JavaPlayEffectTranslator extends PacketTranslator<ServerPlayEffectPacket> {\n\n    @Override\n    public void translate(ServerPlayEffectPacket packet, GeyserSession session) {\n        // Separate case since each RecordEffectData in Java is an individual track in Bedrock\n        if (packet.getEffect() == SoundEffect.RECORD) {\n            RecordEffectData recordEffectData = (RecordEffectData) packet.getData();\n            SoundEvent soundEvent = Registries.RECORDS.getOrDefault(recordEffectData.getRecordId(), SoundEvent.STOP_RECORD);\n            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);\n\n            LevelSoundEventPacket levelSoundEvent = new LevelSoundEventPacket();\n            levelSoundEvent.setIdentifier(\"\");\n            levelSoundEvent.setSound(soundEvent);\n            levelSoundEvent.setPosition(pos);\n            levelSoundEvent.setRelativeVolumeDisabled(packet.isBroadcast());\n            levelSoundEvent.setExtraData(-1);\n            levelSoundEvent.setBabySound(false);\n            session.sendUpstreamPacket(levelSoundEvent);\n\n            if (soundEvent != SoundEvent.STOP_RECORD) {\n                // Send text packet as it seems to be handled in Java Edition client-side.\n                TextPacket textPacket = new TextPacket();\n                textPacket.setType(TextPacket.Type.JUKEBOX_POPUP);\n                textPacket.setNeedsTranslation(true);\n                textPacket.setXuid(\"\");\n                textPacket.setPlatformChatId(\"\");\n                textPacket.setSourceName(null);\n                textPacket.setMessage(\"record.nowPlaying\");\n                String recordString = \"%item.\" + soundEvent.name().toLowerCase(Locale.ROOT) + \".desc\";\n                textPacket.setParameters(Collections.singletonList(LocaleUtils.getLocaleString(recordString, session.getLocale())));\n                session.sendUpstreamPacket(textPacket);\n            }\n            return;\n        }\n\n        if (packet.getEffect() instanceof SoundEffect) {\n            SoundEffect soundEffect = (SoundEffect) packet.getEffect();\n            Effect geyserEffect = Registries.SOUND_EFFECTS.get(soundEffect);\n            if (geyserEffect != null) {\n                geyserEffect.handleEffectPacket(session, packet);\n                return;\n            }\n            GeyserConnector.getInstance().getLogger().debug(\"Unhandled sound effect: \" + soundEffect.name());\n        } else if (packet.getEffect() instanceof ParticleEffect) {\n            ParticleEffect particleEffect = (ParticleEffect) packet.getEffect();\n            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);\n\n            LevelEventPacket effectPacket = new LevelEventPacket();\n            effectPacket.setPosition(pos);\n            effectPacket.setData(0);\n            switch (particleEffect) {\n                case COMPOSTER: {\n                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);\n\n                    ComposterEffectData composterEffectData = (ComposterEffectData) packet.getData();\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    switch (composterEffectData) {\n                        case FILL:\n                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL);\n                            break;\n                        case FILL_SUCCESS:\n                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL_LAYER);\n                            break;\n                    }\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_LAVA_EXTINGUISH: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.7f, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_REDSTONE_TORCH_BURNOUT: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_END_PORTAL_FRAME_FILL: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.3125f, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.BLOCK_END_PORTAL_FRAME_FILL);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case SMOKE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_SHOOT);\n\n                    SmokeEffectData smokeEffectData = (SmokeEffectData) packet.getData();\n                    int data = 0;\n                    switch (smokeEffectData) {\n                        case DOWN:\n                            data = 4;\n                            pos = pos.add(0, -0.9f, 0);\n                            break;\n                        case UP:\n                            data = 4;\n                            pos = pos.add(0, 0.5f, 0);\n                            break;\n                        case NORTH:\n                            data = 1;\n                            pos = pos.add(0, -0.2f, -0.7f);\n                            break;\n                        case SOUTH:\n                            data = 7;\n                            pos = pos.add(0, -0.2f, 0.7f);\n                            break;\n                        case WEST:\n                            data = 3;\n                            pos = pos.add(-0.7f, -0.2f, 0);\n                            break;\n                        case EAST:\n                            data = 5;\n                            pos = pos.add(0.7f, -0.2f, 0);\n                            break;\n\n                    }\n                    effectPacket.setPosition(pos);\n                    effectPacket.setData(data);\n                    break;\n                }\n                //TODO: Block break particles when under fire\n                case BREAK_BLOCK: {\n                    effectPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);\n\n                    BreakBlockEffectData breakBlockEffectData = (BreakBlockEffectData) packet.getData();\n                    effectPacket.setData(session.getBlockMappings().getBedrockBlockId(breakBlockEffectData.getBlockState()));\n                    break;\n                }\n                case BREAK_SPLASH_POTION: {\n                    effectPacket.setType(LevelEventType.PARTICLE_POTION_SPLASH);\n                    effectPacket.setPosition(pos.add(0, -0.5f, 0));\n\n                    BreakPotionEffectData splashPotionData = (BreakPotionEffectData) packet.getData();\n                    effectPacket.setData(splashPotionData.getPotionId());\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.GLASS);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BREAK_EYE_OF_ENDER: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);\n                    break;\n                }\n                case MOB_SPAWN: {\n                    effectPacket.setType(LevelEventType.PARTICLE_MOB_BLOCK_SPAWN); // TODO: Check, but I don't think I really verified this ever went into effect on Java\n                    break;\n                }\n                case BONEMEAL_GROW_WITH_SOUND: // Note that there is no particle without sound in Bedrock. If you wanted to implement the sound, send a PlaySoundPacket with \"item.bone_meal.use\" and volume and pitch at 1.0F\n                case BONEMEAL_GROW: {\n                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);\n\n                    BonemealGrowEffectData growEffectData = (BonemealGrowEffectData) packet.getData();\n                    effectPacket.setData(growEffectData.getParticleCount());\n                    break;\n                }\n                case ENDERDRAGON_FIREBALL_EXPLODE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH); // TODO\n\n                    DragonFireballEffectData fireballEffectData = (DragonFireballEffectData) packet.getData();\n                    if (fireballEffectData == DragonFireballEffectData.HAS_SOUND) {\n                        LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                        soundEventPacket.setSound(SoundEvent.EXPLODE);\n                        soundEventPacket.setPosition(pos);\n                        soundEventPacket.setIdentifier(\"\");\n                        soundEventPacket.setExtraData(-1);\n                        soundEventPacket.setBabySound(false);\n                        soundEventPacket.setRelativeVolumeDisabled(false);\n                        session.sendUpstreamPacket(soundEventPacket);\n                    }\n                    break;\n                }\n                case EXPLOSION: {\n                    effectPacket.setType(LevelEventType.PARTICLE_GENERIC_SPAWN);\n                    effectPacket.setData(61);\n                    break;\n                }\n                case EVAPORATE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE_WATER);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.5f, -0.5f));\n                    break;\n                }\n                case END_GATEWAY_SPAWN: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EXPLOSION);\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXPLODE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case DRIPSTONE_DRIP: {\n                    effectPacket.setType(LevelEventType.PARTICLE_DRIPSTONE_DRIP);\n                    break;\n                }\n                case ELECTRIC_SPARK: {\n                    // Matches with a Bedrock server but doesn't seem to match up with Java\n                    effectPacket.setType(LevelEventType.PARTICLE_ELECTRIC_SPARK);\n                    break;\n                }\n                case WAX_ON: {\n                    effectPacket.setType(LevelEventType.PARTICLE_WAX_ON);\n                    break;\n                }\n                case WAX_OFF: {\n                    effectPacket.setType(LevelEventType.PARTICLE_WAX_OFF);\n                    break;\n                }\n                case SCRAPE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_SCRAPE);\n                    break;\n                }\n                default: {\n                    GeyserConnector.getInstance().getLogger().debug(\"Unhandled particle effect: \" + particleEffect.name());\n                    return;\n                }\n            }\n            session.sendUpstreamPacket(effectPacket);\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;\nimport com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlaySoundPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerPlaySoundPacket.class)\npublic class JavaPlaySoundTranslator extends PacketTranslator<ServerPlaySoundPacket> {\n\n    @Override\n    public void translate(ServerPlaySoundPacket packet, GeyserSession session) {\n        String packetSound;\n        if (packet.getSound() instanceof BuiltinSound) {\n            packetSound = ((BuiltinSound) packet.getSound()).getName();\n        } else if (packet.getSound() instanceof CustomSound) {\n            packetSound = ((CustomSound) packet.getSound()).getName();\n        } else {\n            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());\n            return;\n        }\n\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));\n        String playsound;\n        if (soundMapping == null || soundMapping.getPlaysound() == null) {\n            // no mapping\n            session.getConnector().getLogger()\n                    .debug(\"[PlaySound] Defaulting to sound server gave us for \" + packet.toString());\n            playsound = packetSound.replace(\"minecraft:\", \"\");\n        } else {\n            playsound = soundMapping.getPlaysound();\n        }\n\n        PlaySoundPacket playSoundPacket = new PlaySoundPacket();\n        playSoundPacket.setSound(playsound);\n        playSoundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        playSoundPacket.setVolume(packet.getVolume());\n        playSoundPacket.setPitch(packet.getPitch());\n\n        session.sendUpstreamPacket(playSoundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.world.particle.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnParticlePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.ParticleMapping;\nimport org.geysermc.connector.utils.DimensionUtils;\n\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Function;\n\n@Translator(packet = ServerSpawnParticlePacket.class)\npublic class JavaSpawnParticleTranslator extends PacketTranslator<ServerSpawnParticlePacket> {\n\n    @Override\n    public void translate(ServerSpawnParticlePacket packet, GeyserSession session) {\n        Function<Vector3f, BedrockPacket> particleCreateFunction = createParticle(session, packet.getParticle());\n        if (particleCreateFunction != null) {\n            if (packet.getAmount() == 0) {\n                // 0 means don't apply the offset\n                Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n                session.sendUpstreamPacket(particleCreateFunction.apply(position));\n            } else {\n                Random random = ThreadLocalRandom.current();\n                for (int i = 0; i < packet.getAmount(); i++) {\n                    double offsetX = random.nextGaussian() * (double) packet.getOffsetX();\n                    double offsetY = random.nextGaussian() * (double) packet.getOffsetY();\n                    double offsetZ = random.nextGaussian() * (double) packet.getOffsetZ();\n                    Vector3f position = Vector3f.from(packet.getX() + offsetX, packet.getY() + offsetY, packet.getZ() + offsetZ);\n\n                    session.sendUpstreamPacket(particleCreateFunction.apply(position));\n                }\n            }\n        } else {\n            // Null is only returned when no particle of this type is found\n            session.getConnector().getLogger().debug(\"Unhandled particle packet: \" + packet);\n        }\n    }\n\n    /**\n     * @param session the Bedrock client session.\n     * @param particle the Java particle to translate to a Bedrock equivalent.\n     * @return a function to create a packet with a specified particle, in the event we need to spawn multiple particles\n     * with different offsets.\n     */\n    private Function<Vector3f, BedrockPacket> createParticle(GeyserSession session, Particle particle) {\n        switch (particle.getType()) {\n            case BLOCK: {\n                int blockState = session.getBlockMappings().getBedrockBlockId(((BlockParticleData) particle.getData()).getBlockState());\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_CRACK_BLOCK);\n                    packet.setPosition(position);\n                    packet.setData(blockState);\n                    return packet;\n                };\n            }\n            case FALLING_DUST: {\n                int blockState = session.getBlockMappings().getBedrockBlockId(((FallingDustParticleData) particle.getData()).getBlockState());\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    // In fact, FallingDustParticle should have data like DustParticle,\n                    // but in MCProtocol, its data is BlockState(1).\n                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);\n                    packet.setData(blockState);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            case ITEM: {\n                ItemStack javaItem = ((ItemParticleData) particle.getData()).getItemStack();\n                ItemData bedrockItem = ItemTranslator.translateToBedrock(session, javaItem);\n                int data = bedrockItem.getId() << 16 | bedrockItem.getDamage();\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_ITEM_BREAK);\n                    packet.setData(data);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            case DUST:\n            case DUST_COLOR_TRANSITION: { //TODO\n                DustParticleData data = (DustParticleData) particle.getData();\n                int r = (int) (data.getRed() * 255);\n                int g = (int) (data.getGreen() * 255);\n                int b = (int) (data.getBlue() * 255);\n                int rgbData = ((0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);\n                    packet.setData(rgbData);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            default: {\n                ParticleMapping particleMapping = Registries.PARTICLES.get(particle.getType());\n                if (particleMapping == null) { //TODO ensure no particle can be null\n                    return null;\n                }\n\n                if (particleMapping.getLevelEventType() != null) {\n                    return (position) -> {\n                        LevelEventPacket packet = new LevelEventPacket();\n                        packet.setType(particleMapping.getLevelEventType());\n                        packet.setPosition(position);\n                        return packet;\n                    };\n                } else if (particleMapping.getIdentifier() != null) {\n                    int dimensionId = DimensionUtils.javaToBedrock(session.getDimension());\n                    return (position) -> {\n                        SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();\n                        stringPacket.setIdentifier(particleMapping.getIdentifier());\n                        stringPacket.setDimensionId(dimensionId);\n                        stringPacket.setPosition(position);\n                        return stringPacket;\n                    };\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnPositionPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.packet.SetSpawnPositionPacket;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerSpawnPositionPacket.class)\npublic class JavaSpawnPositionTranslator extends PacketTranslator<ServerSpawnPositionPacket> {\n\n    @Override\n    public void translate(ServerSpawnPositionPacket packet, GeyserSession session) {\n        SetSpawnPositionPacket spawnPositionPacket = new SetSpawnPositionPacket();\n        spawnPositionPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n        spawnPositionPacket.setSpawnForced(true);\n        spawnPositionPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n        spawnPositionPacket.setSpawnType(SetSpawnPositionPacket.Type.WORLD_SPAWN);\n        session.sendUpstreamPacket(spawnPositionPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;\nimport com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerStopSoundPacket;\nimport com.nukkitx.protocol.bedrock.packet.StopSoundPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerStopSoundPacket.class)\npublic class JavaStopSoundTranslator extends PacketTranslator<ServerStopSoundPacket> {\n\n    @Override\n    public void translate(ServerStopSoundPacket packet, GeyserSession session) {\n        // Runs if all sounds are stopped\n        if (packet.getSound() == null) {\n            StopSoundPacket stopPacket = new StopSoundPacket();\n            stopPacket.setStoppingAllSound(true);\n            stopPacket.setSoundName(\"\");\n            session.sendUpstreamPacket(stopPacket);\n            return;\n        }\n\n        String packetSound;\n        if (packet.getSound() instanceof BuiltinSound) {\n            packetSound = ((BuiltinSound) packet.getSound()).getName();\n        } else if (packet.getSound() instanceof CustomSound) {\n            packetSound = ((CustomSound) packet.getSound()).getName();\n        } else {\n            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());\n            return;\n        }\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));\n        session.getConnector().getLogger()\n                .debug(\"[StopSound] Sound mapping \" + packetSound + \" -> \"\n                        + soundMapping + (soundMapping == null ? \"[not found]\" : \"\")\n                        + \" - \" + packet.toString());\n        String playsound;\n        if (soundMapping == null || soundMapping.getPlaysound() == null) {\n            // no mapping\n            session.getConnector().getLogger()\n                    .debug(\"[StopSound] Defaulting to sound server gave us.\");\n            playsound = packetSound;\n        } else {\n            playsound = soundMapping.getPlaysound();\n        }\n\n        StopSoundPacket stopSoundPacket = new StopSoundPacket();\n        stopSoundPacket.setSoundName(playsound);\n        // packet not mapped in the library\n        stopSoundPacket.setStoppingAllSound(false);\n\n        session.sendUpstreamPacket(stopSoundPacket);\n        session.getConnector().getLogger().debug(\"[StopSound] Packet sent - \" + packet.toString() + \" --> \" + stopSoundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerTradeListPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.UpdateTradePacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.type.ItemMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Translator(packet = ServerTradeListPacket.class)\npublic class JavaTradeListTranslator extends PacketTranslator<ServerTradeListPacket> {\n\n    @Override\n    public void translate(ServerTradeListPacket packet, GeyserSession session) {\n        Inventory openInventory = session.getOpenInventory();\n        if (!(openInventory instanceof MerchantContainer && openInventory.getId() == packet.getWindowId())) {\n            return;\n        }\n\n        // Retrieve the fake villager involved in the trade, and update its metadata to match with the window information\n        MerchantContainer merchantInventory = (MerchantContainer) openInventory;\n        merchantInventory.setVillagerTrades(packet.getTrades());\n        Entity villager = merchantInventory.getVillager();\n        villager.getMetadata().put(EntityData.TRADE_TIER, packet.getVillagerLevel() - 1);\n        villager.getMetadata().put(EntityData.MAX_TRADE_TIER, 4);\n        villager.getMetadata().put(EntityData.TRADE_XP, packet.getExperience());\n        villager.updateBedrockMetadata(session);\n\n        // Construct the packet that opens the trading window\n        UpdateTradePacket updateTradePacket = new UpdateTradePacket();\n        updateTradePacket.setTradeTier(packet.getVillagerLevel() - 1);\n        updateTradePacket.setContainerId((short) packet.getWindowId());\n        updateTradePacket.setContainerType(ContainerType.TRADE);\n        updateTradePacket.setDisplayName(openInventory.getTitle());\n        updateTradePacket.setSize(0);\n        updateTradePacket.setNewTradingUi(true);\n        updateTradePacket.setUsingEconomyTrade(true);\n        updateTradePacket.setPlayerUniqueEntityId(session.getPlayerEntity().getGeyserId());\n        updateTradePacket.setTraderUniqueEntityId(villager.getGeyserId());\n\n        NbtMapBuilder builder = NbtMap.builder();\n        boolean addExtraTrade = packet.isRegularVillager() && packet.getVillagerLevel() < 5;\n        List<NbtMap> tags = new ArrayList<>(addExtraTrade ? packet.getTrades().length + 1 : packet.getTrades().length);\n        for (int i = 0; i < packet.getTrades().length; i++) {\n            VillagerTrade trade = packet.getTrades()[i];\n            NbtMapBuilder recipe = NbtMap.builder();\n            recipe.putInt(\"netId\", i + 1);\n            recipe.putInt(\"maxUses\", trade.isTradeDisabled() ? 0 : trade.getMaxUses());\n            recipe.putInt(\"traderExp\", trade.getXp());\n            recipe.putFloat(\"priceMultiplierA\", trade.getPriceMultiplier());\n            recipe.put(\"sell\", getItemTag(session, trade.getOutput(), 0));\n            recipe.putFloat(\"priceMultiplierB\", 0.0f);\n            recipe.putInt(\"buyCountB\", trade.getSecondInput() != null ? trade.getSecondInput().getAmount() : 0);\n            recipe.putInt(\"buyCountA\", trade.getFirstInput().getAmount());\n            recipe.putInt(\"demand\", trade.getDemand());\n            recipe.putInt(\"tier\", packet.getVillagerLevel() > 0 ? packet.getVillagerLevel() - 1 : 0); // -1 crashes client\n            recipe.put(\"buyA\", getItemTag(session, trade.getFirstInput(), trade.getSpecialPrice()));\n            if (trade.getSecondInput() != null) {\n                recipe.put(\"buyB\", getItemTag(session, trade.getSecondInput(), 0));\n            }\n            recipe.putInt(\"uses\", trade.getNumUses());\n            recipe.putByte(\"rewardExp\", (byte) 1);\n            tags.add(recipe.build());\n        }\n\n        //Hidden trade to fix visual experience bug\n        if (addExtraTrade) {\n            tags.add(NbtMap.builder()\n                    .putInt(\"maxUses\", 0)\n                    .putInt(\"traderExp\", 0)\n                    .putFloat(\"priceMultiplierA\", 0.0f)\n                    .putFloat(\"priceMultiplierB\", 0.0f)\n                    .putInt(\"buyCountB\", 0)\n                    .putInt(\"buyCountA\", 0)\n                    .putInt(\"demand\", 0)\n                    .putInt(\"tier\", 5)\n                    .putInt(\"uses\", 0)\n                    .putByte(\"rewardExp\", (byte) 0)\n                    .build());\n        }\n\n        builder.putList(\"Recipes\", NbtType.COMPOUND, tags);\n\n        List<NbtMap> expTags = new ArrayList<>(5);\n        expTags.add(NbtMap.builder().putInt(\"0\", 0).build());\n        expTags.add(NbtMap.builder().putInt(\"1\", 10).build());\n        expTags.add(NbtMap.builder().putInt(\"2\", 70).build());\n        expTags.add(NbtMap.builder().putInt(\"3\", 150).build());\n        expTags.add(NbtMap.builder().putInt(\"4\", 250).build());\n        builder.putList(\"TierExpRequirements\", NbtType.COMPOUND, expTags);\n\n        updateTradePacket.setOffers(builder.build());\n        session.sendUpstreamPacket(updateTradePacket);\n    }\n\n    private NbtMap getItemTag(GeyserSession session, ItemStack stack, int specialPrice) {\n        ItemData itemData = ItemTranslator.translateToBedrock(session, stack);\n        ItemMapping mapping = session.getItemMappings().getMapping(stack);\n\n        NbtMapBuilder builder = NbtMap.builder();\n        builder.putByte(\"Count\", (byte) (Math.max(itemData.getCount() + specialPrice, 1)));\n        builder.putShort(\"Damage\", (short) itemData.getDamage());\n        builder.putString(\"Name\", mapping.getBedrockIdentifier());\n        if (itemData.getTag() != null) {\n            NbtMap tag = itemData.getTag().toBuilder().build();\n            builder.put(\"tag\", tag);\n        }\n\n        NbtMap blockTag = session.getBlockMappings().getBedrockBlockNbt(mapping.getJavaIdentifier());\n        if (blockTag != null) {\n            // This fixes certain blocks being unable to stack after grabbing one\n            builder.putCompound(\"Block\", blockTag);\n            builder.putShort(\"Damage\", (short) 0);\n        }\n\n        return builder.build();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUnloadChunkPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Iterator;\n\n@Translator(packet = ServerUnloadChunkPacket.class)\npublic class JavaUnloadChunkTranslator extends PacketTranslator<ServerUnloadChunkPacket> {\n\n    @Override\n    public void translate(ServerUnloadChunkPacket packet, GeyserSession session) {\n        session.getChunkCache().removeChunk(packet.getX(), packet.getZ());\n\n        //Checks if a skull is in an unloaded chunk then removes it\n        Iterator<Vector3i> iterator = session.getSkullCache().keySet().iterator();\n        while (iterator.hasNext()) {\n            Vector3i position = iterator.next();\n            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {\n                session.getSkullCache().get(position).despawnEntity(session);\n                iterator.remove();\n            }\n        }\n\n        // Do the same thing with lecterns\n        iterator = session.getLecternCache().iterator();\n        while (iterator.hasNext()) {\n            Vector3i position = iterator.next();\n            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {\n                iterator.remove();\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.world.block.UpdatedTileType;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTileEntityPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.network.translators.world.block.entity.BlockEntityTranslator;\nimport org.geysermc.connector.network.translators.world.block.entity.RequiresBlockState;\nimport org.geysermc.connector.network.translators.world.block.entity.SkullBlockEntityTranslator;\nimport org.geysermc.connector.utils.BlockEntityUtils;\n\n@Translator(packet = ServerUpdateTileEntityPacket.class)\npublic class JavaUpdateTileEntityTranslator extends PacketTranslator<ServerUpdateTileEntityPacket> {\n\n    @Override\n    public void translate(ServerUpdateTileEntityPacket packet, GeyserSession session) {\n        String id = BlockEntityUtils.getBedrockBlockEntityId(packet.getType().name());\n        if (packet.getNbt().isEmpty()) { // Fixes errors in servers sending empty NBT\n            BlockEntityUtils.updateBlockEntity(session, NbtMap.EMPTY, packet.getPosition());\n            return;\n        }\n\n        BlockEntityTranslator translator = BlockEntityUtils.getBlockEntityTranslator(id);\n        // The Java block state is used in BlockEntityTranslator.translateTag() to make up for some inconsistencies\n        // between Java block states and Bedrock block entity data\n        int blockState;\n        if (translator instanceof RequiresBlockState) {\n            blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition());\n        } else {\n            blockState = BlockStateValues.JAVA_AIR_ID;\n        }\n        BlockEntityUtils.updateBlockEntity(session, translator.getBlockEntityTag(id, packet.getNbt(), blockState), packet.getPosition());\n        // Check for custom skulls.\n        if (SkullBlockEntityTranslator.ALLOW_CUSTOM_SKULLS && packet.getNbt().contains(\"SkullOwner\")) {\n            SkullBlockEntityTranslator.spawnPlayer(session, packet.getNbt(), blockState);\n        }\n\n        // If block entity is command block, OP permission level is appropriate, player is in creative mode and the NBT is not empty\n        if (packet.getType() == UpdatedTileType.COMMAND_BLOCK && session.getOpPermissionLevel() >= 2 &&\n                session.getGameMode() == GameMode.CREATIVE && packet.getNbt().size() > 5) {\n            ContainerOpenPacket openPacket = new ContainerOpenPacket();\n            openPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n            openPacket.setId((byte) 1);\n            openPacket.setType(ContainerType.COMMAND_BLOCK);\n            openPacket.setUniqueEntityId(-1);\n            session.sendUpstreamPacket(openPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTimePacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTimePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerUpdateTimePacket.class)\npublic class JavaUpdateTimeTranslator extends PacketTranslator<ServerUpdateTimePacket> {\n\n    @Override\n    public void translate(ServerUpdateTimePacket packet, GeyserSession session) {\n        // Bedrock sends a GameRulesChangedPacket if there is no daylight cycle\n        // Java just sends a negative long if there is no daylight cycle\n        long time = packet.getTime();\n\n        // https://minecraft.gamepedia.com/Day-night_cycle#24-hour_Minecraft_day\n        SetTimePacket setTimePacket = new SetTimePacket();\n        setTimePacket.setTime((int) Math.abs(time) % 24000);\n        session.sendUpstreamPacket(setTimePacket);\n        if (!session.isDaylightCycle() && time >= 0) {\n            // Client thinks there is no daylight cycle but there is\n            session.setDaylightCycle(true);\n        } else if (session.isDaylightCycle() && time < 0) {\n            // Client thinks there is daylight cycle but there isn't\n            session.setDaylightCycle(false);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewDistancePacket;\n\n@Translator(packet = ServerUpdateViewDistancePacket.class)\npublic class JavaUpdateViewDistanceTranslator extends PacketTranslator<ServerUpdateViewDistancePacket> {\n\n    @Override\n    public void translate(ServerUpdateViewDistancePacket packet, GeyserSession session) {\n        session.setRenderDistance(packet.getViewDistance());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewPositionPacket;\nimport com.nukkitx.math.vector.Vector3i;\n\n@Translator(packet = ServerUpdateViewPositionPacket.class)\npublic class JavaUpdateViewPositionTranslator extends PacketTranslator<ServerUpdateViewPositionPacket> {\n\n    @Override\n    public void translate(ServerUpdateViewPositionPacket packet, GeyserSession session) {\n        if (!session.isSpawned() && session.getLastChunkPosition() == null) {\n            ChunkUtils.updateChunkPosition(session, Vector3i.from(packet.getChunkX() << 4, 64, packet.getChunkZ() << 4));\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerVehicleMovePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerVehicleMovePacket.class)\npublic class JavaVehicleMoveTranslator extends PacketTranslator<ServerVehicleMovePacket> {\n\n    @Override\n    public void translate(ServerVehicleMovePacket packet, GeyserSession session) {\n        Entity entity = session.getRidingVehicleEntity();\n        if (entity == null) return;\n\n        entity.moveAbsolute(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), false, true);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.utils;\n\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.JsonNodeType;\nimport com.github.steveice10.mc.auth.service.MsaAuthenticationService;\nimport com.nimbusds.jose.JWSObject;\nimport com.nukkitx.network.util.Preconditions;\nimport com.nukkitx.protocol.bedrock.packet.LoginPacket;\nimport com.nukkitx.protocol.bedrock.packet.ServerToClientHandshakePacket;\nimport com.nukkitx.protocol.bedrock.util.EncryptionUtils;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.configuration.GeyserConfiguration;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.auth.AuthData;\nimport org.geysermc.connector.network.session.auth.BedrockClientData;\nimport org.geysermc.cumulus.CustomForm;\nimport org.geysermc.cumulus.ModalForm;\nimport org.geysermc.cumulus.SimpleForm;\nimport org.geysermc.cumulus.response.CustomFormResponse;\nimport org.geysermc.cumulus.response.ModalFormResponse;\nimport org.geysermc.cumulus.response.SimpleFormResponse;\n\nimport javax.crypto.SecretKey;\nimport java.io.IOException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECGenParameterSpec;\nimport java.util.UUID;\n\npublic class LoginEncryptionUtils {\n    private static final ObjectMapper JSON_MAPPER = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n\n    private static boolean HAS_SENT_ENCRYPTION_MESSAGE = false;\n\n    private static boolean validateChainData(JsonNode data) throws Exception {\n        ECPublicKey lastKey = null;\n        boolean validChain = false;\n        for (JsonNode node : data) {\n            JWSObject jwt = JWSObject.parse(node.asText());\n\n            if (!validChain) {\n                validChain = EncryptionUtils.verifyJwt(jwt, EncryptionUtils.getMojangPublicKey());\n            }\n\n            if (lastKey != null) {\n                if (!EncryptionUtils.verifyJwt(jwt, lastKey)) return false;\n            }\n\n            JsonNode payloadNode = JSON_MAPPER.readTree(jwt.getPayload().toString());\n            JsonNode ipkNode = payloadNode.get(\"identityPublicKey\");\n            Preconditions.checkState(ipkNode != null && ipkNode.getNodeType() == JsonNodeType.STRING, \"identityPublicKey node is missing in chain\");\n            lastKey = EncryptionUtils.generateKey(ipkNode.asText());\n        }\n        return validChain;\n    }\n\n    public static void encryptPlayerConnection(GeyserConnector connector, GeyserSession session, LoginPacket loginPacket) {\n        JsonNode certData;\n        try {\n            certData = JSON_MAPPER.readTree(loginPacket.getChainData().toByteArray());\n        } catch (IOException ex) {\n            throw new RuntimeException(\"Certificate JSON can not be read.\");\n        }\n\n        JsonNode certChainData = certData.get(\"chain\");\n        if (certChainData.getNodeType() != JsonNodeType.ARRAY) {\n            throw new RuntimeException(\"Certificate data is not valid\");\n        }\n\n        encryptConnectionWithCert(connector, session, loginPacket.getSkinData().toString(), certChainData);\n    }\n\n    private static void encryptConnectionWithCert(GeyserConnector connector, GeyserSession session, String clientData, JsonNode certChainData) {\n        try {\n            boolean validChain = validateChainData(certChainData);\n\n            connector.getLogger().debug(String.format(\"Is player data valid? %s\", validChain));\n\n            if (!validChain && !session.getConnector().getConfig().isEnableProxyConnections()) {\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.remote.invalid_xbox_account\"));\n                return;\n            }\n            JWSObject jwt = JWSObject.parse(certChainData.get(certChainData.size() - 1).asText());\n            JsonNode payload = JSON_MAPPER.readTree(jwt.getPayload().toBytes());\n\n            if (payload.get(\"extraData\").getNodeType() != JsonNodeType.OBJECT) {\n                throw new RuntimeException(\"AuthData was not found!\");\n            }\n\n            JsonNode extraData = payload.get(\"extraData\");\n            session.setAuthenticationData(new AuthData(\n                    extraData.get(\"displayName\").asText(),\n                    UUID.fromString(extraData.get(\"identity\").asText()),\n                    extraData.get(\"XUID\").asText(),\n                    certChainData, clientData\n            ));\n\n            if (payload.get(\"identityPublicKey\").getNodeType() != JsonNodeType.STRING) {\n                throw new RuntimeException(\"Identity Public Key was not found!\");\n            }\n\n            ECPublicKey identityPublicKey = EncryptionUtils.generateKey(payload.get(\"identityPublicKey\").textValue());\n            JWSObject clientJwt = JWSObject.parse(clientData);\n            EncryptionUtils.verifyJwt(clientJwt, identityPublicKey);\n\n            JsonNode clientDataJson = JSON_MAPPER.readTree(clientJwt.getPayload().toBytes());\n            BedrockClientData data = JSON_MAPPER.convertValue(clientDataJson, BedrockClientData.class);\n            session.setClientData(data);\n\n            if (EncryptionUtils.canUseEncryption()) {\n                try {\n                    LoginEncryptionUtils.startEncryptionHandshake(session, identityPublicKey);\n                } catch (Throwable e) {\n                    // An error can be thrown on older Java 8 versions about an invalid key\n                    if (connector.getConfig().isDebugMode()) {\n                        e.printStackTrace();\n                    }\n\n                    sendEncryptionFailedMessage(connector);\n                }\n            } else {\n                sendEncryptionFailedMessage(connector);\n            }\n        } catch (Exception ex) {\n            session.disconnect(\"disconnectionScreen.internalError.cantConnect\");\n            throw new RuntimeException(\"Unable to complete login\", ex);\n        }\n    }\n\n    private static void startEncryptionHandshake(GeyserSession session, PublicKey key) throws Exception {\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"EC\");\n        generator.initialize(new ECGenParameterSpec(\"secp384r1\"));\n        KeyPair serverKeyPair = generator.generateKeyPair();\n\n        byte[] token = EncryptionUtils.generateRandomToken();\n        SecretKey encryptionKey = EncryptionUtils.getSecretKey(serverKeyPair.getPrivate(), key, token);\n        session.getUpstream().getSession().enableEncryption(encryptionKey);\n\n        ServerToClientHandshakePacket packet = new ServerToClientHandshakePacket();\n        packet.setJwt(EncryptionUtils.createHandshakeJwt(serverKeyPair, token).serialize());\n        session.sendUpstreamPacketImmediately(packet);\n    }\n\n    private static void sendEncryptionFailedMessage(GeyserConnector connector) {\n        if (!HAS_SENT_ENCRYPTION_MESSAGE) {\n            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_1\"));\n            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_2\", \"https://geysermc.org/supported_java\"));\n            HAS_SENT_ENCRYPTION_MESSAGE = true;\n        }\n    }\n\n    public static void buildAndShowLoginWindow(GeyserSession session) {\n        // Set DoDaylightCycle to false so the time doesn't accelerate while we're here\n        session.setDaylightCycle(false);\n\n        GeyserConfiguration config = session.getConnector().getConfig();\n        boolean isPasswordAuthEnabled = config.getRemote().isPasswordAuthentication();\n\n        session.sendForm(\n                SimpleForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.notice.title\")\n                        .content(\"geyser.auth.login.form.notice.desc\")\n                        .optionalButton(\"geyser.auth.login.form.notice.btn_login.mojang\", isPasswordAuthEnabled)\n                        .button(\"geyser.auth.login.form.notice.btn_login.microsoft\")\n                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            SimpleFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginWindow(session);\n                                return;\n                            }\n\n                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 0) {\n                                session.setMicrosoftAccount(false);\n                                buildAndShowLoginDetailsWindow(session);\n                                return;\n                            }\n\n                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 1) {\n                                session.setMicrosoftAccount(true);\n                                buildAndShowMicrosoftAuthenticationWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 0) {\n                                // Just show the OAuth code\n                                session.authenticateWithMicrosoftCode();\n                                return;\n                            }\n\n                            session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                        }));\n    }\n\n    public static void buildAndShowLoginDetailsWindow(GeyserSession session) {\n        session.sendForm(\n                CustomForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.details.title\")\n                        .label(\"geyser.auth.login.form.details.desc\")\n                        .input(\"geyser.auth.login.form.details.email\", \"account@geysermc.org\", \"\")\n                        .input(\"geyser.auth.login.form.details.pass\", \"123456\", \"\")\n                        .responseHandler((form, responseData) -> {\n                            CustomFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginDetailsWindow(session);\n                                return;\n                            }\n\n                            session.authenticate(response.next(), response.next());\n                        }));\n    }\n\n    /**\n     * Prompts the user between either OAuth code login or manual password authentication\n     */\n    public static void buildAndShowMicrosoftAuthenticationWindow(GeyserSession session) {\n        session.sendForm(\n                SimpleForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.notice.btn_login.microsoft\")\n                        .button(\"geyser.auth.login.method.browser\")\n                        .button(\"geyser.auth.login.method.password\")\n                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            SimpleFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 0) {\n                                session.authenticateWithMicrosoftCode();\n                            } else if (response.getClickedButtonId() == 1) {\n                                buildAndShowLoginDetailsWindow(session);\n                            } else {\n                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                            }\n                        }));\n    }\n\n    /**\n     * Shows the code that a user must input into their browser\n     */\n    public static void buildAndShowMicrosoftCodeWindow(GeyserSession session, MsaAuthenticationService.MsCodeResponse msCode) {\n        session.sendForm(\n                ModalForm.builder()\n                        .title(\"%xbox.signin\")\n                        .content(\"%xbox.signin.website\\n%xbox.signin.url\\n%xbox.signin.enterCode\\n\" + msCode.user_code)\n                        .button1(\"%gui.done\")\n                        .button2(\"%menu.disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            ModalFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowMicrosoftAuthenticationWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 1) {\n                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                            }\n                        })\n        );\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>org.geysermc</groupId>\n    <artifactId>geyser-parent</artifactId>\n    <version>1.4.1-SNAPSHOT</version>\n    <packaging>pom</packaging>\n    <name>Geyser</name>\n    <description>Allows for players from Minecraft Bedrock Edition to join Minecraft Java Edition servers.</description>\n    <url>https://geysermc.org</url>\n\n    <properties>\n        <outputName>Geyser</outputName>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <organization>\n        <name>GeyserMC</name>\n        <url>https://github.com/GeyserMC/Geyser/blob/master/pom.xml</url>\n    </organization>\n\n    <scm>\n        <connection>scm:git:https://github.com/GeyserMC/Geyser.git</connection>\n        <developerConnection>scm:git:git@github.com:GeyserMC/Geyser.git</developerConnection>\n        <url>https://github.com/GeyserMC/Geyser</url>\n    </scm>\n\n    <modules>\n        <module>ap</module>\n        <module>bootstrap</module>\n        <module>common</module>\n        <module>connector</module>\n    </modules>\n\n    <repositories>\n        <repository>\n            <id>jitpack.io</id>\n            <url>https://jitpack.io</url>\n        </repository>\n        <repository>\n            <id>opencollab-release-repo</id>\n            <url>https://repo.opencollab.dev/maven-releases/</url>\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n        <repository>\n            <id>opencollab-snapshot-repo</id>\n            <url>https://repo.opencollab.dev/maven-snapshots/</url>\n            <releases>\n                <enabled>false</enabled>\n            </releases>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n        </repository>\n        <repository>\n            <id>sonatype</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.20</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n</project>\n"], "fixing_code": ["pipeline {\n    agent any\n    tools {\n        maven 'Maven 3'\n        jdk 'Java 16'\n    }\n    options {\n        buildDiscarder(logRotator(artifactNumToKeepStr: '20'))\n    }\n    stages {\n        stage ('Build') {\n            steps {\n                sh 'git submodule update --init --recursive'\n                sh 'mvn clean package'\n            }\n            post {\n                success {\n                    archiveArtifacts artifacts: 'bootstrap/**/target/*.jar', excludes: 'bootstrap/**/target/original-*.jar', fingerprint: true\n                }\n            }\n        }\n\n        stage ('Deploy') {\n            when {\n                branch \"master\"\n            }\n\n            steps {\n                rtMavenDeployer(\n                        id: \"maven-deployer\",\n                        serverId: \"opencollab-artifactory\",\n                        releaseRepo: \"maven-releases\",\n                        snapshotRepo: \"maven-snapshots\"\n                )\n                rtMavenResolver(\n                        id: \"maven-resolver\",\n                        serverId: \"opencollab-artifactory\",\n                        releaseRepo: \"maven-deploy-release\",\n                        snapshotRepo: \"maven-deploy-snapshot\"\n                )\n                rtMavenRun(\n                        pom: 'pom.xml',\n                        goals: 'javadoc:jar source:jar install -DskipTests',\n                        deployerId: \"maven-deployer\",\n                        resolverId: \"maven-resolver\"\n                )\n                rtPublishBuildInfo(\n                        serverId: \"opencollab-artifactory\"\n                )\n            }\n        }\n    }\n\n    post {\n        always {\n            script {\n                def changeLogSets = currentBuild.changeSets\n                def message = \"**Changes:**\"\n\n                if (changeLogSets.size() == 0) {\n                    message += \"\\n*No changes.*\"\n                } else {\n                    def repositoryUrl = scm.userRemoteConfigs[0].url.replace(\".git\", \"\")\n                    def count = 0;\n                    def extra = 0;\n                    for (int i = 0; i < changeLogSets.size(); i++) {\n                        def entries = changeLogSets[i].items\n                        for (int j = 0; j < entries.length; j++) {\n                            if (count <= 10) {\n                                def entry = entries[j]\n                                def commitId = entry.commitId.substring(0, 6)\n                                message += \"\\n   - [`${commitId}`](${repositoryUrl}/commit/${entry.commitId}) ${entry.msg}\"\n                                count++\n                            } else {\n                                extra++;\n                            }\n                        }\n                    }\n                    \n                    if (extra != 0) {\n                        message += \"\\n   - ${extra} more commits\"\n                    }\n                }\n\n                env.changes = message\n            }\n            deleteDir()\n            withCredentials([string(credentialsId: 'geyser-discord-webhook', variable: 'DISCORD_WEBHOOK')]) {\n                discordSend description: \"**Build:** [${currentBuild.id}](${env.BUILD_URL})\\n**Status:** [${currentBuild.currentResult}](${env.BUILD_URL})\\n${changes}\\n\\n[**Artifacts on Jenkins**](https://ci.opencollab.dev/job/GeyserMC/job/Geyser)\", footer: 'Open Collaboration Jenkins', link: env.BUILD_URL, successful: currentBuild.resultIsBetterOrEqualTo('SUCCESS'), title: \"${env.JOB_NAME} #${currentBuild.id}\", webhookURL: DISCORD_WEBHOOK\n            }\n        }\n        success {\n            script {\n                if (env.BRANCH_NAME == 'master') {\n                    build propagate: false, wait: false, job: 'GeyserMC/Geyser-Fabric/java-1.17', parameters: [booleanParam(name: 'SKIP_DISCORD', value: true)]\n                    build propagate: false, wait: false, job: 'GeyserMC/GeyserConnect/master', parameters: [booleanParam(name: 'SKIP_DISCORD', value: true)]\n                }\n            }\n        }\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n\n    <artifactId>ap</artifactId>\n    <version>1.4.2-SNAPSHOT</version>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-bungeecord</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Used for better working with internals without reflection -->\n        <dependency>\n            <groupId>com.github.SpigotMC.BungeeCord</groupId>\n            <artifactId>bungeecord-proxy</artifactId>\n            <version>a7c6ede</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-BungeeCord</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.bungeecord.GeyserBungeeMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>net.md_5.bungee.jni</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.jni</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <!-- This is not used because relocating breaks natives, but we must include it\n                                     or else we get ClassDefNotFound -->\n                                    <pattern>io.netty.channel.kqueue</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.io.netty.channel.kqueue</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.bungeecord.shaded.kyori</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-parent</artifactId>\n    <packaging>pom</packaging>\n\n    <repositories>\n        <repository>\n            <id>spigot-public</id>\n            <url>https://hub.spigotmc.org/nexus/content/repositories/public/</url>\n        </repository>\n        <repository>\n            <id>sponge-repo</id>\n            <url>https://repo.spongepowered.org/repository/maven-public/</url>\n        </repository>\n        <repository>\n            <id>bungeecord-repo</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots</url>\n        </repository>\n        <repository>\n            <id>velocity-repo</id>\n            <url>https://repo.velocitypowered.com/snapshots/</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>ap</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n    <modules>\n        <module>bungeecord</module>\n        <module>spigot</module>\n        <module>sponge</module>\n        <module>standalone</module>\n        <module>velocity</module>\n    </modules>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-spigot</artifactId>\n\n    <repositories>\n        <repository>\n            <id>viaversion-repo</id>\n            <url>https://repo.viaversion.com</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.spigotmc</groupId>\n            <artifactId>spigot-api</artifactId>\n            <version>1.15.2-R0.1-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.viaversion</groupId>\n            <artifactId>viaversion</artifactId>\n            <version>4.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.geysermc.geyser.adapters</groupId>\n            <artifactId>spigot-all</artifactId>\n            <version>1.2-SNAPSHOT</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Spigot</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.spigot.GeyserSpigotMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.kyori</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>org.objectweb.asm</pattern>\n                                    <shadedPattern>org.geysermc.platform.spigot.shaded.asm</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <!-- We cannot shade Netty, or else native libraries will not load -->\n                            <!-- Needed because older Spigot builds do not provide the haproxy module -->\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-transport-native-kqueue:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-codec-dns:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns:*</exclude>\n                            <exclude>io.netty:netty-resolver-dns-native-macos:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-sponge</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.spongepowered</groupId>\n            <artifactId>spongeapi</artifactId>\n            <version>7.1.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Sponge</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.sponge.GeyserSpongeMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>io.netty</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.netty</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori</pattern>\n                                    <shadedPattern>org.geysermc.platform.sponge.shaded.kyori</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <exclude>org.yaml:*</exclude>\n                            <exclude>org.slf4j:*</exclude>\n                            <exclude>org.ow2.asm:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-standalone</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.minecrell</groupId>\n            <artifactId>terminalconsoleappender</artifactId>\n            <version>1.2.0</version>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.apache.logging.log4j</groupId>\n                    <artifactId>log4j-core</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-reader</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-terminal-jna</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>org.jline</groupId>\n                    <artifactId>jline-terminal</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-terminal</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-terminal-jna</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.jline</groupId>\n            <artifactId>jline-reader</artifactId>\n            <version>3.20.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-api</artifactId>\n            <version>2.13.1</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-core</artifactId>\n            <version>2.13.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.logging.log4j</groupId>\n            <artifactId>log4j-slf4j18-impl</artifactId>\n            <version>2.13.1</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}</finalName>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.standalone.GeyserStandaloneBootstrap</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <dependencies>\n                    <dependency>\n                        <groupId>com.github.edwgiz</groupId>\n                        <artifactId>maven-shade-plugin.log4j2-cachefile-transformer</artifactId>\n                        <version>2.8.1</version>\n                    </dependency>\n                </dependencies>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <minimizeJar>false</minimizeJar>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <filters>\n                        <filter>\n                            <artifact>*:*</artifact>\n                            <excludes>\n                                <exclude>META-INF/versions/9/module-info.class</exclude>\n                            </excludes>\n                        </filter>\n                    </filters>\n                    <transformers>\n                        <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                            <mainClass>org.geysermc.platform.standalone.GeyserStandaloneBootstrap</mainClass>\n                            <manifestEntries>\n                                <Multi-Release>true</Multi-Release>\n                            </manifestEntries>\n                        </transformer>\n                        <transformer\n                                implementation=\"com.github.edwgiz.mavenShadePlugin.log4j2CacheTransformer.PluginsCacheFileTransformer\">\n                        </transformer>\n                    </transformers>\n                    <dependencyReducedPomLocation>${project.build.directory}/dependency-reduced-pom.xml</dependencyReducedPomLocation>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>bootstrap-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>bootstrap-velocity</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>connector</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.velocitypowered</groupId>\n            <artifactId>velocity-api</artifactId>\n            <version>3.0.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    <build>\n        <finalName>${outputName}-Velocity</finalName>\n        <resources>\n            <resource>\n                <directory>src/main/resources/</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <archive>\n                        <manifestEntries>\n                            <Main-Class>org.geysermc.platform.velocity.GeyserVelocityMain</Main-Class>\n                        </manifestEntries>\n                    </archive>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>com.fasterxml.jackson</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.jackson</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>it.unimi.dsi.fastutil</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.fastutil</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.common</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.google.common</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>com.google.guava</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.google.guava</shadedPattern>\n                                </relocation>\n                                <relocation>\n                                    <pattern>net.kyori.adventure.text.serializer.gson.legacyimpl</pattern>\n                                    <shadedPattern>org.geysermc.platform.velocity.shaded.kyori.legacyimpl</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n                <configuration>\n                    <artifactSet>\n                        <excludes>\n                            <exclude>com.google.code.gson:*</exclude>\n                            <!-- Needed because Velocity provides every dependency except netty-resolver-dns -->\n                            <exclude>io.netty:netty-transport-native-epoll:*</exclude>\n                            <exclude>io.netty:netty-transport-native-unix-common:*</exclude>\n                            <exclude>io.netty:netty-transport-native-kqueue:*</exclude>\n                            <exclude>io.netty:netty-handler:*</exclude>\n                            <exclude>io.netty:netty-common:*</exclude>\n                            <exclude>io.netty:netty-buffer:*</exclude>\n                            <exclude>io.netty:netty-resolver:*</exclude>\n                            <exclude>io.netty:netty-transport:*</exclude>\n                            <exclude>io.netty:netty-codec:*</exclude>\n                            <exclude>io.netty:netty-codec-haproxy:*</exclude>\n                            <exclude>org.slf4j:*</exclude>\n                            <exclude>org.ow2.asm:*</exclude>\n                            <!-- Exclude all Kyori dependencies except the legacy NBT serializer -->\n                            <exclude>net.kyori:adventure-api:*</exclude>\n                            <exclude>net.kyori:examination-api:*</exclude>\n                            <exclude>net.kyori:examination-string:*</exclude>\n                            <exclude>net.kyori:adventure-text-serializer-gson:*</exclude>\n                            <exclude>net.kyori:adventure-text-serializer-legacy:*</exclude>\n                            <exclude>net.kyori:adventure-nbt:*</exclude>\n                        </excludes>\n                    </artifactSet>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>common</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc.cumulus</groupId>\n            <artifactId>cumulus</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.8.6</version>\n        </dependency>\n    </dependencies>\n</project>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <parent>\n        <groupId>org.geysermc</groupId>\n        <artifactId>geyser-parent</artifactId>\n        <version>1.4.2-SNAPSHOT</version>\n    </parent>\n    <artifactId>connector</artifactId>\n\n    <properties>\n        <adventure.version>4.8.0</adventure.version>\n        <fastutil.version>8.5.2</fastutil.version>\n        <jackson.version>2.12.4</jackson.version>\n        <netty.version>4.1.66.Final</netty.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>ap</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.geysermc</groupId>\n            <artifactId>common</artifactId>\n            <version>1.4.2-SNAPSHOT</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Jackson JSON and YAML serialization -->\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.dataformat</groupId>\n            <artifactId>jackson-dataformat-yaml</artifactId>\n            <version>${jackson.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.google.guava</groupId>\n            <artifactId>guava</artifactId>\n            <version>29.0-jre</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- fastutil maps -->\n        <dependency>\n            <groupId>com.nukkitx</groupId>\n            <artifactId>nbt</artifactId>\n            <!-- Used for key/value interning -->\n            <version>2.1.0</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-int-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-long-long-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-byte-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-int-boolean-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-object-int-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.fastutil</groupId>\n            <artifactId>fastutil-object-object-maps</artifactId>\n            <version>${fastutil.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Network libraries -->\n        <dependency>\n            <groupId>org.java-websocket</groupId>\n            <artifactId>Java-WebSocket</artifactId>\n            <version>1.5.1</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.github.CloudburstMC.Protocol</groupId>\n            <artifactId>bedrock-v448</artifactId>\n            <version>6ce2f6e</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>com.nukkitx.network</groupId>\n                    <artifactId>raknet</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.nukkitx</groupId>\n                    <artifactId>nbt</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.nukkitx.network</groupId>\n            <artifactId>raknet</artifactId>\n            <version>1.6.26-20210217.205834-2</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>io.netty</groupId>\n                    <artifactId>*</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>MCAuthLib</artifactId>\n            <version>0e48a094f2</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>MCProtocolLib</artifactId>\n            <version>e17787a</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>net.kyori</groupId>\n                    <artifactId>adventure-text-serializer-gson</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.github.steveice10</groupId>\n                    <artifactId>packetlib</artifactId>\n                </exclusion>\n                <exclusion>\n                    <groupId>com.github.steveice10</groupId>\n                    <artifactId>mcauthlib</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>com.github.GeyserMC</groupId>\n            <artifactId>PacketLib</artifactId>\n            <version>86c9c38</version>\n            <scope>compile</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>io.netty</groupId>\n                    <artifactId>netty-all</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-resolver-dns</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-resolver-dns-native-macos</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>osx-x86_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-codec-haproxy</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Network dependencies we are updating ourselves -->\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-handler</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-epoll</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>linux-x86_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-epoll</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>linux-aarch_64</classifier>\n        </dependency>\n        <dependency>\n            <groupId>io.netty</groupId>\n            <artifactId>netty-transport-native-kqueue</artifactId>\n            <version>${netty.version}</version>\n            <scope>compile</scope>\n            <classifier>osx-x86_64</classifier>\n        </dependency>\n        <!-- Adventure text serialization -->\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-api</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-gson</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-legacy</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <dependency>\n            <groupId>net.kyori</groupId>\n            <artifactId>adventure-text-serializer-gson-legacy-impl</artifactId>\n            <version>${adventure.version}</version>\n            <scope>compile</scope>\n        </dependency>\n        <!-- Other -->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.0</version>\n                <configuration>\n                    <excludes>\n                        <exclude>**/services/javax.annotation.processing.Processor</exclude>\n                    </excludes>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>pl.project13.maven</groupId>\n                <artifactId>git-commit-id-plugin</artifactId>\n                <version>4.0.0</version>\n                <executions>\n                    <execution>\n                        <id>get-the-git-infos</id>\n                        <goals>\n                            <goal>revision</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <generateGitPropertiesFile>true</generateGitPropertiesFile>\n                    <generateGitPropertiesFilename>${project.build.outputDirectory}/git.properties</generateGitPropertiesFilename>\n                    <format>properties</format>\n                    <failOnNoGitDirectory>false</failOnNoGitDirectory>\n                    <failOnUnableToExtractRepoInfo>false</failOnUnableToExtractRepoInfo>\n                    <runOnlyOnce>false</runOnlyOnce>\n                    <verbose>true</verbose>\n                    <skipPoms>false</skipPoms>\n                    <excludeProperties>\n                        <excludeProperty>git.user.*</excludeProperty>\n                        <excludeProperty>git.*.user.*</excludeProperty>\n                        <excludeProperty>git.closest.*</excludeProperty>\n                        <excludeProperty>git.commit.id.describe</excludeProperty>\n                        <excludeProperty>git.commit.id.describe-short</excludeProperty>\n                        <excludeProperty>git.commit.message.short</excludeProperty>\n                    </excludeProperties>\n                    <commitIdGenerationMode>flat</commitIdGenerationMode>\n                    <gitDescribe>\n                        <always>true</always>\n                    </gitDescribe>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>com.google.code.maven-replacer-plugin</groupId>\n                <artifactId>replacer</artifactId>\n                <version>1.5.3</version>\n                <executions>\n                    <execution>\n                        <id>add-version</id>\n                        <phase>process-sources</phase>\n                        <goals>\n                            <goal>replace</goal>\n                        </goals>\n                        <configuration>\n                            <includes>\n                                <include>${project.basedir}/src/main/java/org/geysermc/connector/GeyserConnector.java</include>\n                            </includes>\n                            <replacements>\n                                <replacement>\n                                    <token>String VERSION = \".*\"</token>\n                                    <value>String VERSION = \"${project.version} (\" + GIT_VERSION + \")\"</value>\n                                </replacement>\n                                <replacement>\n                                    <token>String GIT_VERSION = \".*\"</token>\n                                    <!--suppress UnresolvedMavenProperty -->\n                                    <value>String GIT_VERSION = \"git-${git.branch}-${git.commit.id.abbrev}\"</value>\n                                </replacement>\n                            </replacements>\n                        </configuration>\n                    </execution>\n\n                    <execution>\n                        <id>remove-version</id>\n                        <phase>process-classes</phase>\n                        <goals>\n                            <goal>replace</goal>\n                        </goals>\n                        <configuration>\n                            <includes>\n                                <include>${project.basedir}/src/main/java/org/geysermc/connector/GeyserConnector.java</include>\n                            </includes>\n                            <replacements>\n                                <replacement>\n                                    <token>String VERSION = \".*\"</token>\n                                    <value>String VERSION = \"DEV\"</value>\n                                </replacement>\n                                <replacement>\n                                    <token>String GIT_VERSION = \".*\"</token>\n                                    <value>String GIT_VERSION = \"DEV\"</value>\n                                </replacement>\n                            </replacements>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <version>2.22.0</version>\n                <configuration>\n                    <!-- Force the right file encoding during unit testing -->\n                    <argLine>-Dfile.encoding=${project.build.sourceEncoding}</argLine>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network;\n\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport com.nukkitx.protocol.bedrock.BedrockPacketCodec;\nimport com.nukkitx.protocol.bedrock.data.ExperimentData;\nimport com.nukkitx.protocol.bedrock.data.ResourcePackType;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.configuration.GeyserConfiguration;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslatorRegistry;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.utils.*;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\npublic class UpstreamPacketHandler extends LoggingPacketHandler {\n\n    public UpstreamPacketHandler(GeyserConnector connector, GeyserSession session) {\n        super(connector, session);\n    }\n\n    private boolean translateAndDefault(BedrockPacket packet) {\n        return PacketTranslatorRegistry.BEDROCK_TRANSLATOR.translate(packet.getClass(), packet, session);\n    }\n\n    @Override\n    boolean defaultHandler(BedrockPacket packet) {\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(LoginPacket loginPacket) {\n        BedrockPacketCodec packetCodec = BedrockProtocol.getBedrockCodec(loginPacket.getProtocolVersion());\n        if (packetCodec == null) {\n            String supportedVersions = BedrockProtocol.getAllSupportedVersions();\n            if (loginPacket.getProtocolVersion() > BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {\n                // Too early to determine session locale\n                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.server\", supportedVersions));\n                return true;\n            } else if (loginPacket.getProtocolVersion() < BedrockProtocol.DEFAULT_BEDROCK_CODEC.getProtocolVersion()) {\n                session.getConnector().getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.outdated.client\", supportedVersions));\n                return true;\n            }\n        }\n\n        session.getUpstream().getSession().setPacketCodec(packetCodec);\n\n        // Set the block translation based off of version\n        session.setBlockMappings(BlockRegistries.BLOCKS.forVersion(loginPacket.getProtocolVersion()));\n        session.setItemMappings(Registries.ITEMS.forVersion(loginPacket.getProtocolVersion()));\n\n        LoginEncryptionUtils.encryptPlayerConnection(session, loginPacket);\n\n        PlayStatusPacket playStatus = new PlayStatusPacket();\n        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        session.sendUpstreamPacket(playStatus);\n\n        ResourcePacksInfoPacket resourcePacksInfo = new ResourcePacksInfoPacket();\n        for(ResourcePack resourcePack : ResourcePack.PACKS.values()) {\n            ResourcePackManifest.Header header = resourcePack.getManifest().getHeader();\n            resourcePacksInfo.getResourcePackInfos().add(new ResourcePacksInfoPacket.Entry(\n                    header.getUuid().toString(), header.getVersionString(), resourcePack.getFile().length(),\n                            \"\", \"\", \"\", false, false));\n        }\n        resourcePacksInfo.setForcedToAccept(GeyserConnector.getInstance().getConfig().isForceResourcePacks());\n        session.sendUpstreamPacket(resourcePacksInfo);\n        return true;\n    }\n\n    @Override\n    public boolean handle(ResourcePackClientResponsePacket packet) {\n        switch (packet.getStatus()) {\n            case COMPLETED:\n                session.connect();\n                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.network.connect\", session.getAuthData().getName()));\n                break;\n\n            case SEND_PACKS:\n                for(String id : packet.getPackIds()) {\n                    ResourcePackDataInfoPacket data = new ResourcePackDataInfoPacket();\n                    String[] packID = id.split(\"_\");\n                    ResourcePack pack = ResourcePack.PACKS.get(packID[0]);\n                    ResourcePackManifest.Header header = pack.getManifest().getHeader();\n\n                    data.setPackId(header.getUuid());\n                    int chunkCount = (int) Math.ceil((int) pack.getFile().length() / (double) ResourcePack.CHUNK_SIZE);\n                    data.setChunkCount(chunkCount);\n                    data.setCompressedPackSize(pack.getFile().length());\n                    data.setMaxChunkSize(ResourcePack.CHUNK_SIZE);\n                    data.setHash(pack.getSha256());\n                    data.setPackVersion(packID[1]);\n                    data.setPremium(false);\n                    data.setType(ResourcePackType.RESOURCE);\n\n                    session.sendUpstreamPacket(data);\n                }\n                break;\n\n            case HAVE_ALL_PACKS:\n                ResourcePackStackPacket stackPacket = new ResourcePackStackPacket();\n                stackPacket.setExperimentsPreviouslyToggled(false);\n                stackPacket.setForcedToAccept(false); // Leaving this as false allows the player to choose to download or not\n                stackPacket.setGameVersion(session.getClientData().getGameVersion());\n\n                for (ResourcePack pack : ResourcePack.PACKS.values()) {\n                    ResourcePackManifest.Header header = pack.getManifest().getHeader();\n                    stackPacket.getResourcePacks().add(new ResourcePackStackPacket.Entry(header.getUuid().toString(), header.getVersionString(), \"\"));\n                }\n\n                if (session.getItemMappings().getFurnaceMinecartData() != null) {\n                    // Allow custom items to work\n                    stackPacket.getExperiments().add(new ExperimentData(\"data_driven_items\", true));\n                }\n\n                if (session.getConnector().getConfig().isExtendedWorldHeight()) {\n                    // Allow extended world height in the overworld to work\n                    stackPacket.getExperiments().add(new ExperimentData(\"caves_and_cliffs\", true));\n                }\n\n                session.sendUpstreamPacket(stackPacket);\n                break;\n\n            default:\n                session.disconnect(\"disconnectionScreen.resourcePack\");\n                break;\n        }\n\n        return true;\n    }\n\n    @Override\n    public boolean handle(ModalFormResponsePacket packet) {\n        session.executeInEventLoop(() -> session.getFormCache().handleResponse(packet));\n        return true;\n    }\n\n    private boolean couldLoginUserByName(String bedrockUsername) {\n        if (connector.getConfig().getUserAuths() != null) {\n            GeyserConfiguration.IUserAuthenticationInfo info = connector.getConfig().getUserAuths().get(bedrockUsername);\n\n            if (info != null) {\n                connector.getLogger().info(LanguageUtils.getLocaleStringLog(\"geyser.auth.stored_credentials\", session.getAuthData().getName()));\n                session.setMicrosoftAccount(info.isMicrosoftAccount());\n                session.authenticate(info.getEmail(), info.getPassword());\n\n                // TODO send a message to bedrock user telling them they are connected (if nothing like a motd\n                //      somes from the Java server w/in a few seconds)\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean handle(SetLocalPlayerAsInitializedPacket packet) {\n        LanguageUtils.loadGeyserLocale(session.getLocale());\n\n        if (!session.isLoggedIn() && !session.isLoggingIn() && session.getRemoteAuthType() == AuthType.ONLINE) {\n            // TODO it is safer to key authentication on something that won't change (UUID, not username)\n            if (!couldLoginUserByName(session.getAuthData().getName())) {\n                LoginEncryptionUtils.buildAndShowLoginWindow(session);\n            }\n            // else we were able to log the user in\n        }\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(MovePlayerPacket packet) {\n        if (session.isLoggingIn()) {\n            SetTitlePacket titlePacket = new SetTitlePacket();\n            titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n            titlePacket.setText(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.wait\", session.getLocale()));\n            titlePacket.setFadeInTime(0);\n            titlePacket.setFadeOutTime(1);\n            titlePacket.setStayTime(2);\n            titlePacket.setXuid(\"\");\n            titlePacket.setPlatformOnlineId(\"\");\n            session.sendUpstreamPacket(titlePacket);\n        }\n\n        return translateAndDefault(packet);\n    }\n\n    @Override\n    public boolean handle(ResourcePackChunkRequestPacket packet) {\n        ResourcePackChunkDataPacket data = new ResourcePackChunkDataPacket();\n        ResourcePack pack = ResourcePack.PACKS.get(packet.getPackId().toString());\n\n        data.setChunkIndex(packet.getChunkIndex());\n        data.setProgress(packet.getChunkIndex() * ResourcePack.CHUNK_SIZE);\n        data.setPackVersion(packet.getPackVersion());\n        data.setPackId(packet.getPackId());\n\n        int offset = packet.getChunkIndex() * ResourcePack.CHUNK_SIZE;\n        byte[] packData = new byte[(int) MathUtils.constrain(pack.getFile().length() - offset, 0, ResourcePack.CHUNK_SIZE)];\n\n        try (InputStream inputStream = new FileInputStream(pack.getFile())) {\n            inputStream.skip(offset);\n            inputStream.read(packData, 0, packData.length);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        data.setData(packData);\n\n        session.sendUpstreamPacket(data);\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators;\n\nimport org.geysermc.connector.network.session.GeyserSession;\n\npublic abstract class PacketTranslator<T> {\n\n    public abstract void translate(GeyserSession session, T packet);\n\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListDataPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateLightPacket;\nimport com.github.steveice10.packetlib.packet.Packet;\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport io.netty.channel.EventLoop;\nimport it.unimi.dsi.fastutil.objects.ObjectArrayList;\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.utils.FileUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\npublic class PacketTranslatorRegistry<T> {\n    private final Map<Class<? extends T>, PacketTranslator<? extends T>> translators = new IdentityHashMap<>();\n\n    public static final PacketTranslatorRegistry<Packet> JAVA_TRANSLATOR = new PacketTranslatorRegistry<>();\n    public static final PacketTranslatorRegistry<BedrockPacket> BEDROCK_TRANSLATOR = new PacketTranslatorRegistry<>();\n\n    private static final ObjectArrayList<Class<?>> IGNORED_PACKETS = new ObjectArrayList<>();\n\n    static {\n        for (Class<?> clazz : FileUtils.getGeneratedClassesForAnnotation(Translator.class)) {\n            Class<?> packet = clazz.getAnnotation(Translator.class).packet();\n\n            GeyserConnector.getInstance().getLogger().debug(\"Found annotated translator: \" + clazz.getCanonicalName() + \" : \" + packet.getSimpleName());\n\n            try {\n                if (Packet.class.isAssignableFrom(packet)) {\n                    Class<? extends Packet> targetPacket = (Class<? extends Packet>) packet;\n                    PacketTranslator<? extends Packet> translator = (PacketTranslator<? extends Packet>) clazz.newInstance();\n\n                    JAVA_TRANSLATOR.translators.put(targetPacket, translator);\n                } else if (BedrockPacket.class.isAssignableFrom(packet)) {\n                    Class<? extends BedrockPacket> targetPacket = (Class<? extends BedrockPacket>) packet;\n                    PacketTranslator<? extends BedrockPacket> translator = (PacketTranslator<? extends BedrockPacket>) clazz.newInstance();\n\n                    BEDROCK_TRANSLATOR.translators.put(targetPacket, translator);\n                } else {\n                    GeyserConnector.getInstance().getLogger().error(\"Class \" + clazz.getCanonicalName() + \" is annotated as a translator but has an invalid target packet.\");\n                }\n            } catch (InstantiationException | IllegalAccessException e) {\n                GeyserConnector.getInstance().getLogger().error(\"Could not instantiate annotated translator \" + clazz.getCanonicalName());\n            }\n        }\n\n        IGNORED_PACKETS.add(ServerUpdateLightPacket.class); // Light is handled on Bedrock for us\n        IGNORED_PACKETS.add(ServerPlayerListDataPacket.class); // Cant be implemented in bedrock\n    }\n\n    private PacketTranslatorRegistry() {\n    }\n\n    public static void init() {\n        // no-op\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <P extends T> boolean translate(Class<? extends P> clazz, P packet, GeyserSession session) {\n        if (!session.getUpstream().isClosed() && !session.isClosed()) {\n            PacketTranslator<P> translator = (PacketTranslator<P>) translators.get(clazz);\n            if (translator != null) {\n                EventLoop eventLoop = session.getEventLoop();\n                if (eventLoop.inEventLoop()) {\n                    translate0(session, translator, packet);\n                } else {\n                    eventLoop.execute(() -> translate0(session, translator, packet));\n                }\n                return true;\n            } else {\n                if ((GeyserConnector.getInstance().getPlatformType() != PlatformType.STANDALONE || !(packet instanceof BedrockPacket)) && !IGNORED_PACKETS.contains(clazz)) {\n                    // Other debug logs already take care of Bedrock packets for us if on standalone\n                    GeyserConnector.getInstance().getLogger().debug(\"Could not find packet for \" + (packet.toString().length() > 25 ? packet.getClass().getSimpleName() : packet));\n                }\n            }\n        }\n        return false;\n    }\n\n    private <P extends T> void translate0(GeyserSession session, PacketTranslator<P> translator, P packet) {\n        if (session.isClosed()) {\n            return;\n        }\n\n        try {\n            translator.translate(session, packet);\n        } catch (Throwable ex) {\n            GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.packet.failed\", packet.getClass().getSimpleName()), ex);\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerAbilitiesPacket;\nimport com.nukkitx.protocol.bedrock.data.AdventureSetting;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.AdventureSettingsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = AdventureSettingsPacket.class)\npublic class BedrockAdventureSettingsTranslator extends PacketTranslator<AdventureSettingsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, AdventureSettingsPacket packet) {\n        boolean isFlying = packet.getSettings().contains(AdventureSetting.FLYING);\n        if (!isFlying && session.getGameMode() == GameMode.SPECTATOR) {\n            // We should always be flying in spectator mode\n            session.sendAdventureSettings();\n            return;\n        }\n\n        session.setFlying(isFlying);\n        ClientPlayerAbilitiesPacket abilitiesPacket = new ClientPlayerAbilitiesPacket(isFlying);\n        session.sendDownstreamPacket(abilitiesPacket);\n\n        if (isFlying && session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.SWIMMING)) {\n            // Bedrock can fly and swim at the same time? Make sure that can't happen\n            session.setSwimming(false);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerSwingArmPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerBoatPacket;\nimport com.nukkitx.protocol.bedrock.packet.AnimatePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = AnimatePacket.class)\npublic class BedrockAnimateTranslator extends PacketTranslator<AnimatePacket> {\n\n    @Override\n    public void translate(GeyserSession session, AnimatePacket packet) {\n        // Stop the player sending animations before they have fully spawned into the server\n        if (!session.isSpawned()) {\n            return;\n        }\n\n        switch (packet.getAction()) {\n            case SWING_ARM:\n                // Delay so entity damage can be processed first\n                session.scheduleInEventLoop(() ->\n                        session.sendDownstreamPacket(new ClientPlayerSwingArmPacket(Hand.MAIN_HAND)),\n                        25,\n                        TimeUnit.MILLISECONDS\n                );\n                break;\n            // These two might need to be flipped, but my recommendation is getting moving working first\n            case ROW_LEFT:\n                // Packet value is a float of how long one has been rowing, so we convert that into a boolean\n                session.setSteeringLeft(packet.getRowingTime() > 0.0);\n                ClientSteerBoatPacket steerLeftPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());\n                session.sendDownstreamPacket(steerLeftPacket);\n                break;\n            case ROW_RIGHT:\n                session.setSteeringRight(packet.getRowingTime() > 0.0);\n                ClientSteerBoatPacket steerRightPacket = new ClientSteerBoatPacket(session.isSteeringLeft(), session.isSteeringRight());\n                session.sendDownstreamPacket(steerRightPacket);\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateJigsawBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientUpdateSignPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.SignUtils;\n\n@Translator(packet = BlockEntityDataPacket.class)\npublic class BedrockBlockEntityDataTranslator extends PacketTranslator<BlockEntityDataPacket> {\n\n    @Override\n    public void translate(GeyserSession session, BlockEntityDataPacket packet) {\n        NbtMap tag = packet.getData();\n        if (tag.getString(\"id\").equals(\"Sign\")) {\n            // This is the reason why this all works - Bedrock sends packets every time you update the sign, Java only wants the final packet\n            // But Bedrock sends one final packet when you're done editing the sign, which should be equal to the last message since there's no edits\n            // So if the latest update does not match the last cached update then it's still being edited\n            if (!tag.getString(\"Text\").equals(session.getLastSignMessage())) {\n                session.setLastSignMessage(tag.getString(\"Text\"));\n                return;\n            }\n            // Otherwise the two messages are identical and we can get to work deconstructing\n            StringBuilder newMessage = new StringBuilder();\n            // While Bedrock's sign lines are one string, Java's is an array of each line\n            // (Initialized all with empty strings because it complains about null)\n            String[] lines = new String[] {\"\", \"\", \"\", \"\"};\n            int iterator = 0;\n            // Keep track of the width of each character\n            // If it goes over the maximum, we need to start a new line to match Java\n            int widthCount = 0;\n            // This converts the message into the array'd message Java wants\n            for (char character : tag.getString(\"Text\").toCharArray()) {\n                widthCount += SignUtils.getCharacterWidth(character);\n                // If we get a return in Bedrock, or go over the character width max, that signals to use the next line.\n                if (character == '\\n' || widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX) {\n                    // We need to apply some more logic if we went over the character width max\n                    boolean wentOverMax = widthCount > SignUtils.JAVA_CHARACTER_WIDTH_MAX && character != '\\n';\n                    widthCount = 0;\n                    // Saves if we're moving a word to the next line\n                    String word = null;\n                    if (wentOverMax && iterator < lines.length - 1) {\n                        // If we went over the max, we want to try to wrap properly like Bedrock does.\n                        // So we look for a space in the Bedrock user's text to imply a word.\n                        int index = newMessage.lastIndexOf(\" \");\n                        if (index != -1) {\n                            // There is indeed a space in this line; let's get it\n                            word = newMessage.substring(index + 1);\n                            // 'Delete' that word from the string builder\n                            newMessage.delete(index, newMessage.length());\n                        }\n                    }\n                    lines[iterator] = newMessage.toString();\n                    iterator++;\n                    // Bedrock, for whatever reason, can hold a message out of the bounds of the four lines\n                    // We don't care about that so we discard that\n                    if (iterator > lines.length - 1) {\n                        break;\n                    }\n                    newMessage = new StringBuilder();\n                    if (wentOverMax) {\n                        // Apply the wrapped word to the new line\n                        if (word != null) {\n                            newMessage.append(word);\n                            // And apply the width count\n                            for (char wordCharacter : word.toCharArray()) {\n                                widthCount += SignUtils.getCharacterWidth(wordCharacter);\n                            }\n                        }\n                        // If we went over the max, we want to append the character to the new line.\n                        newMessage.append(character);\n                        widthCount += SignUtils.getCharacterWidth(character);\n                    }\n                } else newMessage.append(character);\n            }\n            // Put the final line on since it isn't done in the for loop\n            if (iterator < lines.length) lines[iterator] = newMessage.toString();\n            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));\n            ClientUpdateSignPacket clientUpdateSignPacket = new ClientUpdateSignPacket(pos, lines);\n            session.sendDownstreamPacket(clientUpdateSignPacket);\n\n            // We set the sign text cached in the session to null to indicate there is no work-in-progress sign\n            session.setLastSignMessage(null);\n\n        } else if (tag.getString(\"id\").equals(\"JigsawBlock\")) {\n            // Client has just sent a jigsaw block update\n            Position pos = new Position(tag.getInt(\"x\"), tag.getInt(\"y\"), tag.getInt(\"z\"));\n            String name = tag.getString(\"name\");\n            String target = tag.getString(\"target\");\n            String pool = tag.getString(\"target_pool\");\n            String finalState = tag.getString(\"final_state\");\n            String joint = tag.getString(\"joint\");\n            ClientUpdateJigsawBlockPacket jigsawPacket = new ClientUpdateJigsawBlockPacket(pos, name, target, pool,\n                    finalState, joint);\n            session.sendDownstreamPacket(jigsawPacket);\n        }\n\n    }\n}\n", "/*\r\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n * @author GeyserMC\r\n * @link https://github.com/GeyserMC/Geyser\r\n */\r\n\r\npackage org.geysermc.connector.network.translators.bedrock;\r\n\r\nimport com.nukkitx.math.vector.Vector3i;\r\nimport com.nukkitx.protocol.bedrock.packet.BlockPickRequestPacket;\r\nimport org.geysermc.connector.entity.ItemFrameEntity;\r\nimport org.geysermc.connector.entity.type.EntityType;\r\nimport org.geysermc.connector.network.session.GeyserSession;\r\nimport org.geysermc.connector.network.translators.PacketTranslator;\r\nimport org.geysermc.connector.network.translators.Translator;\r\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\r\nimport org.geysermc.connector.registry.BlockRegistries;\r\nimport org.geysermc.connector.utils.InventoryUtils;\r\n\r\n@Translator(packet = BlockPickRequestPacket.class)\r\npublic class BedrockBlockPickRequestTranslator extends PacketTranslator<BlockPickRequestPacket> {\r\n\r\n    @Override\r\n    public void translate(GeyserSession session, BlockPickRequestPacket packet) {\r\n        Vector3i vector = packet.getBlockPosition();\r\n        int blockToPick = session.getConnector().getWorldManager().getBlockAt(session, vector.getX(), vector.getY(), vector.getZ());\r\n        \r\n        // Block is air - chunk caching is probably off\r\n        if (blockToPick == BlockStateValues.JAVA_AIR_ID) {\r\n            // Check for an item frame since the client thinks that's a block when it's an entity in Java\r\n            ItemFrameEntity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\r\n            if (entity != null) {\r\n                // Check to see if the item frame has an item in it first\r\n                if (entity.getHeldItem() != null && entity.getHeldItem().getId() != 0) {\r\n                    // Grab the item in the frame\r\n                    InventoryUtils.findOrCreateItem(session, entity.getHeldItem());\r\n                } else {\r\n                    // Grab the frame as the item\r\n                    InventoryUtils.findOrCreateItem(session, entity.getEntityType() == EntityType.GLOW_ITEM_FRAME ? \"minecraft:glow_item_frame\" : \"minecraft:item_frame\");\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        InventoryUtils.findOrCreateItem(session, BlockRegistries.JAVA_BLOCKS.get(blockToPick).getPickItem());\r\n    }\r\n}\r\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientEditBookPacket;\nimport com.github.steveice10.opennbt.tag.builtin.CompoundTag;\nimport com.github.steveice10.opennbt.tag.builtin.ListTag;\nimport com.github.steveice10.opennbt.tag.builtin.StringTag;\nimport com.github.steveice10.opennbt.tag.builtin.Tag;\nimport com.nukkitx.protocol.bedrock.packet.BookEditPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\n@Translator(packet = BookEditPacket.class)\npublic class BedrockBookEditTranslator extends PacketTranslator<BookEditPacket> {\n    private static final int MAXIMUM_PAGE_LENGTH = 8192 * 4;\n    private static final int MAXIMUM_TITLE_LENGTH = 128 * 4;\n\n    @Override\n    public void translate(GeyserSession session, BookEditPacket packet) {\n        if (packet.getText() != null && !packet.getText().isEmpty() && packet.getText().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_PAGE_LENGTH) {\n            session.getConnector().getLogger().warning(\"Page length greater than server allowed!\");\n            return;\n        }\n\n        GeyserItemStack itemStack = session.getPlayerInventory().getItemInHand();\n        if (itemStack != null) {\n            CompoundTag tag = itemStack.getNbt() != null ? itemStack.getNbt() : new CompoundTag(\"\");\n            ItemStack bookItem = new ItemStack(itemStack.getJavaId(), itemStack.getAmount(), tag);\n            List<Tag> pages = tag.contains(\"pages\") ? new LinkedList<>(((ListTag) tag.get(\"pages\")).getValue()) : new LinkedList<>();\n\n            int page = packet.getPageNumber();\n            switch (packet.getAction()) {\n                case ADD_PAGE: {\n                    // Add empty pages in between\n                    for (int i = pages.size(); i < page; i++) {\n                        pages.add(i, new StringTag(\"\", \"\"));\n                    }\n                    pages.add(page, new StringTag(\"\", packet.getText()));\n                    break;\n                }\n                // Called whenever a page is modified\n                case REPLACE_PAGE: {\n                    if (page < pages.size()) {\n                        pages.set(page, new StringTag(\"\", packet.getText()));\n                    } else {\n                        // Add empty pages in between\n                        for (int i = pages.size(); i < page; i++) {\n                            pages.add(i, new StringTag(\"\", \"\"));\n                        }\n                        pages.add(page, new StringTag(\"\", packet.getText()));\n                    }\n                    break;\n                }\n                case DELETE_PAGE: {\n                    if (page < pages.size()) {\n                        pages.remove(page);\n                    }\n                    break;\n                }\n                case SWAP_PAGES: {\n                    int page2 = packet.getSecondaryPageNumber();\n                    if (page < pages.size() && page2 < pages.size()) {\n                        Collections.swap(pages, page, page2);\n                    }\n                    break;\n                }\n                case SIGN_BOOK: {\n                    tag.put(new StringTag(\"author\", packet.getAuthor()));\n                    tag.put(new StringTag(\"title\", packet.getTitle()));\n                    break;\n                }\n                default:\n                    return;\n            }\n            // Remove empty pages at the end\n            while (pages.size() > 0) {\n                StringTag currentPage = (StringTag) pages.get(pages.size() - 1);\n                if (currentPage.getValue() == null || currentPage.getValue().isEmpty()) {\n                    pages.remove(pages.size() - 1);\n                } else {\n                    break;\n                }\n            }\n            tag.put(new ListTag(\"pages\", pages));\n            // Update local copy\n            session.getPlayerInventory().setItem(36 + session.getPlayerInventory().getHeldItemSlot(), GeyserItemStack.from(bookItem), session);\n            session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());\n\n            List<String> networkPages = new ArrayList<>();\n            for (Tag pageTag : pages) {\n                networkPages.add(((StringTag) pageTag).getValue());\n            }\n\n            String title;\n            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {\n                // Add title to packet so the server knows we're signing\n                if (packet.getTitle().getBytes(StandardCharsets.UTF_8).length > MAXIMUM_TITLE_LENGTH) {\n                    session.getConnector().getLogger().warning(\"Book title larger than server allows!\");\n                    return;\n                }\n\n                title = packet.getTitle();\n            } else {\n                title = null;\n            }\n\n            session.getBookEditCache().setPacket(new ClientEditBookPacket(session.getPlayerInventory().getHeldItemSlot(), networkPages, title));\n            // There won't be any more book updates after this, so we can try sending the edit packet immediately\n            if (packet.getAction() == BookEditPacket.Action.SIGN_BOOK) {\n                session.getBookEditCache().checkForSend();\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.world.block.CommandBlockMode;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockMinecartPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientUpdateCommandBlockPacket;\nimport com.nukkitx.protocol.bedrock.packet.CommandBlockUpdatePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = CommandBlockUpdatePacket.class)\npublic class BedrockCommandBlockUpdateTranslator extends PacketTranslator<CommandBlockUpdatePacket> {\n\n    @Override\n    public void translate(GeyserSession session, CommandBlockUpdatePacket packet) {\n        String command = packet.getCommand();\n        boolean outputTracked = packet.isOutputTracked();\n        if (packet.isBlock()) {\n            CommandBlockMode mode;\n            switch (packet.getMode()) {\n                case CHAIN: // The green one\n                    mode = CommandBlockMode.SEQUENCE;\n                    break;\n                case REPEATING: // The purple one\n                    mode = CommandBlockMode.AUTO;\n                    break;\n                default: // NORMAL, the orange one\n                    mode = CommandBlockMode.REDSTONE;\n                    break;\n            }\n            boolean isConditional = packet.isConditional();\n            boolean automatic = !packet.isRedstoneMode(); // Automatic = Always Active option in Java\n            ClientUpdateCommandBlockPacket commandBlockPacket = new ClientUpdateCommandBlockPacket(\n                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                    command, mode, outputTracked, isConditional, automatic);\n            session.sendDownstreamPacket(commandBlockPacket);\n        } else {\n            ClientUpdateCommandBlockMinecartPacket commandMinecartPacket = new ClientUpdateCommandBlockMinecartPacket(\n                    (int) session.getEntityCache().getEntityByGeyserId(packet.getMinecartRuntimeEntityId()).getEntityId(),\n                    command, outputTracked\n            );\n            session.sendDownstreamPacket(commandMinecartPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.command.CommandManager;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.CommandRequestPacket;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = CommandRequestPacket.class)\npublic class BedrockCommandRequestTranslator extends PacketTranslator<CommandRequestPacket> {\n\n    @Override\n    public void translate(GeyserSession session, CommandRequestPacket packet) {\n        String command = packet.getCommand().replace(\"/\", \"\");\n        CommandManager commandManager = GeyserConnector.getInstance().getCommandManager();\n        if (session.getConnector().getPlatformType() == PlatformType.STANDALONE && command.trim().startsWith(\"geyser \") && commandManager.getCommands().containsKey(command.split(\" \")[1])) {\n            commandManager.runCommand(session, command);\n        } else {\n            String message = packet.getCommand().trim();\n\n            if (MessageTranslator.isTooLong(message, session)) {\n                return;\n            }\n\n            ClientChatPacket chatPacket = new ClientChatPacket(message);\n            session.sendDownstreamPacket(chatPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.nukkitx.protocol.bedrock.packet.ContainerClosePacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ContainerClosePacket.class)\npublic class BedrockContainerCloseTranslator extends PacketTranslator<ContainerClosePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ContainerClosePacket packet) {\n        byte windowId = packet.getId();\n\n        //Client wants close confirmation\n        session.sendUpstreamPacket(packet);\n        session.setClosingInventory(false);\n\n        if (windowId == -1 && session.getOpenInventory() instanceof MerchantContainer) {\n            // 1.16.200 - window ID is always -1 sent from Bedrock\n            windowId = (byte) session.getOpenInventory().getId();\n        }\n\n        Inventory openInventory = session.getOpenInventory();\n        if (openInventory != null) {\n            if (windowId == openInventory.getId()) {\n                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(windowId);\n                session.sendDownstreamPacket(closeWindowPacket);\n                InventoryUtils.closeInventory(session, windowId, false);\n            } else if (openInventory.isPending()) {\n                InventoryUtils.displayInventory(session, openInventory);\n                openInventory.setPending(false);\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.EmoteListPacket;\nimport org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = EmoteListPacket.class)\npublic class BedrockEmoteListTranslator extends PacketTranslator<EmoteListPacket> {\n\n    @Override\n    public void translate(GeyserSession session, EmoteListPacket packet) {\n        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {\n            return;\n        }\n\n        session.refreshEmotes(packet.getPieceIds());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.EntityPickRequestPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n/**\n * Called when the Bedrock user uses the pick block button on an entity\n */\n@Translator(packet = EntityPickRequestPacket.class)\npublic class BedrockEntityPickRequestTranslator extends PacketTranslator<EntityPickRequestPacket> {\n\n    @Override\n    public void translate(GeyserSession session, EntityPickRequestPacket packet) {\n        if (session.getGameMode() != GameMode.CREATIVE) return; // Apparently Java behavior\n        Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n        if (entity == null) return;\n\n        // Get the corresponding item\n        String itemName;\n        switch (entity.getEntityType()) {\n            case BOAT:\n                // Include type of boat in the name\n                int variant = entity.getMetadata().getInt(EntityData.VARIANT);\n                String typeOfBoat;\n                switch (variant) {\n                    case 1:\n                        typeOfBoat = \"spruce\";\n                        break;\n                    case 2:\n                        typeOfBoat = \"birch\";\n                        break;\n                    case 3:\n                        typeOfBoat = \"jungle\";\n                        break;\n                    case 4:\n                        typeOfBoat = \"acacia\";\n                        break;\n                    case 5:\n                        typeOfBoat = \"dark_oak\";\n                        break;\n                    default:\n                        typeOfBoat = \"oak\";\n                        break;\n                }\n                itemName = typeOfBoat + \"_boat\";\n                break;\n            case LEASH_KNOT:\n                itemName = \"lead\";\n                break;\n            case MINECART_CHEST:\n            case MINECART_COMMAND_BLOCK:\n            case MINECART_FURNACE:\n            case MINECART_HOPPER:\n            case MINECART_TNT:\n                // Move MINECART to the end of the name\n                itemName = entity.getEntityType().toString().toLowerCase().replace(\"minecart_\", \"\") + \"_minecart\";\n                break;\n            case MINECART_SPAWNER:\n                // Turns into a normal minecart\n                itemName = \"minecart\";\n                break;\n            case ARMOR_STAND:\n            case END_CRYSTAL:\n            //case ITEM_FRAME: Not an entity in Bedrock Edition\n            //case GLOW_ITEM_FRAME:\n            case MINECART:\n            case PAINTING:\n                // No spawn egg, just an item\n                itemName = entity.getEntityType().toString().toLowerCase();\n                break;\n            default:\n                itemName = entity.getEntityType().toString().toLowerCase() + \"_spawn_egg\";\n                break;\n        }\n\n        String fullItemName = \"minecraft:\" + itemName;\n        ItemMapping mapping = session.getItemMappings().getMapping(fullItemName);\n        // Verify it is, indeed, an item\n        if (mapping == null) return;\n\n        InventoryUtils.findOrCreateItem(session, fullItemName);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientRenameItemPacket;\nimport com.nukkitx.protocol.bedrock.packet.FilterTextPacket;\nimport org.geysermc.connector.inventory.AnvilContainer;\nimport org.geysermc.connector.inventory.CartographyContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Used to send strings to the server and filter out unwanted words.\n * Java doesn't care, so we don't care, and we approve all strings.\n */\n@Translator(packet = FilterTextPacket.class)\npublic class BedrockFilterTextTranslator extends PacketTranslator<FilterTextPacket> {\n\n    @Override\n    public void translate(GeyserSession session, FilterTextPacket packet) {\n        if (session.getOpenInventory() instanceof CartographyContainer) {\n            // We don't want to be able to rename in the cartography table\n            return;\n        }\n        packet.setFromServer(true);\n        session.sendUpstreamPacket(packet);\n\n        if (session.getOpenInventory() instanceof AnvilContainer) {\n            // Java Edition sends a packet every time an item is renamed even slightly in GUI. Fortunately, this works out for us now\n            ClientRenameItemPacket renameItemPacket = new ClientRenameItemPacket(packet.getText());\n            session.sendDownstreamPacket(renameItemPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.*;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.CommandBlockMinecartEntity;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.sound.EntitySoundInteractionHandler;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.registry.type.ItemMappings;\nimport org.geysermc.connector.utils.BlockUtils;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * BedrockInventoryTransactionTranslator handles most interactions between the client and the world,\n * or the client and their inventory.\n */\n@Translator(packet = InventoryTransactionPacket.class)\npublic class BedrockInventoryTransactionTranslator extends PacketTranslator<InventoryTransactionPacket> {\n\n    private static final float MAXIMUM_BLOCK_PLACING_DISTANCE = 64f;\n    private static final int CREATIVE_EYE_HEIGHT_PLACE_DISTANCE = 49;\n    private static final int SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE = 36;\n    private static final float MAXIMUM_BLOCK_DESTROYING_DISTANCE = 36f;\n\n    @Override\n    public void translate(GeyserSession session, InventoryTransactionPacket packet) {\n        // Send book updates before opening inventories\n        session.getBookEditCache().checkForSend();\n\n        ItemMappings mappings = session.getItemMappings();\n\n        switch (packet.getTransactionType()) {\n            case NORMAL:\n                if (packet.getActions().size() == 2) {\n                    InventoryActionData worldAction = packet.getActions().get(0);\n                    InventoryActionData containerAction = packet.getActions().get(1);\n                    if (worldAction.getSource().getType() == InventorySource.Type.WORLD_INTERACTION\n                            && worldAction.getSource().getFlag() == InventorySource.Flag.DROP_ITEM) {\n                        if (session.getPlayerInventory().getHeldItemSlot() != containerAction.getSlot() ||\n                                session.getPlayerInventory().getItemInHand().isEmpty()) {\n                            return;\n                        }\n\n                        boolean dropAll = worldAction.getToItem().getCount() > 1;\n                        ClientPlayerActionPacket dropAllPacket = new ClientPlayerActionPacket(\n                                dropAll ? PlayerAction.DROP_ITEM_STACK : PlayerAction.DROP_ITEM,\n                                BlockUtils.POSITION_ZERO,\n                                BlockFace.DOWN\n                        );\n                        session.sendDownstreamPacket(dropAllPacket);\n\n                        if (dropAll) {\n                            session.getPlayerInventory().setItemInHand(GeyserItemStack.EMPTY);\n                        } else {\n                            session.getPlayerInventory().getItemInHand().sub(1);\n                        }\n                    }\n                }\n                break;\n            case INVENTORY_MISMATCH:\n                break;\n            case ITEM_USE:\n                switch (packet.getActionType()) {\n                    case 0:\n                        // Check to make sure the client isn't spamming interaction\n                        // Based on Nukkit 1.0, with changes to ensure holding down still works\n                        boolean hasAlreadyClicked = System.currentTimeMillis() - session.getLastInteractionTime() < 110.0 &&\n                                packet.getBlockPosition().distanceSquared(session.getLastInteractionBlockPosition()) < 0.00001;\n                        session.setLastInteractionBlockPosition(packet.getBlockPosition());\n                        session.setLastInteractionPlayerPosition(session.getPlayerEntity().getPosition());\n                        if (hasAlreadyClicked) {\n                            break;\n                        } else {\n                            // Only update the interaction time if it's valid - that way holding down still works.\n                            session.setLastInteractionTime(System.currentTimeMillis());\n                        }\n\n                        // Bedrock sends block interact code for a Java entity so we send entity code back to Java\n                        if (session.getBlockMappings().isItemFrame(packet.getBlockRuntimeId())) {\n                            Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                            if (itemFrameEntity != null) {\n                                int entityId = (int) itemFrameEntity.getEntityId();\n                                Vector3f vector = packet.getClickPosition();\n                                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket(entityId,\n                                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                                ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket(entityId,\n                                        InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());\n                                session.sendDownstreamPacket(interactPacket);\n                                session.sendDownstreamPacket(interactAtPacket);\n                                break;\n                            }\n                        }\n\n                        Vector3i blockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getBlockFace());\n                        /*\n                        Checks to ensure that the range will be accepted by the server.\n                        \"Not in range\" doesn't refer to how far a vanilla client goes (that's a whole other mess),\n                        but how much a server will accept from the client maximum\n                         */\n                        // CraftBukkit+ check - see https://github.com/PaperMC/Paper/blob/458db6206daae76327a64f4e2a17b67a7e38b426/Spigot-Server-Patches/0532-Move-range-check-for-block-placing-up.patch\n                        Vector3f playerPosition = session.getPlayerEntity().getPosition();\n\n                        // Adjust position for current eye height\n                        switch (session.getPose()) {\n                            case SNEAKING:\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 1.27f), 0);\n                                break;\n                            case SWIMMING:\n                            case FALL_FLYING: // Elytra\n                            case SPIN_ATTACK: // Trident spin attack\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.4f), 0);\n                                break;\n                            case SLEEPING:\n                                playerPosition = playerPosition.sub(0, (EntityType.PLAYER.getOffset() - 0.2f), 0);\n                                break;\n                        } // else, we don't have to modify the position\n\n                        float diffX = playerPosition.getX() - packet.getBlockPosition().getX();\n                        float diffY = playerPosition.getY() - packet.getBlockPosition().getY();\n                        float diffZ = playerPosition.getZ() - packet.getBlockPosition().getZ();\n                        if (((diffX * diffX) + (diffY * diffY) + (diffZ * diffZ)) >\n                                (session.getGameMode().equals(GameMode.CREATIVE) ? CREATIVE_EYE_HEIGHT_PLACE_DISTANCE : SURVIVAL_EYE_HEIGHT_PLACE_DISTANCE)) {\n                            restoreCorrectBlock(session, blockPos, packet);\n                            return;\n                        }\n\n                        // Vanilla check\n                        if (!(session.getPlayerEntity().getPosition().sub(0, EntityType.PLAYER.getOffset(), 0)\n                                .distanceSquared(packet.getBlockPosition().toFloat().add(0.5f, 0.5f, 0.5f)) < MAXIMUM_BLOCK_PLACING_DISTANCE)) {\n                            // The client thinks that its blocks have been successfully placed. Restore the server's blocks instead.\n                            restoreCorrectBlock(session, blockPos, packet);\n                            return;\n                        }\n                        /*\n                        Block place checks end - client is good to go\n                         */\n\n                        if (packet.getItemInHand() != null && session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {\n                            int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());\n                            if (blockState == BlockStateValues.JAVA_WATER_ID) {\n                                // Otherwise causes multiple mobs to spawn - just send a use item packet\n                                // TODO when we fix mobile bucket rotation, use it for this, too\n                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                session.sendDownstreamPacket(itemPacket);\n                                break;\n                            }\n                        }\n\n                        ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(\n                                new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                                BlockFace.values()[packet.getBlockFace()],\n                                Hand.MAIN_HAND,\n                                packet.getClickPosition().getX(), packet.getClickPosition().getY(), packet.getClickPosition().getZ(),\n                                false);\n                        session.sendDownstreamPacket(blockPacket);\n\n                        if (packet.getItemInHand() != null) {\n                            // Otherwise boats will not be able to be placed in survival and buckets won't work on mobile\n                            if (session.getItemMappings().getBoatIds().contains(packet.getItemInHand().getId())) {\n                                ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                session.sendDownstreamPacket(itemPacket);\n                            } else if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId())) {\n                                // Let the server decide if the bucket item should change, not the client, and revert the changes the client made\n                                InventorySlotPacket slotPacket = new InventorySlotPacket();\n                                slotPacket.setContainerId(ContainerId.INVENTORY);\n                                slotPacket.setSlot(packet.getHotbarSlot());\n                                slotPacket.setItem(packet.getItemInHand());\n                                session.sendUpstreamPacket(slotPacket);\n                                // Don't send ClientPlayerUseItemPacket for powder snow buckets\n                                if (packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().powderSnowBucket().getBedrockId()) {\n                                    // Special check for crafting tables since clients don't send BLOCK_INTERACT when interacting\n                                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition());\n                                    if (session.isSneaking() || blockState != BlockRegistries.JAVA_IDENTIFIERS.get(\"minecraft:crafting_table\")) {\n                                        // Delay the interaction in case the client doesn't intend to actually use the bucket\n                                        // See BedrockActionTranslator.java\n                                        session.setBucketScheduledFuture(session.scheduleInEventLoop(() -> {\n                                            ClientPlayerUseItemPacket itemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                                            session.sendDownstreamPacket(itemPacket);\n                                        }, 5, TimeUnit.MILLISECONDS));\n                                    }\n                                }\n                            }\n                        }\n\n                        if (packet.getActions().isEmpty()) {\n                            if (session.getOpPermissionLevel() >= 2 && session.getGameMode() == GameMode.CREATIVE) {\n                                // Otherwise insufficient permissions\n                                int blockState = session.getBlockMappings().getJavaBlockState(packet.getBlockRuntimeId());\n                                String blockName = BlockRegistries.JAVA_IDENTIFIERS.get().getOrDefault(blockState, \"\");\n                                // In the future this can be used for structure blocks too, however not all elements\n                                // are available in each GUI\n                                if (blockName.contains(\"jigsaw\")) {\n                                    ContainerOpenPacket openPacket = new ContainerOpenPacket();\n                                    openPacket.setBlockPosition(packet.getBlockPosition());\n                                    openPacket.setId((byte) 1);\n                                    openPacket.setType(ContainerType.JIGSAW_EDITOR);\n                                    openPacket.setUniqueEntityId(-1);\n                                    session.sendUpstreamPacket(openPacket);\n                                }\n                            }\n                        }\n\n                        ItemMapping handItem = mappings.getMapping(packet.getItemInHand());\n                        if (handItem.isBlock()) {\n                            session.setLastBlockPlacePosition(blockPos);\n                            session.setLastBlockPlacedId(handItem.getJavaIdentifier());\n                        }\n                        session.setInteracting(true);\n                        break;\n                    case 1:\n                        if (packet.getActions().size() == 1 && packet.getLegacySlots().size() > 0) {\n                            InventoryActionData actionData = packet.getActions().get(0);\n                            LegacySetItemSlotData slotData = packet.getLegacySlots().get(0);\n                            if (slotData.getContainerId() == 6 && actionData.getToItem().getId() != 0) {\n                                // The player is trying to swap out an armor piece that already has an item in it\n                                // Java Edition does not allow this; let's revert it\n                                session.getInventoryTranslator().updateInventory(session, session.getPlayerInventory());\n                            }\n                        }\n\n                        // Handled when sneaking\n                        if (session.getPlayerInventory().getItemInHand().getJavaId() == mappings.getStoredItems().shield().getJavaId()) {\n                            break;\n                        }\n\n                        // Handled in ITEM_USE if the item is not milk\n                        if (packet.getItemInHand() != null) {\n                            if (session.getItemMappings().getBucketIds().contains(packet.getItemInHand().getId()) &&\n                                    packet.getItemInHand().getId() != session.getItemMappings().getStoredItems().milkBucket().getBedrockId()) {\n                                // Handled in case 0 if the item is not milk\n                                break;\n                            } else if (session.getItemMappings().getSpawnEggIds().contains(packet.getItemInHand().getId())) {\n                                // Handled in case 0\n                                break;\n                            }\n                        }\n\n                        ClientPlayerUseItemPacket useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                        session.sendDownstreamPacket(useItemPacket);\n                        break;\n                    case 2:\n                        int blockState = session.getGameMode() == GameMode.CREATIVE ?\n                                session.getConnector().getWorldManager().getBlockAt(session, packet.getBlockPosition()) : session.getBreakingBlock();\n\n                        session.setLastBlockPlacedId(null);\n                        session.setLastBlockPlacePosition(null);\n\n                        // Same deal with vanilla block placing as above.\n                        // This is working out the distance using 3d Pythagoras and the extra value added to the Y is the sneaking height of a java player.\n                        playerPosition = session.getPlayerEntity().getPosition();\n                        Vector3f floatBlockPosition = packet.getBlockPosition().toFloat();\n                        diffX = playerPosition.getX() - (floatBlockPosition.getX() + 0.5f);\n                        diffY = (playerPosition.getY() - EntityType.PLAYER.getOffset()) - (floatBlockPosition.getY() + 0.5f) + 1.5f;\n                        diffZ = playerPosition.getZ() - (floatBlockPosition.getZ() + 0.5f);\n                        float distanceSquared = diffX * diffX + diffY * diffY + diffZ * diffZ;\n                        if (distanceSquared > MAXIMUM_BLOCK_DESTROYING_DISTANCE) {\n                            restoreCorrectBlock(session, packet.getBlockPosition(), packet);\n                            return;\n                        }\n\n                        LevelEventPacket blockBreakPacket = new LevelEventPacket();\n                        blockBreakPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);\n                        blockBreakPacket.setPosition(packet.getBlockPosition().toFloat());\n                        blockBreakPacket.setData(session.getBlockMappings().getBedrockBlockId(blockState));\n                        session.sendUpstreamPacket(blockBreakPacket);\n                        session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n\n                        Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                        if (itemFrameEntity != null) {\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                            break;\n                        }\n\n                        PlayerAction action = session.getGameMode() == GameMode.CREATIVE ? PlayerAction.START_DIGGING : PlayerAction.FINISH_DIGGING;\n                        Position pos = new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ());\n                        ClientPlayerActionPacket breakPacket = new ClientPlayerActionPacket(action, pos, BlockFace.values()[packet.getBlockFace()]);\n                        session.sendDownstreamPacket(breakPacket);\n                        break;\n                }\n                break;\n            case ITEM_RELEASE:\n                if (packet.getActionType() == 0) {\n                    // Followed to the Minecraft Protocol specification outlined at wiki.vg\n                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO,\n                            BlockFace.DOWN);\n                    session.sendDownstreamPacket(releaseItemPacket);\n                }\n                break;\n            case ITEM_USE_ON_ENTITY:\n                Entity entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n                if (entity == null)\n                    return;\n\n                //https://wiki.vg/Protocol#Interact_Entity\n                switch (packet.getActionType()) {\n                    case 0: //Interact\n                        if (entity instanceof CommandBlockMinecartEntity) {\n                            // The UI is handled client-side on Java Edition\n                            // Ensure OP permission level and gamemode is appropriate\n                            if (session.getOpPermissionLevel() < 2 || session.getGameMode() != GameMode.CREATIVE) return;\n                            ContainerOpenPacket openPacket = new ContainerOpenPacket();\n                            openPacket.setBlockPosition(Vector3i.ZERO);\n                            openPacket.setId((byte) 1);\n                            openPacket.setType(ContainerType.COMMAND_BLOCK);\n                            openPacket.setUniqueEntityId(entity.getGeyserId());\n                            session.sendUpstreamPacket(openPacket);\n                            break;\n                        }\n                        Vector3f vector = packet.getClickPosition().sub(entity.getPosition());\n                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                        ClientPlayerInteractEntityPacket interactAtPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                InteractAction.INTERACT_AT, vector.getX(), vector.getY(), vector.getZ(), Hand.MAIN_HAND, session.isSneaking());\n                        session.sendDownstreamPacket(interactPacket);\n                        session.sendDownstreamPacket(interactAtPacket);\n\n                        EntitySoundInteractionHandler.handleEntityInteraction(session, packet.getClickPosition(), entity);\n                        break;\n                    case 1: //Attack\n                        if (entity.getEntityType() == EntityType.ENDER_DRAGON) {\n                            // Redirects the attack to its body entity, this only happens when\n                            // attacking the underbelly of the ender dragon\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId() + 3,\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                        } else {\n                            ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                                    InteractAction.ATTACK, session.isSneaking());\n                            session.sendDownstreamPacket(attackPacket);\n                        }\n                        break;\n                }\n                break;\n        }\n    }\n\n    /**\n     * Restore the correct block state from the server without updating the chunk cache.\n     *\n     * @param session the session of the Bedrock client\n     * @param blockPos the block position to restore\n     */\n    private void restoreCorrectBlock(GeyserSession session, Vector3i blockPos, InventoryTransactionPacket packet) {\n        int javaBlockState = session.getConnector().getWorldManager().getBlockAt(session, blockPos);\n        UpdateBlockPacket updateBlockPacket = new UpdateBlockPacket();\n        updateBlockPacket.setDataLayer(0);\n        updateBlockPacket.setBlockPosition(blockPos);\n        updateBlockPacket.setRuntimeId(session.getBlockMappings().getBedrockBlockId(javaBlockState));\n        updateBlockPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);\n        session.sendUpstreamPacket(updateBlockPacket);\n\n        UpdateBlockPacket updateWaterPacket = new UpdateBlockPacket();\n        updateWaterPacket.setDataLayer(1);\n        updateWaterPacket.setBlockPosition(blockPos);\n        updateWaterPacket.setRuntimeId(BlockRegistries.WATERLOGGED.get().contains(javaBlockState) ? session.getBlockMappings().getBedrockWaterId() : session.getBlockMappings().getBedrockAirId());\n        updateWaterPacket.getFlags().addAll(UpdateBlockPacket.FLAG_ALL_PRIORITY);\n        session.sendUpstreamPacket(updateWaterPacket);\n\n        // Reset the item in hand to prevent \"missing\" blocks\n        InventorySlotPacket slotPacket = new InventorySlotPacket();\n        slotPacket.setContainerId(ContainerId.INVENTORY);\n        slotPacket.setSlot(packet.getHotbarSlot());\n        slotPacket.setItem(packet.getItemInHand());\n        session.sendUpstreamPacket(slotPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.nukkitx.protocol.bedrock.packet.ItemFrameDropItemPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Pre-1.16.210: used for both survival and creative item frame item removal\n *\n * 1.16.210: only used in creative.\n */\n@Translator(packet = ItemFrameDropItemPacket.class)\npublic class BedrockItemFrameDropItemTranslator extends PacketTranslator<ItemFrameDropItemPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ItemFrameDropItemPacket packet) {\n        Entity entity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n        if (entity != null) {\n            ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                    InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n            session.sendDownstreamPacket(interactPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ItemStackRequestPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\n\n/**\n * The packet sent for server-authoritative-style inventory transactions.\n */\n@Translator(packet = ItemStackRequestPacket.class)\npublic class BedrockItemStackRequestTranslator extends PacketTranslator<ItemStackRequestPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ItemStackRequestPacket packet) {\n        Inventory inventory = session.getOpenInventory();\n        if (inventory == null)\n            return;\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        translator.translateRequests(session, inventory, packet.getRequests());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPlaceBlockPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientClickWindowButtonPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.nukkitx.protocol.bedrock.packet.LecternUpdatePacket;\nimport org.geysermc.connector.inventory.LecternContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n/**\n * Used to translate moving pages, or closing the inventory\n */\n@Translator(packet = LecternUpdatePacket.class)\npublic class BedrockLecternUpdateTranslator extends PacketTranslator<LecternUpdatePacket> {\n\n    @Override\n    public void translate(GeyserSession session, LecternUpdatePacket packet) {\n        if (packet.isDroppingBook()) {\n            // Bedrock drops the book outside of the GUI. Java drops it in the GUI\n            // So, we enter the GUI and then drop it! :)\n            session.setDroppingLecternBook(true);\n\n            // Emulate an interact packet\n            ClientPlayerPlaceBlockPacket blockPacket = new ClientPlayerPlaceBlockPacket(\n                    new Position(packet.getBlockPosition().getX(), packet.getBlockPosition().getY(), packet.getBlockPosition().getZ()),\n                    BlockFace.DOWN,\n                    Hand.MAIN_HAND,\n                    0, 0, 0, // Java doesn't care about these when dealing with a lectern\n                    false);\n            session.sendDownstreamPacket(blockPacket);\n        } else {\n            // Bedrock wants to either move a page or exit\n            if (!(session.getOpenInventory() instanceof LecternContainer)) {\n                session.getConnector().getLogger().debug(\"Expected lectern but it wasn't open!\");\n                return;\n            }\n\n            LecternContainer lecternContainer = (LecternContainer) session.getOpenInventory();\n            if (lecternContainer.getCurrentBedrockPage() == packet.getPage()) {\n                // The same page means Bedrock is closing the window\n                ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(lecternContainer.getId());\n                session.sendDownstreamPacket(closeWindowPacket);\n                InventoryUtils.closeInventory(session, lecternContainer.getId(), false);\n            } else {\n                // Each \"page\" Bedrock gives to us actually represents two pages (think opening a book and seeing two pages)\n                // Each \"page\" on Java is just one page (think a spiral notebook folded back to only show one page)\n                int newJavaPage = (packet.getPage() * 2);\n                int currentJavaPage = (lecternContainer.getCurrentBedrockPage() * 2);\n\n                // Send as many click button packets as we need to\n                // Java has the option to specify exact page numbers by adding 100 to the number, but buttonId variable\n                // is a byte when transmitted over the network and therefore this stops us at 128\n                if (newJavaPage > currentJavaPage) {\n                    for (int i = currentJavaPage; i < newJavaPage; i++) {\n                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 2);\n                        session.sendDownstreamPacket(clickButtonPacket);\n                    }\n                } else {\n                    for (int i = currentJavaPage; i > newJavaPage; i--) {\n                        ClientClickWindowButtonPacket clickButtonPacket = new ClientClickWindowButtonPacket(session.getOpenInventory().getId(), 1);\n                        session.sendDownstreamPacket(clickButtonPacket);\n                    }\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.MapInfoRequestPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = MapInfoRequestPacket.class)\npublic class BedrockMapInfoRequestTranslator extends PacketTranslator<MapInfoRequestPacket> {\n\n    @Override\n    public void translate(GeyserSession session, MapInfoRequestPacket packet) {\n        long mapId = packet.getUniqueMapId();\n\n        ClientboundMapItemDataPacket mapPacket = session.getStoredMaps().remove(mapId);\n        if (mapPacket != null) {\n            // Delay the packet 100ms to prevent the client from ignoring the packet\n            GeyserConnector.getInstance().getGeneralThreadPool().schedule(() -> session.sendUpstreamPacket(mapPacket),\n                    100, TimeUnit.MILLISECONDS);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerChangeHeldItemPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerUseItemPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerId;\nimport com.nukkitx.protocol.bedrock.packet.MobEquipmentPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.CooldownUtils;\nimport org.geysermc.connector.utils.InteractiveTagManager;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = MobEquipmentPacket.class)\npublic class BedrockMobEquipmentTranslator extends PacketTranslator<MobEquipmentPacket> {\n\n    @Override\n    public void translate(GeyserSession session, MobEquipmentPacket packet) {\n        if (!session.isSpawned() || packet.getHotbarSlot() > 8 ||\n                packet.getContainerId() != ContainerId.INVENTORY || session.getPlayerInventory().getHeldItemSlot() == packet.getHotbarSlot()) {\n            // For the last condition - Don't update the slot if the slot is the same - not Java Edition behavior and messes with plugins such as Grief Prevention\n            return;\n        }\n\n        // Send book update before switching hotbar slot\n        session.getBookEditCache().checkForSend();\n\n        session.getPlayerInventory().setHeldItemSlot(packet.getHotbarSlot());\n\n        ClientPlayerChangeHeldItemPacket changeHeldItemPacket = new ClientPlayerChangeHeldItemPacket(packet.getHotbarSlot());\n        session.sendDownstreamPacket(changeHeldItemPacket);\n\n        if (session.isSneaking() && session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {\n            // Activate shield since we are already sneaking\n            // (No need to send a release item packet - Java doesn't do this when swapping items)\n            // Required to do it a tick later or else it doesn't register\n            session.getConnector().getGeneralThreadPool().schedule(() -> session.sendDownstreamPacket(new ClientPlayerUseItemPacket(Hand.MAIN_HAND)),\n                    50, TimeUnit.MILLISECONDS);\n        }\n\n        // Java sends a cooldown indicator whenever you switch an item\n        CooldownUtils.sendCooldown(session);\n\n        // Update the interactive tag, if an entity is present\n        if (session.getMouseoverEntity() != null) {\n            InteractiveTagManager.updateTag(session, session.getMouseoverEntity());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;\nimport com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;\nimport org.geysermc.connector.entity.BoatEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Sent by the client when moving a horse.\n */\n@Translator(packet = MoveEntityAbsolutePacket.class)\npublic class BedrockMoveEntityAbsoluteTranslator extends PacketTranslator<MoveEntityAbsolutePacket> {\n\n    @Override\n    public void translate(GeyserSession session, MoveEntityAbsolutePacket packet) {\n        session.setLastVehicleMoveTimestamp(System.currentTimeMillis());\n\n        float y = packet.getPosition().getY();\n        if (session.getRidingVehicleEntity() instanceof BoatEntity) {\n            // Remove the offset to prevents boats from looking like they're floating in water\n            y -= EntityType.BOAT.getOffset();\n        }\n        ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(\n                packet.getPosition().getX(), y, packet.getPosition().getZ(),\n                packet.getRotation().getY() - 90, packet.getRotation().getX()\n        );\n        session.sendDownstreamPacket(clientVehicleMovePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientKeepAlivePacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.floodgate.util.DeviceOs;\n\nimport java.util.Collections;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Used to send the forwarded keep alive packet back to the server\n */\n@Translator(packet = NetworkStackLatencyPacket.class)\npublic class BedrockNetworkStackLatencyTranslator extends PacketTranslator<NetworkStackLatencyPacket> {\n\n    @Override\n    public void translate(GeyserSession session, NetworkStackLatencyPacket packet) {\n        long pingId;\n        // so apparently, as of 1.16.200\n        // PS4 divides the network stack latency timestamp FOR US!!!\n        // WTF\n        if (session.getClientData().getDeviceOs().equals(DeviceOs.PS4)) {\n            pingId = packet.getTimestamp();\n        } else {\n            pingId = packet.getTimestamp() / 1000;\n        }\n\n        // negative timestamps are used as hack to fix the url image loading bug\n        if (packet.getTimestamp() > 0) {\n            if (session.getConnector().getConfig().isForwardPlayerPing()) {\n                ClientKeepAlivePacket keepAlivePacket = new ClientKeepAlivePacket(pingId);\n                session.sendDownstreamPacket(keepAlivePacket);\n            }\n            return;\n        }\n\n        // Hack to fix the url image loading bug\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n\n        AttributeData attribute = session.getPlayerEntity().getAttributes().get(GeyserAttributeType.EXPERIENCE_LEVEL);\n        if (attribute != null) {\n            attributesPacket.setAttributes(Collections.singletonList(attribute));\n        } else {\n            attributesPacket.setAttributes(Collections.singletonList(GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(0)));\n        }\n\n        session.getConnector().getGeneralThreadPool().schedule(\n                () -> session.sendUpstreamPacket(attributesPacket),\n                500, TimeUnit.MILLISECONDS);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.PacketViolationWarningPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = PacketViolationWarningPacket.class)\npublic class BedrockPacketViolationWarningTranslator extends PacketTranslator<PacketViolationWarningPacket> {\n\n    @Override\n    public void translate(GeyserSession session, PacketViolationWarningPacket packet) {\n        // Not translated since this is something that the developers need to know\n        session.getConnector().getLogger().error(\"Packet violation warning sent from client! \" + packet.toString());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientSteerVehiclePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientVehicleMovePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.PlayerInputPacket;\nimport org.geysermc.connector.entity.BoatEntity;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.entity.living.animal.horse.LlamaEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Sent by the client for minecarts and boats.\n */\n@Translator(packet = PlayerInputPacket.class)\npublic class BedrockPlayerInputTranslator extends PacketTranslator<PlayerInputPacket> {\n\n    @Override\n    public void translate(GeyserSession session, PlayerInputPacket packet) {\n        ClientSteerVehiclePacket clientSteerVehiclePacket = new ClientSteerVehiclePacket(\n                packet.getInputMotion().getX(), packet.getInputMotion().getY(), packet.isJumping(), packet.isSneaking()\n        );\n\n        session.sendDownstreamPacket(clientSteerVehiclePacket);\n\n        // Bedrock only sends movement vehicle packets while moving\n        // This allows horses to take damage while standing on magma\n        Entity vehicle = session.getRidingVehicleEntity();\n        boolean sendMovement = false;\n        if (vehicle instanceof AbstractHorseEntity && !(vehicle instanceof LlamaEntity)) {\n            sendMovement = vehicle.isOnGround();\n        } else if (vehicle instanceof BoatEntity) {\n            if (vehicle.getPassengers().size() == 1) {\n                // The player is the only rider\n                sendMovement = true;\n            } else {\n                // Check if the player is the front rider\n                Vector3f seatPos = session.getPlayerEntity().getMetadata().getVector3f(EntityData.RIDER_SEAT_POSITION, null);\n                if (seatPos != null && seatPos.getX() > 0) {\n                    sendMovement = true;\n                }\n            }\n        }\n        if (sendMovement) {\n            long timeSinceVehicleMove = System.currentTimeMillis() - session.getLastVehicleMoveTimestamp();\n            if (timeSinceVehicleMove >= 100) {\n                Vector3f vehiclePosition = vehicle.getPosition();\n                Vector3f vehicleRotation = vehicle.getRotation();\n\n                if (vehicle instanceof BoatEntity) {\n                    // Remove some Y position to prevents boats flying up\n                    vehiclePosition = vehiclePosition.down(EntityType.BOAT.getOffset());\n                }\n\n                ClientVehicleMovePacket clientVehicleMovePacket = new ClientVehicleMovePacket(\n                        vehiclePosition.getX(), vehiclePosition.getY(), vehiclePosition.getZ(),\n                        vehicleRotation.getX() - 90, vehicleRotation.getY()\n                );\n                session.sendDownstreamPacket(clientVehicleMovePacket);\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.packet.PositionTrackingDBClientRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.PositionTrackingDBServerBroadcastPacket;\nimport it.unimi.dsi.fastutil.ints.IntArrayList;\nimport it.unimi.dsi.fastutil.ints.IntList;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.LoadstoneTracker;\n\n@Translator(packet = PositionTrackingDBClientRequestPacket.class)\npublic class BedrockPositionTrackingDBClientRequestTranslator extends PacketTranslator<PositionTrackingDBClientRequestPacket> {\n\n    @Override\n    public void translate(GeyserSession session, PositionTrackingDBClientRequestPacket packet) {\n        PositionTrackingDBServerBroadcastPacket broadcastPacket = new PositionTrackingDBServerBroadcastPacket();\n        broadcastPacket.setTrackingId(packet.getTrackingId());\n\n        // Fetch the stored Loadstone\n        LoadstoneTracker.LoadstonePos pos = LoadstoneTracker.getPos(packet.getTrackingId());\n\n        // If we don't have data for that ID tell the client its not found\n        if (pos == null) {\n            broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.NOT_FOUND);\n            session.sendUpstreamPacket(broadcastPacket);\n            return;\n        }\n\n        broadcastPacket.setAction(PositionTrackingDBServerBroadcastPacket.Action.UPDATE);\n\n        // Build the nbt data for the update\n        NbtMapBuilder builder = NbtMap.builder();\n        builder.putInt(\"dim\", DimensionUtils.javaToBedrock(pos.getDimension()));\n        builder.putString(\"id\", String.format(\"%08X\", packet.getTrackingId()));\n\n        builder.putByte(\"version\", (byte) 1); // Not sure what this is for\n        builder.putByte(\"status\", (byte) 0); // Not sure what this is for\n\n        // Build the position for the update\n        IntList posList = new IntArrayList();\n        posList.add(pos.getX());\n        posList.add(pos.getY());\n        posList.add(pos.getZ());\n        builder.putList(\"pos\", NbtType.INT, posList);\n        broadcastPacket.setTag(builder.build());\n\n        session.sendUpstreamPacket(broadcastPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport com.nukkitx.protocol.bedrock.packet.RespawnPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = RespawnPacket.class)\npublic class BedrockRespawnTranslator extends PacketTranslator<RespawnPacket> {\n\n    @Override\n    public void translate(GeyserSession session, RespawnPacket packet) {\n        if (packet.getState() == RespawnPacket.State.CLIENT_READY) {\n            // Previously we only sent the respawn packet before the server finished loading\n            // The message included was 'Otherwise when immediate respawn is on the client never loads'\n            // But I assume the new if statement below fixes that problem\n            RespawnPacket respawnPacket = new RespawnPacket();\n            respawnPacket.setRuntimeEntityId(0);\n            respawnPacket.setPosition(Vector3f.ZERO);\n            respawnPacket.setState(RespawnPacket.State.SERVER_READY);\n            session.sendUpstreamPacket(respawnPacket);\n\n            if (session.isSpawned()) {\n                // Client might be stuck; resend spawn information\n                PlayerEntity entity = session.getPlayerEntity();\n                if (entity == null) return;\n                SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n                entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n                entityDataPacket.getMetadata().putAll(entity.getMetadata());\n                session.sendUpstreamPacket(entityDataPacket);\n\n                MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                movePlayerPacket.setPosition(entity.getPosition());\n                movePlayerPacket.setRotation(entity.getBedrockRotation());\n                movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);\n                session.sendUpstreamPacket(movePlayerPacket);\n            }\n\n            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n            session.sendDownstreamPacket(javaRespawnPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.packet.ServerSettingsRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.ServerSettingsResponsePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.SettingsUtils;\nimport org.geysermc.cumulus.CustomForm;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerSettingsRequestPacket.class)\npublic class BedrockServerSettingsRequestTranslator extends PacketTranslator<ServerSettingsRequestPacket> {\n    @Override\n    public void translate(GeyserSession session, ServerSettingsRequestPacket packet) {\n        CustomForm window = SettingsUtils.buildForm(session);\n        int windowId = session.getFormCache().addForm(window);\n\n        // Fixes https://bugs.mojang.com/browse/MCPE-94012 because of the delay\n        session.getConnector().getGeneralThreadPool().schedule(() -> {\n            ServerSettingsResponsePacket serverSettingsResponsePacket = new ServerSettingsResponsePacket();\n            serverSettingsResponsePacket.setFormData(window.getJsonData());\n            serverSettingsResponsePacket.setFormId(windowId);\n            session.sendUpstreamPacket(serverSettingsResponsePacket);\n        }, 1, TimeUnit.SECONDS);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.SetLocalPlayerAsInitializedPacket;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\nimport org.geysermc.connector.skin.SkullSkinManager;\n\n@Translator(packet = SetLocalPlayerAsInitializedPacket.class)\npublic class BedrockSetLocalPlayerAsInitializedTranslator extends PacketTranslator<SetLocalPlayerAsInitializedPacket> {\n    @Override\n    public void translate(GeyserSession session, SetLocalPlayerAsInitializedPacket packet) {\n        if (session.getPlayerEntity().getGeyserId() == packet.getRuntimeEntityId()) {\n            if (!session.getUpstream().isInitialized()) {\n                session.getUpstream().setInitialized(true);\n                session.login();\n\n                for (PlayerEntity entity : session.getEntityCache().getEntitiesByType(PlayerEntity.class)) {\n                    if (!entity.isValid()) {\n                        SkinManager.requestAndHandleSkinAndCape(entity, session, null);\n                        entity.sendPlayer(session);\n                    }\n                }\n\n                // Send Skulls\n                for (PlayerEntity entity : session.getSkullCache().values()) {\n                    entity.spawnEntity(session);\n\n                    SkullSkinManager.requestAndHandleSkin(entity, session, (skin) ->  {\n                        entity.getMetadata().getFlags().setFlag(EntityFlag.INVISIBLE, false);\n                        entity.updateBedrockMetadata(session);\n                    });\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.nukkitx.protocol.bedrock.packet.ShowCreditsPacket;\n\n@Translator(packet = ShowCreditsPacket.class)\npublic class BedrockShowCreditsTranslator extends PacketTranslator<ShowCreditsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ShowCreditsPacket packet) {\n        if (packet.getStatus() == ShowCreditsPacket.Status.END_CREDITS) {\n            ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n            session.sendDownstreamPacket(javaRespawnPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = TextPacket.class)\npublic class BedrockTextTranslator extends PacketTranslator<TextPacket> {\n\n    @Override\n    public void translate(GeyserSession session, TextPacket packet) {\n        String message = packet.getMessage();\n\n        if (MessageTranslator.isTooLong(message, session)) {\n            return;\n        }\n\n        ClientChatPacket chatPacket = new ClientChatPacket(message);\n        session.sendDownstreamPacket(chatPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity;\n\nimport com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientSelectTradePacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.packet.EntityEventPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = EntityEventPacket.class)\npublic class BedrockEntityEventTranslator extends PacketTranslator<EntityEventPacket> {\n\n    @Override\n    public void translate(GeyserSession session, EntityEventPacket packet) {\n        switch (packet.getType()) {\n            case EATING_ITEM:\n                // Resend the packet so we get the eating sounds\n                session.sendUpstreamPacket(packet);\n                return;\n            case COMPLETE_TRADE:\n                ClientSelectTradePacket selectTradePacket = new ClientSelectTradePacket(packet.getData());\n                session.sendDownstreamPacket(selectTradePacket);\n\n                session.scheduleInEventLoop(() -> {\n                    Entity villager = session.getPlayerEntity();\n                    Inventory openInventory = session.getOpenInventory();\n                    if (openInventory instanceof MerchantContainer) {\n                        MerchantContainer merchantInventory = (MerchantContainer) openInventory;\n                        VillagerTrade[] trades = merchantInventory.getVillagerTrades();\n                        if (trades != null && packet.getData() >= 0 && packet.getData() < trades.length) {\n                            VillagerTrade trade = merchantInventory.getVillagerTrades()[packet.getData()];\n                            openInventory.setItem(2, GeyserItemStack.from(trade.getOutput()), session);\n                            villager.getMetadata().put(EntityData.TRADE_XP, trade.getXp() + villager.getMetadata().getInt(EntityData.TRADE_XP));\n                            villager.updateBedrockMetadata(session);\n                        }\n                    }\n                }, 100, TimeUnit.MILLISECONDS);\n                return;\n        }\n        session.getConnector().getLogger().debug(\"Did not translate incoming EntityEventPacket: \" + packet.toString());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.*;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.*;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.PlayerActionType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemFrameEntity;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.inventory.PlayerInventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.BlockUtils;\n\nimport java.util.ArrayList;\n\n@Translator(packet = PlayerActionPacket.class)\npublic class BedrockActionTranslator extends PacketTranslator<PlayerActionPacket> {\n\n    @Override\n    public void translate(GeyserSession session, PlayerActionPacket packet) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        // Send book update before any player action\n        if (packet.getAction() != PlayerActionType.RESPAWN) {\n            session.getBookEditCache().checkForSend();\n        }\n\n        Vector3i vector = packet.getBlockPosition();\n        Position position = new Position(vector.getX(), vector.getY(), vector.getZ());\n\n        switch (packet.getAction()) {\n            case RESPAWN:\n                // Respawn process is finished and the server and client are both OK with respawning.\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setRuntimeEntityId(entity.getGeyserId());\n                eventPacket.setType(EntityEventType.RESPAWN);\n                eventPacket.setData(0);\n                session.sendUpstreamPacket(eventPacket);\n                // Resend attributes or else in rare cases the user can think they're not dead when they are, upon joining the server\n                UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n                attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));\n                session.sendUpstreamPacket(attributesPacket);\n                break;\n            case START_SWIMMING:\n                ClientPlayerStatePacket startSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);\n                session.sendDownstreamPacket(startSwimPacket);\n\n                session.setSwimming(true);\n                break;\n            case STOP_SWIMMING:\n                ClientPlayerStatePacket stopSwimPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);\n                session.sendDownstreamPacket(stopSwimPacket);\n\n                session.setSwimming(false);\n                break;\n            case START_GLIDE:\n                // Otherwise gliding will not work in creative\n                ClientPlayerAbilitiesPacket playerAbilitiesPacket = new ClientPlayerAbilitiesPacket(false);\n                session.sendDownstreamPacket(playerAbilitiesPacket);\n            case STOP_GLIDE:\n                ClientPlayerStatePacket glidePacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_ELYTRA_FLYING);\n                session.sendDownstreamPacket(glidePacket);\n                break;\n            case START_SNEAK:\n                ClientPlayerStatePacket startSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);\n                session.sendDownstreamPacket(startSneakPacket);\n\n                // Toggle the shield, if relevant\n                PlayerInventory playerInv = session.getPlayerInventory();\n                ItemMapping shield = session.getItemMappings().getMapping(\"minecraft:shield\");\n                if ((playerInv.getItemInHand().getJavaId() == shield.getJavaId()) ||\n                        (playerInv.getOffhand().getJavaId() == shield.getJavaId())) {\n                    ClientPlayerUseItemPacket useItemPacket;\n                    if (playerInv.getItemInHand().getJavaId() == shield.getJavaId()) {\n                        useItemPacket = new ClientPlayerUseItemPacket(Hand.MAIN_HAND);\n                    } else {\n                        // Else we just assume it's the offhand, to simplify logic and to assure the packet gets sent\n                        useItemPacket = new ClientPlayerUseItemPacket(Hand.OFF_HAND);\n                    }\n                    session.sendDownstreamPacket(useItemPacket);\n                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, true);\n                    // metadata will be updated when sneaking\n                }\n\n                session.setSneaking(true);\n                break;\n            case STOP_SNEAK:\n                ClientPlayerStatePacket stopSneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SNEAKING);\n                session.sendDownstreamPacket(stopSneakPacket);\n\n                // Stop shield, if necessary\n                if (session.getPlayerEntity().getMetadata().getFlags().getFlag(EntityFlag.BLOCKING)) {\n                    ClientPlayerActionPacket releaseItemPacket = new ClientPlayerActionPacket(PlayerAction.RELEASE_USE_ITEM, BlockUtils.POSITION_ZERO, BlockFace.DOWN);\n                    session.sendDownstreamPacket(releaseItemPacket);\n                    session.getPlayerEntity().getMetadata().getFlags().setFlag(EntityFlag.BLOCKING, false);\n                    // metadata will be updated when sneaking\n                }\n\n                session.setSneaking(false);\n                break;\n            case START_SPRINT:\n                ClientPlayerStatePacket startSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SPRINTING);\n                session.sendDownstreamPacket(startSprintPacket);\n                session.setSprinting(true);\n                break;\n            case STOP_SPRINT:\n                ClientPlayerStatePacket stopSprintPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.STOP_SPRINTING);\n                session.sendDownstreamPacket(stopSprintPacket);\n                session.setSprinting(false);\n                break;\n            case DROP_ITEM:\n                ClientPlayerActionPacket dropItemPacket = new ClientPlayerActionPacket(PlayerAction.DROP_ITEM, position, BlockFace.values()[packet.getFace()]);\n                session.sendDownstreamPacket(dropItemPacket);\n                break;\n            case STOP_SLEEP:\n                ClientPlayerStatePacket stopSleepingPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.LEAVE_BED);\n                session.sendDownstreamPacket(stopSleepingPacket);\n                break;\n            case BLOCK_INTERACT:\n                // Client means to interact with a block; cancel bucket interaction, if any\n                if (session.getBucketScheduledFuture() != null) {\n                    session.getBucketScheduledFuture().cancel(true);\n                    session.setBucketScheduledFuture(null);\n                }\n                // Otherwise handled in BedrockInventoryTransactionTranslator\n                break;\n            case START_BREAK:\n                // Start the block breaking animation\n                if (session.getGameMode() != GameMode.CREATIVE) {\n                    int blockState = session.getConnector().getWorldManager().getBlockAt(session, vector);\n                    LevelEventPacket startBreak = new LevelEventPacket();\n                    startBreak.setType(LevelEventType.BLOCK_START_BREAK);\n                    startBreak.setPosition(vector.toFloat());\n                    double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(blockState)) * 20;\n                    startBreak.setData((int) (65535 / breakTime));\n                    session.setBreakingBlock(blockState);\n                    session.sendUpstreamPacket(startBreak);\n                }\n\n                // Account for fire - the client likes to hit the block behind.\n                Vector3i fireBlockPos = BlockUtils.getBlockPosition(packet.getBlockPosition(), packet.getFace());\n                int blockUp = session.getConnector().getWorldManager().getBlockAt(session, fireBlockPos);\n                String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(blockUp);\n                if (identifier.startsWith(\"minecraft:fire\") || identifier.startsWith(\"minecraft:soul_fire\")) {\n                    ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, new Position(fireBlockPos.getX(),\n                            fireBlockPos.getY(), fireBlockPos.getZ()), BlockFace.values()[packet.getFace()]);\n                    session.sendDownstreamPacket(startBreakingPacket);\n                    if (session.getGameMode() == GameMode.CREATIVE) {\n                        break;\n                    }\n                }\n\n                ClientPlayerActionPacket startBreakingPacket = new ClientPlayerActionPacket(PlayerAction.START_DIGGING, position, BlockFace.values()[packet.getFace()]);\n                session.sendDownstreamPacket(startBreakingPacket);\n                break;\n            case CONTINUE_BREAK:\n                if (session.getGameMode() == GameMode.CREATIVE) {\n                    break;\n                }\n                Vector3f vectorFloat = vector.toFloat();\n                LevelEventPacket continueBreakPacket = new LevelEventPacket();\n                continueBreakPacket.setType(LevelEventType.PARTICLE_CRACK_BLOCK);\n                continueBreakPacket.setData((session.getBlockMappings().getBedrockBlockId(session.getBreakingBlock())) | (packet.getFace() << 24));\n                continueBreakPacket.setPosition(vectorFloat);\n                session.sendUpstreamPacket(continueBreakPacket);\n\n                // Update the break time in the event that player conditions changed (jumping, effects applied)\n                LevelEventPacket updateBreak = new LevelEventPacket();\n                updateBreak.setType(LevelEventType.BLOCK_UPDATE_BREAK);\n                updateBreak.setPosition(vectorFloat);\n                double breakTime = BlockUtils.getSessionBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(session.getBreakingBlock())) * 20;\n                updateBreak.setData((int) (65535 / breakTime));\n                session.sendUpstreamPacket(updateBreak);\n                break;\n            case ABORT_BREAK:\n                if (session.getGameMode() != GameMode.CREATIVE) {\n                    // As of 1.16.210: item frame items are taken out here.\n                    // Survival also sends START_BREAK, but by attaching our process here adventure mode also works\n                    Entity itemFrameEntity = ItemFrameEntity.getItemFrameEntity(session, packet.getBlockPosition());\n                    if (itemFrameEntity != null) {\n                        ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) itemFrameEntity.getEntityId(),\n                                InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n                        session.sendDownstreamPacket(interactPacket);\n                        break;\n                    }\n                }\n\n                ClientPlayerActionPacket abortBreakingPacket = new ClientPlayerActionPacket(PlayerAction.CANCEL_DIGGING, position, BlockFace.DOWN);\n                session.sendDownstreamPacket(abortBreakingPacket);\n                LevelEventPacket stopBreak = new LevelEventPacket();\n                stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);\n                stopBreak.setPosition(vector.toFloat());\n                stopBreak.setData(0);\n                session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n                session.sendUpstreamPacket(stopBreak);\n                break;\n            case STOP_BREAK:\n                // Handled in BedrockInventoryTransactionTranslator\n                break;\n            case DIMENSION_CHANGE_SUCCESS:\n                //sometimes the client doesn't feel like loading\n                PlayStatusPacket spawnPacket = new PlayStatusPacket();\n                spawnPacket.setStatus(PlayStatusPacket.Status.PLAYER_SPAWN);\n                session.sendUpstreamPacket(spawnPacket);\n\n                attributesPacket = new UpdateAttributesPacket();\n                attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n                attributesPacket.setAttributes(new ArrayList<>(entity.getAttributes().values()));\n                session.sendUpstreamPacket(attributesPacket);\n\n                session.getEntityCache().updateBossBars();\n                break;\n            case JUMP:\n                entity.setOnGround(false); // Increase block break time while jumping\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockFace;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerActionPacket;\nimport com.nukkitx.protocol.bedrock.packet.EmotePacket;\nimport org.geysermc.connector.configuration.EmoteOffhandWorkaroundOption;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.BlockUtils;\n\n@Translator(packet = EmotePacket.class)\npublic class BedrockEmoteTranslator extends PacketTranslator<EmotePacket> {\n\n    @Override\n    public void translate(GeyserSession session, EmotePacket packet) {\n        if (session.getConnector().getConfig().getEmoteOffhandWorkaround() != EmoteOffhandWorkaroundOption.DISABLED) {\n            // Activate the workaround - we should trigger the offhand now\n            ClientPlayerActionPacket swapHandsPacket = new ClientPlayerActionPacket(PlayerAction.SWAP_HANDS, BlockUtils.POSITION_ZERO,\n                    BlockFace.DOWN);\n            session.sendDownstreamPacket(swapHandsPacket);\n\n            if (session.getConnector().getConfig().getEmoteOffhandWorkaround() == EmoteOffhandWorkaroundOption.NO_EMOTES) {\n                return;\n            }\n        }\n\n        long javaId = session.getPlayerEntity().getEntityId();\n        for (GeyserSession otherSession : session.getConnector().getPlayers()) {\n            if (otherSession != session) {\n                if (otherSession.isClosed()) continue;\n                if (otherSession.getEventLoop().inEventLoop()) {\n                    playEmote(otherSession, javaId, packet.getEmoteId());\n                } else {\n                    session.executeInEventLoop(() -> playEmote(otherSession, javaId, packet.getEmoteId()));\n                }\n            }\n        }\n    }\n\n    private void playEmote(GeyserSession otherSession, long javaId, String emoteId) {\n        Entity otherEntity = otherSession.getEntityCache().getEntityByJavaId(javaId); // Must be ran on same thread\n        if (otherEntity == null) return;\n        EmotePacket otherEmotePacket = new EmotePacket();\n        otherEmotePacket.setEmoteId(emoteId);\n        otherEmotePacket.setRuntimeEntityId(otherEntity.getGeyserId());\n        otherSession.sendUpstreamPacket(otherEmotePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.Hand;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.InteractAction;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerInteractEntityPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;\nimport com.nukkitx.protocol.bedrock.packet.InteractPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InteractiveTagManager;\n\n@Translator(packet = InteractPacket.class)\npublic class BedrockInteractTranslator extends PacketTranslator<InteractPacket> {\n\n    @Override\n    public void translate(GeyserSession session, InteractPacket packet) {\n        Entity entity;\n        if (packet.getRuntimeEntityId() == session.getPlayerEntity().getGeyserId()) {\n            //Player is not in entity cache\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n        }\n        if (entity == null)\n            return;\n\n        switch (packet.getAction()) {\n            case INTERACT:\n                if (session.getPlayerInventory().getItemInHand().getJavaId() == session.getItemMappings().getStoredItems().shield().getJavaId()) {\n                    break;\n                }\n                ClientPlayerInteractEntityPacket interactPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                        InteractAction.INTERACT, Hand.MAIN_HAND, session.isSneaking());\n                session.sendDownstreamPacket(interactPacket);\n                break;\n            case DAMAGE:\n                ClientPlayerInteractEntityPacket attackPacket = new ClientPlayerInteractEntityPacket((int) entity.getEntityId(),\n                        InteractAction.ATTACK, Hand.MAIN_HAND, session.isSneaking());\n                session.sendDownstreamPacket(attackPacket);\n                break;\n            case LEAVE_VEHICLE:\n                ClientPlayerStatePacket sneakPacket = new ClientPlayerStatePacket((int) entity.getEntityId(), PlayerState.START_SNEAKING);\n                session.sendDownstreamPacket(sneakPacket);\n                session.setRidingVehicleEntity(null);\n                break;\n            case MOUSEOVER:\n                // Handle the buttons for mobile - \"Mount\", etc; and the suggestions for console - \"ZL: Mount\", etc\n                if (packet.getRuntimeEntityId() != 0) {\n                    Entity interactEntity = session.getEntityCache().getEntityByGeyserId(packet.getRuntimeEntityId());\n                    session.setMouseoverEntity(interactEntity);\n                    if (interactEntity == null) {\n                        return;\n                    }\n\n                    InteractiveTagManager.updateTag(session, interactEntity);\n                } else {\n                    if (session.getMouseoverEntity() != null) {\n                        // No interactive tag should be sent\n                        session.setMouseoverEntity(null);\n                        session.getPlayerEntity().getMetadata().put(EntityData.INTERACTIVE_TAG, \"\");\n                        session.getPlayerEntity().updateBedrockMetadata(session);\n                    }\n                }\n                break;\n            case OPEN_INVENTORY:\n                if (session.getOpenInventory() == null) {\n                    Entity ridingEntity = session.getRidingVehicleEntity();\n                    if (ridingEntity instanceof AbstractHorseEntity) {\n                        if (ridingEntity.getMetadata().getFlags().getFlag(EntityFlag.TAMED)) {\n                            // We should request to open the horse inventory instead\n                            ClientPlayerStatePacket openHorseWindowPacket = new ClientPlayerStatePacket((int) session.getPlayerEntity().getEntityId(), PlayerState.OPEN_HORSE_INVENTORY);\n                            session.sendDownstreamPacket(openHorseWindowPacket);\n                        }\n                    } else {\n                        session.setOpenInventory(session.getPlayerInventory());\n\n                        ContainerOpenPacket containerOpenPacket = new ContainerOpenPacket();\n                        containerOpenPacket.setId((byte) 0);\n                        containerOpenPacket.setType(ContainerType.INVENTORY);\n                        containerOpenPacket.setUniqueEntityId(-1);\n                        containerOpenPacket.setBlockPosition(entity.getPosition().toInt());\n                        session.sendUpstreamPacket(containerOpenPacket);\n                    }\n                }\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerPositionRotationPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerRotationPacket;\nimport com.github.steveice10.packetlib.packet.Packet;\nimport com.nukkitx.math.vector.Vector3d;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.MoveEntityAbsolutePacket;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.common.ChatColor;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = MovePlayerPacket.class)\npublic class BedrockMovePlayerTranslator extends PacketTranslator<MovePlayerPacket> {\n    /* The upper and lower bounds to check for the void floor that only exists in Bedrock */\n    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y;\n    private static final int BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y;\n\n    static {\n        BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight() ? -104 : -40;\n        BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y = BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y + 2;\n    }\n\n    @Override\n    public void translate(GeyserSession session, MovePlayerPacket packet) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n        if (!session.isSpawned()) return;\n\n        if (!session.getUpstream().isInitialized()) {\n            MoveEntityAbsolutePacket moveEntityBack = new MoveEntityAbsolutePacket();\n            moveEntityBack.setRuntimeEntityId(entity.getGeyserId());\n            moveEntityBack.setPosition(entity.getPosition());\n            moveEntityBack.setRotation(entity.getBedrockRotation());\n            moveEntityBack.setTeleported(true);\n            moveEntityBack.setOnGround(true);\n            session.sendUpstreamPacketImmediately(moveEntityBack);\n            return;\n        }\n\n        session.setLastMovementTimestamp(System.currentTimeMillis());\n\n        // Send book update before the player moves\n        session.getBookEditCache().checkForSend();\n\n        session.confirmTeleport(packet.getPosition().toDouble().sub(0, EntityType.PLAYER.getOffset(), 0));\n        // head yaw, pitch, head yaw\n        Vector3f rotation = Vector3f.from(packet.getRotation().getY(), packet.getRotation().getX(), packet.getRotation().getY());\n\n        boolean positionChanged = !entity.getPosition().equals(packet.getPosition());\n        boolean rotationChanged = !entity.getRotation().equals(rotation);\n\n        // If only the pitch and yaw changed\n        // This isn't needed, but it makes the packets closer to vanilla\n        // It also means you can't \"lag back\" while only looking, in theory\n        if (!positionChanged && rotationChanged) {\n            ClientPlayerRotationPacket playerRotationPacket = new ClientPlayerRotationPacket(\n                    packet.isOnGround(), packet.getRotation().getY(), packet.getRotation().getX());\n\n            entity.setRotation(rotation);\n            entity.setOnGround(packet.isOnGround());\n\n            session.sendDownstreamPacket(playerRotationPacket);\n        } else {\n            Vector3d position = session.getCollisionManager().adjustBedrockPosition(packet.getPosition(), packet.isOnGround());\n            if (position != null) { // A null return value cancels the packet\n                if (isValidMove(session, packet.getMode(), entity.getPosition(), packet.getPosition())) {\n                    Packet movePacket;\n                    if (rotationChanged) {\n                        // Send rotation updates as well\n                        movePacket = new ClientPlayerPositionRotationPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ(),\n                                packet.getRotation().getY(), packet.getRotation().getX());\n                        entity.setRotation(rotation);\n                    } else {\n                        // Rotation did not change; don't send an update with rotation\n                        movePacket = new ClientPlayerPositionPacket(packet.isOnGround(), position.getX(), position.getY(), position.getZ());\n                    }\n\n                    // Compare positions here for void floor fix below before the player's position variable is set to the packet position\n                    boolean notMovingUp = entity.getPosition().getY() >= packet.getPosition().getY();\n\n                    entity.setPositionManual(packet.getPosition());\n                    entity.setOnGround(packet.isOnGround());\n\n                    // Send final movement changes\n                    session.sendDownstreamPacket(movePacket);\n\n                    if (notMovingUp) {\n                        int floorY = position.getFloorY();\n                        // If the client believes the world has extended height, then it also believes the void floor\n                        // still exists, just at a lower spot\n                        boolean extendedWorld = session.getChunkCache().isExtendedHeight();\n                        if (floorY <= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_LOWER_Y : -38)\n                                && floorY >= (extendedWorld ? BEDROCK_OVERWORLD_VOID_FLOOR_UPPER_Y : -40)) {\n                            // Work around there being a floor at the bottom of the world and teleport the player below it\n                            // Moving from below to above the void floor works fine\n                            entity.setPosition(entity.getPosition().sub(0, 4f, 0));\n                            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                            movePlayerPacket.setPosition(entity.getPosition());\n                            movePlayerPacket.setRotation(entity.getBedrockRotation());\n                            movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                            movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.BEHAVIOR);\n                            session.sendUpstreamPacket(movePlayerPacket);\n                        }\n                    }\n                } else {\n                    // Not a valid move\n                    session.getConnector().getLogger().debug(\"Recalculating position...\");\n                    session.getCollisionManager().recalculatePosition();\n                }\n            }\n        }\n\n        // Move parrots to match if applicable\n        if (entity.getLeftParrot() != null) {\n            entity.getLeftParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);\n        }\n        if (entity.getRightParrot() != null) {\n            entity.getRightParrot().moveAbsolute(session, entity.getPosition(), entity.getRotation(), true, false);\n        }\n    }\n\n    private boolean isValidMove(GeyserSession session, MovePlayerPacket.Mode mode, Vector3f currentPosition, Vector3f newPosition) {\n        if (mode != MovePlayerPacket.Mode.NORMAL)\n            return true;\n\n        double xRange = newPosition.getX() - currentPosition.getX();\n        double yRange = newPosition.getY() - currentPosition.getY();\n        double zRange = newPosition.getZ() - currentPosition.getZ();\n\n        if (xRange < 0)\n            xRange = -xRange;\n        if (yRange < 0)\n            yRange = -yRange;\n        if (zRange < 0)\n            zRange = -zRange;\n\n        if ((xRange + yRange + zRange) > 100) {\n            session.getConnector().getLogger().debug(ChatColor.RED + session.getName() + \" moved too quickly.\" +\n                    \" current position: \" + currentPosition + \", new position: \" + newPosition);\n\n            return false;\n        }\n\n        return true;\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerState;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.player.ClientPlayerStatePacket;\nimport com.nukkitx.protocol.bedrock.packet.RiderJumpPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = RiderJumpPacket.class)\npublic class BedrockRiderJumpTranslator extends PacketTranslator<RiderJumpPacket> {\n    @Override\n    public void translate(GeyserSession session, RiderJumpPacket packet) {\n        Entity vehicle = session.getRidingVehicleEntity();\n        if (vehicle instanceof AbstractHorseEntity) {\n            ClientPlayerStatePacket playerStatePacket = new ClientPlayerStatePacket((int) vehicle.getEntityId(),  PlayerState.START_HORSE_JUMP, packet.getJumpStrength());\n            session.sendDownstreamPacket(playerStatePacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.entity.player;\n\nimport com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * In vanilla Bedrock, if you have operator status, this sets the player's gamemode without confirmation from the server.\n * Since we have a custom server option to request the gamemode, we just reset the gamemode and ignore this.\n */\n@Translator(packet = SetPlayerGameTypePacket.class)\npublic class BedrockSetPlayerGameTypeTranslator extends PacketTranslator<SetPlayerGameTypePacket> {\n\n    @Override\n    public void translate(GeyserSession session, SetPlayerGameTypePacket packet) {\n        // no\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(session.getGameMode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.bedrock.world;\n\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.CooldownUtils;\n\n@Translator(packet = LevelSoundEventPacket.class)\npublic class BedrockLevelSoundEventTranslator extends PacketTranslator<LevelSoundEventPacket> {\n\n    @Override\n    public void translate(GeyserSession session, LevelSoundEventPacket packet) {\n        // lol what even :thinking:\n        session.sendUpstreamPacket(packet);\n\n        // Yes, what even, but thankfully we can hijack this packet to send the cooldown\n        if (packet.getSound() == SoundEvent.ATTACK_NODAMAGE || packet.getSound() == SoundEvent.ATTACK || packet.getSound() == SoundEvent.ATTACK_STRONG) {\n            // Send a faux cooldown since Bedrock has no cooldown support\n            // Sent here because Java still sends a cooldown if the player doesn't hit anything but Bedrock always sends a sound\n            CooldownUtils.sendCooldown(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementTabPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.AdvancementsCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Indicates that the client should open a particular advancement tab\n */\n@Translator(packet = ServerAdvancementTabPacket.class)\npublic class JavaAdvancementsTabTranslator extends PacketTranslator<ServerAdvancementTabPacket> {\n    @Override\n    public void translate(GeyserSession session, ServerAdvancementTabPacket packet) {\n        AdvancementsCache advancementsCache = session.getAdvancementsCache();\n        advancementsCache.setCurrentAdvancementCategoryId(packet.getTabId());\n        advancementsCache.buildAndShowListForm();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.advancement.Advancement;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerAdvancementsPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\nimport org.geysermc.connector.network.session.cache.AdvancementsCache;\nimport org.geysermc.connector.utils.GeyserAdvancement;\nimport org.geysermc.connector.utils.LocaleUtils;\n\nimport java.util.Map;\n\n@Translator(packet = ServerAdvancementsPacket.class)\npublic class JavaAdvancementsTranslator extends PacketTranslator<ServerAdvancementsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerAdvancementsPacket packet) {\n        AdvancementsCache advancementsCache = session.getAdvancementsCache();\n        if (packet.isReset()) {\n            advancementsCache.getStoredAdvancements().clear();\n            advancementsCache.getStoredAdvancementProgress().clear();\n        }\n\n        // Removes removed advancements from player's stored advancements\n        for (String removedAdvancement : packet.getRemovedAdvancements()) {\n            advancementsCache.getStoredAdvancements().remove(removedAdvancement);\n        }\n\n        advancementsCache.getStoredAdvancementProgress().putAll(packet.getProgress());\n\n        sendToolbarAdvancementUpdates(session, packet);\n\n        // Adds advancements to the player's stored advancements when advancements are sent\n        for (Advancement advancement : packet.getAdvancements()) {\n            if (advancement.getDisplayData() != null && !advancement.getDisplayData().isHidden()) {\n                GeyserAdvancement geyserAdvancement = GeyserAdvancement.from(advancement);\n                advancementsCache.getStoredAdvancements().put(advancement.getId(), geyserAdvancement);\n            } else {\n                advancementsCache.getStoredAdvancements().remove(advancement.getId());\n            }\n        }\n    }\n\n    /**\n     * Handle all advancements progress updates\n     */\n    public void sendToolbarAdvancementUpdates(GeyserSession session, ServerAdvancementsPacket packet) {\n        if (packet.isReset()) {\n            // Advancements are being cleared, so they can't be granted\n            return;\n        }\n        for (Map.Entry<String, Map<String, Long>> progress : packet.getProgress().entrySet()) {\n            GeyserAdvancement advancement = session.getAdvancementsCache().getStoredAdvancements().get(progress.getKey());\n            if (advancement != null && advancement.getDisplayData() != null) {\n                if (session.getAdvancementsCache().isEarned(advancement)) {\n                    // Java uses some pink color for toast challenge completes\n                    String color = advancement.getDisplayData().getFrameType() == Advancement.DisplayData.FrameType.CHALLENGE ?\n                            \"\u00a7d\" : \"\u00a7a\";\n                    String advancementName = MessageTranslator.convertMessage(advancement.getDisplayData().getTitle(), session.getLocale());\n\n                    // Send an action bar message stating they earned an achievement\n                    // Sent for instances where broadcasting advancements through chat are disabled\n                    SetTitlePacket titlePacket = new SetTitlePacket();\n                    titlePacket.setText(color + \"[\" + LocaleUtils.getLocaleString(\"advancements.toast.\" +\n                            advancement.getDisplayData().getFrameType().toString().toLowerCase(), session.getLocale()) + \"]\u00a7f \" + advancementName);\n                    titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n                    titlePacket.setFadeOutTime(3);\n                    titlePacket.setFadeInTime(3);\n                    titlePacket.setStayTime(3);\n                    titlePacket.setXuid(\"\");\n                    titlePacket.setPlatformOnlineId(\"\");\n                    session.sendUpstreamPacket(titlePacket);\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.BossBar;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerBossBarPacket;\n\n@Translator(packet = ServerBossBarPacket.class)\npublic class JavaBossBarTranslator extends PacketTranslator<ServerBossBarPacket> {\n    @Override\n    public void translate(GeyserSession session, ServerBossBarPacket packet) {\n        BossBar bossBar = session.getEntityCache().getBossBar(packet.getUuid());\n        switch (packet.getAction()) {\n            case ADD:\n                long entityId = session.getEntityCache().getNextEntityId().incrementAndGet();\n                bossBar = new BossBar(session, entityId, packet.getTitle(), packet.getHealth(), 0, 1, 0);\n                session.getEntityCache().addBossBar(packet.getUuid(), bossBar);\n                break;\n            case UPDATE_TITLE:\n                if (bossBar != null) bossBar.updateTitle(packet.getTitle());\n                break;\n            case UPDATE_HEALTH:\n                if (bossBar != null) bossBar.updateHealth(packet.getHealth());\n                break;\n            case REMOVE:\n                session.getEntityCache().removeBossBar(packet.getUuid());\n                break;\n            case UPDATE_STYLE:\n            case UPDATE_FLAGS:\n                //todo\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerChatPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerChatPacket.class)\npublic class JavaChatTranslator extends PacketTranslator<ServerChatPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerChatPacket packet) {\n        TextPacket textPacket = new TextPacket();\n        textPacket.setPlatformChatId(\"\");\n        textPacket.setSourceName(\"\");\n        textPacket.setXuid(session.getAuthData().getXboxUUID());\n        switch (packet.getType()) {\n            case CHAT:\n                textPacket.setType(TextPacket.Type.CHAT);\n                break;\n            case SYSTEM:\n                textPacket.setType(TextPacket.Type.SYSTEM);\n                break;\n            case NOTIFICATION:\n                textPacket.setType(TextPacket.Type.TIP);\n                break;\n            default:\n                textPacket.setType(TextPacket.Type.RAW);\n                break;\n        }\n\n        textPacket.setNeedsTranslation(false);\n        textPacket.setMessage(MessageTranslator.convertMessage(packet.getMessage(), session.getLocale()));\n\n        session.sendUpstreamPacket(textPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.command.CommandNode;\nimport com.github.steveice10.mc.protocol.data.game.command.CommandParser;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareCommandsPacket;\nimport com.nukkitx.protocol.bedrock.data.command.CommandData;\nimport com.nukkitx.protocol.bedrock.data.command.CommandEnumData;\nimport com.nukkitx.protocol.bedrock.data.command.CommandParam;\nimport com.nukkitx.protocol.bedrock.data.command.CommandParamData;\nimport com.nukkitx.protocol.bedrock.packet.AvailableCommandsPacket;\nimport it.unimi.dsi.fastutil.Hash;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectMap;\nimport it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;\nimport it.unimi.dsi.fastutil.ints.IntOpenHashSet;\nimport it.unimi.dsi.fastutil.ints.IntSet;\nimport it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;\nimport lombok.Getter;\nimport lombok.ToString;\nimport net.kyori.adventure.text.format.NamedTextColor;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.Enchantment;\nimport org.geysermc.connector.registry.BlockRegistries;\n\nimport java.util.*;\n\n@Translator(packet = ServerDeclareCommandsPacket.class)\npublic class JavaDeclareCommandsTranslator extends PacketTranslator<ServerDeclareCommandsPacket> {\n\n    private static final String[] ENUM_BOOLEAN = {\"true\", \"false\"};\n    private static final String[] VALID_COLORS;\n    private static final String[] VALID_SCOREBOARD_SLOTS;\n\n    private static final Hash.Strategy<CommandParamData[][]> PARAM_STRATEGY = new Hash.Strategy<CommandParamData[][]>() {\n        @Override\n        public int hashCode(CommandParamData[][] o) {\n            return Arrays.deepHashCode(o);\n        }\n\n        @Override\n        public boolean equals(CommandParamData[][] a, CommandParamData[][] b) {\n            if (a == b) return true;\n            if (a == null || b == null) return false;\n            if (a.length != b.length) return false;\n            for (int i = 0; i < a.length; i++) {\n                CommandParamData[] a1 = a[i];\n                CommandParamData[] b1 = b[i];\n                if (a1.length != b1.length) return false;\n\n                for (int j = 0; j < a1.length; j++) {\n                    if (!a1[j].equals(b1[j])) return false;\n                }\n            }\n            return true;\n        }\n    };\n\n    static {\n        List<String> validColors = new ArrayList<>(NamedTextColor.NAMES.keys());\n        validColors.add(\"reset\");\n        VALID_COLORS = validColors.toArray(new String[0]);\n\n        List<String> teamOptions = new ArrayList<>(Arrays.asList(\"list\", \"sidebar\", \"belowName\"));\n        for (String color : NamedTextColor.NAMES.keys()) {\n            teamOptions.add(\"sidebar.team.\" + color);\n        }\n        VALID_SCOREBOARD_SLOTS = teamOptions.toArray(new String[0]);\n    }\n\n    @Override\n    public void translate(GeyserSession session, ServerDeclareCommandsPacket packet) {\n        // Don't send command suggestions if they are disabled\n        if (!session.getConnector().getConfig().isCommandSuggestions()) {\n            session.getConnector().getLogger().debug(\"Not sending translated command suggestions as they are disabled.\");\n\n            // Send an empty packet so Bedrock doesn't override /help with its own, built-in help command.\n            AvailableCommandsPacket emptyPacket = new AvailableCommandsPacket();\n            session.sendUpstreamPacket(emptyPacket);\n            return;\n        }\n\n        CommandNode[] nodes = packet.getNodes();\n        List<CommandData> commandData = new ArrayList<>();\n        IntSet commandNodes = new IntOpenHashSet();\n        Set<String> knownAliases = new HashSet<>();\n        Map<CommandParamData[][], Set<String>> commands = new Object2ObjectOpenCustomHashMap<>(PARAM_STRATEGY);\n        Int2ObjectMap<List<CommandNode>> commandArgs = new Int2ObjectOpenHashMap<>();\n\n        // Get the first node, it should be a root node\n        CommandNode rootNode = nodes[packet.getFirstNodeIndex()];\n\n        // Loop through the root nodes to get all commands\n        for (int nodeIndex : rootNode.getChildIndices()) {\n            CommandNode node = nodes[nodeIndex];\n\n            // Make sure we don't have duplicated commands (happens if there is more than 1 root node)\n            if (!commandNodes.add(nodeIndex) || !knownAliases.add(node.getName().toLowerCase())) continue;\n\n            // Get and update the commandArgs list with the found arguments\n            if (node.getChildIndices().length >= 1) {\n                for (int childIndex : node.getChildIndices()) {\n                    commandArgs.computeIfAbsent(nodeIndex, ArrayList::new).add(nodes[childIndex]);\n                }\n            }\n\n            // Get and parse all params\n            CommandParamData[][] params = getParams(session, nodes[nodeIndex], nodes);\n\n            // Insert the alias name into the command list\n            commands.computeIfAbsent(params, index -> new HashSet<>()).add(node.getName().toLowerCase());\n        }\n\n        // The command flags, not sure what these do apart from break things\n        List<CommandData.Flag> flags = Collections.emptyList();\n\n        // Loop through all the found commands\n\n        for (Map.Entry<CommandParamData[][], Set<String>> entry : commands.entrySet()) {\n            String commandName = entry.getValue().iterator().next(); // We know this has a value\n\n            // Create a basic alias\n            CommandEnumData aliases = new CommandEnumData(commandName + \"Aliases\", entry.getValue().toArray(new String[0]), false);\n\n            // Build the completed command and add it to the final list\n            CommandData data = new CommandData(commandName, session.getConnector().getCommandManager().getDescription(commandName), flags, (byte) 0, aliases, entry.getKey());\n            commandData.add(data);\n        }\n\n        // Add our commands to the AvailableCommandsPacket for the bedrock client\n        AvailableCommandsPacket availableCommandsPacket = new AvailableCommandsPacket();\n        availableCommandsPacket.getCommands().addAll(commandData);\n\n        session.getConnector().getLogger().debug(\"Sending command packet of \" + commandData.size() + \" commands\");\n\n        // Finally, send the commands to the client\n        session.sendUpstreamPacket(availableCommandsPacket);\n    }\n\n    /**\n     * Build the command parameter array for the given command\n     *\n     * @param session the session\n     * @param commandNode The command to build the parameters for\n     * @param allNodes    Every command node\n     * @return An array of parameter option arrays\n     */\n    private static CommandParamData[][] getParams(GeyserSession session, CommandNode commandNode, CommandNode[] allNodes) {\n        // Check if the command is an alias and redirect it\n        if (commandNode.getRedirectIndex() != -1) {\n            GeyserConnector.getInstance().getLogger().debug(\"Redirecting command \" + commandNode.getName() + \" to \" + allNodes[commandNode.getRedirectIndex()].getName());\n            commandNode = allNodes[commandNode.getRedirectIndex()];\n        }\n\n        if (commandNode.getChildIndices().length >= 1) {\n            // Create the root param node and build all the children\n            ParamInfo rootParam = new ParamInfo(commandNode, null);\n            rootParam.buildChildren(session, allNodes);\n\n            List<CommandParamData[]> treeData = rootParam.getTree();\n\n            return treeData.toArray(new CommandParamData[0][]);\n        }\n\n        return new CommandParamData[0][0];\n    }\n\n    /**\n     * Convert Java edition command types to Bedrock edition\n     *\n     * @param session the session\n     * @param parser Command type to convert\n     * @return Bedrock parameter data type\n     */\n    private static Object mapCommandType(GeyserSession session, CommandParser parser) {\n        if (parser == null) {\n            return CommandParam.STRING;\n        }\n\n        switch (parser) {\n            case FLOAT:\n            case ROTATION:\n            case DOUBLE:\n                return CommandParam.FLOAT;\n\n            case INTEGER:\n            case LONG:\n                return CommandParam.INT;\n\n            case ENTITY:\n            case GAME_PROFILE:\n                return CommandParam.TARGET;\n\n            case BLOCK_POS:\n                return CommandParam.BLOCK_POSITION;\n\n            case COLUMN_POS:\n            case VEC3:\n                return CommandParam.POSITION;\n\n            case MESSAGE:\n                return CommandParam.MESSAGE;\n\n            case NBT:\n            case NBT_COMPOUND_TAG:\n            case NBT_TAG:\n            case NBT_PATH:\n                return CommandParam.JSON;\n\n            case RESOURCE_LOCATION:\n            case FUNCTION:\n                return CommandParam.FILE_PATH;\n\n            case BOOL:\n                return ENUM_BOOLEAN;\n\n            case OPERATION: // \">=\", \"==\", etc\n                return CommandParam.OPERATOR;\n\n            case BLOCK_STATE:\n                return BlockRegistries.JAVA_TO_BEDROCK_IDENTIFIERS.get().keySet().toArray(new String[0]);\n\n            case ITEM_STACK:\n                return session.getItemMappings().getItemNames();\n\n            case ITEM_ENCHANTMENT:\n                return Enchantment.JavaEnchantment.ALL_JAVA_IDENTIFIERS;\n\n            case ENTITY_SUMMON:\n                return EntityType.ALL_JAVA_IDENTIFIERS;\n\n            case COLOR:\n                return VALID_COLORS;\n\n            case SCOREBOARD_SLOT:\n                return VALID_SCOREBOARD_SLOTS;\n\n            default:\n                return CommandParam.STRING;\n        }\n    }\n\n    @Getter\n    @ToString\n    private static class ParamInfo {\n        private final CommandNode paramNode;\n        private final CommandParamData paramData;\n        private final List<ParamInfo> children;\n\n        /**\n         * Create a new parameter info object\n         *\n         * @param paramNode CommandNode the parameter is for\n         * @param paramData The existing parameters for the command\n         */\n        public ParamInfo(CommandNode paramNode, CommandParamData paramData) {\n            this.paramNode = paramNode;\n            this.paramData = paramData;\n            this.children = new ArrayList<>();\n        }\n\n        /**\n         * Build the array of all the child parameters (recursive)\n         *\n         * @param session the session\n         * @param allNodes Every command node\n         */\n        public void buildChildren(GeyserSession session, CommandNode[] allNodes) {\n            for (int paramID : paramNode.getChildIndices()) {\n                CommandNode paramNode = allNodes[paramID];\n\n                if (paramNode == this.paramNode) {\n                    // Fixes a StackOverflowError when an argument has itself as a child\n                    continue;\n                }\n\n                if (paramNode.getParser() == null) {\n                    boolean foundCompatible = false;\n                    for (int i = 0; i < children.size(); i++) {\n                        ParamInfo enumParamInfo = children.get(i);\n                        // Check to make sure all descending nodes of this command are compatible - otherwise, create a new overload\n                        if (isCompatible(allNodes, enumParamInfo.getParamNode(), paramNode)) {\n                            foundCompatible = true;\n                            // Extend the current list of enum values\n                            String[] enumOptions = Arrays.copyOf(enumParamInfo.getParamData().getEnumData().getValues(), enumParamInfo.getParamData().getEnumData().getValues().length + 1);\n                            enumOptions[enumOptions.length - 1] = paramNode.getName();\n\n                            // Re-create the command using the updated values\n                            CommandEnumData enumData = new CommandEnumData(enumParamInfo.getParamData().getEnumData().getName(), enumOptions, false);\n                            children.set(i, new ParamInfo(enumParamInfo.getParamNode(), new CommandParamData(enumParamInfo.getParamData().getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));\n                            break;\n                        }\n                    }\n\n                    if (!foundCompatible) {\n                        // Create a new subcommand with this exact type\n                        CommandEnumData enumData = new CommandEnumData(paramNode.getName(), new String[]{paramNode.getName()}, false);\n\n                        // On setting optional:\n                        // isExecutable is defined as a node \"constitutes a valid command.\"\n                        // Therefore, any children of the parameter must simply be optional.\n                        children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, null, null, Collections.emptyList())));\n                    }\n                } else {\n                    // Put the non-enum param into the list\n                    Object mappedType = mapCommandType(session, paramNode.getParser());\n                    CommandEnumData enumData = null;\n                    CommandParam type = null;\n                    if (mappedType instanceof String[]) {\n                        enumData = new CommandEnumData(paramNode.getParser().name().toLowerCase(), (String[]) mappedType, false);\n                    } else {\n                        type = (CommandParam) mappedType;\n                    }\n                    // IF enumData != null:\n                    // In game, this will show up like <paramNode.getName(): enumData.getName()>\n                    // So if paramNode.getName() == \"value\" and enumData.getName() == \"bool\": <value: bool>\n                    children.add(new ParamInfo(paramNode, new CommandParamData(paramNode.getName(), this.paramNode.isExecutable(), enumData, type, null, Collections.emptyList())));\n                }\n            }\n\n            // Recursively build all child options\n            for (ParamInfo child : children) {\n                child.buildChildren(session, allNodes);\n            }\n        }\n\n        /**\n         * Comparing CommandNode type a and b, determine if they are in the same overload.\n         * <p>\n         * Take the <code>gamerule</code> command, and let's present three \"subcommands\" you can perform:\n         *\n         * <ul>\n         *     <li><code>gamerule doDaylightCycle true</code></li>\n         *     <li><code>gamerule announceAdvancements false</code></li>\n         *     <li><code>gamerule randomTickSpeed 3</code></li>\n         * </ul>\n         *\n         * While all three of them are indeed part of the same command, the command setting randomTickSpeed parses an int,\n         * while the others use boolean. In Bedrock, this should be presented as a separate overload to indicate that this\n         * does something a little different.\n         * <p>\n         * Therefore, this function will return <code>true</code> if the first two are compared, as they use the same\n         * parsers. If the third is compared with either of the others, this function will return <code>false</code>.\n         * <p>\n         * Here's an example of how the above would be presented to Bedrock (as of 1.16.200). Notice how the top two <code>CommandParamData</code>\n         * classes of each array are identical in type, but the following class is different:\n         * <pre>\n         *     overloads=[\n         *         [\n         *            CommandParamData(name=doDaylightCycle, optional=false, enumData=CommandEnumData(name=announceAdvancements, values=[announceAdvancements, doDaylightCycle], isSoft=false), type=STRING, postfix=null, options=[])\n         *            CommandParamData(name=value, optional=false, enumData=CommandEnumData(name=value, values=[true, false], isSoft=false), type=null, postfix=null, options=[])\n         *         ]\n         *         [\n         *            CommandParamData(name=randomTickSpeed, optional=false, enumData=CommandEnumData(name=randomTickSpeed, values=[randomTickSpeed], isSoft=false), type=STRING, postfix=null, options=[])\n         *            CommandParamData(name=value, optional=false, enumData=null, type=INT, postfix=null, options=[])\n         *         ]\n         *     ]\n         * </pre>\n         *\n         * @return if these two can be merged into one overload.\n         */\n        private boolean isCompatible(CommandNode[] allNodes, CommandNode a, CommandNode b) {\n            if (a == b) return true;\n            if (a.getParser() != b.getParser()) return false;\n            if (a.getChildIndices().length != b.getChildIndices().length) return false;\n\n            for (int i = 0; i < a.getChildIndices().length; i++) {\n                boolean hasSimilarity = false;\n                CommandNode a1 = allNodes[a.getChildIndices()[i]];\n                // Search \"b\" until we find a child that matches this one\n                for (int j = 0; j < b.getChildIndices().length; j++) {\n                    if (isCompatible(allNodes, a1, allNodes[b.getChildIndices()[j]])) {\n                        hasSimilarity = true;\n                        break;\n                    }\n                }\n\n                if (!hasSimilarity) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Get the tree of every parameter node (recursive)\n         *\n         * @return List of parameter options arrays for the command\n         */\n        public List<CommandParamData[]> getTree() {\n            List<CommandParamData[]> treeParamData = new ArrayList<>();\n\n            for (ParamInfo child : children) {\n                // Get the tree from the child\n                List<CommandParamData[]> childTree = child.getTree();\n\n                // Un-pack the tree append the child node to it and push into the list\n                for (CommandParamData[] subChild : childTree) {\n                    CommandParamData[] tmpTree = new CommandParamData[subChild.length + 1];\n                    tmpTree[0] = child.getParamData();\n                    System.arraycopy(subChild, 0, tmpTree, 1, subChild.length);\n\n                    treeParamData.add(tmpTree);\n                }\n\n                // If we have no more child parameters just the child\n                if (childTree.size() == 0) {\n                    treeParamData.add(new CommandParamData[] { child.getParamData() });\n                }\n            }\n\n            return treeParamData;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Recipe;\nimport com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.StoneCuttingRecipeData;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareRecipesPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.data.inventory.CraftingData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;\nimport it.unimi.dsi.fastutil.ints.*;\nimport lombok.AllArgsConstructor;\nimport lombok.EqualsAndHashCode;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static org.geysermc.connector.utils.InventoryUtils.LAST_RECIPE_NET_ID;\n\n/**\n * Used to send all valid recipes from Java to Bedrock.\n *\n * Bedrock REQUIRES a CraftingDataPacket to be sent in order to craft anything.\n */\n@Translator(packet = ServerDeclareRecipesPacket.class)\npublic class JavaDeclareRecipesTranslator extends PacketTranslator<ServerDeclareRecipesPacket> {\n    /**\n     * Required to use the specified cartography table recipes\n     */\n    private static final List<CraftingData> CARTOGRAPHY_RECIPES = Arrays.asList(\n            CraftingData.fromMulti(UUID.fromString(\"8b36268c-1829-483c-a0f1-993b7156a8f2\"), ++LAST_RECIPE_NET_ID), // Map extending\n            CraftingData.fromMulti(UUID.fromString(\"442d85ed-8272-4543-a6f1-418f90ded05d\"), ++LAST_RECIPE_NET_ID), // Map cloning\n            CraftingData.fromMulti(UUID.fromString(\"98c84b38-1085-46bd-b1ce-dd38c159e6cc\"), ++LAST_RECIPE_NET_ID), // Map upgrading\n            CraftingData.fromMulti(UUID.fromString(\"602234e4-cac1-4353-8bb7-b1ebff70024b\"), ++LAST_RECIPE_NET_ID) // Map locking\n    );\n\n    @Override\n    public void translate(GeyserSession session, ServerDeclareRecipesPacket packet) {\n        Map<RecipeType, List<CraftingData>> recipeTypes = Registries.CRAFTING_DATA.forVersion(session.getUpstream().getProtocolVersion());\n        // Get the last known network ID (first used for the pregenerated recipes) and increment from there.\n        int netId = InventoryUtils.LAST_RECIPE_NET_ID + 1;\n\n        Int2ObjectMap<Recipe> recipeMap = new Int2ObjectOpenHashMap<>(Registries.RECIPES.forVersion(session.getUpstream().getProtocolVersion()));\n        Int2ObjectMap<List<StoneCuttingRecipeData>> unsortedStonecutterData = new Int2ObjectOpenHashMap<>();\n        CraftingDataPacket craftingDataPacket = new CraftingDataPacket();\n        craftingDataPacket.setCleanRecipes(true);\n        for (Recipe recipe : packet.getRecipes()) {\n            switch (recipe.getType()) {\n                case CRAFTING_SHAPELESS: {\n                    ShapelessRecipeData shapelessRecipeData = (ShapelessRecipeData) recipe.getData();\n                    ItemData output = ItemTranslator.translateToBedrock(session, shapelessRecipeData.getResult());\n                    // Strip NBT - tools won't appear in the recipe book otherwise\n                    output = output.toBuilder().tag(null).build();\n                    ItemData[][] inputCombinations = combinations(session, shapelessRecipeData.getIngredients());\n                    for (ItemData[] inputs : inputCombinations) {\n                        UUID uuid = UUID.randomUUID();\n                        craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),\n                                Arrays.asList(inputs), Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));\n                        recipeMap.put(netId++, recipe);\n                    }\n                    break;\n                }\n                case CRAFTING_SHAPED: {\n                    ShapedRecipeData shapedRecipeData = (ShapedRecipeData) recipe.getData();\n                    ItemData output = ItemTranslator.translateToBedrock(session, shapedRecipeData.getResult());\n                    // See above\n                    output = output.toBuilder().tag(null).build();\n                    ItemData[][] inputCombinations = combinations(session, shapedRecipeData.getIngredients());\n                    for (ItemData[] inputs : inputCombinations) {\n                        UUID uuid = UUID.randomUUID();\n                        craftingDataPacket.getCraftingData().add(CraftingData.fromShaped(uuid.toString(),\n                                shapedRecipeData.getWidth(), shapedRecipeData.getHeight(), Arrays.asList(inputs),\n                                        Collections.singletonList(output), uuid, \"crafting_table\", 0, netId));\n                        recipeMap.put(netId++, recipe);\n                    }\n                    break;\n                }\n                case STONECUTTING: {\n                    StoneCuttingRecipeData stoneCuttingData = (StoneCuttingRecipeData) recipe.getData();\n                    ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];\n                    List<StoneCuttingRecipeData> data = unsortedStonecutterData.get(ingredient.getId());\n                    if (data == null) {\n                        data = new ArrayList<>();\n                        unsortedStonecutterData.put(ingredient.getId(), data);\n                    }\n                    data.add(stoneCuttingData);\n                    // Save for processing after all recipes have been received\n                    break;\n                }\n                default: {\n                    List<CraftingData> craftingData = recipeTypes.get(recipe.getType());\n                    if (craftingData != null) {\n                        craftingDataPacket.getCraftingData().addAll(craftingData);\n                    }\n                    break;\n                }\n            }\n        }\n        craftingDataPacket.getCraftingData().addAll(CARTOGRAPHY_RECIPES);\n        craftingDataPacket.getPotionMixData().addAll(Registries.POTION_MIXES.get());\n\n        Int2ObjectMap<IntList> stonecutterRecipeMap = new Int2ObjectOpenHashMap<>();\n        for (Int2ObjectMap.Entry<List<StoneCuttingRecipeData>> data : unsortedStonecutterData.int2ObjectEntrySet()) {\n            // Sort the list by each output item's Java identifier - this is how it's sorted on Java, and therefore\n            // We can get the correct order for button pressing\n            data.getValue().sort(Comparator.comparing((stoneCuttingRecipeData ->\n                    session.getItemMappings().getItems().get(stoneCuttingRecipeData.getResult().getId()).getJavaIdentifier())));\n\n            // Now that it's sorted, let's translate these recipes\n            for (StoneCuttingRecipeData stoneCuttingData : data.getValue()) {\n                // As of 1.16.4, all stonecutter recipes have one ingredient option\n                ItemStack ingredient = stoneCuttingData.getIngredient().getOptions()[0];\n                ItemData input = ItemTranslator.translateToBedrock(session, ingredient);\n                ItemData output = ItemTranslator.translateToBedrock(session, stoneCuttingData.getResult());\n                UUID uuid = UUID.randomUUID();\n\n                // We need to register stonecutting recipes so they show up on Bedrock\n                craftingDataPacket.getCraftingData().add(CraftingData.fromShapeless(uuid.toString(),\n                        Collections.singletonList(input), Collections.singletonList(output), uuid, \"stonecutter\", 0, netId++));\n\n                // Save the recipe list for reference when crafting\n                IntList outputs = stonecutterRecipeMap.get(ingredient.getId());\n                if (outputs == null) {\n                    outputs = new IntArrayList();\n                    // Add the ingredient as the key and all possible values as the value\n                    stonecutterRecipeMap.put(ingredient.getId(), outputs);\n                }\n                outputs.add(stoneCuttingData.getResult().getId());\n            }\n        }\n\n        session.sendUpstreamPacket(craftingDataPacket);\n        session.setCraftingRecipes(recipeMap);\n        session.getUnlockedRecipes().clear();\n        session.setStonecutterRecipes(stonecutterRecipeMap);\n        session.getLastRecipeNetId().set(netId);\n    }\n\n    //TODO: rewrite\n    /**\n     * The Java server sends an array of items for each ingredient you can use per slot in the crafting grid.\n     * Bedrock recipes take only one ingredient per crafting grid slot.\n     *\n     * @return the Java ingredient list as an array that Bedrock can understand\n     */\n    private ItemData[][] combinations(GeyserSession session, Ingredient[] ingredients) {\n        Map<Set<ItemData>, IntSet> squashedOptions = new HashMap<>();\n        for (int i = 0; i < ingredients.length; i++) {\n            if (ingredients[i].getOptions().length == 0) {\n                squashedOptions.computeIfAbsent(Collections.singleton(ItemData.AIR), k -> new IntOpenHashSet()).add(i);\n                continue;\n            }\n            Ingredient ingredient = ingredients[i];\n            Map<GroupedItem, List<ItemData>> groupedByIds = Arrays.stream(ingredient.getOptions())\n                    .map(item -> ItemTranslator.translateToBedrock(session, item))\n                    .collect(Collectors.groupingBy(item -> new GroupedItem(item.getId(), item.getCount(), item.getTag())));\n            Set<ItemData> optionSet = new HashSet<>(groupedByIds.size());\n            for (Map.Entry<GroupedItem, List<ItemData>> entry : groupedByIds.entrySet()) {\n                if (entry.getValue().size() > 1) {\n                    GroupedItem groupedItem = entry.getKey();\n                    int idCount = 0;\n                    //not optimal\n                    for (ItemMapping mapping : session.getItemMappings().getItems().values()) {\n                        if (mapping.getBedrockId() == groupedItem.id) {\n                            idCount++;\n                        }\n                    }\n                    if (entry.getValue().size() < idCount) {\n                        optionSet.addAll(entry.getValue());\n                    } else {\n                        optionSet.add(ItemData.builder()\n                                .id(groupedItem.id)\n                                .damage(Short.MAX_VALUE)\n                                .count(groupedItem.count)\n                                .tag(groupedItem.tag).build());\n                    }\n                } else {\n                    ItemData item = entry.getValue().get(0);\n                    optionSet.add(item);\n                }\n            }\n            squashedOptions.computeIfAbsent(optionSet, k -> new IntOpenHashSet()).add(i);\n        }\n        int totalCombinations = 1;\n        for (Set<ItemData> optionSet : squashedOptions.keySet()) {\n            totalCombinations *= optionSet.size();\n        }\n        if (totalCombinations > 500) {\n            ItemData[] translatedItems = new ItemData[ingredients.length];\n            for (int i = 0; i < ingredients.length; i++) {\n                if (ingredients[i].getOptions().length > 0) {\n                    translatedItems[i] = ItemTranslator.translateToBedrock(session, ingredients[i].getOptions()[0]);\n                } else {\n                    translatedItems[i] = ItemData.AIR;\n                }\n            }\n            return new ItemData[][]{translatedItems};\n        }\n        List<Set<ItemData>> sortedSets = new ArrayList<>(squashedOptions.keySet());\n        sortedSets.sort(Comparator.comparing(Set::size, Comparator.reverseOrder()));\n        ItemData[][] combinations = new ItemData[totalCombinations][ingredients.length];\n        int x = 1;\n        for (Set<ItemData> set : sortedSets) {\n            IntSet slotSet = squashedOptions.get(set);\n            int i = 0;\n            for (ItemData item : set) {\n                for (int j = 0; j < totalCombinations / set.size(); j++) {\n                    final int comboIndex = (i * x) + (j % x) + ((j / x) * set.size() * x);\n                    for (int slot : slotSet) {\n                        combinations[comboIndex][slot] = item;\n                    }\n                }\n                i++;\n            }\n            x *= set.size();\n        }\n        return combinations;\n    }\n\n    @EqualsAndHashCode\n    @AllArgsConstructor\n    private static class GroupedItem {\n        int id;\n        int count;\n        NbtMap tag;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDeclareTagsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerDeclareTagsPacket.class)\npublic class JavaDeclareTagsTranslator extends PacketTranslator<ServerDeclareTagsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerDeclareTagsPacket packet) {\n        session.getTagCache().loadPacket(packet);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDifficultyPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetDifficultyPacket;\n\n@Translator(packet = ServerDifficultyPacket.class)\npublic class JavaDifficultyTranslator extends PacketTranslator<ServerDifficultyPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerDifficultyPacket packet) {\n        SetDifficultyPacket setDifficultyPacket = new SetDifficultyPacket();\n        setDifficultyPacket.setDifficulty(packet.getDifficulty().ordinal());\n        session.sendUpstreamPacket(setDifficultyPacket);\n\n        session.getWorldCache().setDifficulty(packet.getDifficulty());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerDisconnectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerDisconnectPacket.class)\npublic class JavaDisconnectPacket extends PacketTranslator<ServerDisconnectPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerDisconnectPacket packet) {\n        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.HandPreference;\nimport com.github.steveice10.mc.protocol.data.game.setting.ChatVisibility;\nimport com.github.steveice10.mc.protocol.data.game.setting.SkinPart;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientSettingsPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerJoinGamePacket;\nimport com.nukkitx.protocol.bedrock.data.GameRuleData;\nimport com.nukkitx.protocol.bedrock.data.PlayerPermission;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.BiomeTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.PluginMessageUtils;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n@Translator(packet = ServerJoinGamePacket.class)\npublic class JavaJoinGameTranslator extends PacketTranslator<ServerJoinGamePacket> {\n    private static final List<SkinPart> SKIN_PART_VALUES = Arrays.asList(SkinPart.values());\n\n    @Override\n    public void translate(GeyserSession session, ServerJoinGamePacket packet) {\n        PlayerEntity entity = session.getPlayerEntity();\n        entity.setEntityId(packet.getEntityId());\n\n        // If the player is already initialized and a join game packet is sent, they\n        // are swapping servers\n        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());\n        if (session.isSpawned()) {\n            String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);\n            DimensionUtils.switchDimension(session, fakeDim);\n\n            session.getWorldCache().removeScoreboard();\n        }\n        session.setWorldName(packet.getWorldName());\n\n        BiomeTranslator.loadServerBiomes(session, packet.getDimensionCodec());\n        session.getTagCache().clear();\n\n        AdventureSettingsPacket bedrockPacket = new AdventureSettingsPacket();\n        bedrockPacket.setUniqueEntityId(session.getPlayerEntity().getGeyserId());\n        bedrockPacket.setPlayerPermission(PlayerPermission.MEMBER);\n        session.sendUpstreamPacket(bedrockPacket);\n\n        PlayStatusPacket playStatus = new PlayStatusPacket();\n        playStatus.setStatus(PlayStatusPacket.Status.LOGIN_SUCCESS);\n        // session.sendPacket(playStatus);\n\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(packet.getGameMode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n        session.setGameMode(packet.getGameMode());\n\n        SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n        entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n        entityDataPacket.getMetadata().putAll(entity.getMetadata());\n        session.sendUpstreamPacket(entityDataPacket);\n\n        // Send if client should show respawn screen\n        GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();\n        gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\", !packet.isEnableRespawnScreen()));\n        session.sendUpstreamPacket(gamerulePacket);\n\n        session.setReducedDebugInfo(packet.isReducedDebugInfo());\n\n        session.setRenderDistance(packet.getViewDistance());\n\n        // We need to send our skin parts to the server otherwise java sees us with no hat, jacket etc\n        String locale = session.getLocale();\n        ClientSettingsPacket clientSettingsPacket = new ClientSettingsPacket(locale, (byte) session.getRenderDistance(), ChatVisibility.FULL, true, SKIN_PART_VALUES, HandPreference.RIGHT_HAND, false);\n        session.sendDownstreamPacket(clientSettingsPacket);\n\n        session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:brand\", PluginMessageUtils.getGeyserBrandData()));\n\n        // register the plugin messaging channels used in Floodgate\n        if (session.getRemoteAuthType() == AuthType.FLOODGATE) {\n            session.sendDownstreamPacket(new ClientPluginMessagePacket(\"minecraft:register\", PluginMessageUtils.getFloodgateRegisterData()));\n        }\n\n        if (!newDimension.equals(session.getDimension())) {\n            DimensionUtils.switchDimension(session, newDimension);\n        }\n\n        ChunkUtils.applyDimensionHeight(session, packet.getDimension());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerKeepAlivePacket;\nimport com.nukkitx.protocol.bedrock.packet.NetworkStackLatencyPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Used to forward the keep alive packet to the client in order to get back a reliable ping.\n */\n@Translator(packet = ServerKeepAlivePacket.class)\npublic class JavaKeepAliveTranslator extends PacketTranslator<ServerKeepAlivePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerKeepAlivePacket packet) {\n        if (!session.getConnector().getConfig().isForwardPlayerPing()) {\n            return;\n        }\n        NetworkStackLatencyPacket latencyPacket = new NetworkStackLatencyPacket();\n        latencyPacket.setFromServer(true);\n        latencyPacket.setTimestamp(packet.getPingId() * 1000);\n        session.sendUpstreamPacket(latencyPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginDisconnectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = LoginDisconnectPacket.class)\npublic class JavaLoginDisconnectTranslator extends PacketTranslator<LoginDisconnectPacket> {\n\n    @Override\n    public void translate(GeyserSession session, LoginDisconnectPacket packet) {\n        // The client doesn't manually get disconnected so we have to do it ourselves\n        session.disconnect(MessageTranslator.convertMessage(packet.getReason(), session.getLocale()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.login.client.LoginPluginResponsePacket;\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginPluginRequestPacket;\n\n@Translator(packet = LoginPluginRequestPacket.class)\npublic class JavaLoginPluginRequestTranslator extends PacketTranslator<LoginPluginRequestPacket> {\n    @Override\n    public void translate(GeyserSession session, LoginPluginRequestPacket packet) {\n        // A vanilla client doesn't know any PluginMessage in the Login state, so we don't know any either.\n        // Note: Fabric Networking API v1 will not let the client log in without sending this\n        session.sendDownstreamPacket(\n                new LoginPluginResponsePacket(packet.getMessageId(), null)\n        );\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.auth.data.GameProfile;\nimport com.github.steveice10.mc.protocol.packet.login.server.LoginSuccessPacket;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = LoginSuccessPacket.class)\npublic class JavaLoginSuccessTranslator extends PacketTranslator<LoginSuccessPacket> {\n\n    @Override\n    public void translate(GeyserSession session, LoginSuccessPacket packet) {\n        PlayerEntity playerEntity = session.getPlayerEntity();\n        AuthType remoteAuthType = session.getRemoteAuthType();\n\n        // Required, or else Floodgate players break with Spigot chunk caching\n        GameProfile profile = packet.getProfile();\n        playerEntity.setUsername(profile.getName());\n        playerEntity.setUuid(profile.getId());\n\n        // Check if they are not using a linked account\n        if (remoteAuthType == AuthType.OFFLINE || playerEntity.getUuid().getMostSignificantBits() == 0) {\n            SkinManager.handleBedrockSkin(playerEntity, session.getClientData());\n        }\n\n        if (remoteAuthType == AuthType.FLOODGATE) {\n            // We'll send the skin upload a bit after the handshake packet (aka this packet),\n            // because otherwise the global server returns the data too fast.\n            session.getAuthData().upload(session.getConnector());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPongPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPingPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n// Why does this packet exist? Whatever, we better implement it\n@Translator(packet = ServerPingPacket.class)\npublic class JavaPingPacket extends PacketTranslator<ServerPingPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPingPacket packet) {\n        session.sendDownstreamPacket(new ClientPongPacket(packet.getId()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2020 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientPluginMessagePacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPluginMessagePacket;\nimport com.google.common.base.Charsets;\nimport org.geysermc.connector.common.AuthType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.cumulus.Form;\nimport org.geysermc.cumulus.Forms;\nimport org.geysermc.cumulus.util.FormType;\n\nimport java.nio.charset.StandardCharsets;\n\n@Translator(packet = ServerPluginMessagePacket.class)\npublic class JavaPluginMessageTranslator extends PacketTranslator<ServerPluginMessagePacket> {\n    @Override\n    public void translate(GeyserSession session, ServerPluginMessagePacket packet) {\n        // The only plugin messages it has to listen for are Floodgate plugin messages\n        if (session.getRemoteAuthType() != AuthType.FLOODGATE) {\n            return;\n        }\n\n        String channel = packet.getChannel();\n\n        if (channel.equals(\"floodgate:form\")) {\n            byte[] data = packet.getData();\n\n            // receive: first byte is form type, second and third are the id, remaining is the form data\n            // respond: first and second byte id, remaining is form response data\n\n            FormType type = FormType.getByOrdinal(data[0]);\n            if (type == null) {\n                throw new NullPointerException(\n                        \"Got type \" + data[0] + \" which isn't a valid form type!\");\n            }\n\n            String dataString = new String(data, 3, data.length - 3, Charsets.UTF_8);\n\n            Form form = Forms.fromJson(dataString, type);\n            form.setResponseHandler(response -> {\n                byte[] raw = response.getBytes(StandardCharsets.UTF_8);\n                byte[] finalData = new byte[raw.length + 2];\n\n                finalData[0] = data[1];\n                finalData[1] = data[2];\n                System.arraycopy(raw, 0, finalData, 2, raw.length);\n\n                session.sendDownstreamPacket(new ClientPluginMessagePacket(channel, finalData));\n            });\n            session.sendForm(form);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerRespawnPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetPlayerGameTypePacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerRespawnPacket.class)\npublic class JavaRespawnTranslator extends PacketTranslator<ServerRespawnPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerRespawnPacket packet) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        entity.setHealth(entity.getMaxHealth());\n        entity.getAttributes().put(GeyserAttributeType.HEALTH, entity.createHealthAttribute());\n\n        session.setInventoryTranslator(InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR);\n        session.setOpenInventory(null);\n        session.setClosingInventory(false);\n\n        SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n        playerGameTypePacket.setGamemode(packet.getGamemode().ordinal());\n        session.sendUpstreamPacket(playerGameTypePacket);\n        session.setGameMode(packet.getGamemode());\n\n        if (session.isRaining()) {\n            LevelEventPacket stopRainPacket = new LevelEventPacket();\n            stopRainPacket.setType(LevelEventType.STOP_RAINING);\n            stopRainPacket.setData(0);\n            stopRainPacket.setPosition(Vector3f.ZERO);\n            session.sendUpstreamPacket(stopRainPacket);\n            session.setRaining(false);\n        }\n\n        if (session.isThunder()) {\n            LevelEventPacket stopThunderPacket = new LevelEventPacket();\n            stopThunderPacket.setType(LevelEventType.STOP_THUNDERSTORM);\n            stopThunderPacket.setData(0);\n            stopThunderPacket.setPosition(Vector3f.ZERO);\n            session.sendUpstreamPacket(stopThunderPacket);\n            session.setThunder(false);\n        }\n\n        String newDimension = DimensionUtils.getNewDimension(packet.getDimension());\n        if (!session.getDimension().equals(newDimension) || !packet.getWorldName().equals(session.getWorldName())) {\n            // Switching to a new world (based off the world name change); send a fake dimension change\n            if (!packet.getWorldName().equals(session.getWorldName()) && (session.getDimension().equals(newDimension)\n                    // Ensure that the player never ever dimension switches to the same dimension - BAD\n                    // Can likely be removed if the Above Bedrock Nether Building option can be removed\n                    || DimensionUtils.javaToBedrock(session.getDimension()) == DimensionUtils.javaToBedrock(newDimension))) {\n                String fakeDim = DimensionUtils.getTemporaryDimension(session.getDimension(), newDimension);\n                DimensionUtils.switchDimension(session, fakeDim);\n            }\n            session.setWorldName(packet.getWorldName());\n            DimensionUtils.switchDimension(session, newDimension);\n        }\n\n        ChunkUtils.applyDimensionHeight(session, packet.getDimension());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerStatisticsPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.StatisticsUtils;\n\n@Translator(packet = ServerStatisticsPacket.class)\npublic class JavaStatisticsTranslator extends PacketTranslator<ServerStatisticsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerStatisticsPacket packet) {\n        session.updateStatistics(packet.getStatistics());\n\n        if (session.isWaitingForStatistics()) {\n            session.setWaitingForStatistics(false);\n            StatisticsUtils.buildAndSendStatisticsMenu(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java;\n\nimport com.github.steveice10.mc.protocol.data.game.UnlockRecipesAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerUnlockRecipesPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Arrays;\n\n/**\n * Used to list recipes that we can definitely use the recipe book for (and therefore save on packet usage)\n */\n@Translator(packet = ServerUnlockRecipesPacket.class)\npublic class JavaUnlockRecipesTranslator extends PacketTranslator<ServerUnlockRecipesPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUnlockRecipesPacket packet) {\n        if (packet.getAction() == UnlockRecipesAction.REMOVE) {\n            session.getUnlockedRecipes().removeAll(Arrays.asList(packet.getRecipes()));\n        } else {\n            session.getUnlockedRecipes().addAll(Arrays.asList(packet.getRecipes()));\n        }\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAnimationPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.AnimateEntityPacket;\nimport com.nukkitx.protocol.bedrock.packet.AnimatePacket;\nimport com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerEntityAnimationPacket.class)\npublic class JavaEntityAnimationTranslator extends PacketTranslator<ServerEntityAnimationPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityAnimationPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        AnimatePacket animatePacket = new AnimatePacket();\n        animatePacket.setRuntimeEntityId(entity.getGeyserId());\n        switch (packet.getAnimation()) {\n            case SWING_ARM:\n                animatePacket.setAction(AnimatePacket.Action.SWING_ARM);\n                break;\n            case EAT_FOOD: // ACTUALLY SWING OFF HAND\n                // Use the OptionalPack to trigger the animation\n                AnimateEntityPacket offHandPacket = new AnimateEntityPacket();\n                offHandPacket.setAnimation(\"animation.player.attack.rotations.offhand\");\n                offHandPacket.setNextState(\"default\");\n                offHandPacket.setBlendOutTime(0.0f);\n                offHandPacket.setStopExpression(\"query.any_animation_finished\");\n                offHandPacket.setController(\"__runtime_controller\");\n                offHandPacket.getRuntimeEntityIds().add(entity.getGeyserId());\n\n                session.sendUpstreamPacket(offHandPacket);\n                return;\n            case CRITICAL_HIT:\n                animatePacket.setAction(AnimatePacket.Action.CRITICAL_HIT);\n                break;\n            case ENCHANTMENT_CRITICAL_HIT:\n                animatePacket.setAction(AnimatePacket.Action.MAGIC_CRITICAL_HIT); // Unsure if this does anything\n                // Spawn custom particle\n                SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();\n                stringPacket.setIdentifier(\"geyseropt:enchanted_hit_multiple\");\n                stringPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n                stringPacket.setPosition(Vector3f.ZERO);\n                stringPacket.setUniqueEntityId(entity.getGeyserId());\n                session.sendUpstreamPacket(stringPacket);\n                break;\n            case LEAVE_BED:\n                animatePacket.setAction(AnimatePacket.Action.WAKE_UP);\n                break;\n            default:\n                // Unknown Animation\n                return;\n        }\n\n        session.sendUpstreamPacket(animatePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityAttachPacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityFlag;\nimport com.nukkitx.protocol.bedrock.packet.EntityEventPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * Called when a leash is attached, removed or updated from an entity\n */\n@Translator(packet = ServerEntityAttachPacket.class)\npublic class JavaEntityAttachTranslator extends PacketTranslator<ServerEntityAttachPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityAttachPacket packet) {\n\n        Entity holderId;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            holderId = session.getPlayerEntity();\n        } else {\n            holderId = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n            if (holderId == null) {\n                return;\n            }\n        }\n\n        Entity attachedToId;\n        if (packet.getAttachedToId() == session.getPlayerEntity().getEntityId()) {\n            attachedToId = session.getPlayerEntity();\n        } else {\n            attachedToId = session.getEntityCache().getEntityByJavaId(packet.getAttachedToId());\n            if ((attachedToId == null || packet.getAttachedToId() == 0)) {\n                // Is not being leashed\n                holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, false);\n                holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, -1L);\n                holderId.updateBedrockMetadata(session);\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setRuntimeEntityId(holderId.getGeyserId());\n                eventPacket.setType(EntityEventType.REMOVE_LEASH);\n                eventPacket.setData(0);\n                session.sendUpstreamPacket(eventPacket);\n                return;\n            }\n        }\n\n        holderId.getMetadata().getFlags().setFlag(EntityFlag.LEASHED, true);\n        holderId.getMetadata().put(EntityData.LEASH_HOLDER_EID, attachedToId.getGeyserId());\n        holderId.updateBedrockMetadata(session);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityCollectItemPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.TakeItemEntityPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ExpOrbEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n/**\n * This packet is called whenever a player picks up an item.\n * In Java, this is called for item entities, experience orbs and arrows\n * Bedrock uses it for arrows and item entities, but not experience orbs.\n */\n@Translator(packet = ServerEntityCollectItemPacket.class)\npublic class JavaEntityCollectItemTranslator extends PacketTranslator<ServerEntityCollectItemPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityCollectItemPacket packet) {\n        // Collected entity is the other entity\n        Entity collectedEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectedEntityId());\n        if (collectedEntity == null) return;\n        // Collector is the entity 'picking up' the item\n        Entity collectorEntity;\n        if (packet.getCollectorEntityId() == session.getPlayerEntity().getEntityId()) {\n            collectorEntity = session.getPlayerEntity();\n        } else {\n            collectorEntity = session.getEntityCache().getEntityByJavaId(packet.getCollectorEntityId());\n        }\n        if (collectorEntity == null) return;\n        if (collectedEntity instanceof ExpOrbEntity) {\n            // Player just picked up an experience orb\n            LevelEventPacket xpPacket = new LevelEventPacket();\n            xpPacket.setType(LevelEventType.SOUND_EXPERIENCE_ORB_PICKUP);\n            xpPacket.setPosition(collectedEntity.getPosition());\n            xpPacket.setData(0);\n            session.sendUpstreamPacket(xpPacket);\n        } else {\n            // Item is being picked up (visual only)\n            TakeItemEntityPacket takeItemEntityPacket = new TakeItemEntityPacket();\n            takeItemEntityPacket.setRuntimeEntityId(collectorEntity.getGeyserId());\n            takeItemEntityPacket.setItemRuntimeEntityId(collectedEntity.getGeyserId());\n            session.sendUpstreamPacket(takeItemEntityPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEffectPacket;\nimport com.nukkitx.protocol.bedrock.packet.MobEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\n@Translator(packet = ServerEntityEffectPacket.class)\npublic class JavaEntityEffectTranslator extends PacketTranslator<ServerEntityEffectPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityEffectPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n            session.getEffectCache().setEffect(packet.getEffect(), packet.getAmplifier());\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        MobEffectPacket mobEffectPacket = new MobEffectPacket();\n        mobEffectPacket.setAmplifier(packet.getAmplifier());\n        mobEffectPacket.setDuration(packet.getDuration());\n        mobEffectPacket.setEvent(MobEffectPacket.Event.ADD);\n        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());\n        mobEffectPacket.setParticles(packet.isShowParticles());\n        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));\n        session.sendUpstreamPacket(mobEffectPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Equipment;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityEquipmentPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\n\n@Translator(packet = ServerEntityEquipmentPacket.class)\npublic class JavaEntityEquipmentTranslator extends PacketTranslator<ServerEntityEquipmentPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityEquipmentPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n\n        if (entity == null)\n            return;\n\n        if (!(entity instanceof LivingEntity)) {\n            session.getConnector().getLogger().debug(\"Attempted to add armor to a non-living entity type (\" +\n                    entity.getEntityType().name() + \").\");\n            return;\n        }\n\n        boolean armorUpdated = false;\n        boolean mainHandUpdated = false;\n        boolean offHandUpdated = false;\n        LivingEntity livingEntity = (LivingEntity) entity;\n        for (Equipment equipment : packet.getEquipment()) {\n            ItemData item = ItemTranslator.translateToBedrock(session, equipment.getItem());\n            switch (equipment.getSlot()) {\n                case HELMET:\n                    livingEntity.setHelmet(item);\n                    armorUpdated = true;\n                    break;\n                case CHESTPLATE:\n                    livingEntity.setChestplate(item);\n                    armorUpdated = true;\n                    break;\n                case LEGGINGS:\n                    livingEntity.setLeggings(item);\n                    armorUpdated = true;\n                    break;\n                case BOOTS:\n                    livingEntity.setBoots(item);\n                    armorUpdated = true;\n                    break;\n                case MAIN_HAND:\n                    livingEntity.setHand(item);\n                    mainHandUpdated = true;\n                    break;\n                case OFF_HAND:\n                    livingEntity.setOffHand(item);\n                    offHandUpdated = true;\n                    break;\n            }\n        }\n\n        if (armorUpdated) {\n            livingEntity.updateArmor(session);\n        }\n        if (mainHandUpdated) {\n            livingEntity.updateMainHand(session);\n        }\n        if (offHandUpdated) {\n            livingEntity.updateOffHand(session);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityHeadLookPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityHeadLookPacket.class)\npublic class JavaEntityHeadLookTranslator extends PacketTranslator<ServerEntityHeadLookPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityHeadLookPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n\n        if (entity == null) return;\n\n        entity.updateHeadLookRotation(session, packet.getHeadYaw());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.EntityMetadata;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityMetadataPacket;\nimport org.geysermc.connector.utils.InteractiveTagManager;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerEntityMetadataPacket.class)\npublic class JavaEntityMetadataTranslator extends PacketTranslator<ServerEntityMetadataPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityMetadataPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null) return;\n\n        for (EntityMetadata metadata : packet.getMetadata()) {\n            try {\n                entity.updateBedrockMetadata(metadata, session);\n            } catch (ClassCastException e) {\n                // Class cast exceptions are really the only ones we're going to get in normal gameplay\n                // Because some entity rewriters forget about some values\n                // Any other errors are actual bugs\n                session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.metadata.failed\", metadata, entity.getEntityType()));\n                session.getConnector().getLogger().debug(\"Entity Java ID: \" + entity.getEntityId() + \", Geyser ID: \" + entity.getGeyserId());\n                if (session.getConnector().getConfig().isDebugMode()) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        entity.updateBedrockMetadata(session);\n\n        // Update the interactive tag, if necessary\n        if (session.getMouseoverEntity() != null && session.getMouseoverEntity().getEntityId() == entity.getEntityId()) {\n            InteractiveTagManager.updateTag(session, entity);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionRotationPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPositionRotationPacket.class)\npublic class JavaEntityPositionRotationTranslator extends PacketTranslator<ServerEntityPositionRotationPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityPositionRotationPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.updatePositionAndRotation(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPositionPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPositionPacket.class)\npublic class JavaEntityPositionTranslator extends PacketTranslator<ServerEntityPositionPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityPositionPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.moveRelative(session, packet.getMoveX(), packet.getMoveY(), packet.getMoveZ(), entity.getRotation(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityPropertiesPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityPropertiesPacket.class)\npublic class JavaEntityPropertiesTranslator extends PacketTranslator<ServerEntityPropertiesPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityPropertiesPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (!(entity instanceof LivingEntity)) return;\n\n        ((LivingEntity) entity).updateBedrockAttributes(session, packet.getAttributes());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRemoveEffectPacket;\nimport com.nukkitx.protocol.bedrock.packet.MobEffectPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\n@Translator(packet = ServerEntityRemoveEffectPacket.class)\npublic class JavaEntityRemoveEffectTranslator extends PacketTranslator<ServerEntityRemoveEffectPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityRemoveEffectPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n            session.getEffectCache().removeEffect(packet.getEffect());\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        MobEffectPacket mobEffectPacket = new MobEffectPacket();\n        mobEffectPacket.setEvent(MobEffectPacket.Event.REMOVE);\n        mobEffectPacket.setRuntimeEntityId(entity.getGeyserId());\n        mobEffectPacket.setEffectId(EntityUtils.toBedrockEffectId(packet.getEffect()));\n        session.sendUpstreamPacket(mobEffectPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityRotationPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityRotationPacket.class)\npublic class JavaEntityRotationTranslator extends PacketTranslator<ServerEntityRotationPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityRotationPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.updateRotation(session, packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntitySetPassengersPacket;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;\nimport it.unimi.dsi.fastutil.longs.LongOpenHashSet;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\n\nimport java.util.Arrays;\n\n@Translator(packet = ServerEntitySetPassengersPacket.class)\npublic class JavaEntitySetPassengersTranslator extends PacketTranslator<ServerEntitySetPassengersPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntitySetPassengersPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n\n        if (entity == null) return;\n\n        LongOpenHashSet passengers = entity.getPassengers().clone();\n        boolean rider = true;\n        for (long passengerId : packet.getPassengerIds()) {\n            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);\n            if (passengerId == session.getPlayerEntity().getEntityId()) {\n                passenger = session.getPlayerEntity();\n                session.setRidingVehicleEntity(entity);\n                // We need to confirm teleports before entering a vehicle, or else we will likely exit right out\n                session.confirmTeleport(passenger.getPosition().sub(0, EntityType.PLAYER.getOffset(), 0).toDouble());\n            }\n            // Passenger hasn't loaded in (likely since we're waiting for a skin response)\n            // and entity link needs to be set later\n            if (passenger == null && passengerId != 0) {\n                session.getEntityCache().addCachedPlayerEntityLink(passengerId, packet.getEntityId());\n            }\n            if (passenger == null) {\n                continue;\n            }\n\n            EntityLinkData.Type type = rider ? EntityLinkData.Type.RIDER : EntityLinkData.Type.PASSENGER;\n            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n            linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), type, false));\n            session.sendUpstreamPacket(linkPacket);\n            passengers.add(passengerId);\n\n            // Head rotation on boats\n            if (entity.getEntityType() == EntityType.BOAT) {\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 1);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 90f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 1f);\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, -90f);\n            } else {\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n            }\n\n            passenger.updateBedrockMetadata(session);\n            rider = false;\n        }\n\n        entity.setPassengers(passengers);\n\n        for (long passengerId : entity.getPassengers()) {\n            Entity passenger = session.getEntityCache().getEntityByJavaId(passengerId);\n            if (passengerId == session.getPlayerEntity().getEntityId()) {\n                passenger = session.getPlayerEntity();\n            }\n            if (passenger == null) {\n                continue;\n            }\n            if (Arrays.stream(packet.getPassengerIds()).noneMatch(id -> id == passengerId)) {\n                SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n                linkPacket.setEntityLink(new EntityLinkData(entity.getGeyserId(), passenger.getGeyserId(), EntityLinkData.Type.REMOVE, false));\n                session.sendUpstreamPacket(linkPacket);\n                passengers.remove(passenger.getEntityId());\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n                passenger.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n                passenger.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);\n\n                EntityUtils.updateMountOffset(passenger, entity, session, false, false, (packet.getPassengerIds().length > 1));\n            } else {\n                EntityUtils.updateMountOffset(passenger, entity, session, (packet.getPassengerIds()[0] == passengerId), true, (packet.getPassengerIds().length > 1));\n            }\n\n            // Force an update to the passenger metadata\n            passenger.updateBedrockMetadata(session);\n        }\n\n        switch (entity.getEntityType()) {\n            case HORSE:\n            case SKELETON_HORSE:\n            case DONKEY:\n            case MULE:\n            case RAVAGER:\n                entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 181.0f);\n                entity.updateBedrockMetadata(session);\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityStatusPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.LivingEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerEntityStatusPacket.class)\npublic class JavaEntityStatusTranslator extends PacketTranslator<ServerEntityStatusPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityStatusPacket packet) {\n        Entity entity;\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        } else {\n            entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        }\n        if (entity == null)\n            return;\n\n        EntityEventPacket entityEventPacket = new EntityEventPacket();\n        entityEventPacket.setRuntimeEntityId(entity.getGeyserId());\n        switch (packet.getStatus()) {\n            case PLAYER_ENABLE_REDUCED_DEBUG:\n                session.setReducedDebugInfo(true);\n                return;\n            case PLAYER_DISABLE_REDUCED_DEBUG:\n                session.setReducedDebugInfo(false);\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_0:\n                session.setOpPermissionLevel(0);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_1:\n                session.setOpPermissionLevel(1);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_2:\n                session.setOpPermissionLevel(2);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_3:\n                session.setOpPermissionLevel(3);\n                session.sendAdventureSettings();\n                return;\n            case PLAYER_OP_PERMISSION_LEVEL_4:\n                session.setOpPermissionLevel(4);\n                session.sendAdventureSettings();\n                return;\n\n            // EntityEventType.HURT sends extra data depending on the type of damage. However this appears to have no visual changes\n            case LIVING_BURN:\n            case LIVING_DROWN:\n            case LIVING_HURT:\n            case LIVING_HURT_SWEET_BERRY_BUSH:\n            case LIVING_HURT_THORNS:\n            case LIVING_FREEZE:\n                entityEventPacket.setType(EntityEventType.HURT);\n                break;\n            case LIVING_DEATH:\n                entityEventPacket.setType(EntityEventType.DEATH);\n                if (entity.getEntityType() == EntityType.THROWN_EGG) {\n                    LevelEventPacket particlePacket = new LevelEventPacket();\n                    particlePacket.setType(LevelEventType.PARTICLE_ITEM_BREAK);\n                    particlePacket.setData(session.getItemMappings().getStoredItems().egg().getBedrockId() << 16);\n                    particlePacket.setPosition(entity.getPosition());\n                    for (int i = 0; i < 6; i++) {\n                        session.sendUpstreamPacket(particlePacket);\n                    }\n                } else if (entity.getEntityType() == EntityType.SNOWBALL) {\n                    LevelEventPacket particlePacket = new LevelEventPacket();\n                    particlePacket.setType(LevelEventType.PARTICLE_SNOWBALL_POOF);\n                    particlePacket.setPosition(entity.getPosition());\n                    for (int i = 0; i < 8; i++) {\n                        session.sendUpstreamPacket(particlePacket);\n                    }\n                }\n                break;\n            case WOLF_SHAKE_WATER:\n                entityEventPacket.setType(EntityEventType.SHAKE_WETNESS);\n                break;\n            case PLAYER_FINISH_USING_ITEM:\n                entityEventPacket.setType(EntityEventType.USE_ITEM);\n                break;\n            case FISHING_HOOK_PULL_PLAYER:\n                // Player is pulled from a fishing rod\n                // The physics of this are clientside on Java\n                long pulledById = entity.getMetadata().getLong(EntityData.TARGET_EID);\n                if (session.getPlayerEntity().getGeyserId() == pulledById) {\n                    Entity hookOwner = session.getEntityCache().getEntityByGeyserId(entity.getMetadata().getLong(EntityData.OWNER_EID));\n                    if (hookOwner != null) {\n                        // https://minecraft.gamepedia.com/Fishing_Rod#Hooking_mobs_and_other_entities\n                        SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();\n                        motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n                        motionPacket.setMotion(hookOwner.getPosition().sub(session.getPlayerEntity().getPosition()).mul(0.1f));\n                        session.sendUpstreamPacket(motionPacket);\n                    }\n                }\n                return;\n            case TAMEABLE_TAMING_FAILED:\n                entityEventPacket.setType(EntityEventType.TAME_FAILED);\n                break;\n            case TAMEABLE_TAMING_SUCCEEDED:\n                entityEventPacket.setType(EntityEventType.TAME_SUCCEEDED);\n                break;\n            case ZOMBIE_VILLAGER_CURE: // Played when a zombie bites the golden apple\n                LevelSoundEvent2Packet soundPacket = new LevelSoundEvent2Packet();\n                soundPacket.setSound(SoundEvent.REMEDY);\n                soundPacket.setPosition(entity.getPosition());\n                soundPacket.setExtraData(-1);\n                soundPacket.setIdentifier(\"\");\n                soundPacket.setRelativeVolumeDisabled(false);\n                session.sendUpstreamPacket(soundPacket);\n                return;\n            case ANIMAL_EMIT_HEARTS:\n                entityEventPacket.setType(EntityEventType.LOVE_PARTICLES);\n                break;\n            case FIREWORK_EXPLODE:\n                entityEventPacket.setType(EntityEventType.FIREWORK_EXPLODE);\n                break;\n            case WITCH_EMIT_PARTICLES:\n                entityEventPacket.setType(EntityEventType.WITCH_HAT_MAGIC); //TODO: CHECK\n                break;\n            case TOTEM_OF_UNDYING_MAKE_SOUND:\n                entityEventPacket.setType(EntityEventType.CONSUME_TOTEM);\n                break;\n            case SHEEP_GRAZE_OR_TNT_CART_EXPLODE:\n                if (entity.getEntityType() == EntityType.SHEEP) {\n                    entityEventPacket.setType(EntityEventType.EAT_GRASS);\n                } else {\n                    entityEventPacket.setType(EntityEventType.PRIME_TNT_MINECART);\n                }\n                break;\n            case IRON_GOLEM_HOLD_POPPY:\n                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_OFFER);\n                break;\n            case IRON_GOLEM_EMPTY_HAND:\n                entityEventPacket.setType(EntityEventType.GOLEM_FLOWER_WITHDRAW);\n                break;\n            case IRON_GOLEM_ATTACK:\n                if (entity.getEntityType() == EntityType.IRON_GOLEM) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_START);\n                }\n                break;\n            case RABBIT_JUMP_OR_MINECART_SPAWNER_DELAY_RESET:\n                if (entity.getEntityType() == EntityType.RABBIT) {\n                    // This doesn't match vanilla Bedrock behavior but I'm unsure how to make it better\n                    // I assume part of the problem is that Bedrock uses a duration and Java just says the rabbit is jumping\n                    SetEntityDataPacket dataPacket = new SetEntityDataPacket();\n                    dataPacket.getMetadata().put(EntityData.JUMP_DURATION, (byte) 3);\n                    dataPacket.setRuntimeEntityId(entity.getGeyserId());\n                    session.sendUpstreamPacket(dataPacket);\n                    return;\n                }\n                break;\n            case LIVING_EQUIPMENT_BREAK_HEAD:\n            case LIVING_EQUIPMENT_BREAK_CHEST:\n            case LIVING_EQUIPMENT_BREAK_LEGS:\n            case LIVING_EQUIPMENT_BREAK_FEET:\n            case LIVING_EQUIPMENT_BREAK_MAIN_HAND:\n            case LIVING_EQUIPMENT_BREAK_OFF_HAND:\n                LevelSoundEvent2Packet equipmentBreakPacket = new LevelSoundEvent2Packet();\n                equipmentBreakPacket.setSound(SoundEvent.BREAK);\n                equipmentBreakPacket.setPosition(entity.getPosition());\n                equipmentBreakPacket.setExtraData(-1);\n                equipmentBreakPacket.setIdentifier(\"\");\n                session.sendUpstreamPacket(equipmentBreakPacket);\n                return;\n            case PLAYER_SWAP_SAME_ITEM: // Not just used for players\n                if (entity instanceof LivingEntity) {\n                    LivingEntity livingEntity = (LivingEntity) entity;\n                    ItemData newMainHand = livingEntity.getOffHand();\n                    livingEntity.setOffHand(livingEntity.getHand());\n                    livingEntity.setHand(newMainHand);\n\n                    livingEntity.updateMainHand(session);\n                    livingEntity.updateOffHand(session);\n                } else {\n                    session.getConnector().getLogger().debug(\"Got status message to swap hands for a non-living entity.\");\n                }\n                return;\n            case GOAT_LOWERING_HEAD:\n                if (entity.getEntityType() == EntityType.GOAT) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_START);\n                }\n                break;\n            case GOAT_STOP_LOWERING_HEAD:\n                if (entity.getEntityType() == EntityType.GOAT) {\n                    entityEventPacket.setType(EntityEventType.ATTACK_STOP);\n                }\n                break;\n            case MAKE_POOF_PARTICLES:\n                if (entity instanceof LivingEntity) {\n                    entityEventPacket.setType(EntityEventType.DEATH_SMOKE_CLOUD);\n                }\n                break;\n        }\n\n        if (entityEventPacket.getType() != null) {\n            session.sendUpstreamPacket(entityEventPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityTeleportPacket;\nimport com.nukkitx.math.vector.Vector3f;\n\n@Translator(packet = ServerEntityTeleportPacket.class)\npublic class JavaEntityTeleportTranslator extends PacketTranslator<ServerEntityTeleportPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityTeleportPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.teleport(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), packet.isOnGround());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ItemEntity;\nimport org.geysermc.connector.entity.living.animal.horse.AbstractHorseEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerEntityVelocityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;\n\n@Translator(packet = ServerEntityVelocityPacket.class)\npublic class JavaEntityVelocityTranslator extends PacketTranslator<ServerEntityVelocityPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerEntityVelocityPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (packet.getEntityId() == session.getPlayerEntity().getEntityId()) {\n            entity = session.getPlayerEntity();\n        }\n        if (entity == null) return;\n\n        entity.setMotion(Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ()));\n\n        if (entity == session.getRidingVehicleEntity() && entity instanceof AbstractHorseEntity) {\n            // Horses for some reason teleport back when a SetEntityMotionPacket is sent while\n            // a player is riding on them. Java clients seem to ignore it anyways.\n            return;\n        }\n\n        if (entity instanceof ItemEntity) {\n            // Don't bother sending entity motion packets for items\n            // since the client doesn't seem to care\n            return;\n        }\n\n        SetEntityMotionPacket entityMotionPacket = new SetEntityMotionPacket();\n        entityMotionPacket.setRuntimeEntityId(entity.getGeyserId());\n        entityMotionPacket.setMotion(entity.getMotion());\n\n        session.sendUpstreamPacket(entityMotionPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerRemoveEntitiesPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerRemoveEntitiesPacket.class)\npublic class JavaRemoveEntitiesTranslator extends PacketTranslator<ServerRemoveEntitiesPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerRemoveEntitiesPacket packet) {\n        for (int entityId : packet.getEntityIds()) {\n            Entity entity = session.getEntityCache().getEntityByJavaId(entityId);\n            if (entity != null) {\n                session.getEntityCache().removeEntity(entity, false);\n            }\n        }\n    }\n}\n\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerAbilitiesPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerPlayerAbilitiesPacket.class)\npublic class JavaPlayerAbilitiesTranslator extends PacketTranslator<ServerPlayerAbilitiesPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerAbilitiesPacket packet) {\n        session.setCanFly(packet.isCanFly());\n        session.setFlying(packet.isFlying());\n        session.sendAdventureSettings();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PlayerAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerActionAckPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerPlayerActionAckPacket.class)\npublic class JavaPlayerActionAckTranslator extends PacketTranslator<ServerPlayerActionAckPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerActionAckPacket packet) {\n        ChunkUtils.updateBlock(session, packet.getNewState(), packet.getPosition());\n        if (packet.getAction() == PlayerAction.START_DIGGING && !packet.isSuccessful()) {\n            LevelEventPacket stopBreak = new LevelEventPacket();\n            stopBreak.setType(LevelEventType.BLOCK_STOP_BREAK);\n            stopBreak.setPosition(Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n            stopBreak.setData(0);\n            session.setBreakingBlock(BlockStateValues.JAVA_AIR_ID);\n            session.sendUpstreamPacket(stopBreak);\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerChangeHeldItemPacket;\nimport com.nukkitx.protocol.bedrock.packet.PlayerHotbarPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerPlayerChangeHeldItemPacket.class)\npublic class JavaPlayerChangeHeldItemTranslator extends PacketTranslator<ServerPlayerChangeHeldItemPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerChangeHeldItemPacket packet) {\n        PlayerHotbarPacket hotbarPacket = new PlayerHotbarPacket();\n        hotbarPacket.setContainerId(0);\n        hotbarPacket.setSelectedHotbarSlot(packet.getSlot());\n        hotbarPacket.setSelectHotbarSlot(true);\n        session.sendUpstreamPacket(hotbarPacket);\n\n        session.getPlayerInventory().setHeldItemSlot(packet.getSlot());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerHealthPacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.SetHealthPacket;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.List;\n\n@Translator(packet = ServerPlayerHealthPacket.class)\npublic class JavaPlayerHealthTranslator extends PacketTranslator<ServerPlayerHealthPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerHealthPacket packet) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        int health = (int) Math.ceil(packet.getHealth());\n        SetHealthPacket setHealthPacket = new SetHealthPacket();\n        setHealthPacket.setHealth(health);\n        session.sendUpstreamPacket(setHealthPacket);\n\n        entity.setHealth(packet.getHealth());\n\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        List<AttributeData> attributes = attributesPacket.getAttributes();\n\n        AttributeData healthAttribute = entity.createHealthAttribute();\n        entity.getAttributes().put(GeyserAttributeType.HEALTH, healthAttribute);\n        attributes.add(healthAttribute);\n\n        AttributeData hungerAttribute = GeyserAttributeType.HUNGER.getAttribute(packet.getFood());\n        entity.getAttributes().put(GeyserAttributeType.HUNGER, hungerAttribute);\n        attributes.add(hungerAttribute);\n\n        AttributeData saturationAttribute = GeyserAttributeType.SATURATION.getAttribute(packet.getSaturation());\n        entity.getAttributes().put(GeyserAttributeType.SATURATION, saturationAttribute);\n        attributes.add(saturationAttribute);\n\n        attributesPacket.setRuntimeEntityId(entity.getGeyserId());\n        session.sendUpstreamPacket(attributesPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.PlayerListEntry;\nimport com.github.steveice10.mc.protocol.data.game.PlayerListEntryAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerPlayerListEntryPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.PlayerListPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = ServerPlayerListEntryPacket.class)\npublic class JavaPlayerListEntryTranslator extends PacketTranslator<ServerPlayerListEntryPacket> {\n    @Override\n    public void translate(GeyserSession session, ServerPlayerListEntryPacket packet) {\n        if (packet.getAction() != PlayerListEntryAction.ADD_PLAYER && packet.getAction() != PlayerListEntryAction.REMOVE_PLAYER)\n            return;\n\n        PlayerListPacket translate = new PlayerListPacket();\n        translate.setAction(packet.getAction() == PlayerListEntryAction.ADD_PLAYER ? PlayerListPacket.Action.ADD : PlayerListPacket.Action.REMOVE);\n\n        for (PlayerListEntry entry : packet.getEntries()) {\n            switch (packet.getAction()) {\n                case ADD_PLAYER:\n                    PlayerEntity playerEntity;\n                    boolean self = entry.getProfile().getId().equals(session.getPlayerEntity().getUuid());\n\n                    if (self) {\n                        // Entity is ourself\n                        playerEntity = session.getPlayerEntity();\n                    } else {\n                        playerEntity = session.getEntityCache().getPlayerEntity(entry.getProfile().getId());\n                    }\n\n                    if (playerEntity == null) {\n                        // It's a new player\n                        playerEntity = new PlayerEntity(\n                                entry.getProfile(),\n                                -1,\n                                session.getEntityCache().getNextEntityId().incrementAndGet(),\n                                Vector3f.ZERO,\n                                Vector3f.ZERO,\n                                Vector3f.ZERO\n                        );\n\n                        session.getEntityCache().addPlayerEntity(playerEntity);\n                    } else {\n                        playerEntity.setProfile(entry.getProfile());\n                    }\n\n                    playerEntity.setPlayerList(true);\n\n                    // We'll send our own PlayerListEntry in requestAndHandleSkinAndCape\n                    // But we need to send other player's entries so they show up in the player list\n                    // without processing their skin information - that'll be processed when they spawn in\n                    if (self) {\n                        SkinManager.requestAndHandleSkinAndCape(playerEntity, session, skinAndCape ->\n                                GeyserConnector.getInstance().getLogger().debug(\"Loaded Local Bedrock Java Skin Data for \" + session.getClientData().getUsername()));\n                    } else {\n                        playerEntity.setValid(true);\n                        PlayerListPacket.Entry playerListEntry = SkinManager.buildCachedEntry(session, playerEntity);\n\n                        translate.getEntries().add(playerListEntry);\n                    }\n                    break;\n                case REMOVE_PLAYER:\n                    // As the player entity is no longer present, we can remove the entry\n                    PlayerEntity entity = session.getEntityCache().removePlayerEntity(entry.getProfile().getId());\n                    if (entity != null) {\n                        // Just remove the entity's player list status\n                        // Don't despawn the entity - the Java server will also take care of that.\n                        entity.setPlayerList(false);\n                    }\n                    if (entity == session.getPlayerEntity()) {\n                        // If removing ourself we use our AuthData UUID\n                        translate.getEntries().add(new PlayerListPacket.Entry(session.getAuthData().getUUID()));\n                    } else {\n                        translate.getEntries().add(new PlayerListPacket.Entry(entry.getProfile().getId()));\n                    }\n                    break;\n            }\n        }\n\n        if (!translate.getEntries().isEmpty() && (packet.getAction() == PlayerListEntryAction.REMOVE_PLAYER || session.getUpstream().isInitialized())) {\n            session.sendUpstreamPacket(translate);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.PositionElement;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.world.ClientTeleportConfirmPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerPositionRotationPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityLinkData;\nimport com.nukkitx.protocol.bedrock.packet.MovePlayerPacket;\nimport com.nukkitx.protocol.bedrock.packet.RespawnPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityLinkPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.TeleportCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerPlayerPositionRotationPacket.class)\npublic class JavaPlayerPositionRotationTranslator extends PacketTranslator<ServerPlayerPositionRotationPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerPositionRotationPacket packet) {\n        if (!session.isLoggedIn())\n            return;\n\n        PlayerEntity entity = session.getPlayerEntity();\n\n        if (!session.isSpawned()) {\n            Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n            entity.setPosition(pos);\n            entity.setRotation(Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw()));\n\n            RespawnPacket respawnPacket = new RespawnPacket();\n            respawnPacket.setRuntimeEntityId(0); // Bedrock server behavior\n            respawnPacket.setPosition(entity.getPosition());\n            respawnPacket.setState(RespawnPacket.State.SERVER_READY);\n            session.sendUpstreamPacket(respawnPacket);\n\n            SetEntityDataPacket entityDataPacket = new SetEntityDataPacket();\n            entityDataPacket.setRuntimeEntityId(entity.getGeyserId());\n            entityDataPacket.getMetadata().putAll(entity.getMetadata());\n            session.sendUpstreamPacket(entityDataPacket);\n\n            MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n            movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n            movePlayerPacket.setPosition(entity.getPosition());\n            movePlayerPacket.setRotation(Vector3f.from(packet.getPitch(), packet.getYaw(), 0));\n            movePlayerPacket.setMode(MovePlayerPacket.Mode.RESPAWN);\n\n            session.sendUpstreamPacket(movePlayerPacket);\n            session.setSpawned(true);\n\n            ClientTeleportConfirmPacket teleportConfirmPacket = new ClientTeleportConfirmPacket(packet.getTeleportId());\n            session.sendDownstreamPacket(teleportConfirmPacket);\n\n            ChunkUtils.updateChunkPosition(session, pos.toInt());\n\n            session.getConnector().getLogger().debug(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.spawn\", packet.getX(), packet.getY(), packet.getZ()));\n            return;\n        }\n\n        session.setSpawned(true);\n\n        if (packet.isDismountVehicle() && session.getRidingVehicleEntity() != null) {\n            Entity vehicle = session.getRidingVehicleEntity();\n            SetEntityLinkPacket linkPacket = new SetEntityLinkPacket();\n            linkPacket.setEntityLink(new EntityLinkData(vehicle.getGeyserId(), entity.getGeyserId(), EntityLinkData.Type.REMOVE, false, false));\n            session.sendUpstreamPacket(linkPacket);\n            vehicle.getPassengers().remove(entity.getEntityId());\n            entity.getMetadata().put(EntityData.RIDER_ROTATION_LOCKED, (byte) 0);\n            entity.getMetadata().put(EntityData.RIDER_MAX_ROTATION, 0f);\n            entity.getMetadata().put(EntityData.RIDER_MIN_ROTATION, 0f);\n            entity.getMetadata().put(EntityData.RIDER_ROTATION_OFFSET, 0f);\n            session.setRidingVehicleEntity(null);\n            entity.updateBedrockMetadata(session);\n\n            EntityUtils.updateMountOffset(entity, vehicle, session, false, false, entity.getPassengers().size() > 1);\n        }\n\n        // If coordinates are relative, then add to the existing coordinate\n        double newX = packet.getX() +\n                (packet.getRelative().contains(PositionElement.X) ? entity.getPosition().getX() : 0);\n        double newY = packet.getY() +\n                (packet.getRelative().contains(PositionElement.Y) ? entity.getPosition().getY() - EntityType.PLAYER.getOffset() : 0);\n        double newZ = packet.getZ() +\n                (packet.getRelative().contains(PositionElement.Z) ? entity.getPosition().getZ() : 0);\n\n        float newPitch = packet.getPitch() +\n                (packet.getRelative().contains(PositionElement.PITCH) ? entity.getBedrockRotation().getX() : 0);\n        float newYaw = packet.getYaw() +\n                (packet.getRelative().contains(PositionElement.YAW) ? entity.getBedrockRotation().getY() : 0);\n\n        session.getConnector().getLogger().debug(\"Teleport from \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());\n\n        session.addTeleport(new TeleportCache(newX, newY, newZ, newPitch, newYaw, packet.getTeleportId()));\n\n        Vector3f lastPlayerPosition = entity.getPosition().down(EntityType.PLAYER.getOffset());\n        float lastPlayerPitch = entity.getBedrockRotation().getX();\n        Vector3f teleportDestination = Vector3f.from(newX, newY, newZ);\n        entity.moveAbsolute(session, teleportDestination, newYaw, newPitch, true, true);\n\n        session.getConnector().getLogger().debug(\"to \" + entity.getPosition().getX() + \" \" + (entity.getPosition().getY() - EntityType.PLAYER.getOffset()) + \" \" + entity.getPosition().getZ());\n\n        // Bedrock ignores teleports that are extremely close to the player's original position and orientation,\n        // so check if we can immediately confirm the teleport\n        if (lastPlayerPosition.distanceSquared(teleportDestination) < 0.001 && Math.abs(newPitch - lastPlayerPitch) < 5) {\n            session.confirmTeleport(lastPlayerPosition.toDouble());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.player;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.player.ServerPlayerSetExperiencePacket;\nimport com.nukkitx.protocol.bedrock.data.AttributeData;\nimport com.nukkitx.protocol.bedrock.packet.UpdateAttributesPacket;\nimport org.geysermc.connector.entity.attribute.GeyserAttributeType;\nimport org.geysermc.connector.entity.player.SessionPlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Arrays;\n\n@Translator(packet = ServerPlayerSetExperiencePacket.class)\npublic class JavaPlayerSetExperienceTranslator extends PacketTranslator<ServerPlayerSetExperiencePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayerSetExperiencePacket packet) {\n        SessionPlayerEntity entity = session.getPlayerEntity();\n\n        AttributeData experience = GeyserAttributeType.EXPERIENCE.getAttribute(packet.getExperience());\n        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE, experience);\n        AttributeData experienceLevel = GeyserAttributeType.EXPERIENCE_LEVEL.getAttribute(packet.getLevel());\n        entity.getAttributes().put(GeyserAttributeType.EXPERIENCE_LEVEL, experienceLevel);\n\n        UpdateAttributesPacket attributesPacket = new UpdateAttributesPacket();\n        attributesPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n        attributesPacket.setAttributes(Arrays.asList(experience, experienceLevel));\n        session.sendUpstreamPacket(attributesPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.object.FallingBlockData;\nimport com.github.steveice10.mc.protocol.data.game.entity.object.HangingDirection;\nimport com.github.steveice10.mc.protocol.data.game.entity.object.ProjectileData;\nimport com.github.steveice10.mc.protocol.data.game.entity.type.EntityType;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnEntityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.*;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n@Translator(packet = ServerSpawnEntityPacket.class)\npublic class JavaSpawnEntityTranslator extends PacketTranslator<ServerSpawnEntityPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnEntityPacket packet) {\n\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), 0);\n\n        org.geysermc.connector.entity.type.EntityType type = EntityUtils.toBedrockEntity(packet.getType());\n        if (type == null) {\n            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));\n            return;\n        }\n\n        Class<? extends Entity> entityClass = type.getEntityClass();\n        try {\n            Entity entity;\n            if (packet.getType() == EntityType.FALLING_BLOCK) {\n                entity = new FallingBlockEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation, ((FallingBlockData) packet.getData()).getId());\n            } else if (packet.getType() == EntityType.ITEM_FRAME || packet.getType() == EntityType.GLOW_ITEM_FRAME) {\n                // Item frames need the hanging direction\n                entity = new ItemFrameEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation, (HangingDirection) packet.getData());\n            } else if (packet.getType() == EntityType.FISHING_BOBBER) {\n                // Fishing bobbers need the owner for the line\n                int ownerEntityId = ((ProjectileData) packet.getData()).getOwnerId();\n                Entity owner = session.getEntityCache().getEntityByJavaId(ownerEntityId);\n                if (owner == null && session.getPlayerEntity().getEntityId() == ownerEntityId) {\n                    owner = session.getPlayerEntity();\n                }\n                // Java clients only spawn fishing hooks with a player as its owner\n                if (owner instanceof PlayerEntity) {\n                    entity = new FishingHookEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                            type, position, motion, rotation, (PlayerEntity) owner);\n                } else {\n                    return;\n                }\n            } else if (packet.getType() == EntityType.BOAT) {\n                // Initial rotation is incorrect\n                entity = new BoatEntity(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, Vector3f.from(packet.getYaw(), 0, packet.getYaw()));\n            } else {\n                Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, org.geysermc.connector.entity.type.EntityType.class,\n                        Vector3f.class, Vector3f.class, Vector3f.class);\n\n                entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                        type, position, motion, rotation\n                );\n            }\n            session.getEntityCache().spawnEntity(entity);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.ExpOrbEntity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnExpOrbPacket;\nimport com.nukkitx.math.vector.Vector3f;\n\n@Translator(packet = ServerSpawnExpOrbPacket.class)\npublic class JavaSpawnExpOrbTranslator extends PacketTranslator<ServerSpawnExpOrbPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnExpOrbPacket packet) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n\n        Entity entity = new ExpOrbEntity(\n                packet.getExp(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                EntityType.EXPERIENCE_ORB, position, Vector3f.ZERO, Vector3f.ZERO\n        );\n\n        session.getEntityCache().spawnEntity(entity);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnLivingEntityPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.type.EntityType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.EntityUtils;\nimport org.geysermc.connector.utils.LanguageUtils;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n@Translator(packet = ServerSpawnLivingEntityPacket.class)\npublic class JavaSpawnLivingEntityTranslator extends PacketTranslator<ServerSpawnLivingEntityPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnLivingEntityPacket packet) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f motion = Vector3f.from(packet.getMotionX(), packet.getMotionY(), packet.getMotionZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getHeadYaw());\n\n        EntityType type = EntityUtils.toBedrockEntity(packet.getType());\n        if (type == null) {\n            session.getConnector().getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.entity.type_null\", packet.getType()));\n            return;\n        }\n\n        Class<? extends Entity> entityClass = type.getEntityClass();\n        try {\n            Constructor<? extends Entity> entityConstructor = entityClass.getConstructor(long.class, long.class, EntityType.class,\n                    Vector3f.class, Vector3f.class, Vector3f.class);\n\n            Entity entity = entityConstructor.newInstance(packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(),\n                    type, position, motion, rotation\n            );\n            session.getEntityCache().spawnEntity(entity);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPaintingPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.PaintingEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.PaintingType;\n\n@Translator(packet = ServerSpawnPaintingPacket.class)\npublic class JavaSpawnPaintingTranslator extends PacketTranslator<ServerSpawnPaintingPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnPaintingPacket packet) {\n        Vector3f position = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n\n        PaintingEntity entity = new PaintingEntity(packet.getEntityId(),\n                session.getEntityCache().getNextEntityId().incrementAndGet(),\n                position, PaintingType.getByPaintingType(packet.getPaintingType()), packet.getDirection().ordinal());\n\n        session.getEntityCache().spawnEntity(entity);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.entity.spawn;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.spawn.ServerSpawnPlayerPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.LanguageUtils;\nimport org.geysermc.connector.skin.SkinManager;\n\n@Translator(packet = ServerSpawnPlayerPacket.class)\npublic class JavaSpawnPlayerTranslator extends PacketTranslator<ServerSpawnPlayerPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnPlayerPacket packet) {\n        Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        Vector3f rotation = Vector3f.from(packet.getYaw(), packet.getPitch(), packet.getYaw());\n\n        PlayerEntity entity;\n        if (packet.getUuid().equals(session.getPlayerEntity().getUuid())) {\n            // Server is sending a fake version of the current player\n            entity = new PlayerEntity(session.getPlayerEntity().getProfile(), packet.getEntityId(), session.getEntityCache().getNextEntityId().incrementAndGet(), position, Vector3f.ZERO, rotation);\n        } else {\n            entity = session.getEntityCache().getPlayerEntity(packet.getUuid());\n            if (entity == null) {\n                GeyserConnector.getInstance().getLogger().error(LanguageUtils.getLocaleStringLog(\"geyser.entity.player.failed_list\", packet.getUuid()));\n                return;\n            }\n\n            entity.setEntityId(packet.getEntityId());\n            entity.setPosition(position);\n            entity.setRotation(rotation);\n        }\n        session.getEntityCache().cacheEntity(entity);\n\n        entity.sendPlayer(session);\n        SkinManager.requestAndHandleSkinAndCape(entity, session, null);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerDisplayScoreboardPacket;\n\n@Translator(packet = ServerDisplayScoreboardPacket.class)\npublic class JavaDisplayScoreboardTranslator extends PacketTranslator<ServerDisplayScoreboardPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerDisplayScoreboardPacket packet) {\n        session.getWorldCache().getScoreboard()\n                .displayObjective(packet.getName(), packet.getPosition());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.WorldCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Objective;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\nimport com.github.steveice10.mc.protocol.data.game.scoreboard.ObjectiveAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerScoreboardObjectivePacket;\n\n@Translator(packet = ServerScoreboardObjectivePacket.class)\npublic class JavaScoreboardObjectiveTranslator extends PacketTranslator<ServerScoreboardObjectivePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerScoreboardObjectivePacket packet) {\n        WorldCache worldCache = session.getWorldCache();\n        Scoreboard scoreboard = worldCache.getScoreboard();\n        Objective objective = scoreboard.getObjective(packet.getName());\n        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();\n\n        if (objective == null && packet.getAction() != ObjectiveAction.REMOVE) {\n            objective = scoreboard.registerNewObjective(packet.getName(), false);\n        }\n\n        switch (packet.getAction()) {\n            case ADD:\n            case UPDATE:\n                objective.setDisplayName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setType(packet.getType().ordinal());\n                break;\n            case REMOVE:\n                scoreboard.unregisterObjective(packet.getName());\n                break;\n        }\n\n        if (objective == null || !objective.isActive()) {\n            return;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerTeamPacket;\nimport it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.GeyserLogger;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.scoreboard.Team;\nimport org.geysermc.connector.scoreboard.UpdateType;\nimport org.geysermc.connector.utils.LanguageUtils;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\nimport java.util.Arrays;\nimport java.util.Set;\n\n@Translator(packet = ServerTeamPacket.class)\npublic class JavaTeamTranslator extends PacketTranslator<ServerTeamPacket> {\n    private static final GeyserLogger LOGGER = GeyserConnector.getInstance().getLogger();\n\n    @Override\n    public void translate(GeyserSession session, ServerTeamPacket packet) {\n        if (LOGGER.isDebug()) {\n            LOGGER.debug(\"Team packet \" + packet.getTeamName() + \" \" + packet.getAction() + \" \" + Arrays.toString(packet.getPlayers()));\n        }\n\n        int pps = session.getWorldCache().increaseAndGetScoreboardPacketsPerSecond();\n\n        Scoreboard scoreboard = session.getWorldCache().getScoreboard();\n        Team team = scoreboard.getTeam(packet.getTeamName());\n        switch (packet.getAction()) {\n            case CREATE:\n                scoreboard.registerNewTeam(packet.getTeamName(), toPlayerSet(packet.getPlayers()))\n                        .setName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setColor(packet.getColor())\n                        .setNameTagVisibility(packet.getNameTagVisibility())\n                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))\n                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()));\n                break;\n            case UPDATE:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n\n                team.setName(MessageTranslator.convertMessage(packet.getDisplayName()))\n                        .setColor(packet.getColor())\n                        .setNameTagVisibility(packet.getNameTagVisibility())\n                        .setPrefix(MessageTranslator.convertMessage(packet.getPrefix(), session.getLocale()))\n                        .setSuffix(MessageTranslator.convertMessage(packet.getSuffix(), session.getLocale()))\n                        .setUpdateType(UpdateType.UPDATE);\n                break;\n            case ADD_PLAYER:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n                team.addEntities(packet.getPlayers());\n                break;\n            case REMOVE_PLAYER:\n                if (team == null) {\n                    LOGGER.debug(LanguageUtils.getLocaleStringLog(\n                            \"geyser.network.translator.team.failed_not_registered\",\n                            packet.getAction(), packet.getTeamName()\n                    ));\n                    return;\n                }\n                team.removeEntities(packet.getPlayers());\n                break;\n            case REMOVE:\n                scoreboard.removeTeam(packet.getTeamName());\n                break;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n\n    private Set<String> toPlayerSet(String[] players) {\n        return new ObjectOpenHashSet<>(players);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.scoreboard;\n\nimport com.github.steveice10.mc.protocol.data.game.scoreboard.ScoreboardAction;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.scoreboard.ServerUpdateScorePacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.GeyserLogger;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.cache.WorldCache;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.scoreboard.Objective;\nimport org.geysermc.connector.scoreboard.Scoreboard;\nimport org.geysermc.connector.scoreboard.ScoreboardUpdater;\nimport org.geysermc.connector.utils.LanguageUtils;\n\n@Translator(packet = ServerUpdateScorePacket.class)\npublic class JavaUpdateScoreTranslator extends PacketTranslator<ServerUpdateScorePacket> {\n    private final GeyserLogger logger;\n\n    public JavaUpdateScoreTranslator() {\n        logger = GeyserConnector.getInstance().getLogger();\n    }\n\n    @Override\n    public void translate(GeyserSession session, ServerUpdateScorePacket packet) {\n        WorldCache worldCache = session.getWorldCache();\n        Scoreboard scoreboard = worldCache.getScoreboard();\n        int pps = worldCache.increaseAndGetScoreboardPacketsPerSecond();\n\n        Objective objective = scoreboard.getObjective(packet.getObjective());\n        if (objective == null && packet.getAction() != ScoreboardAction.REMOVE) {\n            logger.info(LanguageUtils.getLocaleStringLog(\"geyser.network.translator.score.failed_objective\", packet.getObjective()));\n            return;\n        }\n\n        switch (packet.getAction()) {\n            case ADD_OR_UPDATE:\n                objective.setScore(packet.getEntry(), packet.getValue());\n                break;\n            case REMOVE:\n                if (objective != null) {\n                    objective.removeScore(packet.getEntry());\n                } else {\n                    for (Objective objective1 : scoreboard.getObjectives().values()) {\n                        objective1.removeScore(packet.getEntry());\n                    }\n                }\n                break;\n        }\n\n        // ScoreboardUpdater will handle it for us if the packets per second\n        // (for score and team packets) is higher then the first threshold\n        if (pps < ScoreboardUpdater.FIRST_SCORE_PACKETS_PER_SECOND_THRESHOLD) {\n            scoreboard.onUpdate();\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerClearTitlesPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerClearTitlesPacket.class)\npublic class JavaClearTitlesTranslator extends PacketTranslator<ServerClearTitlesPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerClearTitlesPacket packet) {\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        // TODO handle packet.isResetTimes()\n        titlePacket.setType(SetTitlePacket.Type.CLEAR);\n        titlePacket.setText(\"\");\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetActionBarTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetActionBarTextPacket.class)\npublic class JavaSetActionBarTextTranslator extends PacketTranslator<ServerSetActionBarTextPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSetActionBarTextPacket packet) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.ACTIONBAR);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetSubtitleTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetSubtitleTextPacket.class)\npublic class JavaSetSubtitleTextTranslator extends PacketTranslator<ServerSetSubtitleTextPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSetSubtitleTextPacket packet) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.SUBTITLE);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitleTextPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\n\n@Translator(packet = ServerSetTitleTextPacket.class)\npublic class JavaSetTitleTextTranslator extends PacketTranslator<ServerSetTitleTextPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSetTitleTextPacket packet) {\n        String text;\n        if (packet.getText() == null) { //TODO 1.17 can this happen?\n            text = \" \";\n        } else {\n            text = MessageTranslator.convertMessage(packet.getText(), session.getLocale());\n        }\n\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.TITLE);\n        titlePacket.setText(text);\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.title;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.title.ServerSetTitlesAnimationPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTitlePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerSetTitlesAnimationPacket.class)\npublic class JavaSetTitlesAnimationTranslator extends PacketTranslator<ServerSetTitlesAnimationPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSetTitlesAnimationPacket packet) {\n        SetTitlePacket titlePacket = new SetTitlePacket();\n        titlePacket.setType(SetTitlePacket.Type.TIMES);\n        titlePacket.setText(\"\");\n        titlePacket.setFadeInTime(packet.getFadeIn());\n        titlePacket.setFadeOutTime(packet.getFadeOut());\n        titlePacket.setStayTime(packet.getStay());\n        titlePacket.setXuid(\"\");\n        titlePacket.setPlatformOnlineId(\"\");\n        session.sendUpstreamPacket(titlePacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerCloseWindowPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerCloseWindowPacket.class)\npublic class JavaCloseWindowTranslator extends PacketTranslator<ServerCloseWindowPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerCloseWindowPacket packet) {\n        // Sometimes the server can request a window close of ID 0... when the window isn't even open\n        // Don't confirm in this instance\n        InventoryUtils.closeInventory(session, packet.getWindowId(), (session.getOpenInventory() != null && session.getOpenInventory().getId() == packet.getWindowId()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenHorseWindowPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.UpdateEquipPacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.entity.living.animal.horse.ChestedHorseEntity;\nimport org.geysermc.connector.entity.living.animal.horse.LlamaEntity;\nimport org.geysermc.connector.inventory.Container;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.DonkeyInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.HorseInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.horse.LlamaInventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n@Translator(packet = ServerOpenHorseWindowPacket.class)\npublic class JavaOpenHorseWindowTranslator extends PacketTranslator<ServerOpenHorseWindowPacket> {\n\n    private static final NbtMap ARMOR_SLOT;\n    private static final NbtMap CARPET_SLOT;\n    private static final NbtMap SADDLE_SLOT;\n\n    static {\n        // Build the NBT mappings that Bedrock wants to lay out the GUI\n        String[] acceptedHorseArmorIdentifiers = new String[] {\"minecraft:horsearmorleather\", \"minecraft:horsearmoriron\",\n                \"minecraft:horsearmorgold\", \"minecraft:horsearmordiamond\"};\n        NbtMapBuilder armorBuilder = NbtMap.builder();\n        List<NbtMap> acceptedArmors = new ArrayList<>(4);\n        for (String identifier : acceptedHorseArmorIdentifiers) {\n            NbtMapBuilder acceptedItemBuilder = NbtMap.builder()\n                    .putShort(\"Aux\", Short.MAX_VALUE)\n                    .putString(\"Name\", identifier);\n            acceptedArmors.add(NbtMap.builder().putCompound(\"slotItem\", acceptedItemBuilder.build()).build());\n        }\n        armorBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedArmors);\n        NbtMapBuilder armorItem = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:horsearmoriron\");\n        armorBuilder.putCompound(\"item\", armorItem.build());\n        armorBuilder.putInt(\"slotNumber\", 1);\n        ARMOR_SLOT = armorBuilder.build();\n\n        NbtMapBuilder carpetBuilder = NbtMap.builder();\n        NbtMapBuilder carpetItem = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:carpet\");\n        List<NbtMap> acceptedCarpet = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", carpetItem.build()).build());\n        carpetBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedCarpet);\n        carpetBuilder.putCompound(\"item\", carpetItem.build());\n        carpetBuilder.putInt(\"slotNumber\", 1);\n        CARPET_SLOT = carpetBuilder.build();\n\n        NbtMapBuilder saddleBuilder = NbtMap.builder();\n        NbtMapBuilder acceptedSaddle = NbtMap.builder()\n                .putShort(\"Aux\", Short.MAX_VALUE)\n                .putString(\"Name\", \"minecraft:saddle\");\n        List<NbtMap> acceptedItem = Collections.singletonList(NbtMap.builder().putCompound(\"slotItem\", acceptedSaddle.build()).build());\n        saddleBuilder.putList(\"acceptedItems\", NbtType.COMPOUND, acceptedItem);\n        saddleBuilder.putCompound(\"item\", acceptedSaddle.build());\n        saddleBuilder.putInt(\"slotNumber\", 0);\n        SADDLE_SLOT = saddleBuilder.build();\n    }\n\n    @Override\n    public void translate(GeyserSession session, ServerOpenHorseWindowPacket packet) {\n        Entity entity = session.getEntityCache().getEntityByJavaId(packet.getEntityId());\n        if (entity == null) {\n            return;\n        }\n\n        UpdateEquipPacket updateEquipPacket = new UpdateEquipPacket();\n        updateEquipPacket.setWindowId((short) packet.getWindowId());\n        updateEquipPacket.setWindowType((short) ContainerType.HORSE.getId());\n        updateEquipPacket.setUniqueEntityId(entity.getGeyserId());\n\n        NbtMapBuilder builder = NbtMap.builder();\n        List<NbtMap> slots = new ArrayList<>();\n\n        InventoryTranslator inventoryTranslator;\n        if (entity instanceof LlamaEntity) {\n            inventoryTranslator = new LlamaInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(CARPET_SLOT);\n        } else if (entity instanceof ChestedHorseEntity) {\n            inventoryTranslator = new DonkeyInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(SADDLE_SLOT);\n        } else {\n            inventoryTranslator = new HorseInventoryTranslator(packet.getNumberOfSlots());\n            slots.add(SADDLE_SLOT);\n            slots.add(ARMOR_SLOT);\n        }\n\n        // Build the NbtMap that sets the icons for Bedrock (e.g. sets the saddle outline on the saddle slot)\n        builder.putList(\"slots\", NbtType.COMPOUND, slots);\n\n        updateEquipPacket.setTag(builder.build());\n        session.sendUpstreamPacket(updateEquipPacket);\n\n        session.setInventoryTranslator(inventoryTranslator);\n        InventoryUtils.openInventory(session, new Container(entity.getMetadata().getString(EntityData.NAMETAG), packet.getWindowId(), packet.getNumberOfSlots(), null, session.getPlayerInventory()));\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.client.window.ClientCloseWindowPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerOpenWindowPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.chat.MessageTranslator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\nimport org.geysermc.connector.utils.LocaleUtils;\n\n@Translator(packet = ServerOpenWindowPacket.class)\npublic class JavaOpenWindowTranslator extends PacketTranslator<ServerOpenWindowPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerOpenWindowPacket packet) {\n        if (packet.getWindowId() == 0) {\n            return;\n        }\n\n        InventoryTranslator newTranslator = InventoryTranslator.INVENTORY_TRANSLATORS.get(packet.getType());\n        Inventory openInventory = session.getOpenInventory();\n        //No translator exists for this window type. Close all windows and return.\n        if (newTranslator == null) {\n            if (openInventory != null) {\n                InventoryUtils.closeInventory(session, openInventory.getId(), true);\n            }\n            ClientCloseWindowPacket closeWindowPacket = new ClientCloseWindowPacket(packet.getWindowId());\n            session.sendDownstreamPacket(closeWindowPacket);\n            return;\n        }\n\n        String name = MessageTranslator.convertMessageLenient(packet.getName(), session.getLocale());\n        name = LocaleUtils.getLocaleString(name, session.getLocale());\n\n        Inventory newInventory = newTranslator.createInventory(name, packet.getWindowId(), packet.getType(), session.getPlayerInventory());\n        if (openInventory != null) {\n            // If the window type is the same, don't close.\n            // In rare cases, inventories can do funny things where it keeps the same window type up but change the contents.\n            if (openInventory.getWindowType() != packet.getType()) {\n                // Sometimes the server can double-open an inventory with the same ID - don't confirm in that instance.\n                InventoryUtils.closeInventory(session, openInventory.getId(), openInventory.getId() != packet.getWindowId());\n            }\n        }\n\n        session.setInventoryTranslator(newTranslator);\n        InventoryUtils.openInventory(session, newInventory);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Ingredient;\nimport com.github.steveice10.mc.protocol.data.game.recipe.Recipe;\nimport com.github.steveice10.mc.protocol.data.game.recipe.RecipeType;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapedRecipeData;\nimport com.github.steveice10.mc.protocol.data.game.recipe.data.ShapelessRecipeData;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerSetSlotPacket;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerId;\nimport com.nukkitx.protocol.bedrock.data.inventory.CraftingData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.CraftingDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.InventorySlotPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.CraftingInventoryTranslator;\nimport org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Objects;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerSetSlotPacket.class)\npublic class JavaSetSlotTranslator extends PacketTranslator<ServerSetSlotPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSetSlotPacket packet) {\n        if (packet.getWindowId() == 255) { //cursor\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());\n            session.getPlayerInventory().setCursor(newItem, session);\n            InventoryUtils.updateCursor(session);\n            return;\n        }\n\n        //TODO: support window id -2, should update player inventory\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        inventory.setStateId(packet.getStateId());\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            if (session.getCraftingGridFuture() != null) {\n                session.getCraftingGridFuture().cancel(false);\n            }\n            session.setCraftingGridFuture(session.scheduleInEventLoop(() -> updateCraftingGrid(session, packet, inventory, translator), 150, TimeUnit.MILLISECONDS));\n\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItem());\n            if (packet.getWindowId() == 0 && !(translator instanceof PlayerInventoryTranslator)) {\n                // In rare cases, the window ID can still be 0 but Java treats it as valid\n                session.getPlayerInventory().setItem(packet.getSlot(), newItem, session);\n                InventoryTranslator.PLAYER_INVENTORY_TRANSLATOR.updateSlot(session, session.getPlayerInventory(), packet.getSlot());\n            } else {\n                inventory.setItem(packet.getSlot(), newItem, session);\n                translator.updateSlot(session, inventory, packet.getSlot());\n            }\n        }\n    }\n\n    private static void updateCraftingGrid(GeyserSession session, ServerSetSlotPacket packet, Inventory inventory, InventoryTranslator translator) {\n        if (packet.getSlot() == 0) {\n            int gridSize;\n            if (translator instanceof PlayerInventoryTranslator) {\n                gridSize = 4;\n            } else if (translator instanceof CraftingInventoryTranslator) {\n                gridSize = 9;\n            } else {\n                return;\n            }\n\n            if (packet.getItem() == null || packet.getItem().getId() == 0) {\n                return;\n            }\n\n            int offset = gridSize == 4 ? 28 : 32;\n            int gridDimensions = gridSize == 4 ? 2 : 3;\n            int firstRow = -1, height = -1;\n            int firstCol = -1, width = -1;\n            for (int row = 0; row < gridDimensions; row++) {\n                for (int col = 0; col < gridDimensions; col++) {\n                    if (!inventory.getItem(col + (row * gridDimensions) + 1).isEmpty()) {\n                        if (firstRow == -1) {\n                            firstRow = row;\n                            firstCol = col;\n                        } else {\n                            firstCol = Math.min(firstCol, col);\n                        }\n                        height = Math.max(height, row);\n                        width = Math.max(width, col);\n                    }\n                }\n            }\n\n            //empty grid\n            if (firstRow == -1) {\n                return;\n            }\n\n            height += -firstRow + 1;\n            width += -firstCol + 1;\n\n            recipes:\n            for (Recipe recipe : session.getCraftingRecipes().values()) {\n                if (recipe.getType() == RecipeType.CRAFTING_SHAPED) {\n                    ShapedRecipeData data = (ShapedRecipeData) recipe.getData();\n                    if (!data.getResult().equals(packet.getItem())) {\n                        continue;\n                    }\n                    if (data.getWidth() != width || data.getHeight() != height || width * height != data.getIngredients().length) {\n                        continue;\n                    }\n\n                    Ingredient[] ingredients = data.getIngredients();\n                    if (!testShapedRecipe(ingredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {\n                        Ingredient[] mirroredIngredients = new Ingredient[data.getIngredients().length];\n                        for (int row = 0; row < height; row++) {\n                            for (int col = 0; col < width; col++) {\n                                mirroredIngredients[col + (row * width)] = ingredients[(width - 1 - col) + (row * width)];\n                            }\n                        }\n\n                        if (Arrays.equals(ingredients, mirroredIngredients) ||\n                                !testShapedRecipe(mirroredIngredients, inventory, gridDimensions, firstRow, height, firstCol, width)) {\n                            continue;\n                        }\n                    }\n                    // Recipe is had, don't sent packet\n                    return;\n                } else if (recipe.getType() == RecipeType.CRAFTING_SHAPELESS) {\n                    ShapelessRecipeData data = (ShapelessRecipeData) recipe.getData();\n                    if (!data.getResult().equals(packet.getItem())) {\n                        continue;\n                    }\n                    for (int i = 0; i < data.getIngredients().length; i++) {\n                        Ingredient ingredient = data.getIngredients()[i];\n                        for (ItemStack itemStack : ingredient.getOptions()) {\n                            boolean inventoryHasItem = false;\n                            for (int j = 0; j < inventory.getSize(); j++) {\n                                GeyserItemStack geyserItemStack = inventory.getItem(j);\n                                if (geyserItemStack.isEmpty()) {\n                                    inventoryHasItem = itemStack == null || itemStack.getId() == 0;\n                                    if (inventoryHasItem) {\n                                        break;\n                                    }\n                                } else if (itemStack.equals(geyserItemStack.getItemStack(1))) {\n                                    inventoryHasItem = true;\n                                    break;\n                                }\n                            }\n                            if (!inventoryHasItem) {\n                                continue recipes;\n                            }\n                        }\n                    }\n                    // Recipe is had, don't sent packet\n                    return;\n                }\n            }\n\n            UUID uuid = UUID.randomUUID();\n            int newRecipeId = session.getLastRecipeNetId().incrementAndGet();\n\n            ItemData[] ingredients = new ItemData[height * width];\n            //construct ingredient list and clear slots on client\n            Ingredient[] javaIngredients = new Ingredient[height * width];\n            int index = 0;\n            for (int row = firstRow; row < height + firstRow; row++) {\n                for (int col = firstCol; col < width + firstCol; col++) {\n                    GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);\n                    ingredients[index] = geyserItemStack.getItemData(session);\n                    ItemStack[] itemStacks = new ItemStack[] {geyserItemStack.isEmpty() ? null : geyserItemStack.getItemStack(1)};\n                    javaIngredients[index] = new Ingredient(itemStacks);\n\n                    InventorySlotPacket slotPacket = new InventorySlotPacket();\n                    slotPacket.setContainerId(ContainerId.UI);\n                    slotPacket.setSlot(col + (row * gridDimensions) + offset);\n                    slotPacket.setItem(ItemData.AIR);\n                    session.sendUpstreamPacket(slotPacket);\n                    index++;\n                }\n            }\n\n            ShapedRecipeData data = new ShapedRecipeData(width, height, \"\", javaIngredients, packet.getItem());\n            // Cache this recipe so we know the client has received it\n            session.getCraftingRecipes().put(newRecipeId, new Recipe(RecipeType.CRAFTING_SHAPED, uuid.toString(), data));\n\n            CraftingDataPacket craftPacket = new CraftingDataPacket();\n            craftPacket.getCraftingData().add(CraftingData.fromShaped(\n                    uuid.toString(),\n                    width,\n                    height,\n                    Arrays.asList(ingredients),\n                    Collections.singletonList(ItemTranslator.translateToBedrock(session, packet.getItem())),\n                    uuid,\n                    \"crafting_table\",\n                    0,\n                    newRecipeId\n            ));\n            craftPacket.setCleanRecipes(false);\n            session.sendUpstreamPacket(craftPacket);\n\n            index = 0;\n            for (int row = firstRow; row < height + firstRow; row++) {\n                for (int col = firstCol; col < width + firstCol; col++) {\n                    InventorySlotPacket slotPacket = new InventorySlotPacket();\n                    slotPacket.setContainerId(ContainerId.UI);\n                    slotPacket.setSlot(col + (row * gridDimensions) + offset);\n                    slotPacket.setItem(ingredients[index]);\n                    session.sendUpstreamPacket(slotPacket);\n                    index++;\n                }\n            }\n        }\n    }\n\n    private static boolean testShapedRecipe(Ingredient[] ingredients, Inventory inventory, int gridDimensions, int firstRow, int height, int firstCol, int width) {\n        int ingredientIndex = 0;\n        for (int row = firstRow; row < height + firstRow; row++) {\n            for (int col = firstCol; col < width + firstCol; col++) {\n                GeyserItemStack geyserItemStack = inventory.getItem(col + (row * gridDimensions) + 1);\n                Ingredient ingredient = ingredients[ingredientIndex++];\n                if (ingredient.getOptions().length == 0) {\n                    if (!geyserItemStack.isEmpty()) {\n                        return false;\n                    }\n                } else {\n                    boolean inventoryHasItem = false;\n                    for (ItemStack item : ingredient.getOptions()) {\n                        if (Objects.equals(geyserItemStack.getItemStack(1), item)) {\n                            inventoryHasItem = true;\n                            break;\n                        }\n                    }\n                    if (!inventoryHasItem) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowItemsPacket;\nimport org.geysermc.connector.inventory.GeyserItemStack;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerWindowItemsPacket.class)\npublic class JavaWindowItemsTranslator extends PacketTranslator<ServerWindowItemsPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerWindowItemsPacket packet) {\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        inventory.setStateId(packet.getStateId());\n\n        for (int i = 0; i < packet.getItems().length; i++) {\n            GeyserItemStack newItem = GeyserItemStack.from(packet.getItems()[i]);\n            inventory.setItem(i, newItem, session);\n        }\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            translator.updateInventory(session, inventory);\n        }\n\n        session.getPlayerInventory().setCursor(GeyserItemStack.from(packet.getCarriedItem()), session);\n        InventoryUtils.updateCursor(session);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.window;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerWindowPropertyPacket;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.InventoryTranslator;\nimport org.geysermc.connector.utils.InventoryUtils;\n\n@Translator(packet = ServerWindowPropertyPacket.class)\npublic class JavaWindowPropertyTranslator extends PacketTranslator<ServerWindowPropertyPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerWindowPropertyPacket packet) {\n        Inventory inventory = InventoryUtils.getInventory(session, packet.getWindowId());\n        if (inventory == null)\n            return;\n\n        InventoryTranslator translator = session.getInventoryTranslator();\n        if (translator != null) {\n            translator.updateProperty(session, inventory, packet.getRawProperty(), packet.getValue());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockBreakAnimPacket;\nimport com.github.steveice10.opennbt.tag.builtin.CompoundTag;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.registry.type.ItemMapping;\nimport org.geysermc.connector.utils.BlockUtils;\n\n@Translator(packet = ServerBlockBreakAnimPacket.class)\npublic class JavaBlockBreakAnimTranslator extends PacketTranslator<ServerBlockBreakAnimPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerBlockBreakAnimPacket packet) {\n        int state = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n        int breakTime = (int) (65535 / Math.ceil(BlockUtils.getBreakTime(session, BlockRegistries.JAVA_BLOCKS.get(state), ItemMapping.AIR, new CompoundTag(\"\"), false) * 20));\n        LevelEventPacket levelEventPacket = new LevelEventPacket();\n        levelEventPacket.setPosition(Vector3f.from(\n                packet.getPosition().getX(),\n                packet.getPosition().getY(),\n                packet.getPosition().getZ()\n        ));\n        levelEventPacket.setType(LevelEventType.BLOCK_START_BREAK);\n\n        switch (packet.getStage()) {\n            case STAGE_1:\n                levelEventPacket.setData(breakTime);\n                break;\n            case STAGE_2:\n                levelEventPacket.setData(breakTime * 2);\n                break;\n            case STAGE_3:\n                levelEventPacket.setData(breakTime * 3);\n                break;\n            case STAGE_4:\n                levelEventPacket.setData(breakTime * 4);\n                break;\n            case STAGE_5:\n                levelEventPacket.setData(breakTime * 5);\n                break;\n            case STAGE_6:\n                levelEventPacket.setData(breakTime * 6);\n                break;\n            case STAGE_7:\n                levelEventPacket.setData(breakTime * 7);\n                break;\n            case STAGE_8:\n                levelEventPacket.setData(breakTime * 8);\n                break;\n            case STAGE_9:\n                levelEventPacket.setData(breakTime * 9);\n                break;\n            case STAGE_10:\n                levelEventPacket.setData(breakTime * 10);\n                break;\n            case RESET:\n                levelEventPacket.setType(LevelEventType.BLOCK_STOP_BREAK);\n                levelEventPacket.setData(0);\n                break;\n        }\n        session.sendUpstreamPacket(levelEventPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockChangePacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.common.PlatformType;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.sound.BlockSoundInteractionHandler;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerBlockChangePacket.class)\npublic class JavaBlockChangeTranslator extends PacketTranslator<ServerBlockChangePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerBlockChangePacket packet) {\n        Position pos = packet.getRecord().getPosition();\n        boolean updatePlacement = session.getConnector().getPlatformType() != PlatformType.SPIGOT && // Spigot simply listens for the block place event\n                session.getConnector().getWorldManager().getBlockAt(session, pos) != packet.getRecord().getBlock();\n        ChunkUtils.updateBlock(session, packet.getRecord().getBlock(), pos);\n        if (updatePlacement) {\n            this.checkPlace(session, packet);\n        }\n        this.checkInteract(session, packet);\n    }\n\n    private boolean checkPlace(GeyserSession session, ServerBlockChangePacket packet) {\n        Vector3i lastPlacePos = session.getLastBlockPlacePosition();\n        if (lastPlacePos == null) {\n            return false;\n        }\n        if ((lastPlacePos.getX() != packet.getRecord().getPosition().getX()\n                || lastPlacePos.getY() != packet.getRecord().getPosition().getY()\n                || lastPlacePos.getZ() != packet.getRecord().getPosition().getZ())) {\n            return false;\n        }\n\n        // We need to check if the identifier is the same, else a packet with the sound of what the\n        // player has in their hand is played, despite if the block is being placed or not\n        boolean contains = false;\n        String identifier = BlockRegistries.JAVA_BLOCKS.get(packet.getRecord().getBlock()).getItemIdentifier();\n        if (identifier.equals(session.getLastBlockPlacedId())) {\n            contains = true;\n        }\n\n        if (!contains) {\n            session.setLastBlockPlacePosition(null);\n            session.setLastBlockPlacedId(null);\n            return false;\n        }\n\n        // This is not sent from the server, so we need to send it this way\n        LevelSoundEventPacket placeBlockSoundPacket = new LevelSoundEventPacket();\n        placeBlockSoundPacket.setSound(SoundEvent.PLACE);\n        placeBlockSoundPacket.setPosition(lastPlacePos.toFloat());\n        placeBlockSoundPacket.setBabySound(false);\n        placeBlockSoundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(packet.getRecord().getBlock()));\n        placeBlockSoundPacket.setIdentifier(\":\");\n        session.sendUpstreamPacket(placeBlockSoundPacket);\n        session.setLastBlockPlacePosition(null);\n        session.setLastBlockPlacedId(null);\n        return true;\n    }\n\n    private void checkInteract(GeyserSession session, ServerBlockChangePacket packet) {\n        Vector3i lastInteractPos = session.getLastInteractionBlockPosition();\n        if (lastInteractPos == null || !session.isInteracting()) {\n            return;\n        }\n        if ((lastInteractPos.getX() != packet.getRecord().getPosition().getX()\n                || lastInteractPos.getY() != packet.getRecord().getPosition().getY()\n                || lastInteractPos.getZ() != packet.getRecord().getPosition().getZ())) {\n            return;\n        }\n        String identifier = BlockRegistries.JAVA_IDENTIFIERS.get().get(packet.getRecord().getBlock());\n        session.setInteracting(false);\n        BlockSoundInteractionHandler.handleBlockInteraction(session, lastInteractPos.toFloat(), identifier);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.Position;\nimport com.github.steveice10.mc.protocol.data.game.world.block.value.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerBlockValuePacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.protocol.bedrock.packet.BlockEntityDataPacket;\nimport com.nukkitx.protocol.bedrock.packet.BlockEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.network.translators.world.block.entity.NoteblockBlockEntityTranslator;\n\nimport java.util.concurrent.TimeUnit;\n\n@Translator(packet = ServerBlockValuePacket.class)\npublic class JavaBlockValueTranslator extends PacketTranslator<ServerBlockValuePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerBlockValuePacket packet) {\n        BlockEventPacket blockEventPacket = new BlockEventPacket();\n        blockEventPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(),\n                packet.getPosition().getY(), packet.getPosition().getZ()));\n        if (packet.getValue() instanceof ChestValue) {\n            ChestValue value = (ChestValue) packet.getValue() ;\n            blockEventPacket.setEventType(1);\n            blockEventPacket.setEventData(value.getViewers() > 0 ? 1 : 0);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof EndGatewayValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof NoteBlockValue) {\n            NoteblockBlockEntityTranslator.translate(session, packet.getPosition());\n        } else if (packet.getValue() instanceof PistonValue) {\n            PistonValueType type = (PistonValueType) packet.getType();\n\n            // Unlike everything else, pistons need a block entity packet to convey motion\n            // TODO: Doesn't register on chunk load; needs to be interacted with first\n            Vector3i position = Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ());\n            if (type == PistonValueType.PUSHING) {\n                extendPiston(session, position, 0.0f, 0.0f);\n            } else {\n                retractPiston(session, position, 1.0f, 1.0f);\n            }\n        } else if (packet.getValue() instanceof MobSpawnerValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof EndGatewayValue) {\n            blockEventPacket.setEventType(1);\n            session.sendUpstreamPacket(blockEventPacket);\n        } else if (packet.getValue() instanceof GenericBlockValue && packet.getBlockId() == BlockStateValues.JAVA_BELL_ID) {\n            // Bells - needed to show ring from other players\n            GenericBlockValue bellValue = (GenericBlockValue) packet.getValue();\n            Position position = packet.getPosition();\n\n            BlockEntityDataPacket blockEntityPacket = new BlockEntityDataPacket();\n            blockEntityPacket.setBlockPosition(Vector3i.from(position.getX(), position.getY(), position.getZ()));\n\n            NbtMapBuilder builder = NbtMap.builder();\n            builder.putInt(\"x\", position.getX());\n            builder.putInt(\"y\", position.getY());\n            builder.putInt(\"z\", position.getZ());\n            builder.putString(\"id\", \"Bell\");\n            int bedrockRingDirection;\n            switch (bellValue.getValue()) {\n                case 3: // north\n                    bedrockRingDirection = 0;\n                    break;\n                case 4: // east\n                    bedrockRingDirection = 1;\n                    break;\n                case 5: // west\n                    bedrockRingDirection = 3;\n                    break;\n                default: // south (2) is identical\n                    bedrockRingDirection = bellValue.getValue();\n            }\n            builder.putInt(\"Direction\", bedrockRingDirection);\n            builder.putByte(\"Ringing\", (byte) 1);\n            builder.putInt(\"Ticks\", 0);\n            \n            blockEntityPacket.setData(builder.build());\n            session.sendUpstreamPacket(blockEntityPacket);\n        }\n    }\n\n    /**\n     * Emulating a piston extending\n     * @param session GeyserSession\n     * @param position Block position\n     * @param progress How far the piston is\n     * @param lastProgress How far the piston last was\n     */\n    private void extendPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {\n        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();\n        blockEntityDataPacket.setBlockPosition(position);\n        byte state = (byte) ((progress == 1.0f && lastProgress == 1.0f) ? 2 : 1);\n        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));\n        session.sendUpstreamPacket(blockEntityDataPacket);\n        if (lastProgress != 1.0f) {\n            session.getConnector().getGeneralThreadPool().schedule(() ->\n                            extendPiston(session, position, (progress >= 1.0f) ? 1.0f : progress + 0.5f, progress),\n                    20, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    /**\n     * Emulate a piston retracting.\n     * @param session GeyserSession\n     * @param position Block position\n     * @param progress Current progress of piston\n     * @param lastProgress Last progress of piston\n     */\n    private void retractPiston(GeyserSession session, Vector3i position, float progress, float lastProgress) {\n        BlockEntityDataPacket blockEntityDataPacket = new BlockEntityDataPacket();\n        blockEntityDataPacket.setBlockPosition(position);\n        byte state = (byte) ((progress == 0.0f && lastProgress == 0.0f) ? 0 : 3);\n        blockEntityDataPacket.setData(buildPistonTag(position, progress, lastProgress, state));\n        session.sendUpstreamPacket(blockEntityDataPacket);\n        if (lastProgress != 0.0f) {\n            session.getConnector().getGeneralThreadPool().schedule(() ->\n                            retractPiston(session, position, (progress <= 0.0f) ? 0.0f : progress - 0.5f, progress),\n                    20, TimeUnit.MILLISECONDS);\n        }\n    }\n\n    /**\n     * Build a piston tag\n     * @param position Piston position\n     * @param progress Current progress of piston\n     * @param lastProgress Last progress of piston\n     * @param state\n     * @return Bedrock CompoundTag of piston\n     */\n    private NbtMap buildPistonTag(Vector3i position, float progress, float lastProgress, byte state) {\n        NbtMapBuilder builder = NbtMap.builder()\n                .putInt(\"x\", position.getX())\n                .putInt(\"y\", position.getY())\n                .putInt(\"z\", position.getZ())\n                .putFloat(\"Progress\", progress)\n                .putFloat(\"LastProgress\", lastProgress)\n                .putString(\"id\", \"PistonArm\")\n                .putByte(\"NewState\", state)\n                .putByte(\"State\", state);\n        return builder.build();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.chunk.Column;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerChunkDataPacket;\nimport com.nukkitx.nbt.NBTOutputStream;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtUtils;\nimport com.nukkitx.network.VarInts;\nimport com.nukkitx.protocol.bedrock.packet.LevelChunkPacket;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.buffer.ByteBufOutputStream;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.chunk.ChunkSection;\nimport org.geysermc.connector.network.translators.world.BiomeTranslator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT;\nimport static org.geysermc.connector.utils.ChunkUtils.MINIMUM_ACCEPTED_HEIGHT_OVERWORLD;\n\n@Translator(packet = ServerChunkDataPacket.class)\npublic class JavaChunkDataTranslator extends PacketTranslator<ServerChunkDataPacket> {\n    // Caves and cliffs supports 3D biomes by implementing a very similar palette system to blocks\n    private static final boolean NEW_BIOME_WRITE = GeyserConnector.getInstance().getConfig().isExtendedWorldHeight();\n\n    @Override\n    public void translate(GeyserSession session, ServerChunkDataPacket packet) {\n        if (session.isSpawned()) {\n            ChunkUtils.updateChunkPosition(session, session.getPlayerEntity().getPosition().toInt());\n        }\n\n        session.getChunkCache().addToCache(packet.getColumn());\n        Column column = packet.getColumn();\n\n        // Ensure that, if the player is using lower world heights, the position is not offset\n        int yOffset = session.getChunkCache().getChunkMinY();\n\n        GeyserConnector.getInstance().getGeneralThreadPool().execute(() -> {\n            try {\n                if (session.isClosed()) {\n                    return;\n                }\n                ChunkUtils.ChunkData chunkData = ChunkUtils.translateToBedrock(session, column, yOffset);\n                ChunkSection[] sections = chunkData.getSections();\n\n                // Find highest section\n                int sectionCount = sections.length - 1;\n                while (sectionCount >= 0 && sections[sectionCount] == null) {\n                    sectionCount--;\n                }\n                sectionCount++;\n\n                // Estimate chunk size\n                int size = 0;\n                for (int i = 0; i < sectionCount; i++) {\n                    ChunkSection section = sections[i];\n                    size += (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).estimateNetworkSize();\n                }\n                if (NEW_BIOME_WRITE) {\n                    size += ChunkUtils.EMPTY_CHUNK_DATA.length; // Consists only of biome data\n                } else {\n                    size += 256; // Biomes pre-1.18\n                }\n                size += 1; // Border blocks\n                size += 1; // Extra data length (always 0)\n                size += chunkData.getBlockEntities().length * 64; // Conservative estimate of 64 bytes per tile entity\n\n                // Allocate output buffer\n                ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(size);\n                byte[] payload;\n                try {\n                    for (int i = 0; i < sectionCount; i++) {\n                        ChunkSection section = sections[i];\n                        (section != null ? section : session.getBlockMappings().getEmptyChunkSection()).writeToNetwork(byteBuf);\n                    }\n\n                    if (NEW_BIOME_WRITE) {\n                        // At this point we're dealing with Bedrock chunk sections\n                        boolean overworld = session.getChunkCache().isExtendedHeight();\n                        int dimensionOffset = (overworld ? MINIMUM_ACCEPTED_HEIGHT_OVERWORLD : MINIMUM_ACCEPTED_HEIGHT) >> 4;\n                        for (int i = 0; i < sectionCount; i++) {\n                            int biomeYOffset = dimensionOffset + i;\n                            if (biomeYOffset < yOffset) {\n                                // Ignore this biome section since it goes below the height of the Java world\n                                byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);\n                                continue;\n                            }\n                            BiomeTranslator.toNewBedrockBiome(session, column.getBiomeData(), i + (dimensionOffset - yOffset)).writeToNetwork(byteBuf);\n                        }\n\n                        // As of 1.17.10, Bedrock hardcodes to always read 32 biome sections\n                        int remainingEmptyBiomes = 32 - sectionCount;\n                        for (int i = 0; i < remainingEmptyBiomes; i++) {\n                            byteBuf.writeBytes(ChunkUtils.EMPTY_BIOME_DATA);\n                        }\n                    } else {\n                        byteBuf.writeBytes(BiomeTranslator.toBedrockBiome(session, column.getBiomeData())); // Biomes - 256 bytes\n                    }\n                    byteBuf.writeByte(0); // Border blocks - Edu edition only\n                    VarInts.writeUnsignedInt(byteBuf, 0); // extra data length, 0 for now\n\n                    // Encode tile entities into buffer\n                    NBTOutputStream nbtStream = NbtUtils.createNetworkWriter(new ByteBufOutputStream(byteBuf));\n                    for (NbtMap blockEntity : chunkData.getBlockEntities()) {\n                        nbtStream.writeTag(blockEntity);\n                    }\n\n                    // Copy data into byte[], because the protocol lib really likes things that are s l o w\n                    byteBuf.readBytes(payload = new byte[byteBuf.readableBytes()]);\n                } finally {\n                    byteBuf.release(); // Release buffer to allow buffer pooling to be useful\n                }\n\n                LevelChunkPacket levelChunkPacket = new LevelChunkPacket();\n                levelChunkPacket.setSubChunksLength(sectionCount);\n                levelChunkPacket.setCachingEnabled(false);\n                levelChunkPacket.setChunkX(column.getX());\n                levelChunkPacket.setChunkZ(column.getZ());\n                levelChunkPacket.setData(payload);\n                session.sendUpstreamPacket(levelChunkPacket);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        });\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.block.ExplodedBlockRecord;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerExplosionPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SetEntityMotionPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.utils.ChunkUtils;\n\n@Translator(packet = ServerExplosionPacket.class)\npublic class JavaExplosionTranslator extends PacketTranslator<ServerExplosionPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerExplosionPacket packet) {\n        for (ExplodedBlockRecord record : packet.getExploded()) {\n            Vector3f pos = Vector3f.from(packet.getX() + record.getX(), packet.getY() + record.getY(), packet.getZ() + record.getZ());\n            ChunkUtils.updateBlock(session, BlockStateValues.JAVA_AIR_ID, pos.toInt());\n        }\n\n        Vector3f pos = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n        // Since bedrock does not play an explosion sound and particles sound, we have to manually do so\n        LevelEventPacket levelEventPacket = new LevelEventPacket();\n        levelEventPacket.setType(packet.getRadius() >= 2.0f ? LevelEventType.PARTICLE_HUGE_EXPLODE : LevelEventType.PARTICLE_EXPLOSION);\n        levelEventPacket.setData(0);\n        levelEventPacket.setPosition(pos.toFloat());\n        session.sendUpstreamPacket(levelEventPacket);\n\n        LevelSoundEventPacket levelSoundEventPacket = new LevelSoundEventPacket();\n        levelSoundEventPacket.setRelativeVolumeDisabled(false);\n        levelSoundEventPacket.setBabySound(false);\n        levelSoundEventPacket.setExtraData(-1);\n        levelSoundEventPacket.setSound(SoundEvent.EXPLODE);\n        levelSoundEventPacket.setIdentifier(\":\");\n        levelSoundEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        session.sendUpstreamPacket(levelSoundEventPacket);\n\n        if (packet.getPushX() > 0f || packet.getPushY() > 0f || packet.getPushZ() > 0f) {\n            SetEntityMotionPacket motionPacket = new SetEntityMotionPacket();\n            motionPacket.setRuntimeEntityId(session.getPlayerEntity().getGeyserId());\n            motionPacket.setMotion(Vector3f.from(packet.getPushX(), packet.getPushY(), packet.getPushZ()));\n            session.sendUpstreamPacket(motionPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.map.MapData;\nimport com.github.steveice10.mc.protocol.data.game.world.map.MapIcon;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMapDataPacket;\nimport com.nukkitx.protocol.bedrock.data.MapDecoration;\nimport com.nukkitx.protocol.bedrock.data.MapTrackedObject;\nimport com.nukkitx.protocol.bedrock.packet.ClientboundMapItemDataPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.BedrockMapIcon;\nimport org.geysermc.connector.utils.DimensionUtils;\nimport org.geysermc.connector.utils.MapColor;\n\n@Translator(packet = ServerMapDataPacket.class)\npublic class JavaMapDataTranslator extends PacketTranslator<ServerMapDataPacket> {\n    @Override\n    public void translate(GeyserSession session, ServerMapDataPacket packet) {\n        ClientboundMapItemDataPacket mapItemDataPacket = new ClientboundMapItemDataPacket();\n        boolean shouldStore = false;\n\n        mapItemDataPacket.setUniqueMapId(packet.getMapId());\n        mapItemDataPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n        mapItemDataPacket.setLocked(packet.isLocked());\n        mapItemDataPacket.setScale(packet.getScale());\n\n        MapData data = packet.getData();\n        if (data != null) {\n            mapItemDataPacket.setXOffset(data.getX());\n            mapItemDataPacket.setYOffset(data.getY());\n            mapItemDataPacket.setWidth(data.getColumns());\n            mapItemDataPacket.setHeight(data.getRows());\n\n            // We have a full map image, this usually only happens on spawn for the initial image\n            if (mapItemDataPacket.getWidth() == 128 && mapItemDataPacket.getHeight() == 128) {\n                shouldStore = true;\n            }\n\n            // Every int entry is an ABGR color\n            int[] colors = new int[data.getData().length];\n\n            int idx = 0;\n            for (byte colorId : data.getData()) {\n                colors[idx++] = MapColor.fromId(colorId & 0xFF).toABGR();\n            }\n\n            mapItemDataPacket.setColors(colors);\n        }\n\n        // Bedrock needs an entity id to display an icon\n        int id = 0;\n        for (MapIcon icon : packet.getIcons()) {\n            BedrockMapIcon bedrockMapIcon = BedrockMapIcon.fromType(icon.getIconType());\n\n            mapItemDataPacket.getTrackedObjects().add(new MapTrackedObject(id));\n            mapItemDataPacket.getDecorations().add(new MapDecoration(bedrockMapIcon.getIconID(), icon.getIconRotation(), icon.getCenterX(), icon.getCenterZ(), \"\", bedrockMapIcon.toARGB()));\n            id++;\n        }\n\n        // Store the map to send when the client requests it, as bedrock expects the data after a MapInfoRequestPacket\n        if (shouldStore) {\n            session.getStoredMaps().put(mapItemDataPacket.getUniqueMapId(), mapItemDataPacket);\n        }\n\n        // Send anyway just in case\n        session.sendUpstreamPacket(mapItemDataPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport com.github.steveice10.mc.protocol.data.game.world.block.BlockChangeRecord;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerMultiBlockChangePacket;\n\n@Translator(packet = ServerMultiBlockChangePacket.class)\npublic class JavaMultiBlockChangeTranslator extends PacketTranslator<ServerMultiBlockChangePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerMultiBlockChangePacket packet) {\n        for (BlockChangeRecord record : packet.getRecords()) {\n            ChunkUtils.updateBlock(session, record.getBlock(), record.getPosition());\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.ClientRequest;\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.EnterCreditsValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.RainStrengthValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.RespawnScreenValue;\nimport com.github.steveice10.mc.protocol.data.game.world.notify.ThunderStrengthValue;\nimport com.github.steveice10.mc.protocol.packet.ingame.client.ClientRequestPacket;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerNotifyClientPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.GameRuleData;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityEventType;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.entity.player.PlayerEntity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.inventory.translators.PlayerInventoryTranslator;\nimport org.geysermc.connector.utils.LocaleUtils;\n\n@Translator(packet = ServerNotifyClientPacket.class)\npublic class JavaNotifyClientTranslator extends PacketTranslator<ServerNotifyClientPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerNotifyClientPacket packet) {\n        PlayerEntity entity = session.getPlayerEntity();\n\n        switch (packet.getNotification()) {\n            case START_RAIN:\n                LevelEventPacket startRainPacket = new LevelEventPacket();\n                startRainPacket.setType(LevelEventType.START_RAINING);\n                startRainPacket.setData(Integer.MAX_VALUE);\n                startRainPacket.setPosition(Vector3f.ZERO);\n                session.sendUpstreamPacket(startRainPacket);\n                session.setRaining(true);\n                break;\n            case STOP_RAIN:\n                LevelEventPacket stopRainPacket = new LevelEventPacket();\n                stopRainPacket.setType(LevelEventType.STOP_RAINING);\n                stopRainPacket.setData(0);\n                stopRainPacket.setPosition(Vector3f.ZERO);\n                session.sendUpstreamPacket(stopRainPacket);\n                session.setRaining(false);\n                break;\n            case RAIN_STRENGTH:\n                // While the above values are used, they CANNOT BE TRUSTED on a vanilla server as they are swapped around\n                // Spigot and forks implement it correctly\n                // Rain strength is your best way for determining if there is any rain\n                RainStrengthValue value = (RainStrengthValue) packet.getValue();\n                boolean isCurrentlyRaining = value.getStrength() > 0f;\n                // Java sends the rain level. Bedrock doesn't care, so we don't care if it's already raining.\n                if (isCurrentlyRaining != session.isRaining()) {\n                    LevelEventPacket changeRainPacket = new LevelEventPacket();\n                    changeRainPacket.setType(isCurrentlyRaining ? LevelEventType.START_RAINING : LevelEventType.STOP_RAINING);\n                    changeRainPacket.setData(Integer.MAX_VALUE); // Dunno what this does; used to be implemented with ThreadLocalRandom\n                    changeRainPacket.setPosition(Vector3f.ZERO);\n                    session.sendUpstreamPacket(changeRainPacket);\n                    session.setRaining(isCurrentlyRaining);\n                }\n                break;\n            case THUNDER_STRENGTH:\n                // See above, same process\n                ThunderStrengthValue thunderValue = (ThunderStrengthValue) packet.getValue();\n                boolean isCurrentlyThundering = thunderValue.getStrength() > 0f;\n                if (isCurrentlyThundering != session.isThunder()) {\n                    LevelEventPacket changeThunderPacket = new LevelEventPacket();\n                    changeThunderPacket.setType(isCurrentlyThundering ? LevelEventType.START_THUNDERSTORM : LevelEventType.STOP_THUNDERSTORM);\n                    changeThunderPacket.setData(Integer.MAX_VALUE);\n                    changeThunderPacket.setPosition(Vector3f.ZERO);\n                    session.sendUpstreamPacket(changeThunderPacket);\n                    session.setThunder(isCurrentlyThundering);\n                }\n                break;\n            case CHANGE_GAMEMODE:\n                GameMode gameMode = (GameMode) packet.getValue();\n\n                SetPlayerGameTypePacket playerGameTypePacket = new SetPlayerGameTypePacket();\n                playerGameTypePacket.setGamemode(gameMode.ordinal());\n                session.sendUpstreamPacket(playerGameTypePacket);\n                session.setGameMode(gameMode);\n\n                session.sendAdventureSettings();\n\n                if (session.getPlayerEntity().isOnGround() && gameMode == GameMode.SPECTATOR) {\n                    // Fix a bug where the player has glitched movement and thinks they are still on the ground\n                    MovePlayerPacket movePlayerPacket = new MovePlayerPacket();\n                    movePlayerPacket.setRuntimeEntityId(entity.getGeyserId());\n                    movePlayerPacket.setPosition(entity.getPosition());\n                    movePlayerPacket.setRotation(entity.getBedrockRotation());\n                    movePlayerPacket.setOnGround(false);\n                    movePlayerPacket.setMode(MovePlayerPacket.Mode.TELEPORT);\n                    movePlayerPacket.setTeleportationCause(MovePlayerPacket.TeleportationCause.UNKNOWN);\n                    session.sendUpstreamPacket(movePlayerPacket);\n                }\n\n                // Update the crafting grid to add/remove barriers for creative inventory\n                PlayerInventoryTranslator.updateCraftingGrid(session, session.getPlayerInventory());\n                break;\n            case ENTER_CREDITS:\n                switch ((EnterCreditsValue) packet.getValue()) {\n                    case SEEN_BEFORE:\n                        ClientRequestPacket javaRespawnPacket = new ClientRequestPacket(ClientRequest.RESPAWN);\n                        session.sendDownstreamPacket(javaRespawnPacket);\n                        break;\n                    case FIRST_TIME:\n                        ShowCreditsPacket showCreditsPacket = new ShowCreditsPacket();\n                        showCreditsPacket.setStatus(ShowCreditsPacket.Status.START_CREDITS);\n                        showCreditsPacket.setRuntimeEntityId(entity.getGeyserId());\n                        session.sendUpstreamPacket(showCreditsPacket);\n                        break;\n                }\n                break;\n            case AFFECTED_BY_ELDER_GUARDIAN:\n                EntityEventPacket eventPacket = new EntityEventPacket();\n                eventPacket.setType(EntityEventType.ELDER_GUARDIAN_CURSE);\n                eventPacket.setData(0);\n                eventPacket.setRuntimeEntityId(entity.getGeyserId());\n                session.sendUpstreamPacket(eventPacket);\n                break;\n            case ENABLE_RESPAWN_SCREEN:\n                GameRulesChangedPacket gamerulePacket = new GameRulesChangedPacket();\n                gamerulePacket.getGameRules().add(new GameRuleData<>(\"doimmediaterespawn\",\n                        packet.getValue() == RespawnScreenValue.IMMEDIATE_RESPAWN));\n                session.sendUpstreamPacket(gamerulePacket);\n                break;\n            case INVALID_BED:\n                // Not sent as a proper message? Odd.\n                session.sendMessage(LocaleUtils.getLocaleString(\"block.minecraft.spawn.not_valid\",\n                        session.getLocale()));\n                break;\n            case ARROW_HIT_PLAYER:\n                PlaySoundPacket arrowSoundPacket = new PlaySoundPacket();\n                arrowSoundPacket.setSound(\"random.orb\");\n                arrowSoundPacket.setPitch(0.5f);\n                arrowSoundPacket.setVolume(0.5f);\n                arrowSoundPacket.setPosition(entity.getPosition());\n                session.sendUpstreamPacket(arrowSoundPacket);\n                break;\n            default:\n                break;\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayBuiltinSoundPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.registry.BlockRegistries;\nimport org.geysermc.connector.utils.SoundUtils;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerPlayBuiltinSoundPacket.class)\npublic class JavaPlayBuiltinSoundTranslator extends PacketTranslator<ServerPlayBuiltinSoundPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayBuiltinSoundPacket packet) {\n        String packetSound = packet.getSound().getName();\n\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound);\n        if (soundMapping == null) {\n            session.getConnector().getLogger().debug(\"[Builtin] Sound mapping \" + packetSound + \" not found - \" + packet.toString());\n            return;\n        }\n\n        if (soundMapping.isLevelEvent()) {\n            LevelEventPacket levelEventPacket = new LevelEventPacket();\n            levelEventPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n            levelEventPacket.setData(0);\n            levelEventPacket.setType(LevelEventType.valueOf(soundMapping.getBedrock()));\n            session.sendUpstreamPacket(levelEventPacket);\n            return;\n        }\n        LevelSoundEventPacket soundPacket = new LevelSoundEventPacket();\n        SoundEvent sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());\n        if (sound == null) {\n            sound = SoundUtils.toSoundEvent(soundMapping.getBedrock());\n        }\n        if (sound == null) {\n            sound = SoundUtils.toSoundEvent(packetSound);\n        }\n        if (sound == null) {\n            session.getConnector().getLogger().debug(\"[Builtin] Sound for original \" + packetSound + \" to mappings \" + soundPacket\n                            + \" was not a playable level sound, or has yet to be mapped to an enum in \"\n                            + \"NukkitX SoundEvent \");\n            return;\n        }\n\n        soundPacket.setSound(sound);\n        soundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        soundPacket.setIdentifier(soundMapping.getIdentifier());\n        if (sound == SoundEvent.NOTE) {\n            // Minecraft Wiki: 2^(x/12) = Java pitch where x is -12 to 12\n            // Java sends the note value as above starting with -12 and ending at 12\n            // Bedrock has a number for each type of note, then proceeds up the scale by adding to that number\n            soundPacket.setExtraData(soundMapping.getExtraData() + (int)(Math.round((Math.log10(packet.getPitch()) / Math.log10(2)) * 12)) + 12);\n        } else if (sound == SoundEvent.PLACE && soundMapping.getExtraData() == -1) {\n            if (!soundMapping.getIdentifier().equals(\":\")) {\n                soundPacket.setExtraData(session.getBlockMappings().getBedrockBlockId(\n                        BlockRegistries.JAVA_IDENTIFIERS.getOrDefault(soundMapping.getIdentifier(), BlockStateValues.JAVA_AIR_ID)));\n            } else {\n                session.getConnector().getLogger().debug(\"PLACE sound mapping identifier was invalid! Please report: \" + packet.toString());\n            }\n            soundPacket.setIdentifier(\":\");\n        } else {\n            soundPacket.setExtraData(soundMapping.getExtraData());\n        }\n\n\n        soundPacket.setBabySound(false); // might need to adjust this in the future\n        soundPacket.setRelativeVolumeDisabled(false);\n        session.sendUpstreamPacket(soundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.effect.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlayEffectPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.SoundEvent;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.LevelSoundEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.TextPacket;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.effect.Effect;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.utils.LocaleUtils;\n\nimport java.util.Collections;\nimport java.util.Locale;\n\n@Translator(packet = ServerPlayEffectPacket.class)\npublic class JavaPlayEffectTranslator extends PacketTranslator<ServerPlayEffectPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlayEffectPacket packet) {\n        // Separate case since each RecordEffectData in Java is an individual track in Bedrock\n        if (packet.getEffect() == SoundEffect.RECORD) {\n            RecordEffectData recordEffectData = (RecordEffectData) packet.getData();\n            SoundEvent soundEvent = Registries.RECORDS.getOrDefault(recordEffectData.getRecordId(), SoundEvent.STOP_RECORD);\n            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);\n\n            LevelSoundEventPacket levelSoundEvent = new LevelSoundEventPacket();\n            levelSoundEvent.setIdentifier(\"\");\n            levelSoundEvent.setSound(soundEvent);\n            levelSoundEvent.setPosition(pos);\n            levelSoundEvent.setRelativeVolumeDisabled(packet.isBroadcast());\n            levelSoundEvent.setExtraData(-1);\n            levelSoundEvent.setBabySound(false);\n            session.sendUpstreamPacket(levelSoundEvent);\n\n            if (soundEvent != SoundEvent.STOP_RECORD) {\n                // Send text packet as it seems to be handled in Java Edition client-side.\n                TextPacket textPacket = new TextPacket();\n                textPacket.setType(TextPacket.Type.JUKEBOX_POPUP);\n                textPacket.setNeedsTranslation(true);\n                textPacket.setXuid(\"\");\n                textPacket.setPlatformChatId(\"\");\n                textPacket.setSourceName(null);\n                textPacket.setMessage(\"record.nowPlaying\");\n                String recordString = \"%item.\" + soundEvent.name().toLowerCase(Locale.ROOT) + \".desc\";\n                textPacket.setParameters(Collections.singletonList(LocaleUtils.getLocaleString(recordString, session.getLocale())));\n                session.sendUpstreamPacket(textPacket);\n            }\n            return;\n        }\n\n        if (packet.getEffect() instanceof SoundEffect) {\n            SoundEffect soundEffect = (SoundEffect) packet.getEffect();\n            Effect geyserEffect = Registries.SOUND_EFFECTS.get(soundEffect);\n            if (geyserEffect != null) {\n                geyserEffect.handleEffectPacket(session, packet);\n                return;\n            }\n            GeyserConnector.getInstance().getLogger().debug(\"Unhandled sound effect: \" + soundEffect.name());\n        } else if (packet.getEffect() instanceof ParticleEffect) {\n            ParticleEffect particleEffect = (ParticleEffect) packet.getEffect();\n            Vector3f pos = Vector3f.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()).add(0.5f, 0.5f, 0.5f);\n\n            LevelEventPacket effectPacket = new LevelEventPacket();\n            effectPacket.setPosition(pos);\n            effectPacket.setData(0);\n            switch (particleEffect) {\n                case COMPOSTER: {\n                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);\n\n                    ComposterEffectData composterEffectData = (ComposterEffectData) packet.getData();\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    switch (composterEffectData) {\n                        case FILL:\n                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL);\n                            break;\n                        case FILL_SUCCESS:\n                            soundEventPacket.setSound(SoundEvent.COMPOSTER_FILL_LAYER);\n                            break;\n                    }\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_LAVA_EXTINGUISH: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.7f, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_REDSTONE_TORCH_BURNOUT: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXTINGUISH_FIRE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BLOCK_END_PORTAL_FRAME_FILL: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.3125f, -0.5f));\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.BLOCK_END_PORTAL_FRAME_FILL);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case SMOKE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_SHOOT);\n\n                    SmokeEffectData smokeEffectData = (SmokeEffectData) packet.getData();\n                    int data = 0;\n                    switch (smokeEffectData) {\n                        case DOWN:\n                            data = 4;\n                            pos = pos.add(0, -0.9f, 0);\n                            break;\n                        case UP:\n                            data = 4;\n                            pos = pos.add(0, 0.5f, 0);\n                            break;\n                        case NORTH:\n                            data = 1;\n                            pos = pos.add(0, -0.2f, -0.7f);\n                            break;\n                        case SOUTH:\n                            data = 7;\n                            pos = pos.add(0, -0.2f, 0.7f);\n                            break;\n                        case WEST:\n                            data = 3;\n                            pos = pos.add(-0.7f, -0.2f, 0);\n                            break;\n                        case EAST:\n                            data = 5;\n                            pos = pos.add(0.7f, -0.2f, 0);\n                            break;\n\n                    }\n                    effectPacket.setPosition(pos);\n                    effectPacket.setData(data);\n                    break;\n                }\n                //TODO: Block break particles when under fire\n                case BREAK_BLOCK: {\n                    effectPacket.setType(LevelEventType.PARTICLE_DESTROY_BLOCK);\n\n                    BreakBlockEffectData breakBlockEffectData = (BreakBlockEffectData) packet.getData();\n                    effectPacket.setData(session.getBlockMappings().getBedrockBlockId(breakBlockEffectData.getBlockState()));\n                    break;\n                }\n                case BREAK_SPLASH_POTION: {\n                    effectPacket.setType(LevelEventType.PARTICLE_POTION_SPLASH);\n                    effectPacket.setPosition(pos.add(0, -0.5f, 0));\n\n                    BreakPotionEffectData splashPotionData = (BreakPotionEffectData) packet.getData();\n                    effectPacket.setData(splashPotionData.getPotionId());\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.GLASS);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case BREAK_EYE_OF_ENDER: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH);\n                    break;\n                }\n                case MOB_SPAWN: {\n                    effectPacket.setType(LevelEventType.PARTICLE_MOB_BLOCK_SPAWN); // TODO: Check, but I don't think I really verified this ever went into effect on Java\n                    break;\n                }\n                case BONEMEAL_GROW_WITH_SOUND: // Note that there is no particle without sound in Bedrock. If you wanted to implement the sound, send a PlaySoundPacket with \"item.bone_meal.use\" and volume and pitch at 1.0F\n                case BONEMEAL_GROW: {\n                    effectPacket.setType(LevelEventType.PARTICLE_CROP_GROWTH);\n\n                    BonemealGrowEffectData growEffectData = (BonemealGrowEffectData) packet.getData();\n                    effectPacket.setData(growEffectData.getParticleCount());\n                    break;\n                }\n                case ENDERDRAGON_FIREBALL_EXPLODE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EYE_OF_ENDER_DEATH); // TODO\n\n                    DragonFireballEffectData fireballEffectData = (DragonFireballEffectData) packet.getData();\n                    if (fireballEffectData == DragonFireballEffectData.HAS_SOUND) {\n                        LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                        soundEventPacket.setSound(SoundEvent.EXPLODE);\n                        soundEventPacket.setPosition(pos);\n                        soundEventPacket.setIdentifier(\"\");\n                        soundEventPacket.setExtraData(-1);\n                        soundEventPacket.setBabySound(false);\n                        soundEventPacket.setRelativeVolumeDisabled(false);\n                        session.sendUpstreamPacket(soundEventPacket);\n                    }\n                    break;\n                }\n                case EXPLOSION: {\n                    effectPacket.setType(LevelEventType.PARTICLE_GENERIC_SPAWN);\n                    effectPacket.setData(61);\n                    break;\n                }\n                case EVAPORATE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EVAPORATE_WATER);\n                    effectPacket.setPosition(pos.add(-0.5f, 0.5f, -0.5f));\n                    break;\n                }\n                case END_GATEWAY_SPAWN: {\n                    effectPacket.setType(LevelEventType.PARTICLE_EXPLOSION);\n\n                    LevelSoundEventPacket soundEventPacket = new LevelSoundEventPacket();\n                    soundEventPacket.setSound(SoundEvent.EXPLODE);\n                    soundEventPacket.setPosition(pos);\n                    soundEventPacket.setIdentifier(\"\");\n                    soundEventPacket.setExtraData(-1);\n                    soundEventPacket.setBabySound(false);\n                    soundEventPacket.setRelativeVolumeDisabled(false);\n                    session.sendUpstreamPacket(soundEventPacket);\n                    break;\n                }\n                case DRIPSTONE_DRIP: {\n                    effectPacket.setType(LevelEventType.PARTICLE_DRIPSTONE_DRIP);\n                    break;\n                }\n                case ELECTRIC_SPARK: {\n                    // Matches with a Bedrock server but doesn't seem to match up with Java\n                    effectPacket.setType(LevelEventType.PARTICLE_ELECTRIC_SPARK);\n                    break;\n                }\n                case WAX_ON: {\n                    effectPacket.setType(LevelEventType.PARTICLE_WAX_ON);\n                    break;\n                }\n                case WAX_OFF: {\n                    effectPacket.setType(LevelEventType.PARTICLE_WAX_OFF);\n                    break;\n                }\n                case SCRAPE: {\n                    effectPacket.setType(LevelEventType.PARTICLE_SCRAPE);\n                    break;\n                }\n                default: {\n                    GeyserConnector.getInstance().getLogger().debug(\"Unhandled particle effect: \" + particleEffect.name());\n                    return;\n                }\n            }\n            session.sendUpstreamPacket(effectPacket);\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;\nimport com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerPlaySoundPacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.packet.*;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerPlaySoundPacket.class)\npublic class JavaPlaySoundTranslator extends PacketTranslator<ServerPlaySoundPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerPlaySoundPacket packet) {\n        String packetSound;\n        if (packet.getSound() instanceof BuiltinSound) {\n            packetSound = ((BuiltinSound) packet.getSound()).getName();\n        } else if (packet.getSound() instanceof CustomSound) {\n            packetSound = ((CustomSound) packet.getSound()).getName();\n        } else {\n            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());\n            return;\n        }\n\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));\n        String playsound;\n        if (soundMapping == null || soundMapping.getPlaysound() == null) {\n            // no mapping\n            session.getConnector().getLogger()\n                    .debug(\"[PlaySound] Defaulting to sound server gave us for \" + packet.toString());\n            playsound = packetSound.replace(\"minecraft:\", \"\");\n        } else {\n            playsound = soundMapping.getPlaysound();\n        }\n\n        PlaySoundPacket playSoundPacket = new PlaySoundPacket();\n        playSoundPacket.setSound(playsound);\n        playSoundPacket.setPosition(Vector3f.from(packet.getX(), packet.getY(), packet.getZ()));\n        playSoundPacket.setVolume(packet.getVolume());\n        playSoundPacket.setPitch(packet.getPitch());\n\n        session.sendUpstreamPacket(playSoundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.world.particle.*;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnParticlePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport com.nukkitx.protocol.bedrock.BedrockPacket;\nimport com.nukkitx.protocol.bedrock.data.LevelEventType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.LevelEventPacket;\nimport com.nukkitx.protocol.bedrock.packet.SpawnParticleEffectPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.ParticleMapping;\nimport org.geysermc.connector.utils.DimensionUtils;\n\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.function.Function;\n\n@Translator(packet = ServerSpawnParticlePacket.class)\npublic class JavaSpawnParticleTranslator extends PacketTranslator<ServerSpawnParticlePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnParticlePacket packet) {\n        Function<Vector3f, BedrockPacket> particleCreateFunction = createParticle(session, packet.getParticle());\n        if (particleCreateFunction != null) {\n            if (packet.getAmount() == 0) {\n                // 0 means don't apply the offset\n                Vector3f position = Vector3f.from(packet.getX(), packet.getY(), packet.getZ());\n                session.sendUpstreamPacket(particleCreateFunction.apply(position));\n            } else {\n                Random random = ThreadLocalRandom.current();\n                for (int i = 0; i < packet.getAmount(); i++) {\n                    double offsetX = random.nextGaussian() * (double) packet.getOffsetX();\n                    double offsetY = random.nextGaussian() * (double) packet.getOffsetY();\n                    double offsetZ = random.nextGaussian() * (double) packet.getOffsetZ();\n                    Vector3f position = Vector3f.from(packet.getX() + offsetX, packet.getY() + offsetY, packet.getZ() + offsetZ);\n\n                    session.sendUpstreamPacket(particleCreateFunction.apply(position));\n                }\n            }\n        } else {\n            // Null is only returned when no particle of this type is found\n            session.getConnector().getLogger().debug(\"Unhandled particle packet: \" + packet);\n        }\n    }\n\n    /**\n     * @param session the Bedrock client session.\n     * @param particle the Java particle to translate to a Bedrock equivalent.\n     * @return a function to create a packet with a specified particle, in the event we need to spawn multiple particles\n     * with different offsets.\n     */\n    private Function<Vector3f, BedrockPacket> createParticle(GeyserSession session, Particle particle) {\n        switch (particle.getType()) {\n            case BLOCK: {\n                int blockState = session.getBlockMappings().getBedrockBlockId(((BlockParticleData) particle.getData()).getBlockState());\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_CRACK_BLOCK);\n                    packet.setPosition(position);\n                    packet.setData(blockState);\n                    return packet;\n                };\n            }\n            case FALLING_DUST: {\n                int blockState = session.getBlockMappings().getBedrockBlockId(((FallingDustParticleData) particle.getData()).getBlockState());\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    // In fact, FallingDustParticle should have data like DustParticle,\n                    // but in MCProtocol, its data is BlockState(1).\n                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);\n                    packet.setData(blockState);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            case ITEM: {\n                ItemStack javaItem = ((ItemParticleData) particle.getData()).getItemStack();\n                ItemData bedrockItem = ItemTranslator.translateToBedrock(session, javaItem);\n                int data = bedrockItem.getId() << 16 | bedrockItem.getDamage();\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_ITEM_BREAK);\n                    packet.setData(data);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            case DUST:\n            case DUST_COLOR_TRANSITION: { //TODO\n                DustParticleData data = (DustParticleData) particle.getData();\n                int r = (int) (data.getRed() * 255);\n                int g = (int) (data.getGreen() * 255);\n                int b = (int) (data.getBlue() * 255);\n                int rgbData = ((0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);\n                return (position) -> {\n                    LevelEventPacket packet = new LevelEventPacket();\n                    packet.setType(LevelEventType.PARTICLE_FALLING_DUST);\n                    packet.setData(rgbData);\n                    packet.setPosition(position);\n                    return packet;\n                };\n            }\n            default: {\n                ParticleMapping particleMapping = Registries.PARTICLES.get(particle.getType());\n                if (particleMapping == null) { //TODO ensure no particle can be null\n                    return null;\n                }\n\n                if (particleMapping.getLevelEventType() != null) {\n                    return (position) -> {\n                        LevelEventPacket packet = new LevelEventPacket();\n                        packet.setType(particleMapping.getLevelEventType());\n                        packet.setPosition(position);\n                        return packet;\n                    };\n                } else if (particleMapping.getIdentifier() != null) {\n                    int dimensionId = DimensionUtils.javaToBedrock(session.getDimension());\n                    return (position) -> {\n                        SpawnParticleEffectPacket stringPacket = new SpawnParticleEffectPacket();\n                        stringPacket.setIdentifier(particleMapping.getIdentifier());\n                        stringPacket.setDimensionId(dimensionId);\n                        stringPacket.setPosition(position);\n                        return stringPacket;\n                    };\n                } else {\n                    return null;\n                }\n            }\n        }\n    }\n}", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerSpawnPositionPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.protocol.bedrock.packet.SetSpawnPositionPacket;\nimport org.geysermc.connector.utils.DimensionUtils;\n\n@Translator(packet = ServerSpawnPositionPacket.class)\npublic class JavaSpawnPositionTranslator extends PacketTranslator<ServerSpawnPositionPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerSpawnPositionPacket packet) {\n        SetSpawnPositionPacket spawnPositionPacket = new SetSpawnPositionPacket();\n        spawnPositionPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n        spawnPositionPacket.setSpawnForced(true);\n        spawnPositionPacket.setDimensionId(DimensionUtils.javaToBedrock(session.getDimension()));\n        spawnPositionPacket.setSpawnType(SetSpawnPositionPacket.Type.WORLD_SPAWN);\n        session.sendUpstreamPacket(spawnPositionPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.world.sound.BuiltinSound;\nimport com.github.steveice10.mc.protocol.data.game.world.sound.CustomSound;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.ServerStopSoundPacket;\nimport com.nukkitx.protocol.bedrock.packet.StopSoundPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.registry.Registries;\nimport org.geysermc.connector.registry.type.SoundMapping;\n\n@Translator(packet = ServerStopSoundPacket.class)\npublic class JavaStopSoundTranslator extends PacketTranslator<ServerStopSoundPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerStopSoundPacket packet) {\n        // Runs if all sounds are stopped\n        if (packet.getSound() == null) {\n            StopSoundPacket stopPacket = new StopSoundPacket();\n            stopPacket.setStoppingAllSound(true);\n            stopPacket.setSoundName(\"\");\n            session.sendUpstreamPacket(stopPacket);\n            return;\n        }\n\n        String packetSound;\n        if (packet.getSound() instanceof BuiltinSound) {\n            packetSound = ((BuiltinSound) packet.getSound()).getName();\n        } else if (packet.getSound() instanceof CustomSound) {\n            packetSound = ((CustomSound) packet.getSound()).getName();\n        } else {\n            session.getConnector().getLogger().debug(\"Unknown sound packet, we were unable to map this. \" + packet.toString());\n            return;\n        }\n        SoundMapping soundMapping = Registries.SOUNDS.get(packetSound.replace(\"minecraft:\", \"\"));\n        session.getConnector().getLogger()\n                .debug(\"[StopSound] Sound mapping \" + packetSound + \" -> \"\n                        + soundMapping + (soundMapping == null ? \"[not found]\" : \"\")\n                        + \" - \" + packet.toString());\n        String playsound;\n        if (soundMapping == null || soundMapping.getPlaysound() == null) {\n            // no mapping\n            session.getConnector().getLogger()\n                    .debug(\"[StopSound] Defaulting to sound server gave us.\");\n            playsound = packetSound;\n        } else {\n            playsound = soundMapping.getPlaysound();\n        }\n\n        StopSoundPacket stopSoundPacket = new StopSoundPacket();\n        stopSoundPacket.setSoundName(playsound);\n        // packet not mapped in the library\n        stopSoundPacket.setStoppingAllSound(false);\n\n        session.sendUpstreamPacket(stopSoundPacket);\n        session.getConnector().getLogger().debug(\"[StopSound] Packet sent - \" + packet.toString() + \" --> \" + stopSoundPacket);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.metadata.ItemStack;\nimport com.github.steveice10.mc.protocol.data.game.window.VillagerTrade;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.window.ServerTradeListPacket;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.nbt.NbtMapBuilder;\nimport com.nukkitx.nbt.NbtType;\nimport com.nukkitx.protocol.bedrock.data.entity.EntityData;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.data.inventory.ItemData;\nimport com.nukkitx.protocol.bedrock.packet.UpdateTradePacket;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.inventory.Inventory;\nimport org.geysermc.connector.inventory.MerchantContainer;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.item.ItemTranslator;\nimport org.geysermc.connector.registry.type.ItemMapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Translator(packet = ServerTradeListPacket.class)\npublic class JavaTradeListTranslator extends PacketTranslator<ServerTradeListPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerTradeListPacket packet) {\n        Inventory openInventory = session.getOpenInventory();\n        if (!(openInventory instanceof MerchantContainer && openInventory.getId() == packet.getWindowId())) {\n            return;\n        }\n\n        // Retrieve the fake villager involved in the trade, and update its metadata to match with the window information\n        MerchantContainer merchantInventory = (MerchantContainer) openInventory;\n        merchantInventory.setVillagerTrades(packet.getTrades());\n        Entity villager = merchantInventory.getVillager();\n        villager.getMetadata().put(EntityData.TRADE_TIER, packet.getVillagerLevel() - 1);\n        villager.getMetadata().put(EntityData.MAX_TRADE_TIER, 4);\n        villager.getMetadata().put(EntityData.TRADE_XP, packet.getExperience());\n        villager.updateBedrockMetadata(session);\n\n        // Construct the packet that opens the trading window\n        UpdateTradePacket updateTradePacket = new UpdateTradePacket();\n        updateTradePacket.setTradeTier(packet.getVillagerLevel() - 1);\n        updateTradePacket.setContainerId((short) packet.getWindowId());\n        updateTradePacket.setContainerType(ContainerType.TRADE);\n        updateTradePacket.setDisplayName(openInventory.getTitle());\n        updateTradePacket.setSize(0);\n        updateTradePacket.setNewTradingUi(true);\n        updateTradePacket.setUsingEconomyTrade(true);\n        updateTradePacket.setPlayerUniqueEntityId(session.getPlayerEntity().getGeyserId());\n        updateTradePacket.setTraderUniqueEntityId(villager.getGeyserId());\n\n        NbtMapBuilder builder = NbtMap.builder();\n        boolean addExtraTrade = packet.isRegularVillager() && packet.getVillagerLevel() < 5;\n        List<NbtMap> tags = new ArrayList<>(addExtraTrade ? packet.getTrades().length + 1 : packet.getTrades().length);\n        for (int i = 0; i < packet.getTrades().length; i++) {\n            VillagerTrade trade = packet.getTrades()[i];\n            NbtMapBuilder recipe = NbtMap.builder();\n            recipe.putInt(\"netId\", i + 1);\n            recipe.putInt(\"maxUses\", trade.isTradeDisabled() ? 0 : trade.getMaxUses());\n            recipe.putInt(\"traderExp\", trade.getXp());\n            recipe.putFloat(\"priceMultiplierA\", trade.getPriceMultiplier());\n            recipe.put(\"sell\", getItemTag(session, trade.getOutput(), 0));\n            recipe.putFloat(\"priceMultiplierB\", 0.0f);\n            recipe.putInt(\"buyCountB\", trade.getSecondInput() != null ? trade.getSecondInput().getAmount() : 0);\n            recipe.putInt(\"buyCountA\", trade.getFirstInput().getAmount());\n            recipe.putInt(\"demand\", trade.getDemand());\n            recipe.putInt(\"tier\", packet.getVillagerLevel() > 0 ? packet.getVillagerLevel() - 1 : 0); // -1 crashes client\n            recipe.put(\"buyA\", getItemTag(session, trade.getFirstInput(), trade.getSpecialPrice()));\n            if (trade.getSecondInput() != null) {\n                recipe.put(\"buyB\", getItemTag(session, trade.getSecondInput(), 0));\n            }\n            recipe.putInt(\"uses\", trade.getNumUses());\n            recipe.putByte(\"rewardExp\", (byte) 1);\n            tags.add(recipe.build());\n        }\n\n        //Hidden trade to fix visual experience bug\n        if (addExtraTrade) {\n            tags.add(NbtMap.builder()\n                    .putInt(\"maxUses\", 0)\n                    .putInt(\"traderExp\", 0)\n                    .putFloat(\"priceMultiplierA\", 0.0f)\n                    .putFloat(\"priceMultiplierB\", 0.0f)\n                    .putInt(\"buyCountB\", 0)\n                    .putInt(\"buyCountA\", 0)\n                    .putInt(\"demand\", 0)\n                    .putInt(\"tier\", 5)\n                    .putInt(\"uses\", 0)\n                    .putByte(\"rewardExp\", (byte) 0)\n                    .build());\n        }\n\n        builder.putList(\"Recipes\", NbtType.COMPOUND, tags);\n\n        List<NbtMap> expTags = new ArrayList<>(5);\n        expTags.add(NbtMap.builder().putInt(\"0\", 0).build());\n        expTags.add(NbtMap.builder().putInt(\"1\", 10).build());\n        expTags.add(NbtMap.builder().putInt(\"2\", 70).build());\n        expTags.add(NbtMap.builder().putInt(\"3\", 150).build());\n        expTags.add(NbtMap.builder().putInt(\"4\", 250).build());\n        builder.putList(\"TierExpRequirements\", NbtType.COMPOUND, expTags);\n\n        updateTradePacket.setOffers(builder.build());\n        session.sendUpstreamPacket(updateTradePacket);\n    }\n\n    private NbtMap getItemTag(GeyserSession session, ItemStack stack, int specialPrice) {\n        ItemData itemData = ItemTranslator.translateToBedrock(session, stack);\n        ItemMapping mapping = session.getItemMappings().getMapping(stack);\n\n        NbtMapBuilder builder = NbtMap.builder();\n        builder.putByte(\"Count\", (byte) (Math.max(itemData.getCount() + specialPrice, 1)));\n        builder.putShort(\"Damage\", (short) itemData.getDamage());\n        builder.putString(\"Name\", mapping.getBedrockIdentifier());\n        if (itemData.getTag() != null) {\n            NbtMap tag = itemData.getTag().toBuilder().build();\n            builder.put(\"tag\", tag);\n        }\n\n        NbtMap blockTag = session.getBlockMappings().getBedrockBlockNbt(mapping.getJavaIdentifier());\n        if (blockTag != null) {\n            // This fixes certain blocks being unable to stack after grabbing one\n            builder.putCompound(\"Block\", blockTag);\n            builder.putShort(\"Damage\", (short) 0);\n        }\n\n        return builder.build();\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUnloadChunkPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport java.util.Iterator;\n\n@Translator(packet = ServerUnloadChunkPacket.class)\npublic class JavaUnloadChunkTranslator extends PacketTranslator<ServerUnloadChunkPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUnloadChunkPacket packet) {\n        session.getChunkCache().removeChunk(packet.getX(), packet.getZ());\n\n        //Checks if a skull is in an unloaded chunk then removes it\n        Iterator<Vector3i> iterator = session.getSkullCache().keySet().iterator();\n        while (iterator.hasNext()) {\n            Vector3i position = iterator.next();\n            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {\n                session.getSkullCache().get(position).despawnEntity(session);\n                iterator.remove();\n            }\n        }\n\n        // Do the same thing with lecterns\n        iterator = session.getLecternCache().iterator();\n        while (iterator.hasNext()) {\n            Vector3i position = iterator.next();\n            if ((position.getX() >> 4) == packet.getX() && (position.getZ() >> 4) == packet.getZ()) {\n                iterator.remove();\n            }\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.data.game.entity.player.GameMode;\nimport com.github.steveice10.mc.protocol.data.game.world.block.UpdatedTileType;\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTileEntityPacket;\nimport com.nukkitx.math.vector.Vector3i;\nimport com.nukkitx.nbt.NbtMap;\nimport com.nukkitx.protocol.bedrock.data.inventory.ContainerType;\nimport com.nukkitx.protocol.bedrock.packet.ContainerOpenPacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.network.translators.world.block.BlockStateValues;\nimport org.geysermc.connector.network.translators.world.block.entity.BlockEntityTranslator;\nimport org.geysermc.connector.network.translators.world.block.entity.RequiresBlockState;\nimport org.geysermc.connector.network.translators.world.block.entity.SkullBlockEntityTranslator;\nimport org.geysermc.connector.utils.BlockEntityUtils;\n\n@Translator(packet = ServerUpdateTileEntityPacket.class)\npublic class JavaUpdateTileEntityTranslator extends PacketTranslator<ServerUpdateTileEntityPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUpdateTileEntityPacket packet) {\n        String id = BlockEntityUtils.getBedrockBlockEntityId(packet.getType().name());\n        if (packet.getNbt().isEmpty()) { // Fixes errors in servers sending empty NBT\n            BlockEntityUtils.updateBlockEntity(session, NbtMap.EMPTY, packet.getPosition());\n            return;\n        }\n\n        BlockEntityTranslator translator = BlockEntityUtils.getBlockEntityTranslator(id);\n        // The Java block state is used in BlockEntityTranslator.translateTag() to make up for some inconsistencies\n        // between Java block states and Bedrock block entity data\n        int blockState;\n        if (translator instanceof RequiresBlockState) {\n            blockState = session.getConnector().getWorldManager().getBlockAt(session, packet.getPosition());\n        } else {\n            blockState = BlockStateValues.JAVA_AIR_ID;\n        }\n        BlockEntityUtils.updateBlockEntity(session, translator.getBlockEntityTag(id, packet.getNbt(), blockState), packet.getPosition());\n        // Check for custom skulls.\n        if (SkullBlockEntityTranslator.ALLOW_CUSTOM_SKULLS && packet.getNbt().contains(\"SkullOwner\")) {\n            SkullBlockEntityTranslator.spawnPlayer(session, packet.getNbt(), blockState);\n        }\n\n        // If block entity is command block, OP permission level is appropriate, player is in creative mode and the NBT is not empty\n        if (packet.getType() == UpdatedTileType.COMMAND_BLOCK && session.getOpPermissionLevel() >= 2 &&\n                session.getGameMode() == GameMode.CREATIVE && packet.getNbt().size() > 5) {\n            ContainerOpenPacket openPacket = new ContainerOpenPacket();\n            openPacket.setBlockPosition(Vector3i.from(packet.getPosition().getX(), packet.getPosition().getY(), packet.getPosition().getZ()));\n            openPacket.setId((byte) 1);\n            openPacket.setType(ContainerType.COMMAND_BLOCK);\n            openPacket.setUniqueEntityId(-1);\n            session.sendUpstreamPacket(openPacket);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateTimePacket;\nimport com.nukkitx.protocol.bedrock.packet.SetTimePacket;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerUpdateTimePacket.class)\npublic class JavaUpdateTimeTranslator extends PacketTranslator<ServerUpdateTimePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUpdateTimePacket packet) {\n        // Bedrock sends a GameRulesChangedPacket if there is no daylight cycle\n        // Java just sends a negative long if there is no daylight cycle\n        long time = packet.getTime();\n\n        // https://minecraft.gamepedia.com/Day-night_cycle#24-hour_Minecraft_day\n        SetTimePacket setTimePacket = new SetTimePacket();\n        setTimePacket.setTime((int) Math.abs(time) % 24000);\n        session.sendUpstreamPacket(setTimePacket);\n        if (!session.isDaylightCycle() && time >= 0) {\n            // Client thinks there is no daylight cycle but there is\n            session.setDaylightCycle(true);\n        } else if (session.isDaylightCycle() && time < 0) {\n            // Client thinks there is daylight cycle but there isn't\n            session.setDaylightCycle(false);\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewDistancePacket;\n\n@Translator(packet = ServerUpdateViewDistancePacket.class)\npublic class JavaUpdateViewDistanceTranslator extends PacketTranslator<ServerUpdateViewDistancePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUpdateViewDistancePacket packet) {\n        session.setRenderDistance(packet.getViewDistance());\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\nimport org.geysermc.connector.utils.ChunkUtils;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.world.ServerUpdateViewPositionPacket;\nimport com.nukkitx.math.vector.Vector3i;\n\n@Translator(packet = ServerUpdateViewPositionPacket.class)\npublic class JavaUpdateViewPositionTranslator extends PacketTranslator<ServerUpdateViewPositionPacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerUpdateViewPositionPacket packet) {\n        if (!session.isSpawned() && session.getLastChunkPosition() == null) {\n            ChunkUtils.updateChunkPosition(session, Vector3i.from(packet.getChunkX() << 4, 64, packet.getChunkZ() << 4));\n        }\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.network.translators.java.world;\n\nimport com.github.steveice10.mc.protocol.packet.ingame.server.entity.ServerVehicleMovePacket;\nimport com.nukkitx.math.vector.Vector3f;\nimport org.geysermc.connector.entity.Entity;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.translators.PacketTranslator;\nimport org.geysermc.connector.network.translators.Translator;\n\n@Translator(packet = ServerVehicleMovePacket.class)\npublic class JavaVehicleMoveTranslator extends PacketTranslator<ServerVehicleMovePacket> {\n\n    @Override\n    public void translate(GeyserSession session, ServerVehicleMovePacket packet) {\n        Entity entity = session.getRidingVehicleEntity();\n        if (entity == null) return;\n\n        entity.moveAbsolute(session, Vector3f.from(packet.getX(), packet.getY(), packet.getZ()), packet.getYaw(), packet.getPitch(), false, true);\n    }\n}\n", "/*\n * Copyright (c) 2019-2021 GeyserMC. http://geysermc.org\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author GeyserMC\n * @link https://github.com/GeyserMC/Geyser\n */\n\npackage org.geysermc.connector.utils;\n\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.JsonNodeType;\nimport com.github.steveice10.mc.auth.service.MsaAuthenticationService;\nimport com.nimbusds.jose.JWSObject;\nimport com.nimbusds.jose.shaded.json.JSONObject;\nimport com.nimbusds.jose.shaded.json.JSONValue;\nimport com.nukkitx.network.util.Preconditions;\nimport com.nukkitx.protocol.bedrock.packet.LoginPacket;\nimport com.nukkitx.protocol.bedrock.packet.ServerToClientHandshakePacket;\nimport com.nukkitx.protocol.bedrock.util.EncryptionUtils;\nimport org.geysermc.connector.GeyserConnector;\nimport org.geysermc.connector.configuration.GeyserConfiguration;\nimport org.geysermc.connector.network.session.GeyserSession;\nimport org.geysermc.connector.network.session.auth.AuthData;\nimport org.geysermc.connector.network.session.auth.BedrockClientData;\nimport org.geysermc.cumulus.CustomForm;\nimport org.geysermc.cumulus.ModalForm;\nimport org.geysermc.cumulus.SimpleForm;\nimport org.geysermc.cumulus.response.CustomFormResponse;\nimport org.geysermc.cumulus.response.ModalFormResponse;\nimport org.geysermc.cumulus.response.SimpleFormResponse;\n\nimport javax.crypto.SecretKey;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PublicKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECGenParameterSpec;\nimport java.util.UUID;\n\npublic class LoginEncryptionUtils {\n    private static final ObjectMapper JSON_MAPPER = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n\n    private static boolean HAS_SENT_ENCRYPTION_MESSAGE = false;\n\n    private static boolean validateChainData(JsonNode data) throws Exception {\n        if (data.size() != 3) {\n            return false;\n        }\n\n        ECPublicKey lastKey = null;\n        boolean validChain = false;\n        for (JsonNode node : data) {\n            JWSObject jwt = JWSObject.parse(node.asText());\n\n            // x509 cert is expected in every claim\n            URI x5u = jwt.getHeader().getX509CertURL();\n            if (x5u == null) {\n                return false;\n            }\n\n            ECPublicKey expectedKey = EncryptionUtils.generateKey(jwt.getHeader().getX509CertURL().toString());\n            // First key is self-signed\n            if (lastKey == null) {\n                lastKey = expectedKey;\n            } else if (!lastKey.equals(expectedKey)) {\n                return false;\n            }\n\n            if (!EncryptionUtils.verifyJwt(jwt, lastKey)) {\n                return false;\n            }\n\n            if (lastKey.equals(EncryptionUtils.getMojangPublicKey())) {\n                validChain = true;\n            }\n\n            Object payload = JSONValue.parse(jwt.getPayload().toString());\n            Preconditions.checkArgument(payload instanceof JSONObject, \"Payload is not an object\");\n\n            Object identityPublicKey = ((JSONObject) payload).get(\"identityPublicKey\");\n            Preconditions.checkArgument(identityPublicKey instanceof String, \"identityPublicKey node is missing in chain\");\n            lastKey = EncryptionUtils.generateKey((String) identityPublicKey);\n        }\n\n        return validChain;\n    }\n\n    public static void encryptPlayerConnection(GeyserSession session, LoginPacket loginPacket) {\n        JsonNode certData;\n        try {\n            certData = JSON_MAPPER.readTree(loginPacket.getChainData().toByteArray());\n        } catch (IOException ex) {\n            throw new RuntimeException(\"Certificate JSON can not be read.\");\n        }\n\n        JsonNode certChainData = certData.get(\"chain\");\n        if (certChainData.getNodeType() != JsonNodeType.ARRAY) {\n            throw new RuntimeException(\"Certificate data is not valid\");\n        }\n\n        encryptConnectionWithCert(session, loginPacket.getSkinData().toString(), certChainData);\n    }\n\n    private static void encryptConnectionWithCert(GeyserSession session, String clientData, JsonNode certChainData) {\n        try {\n            GeyserConnector connector = session.getConnector();\n\n            boolean validChain = validateChainData(certChainData);\n\n            connector.getLogger().debug(String.format(\"Is player data valid? %s\", validChain));\n\n            if (!validChain && !session.getConnector().getConfig().isEnableProxyConnections()) {\n                session.disconnect(LanguageUtils.getLocaleStringLog(\"geyser.network.remote.invalid_xbox_account\"));\n                return;\n            }\n            JWSObject jwt = JWSObject.parse(certChainData.get(certChainData.size() - 1).asText());\n            JsonNode payload = JSON_MAPPER.readTree(jwt.getPayload().toBytes());\n\n            if (payload.get(\"extraData\").getNodeType() != JsonNodeType.OBJECT) {\n                throw new RuntimeException(\"AuthData was not found!\");\n            }\n\n            JsonNode extraData = payload.get(\"extraData\");\n            session.setAuthenticationData(new AuthData(\n                    extraData.get(\"displayName\").asText(),\n                    UUID.fromString(extraData.get(\"identity\").asText()),\n                    extraData.get(\"XUID\").asText(),\n                    certChainData, clientData\n            ));\n\n            if (payload.get(\"identityPublicKey\").getNodeType() != JsonNodeType.STRING) {\n                throw new RuntimeException(\"Identity Public Key was not found!\");\n            }\n\n            ECPublicKey identityPublicKey = EncryptionUtils.generateKey(payload.get(\"identityPublicKey\").textValue());\n            JWSObject clientJwt = JWSObject.parse(clientData);\n            EncryptionUtils.verifyJwt(clientJwt, identityPublicKey);\n\n            JsonNode clientDataJson = JSON_MAPPER.readTree(clientJwt.getPayload().toBytes());\n            BedrockClientData data = JSON_MAPPER.convertValue(clientDataJson, BedrockClientData.class);\n            session.setClientData(data);\n\n            if (EncryptionUtils.canUseEncryption()) {\n                try {\n                    LoginEncryptionUtils.startEncryptionHandshake(session, identityPublicKey);\n                } catch (Throwable e) {\n                    // An error can be thrown on older Java 8 versions about an invalid key\n                    if (connector.getConfig().isDebugMode()) {\n                        e.printStackTrace();\n                    }\n\n                    sendEncryptionFailedMessage(connector);\n                }\n            } else {\n                sendEncryptionFailedMessage(connector);\n            }\n        } catch (Exception ex) {\n            session.disconnect(\"disconnectionScreen.internalError.cantConnect\");\n            throw new RuntimeException(\"Unable to complete login\", ex);\n        }\n    }\n\n    private static void startEncryptionHandshake(GeyserSession session, PublicKey key) throws Exception {\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"EC\");\n        generator.initialize(new ECGenParameterSpec(\"secp384r1\"));\n        KeyPair serverKeyPair = generator.generateKeyPair();\n\n        byte[] token = EncryptionUtils.generateRandomToken();\n        SecretKey encryptionKey = EncryptionUtils.getSecretKey(serverKeyPair.getPrivate(), key, token);\n        session.getUpstream().getSession().enableEncryption(encryptionKey);\n\n        ServerToClientHandshakePacket packet = new ServerToClientHandshakePacket();\n        packet.setJwt(EncryptionUtils.createHandshakeJwt(serverKeyPair, token).serialize());\n        session.sendUpstreamPacketImmediately(packet);\n    }\n\n    private static void sendEncryptionFailedMessage(GeyserConnector connector) {\n        if (!HAS_SENT_ENCRYPTION_MESSAGE) {\n            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_1\"));\n            connector.getLogger().warning(LanguageUtils.getLocaleStringLog(\"geyser.network.encryption.line_2\", \"https://geysermc.org/supported_java\"));\n            HAS_SENT_ENCRYPTION_MESSAGE = true;\n        }\n    }\n\n    public static void buildAndShowLoginWindow(GeyserSession session) {\n        // Set DoDaylightCycle to false so the time doesn't accelerate while we're here\n        session.setDaylightCycle(false);\n\n        GeyserConfiguration config = session.getConnector().getConfig();\n        boolean isPasswordAuthEnabled = config.getRemote().isPasswordAuthentication();\n\n        session.sendForm(\n                SimpleForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.notice.title\")\n                        .content(\"geyser.auth.login.form.notice.desc\")\n                        .optionalButton(\"geyser.auth.login.form.notice.btn_login.mojang\", isPasswordAuthEnabled)\n                        .button(\"geyser.auth.login.form.notice.btn_login.microsoft\")\n                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            SimpleFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginWindow(session);\n                                return;\n                            }\n\n                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 0) {\n                                session.setMicrosoftAccount(false);\n                                buildAndShowLoginDetailsWindow(session);\n                                return;\n                            }\n\n                            if (isPasswordAuthEnabled && response.getClickedButtonId() == 1) {\n                                session.setMicrosoftAccount(true);\n                                buildAndShowMicrosoftAuthenticationWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 0) {\n                                // Just show the OAuth code\n                                session.authenticateWithMicrosoftCode();\n                                return;\n                            }\n\n                            session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                        }));\n    }\n\n    public static void buildAndShowLoginDetailsWindow(GeyserSession session) {\n        session.sendForm(\n                CustomForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.details.title\")\n                        .label(\"geyser.auth.login.form.details.desc\")\n                        .input(\"geyser.auth.login.form.details.email\", \"account@geysermc.org\", \"\")\n                        .input(\"geyser.auth.login.form.details.pass\", \"123456\", \"\")\n                        .responseHandler((form, responseData) -> {\n                            CustomFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginDetailsWindow(session);\n                                return;\n                            }\n\n                            session.authenticate(response.next(), response.next());\n                        }));\n    }\n\n    /**\n     * Prompts the user between either OAuth code login or manual password authentication\n     */\n    public static void buildAndShowMicrosoftAuthenticationWindow(GeyserSession session) {\n        session.sendForm(\n                SimpleForm.builder()\n                        .translator(LanguageUtils::getPlayerLocaleString, session.getLocale())\n                        .title(\"geyser.auth.login.form.notice.btn_login.microsoft\")\n                        .button(\"geyser.auth.login.method.browser\")\n                        .button(\"geyser.auth.login.method.password\")\n                        .button(\"geyser.auth.login.form.notice.btn_disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            SimpleFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowLoginWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 0) {\n                                session.authenticateWithMicrosoftCode();\n                            } else if (response.getClickedButtonId() == 1) {\n                                buildAndShowLoginDetailsWindow(session);\n                            } else {\n                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                            }\n                        }));\n    }\n\n    /**\n     * Shows the code that a user must input into their browser\n     */\n    public static void buildAndShowMicrosoftCodeWindow(GeyserSession session, MsaAuthenticationService.MsCodeResponse msCode) {\n        session.sendForm(\n                ModalForm.builder()\n                        .title(\"%xbox.signin\")\n                        .content(\"%xbox.signin.website\\n%xbox.signin.url\\n%xbox.signin.enterCode\\n\" + msCode.user_code)\n                        .button1(\"%gui.done\")\n                        .button2(\"%menu.disconnect\")\n                        .responseHandler((form, responseData) -> {\n                            ModalFormResponse response = form.parseResponse(responseData);\n                            if (!response.isCorrect()) {\n                                buildAndShowMicrosoftAuthenticationWindow(session);\n                                return;\n                            }\n\n                            if (response.getClickedButtonId() == 1) {\n                                session.disconnect(LanguageUtils.getPlayerLocaleString(\"geyser.auth.login.form.disconnect\", session.getLocale()));\n                            }\n                        })\n        );\n    }\n}\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>org.geysermc</groupId>\n    <artifactId>geyser-parent</artifactId>\n    <version>1.4.2-SNAPSHOT</version>\n    <packaging>pom</packaging>\n    <name>Geyser</name>\n    <description>Allows for players from Minecraft Bedrock Edition to join Minecraft Java Edition servers.</description>\n    <url>https://geysermc.org</url>\n\n    <properties>\n        <outputName>Geyser</outputName>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <organization>\n        <name>GeyserMC</name>\n        <url>https://github.com/GeyserMC/Geyser/blob/master/pom.xml</url>\n    </organization>\n\n    <scm>\n        <connection>scm:git:https://github.com/GeyserMC/Geyser.git</connection>\n        <developerConnection>scm:git:git@github.com:GeyserMC/Geyser.git</developerConnection>\n        <url>https://github.com/GeyserMC/Geyser</url>\n    </scm>\n\n    <modules>\n        <module>ap</module>\n        <module>bootstrap</module>\n        <module>common</module>\n        <module>connector</module>\n    </modules>\n\n    <repositories>\n        <repository>\n            <id>jitpack.io</id>\n            <url>https://jitpack.io</url>\n        </repository>\n        <repository>\n            <id>opencollab-release-repo</id>\n            <url>https://repo.opencollab.dev/maven-releases/</url>\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n        <repository>\n            <id>opencollab-snapshot-repo</id>\n            <url>https://repo.opencollab.dev/maven-snapshots/</url>\n            <releases>\n                <enabled>false</enabled>\n            </releases>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n        </repository>\n        <repository>\n            <id>sonatype</id>\n            <url>https://oss.sonatype.org/content/repositories/snapshots/</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <version>1.18.20</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n</project>\n"], "filenames": ["Jenkinsfile", "ap/pom.xml", "bootstrap/bungeecord/pom.xml", "bootstrap/pom.xml", "bootstrap/spigot/pom.xml", "bootstrap/sponge/pom.xml", "bootstrap/standalone/pom.xml", "bootstrap/velocity/pom.xml", "common/pom.xml", "connector/pom.xml", "connector/src/main/java/org/geysermc/connector/network/UpstreamPacketHandler.java", "connector/src/main/java/org/geysermc/connector/network/translators/PacketTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/PacketTranslatorRegistry.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockAdventureSettingsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockAnimateTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockBlockEntityDataTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockBlockPickRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockBookEditTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockCommandBlockUpdateTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockCommandRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockContainerCloseTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockEmoteListTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockEntityPickRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockFilterTextTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockInventoryTransactionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockItemFrameDropItemTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockItemStackRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockLecternUpdateTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockMapInfoRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockMobEquipmentTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockMoveEntityAbsoluteTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockNetworkStackLatencyTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockPacketViolationWarningTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockPlayerInputTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockPositionTrackingDBClientRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockRespawnTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockServerSettingsRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockSetLocalPlayerAsInitializedTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockShowCreditsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/BedrockTextTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/BedrockEntityEventTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockActionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockEmoteTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockInteractTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockMovePlayerTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockRiderJumpTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/entity/player/BedrockSetPlayerGameTypeTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/bedrock/world/BedrockLevelSoundEventTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaAdvancementsTabTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaAdvancementsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaBossBarTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaChatTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaDeclareCommandsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaDeclareRecipesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaDeclareTagsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaDifficultyTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaDisconnectPacket.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaJoinGameTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaKeepAliveTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaLoginDisconnectTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaLoginPluginRequestTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaLoginSuccessTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaPingPacket.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaPluginMessageTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaRespawnTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaStatisticsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/JavaUnlockRecipesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityAnimationTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityAttachTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityCollectItemTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityEffectTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityEquipmentTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityHeadLookTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityMetadataTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityPositionRotationTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityPositionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityPropertiesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityRemoveEffectTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityRotationTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntitySetPassengersTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityStatusTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityTeleportTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaEntityVelocityTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/JavaRemoveEntitiesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerAbilitiesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerActionAckTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerChangeHeldItemTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerHealthTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerListEntryTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerPositionRotationTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/player/JavaPlayerSetExperienceTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/spawn/JavaSpawnEntityTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/spawn/JavaSpawnExpOrbTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/spawn/JavaSpawnLivingEntityTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/spawn/JavaSpawnPaintingTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/entity/spawn/JavaSpawnPlayerTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/scoreboard/JavaDisplayScoreboardTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/scoreboard/JavaScoreboardObjectiveTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/scoreboard/JavaTeamTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/scoreboard/JavaUpdateScoreTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/title/JavaClearTitlesTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/title/JavaSetActionBarTextTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/title/JavaSetSubtitleTextTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/title/JavaSetTitleTextTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/title/JavaSetTitlesAnimationTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaCloseWindowTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaOpenHorseWindowTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaOpenWindowTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaSetSlotTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaWindowItemsTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/window/JavaWindowPropertyTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaBlockBreakAnimTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaBlockChangeTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaBlockValueTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaChunkDataTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaExplosionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaMapDataTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaMultiBlockChangeTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaNotifyClientTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaPlayBuiltinSoundTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaPlayEffectTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaPlaySoundTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaSpawnParticleTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaSpawnPositionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaStopSoundTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaTradeListTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaUnloadChunkTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaUpdateTileEntityTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaUpdateTimeTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaUpdateViewDistanceTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaUpdateViewPositionTranslator.java", "connector/src/main/java/org/geysermc/connector/network/translators/java/world/JavaVehicleMoveTranslator.java", "connector/src/main/java/org/geysermc/connector/utils/LoginEncryptionUtils.java", "pom.xml"], "buggy_code_start_loc": [23, 9, 9, 9, 9, 9, 9, 9, 9, 9, 83, 32, 115, 41, 42, 42, 43, 52, 41, 43, 41, 38, 45, 44, 73, 47, 42, 48, 41, 45, 43, 48, 37, 49, 45, 43, 41, 40, 40, 40, 46, 57, 43, 49, 56, 40, 41, 39, 40, 45, 38, 39, 99, 74, 37, 39, 38, 55, 41, 38, 38, 41, 39, 44, 46, 38, 43, 43, 45, 47, 40, 42, 38, 42, 38, 38, 39, 40, 38, 46, 46, 40, 43, 38, 37, 43, 38, 44, 43, 53, 43, 49, 42, 45, 40, 42, 38, 44, 50, 50, 38, 39, 39, 39, 38, 38, 101, 43, 61, 41, 40, 44, 45, 48, 55, 46, 44, 40, 52, 47, 51, 43, 53, 41, 42, 54, 40, 48, 38, 38, 40, 39, 33, 8], "buggy_code_end_loc": [52, 14, 18, 38, 25, 18, 18, 18, 10, 119, 84, 33, 116, 42, 43, 43, 44, 53, 42, 44, 42, 39, 46, 45, 74, 48, 43, 49, 42, 46, 44, 49, 38, 50, 46, 44, 42, 41, 41, 41, 47, 58, 44, 50, 57, 41, 42, 40, 41, 46, 39, 40, 100, 75, 38, 40, 39, 56, 42, 39, 39, 42, 40, 45, 47, 39, 44, 44, 46, 48, 41, 43, 39, 43, 39, 39, 40, 41, 39, 47, 47, 41, 44, 39, 38, 44, 39, 45, 44, 54, 44, 50, 43, 46, 41, 43, 39, 45, 51, 51, 39, 40, 40, 40, 39, 39, 102, 44, 62, 42, 41, 45, 46, 49, 56, 47, 45, 41, 53, 48, 52, 44, 54, 42, 43, 55, 41, 49, 39, 39, 41, 40, 103, 9], "fixing_code_start_loc": [23, 9, 9, 9, 9, 9, 9, 9, 9, 9, 83, 32, 115, 41, 42, 42, 43, 52, 41, 43, 41, 38, 45, 44, 73, 47, 42, 48, 41, 45, 43, 48, 37, 49, 45, 43, 41, 40, 40, 40, 46, 57, 43, 49, 56, 40, 41, 39, 40, 45, 38, 39, 99, 74, 37, 39, 38, 55, 41, 38, 38, 41, 39, 44, 46, 38, 43, 43, 45, 47, 40, 42, 38, 42, 38, 38, 39, 40, 38, 46, 46, 40, 43, 38, 37, 43, 38, 44, 43, 53, 43, 49, 42, 45, 40, 42, 38, 44, 50, 50, 38, 39, 39, 39, 38, 38, 101, 43, 61, 41, 40, 44, 45, 48, 55, 46, 44, 40, 52, 47, 51, 43, 53, 41, 42, 54, 40, 48, 38, 38, 40, 39, 34, 8], "fixing_code_end_loc": [52, 14, 18, 38, 25, 18, 18, 18, 10, 119, 84, 33, 116, 42, 43, 43, 44, 53, 42, 44, 42, 39, 46, 45, 74, 48, 43, 49, 42, 46, 44, 49, 38, 50, 46, 44, 42, 41, 41, 41, 47, 58, 44, 50, 57, 41, 42, 40, 41, 46, 39, 40, 100, 75, 38, 40, 39, 56, 42, 39, 39, 42, 40, 45, 47, 39, 44, 44, 46, 48, 41, 43, 39, 43, 39, 39, 40, 41, 39, 47, 47, 41, 44, 39, 38, 44, 39, 45, 44, 54, 44, 50, 43, 46, 41, 43, 39, 45, 51, 51, 39, 40, 40, 40, 39, 39, 102, 44, 62, 42, 41, 45, 46, 49, 56, 47, 45, 41, 53, 48, 52, 44, 54, 42, 43, 55, 41, 49, 39, 39, 41, 40, 130, 9], "type": "CWE-287", "message": "Geyser is a bridge between Minecraft: Bedrock Edition and Minecraft: Java Edition. Versions of Geyser prior to 1.4.2-SNAPSHOT allow anyone that can connect to the server to forge a LoginPacket with manipulated JWT token allowing impersonation as any user. Version 1.4.2-SNAPSHOT contains a patch for the issue. There are no known workarounds aside from upgrading.", "other": {"cve": {"id": "CVE-2021-39177", "sourceIdentifier": "security-advisories@github.com", "published": "2021-08-30T23:15:07.070", "lastModified": "2021-09-10T14:30:16.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Geyser is a bridge between Minecraft: Bedrock Edition and Minecraft: Java Edition. Versions of Geyser prior to 1.4.2-SNAPSHOT allow anyone that can connect to the server to forge a LoginPacket with manipulated JWT token allowing impersonation as any user. Version 1.4.2-SNAPSHOT contains a patch for the issue. There are no known workarounds aside from upgrading."}, {"lang": "es", "value": "Geyser es un puente entre Minecraft: Bedrock Edition y Minecraft: Java Edition. Unas versiones de Geyser anteriores a 1.4.2-SNAPSHOT permiten a cualquiera que pueda conectarse al servidor falsificar un LoginPacket con un token JWT manipulado, permitiendo una suplantaci\u00f3n de identidad como cualquier usuario. La versi\u00f3n 1.4.2-SNAPSHOT contiene un parche para este problema. No se presentan soluciones conocidas aparte de la actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:geysermc:geyser:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.2", "matchCriteriaId": "515038BF-D294-47CE-B315-48E1C3CA2C13"}]}]}], "references": [{"url": "https://github.com/GeyserMC/Geyser/commit/b9541505af68ac7b7c093206ac7b1ba88957a5a6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/GeyserMC/Geyser/security/advisories/GHSA-h77f-xxx7-4858", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://updates.playhive.com/weekend-maintenance-disclosure-2kJMaY", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/GeyserMC/Geyser/commit/b9541505af68ac7b7c093206ac7b1ba88957a5a6"}}