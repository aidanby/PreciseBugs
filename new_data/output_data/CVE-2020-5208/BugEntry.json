{"buggy_code": ["/*\n* Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n*\n* Redistribution of source code must retain the above copyright\n* notice, this list of conditions and the following disclaimer.\n*\n* Redistribution in binary form must reproduce the above copyright\n* notice, this list of conditions and the following disclaimer in the\n* documentation and/or other materials provided with the distribution.\n*\n* Neither the name of Sun Microsystems, Inc. or the names of\n* contributors may be used to endorse or promote products derived\n* from this software without specific prior written permission.\n*\n* This software is provided \"AS IS,\" without a warranty of any kind.\n* ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,\n* INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.\n* SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS LICENSORS SHALL NOT BE LIABLE\n* FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING\n* OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL\n* SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\n* OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR\n* PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF\n* LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,\n* EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n*/\n\n#include <ipmitool/ipmi.h>\n#include <ipmitool/log.h>\n#include <ipmitool/helper.h>\n#include <ipmitool/ipmi_cc.h>\n#include <ipmitool/ipmi_intf.h>\n#include <ipmitool/ipmi_fru.h>\n#include <ipmitool/ipmi_mc.h>\n#include <ipmitool/ipmi_sdr.h>\n#include <ipmitool/ipmi_strings.h>  /* IANA id strings */\n#include <ipmitool/ipmi_time.h>\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n\n#if HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#define FRU_MULTIREC_CHUNK_SIZE     (255 + sizeof(struct fru_multirec_header))\n#define FRU_FIELD_VALID(a) (a && a[0])\n\nstatic const char *section_id[4] = {\n\t\"Internal Use Section\",\n\t\"Chassis Section\",\n\t\"Board Section\",\n\t\"Product Section\"\n};\n\nstatic const char * combined_voltage_desc[] = {\n\t\"12 V\",\n\t\"-12 V\",\n\t\"5 V\",\n\t\"3.3 V\"\n};\n\nstatic const char * chassis_type_desc[] = {\n\t\"Unspecified\",\n\t\"Other\",\n\t\"Unknown\",\n\t\"Desktop\",\n\t\"Low Profile Desktop\",\n\t\"Pizza Box\",\n\t\"Mini Tower\",\n\t\"Tower\",\n\t\"Portable\",\n\t\"LapTop\",\n\t\"Notebook\",\n\t\"Hand Held\",\n\t\"Docking Station\",\n\t\"All in One\",\n\t\"Sub Notebook\",\n\t\"Space-saving\",\n\t\"Lunch Box\",\n\t\"Main Server Chassis\",\n\t\"Expansion Chassis\",\n\t\"SubChassis\",\n\t\"Bus Expansion Chassis\",\n\t\"Peripheral Chassis\",\n\t\"RAID Chassis\",\n\t\"Rack Mount Chassis\",\n\t\"Sealed-case PC\",\n\t\"Multi-system Chassis\",\n\t\"CompactPCI\",\n\t\"AdvancedTCA\",\n\t\"Blade\",\n\t\"Blade Enclosure\"\n};\n\nstatic inline bool fru_cc_rq2big(int code) {\n\treturn (code == IPMI_CC_REQ_DATA_INV_LENGTH\n\t\t|| code == IPMI_CC_REQ_DATA_FIELD_EXCEED\n\t\t|| code == IPMI_CC_CANT_RET_NUM_REQ_BYTES);\n}\n\n/* From lib/dimm_spd.c: */\nint\nipmi_spd_print_fru(struct ipmi_intf * intf, uint8_t id);\n\nextern int verbose;\n\nstatic void ipmi_fru_read_to_bin(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic void ipmi_fru_write_from_bin(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic int ipmi_fru_upg_ekeying(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic int ipmi_fru_get_multirec_location_from_fru(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\tstruct fru_info *pFruInfo, uint32_t * pRetLocation,\n\t\t\t\t\t\t\tuint32_t * pRetSize);\nstatic int ipmi_fru_get_multirec_from_file(char * pFileName, uint8_t * pBufArea,\n\t\t\t\t\t\tuint32_t size, uint32_t offset);\nstatic int ipmi_fru_get_multirec_size_from_file(char * pFileName, uint32_t * pSize, uint32_t * pOffset);\nint ipmi_fru_get_adjust_size_from_buffer(uint8_t *pBufArea, uint32_t *pSize);\nstatic void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length);\n\nstatic int ipmi_fru_set_field_string(struct ipmi_intf * intf, unsigned\n\t\t\t\t\t\tchar fruId, uint8_t f_type, uint8_t f_index, char *f_string);\nstatic int\nipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info fru, struct fru_header header,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t f_type, uint8_t f_index, char *f_string);\n\nstatic void\nfru_area_print_multirec_bloc(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset);\nint\nread_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf);\nvoid free_fru_bloc(t_ipmi_fru_bloc *bloc);\n\n/* get_fru_area_str  -  Parse FRU area string from raw data\n*\n* @data:   raw FRU data\n* @offset: offset into data for area\n*\n* returns pointer to FRU area string\n*/\nchar * get_fru_area_str(uint8_t * data, uint32_t * offset)\n{\n\tstatic const char bcd_plus[] = \"0123456789 -.:,_\";\n\tchar * str;\n\tint len, off, size, i, j, k, typecode, char_idx;\n\tunion {\n\t\tuint32_t bits;\n\t\tchar chars[4];\n\t} u;\n\n\tsize = 0;\n\toff = *offset;\n\n\t/* bits 6:7 contain format */\n\ttypecode = ((data[off] & 0xC0) >> 6);\n\n\t// printf(\"Typecode:%i\\n\", typecode);\n\t/* bits 0:5 contain length */\n\tlen = data[off++];\n\tlen &= 0x3f;\n\n\tswitch (typecode) {\n\tcase 0:           /* 00b: binary/unspecified */\n\tcase 1:           /* 01b: BCD plus */\n\t\t/* hex dump or BCD -> 2x length */\n\t\tsize = (len * 2);\n\t\tbreak;\n\tcase 2:           /* 10b: 6-bit ASCII */\n\t\t/* 4 chars per group of 1-3 bytes */\n\t\tsize = (((len * 4 + 2) / 3) & ~3);\n\t\tbreak;\n\tcase 3:           /* 11b: 8-bit ASCII */\n\t\t/* no length adjustment */\n\t\tsize = len;\n\t\tbreak;\n\t}\n\n\tif (size < 1) {\n\t\t*offset = off;\n\t\treturn NULL;\n\t}\n\tstr = malloc(size+1);\n\tif (!str)\n\t\treturn NULL;\n\tmemset(str, 0, size+1);\n\n\tif (size == 0) {\n\t\tstr[0] = '\\0';\n\t\t*offset = off;\n\t\treturn str;\n\t}\n\n\tswitch (typecode) {\n\tcase 0:        /* Binary */\n\t\tstrncpy(str, buf2str(&data[off], len), size);\n\t\tbreak;\n\n\tcase 1:        /* BCD plus */\n\t\tfor (k = 0; k < size; k++)\n\t\t\tstr[k] = bcd_plus[((data[off + k / 2] >> ((k % 2) ? 0 : 4)) & 0x0f)];\n\t\tstr[k] = '\\0';\n\t\tbreak;\n\n\tcase 2:        /* 6-bit ASCII */\n\t\tfor (i = j = 0; i < len; i += 3) {\n\t\t\tu.bits = 0;\n\t\t\tk = ((len - i) < 3 ? (len - i) : 3);\n#if WORDS_BIGENDIAN\n\t\t\tu.chars[3] = data[off+i];\n\t\t\tu.chars[2] = (k > 1 ? data[off+i+1] : 0);\n\t\t\tu.chars[1] = (k > 2 ? data[off+i+2] : 0);\n\t\t\tchar_idx = 3;\n#else\n\t\t\tmemcpy((void *)&u.bits, &data[off+i], k);\n\t\t\tchar_idx = 0;\n#endif\n\t\t\tfor (k=0; k<4; k++) {\n\t\t\t\tstr[j++] = ((u.chars[char_idx] & 0x3f) + 0x20);\n\t\t\t\tu.bits >>= 6;\n\t\t\t}\n\t\t}\n\t\tstr[j] = '\\0';\n\t\tbreak;\n\n\tcase 3:\n\t\tmemcpy(str, &data[off], size);\n\t\tstr[size] = '\\0';\n\t\tbreak;\n\t}\n\n\toff += len;\n\t*offset = off;\n\n\treturn str;\n}\n\n/* is_valid_filename - checks file/path supplied by user\n *\n * input_filename - user input string\n *\n * returns   0  if path is ok\n * returns -1 if path is NULL\n * returns -2 if path is too short\n * returns -3 if path is too long\n */\nint\nis_valid_filename(const char *input_filename)\n{\n\tif (!input_filename) {\n\t\tlprintf(LOG_ERR, \"ERROR: NULL pointer passed.\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(input_filename) < 1) {\n\t\tlprintf(LOG_ERR, \"File/path is invalid.\");\n\t\treturn -2;\n\t}\n\n\tif (strlen(input_filename) >= 512) {\n\t\tlprintf(LOG_ERR, \"File/path must be shorter than 512 bytes.\");\n\t\treturn -3;\n\t}\n\n\treturn 0;\n} /* is_valid_filename() */\n\n/* build_fru_bloc  -  build fru bloc for write protection\n*\n* @intf:     ipmi interface\n* @fru_info: information about FRU device\n* @id      : Fru id\n* @soffset : Source offset      (from buffer)\n* @doffset : Destination offset (in device)\n* @length  : Size of data to write (in bytes)\n* @pFrubuf : Pointer on data to write\n*\n* returns 0 on success\n* returns -1 on error\n*/\n#define FRU_NUM_BLOC_COMMON_HEADER  6\nt_ipmi_fru_bloc *\nbuild_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id)\n{\n\tt_ipmi_fru_bloc * p_first, * p_bloc, * p_new;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_header header;\n\tstruct fru_multirec_header rec_hdr;\n\tuint8_t msg_data[4];\n\tuint32_t off;\n\tuint16_t i;\n\n\t/*\n\t* get COMMON Header format\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\n\tif (!rsp) {\n\t\tlprintf(LOG_ERR, \" Device not present (No Response)\");\n\t\treturn NULL;\n\t}\n\n\tif (rsp->ccode) {\n\t\tlprintf(LOG_ERR,\" Device not present (%s)\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn NULL;\n\t}\n\n\tif (verbose > 1) {\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\t}\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\t/* verify header checksum */\n\tif (ipmi_csum((uint8_t *)&header, 8)) {\n\t\tlprintf(LOG_ERR, \" Bad header checksum\");\n\t\treturn NULL;\n\t}\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\", header.version);\n\t\treturn NULL;\n\t}\n\n\t/******************************************\n\t\tMalloc and fill up the bloc contents\n\t*******************************************/\n\n\t// Common header\n\tp_first = malloc(sizeof(struct ipmi_fru_bloc));\n\tif (!p_first) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn NULL;\n\t}\n\n\tp_bloc = p_first;\n\tp_bloc->next = NULL;\n\tp_bloc->start= 0;\n\tp_bloc->size = fru->size;\n\tstrcpy((char *)p_bloc->blocId, \"Common Header Section\");\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (header.offsets[i]) {\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = header.offsets[i] * 8;\n\t\t\tp_new->size = fru->size - p_new->start;\n\n\t\t\tstrncpy((char *)p_new->blocId, section_id[i], sizeof(p_new->blocId));\n\t\t\t/* Make sure string is null terminated */\n\t\t\tp_new->blocId[sizeof(p_new->blocId)-1] = 0;\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t\tp_bloc = p_new;\n\t\t}\n\t}\n\n\t// Multi\n\tif (header.offset.multi) {\n\t\toff = header.offset.multi * 8;\n\n\t\tdo {\n\t\t\t/*\n\t\t\t * check for odd offset for the case of fru devices\n\t\t\t * accessed by words\n\t\t\t */\n\t\t\tif (fru->access && (off & 1)) {\n\t\t\t\tlprintf(LOG_ERR, \" Unaligned offset for a block: %d\", off);\n\t\t\t\t/* increment offset */\n\t\t\t\toff++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (read_fru_area(intf, fru, id, off, 5,\n\t\t\t\t\t(uint8_t *) &rec_hdr) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = off;\n\t\t\tp_new->size = fru->size - p_new->start;\n\t\t\tsprintf((char *)p_new->blocId, \"Multi-Rec Area: Type %i\",\n\t\t\t\t\trec_hdr.type);\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t\tp_bloc = p_new;\n\n\t\t\toff += rec_hdr.len + sizeof(struct fru_multirec_header);\n\n\t\t\t/* verify record header */\n\t\t\tif (ipmi_csum((uint8_t *)&rec_hdr,\n\t\t\t\t\tsizeof(struct fru_multirec_header))) {\n\t\t\t\t/* can't reliably judge for the rest space */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!(rec_hdr.format & 0x80) && (off < fru->size));\n\n\t\tlprintf(LOG_DEBUG,\"Multi-Record area ends at: %i (%xh)\", off, off);\n\n\t\tif (fru->size > off) {\n\t\t\t// Bloc for remaining space\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = off;\n\t\t\tp_new->size = fru->size - p_new->start;\n\t\t\tstrcpy((char *)p_new->blocId, \"Unused space\");\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t}\n\t}\n\n\t/* Dump blocs */\n\tfor(p_bloc = p_first, i = 0; p_bloc; p_bloc = p_bloc->next) {\n\t\tlprintf(LOG_DEBUG ,\"Bloc Numb : %i\", i++);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Id   : %s\", p_bloc->blocId);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Start: %i\", p_bloc->start);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Size : %i\", p_bloc->size);\n\t\tlprintf(LOG_DEBUG ,\"\");\n\t}\n\n\treturn p_first;\n}\n\nvoid\nfree_fru_bloc(t_ipmi_fru_bloc *bloc)\n{\n\tt_ipmi_fru_bloc * del;\n\n\twhile (bloc) {\n\t\tdel = bloc;\n\t\tbloc = bloc->next;\n\t\tfree_n(&del);\n\t}\n}\n\n/* By how many bytes to reduce a write command on a size failure. */\n#define FRU_BLOCK_SZ\t8\n/* Baseline for a large enough piece to reduce via steps instead of bytes. */\n#define FRU_AREA_MAXIMUM_BLOCK_SZ\t32\n\n/*\n * write FRU[doffset:length] from the pFrubuf[soffset:length]\n * rc=1 on success\n**/\nint\nwrite_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\t\t\tuint16_t soffset,  uint16_t doffset,\n\t\t\t\t\tuint16_t length, uint8_t *pFrubuf)\n{\n\tuint16_t tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[255+3];\n\tuint16_t writeLength;\n\tuint16_t found_bloc = 0;\n\n\tfinish = doffset + length;        /* destination offset */\n\tif (finish > fru->size)\n\t{\n\t\tlprintf(LOG_ERROR, \"Return error\");\n\t\treturn -1;\n\t}\n\n\tif (fru->access && ((doffset & 1) || (length & 1))) {\n\t\tlprintf(LOG_ERROR, \"Odd offset or length specified\");\n\t\treturn -1;\n\t}\n\n\tt_ipmi_fru_bloc * fru_bloc = build_fru_bloc(intf, fru, id);\n\tt_ipmi_fru_bloc * saved_fru_bloc = fru_bloc;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = SET_FRU_DATA;\n\treq.msg.data = msg_data;\n\n\t/* initialize request size only once */\n\tif (fru->max_write_size == 0) {\n\t\tuint16_t max_rq_size = ipmi_intf_get_max_request_data_size(intf);\n\n\t\t/* validate lower bound of the maximum request data size */\n\t\tif (max_rq_size <= 3) {\n\t\t\tlprintf(LOG_ERROR, \"Maximum request size is too small to send \"\n\t\t\t\t\t\"a write request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Write FRU Info command returns the number of written bytes in\n\t\t * a single byte field.\n\t\t */\n\t\tif (max_rq_size - 3 > 255) {\n\t\t\t/*  Limit the max write size with 255 bytes. */\n\t\t\tfru->max_write_size = 255;\n\t\t} else {\n\t\t\t/* subtract 1 byte for FRU ID an 2 bytes for offset */\n\t\t\tfru->max_write_size = max_rq_size - 3;\n\t\t}\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\tfru->max_write_size &= ~1;\n\t\t}\n\t}\n\n\tdo {\n\t\tuint16_t end_bloc;\n\t\tuint8_t protected_bloc = 0;\n\n\t\t/* Write per bloc, try to find the end of a bloc*/\n\t\twhile (fru_bloc && fru_bloc->start + fru_bloc->size <= doffset) {\n\t\t\tfru_bloc = fru_bloc->next;\n\t\t\tfound_bloc++;\n\t\t}\n\n\t\tif (fru_bloc && fru_bloc->start + fru_bloc->size < finish) {\n\t\t\tend_bloc = fru_bloc->start + fru_bloc->size;\n\t\t} else {\n\t\t\tend_bloc = finish;\n\t\t}\n\n\t\t/* calculate write length */\n\t\ttmp = end_bloc - doffset;\n\n\t\t/* check that write length is more than maximum request size */\n\t\tif (tmp > fru->max_write_size) {\n\t\t\twriteLength = fru->max_write_size;\n\t\t} else {\n\t\t\twriteLength = tmp;\n\t\t}\n\n\t\t/* copy fru data */\n\t\tmemcpy(&msg_data[3], pFrubuf + soffset, writeLength);\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\twriteLength &= ~1;\n\t\t}\n\n\t\ttmp = doffset;\n\t\tif (fru->access) {\n\t\t\ttmp >>= 1;\n\t\t}\n\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)tmp;\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\treq.msg.data_len = writeLength + 3;\n\n\t\tif(fru_bloc) {\n\t\t\tlprintf(LOG_INFO,\"Writing %d bytes (Bloc #%i: %s)\",\n\t\t\t\t\twriteLength, found_bloc, fru_bloc->blocId);\n\t\t} else {\n\t\t\tlprintf(LOG_INFO,\"Writing %d bytes\", writeLength);\n\t\t}\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fru_cc_rq2big(rsp->ccode)) {\n\t\t\tif (fru->max_write_size > FRU_AREA_MAXIMUM_BLOCK_SZ) {\n\t\t\t\tfru->max_write_size -= FRU_BLOCK_SZ;\n\t\t\t\tlprintf(LOG_INFO, \"Retrying FRU write with request size %d\",\n\t\t\t\t\t\tfru->max_write_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (rsp->ccode == IPMI_CC_FRU_WRITE_PROTECTED_OFFSET) {\n\t\t\trsp->ccode = IPMI_CC_OK;\n\t\t\t// Write protected section\n\t\t\tprotected_bloc = 1;\n\t\t}\n\n\t\tif (rsp->ccode)\n\t\t\tbreak;\n\n\t\tif (protected_bloc == 0) {\n\t\t\t// Write OK, bloc not protected, continue\n\t\t\tlprintf(LOG_INFO,\"Wrote %d bytes\", writeLength);\n\t\t\tdoffset += writeLength;\n\t\t\tsoffset += writeLength;\n\t\t} else {\n\t\t\tif(fru_bloc) {\n\t\t\t\t// Bloc protected, advise user and jump over protected bloc\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\t\"Bloc [%s] protected at offset: %i (size %i bytes)\",\n\t\t\t\t\t\tfru_bloc->blocId, fru_bloc->start, fru_bloc->size);\n\t\t\t\tlprintf(LOG_INFO,\"Jumping over this bloc\");\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\t\"Remaining FRU is protected following offset: %i\",\n\t\t\t\t\t\tdoffset);\n\t\t\t}\n\t\t\tsoffset += end_bloc - doffset;\n\t\t\tdoffset = end_bloc;\n\t\t}\n\t} while (doffset < finish);\n\n\tif (saved_fru_bloc) {\n\t\tfree_fru_bloc(saved_fru_bloc);\n\t}\n\n\treturn doffset >= finish;\n}\n\n/* read_fru_area  -  fill in frubuf[offset:length] from the FRU[offset:length]\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:     fru id\n* @offset: offset into buffer\n* @length: how much to read\n* @frubuf: buffer read into\n*\n* returns -1 on error\n* returns 0 if successful\n*/\nint\nread_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tuint32_t off = offset, tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\tif (fru->max_read_size == 0) {\n\t\tuint16_t max_rs_size = ipmi_intf_get_max_response_data_size(intf) - 1;\n\n\t\t/* validate lower bound of the maximum response data size */\n\t\tif (max_rs_size <= 1) {\n\t\t\tlprintf(LOG_ERROR, \"Maximum response size is too small to send \"\n\t\t\t\t\t\"a read request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Read FRU Info command may read up to 255 bytes of data.\n\t\t */\n\t\tif (max_rs_size - 1 > 255) {\n\t\t\t/*  Limit the max read size with 255 bytes. */\n\t\t\tfru->max_read_size = 255;\n\t\t} else {\n\t\t\t/* subtract 1 byte for bytes count */\n\t\t\tfru->max_read_size = max_rs_size - 1;\n\t\t}\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\tfru->max_read_size &= ~1;\n\t\t}\n\t}\n\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru->max_read_size)\n\t\t\tmsg_data[3] = (uint8_t)fru->max_read_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7h or C8h or CAh return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode)\n\t\t\t    && fru->max_read_size > FRU_BLOCK_SZ)\n\t\t\t{\n\t\t\t\tif (fru->max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ) {\n\t\t\t\t\t/* subtract read length more aggressively */\n\t\t\t\t\tfru->max_read_size -= FRU_BLOCK_SZ;\n\t\t\t\t} else {\n\t\t\t\t\t/* subtract length less aggressively */\n\t\t\t\t\tfru->max_read_size--;\n\t\t\t\t}\n\n\t\t\t\tlprintf(LOG_INFO, \"Retrying FRU read with request size %d\",\n\t\t\t\t\t\tfru->max_read_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tmemcpy(frubuf, rsp->data + 1, tmp);\n\t\toff += tmp;\n\t\tfrubuf += tmp;\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish) {\n\t\t\treturn 0;\n\t\t}\n\t} while (off < finish);\n\n\tif (off < finish) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* read_fru_area  -  fill in frubuf[offset:length] from the FRU[offset:length]\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:     fru id\n* @offset: offset into buffer\n* @length: how much to read\n* @frubuf: buffer read into\n*\n* returns -1 on error\n* returns 0 if successful\n*/\nint\nread_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tstatic uint32_t fru_data_rqst_size = 20;\n\tuint32_t off = offset, tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n#ifdef LIMIT_ALL_REQUEST_SIZE\n\tif (fru_data_rqst_size > 16)\n#else\n\tif (fru->access && fru_data_rqst_size > 16)\n#endif\n\t\tfru_data_rqst_size = 16;\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru_data_rqst_size)\n\t\t\tmsg_data[3] = (uint8_t)fru_data_rqst_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7 or C8  or CA return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\"Retrying FRU read with request size %d\",\n\t\t\t\t\tfru_data_rqst_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tmemcpy((frubuf + off)-offset, rsp->data + 1, tmp);\n\t\toff += tmp;\n\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish)\n\t\t\treturn 0;\n\n\t} while (off < finish);\n\n\tif (off < finish)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n\nstatic void\nfru_area_print_multirec_bloc(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tuint8_t * fru_data = NULL;\n\tuint32_t i;\n\tstruct fru_multirec_header * h;\n\tuint32_t last_off, len;\n\n\ti = last_off = offset;\n\n\tfru_data = malloc(fru->size + 1);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru->size + 1);\n\n\tdo {\n\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t// read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time\n\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t{\n\t\t\tlen = fru->size - last_off;\n\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\tif (read_fru_area(intf, fru, id, last_off, len, fru_data) < 0)\n\t\t\t\tbreak;\n\n\t\t\tlast_off += len;\n\t\t}\n\n\t\t//printf(\"Bloc Numb : %i\\n\", counter);\n\t\tprintf(\"Bloc Start: %i\\n\", i);\n\t\tprintf(\"Bloc Size : %i\\n\", h->len);\n\t\tprintf(\"\\n\");\n\n\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t} while (!(h->format & 0x80));\n\n\ti = offset;\n\tdo {\n\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\tprintf(\"Bloc Start: %i\\n\", i);\n\t\tprintf(\"Bloc Size : %i\\n\", h->len);\n\t\tprintf(\"\\n\");\n\n\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t} while (!(h->format & 0x80));\n\n\tlprintf(LOG_DEBUG ,\"Multi-Record area ends at: %i (%xh)\",i,i);\n\n\tfree_n(&fru_data);\n}\n\n\n/* fru_area_print_chassis  -  Print FRU Chassis Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_chassis(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len, i;\n\tuint8_t tmp[2];\n\tsize_t chassis_type;\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len == 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first two bytes which specify\n\t * fru area version and fru area length\n\t */\n\ti = 2;\n\n\tchassis_type = (fru_data[i] > ARRAY_SIZE(chassis_type_desc) - 1)\n\t               ? 2\n\t               : fru_data[i];\n\tprintf(\" Chassis Type          : %s\\n\", chassis_type_desc[chassis_type]);\n\n \ti++;\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Chassis Part Number   : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Chassis Serial        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Chassis Extra         : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\n\t\tif (i == j) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_board  -  Print FRU Board Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_board(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len;\n\tuint32_t i;\n\ttime_t ts;\n\tuint8_t tmp[2];\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len <= 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first three bytes which specify\n\t * fru area version, fru area length\n\t * and fru board language\n\t */\n\ti = 3;\n\n\tts = ipmi_fru2time_t(&fru_data[i]);\n\tprintf(\" Board Mfg Date        : %s\\n\", ipmi_timestamp_string(ts));\n\ti += 3;  /* skip mfg. date time */\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Mfg             : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Product         : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Serial          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Part Number     : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0 && verbose > 0) {\n\t\t\tprintf(\" Board FRU ID          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Board Extra           : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tif (i == j)\n\t\t\tbreak;\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_product  -  Print FRU Product Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_product(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len, i;\n\tuint8_t tmp[2];\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len == 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first three bytes which specify\n\t * fru area version, fru area length\n\t * and fru board language\n\t */\n\ti = 3;\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Manufacturer  : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Name          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Part Number   : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Version       : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Serial        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Asset Tag     : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0 && verbose > 0) {\n\t\t\tprintf(\" Product FRU ID        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Product Extra         : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tif (i == j)\n\t\t\tbreak;\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_multirec  -  Print FRU Multi Record Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_multirec(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tuint8_t * fru_data;\n\tstruct fru_multirec_header * h;\n\tstruct fru_multirec_powersupply * ps;\n\tstruct fru_multirec_dcoutput * dc;\n\tstruct fru_multirec_dcload * dl;\n\tuint16_t peak_capacity;\n\tuint8_t peak_hold_up_time;\n\tuint32_t last_off;\n\n\tlast_off = offset;\n\n\tfru_data = malloc(FRU_MULTIREC_CHUNK_SIZE);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, FRU_MULTIREC_CHUNK_SIZE);\n\n\th = (struct fru_multirec_header *) (fru_data);\n\n\tdo {\n\t\tif (read_fru_area(intf, fru, id, last_off, sizeof(*h), fru_data) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h->len && read_fru_area(intf, fru, id,\n\t\t\t\tlast_off + sizeof(*h), h->len, fru_data + sizeof(*h)) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_off += h->len + sizeof(*h);\n\n\t\tswitch (h->type) {\n\t\tcase FRU_RECORD_TYPE_POWER_SUPPLY_INFORMATION:\n\t\t\tps = (struct fru_multirec_powersupply *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tps->capacity      = BSWAP_16(ps->capacity);\n\t\t\tps->peak_va    = BSWAP_16(ps->peak_va);\n\t\t\tps->lowend_input1 = BSWAP_16(ps->lowend_input1);\n\t\t\tps->highend_input1   = BSWAP_16(ps->highend_input1);\n\t\t\tps->lowend_input2 = BSWAP_16(ps->lowend_input2);\n\t\t\tps->highend_input2   = BSWAP_16(ps->highend_input2);\n\t\t\tps->combined_capacity   = BSWAP_16(ps->combined_capacity);\n\t\t\tps->peak_cap_ht      = BSWAP_16(ps->peak_cap_ht);\n#endif\n\t\t\tpeak_hold_up_time = (ps->peak_cap_ht & 0xf000) >> 12;\n\t\t\tpeak_capacity     = ps->peak_cap_ht & 0x0fff;\n\n\t\t\tprintf (\" Power Supply Record\\n\");\n\t\t\tprintf (\"  Capacity                   : %d W\\n\",\n\t\t\t\tps->capacity);\n\t\t\tprintf (\"  Peak VA                    : %d VA\\n\",\n\t\t\t\tps->peak_va);\n\t\t\tprintf (\"  Inrush Current             : %d A\\n\",\n\t\t\t\tps->inrush_current);\n\t\t\tprintf (\"  Inrush Interval            : %d ms\\n\",\n\t\t\t\tps->inrush_interval);\n\t\t\tprintf (\"  Input Voltage Range 1      : %d-%d V\\n\",\n\t\t\t\tps->lowend_input1 / 100, ps->highend_input1 / 100);\n\t\t\tprintf (\"  Input Voltage Range 2      : %d-%d V\\n\",\n\t\t\t\tps->lowend_input2 / 100, ps->highend_input2 / 100);\n\t\t\tprintf (\"  Input Frequency Range      : %d-%d Hz\\n\",\n\t\t\t\tps->lowend_freq, ps->highend_freq);\n\t\t\tprintf (\"  A/C Dropout Tolerance      : %d ms\\n\",\n\t\t\t\tps->dropout_tolerance);\n\t\t\tprintf (\"  Flags                      : %s%s%s%s%s\\n\",\n\t\t\t\tps->predictive_fail ? \"'Predictive fail' \" : \"\",\n\t\t\t\tps->pfc ? \"'Power factor correction' \" : \"\",\n\t\t\t\tps->autoswitch ? \"'Autoswitch voltage' \" : \"\",\n\t\t\t\tps->hotswap ? \"'Hot swap' \" : \"\",\n\t\t\t\tps->predictive_fail ? ps->rps_threshold ?\n\t\t\t\tps->tach ? \"'Two pulses per rotation'\" : \"'One pulse per rotation'\" :\n\t\t\t\tps->tach ? \"'Failure on pin de-assertion'\" : \"'Failure on pin assertion'\" : \"\");\n\t\t\tprintf (\"  Peak capacity              : %d W\\n\",\n\t\t\t\tpeak_capacity);\n\t\t\tprintf (\"  Peak capacity holdup       : %d s\\n\",\n\t\t\t\tpeak_hold_up_time);\n\t\t\tif (ps->combined_capacity == 0)\n\t\t\t\tprintf (\"  Combined capacity          : not specified\\n\");\n\t\t\telse\n\t\t\t\tprintf (\"  Combined capacity          : %d W (%s and %s)\\n\",\n\t\t\t\t\tps->combined_capacity,\n\t\t\t\t\tcombined_voltage_desc [ps->combined_voltage1],\n\t\t\t\t\tcombined_voltage_desc [ps->combined_voltage2]);\n\t\t\tif (ps->predictive_fail)\n\t\t\t\tprintf (\"  Fan lower threshold        : %d RPS\\n\",\n\t\t\t\t\tps->rps_threshold);\n\t\t\tbreak;\n\n\t\tcase FRU_RECORD_TYPE_DC_OUTPUT:\n\t\t\tdc = (struct fru_multirec_dcoutput *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tdc->nominal_voltage  = BSWAP_16(dc->nominal_voltage);\n\t\t\tdc->max_neg_dev      = BSWAP_16(dc->max_neg_dev);\n\t\t\tdc->max_pos_dev      = BSWAP_16(dc->max_pos_dev);\n\t\t\tdc->ripple_and_noise = BSWAP_16(dc->ripple_and_noise);\n\t\t\tdc->min_current      = BSWAP_16(dc->min_current);\n\t\t\tdc->max_current      = BSWAP_16(dc->max_current);\n#endif\n\n\t\t\tprintf (\" DC Output Record\\n\");\n\t\t\tprintf (\"  Output Number              : %d\\n\",\n\t\t\t\tdc->output_number);\n\t\t\tprintf (\"  Standby power              : %s\\n\",\n\t\t\t\tdc->standby ? \"Yes\" : \"No\");\n\t\t\tprintf (\"  Nominal voltage            : %.2f V\\n\",\n\t\t\t\t(double) dc->nominal_voltage / 100);\n\t\t\tprintf (\"  Max negative deviation     : %.2f V\\n\",\n\t\t\t\t(double) dc->max_neg_dev / 100);\n\t\t\tprintf (\"  Max positive deviation     : %.2f V\\n\",\n\t\t\t\t(double) dc->max_pos_dev / 100);\n\t\t\tprintf (\"  Ripple and noise pk-pk     : %d mV\\n\",\n\t\t\t\tdc->ripple_and_noise);\n\t\t\tprintf (\"  Minimum current draw       : %.3f A\\n\",\n\t\t\t\t(double) dc->min_current / 1000);\n\t\t\tprintf (\"  Maximum current draw       : %.3f A\\n\",\n\t\t\t\t(double) dc->max_current / 1000);\n\t\t\tbreak;\n\n\t\tcase FRU_RECORD_TYPE_DC_LOAD:\n\t\t\tdl = (struct fru_multirec_dcload *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tdl->nominal_voltage  = BSWAP_16(dl->nominal_voltage);\n\t\t\tdl->min_voltage      = BSWAP_16(dl->min_voltage);\n\t\t\tdl->max_voltage      = BSWAP_16(dl->max_voltage);\n\t\t\tdl->ripple_and_noise = BSWAP_16(dl->ripple_and_noise);\n\t\t\tdl->min_current      = BSWAP_16(dl->min_current);\n\t\t\tdl->max_current      = BSWAP_16(dl->max_current);\n#endif\n\n\t\t\tprintf (\" DC Load Record\\n\");\n\t\t\tprintf (\"  Output Number              : %d\\n\",\n\t\t\t\tdl->output_number);\n\t\t\tprintf (\"  Nominal voltage            : %.2f V\\n\",\n\t\t\t\t(double) dl->nominal_voltage / 100);\n\t\t\tprintf (\"  Min voltage allowed        : %.2f V\\n\",\n\t\t\t\t(double) dl->min_voltage / 100);\n\t\t\tprintf (\"  Max voltage allowed        : %.2f V\\n\",\n\t\t\t\t(double) dl->max_voltage / 100);\n\t\t\tprintf (\"  Ripple and noise pk-pk     : %d mV\\n\",\n\t\t\t\tdl->ripple_and_noise);\n\t\t\tprintf (\"  Minimum current load       : %.3f A\\n\",\n\t\t\t\t(double) dl->min_current / 1000);\n\t\t\tprintf (\"  Maximum current load       : %.3f A\\n\",\n\t\t\t\t(double) dl->max_current / 1000);\n\t\t\tbreak;\n\t\tcase FRU_RECORD_TYPE_OEM_EXTENSION:\n\t\t\t{\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\n\t\t\t\tif( iana == IPMI_OEM_PICMG ){\n\t\t\t\t\tprintf(\"  PICMG Extension Record\\n\");\n\t\t\t\t\tipmi_fru_picmg_ext_print(fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(struct fru_multirec_header),\n\t\t\t\t\t\t\t\t\t\t\t\t\th->len);\n\t\t\t\t}\n\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"  OEM (%s) Record\\n\", val2str( iana, ipmi_oem_info));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (!(h->format & 0x80));\n\n\tlprintf(LOG_DEBUG ,\"Multi-Record area ends at: %i (%xh)\", last_off, last_off);\n\n\tfree_n(&fru_data);\n}\n\n/* ipmi_fru_query_new_value  -  Query new values to replace original FRU content\n*\n* @data:   FRU data\n* @offset: offset of the bytes to be modified in data\n* @len:    size of the modified data\n*\n* returns : TRUE if data changed\n* returns : FALSE if data not changed\n*/\nstatic\nbool\nipmi_fru_query_new_value(uint8_t *data,int offset, size_t len)\n{\n\tbool status = false;\n\tint ret;\n\tchar answer;\n\n\tprintf(\"Would you like to change this value <y/n> ? \");\n\tret = scanf(\"%c\", &answer);\n\tif (ret != 1) {\n\t\treturn false;\n\t}\n\n\tif( answer == 'y' || answer == 'Y' ){\n\t\tint i;\n\t\tunsigned int *holder;\n\n\t\tholder = malloc(len);\n\t\tprintf(\n\t\t \"Enter hex values for each of the %d entries (lsb first), \"\n\t\t \"hit <enter> between entries\\n\", (int)len);\n\n\t\t/* I can't assign scanf' %x into a single char */\n\t\tfor( i=0;i<len;i++ ){\n\t\t\tret = scanf(\"%x\", holder+i);\n\t\t\tif (ret != 1) {\n\t\t\t\tfree_n(&holder);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor( i=0;i<len;i++ ){\n\t\t\tdata[offset++] = (unsigned char) *(holder+i);\n\t\t}\n\t\t/* &data[offset++] */\n\t\tfree_n(&holder);\n\t\tstatus = true;\n\t}\n\telse{\n\t\tprintf(\"Entered %c\\n\",answer);\n\t}\n\n\treturn status;\n}\n\n/* ipmi_fru_oemkontron_edit  -\n*  Query new values to replace original FRU content\n*  This is a generic enough to support any type of 'OEM' record\n*  because the user supplies 'IANA number' , 'record Id' and 'record' version'\n*\n* However, the parser must have 'apriori' knowledge of the record format\n* The currently supported record is :\n*\n*    IANA          : 15000  (Kontron)\n*    RECORD ID     : 3\n*    RECORD VERSION: 0 (or 1)\n*\n* I would have like to put that stuff in an OEM specific file, but apart for\n* the record format information, all commands are really standard 'FRU' command\n*\n*\n* @data:   FRU data\n* @offset: start of the current multi record (start of header)\n* @len:    len of the current record (excluding header)\n* @h:      pointer to record header\n* @oh:     pointer to OEM /PICMG header\n*\n* returns: TRUE if data changed\n* returns: FALSE if data not changed\n*/\n#define OEM_KONTRON_INFORMATION_RECORD 3\n\n#define EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT    12\n#define GET_OEM_KONTRON_COMPLETE_ARG_COUNT     5\n/*\n./src/ipmitool  fru edit 0\noem 15000 3 0 name instance FIELD1 FIELD2 FIELD3 crc32\n*/\n\n#define OEM_KONTRON_SUBCOMMAND_ARG_POS   2\n#define OEM_KONTRON_IANA_ARG_POS         3\n#define OEM_KONTRON_RECORDID_ARG_POS     4\n#define OEM_KONTRON_FORMAT_ARG_POS       5\n#define OEM_KONTRON_NAME_ARG_POS         6\n#define OEM_KONTRON_INSTANCE_ARG_POS     7\n#define OEM_KONTRON_VERSION_ARG_POS      8\n#define OEM_KONTRON_BUILDDATE_ARG_POS    9\n#define OEM_KONTRON_UPDATEDATE_ARG_POS   10\n#define OEM_KONTRON_CRC32_ARG_POS        11\n\n#define OEM_KONTRON_FIELD_SIZE          8\n#define OEM_KONTRON_VERSION_FIELD_SIZE 10\n\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(1)\n#endif\ntypedef struct OemKontronInformationRecordV0{\n\tuint8_t field1TypeLength;\n\tuint8_t field1[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field2TypeLength;\n\tuint8_t field2[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field3TypeLength;\n\tuint8_t field3[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t crcTypeLength;\n\tuint8_t crc32[OEM_KONTRON_FIELD_SIZE];\n}tOemKontronInformationRecordV0;\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(0)\n#endif\n\n\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(1)\n#endif\ntypedef struct OemKontronInformationRecordV1{\n\tuint8_t field1TypeLength;\n\tuint8_t field1[OEM_KONTRON_VERSION_FIELD_SIZE];\n\tuint8_t field2TypeLength;\n\tuint8_t field2[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field3TypeLength;\n\tuint8_t field3[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t crcTypeLength;\n\tuint8_t crc32[OEM_KONTRON_FIELD_SIZE];\n}tOemKontronInformationRecordV1;\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(0)\n#endif\n\n/*\n./src/ipmitool  fru get 0 oem iana 3\n\n*/\n\nstatic void ipmi_fru_oemkontron_get(int argc,\n\t\t\t\t    char ** argv,\n\t\t\t\t    uint8_t * fru_data,\n\t\t\t\t    int off,\n\t\t\t\t    struct fru_multirec_oem_header *oh)\n{\n\tstatic bool badParams = false;\n\tint start = off;\n\tint offset = start;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tif(!badParams){\n\t\t/* the 'OEM' field is already checked in caller */\n\t\tif( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){\n\t\t\tif(strncmp(\"oem\", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){\n\t\t\t\tprintf(\"usage: fru get <id> <oem>\\n\");\n\t\t\t\tbadParams = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif( argc<GET_OEM_KONTRON_COMPLETE_ARG_COUNT ){\n\t\t\tprintf(\"usage: oem <iana> <recordid>\\n\");\n\t\t\tprintf(\"usage: oem 15000 3\\n\");\n\t\t\tbadParams = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (badParams) {\n\t\treturn;\n\t}\n\n\tif (oh->record_id != OEM_KONTRON_INFORMATION_RECORD) {\n\t\treturn;\n\t}\n\n\tuint8_t version;\n\n\tprintf(\"Kontron OEM Information Record\\n\");\n\tversion = oh->record_version;\n\n\tuint8_t blockCount;\n\tuint8_t blockIndex = 0;\n\n\tuint8_t instance = 0;\n\n\tif (str2uchar(argv[OEM_KONTRON_INSTANCE_ARG_POS], &instance) != 0) {\n\t\tlprintf(LOG_ERR,\n\t\t\t\"Instance argument '%s' is either invalid or out of range.\",\n\t\t\targv[OEM_KONTRON_INSTANCE_ARG_POS]);\n\t\tbadParams = true;\n\t\treturn;\n\t}\n\n\tblockCount = fru_data[offset++];\n\n\tfor (blockIndex = 0; blockIndex < blockCount; blockIndex++) {\n\t\tvoid *pRecordData;\n\t\tuint8_t nameLen;\n\n\t\tnameLen = (fru_data[offset++] &= 0x3F);\n\t\tprintf(\"  Name: %*.*s\\n\", nameLen, nameLen,\n\t\t       (const char *)(fru_data + offset));\n\n\t\toffset += nameLen;\n\n\t\tpRecordData = &fru_data[offset];\n\n\t\tprintf(\"  Record Version: %d\\n\", version);\n\t\tif (version == 0) {\n\t\t\tprintf(\"  Version: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field1);\n\t\t\tprintf(\"  Build Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field2);\n\t\t\tprintf(\"  Update Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field3);\n\t\t\tprintf(\"  Checksum: %*.*s\\n\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->crc32);\n\t\t\toffset += sizeof(tOemKontronInformationRecordV0);\n\t\t\toffset++;\n\t\t} else if (version == 1) {\n\t\t\tprintf(\"  Version: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_VERSION_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_VERSION_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field1);\n\t\t\tprintf(\"  Build Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field2);\n\t\t\tprintf(\"  Update Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field3);\n\t\t\tprintf(\"  Checksum: %*.*s\\n\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->crc32);\n\t\t\toffset += sizeof(tOemKontronInformationRecordV1);\n\t\t\toffset++;\n\t\t} else {\n\t\t\tprintf(\"  Unsupported version %d\\n\", version);\n\t\t}\n\t}\n}\n\nstatic\nbool\nipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\tint off,int len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_header *h,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_oem_header *oh)\n{\n\tstatic bool badParams=false;\n\tbool hasChanged = false;\n\tint start = off;\n\tint offset = start;\n\tint length = len;\n\tint i;\n\tuint8_t record_id = 0;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tif(!badParams){\n\t\t/* the 'OEM' field is already checked in caller */\n\t\tif( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){\n\t\t\tif(strncmp(\"oem\", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){\n\t\t\t\tprintf(\"usage: fru edit <id> <oem> <args...>\\n\");\n\t\t\t\tbadParams = true;\n\t\t\t\treturn hasChanged;\n\t\t\t}\n\t\t}\n\t\tif( argc<EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT ){\n\t\t\tprintf(\"usage: oem <iana> <recordid> <format> <args...>\\n\");\n\t\t\tprintf(\"usage: oem 15000 3 0 <name> <instance> <field1>\"\\\n\t\t\t\t\t\" <field2> <field3> <crc32>\\n\");\n\t\t\tbadParams = true;\n\t\t\treturn hasChanged;\n\t\t}\n\t\tif (str2uchar(argv[OEM_KONTRON_RECORDID_ARG_POS], &record_id) != 0) {\n\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\"Record ID argument '%s' is either invalid or out of range.\",\n\t\t\t\t\targv[OEM_KONTRON_RECORDID_ARG_POS]);\n\t\t\tbadParams = true;\n\t\t\treturn hasChanged;\n\t\t}\n\t\tif (record_id == OEM_KONTRON_INFORMATION_RECORD) {\n\t\t\tfor(i=OEM_KONTRON_VERSION_ARG_POS;i<=OEM_KONTRON_CRC32_ARG_POS;i++){\n\t\t\t\tif( (strlen(argv[i]) != OEM_KONTRON_FIELD_SIZE) &&\n\t\t\t\t\t(strlen(argv[i]) != OEM_KONTRON_VERSION_FIELD_SIZE)) {\n\t\t\t\t\tprintf(\"error: version fields must have %d characters\\n\",\n\t\t\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\tbadParams = true;\n\t\t\t\t\treturn hasChanged;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!badParams){\n\n\t\tif(oh->record_id == OEM_KONTRON_INFORMATION_RECORD ) {\n\t\t\tuint8_t formatVersion = 0;\n\t\t\tuint8_t version;\n\n\t\t\tif (str2uchar(argv[OEM_KONTRON_FORMAT_ARG_POS], &formatVersion) != 0) {\n\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\"Format argument '%s' is either invalid or out of range.\",\n\t\t\t\t\t\targv[OEM_KONTRON_FORMAT_ARG_POS]);\n\t\t\t\tbadParams = true;\n\t\t\t\treturn hasChanged;\n\t\t\t}\n\n\t\t\tprintf(\"   Kontron OEM Information Record\\n\");\n\t\t\tversion = oh->record_version;\n\n\t\t\tif( version == formatVersion  ){\n\t\t\t\tuint8_t blockCount;\n\t\t\t\tuint8_t blockIndex=0;\n\n\t\t\t\tuint8_t matchInstance = 0;\n\t\t\t\tuint8_t instance = 0;\n\t\t\t\t\n\t\t\t\tif (str2uchar(argv[OEM_KONTRON_INSTANCE_ARG_POS], &instance) != 0) {\n\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\"Instance argument '%s' is either invalid or out of range.\",\n\t\t\t\t\t\t\targv[OEM_KONTRON_INSTANCE_ARG_POS]);\n\t\t\t\t\tbadParams = true;\n\t\t\t\t\treturn hasChanged;\n\t\t\t\t}\n\n\t\t\t\tblockCount = fru_data[offset++];\n\t\t\t\tprintf(\"   blockCount: %d\\n\",blockCount);\n\n\t\t\t\tfor(blockIndex=0;blockIndex<blockCount;blockIndex++){\n\t\t\t\t\tvoid * pRecordData;\n\t\t\t\t\tuint8_t nameLen;\n\n\t\t\t\t\tnameLen = ( fru_data[offset++] & 0x3F );\n\n\t\t\t\t\tif( version == 0 || version == 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t(const char *)(fru_data+offset),nameLen)&& (matchInstance == instance)){\n\n\t\t\t\t\t\t\tprintf (\"Found : %s\\n\",argv[OEM_KONTRON_NAME_ARG_POS]);\n\t\t\t\t\t\t\toffset+=nameLen;\n\n\t\t\t\t\t\t\tpRecordData =  &fru_data[offset];\n\n\t\t\t\t\t\t\tif( version == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field1 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_VERSION_ARG_POS] ,\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field2 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_BUILDDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field3 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_UPDATEDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->crc32 ,\n\t\t\t\t\t\t\targv[OEM_KONTRON_CRC32_ARG_POS] ,\n\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field1 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_VERSION_ARG_POS] ,\n\t\t\t\t\t\t\t\tOEM_KONTRON_VERSION_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field2 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_BUILDDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field3 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_UPDATEDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->crc32 ,\n\t\t\t\t\t\t\targv[OEM_KONTRON_CRC32_ARG_POS] ,\n\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmatchInstance++;\n\t\t\t\t\t\t\thasChanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t\t(const char *)(fru_data+offset), nameLen)){\n\t\t\t\t\t\t\tprintf (\"Skipped : %s  [instance %d]\\n\",argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t\t\t\t(unsigned int)matchInstance);\n\t\t\t\t\t\t\tmatchInstance++;\n\t\t\t\t\t\t\toffset+=nameLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toffset+=nameLen;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( version == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset+= sizeof(tOemKontronInformationRecordV0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset+= sizeof(tOemKontronInformationRecordV1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf (\"  Unsupported version %d\\n\",version);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"   Version: %d\\n\",version);\n\t\t\t}\n\t\t}\n\t\tif( hasChanged ){\n\n\t\t\tuint8_t record_checksum =0;\n\t\t\tuint8_t header_checksum =0;\n\t\t\tint index;\n\n\t\t\tlprintf(LOG_DEBUG,\"Initial record checksum : %x\",h->record_checksum);\n\t\t\tlprintf(LOG_DEBUG,\"Initial header checksum : %x\",h->header_checksum);\n\t\t\tfor(index=0;index<length;index++){\n\t\t\t\trecord_checksum+=  fru_data[start+index];\n\t\t\t}\n\t\t\t/* Update Record checksum */\n\t\t\th->record_checksum =  ~record_checksum + 1;\n\n\n\t\t\tfor(index=0;index<(sizeof(struct fru_multirec_header) -1);index++){\n\t\t\t\tuint8_t data= *( (uint8_t *)h+ index);\n\t\t\t\theader_checksum+=data;\n\t\t\t}\n\t\t\t/* Update header checksum */\n\t\t\th->header_checksum =  ~header_checksum + 1;\n\n\t\t\tlprintf(LOG_DEBUG,\"Final record checksum : %x\",h->record_checksum);\n\t\t\tlprintf(LOG_DEBUG,\"Final header checksum : %x\",h->header_checksum);\n\n\t\t\t/* write back data */\n\t\t}\n\t}\n\n\treturn hasChanged;\n}\n\n/* ipmi_fru_picmg_ext_edit  -  Query new values to replace original FRU content\n*\n* @data:   FRU data\n* @offset: start of the current multi record (start of header)\n* @len:    len of the current record (excluding header)\n* @h:      pointer to record header\n* @oh:     pointer to OEM /PICMG header\n*\n* returns: TRUE if data changed\n* returns: FALSE if data not changed\n*/\nstatic\nbool\nipmi_fru_picmg_ext_edit(uint8_t * fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\tint off,int len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_header *h,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_oem_header *oh)\n{\n\tbool hasChanged = false;\n\tint start = off;\n\tint offset = start;\n\tint length = len;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tswitch (oh->record_id)\n\t{\n\t\tcase FRU_AMC_ACTIVATION:\n\t\t\tprintf(\"    FRU_AMC_ACTIVATION\\n\");\n\t\t\t{\n\t\t\t\tint index=offset;\n\t\t\t\tuint16_t max_current;\n\n\t\t\t\tmax_current = fru_data[offset];\n\t\t\t\tmax_current |= fru_data[++offset]<<8;\n\n\t\t\t\tprintf(\"      Maximum Internal Current(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)max_current / 10.0f, max_current);\n\n\t\t\t\tif( ipmi_fru_query_new_value(fru_data,index,2) ){\n\t\t\t\t\tmax_current = fru_data[index];\n\t\t\t\t\tmax_current |= fru_data[++index]<<8;\n\t\t\t\t\tprintf(\"      New Maximum Internal Current(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)max_current / 10.0f, max_current);\n\t\t\t\t\thasChanged = true;\n\n\t\t\t\t}\n\n\t\t\t\tprintf(\"      Module Activation Readiness:       %i sec.\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"      Descriptor Count: %i\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tfor (++offset;\n\t\t\t\t\toffset < (off + length);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_activation_record)) {\n\t\t\t\t\tstruct fru_picmgext_activation_record * a =\n\t\t\t\t\t\t(struct fru_picmgext_activation_record *) &fru_data[offset];\n\n\t\t\t\t\tprintf(\"        IPMB-Address:         0x%x\\n\", a->ibmb_addr);\n\t\t\t\t\tprintf(\"        Max. Module Current:  %.2f A\\n\", (float)a->max_module_curr / 10.0f);\n\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CURRENT:\n\t\t\tprintf(\"    FRU_AMC_CURRENT\\n\");\n\t\t\t{\n\t\t\t\tint index=offset;\n\t\t\t\tunsigned char current;\n\n\t\t\t\tcurrent = fru_data[index];\n\n\t\t\t\tprintf(\"      Current draw(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)current / 10.0f, current);\n\n\t\t\t\tif( ipmi_fru_query_new_value(fru_data, index, 1) ){\n\t\t\t\t\tcurrent = fru_data[index];\n\n\t\t\t\t\tprintf(\"      New Current draw(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)current / 10.0f, current);\n\t\t\t\t\thasChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif( hasChanged ){\n\n\t\tuint8_t record_checksum =0;\n\t\tuint8_t header_checksum =0;\n\t\tint index;\n\n\t\tlprintf(LOG_DEBUG,\"Initial record checksum : %x\",h->record_checksum);\n\t\tlprintf(LOG_DEBUG,\"Initial header checksum : %x\",h->header_checksum);\n\t\tfor(index=0;index<length;index++){\n\t\t\trecord_checksum+=  fru_data[start+index];\n\t\t}\n\t\t/* Update Record checksum */\n\t\th->record_checksum =  ~record_checksum + 1;\n\n\n\t\tfor(index=0;index<(sizeof(struct fru_multirec_header) -1);index++){\n\t\t\tuint8_t data= *( (uint8_t *)h+ index);\n\t\t\theader_checksum+=data;\n\t\t}\n\t\t/* Update header checksum */\n\t\th->header_checksum =  ~header_checksum + 1;\n\n\t\tlprintf(LOG_DEBUG,\"Final record checksum : %x\",h->record_checksum);\n\t\tlprintf(LOG_DEBUG,\"Final header checksum : %x\",h->header_checksum);\n\n\t\t/* write back data */\n\t}\n\n\treturn hasChanged;\n}\n\n/* ipmi_fru_picmg_ext_print  - prints OEM fru record (PICMG)\n*\n* @fru_data:  FRU data\n* @offset:    offset of the bytes to be modified in data\n* @length:    size of the record\n*\n* returns : n/a\n*/\nstatic void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length)\n{\n\tstruct fru_multirec_oem_header *h;\n\tint guid_count;\n\tint offset = off;\n\tint start_offset = off;\n\tint i;\n\n\th = (struct fru_multirec_oem_header *) &fru_data[offset];\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tswitch (h->record_id)\n\t{\n\t\tcase FRU_PICMG_BACKPLANE_P2P:\n\t\t{\n\t\t\tuint8_t index;\n\t\t\tunsigned int data;\n\t\t\tstruct fru_picmgext_slot_desc *slot_d;\n\n\t\t\tslot_d =\n\t\t\t\t(struct fru_picmgext_slot_desc*)&fru_data[offset];\n\t\t\toffset += sizeof(struct fru_picmgext_slot_desc);\n\t\t\tprintf(\"    FRU_PICMG_BACKPLANE_P2P\\n\");\n\n\t\t\twhile (offset <= (start_offset+length)) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"    Channel Type:  \");\n\t\t\t\tswitch (slot_d->chan_type)\n\t\t\t\t{\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\tcase 0x07:\n\t\t\t\t\t\tprintf(\"PICMG 2.9\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x08:\n\t\t\t\t\t\tprintf(\"Single Port Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x09:\n\t\t\t\t\t\tprintf(\"Double Port Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0a:\n\t\t\t\t\t\tprintf(\"Full Channel Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0b:\n\t\t\t\t\t\tprintf(\"Base IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0c:\n\t\t\t\t\t\tprintf(\"Update Channel IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0d:\n\t\t\t\t\t\tprintf(\"ShMC Cross Connect\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"Unknown IF (0x%x)\\n\",\n\t\t\t\t\t\t\t\tslot_d->chan_type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"    Slot Addr.   : %02x\\n\",\n\t\t\t\t\t\tslot_d->slot_addr );\n\t\t\t\tprintf(\"    Channel Count: %i\\n\",\n\t\t\t\t\t\tslot_d->chn_count);\n\n\t\t\t\tfor (index = 0;\n\t\t\t\t\t\tindex < (slot_d->chn_count);\n\t\t\t\t\t\tindex++) {\n\t\t\t\t\tstruct fru_picmgext_chn_desc *d;\n\t\t\t\t\tdata = (fru_data[offset+0]) |\n\t\t\t\t\t\t(fru_data[offset+1] << 8) |\n\t\t\t\t\t\t(fru_data[offset+2] << 16);\n\t\t\t\t\td = (struct fru_picmgext_chn_desc *)&data;\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tprintf( \"       \"\n\t\t\t\t\t\t\t\t\"Chn: %02x  ->  \"\n\t\t\t\t\t\t\t\t\"Chn: %02x in \"\n\t\t\t\t\t\t\t\t\"Slot: %02x\\n\",\n\t\t\t\t\t\t\t\td->local_chn,\n\t\t\t\t\t\t\t\td->remote_chn,\n\t\t\t\t\t\t\t\td->remote_slot);\n\t\t\t\t\t}\n\t\t\t\t\toffset += FRU_PICMGEXT_CHN_DESC_RECORD_SIZE;\n\t\t\t\t}\n\t\t\t\tslot_d = (struct fru_picmgext_slot_desc*)&fru_data[offset];\n\t\t\t\toffset += sizeof(struct fru_picmgext_slot_desc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_ADDRESS_TABLE:\n\t\t{\n\t\t\tunsigned int hwaddr;\n\t\t\tunsigned int sitetype;\n\t\t\tunsigned int sitenum;\n\t\t\tunsigned int entries;\n\t\t\tunsigned int i;\n\t\t\tchar *picmg_site_type_strings[] = {\n\t\t\t\t\t\"AdvancedTCA Board\",\n\t\t\t\t\t\"Power Entry\",\n\t\t\t\t\t\"Shelf FRU Information\",\n\t\t\t\t\t\"Dedicated ShMC\",\n\t\t\t\t\t\"Fan Tray\",\n\t\t\t\t\t\"Fan Filter Tray\",\n\t\t\t\t\t\"Alarm\",\n\t\t\t\t\t\"AdvancedMC Module\",\n\t\t\t\t\t\"PMC\",\n\t\t\t\t\t\"Rear Transition Module\"};\n\n\n\t\t\tprintf(\"    FRU_PICMG_ADDRESS_TABLE\\n\");\n\t\t\tprintf(\"      Type/Len:  0x%02x\\n\", fru_data[offset++]);\n\t\t\tprintf(\"      Shelf Addr: \");\n\t\t\tfor (i=0;i<20;i++) {\n\t\t\t\tprintf(\"0x%02x \", fru_data[offset++]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tentries = fru_data[offset++];\n\t\t\tprintf(\"      Addr Table Entries: 0x%02x\\n\", entries);\n\n\t\t\tfor (i=0; i<entries; i++) {\n\t\t\t\thwaddr = fru_data[offset];\n\t\t\t\tsitenum = fru_data[offset + 1];\n\t\t\t\tsitetype = fru_data[offset + 2];\n\t\t\t\tprintf(\n\t\t\t\t\t\t\"        HWAddr: 0x%02x (0x%02x) SiteNum: %d SiteType: 0x%02x %s\\n\",\n\t\t\t\t\t\thwaddr, hwaddr * 2,\n\t\t\t\t\t\tsitenum, sitetype,\n\t\t\t\t\t\t(sitetype < 0xa) ?\n\t\t\t\t\t\tpicmg_site_type_strings[sitetype] :\n\t\t\t\t\t\t\"Reserved\");\n\t\t\t\toffset += 3;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHELF_POWER_DIST:\n\t\t{\n\t\t\tunsigned int entries;\n\t\t\tunsigned int feeds;\n\t\t\tunsigned int hwaddr;\n\t\t\tunsigned int i;\n\t\t\tunsigned int id;\n\t\t\tunsigned int j;\n\t\t\tunsigned int maxext;\n\t\t\tunsigned int maxint;\n\t\t\tunsigned int minexp;\n\n\t\t\tprintf(\"    FRU_PICMG_SHELF_POWER_DIST\\n\");\n\n\t\t\tfeeds = fru_data[offset++];\n\t\t\tprintf(\"      Number of Power Feeds:   0x%02x\\n\",\n\t\t\t\t\tfeeds);\n\n\t\t\tfor (i=0; i<feeds; i++) {\n\t\t\t\tprintf(\"    Feed %d:\\n\", i);\n\t\t\t\tmaxext = fru_data[offset] |\n\t\t\t\t\t(fru_data[offset+1] << 8);\n\t\t\t\toffset += 2;\n\t\t\t\tmaxint = fru_data[offset] |\n\t\t\t\t\t(fru_data[offset+1] << 8);\n\t\t\t\toffset += 2;\n\t\t\t\tminexp = fru_data[offset];\n\t\t\t\toffset += 1;\n\t\t\t\tentries = fru_data[offset];\n\t\t\t\toffset += 1;\n\n\t\t\t\tprintf(\n\t\t\t\t\t\t\"      Max External Current:   %d.%d Amps (0x%04x)\\n\",\n\t\t\t\t\t\tmaxext / 10, maxext % 10, maxext);\n\t\t\t\tif (maxint < 0xffff) {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Max Internal Current:   %d.%d Amps (0x%04x)\\n\",\n\t\t\t\t\t\t\tmaxint / 10, maxint % 10,\n\t\t\t\t\t\t\tmaxint);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Max Internal Current:   Not Specified\\n\");\n\t\t\t\t}\n\n\t\t\t\tif (minexp >= 0x48 && minexp <= 0x90) {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Min Expected Voltage:   -%02d.%dV\\n\",\n\t\t\t\t\t\t\tminexp / 2, (minexp % 2) * 5);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Min Expected Voltage:   -%dV (actual invalid value 0x%x)\\n\",\n\t\t\t\t\t\t\t36, minexp);\n\t\t\t\t}\n\t\t\t\tfor (j=0; j < entries; j++) {\n\t\t\t\t\thwaddr = fru_data[offset++];\n\t\t\t\t\tid = fru_data[offset++];\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"        FRU HW Addr: 0x%02x (0x%02x)\",\n\t\t\t\t\t\t\thwaddr, hwaddr * 2);\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"   FRU ID: 0x%02x\\n\",\n\t\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHELF_ACTIVATION:\n\t\t{\n\t\t\tunsigned int i;\n\t\t\tunsigned int count = 0;\n\n\t\t\tprintf(\"    FRU_PICMG_SHELF_ACTIVATION\\n\");\n\t\t\tprintf(\n\t\t\t\t\t\"      Allowance for FRU Act Readiness:   0x%02x\\n\",\n\t\t\t\t\tfru_data[offset++]);\n\n\t\t\tcount = fru_data[offset++];\n\t\t\tprintf(\n\t\t\t\t\t\"      FRU activation and Power Desc Cnt: 0x%02x\\n\",\n\t\t\t\t\tcount);\n\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tprintf(\"         HW Addr: 0x%02x \",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t\tprintf(\"         FRU ID: 0x%02x \",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t\tprintf(\"         Max FRU Power: 0x%04x \",\n\t\t\t\t\t\tfru_data[offset+0] |\n\t\t\t\t\t\t(fru_data[offset+1]<<8));\n\t\t\t\toffset += 2;\n\t\t\t\tprintf(\"         Config: 0x%02x \\n\",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHMC_IP_CONN:\n\t\t\tprintf(\"    FRU_PICMG_SHMC_IP_CONN\\n\");\n\t\t\tbreak;\n\n\t\tcase FRU_PICMG_BOARD_P2P:\n\t\t\tprintf(\"    FRU_PICMG_BOARD_P2P\\n\");\n\n\t\t\tguid_count = fru_data[offset++];\n\t\t\tprintf(\"      GUID count: %2d\\n\", guid_count);\n\t\t\tfor (i = 0 ; i < guid_count; i++ ) {\n\t\t\t\tint j;\n\t\t\t\tprintf(\"        GUID [%2d]: 0x\", i);\n\n\t\t\t\tfor (j=0; j < sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\tj++) {\n\t\t\t\t\tprintf(\"%02x\", fru_data[offset+j]);\n\t\t\t\t}\n\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\toffset += sizeof(struct fru_picmgext_guid);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tfor (; offset < off + length;\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_link_desc)) {\n\n\t\t\t\t/* to solve little endian /big endian problem */\n\t\t\t\tstruct fru_picmgext_link_desc *d;\n\t\t\t\tunsigned int data = (fru_data[offset+0]) |\n\t\t\t\t\t(fru_data[offset+1] << 8) |\n\t\t\t\t\t(fru_data[offset+2] << 16) |\n\t\t\t\t\t(fru_data[offset+3] << 24);\n\t\t\t\td = (struct fru_picmgext_link_desc *) &data;\n\n\t\t\t\tprintf(\"      Link Grouping ID:     0x%02x\\n\",\n\t\t\t\t\t\td->grouping);\n\t\t\t\tprintf(\"      Link Type Extension:  0x%02x - \",\n\t\t\t\t\t\td->ext);\n\t\t\t\tif (d->type == FRU_PICMGEXT_LINK_TYPE_BASE) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"10/100/1000BASE-T Link (four-pair)\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"ShMC Cross-connect (two-pair)\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"1000Base-BX\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"10GBase-BX4 [XAUI]\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tprintf(\"FC-PI\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tprintf(\"1000Base-KX\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tprintf(\"10GBase-KX4\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET_10GBD) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"10GBase-KR\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"40GBase-KR4\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_PCIE) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t}\n\n\t\t\t\tprintf(\"      Link Type:            0x%02x - \",\n\t\t\t\t\t\td->type);\n\t\t\t\tswitch (d->type) {\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_BASE:\n\t\t\t\t\t\tprintf(\"PICMG 3.0 Base Interface 10/100/1000\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET:\n\t\t\t\t\t\tprintf(\"PICMG 3.1 Ethernet Fabric Interface\\n\");\n\t\t\t\t\t\tprintf(\"                                   Base signaling Link Class\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND:\n\t\t\t\t\t\tprintf(\"PICMG 3.2 Infiniband Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR:\n\t\t\t\t\t\tprintf(\"PICMG 3.3 Star Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase  FRU_PICMGEXT_LINK_TYPE_PCIE:\n\t\t\t\t\t\tprintf(\"PICMG 3.4 PCI Express Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET_10GBD:\n\t\t\t\t\t\tprintf(\"PICMG 3.1 Ethernet Fabric Interface\\n\");\n\t\t\t\t\t\tprintf(\"                                   10.3125Gbd signaling Link Class\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (d->type == 0 || d->type == 0xff) {\n\t\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\t} else if (d->type >= 0x06 && d->type <= 0xef) {\n\t\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\t} else if (d->type >= 0xf0 && d->type <= 0xfe) {\n\t\t\t\t\t\t\tprintf(\"OEM GUID Definition\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"Invalid\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"      Link Designator: \\n\");\n\t\t\t\tprintf(\"        Port Flag:            0x%02x\\n\",\n\t\t\t\t\t\td->desig_port);\n\t\t\t\tprintf(\"        Interface:            0x%02x - \",\n\t\t\t\t\t\td->desig_if);\n\t\t\t\tswitch (d->desig_if) {\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_BASE:\n\t\t\t\t\t\tprintf(\"Base Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_FABRIC:\n\t\t\t\t\t\tprintf(\"Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_UPDATE_CHANNEL:\n\t\t\t\t\t\tprintf(\"Update Channel\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_RESERVED:\n\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"Invalid\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"        Channel Number:       0x%02x\\n\",\n\t\t\t\t\t\td->desig_channel);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CURRENT:\n\t\t{\n\t\t\tunsigned char current;\n\t\t\tprintf(\"    FRU_AMC_CURRENT\\n\");\n\n\t\t\tcurrent = fru_data[offset];\n\t\t\tprintf(\"      Current draw(@12V): %.2f A [ %.2f Watt ]\\n\",\n\t\t\t\t\t(float)current / 10.0f,\n\t\t\t\t\t(float)current / 10.0f * 12.0f);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_AMC_ACTIVATION:\n\t\t\tprintf(\"    FRU_AMC_ACTIVATION\\n\");\n\t\t\t{\n\t\t\t\tuint16_t max_current;\n\n\t\t\t\tmax_current = fru_data[offset];\n\t\t\t\tmax_current |= fru_data[++offset]<<8;\n\t\t\t\tprintf(\"      Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\\n\",\n\t\t\t\t\t\t(float)max_current / 10.0f,\n\t\t\t\t\t\t(float)max_current / 10.0f * 12.0f);\n\n\t\t\t\tprintf(\"      Module Activation Readiness:    %i sec.\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"      Descriptor Count: %i\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tfor(++offset; offset < off + length;\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_activation_record))\n\t\t\t\t{\n\t\t\t\t\tstruct fru_picmgext_activation_record *a;\n\t\t\t\t\ta = (struct fru_picmgext_activation_record *)&fru_data[offset];\n\t\t\t\t\tprintf(\"        IPMB-Address:         0x%x\\n\",\n\t\t\t\t\t\t\ta->ibmb_addr);\n\t\t\t\t\tprintf(\"        Max. Module Current:  %.2f A\\n\",\n\t\t\t\t\t\t\t(float)a->max_module_curr / 10.0f);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CARRIER_P2P:\n\t\t\t{\n\t\t\t\tuint16_t index;\n\t\t\t\tprintf(\"    FRU_CARRIER_P2P\\n\");\n\t\t\t\tfor(; offset < off + length; ) {\n\t\t\t\t\tstruct fru_picmgext_carrier_p2p_record * h =\n\t\t\t\t\t\t(struct fru_picmgext_carrier_p2p_record *)&fru_data[offset];\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\tprintf(\"      Resource ID:      %i\",\n\t\t\t\t\t\t\t(h->resource_id & 0x07));\n\t\t\t\t\t\tprintf(\"  Type: \");\n\t\t\t\t\tif ((h->resource_id>>7) == 1) {\n\t\t\t\t\t\tprintf(\"AMC\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Local\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"      Descriptor Count: %i\\n\",\n\t\t\t\t\t\t\th->p2p_count);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_carrier_p2p_record);\n\t\t\t\t\tfor (index = 0; index < h->p2p_count; index++) {\n\t\t\t\t\t\t/* to solve little endian /big endian problem */\n\t\t\t\t\t\tunsigned char data[3];\n\t\t\t\t\t\tstruct fru_picmgext_carrier_p2p_descriptor * desc;\n# ifndef WORDS_BIGENDIAN\n\t\t\t\t\t\tdata[0] = fru_data[offset+0];\n\t\t\t\t\t\tdata[1] = fru_data[offset+1];\n\t\t\t\t\t\tdata[2] = fru_data[offset+2];\n# else\n\t\t\t\t\t\tdata[0] = fru_data[offset+2];\n\t\t\t\t\t\tdata[1] = fru_data[offset+1];\n\t\t\t\t\t\tdata[2] = fru_data[offset+0];\n# endif\n\t\t\t\t\t\tdesc = (struct fru_picmgext_carrier_p2p_descriptor*)&data;\n\t\t\t\t\t\tprintf(\"        Port: %02d\\t->  Remote Port: %02d\\t\",\n\t\t\t\t\t\t\t\tdesc->local_port, desc->remote_port);\n\t\t\t\t\t\tif ((desc->remote_resource_id >> 7) == 1) {\n\t\t\t\t\t\t\tprintf(\"[ AMC   ID: %02d ]\\n\",\n\t\t\t\t\t\t\t\t\tdesc->remote_resource_id & 0x0F);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"[ local ID: %02d ]\\n\",\n\t\t\t\t\t\t\t\t\tdesc->remote_resource_id & 0x0F);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_carrier_p2p_descriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_P2P:\n\t\t\t{\n\t\t\t\tunsigned int index;\n\t\t\t\tunsigned char channel_count;\n\t\t\t\tstruct fru_picmgext_amc_p2p_record * h;\n\t\t\t\tprintf(\"    FRU_AMC_P2P\\n\");\n\t\t\t\tguid_count = fru_data[offset];\n\t\t\t\tprintf(\"      GUID count: %2d\\n\", guid_count);\n\t\t\t\tfor (i = 0 ; i < guid_count; i++) {\n\t\t\t\t\tint j;\n\t\t\t\t\tprintf(\"        GUID %2d: \", i);\n\t\t\t\t\tfor (j=0; j < sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\t\tj++) {\n\t\t\t\t\t\tprintf(\"%02x\", fru_data[offset+j]);\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\th = (struct fru_picmgext_amc_p2p_record *)&fru_data[++offset];\n\t\t\t\t\tprintf(\"      %s\",\n\t\t\t\t\t\t\t(h->record_type ?\n\t\t\t\t\t\t\t \"AMC Module:\" : \"On-Carrier Device\"));\n\t\t\t\t\tprintf(\"   Resource ID: %i\\n\", h->resource_id);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_amc_p2p_record);\n\t\t\t\t\tchannel_count = fru_data[offset++];\n\t\t\t\t\tprintf(\"       Descriptor Count: %i\\n\",\n\t\t\t\t\t\t\tchannel_count);\n\t\t\t\t\tfor (index = 0; index < channel_count; index++) {\n\t\t\t\t\t\tunsigned int data;\n\t\t\t\t\t\tstruct fru_picmgext_amc_channel_desc_record *d;\n\t\t\t\t\t\t/* pack the data in little endian format.\n\t\t\t\t\t\t * Stupid intel...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdata = fru_data[offset] |\n\t\t\t\t\t\t\t(fru_data[offset + 1] << 8) |\n\t\t\t\t\t\t\t(fru_data[offset + 2] << 16);\n\t\t\t\t\t\td = (struct fru_picmgext_amc_channel_desc_record *)&data;\n\t\t\t\t\t\tprintf(\"        Lane 0 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane0port);\n\t\t\t\t\t\tprintf(\"        Lane 1 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane1port);\n\t\t\t\t\t\tprintf(\"        Lane 2 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane2port);\n\t\t\t\t\t\tprintf(\"        Lane 3 Port: %i\\n\\n\",\n\t\t\t\t\t\t\t\td->lane3port);\n\t\t\t\t\t\toffset += FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; offset < off + length;) {\n\t\t\t\t\t\tunsigned int data[2];\n\t\t\t\t\t\tstruct fru_picmgext_amc_link_desc_record *l;\n\t\t\t\t\t\tl = (struct fru_picmgext_amc_link_desc_record *)&data[0];\n\t\t\t\t\t\tdata[0] = fru_data[offset] |\n\t\t\t\t\t\t\t(fru_data[offset + 1] << 8) |\n\t\t\t\t\t\t\t(fru_data[offset + 2] << 16) |\n\t\t\t\t\t\t\t(fru_data[offset + 3] << 24);\n\t\t\t\t\t\tdata[1] = fru_data[offset + 4];\n\t\t\t\t\t\tprintf( \"      Link Designator:  Channel ID: %i\\n\"\n\t\t\t\t\t\t\t\t\"            Port Flag 0: %s%s%s%s\\n\",\n\t\t\t\t\t\t\t\tl->channel_id,\n\t\t\t\t\t\t\t\t(l->port_flag_0)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_1)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_2)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_3)?\"o\":\"-\"  );\n\t\t\t\t\t\tswitch (l->type) {\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE:\n\t\t\t\t\t\t\t\t/* AMC.1 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.1 PCI Express\\n\", l->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G1_NSSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 1 capable - non SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G1_SSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 1 capable - SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G2_NSSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 2 capable - non SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G2_SSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 2 capable - SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS1:\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS2:\n\t\t\t\t\t\t\t\t/* AMC.1 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.1 PCI Express Advanced Switching\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_ETHERNET:\n\t\t\t\t\t\t\t\t/* AMC.2 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.2 Ethernet\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_ETH_1000_BX:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" 1000Base-Bx (SerDES Gigabit) Ethernet Link\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_ETH_10G_XAUI:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" 10Gbit XAUI Ethernet Link\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_STORAGE:\n\t\t\t\t\t\t\t\t/* AMC.3 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.3 Storage\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_FC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Fibre Channel\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_SATA:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Serial ATA\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_SAS:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Serial Attached SCSI\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_RAPIDIO:\n\t\t\t\t\t\t\t\t/* AMC.4 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.4 Serial Rapid IO\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"reserved or OEM GUID\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprintf(\"        Link group Id:   %i\\n\",\n\t\t\t\t\t\t\t\tl->group_id);\n\t\t\t\t\t\tprintf(\"        Link Asym Match: %i\\n\\n\",\n\t\t\t\t\t\t\t\tl->asym_match);\n\t\t\t\t\t\toffset += FRU_PICMGEXT_AMC_LINK_DESC_RECORD_SIZE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CARRIER_INFO:\n\t\t{\n\t\t\tunsigned char extVersion;\n\t\t\tunsigned char siteCount;\n\n\t\t\tprintf(\"    FRU_CARRIER_INFO\\n\");\n\n\t\t\textVersion = fru_data[offset++];\n\t\t\tsiteCount  = fru_data[offset++];\n\n\t\t\tprintf(\"      AMC.0 extension version: R%d.%d\\n\",\n\t\t\t\t\t(extVersion >> 0)& 0x0F,\n\t\t\t\t\t(extVersion >> 4)& 0x0F );\n\t\t\tprintf(\"      Carrier Sie Number Cnt: %d\\n\", siteCount);\n\n\t\t\tfor (i = 0 ; i < siteCount; i++ ){\n\t\t\t\tprintf(\"       Site ID: %i \\n\", fru_data[offset++]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t\tcase FRU_PICMG_CLK_CARRIER_P2P:\n\t\t{\n\t\t\tunsigned char desc_count;\n\t\t\tint i,j;\n\n\t\t\tprintf(\"    FRU_PICMG_CLK_CARRIER_P2P\\n\");\n\n\t\t\tdesc_count = fru_data[offset++];\n\n\t\t\tfor(i=0; i<desc_count; i++){\n\t\t\t\tunsigned char resource_id;\n\t\t\t\tunsigned char channel_count;\n\n\t\t\t\tresource_id   = fru_data[offset++];\n\t\t\t\tchannel_count = fru_data[offset++];\n\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"      Clock Resource ID: 0x%02x  Type: \", resource_id);\n\t\t\t\tif((resource_id & 0xC0)>>6 == 0) {printf(\"On-Carrier-Device\\n\");}\n\t\t\t\telse if((resource_id & 0xC0)>>6 == 1) {printf(\"AMC slot\\n\");}\n\t\t\t\telse if((resource_id & 0xC0)>>6 == 2) {printf(\"Backplane\\n\");}\n\t\t\t\telse{ printf(\"reserved\\n\");}\n\t\t\t\tprintf(\"      Channel Count: 0x%02x\\n\", channel_count);\n\n\t\t\t\tfor(j=0; j<channel_count; j++){\n\t\t\t\t\tunsigned char loc_channel, rem_channel, rem_resource;\n\n\t\t\t\t\tloc_channel  = fru_data[offset++];\n\t\t\t\t\trem_channel  = fru_data[offset++];\n\t\t\t\t\trem_resource = fru_data[offset++];\n\n\t\t\t\t\tprintf(\"        CLK-ID: 0x%02x    ->\", loc_channel);\n\t\t\t\t\tprintf(\" remote CLKID: 0x%02x   \", rem_channel);\n\t\t\t\t\tif((rem_resource & 0xC0)>>6 == 0) {printf(\"[ Carrier-Dev\");}\n\t\t\t\t\telse if((rem_resource & 0xC0)>>6 == 1) {printf(\"[ AMC slot   \");}\n\t\t\t\t\telse if((rem_resource & 0xC0)>>6 == 2) {printf(\"[ Backplane  \");}\n\t\t\t\t\telse{ printf(\"reserved         \");}\n\t\t\t\t\tprintf(\" 0x%02x ]\\n\", rem_resource&0xF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t\tcase FRU_PICMG_CLK_CONFIG:\n\t\t{\n\t\t\tunsigned char resource_id, descr_count;\n\t\t\tint i,j;\n\n\t\t\tprintf(\"    FRU_PICMG_CLK_CONFIG\\n\");\n\n\t\t\tresource_id = fru_data[offset++];\n\t\t\tdescr_count = fru_data[offset++];\n\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"      Clock Resource ID: 0x%02x\\n\", resource_id);\n\t\t\tprintf(\"      Descr. Count:      0x%02x\\n\", descr_count);\n\n\t\t\tfor(i=0; i<descr_count; i++){\n\t\t\t\tunsigned char channel_id, control;\n\t\t\t\tunsigned char indirect_cnt, direct_cnt;\n\n\t\t\t\tchannel_id = fru_data[offset++];\n\t\t\t\tcontrol    = fru_data[offset++];\n\t\t\t\tprintf(\"        CLK-ID: 0x%02x  -  \", channel_id);\n\t\t\t\tprintf(\"CTRL 0x%02x [ %12s ]\\n\",\n\t\t\t\t\t\t\t\t\tcontrol,\n\t\t\t\t\t\t\t\t\t((control&0x1)==0)?\"Carrier IPMC\":\"Application\");\n\n\t\t\t\tindirect_cnt = fru_data[offset++];\n\t\t\t\tdirect_cnt   = fru_data[offset++];\n\t\t\t\tprintf(\"         Cnt: Indirect 0x%02x  /  Direct 0x%02x\\n\",\n\t\t\t\t\t\tindirect_cnt,\n\t\t\t\t\t\tdirect_cnt);\n\n\t\t\t\t/* indirect desc */\n\t\t\t\tfor(j=0; j<indirect_cnt; j++){\n\t\t\t\t\tunsigned char feature;\n\t\t\t\t\tunsigned char dep_chn_id;\n\n\t\t\t\t\tfeature    = fru_data[offset++];\n\t\t\t\t\tdep_chn_id = fru_data[offset++];\n\n\t\t\t\t\tprintf(\"          Feature: 0x%02x [%8s] - \", feature, (feature&0x1)==1?\"Source\":\"Receiver\");\n\t\t\t\t\tprintf(\"          Dep. CLK-ID: 0x%02x\\n\", dep_chn_id);\n\t\t\t\t}\n\n\t\t\t\t/* direct desc */\n\t\t\t\tfor(j=0; j<direct_cnt; j++){\n\t\t\t\t\tunsigned char feature, family, accuracy;\n\t\t\t\t\tunsigned int freq, min_freq, max_freq;\n\n\t\t\t\t\tfeature  = fru_data[offset++];\n\t\t\t\t\tfamily   = fru_data[offset++];\n\t\t\t\t\taccuracy = fru_data[offset++];\n\t\t\t\t\tfreq     = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\t\t\t\t\tmin_freq = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\t\t\t\t\tmax_freq = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tprintf(\"          - Feature: 0x%02x  - PLL: %x / Asym: %s\\n\",\n\t\t\t\t\t\t\tfeature,\n\t\t\t\t\t\t\t(feature > 1) & 1,\n\t\t\t\t\t\t\t(feature&1)?\"Source\":\"Receiver\");\n\t\t\t\t\tprintf(\"            Family:  0x%02x  - AccLVL: 0x%02x\\n\", family, accuracy);\n\t\t\t\t\tprintf(\"            FRQ: %-9ld - min: %-9ld - max: %-9ld\\n\",\n\t\t\t\t\t\t\tfreq, min_freq, max_freq);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_UTCA_FRU_INFO_TABLE:\n\t\tcase FRU_UTCA_CARRIER_MNG_IP:\n\t\tcase FRU_UTCA_CARRIER_INFO:\n\t\tcase FRU_UTCA_CARRIER_LOCATION:\n\t\tcase FRU_UTCA_SHMC_IP_LINK:\n\t\tcase FRU_UTCA_POWER_POLICY:\n\t\tcase FRU_UTCA_ACTIVATION:\n\t\tcase FRU_UTCA_PM_CAPABILTY:\n\t\tcase FRU_UTCA_FAN_GEOGRAPHY:\n\t\tcase FRU_UTCA_CLOCK_MAPPING:\n\t\tcase FRU_UTCA_MSG_BRIDGE_POLICY:\n\t\tcase FRU_UTCA_OEM_MODULE_DESC:\n\t\t\tprintf(\"    Not implemented yet. uTCA specific record found!!\\n\");\n\t\t\tprintf(\"     - Record ID: 0x%02x\\n\", h->record_id);\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"    Unknown OEM Extension Record ID: %x\\n\", h->record_id);\n\t\tbreak;\n\n\t}\n}\n\n\n/* __ipmi_fru_print  -  Do actual work to print a FRU by its ID\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\n__ipmi_fru_print(struct ipmi_intf * intf, uint8_t id)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn 1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\treturn -1;\n\t}\n\n\t/* offsets need converted to bytes\n\t* but that conversion is not done to the structure\n\t* because we may end up with offset > 255\n\t* which would overflow our 1-byte offset field */\n\n\tlprintf(LOG_DEBUG, \"fru.header.version:         0x%x\",\n\t\theader.version);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.internal: 0x%x\",\n\t\theader.offset.internal * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.chassis:  0x%x\",\n\t\theader.offset.chassis * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.board:    0x%x\",\n\t\theader.offset.board * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.product:  0x%x\",\n\t\theader.offset.product * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.multi:    0x%x\",\n\t\theader.offset.multi * 8);\n\n\t/*\n\t* rather than reading the entire part\n\t* only read the areas we'll format\n\t*/\n\t/* chassis area */\n\tif ((header.offset.chassis*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_chassis(intf, &fru, id, header.offset.chassis*8);\n\n\t/* board area */\n\tif ((header.offset.board*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_board(intf, &fru, id, header.offset.board*8);\n\n\t/* product area */\n\tif ((header.offset.product*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_product(intf, &fru, id, header.offset.product*8);\n\n\t/* multirecord area */\n\tif( verbose==0 ) /* scipp parsing multirecord */\n\t\treturn 0;\n\n\tif ((header.offset.multi*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_multirec(intf, &fru, id, header.offset.multi*8);\n\n\treturn 0;\n}\n\n/* ipmi_fru_print  -  Print a FRU from its SDR locator record\n*\n* @intf:   ipmi interface\n* @fru: SDR FRU Locator Record\n*\n* returns -1 on error\n*/\nint\nipmi_fru_print(struct ipmi_intf * intf, struct sdr_record_fru_locator * fru)\n{\n\tchar desc[17];\n\tuint8_t  bridged_request = 0;\n\tuint32_t save_addr;\n\tuint32_t save_channel;\n\tint rc = 0;\n\n\tif (!fru)\n\t\treturn __ipmi_fru_print(intf, 0);\n\n\t/* Logical FRU Device\n\t*  dev_type == 0x10\n\t*  modifier\n\t*   0x00 = IPMI FRU Inventory\n\t*   0x01 = DIMM Memory ID\n\t*   0x02 = IPMI FRU Inventory\n\t*   0x03 = System Processor FRU\n\t*   0xff = unspecified\n\t*\n\t* EEPROM 24C01 or equivalent\n\t*  dev_type >= 0x08 && dev_type <= 0x0f\n\t*  modifier\n\t*   0x00 = unspecified\n\t*   0x01 = DIMM Memory ID\n\t*   0x02 = IPMI FRU Inventory\n\t*   0x03 = System Processor Cartridge\n\t*/\n\tif (fru->dev_type != 0x10 &&\n\t\t(fru->dev_type_modifier != 0x02 ||\n\t\tfru->dev_type < 0x08 || fru->dev_type > 0x0f))\n\t\treturn -1;\n\n\tif (fru->dev_slave_addr == IPMI_BMC_SLAVE_ADDR &&\n\t\tfru->device_id == 0)\n\t\treturn 0;\n\n\tmemset(desc, 0, sizeof(desc));\n\tmemcpy(desc, fru->id_string, fru->id_code & 0x01f);\n\tdesc[fru->id_code & 0x01f] = 0;\n\tprintf(\"FRU Device Description : %s (ID %d)\\n\", desc, fru->device_id);\n\n\tswitch (fru->dev_type_modifier) {\n\tcase 0x00:\n\tcase 0x02:\n\t\tif (BRIDGE_TO_SENSOR(intf, fru->dev_slave_addr,\n\t\t\t\t\t   fru->channel_num)) {\n\t\t\tbridged_request = 1;\n\t\t\tsave_addr = intf->target_addr;\n\t\t\tintf->target_addr = fru->dev_slave_addr;\n\t\t\tsave_channel = intf->target_channel;\n\t\t\tintf->target_channel = fru->channel_num;\n\t\t}\n\t\t/* print FRU */\n\t\trc = __ipmi_fru_print(intf, fru->device_id);\n\t\tif (bridged_request) {\n\t\t\tintf->target_addr = save_addr;\n\t\t\tintf->target_channel = save_channel;\n\t\t}\n\t\tbreak;\n\tcase 0x01:\n\t\trc = ipmi_spd_print_fru(intf, fru->device_id);\n\t\tbreak;\n\tdefault:\n\t\tif (verbose)\n\t\t\tprintf(\" Unsupported device 0x%02x \"\n\t\t\t\t\t\"type 0x%02x with modifier 0x%02x\\n\",\n\t\t\t\t\tfru->device_id, fru->dev_type,\n\t\t\t\t\tfru->dev_type_modifier);\n\t\telse\n\t\t\tprintf(\" Unsupported device\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\treturn rc;\n}\n\n/* ipmi_fru_print_all  -  Print builtin FRU + SDR FRU Locator records\n*\n* @intf:   ipmi interface\n*\n* returns -1 on error\n*/\nstatic int\nipmi_fru_print_all(struct ipmi_intf * intf)\n{\n\tstruct ipmi_sdr_iterator * itr;\n\tstruct sdr_get_rs * header;\n\tstruct sdr_record_fru_locator * fru;\n\tint rc;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct ipm_devid_rsp *devid;\n\tstruct sdr_record_mc_locator * mc;\n\tuint32_t save_addr;\n\n\tprintf(\"FRU Device Description : Builtin FRU Device (ID 0)\\n\");\n\t/* TODO: Figure out if FRU device 0 may show up in SDR records. */\n\n\t/* Do a Get Device ID command to determine device support */\n\tmemset (&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_APP;\n\treq.msg.cmd = BMC_GET_DEVICE_ID;\n\treq.msg.data_len = 0;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tlprintf(LOG_ERR, \"Get Device ID command failed\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tlprintf(LOG_ERR, \"Get Device ID command failed: %s\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tdevid = (struct ipm_devid_rsp *) rsp->data;\n\n\t/* Check the FRU inventory device bit to decide whether various */\n\t/* FRU commands can be issued to FRU device #0 LUN 0\t\t*/\n\n\tif (devid->adtl_device_support & 0x08) {\t/* FRU Inventory Device bit? */\n\t\trc = ipmi_fru_print(intf, NULL);\n\t\tprintf(\"\\n\");\n\t}\n\n\titr = ipmi_sdr_start(intf, 0);\n\tif (!itr)\n\t\treturn -1;\n\n\t/* Walk the SDRs looking for FRU Devices and Management Controller Devices. */\n\t/* For FRU devices, print the FRU from the SDR locator record.\t\t    */\n\t/* For MC devices, issue FRU commands to the satellite controller to print  */\n\t/* FRU data.\t\t\t\t\t\t\t\t    */\n\twhile ((header = ipmi_sdr_get_next_header(intf, itr)))\n\t{\n\t\tif (header->type == SDR_RECORD_TYPE_MC_DEVICE_LOCATOR ) {\n\t\t\t/* Check the capabilities of the Management Controller Device */\n\t\t\tmc = (struct sdr_record_mc_locator *)\n\t\t\t\tipmi_sdr_get_record(intf, header, itr);\n\t\t\t/* Does this MC device support FRU inventory device? */\n\t\t\tif (mc && (mc->dev_support & 0x08) && /* FRU inventory device? */\n\t\t\t\tintf->target_addr != mc->dev_slave_addr) {\n\t\t\t\t/* Yes. Prepare to issue FRU commands to FRU device #0 LUN 0  */\n\t\t\t\t/* using the slave address specified in the MC record.\t      */\n\n\t\t\t\t/* save current target address */\n\t\t\t\tsave_addr = intf->target_addr;\n\n\t\t\t\t/* set new target address to satellite controller */\n\t\t\t\tintf->target_addr = mc->dev_slave_addr;\n\n\t\t\t\tprintf(\"FRU Device Description : %-16s\\n\", mc->id_string);\n\n\t\t\t\t/* print the FRU by issuing FRU commands to the satellite     */\n\t\t\t\t/* controller.\t\t\t\t\t\t      */\n\t\t\t\trc = __ipmi_fru_print(intf, 0);\n\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\t/* restore previous target */\n\t\t\t\tintf->target_addr = save_addr;\n\t\t\t}\n\n\t\t\tfree_n(&mc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (header->type != SDR_RECORD_TYPE_FRU_DEVICE_LOCATOR)\n\t\t\tcontinue;\n\n\t\t/* Print the FRU from the SDR locator record. */\n\t\tfru = (struct sdr_record_fru_locator *)\n\t\t\tipmi_sdr_get_record(intf, header, itr);\n\t\tif (!fru || !fru->logical) {\n\t\t\tfree_n(&fru);\n\t\t\tcontinue;\n\t\t}\n\t\trc = ipmi_fru_print(intf, fru);\n\t\tfree_n(&fru);\n\t}\n\n\tipmi_sdr_end(itr);\n\n\treturn rc;\n}\n\n/* ipmi_fru_read_help() - print help text for 'read'\n *\n * returns void\n */\nvoid\nipmi_fru_read_help()\n{\n\tlprintf(LOG_NOTICE, \"fru read <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru read 0 /root/fru.bin\");\n} /* ipmi_fru_read_help() */\n\nstatic void\nipmi_fru_read_to_bin(struct ipmi_intf * intf,\n\t\t\tchar * pFileName,\n\t\t\tuint8_t fruId)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tuint8_t msg_data[4];\n\tuint8_t * pFruBuf;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t\treturn;\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (verbose) {\n\t\tprintf(\"Fru Size   = %d bytes\\n\",fru.size);\n\t\tprintf(\"Fru Access = %xh\\n\", fru.access);\n\t}\n\n\tpFruBuf = malloc(fru.size);\n\tif (pFruBuf) {\n\t\tprintf(\"Fru Size         : %d bytes\\n\",fru.size);\n\t\tread_fru_area(intf, &fru, fruId, 0, fru.size, pFruBuf);\n\t} else {\n\t\tlprintf(LOG_ERR, \"Cannot allocate %d bytes\\n\", fru.size);\n\t\treturn;\n\t}\n\n\tif(pFruBuf)\n\t{\n\t\tFILE * pFile;\n\t\tpFile = fopen(pFileName,\"wb\");\n\t\tif (pFile) {\n\t\t\tfwrite(pFruBuf, fru.size, 1, pFile);\n\t\t\tprintf(\"Done\\n\");\n\t\t} else {\n\t\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t\tfree_n(&pFruBuf);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pFile);\n\t}\n\tfree_n(&pFruBuf);\n}\n\nstatic void\nipmi_fru_write_from_bin(struct ipmi_intf * intf,\n\t\t\tchar * pFileName,\n\t\t\tuint8_t fruId)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tuint8_t msg_data[4];\n\tuint8_t *pFruBuf;\n\tuint16_t len = 0;\n\tFILE *pFile;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof (req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t\treturn;\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf(\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (verbose) {\n\t\tprintf(\"Fru Size   = %d bytes\\n\", fru.size);\n\t\tprintf(\"Fru Access = %xh\\n\", fru.access);\n\t}\n\n\tpFruBuf = malloc(fru.size);\n\tif (!pFruBuf) {\n\t\tlprintf(LOG_ERR, \"Cannot allocate %d bytes\\n\", fru.size);\n\t\treturn;\n\t}\n\n\t\tpFile = fopen(pFileName, \"rb\");\n\t\tif (pFile) {\n\t\t\tlen = fread(pFruBuf, 1, fru.size, pFile);\n\t\t\tprintf(\"Fru Size         : %d bytes\\n\", fru.size);\n\t\t\tprintf(\"Size to Write    : %d bytes\\n\", len);\n\t\t\tfclose(pFile);\n\t\t} else {\n\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t}\n\n\t\tif (len != 0) {\n\t\t\twrite_fru_area(intf, &fru, fruId,0, 0, len, pFruBuf);\n\t\t\tlprintf(LOG_INFO,\"Done\");\n\t\t}\n\n\tfree_n(&pFruBuf);\n}\n\n/* ipmi_fru_write_help() - print help text for 'write'\n *\n * returns void\n */\nvoid\nipmi_fru_write_help()\n{\n\tlprintf(LOG_NOTICE, \"fru write <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru write 0 /root/fru.bin\");\n} /* ipmi_fru_write_help() */\n\n/* ipmi_fru_edit_help - print help text for 'fru edit' command\n *\n * returns void\n */\nvoid\nipmi_fru_edit_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru edit <fruid> field <section> <index> <string> - edit FRU string\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru edit <fruid> oem iana <record> <format> <args> - limited OEM support\");\n} /* ipmi_fru_edit_help() */\n\n/* ipmi_fru_edit_multirec  -  Query new values to replace original FRU content\n*\n* @intf:   interface to use\n* @id:  FRU id to work on\n*\n* returns: nothing\n*/\n/* Work in progress, copy paste most of the stuff for other functions in this\n\tfile ... not elegant yet */\nstatic int\nipmi_fru_edit_multirec(struct ipmi_intf * intf, uint8_t id ,\n\t\t\t\t\t\t\t\t\t\t\t\tint argc, char ** argv)\n{\n\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tuint16_t retStatus = 0;\n\tuint32_t offFruMultiRec;\n\tuint32_t fruMultiRecSize = 0;\n\tstruct fru_info fruInfo;\n\tretStatus = ipmi_fru_get_multirec_location_from_fru(intf, id, &fruInfo,\n\t\t\t\t\t\t\t\t&offFruMultiRec,\n\t\t\t\t\t\t\t\t&fruMultiRecSize);\n\tif (retStatus != 0) {\n\t\treturn retStatus;\n\t}\n\n\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\n\t{\n\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\t}\n\n\t{\n\t\tuint8_t * fru_data;\n\t\tuint32_t i;\n\t\tuint32_t offset= offFruMultiRec;\n\t\tstruct fru_multirec_header * h;\n\t\tuint32_t last_off, len;\n\t\tuint8_t error=0;\n\n\t\ti = last_off = offset;\n\n\t\tmemset(&fru, 0, sizeof(fru));\n\t\tfru_data = malloc(fru.size + 1);\n\t\tif (!fru_data) {\n\t\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(fru_data, 0, fru.size + 1);\n\n\t\tdo {\n\t\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t\t/* read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time */\n\t\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t\t{\n\t\t\t\tlen = fru.size - last_off;\n\t\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\t\tif (read_fru_area(intf, &fru, id, last_off, len, fru_data) < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tlast_off += len;\n\t\t\t}\n\t\t\tif( h->type ==  FRU_RECORD_TYPE_OEM_EXTENSION ){\n\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[i + sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\tuint32_t suppliedIana = 0 ;\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\n\t\t\t\t/* Default to PICMG for backward compatibility */\n\t\t\t\tif( argc <=2 ) {\n\t\t\t\t\tsuppliedIana =  IPMI_OEM_PICMG;\n\t\t\t\t}  else {\n\t\t\t\t\tif( !strncmp( argv[2] , \"oem\" , 3 )) {\n\t\t\t\t\t\t/* Expect IANA number next */\n\t\t\t\t\t\tif( argc <= 3 ) {\n\t\t\t\t\t\t\tlprintf(LOG_ERR, \"oem iana <record> <format> [<args>]\");\n\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (str2uint(argv[3], &suppliedIana) == 0) {\n\t\t\t\t\t\t\t\tlprintf(LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\t\"using iana: %d\",\n\t\t\t\t\t\t\t\t\t\tsuppliedIana);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\t\t\t\"Given IANA '%s' is invalid.\",\n\t\t\t\t\t\t\t\t\t\targv[3]);\n\t\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( suppliedIana == iana ) {\n\t\t\t\t\tlprintf(LOG_DEBUG, \"Matching record found\" );\n\n\t\t\t\t\tif( iana == IPMI_OEM_PICMG ){\n\t\t\t\t\t\tif( ipmi_fru_picmg_ext_edit(fru_data,\n\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\th->len, h, oh )){\n\t\t\t\t\t\t\t/* The fru changed */\n\t\t\t\t\t\t\twrite_fru_area(intf,&fru,id, i,i,\n\t\t\t\t\t\th->len+ sizeof(struct fru_multirec_header), fru_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if( iana == IPMI_OEM_KONTRON ) {\n\t\t\t\t\t\tif( ipmi_fru_oemkontron_edit( argc,argv,fru_data,\n\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\th->len, h, oh )){\n\t\t\t\t\t\t\t/* The fru changed */\n\t\t\t\t\t\t\twrite_fru_area(intf,&fru,id, i,i,\n\t\t\t\t\t\th->len+ sizeof(struct fru_multirec_header), fru_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"  OEM IANA (%s) Record not support in this mode\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tval2str( iana,  ipmi_oem_info));\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t\t} while (!(h->format & 0x80) && (error != 1));\n\n\t\tfree_n(&fru_data);\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_get_help - print help text for 'fru get'\n *\n * returns void\n */\nvoid\nipmi_fru_get_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru get <fruid> oem iana <record> <format> <args> - limited OEM support\");\n} /* ipmi_fru_get_help() */\n\nvoid\nipmi_fru_internaluse_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> info             - get internal use area size\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> print            - print internal use area in hex\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> read  <fru file> - read internal use area to file\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> write <fru file> - write internal use area from file\");\n} /* void ipmi_fru_internaluse_help() */\n\n/* ipmi_fru_get_multirec   -  Query new values to replace original FRU content\n*\n* @intf:   interface to use\n* @id:  FRU id to work on\n*\n* returns: nothing\n*/\n/* Work in progress, copy paste most of the stuff for other functions in this\n\tfile ... not elegant yet */\nstatic int\nipmi_fru_get_multirec(struct ipmi_intf * intf, uint8_t id ,\n\t\t\t\t\t\t\t\t\t\t\t\tint argc, char ** argv)\n{\n\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tuint16_t retStatus = 0;\n\tuint32_t offFruMultiRec;\n\tuint32_t fruMultiRecSize = 0;\n\tstruct fru_info fruInfo;\n\tretStatus = ipmi_fru_get_multirec_location_from_fru(intf, id, &fruInfo,\n\t\t\t\t\t\t\t\t&offFruMultiRec,\n\t\t\t\t\t\t\t\t&fruMultiRecSize);\n\tif (retStatus != 0) {\n\t\treturn retStatus;\n\t}\n\n\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\n\t{\n\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\t}\n\n\t{\n\t\tuint8_t * fru_data;\n\t\tuint32_t i;\n\t\tuint32_t offset= offFruMultiRec;\n\t\tstruct fru_multirec_header * h;\n\t\tuint32_t last_off, len;\n\t\tuint8_t error=0;\n\n\t\ti = last_off = offset;\n\n\t\tfru_data = malloc(fru.size + 1);\n\t\tif (!fru_data) {\n\t\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(fru_data, 0, fru.size + 1);\n\n\t\tdo {\n\t\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t\t/* read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time */\n\t\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t\t{\n\t\t\t\tlen = fru.size - last_off;\n\t\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\t\tif (read_fru_area(intf, &fru, id, last_off, len, fru_data) < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tlast_off += len;\n\t\t\t}\n\t\t\tif( h->type ==  FRU_RECORD_TYPE_OEM_EXTENSION ){\n\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[i + sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\tuint32_t suppliedIana = 0 ;\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\t\t\t\tif( !strncmp( argv[2] , \"oem\" , 3 )) {\n\t\t\t\t\t/* Expect IANA number next */\n\t\t\t\t\tif( argc <= 3 ) {\n\t\t\t\t\t\tlprintf(LOG_ERR, \"oem iana <record> <format>\");\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (str2uint(argv[3], &suppliedIana) == 0) {\n\t\t\t\t\t\t\tlprintf(LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\"using iana: %d\",\n\t\t\t\t\t\t\t\t\tsuppliedIana);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\t\t\"Given IANA '%s' is invalid.\",\n\t\t\t\t\t\t\t\t\targv[3]);\n\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( suppliedIana == iana ) {\n\t\t\t\t\tlprintf(LOG_DEBUG, \"Matching record found\" );\n\n\t\t\t\t\tif( iana == IPMI_OEM_KONTRON ) {\n\t\t\t\t\t\tipmi_fru_oemkontron_get(argc, argv, fru_data,\n\t\t\t\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\t\t\t\toh);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"  OEM IANA (%s) Record not supported in this mode\\n\",\n\t\t\t\t\t\t       val2str( iana,  ipmi_oem_info));\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t\t} while (!(h->format & 0x80) && (error != 1));\n\n\t\tfree_n(&fru_data);\n\t}\n\treturn 0;\n}\n\n#define ERR_EXIT do { rc = -1; goto exit; } while(0)\n\nstatic\nint\nipmi_fru_upg_ekeying(struct ipmi_intf *intf, char *pFileName, uint8_t fruId)\n{\n\tstruct fru_info fruInfo = {0};\n\tuint8_t *buf = NULL;\n\tuint32_t offFruMultiRec = 0;\n\tuint32_t fruMultiRecSize = 0;\n\tuint32_t offFileMultiRec = 0;\n\tuint32_t fileMultiRecSize = 0;\n\tint rc = 0;\n\n\tif (!pFileName) {\n\t\tlprintf(LOG_ERR, \"File expected, but none given.\");\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_multirec_location_from_fru(intf, fruId, &fruInfo,\n\t\t\t\t\t\t\t&offFruMultiRec, &fruMultiRecSize) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec location from FRU.\");\n\t\tERR_EXIT;\n\t}\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\tif (ipmi_fru_get_multirec_size_from_file(pFileName, &fileMultiRecSize,\n\t\t\t\t&offFileMultiRec) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec size from file '%s'.\", pFileName);\n\t\tERR_EXIT;\n\t}\n\tbuf = malloc(fileMultiRecSize);\n\tif (!buf) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_multirec_from_file(pFileName, buf, fileMultiRecSize,\n\t\t\t\toffFileMultiRec) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec from file '%s'.\", pFileName);\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_adjust_size_from_buffer(buf, &fileMultiRecSize) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to adjust size from buffer.\");\n\t\tERR_EXIT;\n\t}\n\tif (write_fru_area(intf, &fruInfo, fruId, 0, offFruMultiRec,\n\t\t\t\tfileMultiRecSize, buf) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to write FRU area.\");\n\t\tERR_EXIT;\n\t}\n\n\tlprintf(LOG_INFO, \"Done upgrading Ekey.\");\n\nexit:\n\tfree_n(&buf);\n\n\treturn rc;\n}\n\n/* ipmi_fru_upgekey_help - print help text for 'upgEkey'\n *\n * returns void\n */\nvoid\nipmi_fru_upgekey_help()\n{\n\tlprintf(LOG_NOTICE, \"fru upgEkey <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru upgEkey 0 /root/fru.bin\");\n} /* ipmi_fru_upgekey_help() */\n\nstatic int\nipmi_fru_get_multirec_size_from_file(char * pFileName,\n\t\t\t\t\tuint32_t * pSize,\n\t\t\t\t\tuint32_t * pOffset)\n{\n\tstruct fru_header header;\n\tFILE * pFile;\n\tuint8_t len = 0;\n\tuint32_t end = 0;\n\t*pSize = 0;\n\n\tpFile = fopen(pFileName,\"rb\");\n\tif (pFile) {\n\t\trewind(pFile);\n\t\tlen = fread(&header, 1, 8, pFile);\n\t\tfseek(pFile, 0, SEEK_END);\n\t\tend = ftell(pFile);\n\t\tfclose(pFile);\n\t}\n\n\tlprintf(LOG_DEBUG, \"File Size = %lu\\n\", end);\n\tlprintf(LOG_DEBUG, \"Len = %u\\n\", len);\n\n\tif (len != 8) {\n\t\tprintf(\"Error with file %s in getting size\\n\", pFileName);\n\t\treturn -1;\n\t}\n\n\tif (header.version != 0x01) {\n\t\tprintf (\"Unknown FRU header version %02x.\\n\", header.version);\n\t\treturn -1;\n\t}\n\n\t/* Retrieve length */\n\tif (((header.offset.internal * 8) > (header.offset.internal * 8)) &&\n\t\t((header.offset.internal * 8) < end))\n\t\tend = (header.offset.internal * 8);\n\n\tif (((header.offset.chassis * 8) > (header.offset.chassis * 8)) &&\n\t\t((header.offset.chassis * 8) < end))\n\t\tend = (header.offset.chassis * 8);\n\n\tif (((header.offset.board * 8) > (header.offset.board * 8)) &&\n\t\t((header.offset.board * 8) < end))\n\t\tend = (header.offset.board * 8);\n\n\tif (((header.offset.product * 8) > (header.offset.product * 8)) &&\n\t\t((header.offset.product * 8) < end))\n\t\tend = (header.offset.product * 8);\n\n\t*pSize = end - (header.offset.multi * 8);\n\t*pOffset = (header.offset.multi * 8);\n\n\treturn 0;\n}\n\nint\nipmi_fru_get_adjust_size_from_buffer(uint8_t * fru_data, uint32_t *pSize)\n{\n\tstruct fru_multirec_header * head;\n\tint status = 0;\n\tuint8_t checksum = 0;\n\tuint8_t counter = 0;\n\tuint16_t count = 0;\n\tdo {\n\t\tchecksum = 0;\n\t\thead = (struct fru_multirec_header *) (fru_data + count);\n\t\tif (verbose) {\n\t\t\tprintf(\"Adding (\");\n\t\t}\n\t\tfor (counter = 0; counter < sizeof(struct fru_multirec_header); counter++) {\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\" %02X\", *(fru_data + count + counter));\n\t\t\t}\n\t\t\tchecksum += *(fru_data + count + counter);\n\t\t}\n\t\tif (verbose) {\n\t\t\tprintf(\")\");\n\t\t}\n\t\tif (checksum != 0) {\n\t\t\tlprintf(LOG_ERR, \"Bad checksum in Multi Records\");\n\t\t\tstatus = -1;\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"--> FAIL\");\n\t\t\t}\n\t\t} else if (verbose) {\n\t\t\tprintf(\"--> OK\");\n\t\t}\n\t\tif (verbose > 1 && checksum == 0) {\n\t\t\tfor (counter = 0; counter < head->len; counter++) {\n\t\t\t\tprintf(\" %02X\", *(fru_data + count + counter\n\t\t\t\t\t\t\t+ sizeof(struct fru_multirec_header)));\n\t\t\t}\n\t\t}\n\t\tif (verbose) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcount += head->len + sizeof (struct fru_multirec_header);\n\t} while ((!(head->format & 0x80)) && (status == 0));\n\n\t*pSize = count;\n\tlprintf(LOG_DEBUG, \"Size of multirec: %lu\\n\", *pSize);\n\treturn status;\n}\n\nstatic int\nipmi_fru_get_multirec_from_file(char * pFileName, uint8_t * pBufArea,\n\t\tuint32_t size, uint32_t offset)\n{\n\tFILE * pFile;\n\tuint32_t len = 0;\n\tif (!pFileName) {\n\t\tlprintf(LOG_ERR, \"Invalid file name given.\");\n\t\treturn -1;\n\t}\n\t\n\terrno = 0;\n\tpFile = fopen(pFileName, \"rb\");\n\tif (!pFile) {\n\t\tlprintf(LOG_ERR, \"Error opening file '%s': %i -> %s.\", pFileName, errno,\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\terrno = 0;\n\tif (fseek(pFile, offset, SEEK_SET) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to seek in file '%s': %i -> %s.\", pFileName, errno,\n\t\t\t\tstrerror(errno));\n\t\tfclose(pFile);\n\t\treturn -1;\n\t}\n\tlen = fread(pBufArea, size, 1, pFile);\n\tfclose(pFile);\n\n\tif (len != 1) {\n\t\tlprintf(LOG_ERR, \"Error in file '%s'.\", pFileName);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nipmi_fru_get_multirec_location_from_fru(struct ipmi_intf * intf,\n\t\t\t\t\tuint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_info *pFruInfo,\n\t\t\t\t\tuint32_t * pRetLocation,\n\t\t\t\t\tuint32_t * pRetSize)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\tuint32_t end;\n\tstruct fru_header header;\n\n\t*pRetLocation = 0;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tif (verbose > 1)\n\t\t\tprintf(\"no response\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\telse\n\t\t\tprintf (\"   CCODE = 0x%02x\\n\", rsp->ccode);\n\t\treturn -1;\n\t}\n\tpFruInfo->size = (rsp->data[1] << 8) | rsp->data[0];\n\tpFruInfo->access = rsp->data[2] & 0x1;\n\n\tif (verbose > 1)\n\t\tprintf(\"pFruInfo->size = %d bytes (accessed by %s)\\n\",\n\t\t\t\tpFruInfo->size, pFruInfo->access ? \"words\" : \"bytes\");\n\n\tif (!pFruInfo->size)\n\t\treturn -1;\n\n\tmsg_data[0] = fruId;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\n\tif (!rsp)\n\t\treturn -1;\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout while reading FRU data. (Device not present?)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 0x01) {\n\t\tprintf (\"  Unknown FRU header version %02x.\\n\", header.version);\n\t\treturn -1;\n\t}\n\n\tend = pFruInfo->size;\n\n\t/* Retrieve length */\n\tif (((header.offset.internal * 8) > (header.offset.internal * 8)) &&\n\t\t((header.offset.internal * 8) < end))\n\t\tend = (header.offset.internal * 8);\n\n\tif (((header.offset.chassis * 8) > (header.offset.chassis * 8)) &&\n\t\t((header.offset.chassis * 8) < end))\n\t\tend = (header.offset.chassis * 8);\n\n\tif (((header.offset.board * 8) > (header.offset.board * 8)) &&\n\t\t((header.offset.board * 8) < end))\n\t\tend = (header.offset.board * 8);\n\n\tif (((header.offset.product * 8) > (header.offset.product * 8)) &&\n\t\t((header.offset.product * 8) < end))\n\t\tend = (header.offset.product * 8);\n\n\t*pRetSize = end;\n\t*pRetLocation = 8 * header.offset.multi;\n\n\treturn 0;\n}\n\n/* ipmi_fru_get_internal_use_offset -  Retrieve internal use offset\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_get_internal_use_info(  struct ipmi_intf * intf,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t id,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info * fru,\n\t\t\t\t\t\t\t\t\t\t\tuint16_t * size,\n\t\t\t\t\t\t\t\t\t\t\tuint16_t * offset)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\t// Init output value\n\t* offset = 0;\n\t* size = 0;\n\n\tmemset(fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tfru->size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru->access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru->size, fru->access ? \"words\" : \"bytes\");\n\n\tif (fru->size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru->size);\n\t\treturn -1;\n\t}\n\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn 1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\treturn -1;\n\t}\n\n\tlprintf(LOG_DEBUG, \"fru.header.version:         0x%x\",\n\t\theader.version);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.internal: 0x%x\",\n\t\theader.offset.internal * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.chassis:  0x%x\",\n\t\theader.offset.chassis * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.board:    0x%x\",\n\t\theader.offset.board * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.product:  0x%x\",\n\t\theader.offset.product * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.multi:    0x%x\",\n\t\theader.offset.multi * 8);\n\n\tif((header.offset.internal*8) == 0)\n\t{\n\t\t* size = 0;\n\t\t* offset = 0;\n\t}\n\telse\n\t{\n\t\t(* offset) = (header.offset.internal*8);\n\n\t\tif(header.offset.chassis != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.chassis*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.board != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.board*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.product != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.product*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.multi != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.multi*8)-(* offset));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(* size) = (fru->size - (* offset));\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_info_internal_use -  print internal use info\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_info_internal_use(struct ipmi_intf * intf, uint8_t id)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(          \"Internal Use Area Size  : %i\\n\", size);\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_help - print help text for FRU subcommand\n *\n * returns void\n */\nvoid\nipmi_fru_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"FRU Commands:  print read write upgEkey edit internaluse get\");\n} /* ipmi_fru_help() */\n\n/* ipmi_fru_read_internal_use -  print internal use are in hex or file\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_read_internal_use(struct ipmi_intf * intf, uint8_t id, char * pFileName)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tuint8_t * frubuf;\n\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(          \"Internal Use Area Size  : %i\\n\", size);\n\n\t\tfrubuf = malloc( size );\n\t\tif(frubuf)\n\t\t{\n\t\t\trc = read_fru_area_section(intf, &fru, id, offset, size, frubuf);\n\n\t\t\tif(rc == 0)\n\t\t\t{\n\t\t\t\tif(!pFileName)\n\t\t\t\t{\n\t\t\t\t\tuint16_t counter;\n\t\t\t\t\tfor(counter = 0; counter < size; counter ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((counter % 16) == 0)\n\t\t\t\t\t\t\tprintf(\"\\n%02i- \", (counter / 16));\n\t\t\t\t\t\tprintf(\"%02X \", frubuf[counter]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFILE * pFile;\n\t\t\t\t\tpFile = fopen(pFileName,\"wb\");\n\t\t\t\t\tif (pFile)\n\t\t\t\t\t{\n\t\t\t\t\t\tfwrite(frubuf, size, 1, pFile);\n\t\t\t\t\t\tprintf(\"Done\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t\t\t\t\tfree_n(&frubuf);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tfclose(pFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tfree_n(&frubuf);\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_write_internal_use   -  print internal use are in hex or file\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_write_internal_use(struct ipmi_intf * intf, uint8_t id, char * pFileName)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tuint8_t * frubuf;\n\t\tFILE * fp;\n\t\tuint32_t fileLength = 0;\n\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(            \"Internal Use Area Size  : %i\\n\", size);\n\n\t\tfp = fopen(pFileName, \"r\");\n\n\t\tif(fp)\n\t\t{\n\t\t\t/* Retrieve file length, check if it's fits the Eeprom Size */\n\t\t\tfseek(fp, 0 ,SEEK_END);\n\t\t\tfileLength = ftell(fp);\n\n\t\t\tlprintf(LOG_ERR, \"File Size: %i\", fileLength);\n\t\t\tlprintf(LOG_ERR, \"Area Size: %i\", size);\n\t\t\tif(fileLength != size)\n\t\t\t{\n\t\t\t\tlprintf(LOG_ERR, \"File size does not fit Eeprom Size\");\n\t\t\t\tfclose(fp);\n\t\t\t\tfp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfseek(fp, 0 ,SEEK_SET);\n\t\t\t}\n\t\t}\n\n\t\tif(fp)\n\t\t{\n\t\t\tfrubuf = malloc( size );\n\t\t\tif(frubuf)\n\t\t\t{\n\t\t\t\tuint16_t fru_read_size;\n\t\t\t\tfru_read_size = fread(frubuf, 1, size, fp);\n\n\t\t\t\tif(fru_read_size == size)\n\t\t\t\t{\n\t\t\t\t\trc = write_fru_area(intf, &fru, id, 0, offset, size, frubuf);\n\n\t\t\t\t\tif(rc == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlprintf(LOG_INFO, \"Done\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlprintf(LOG_ERR, \"Unable to read file: %i\\n\", fru_read_size);\n\t\t\t\t}\n\n\t\t\t\tfree_n(&frubuf);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tfp = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t}\n\treturn 0;\n}\n\nint\nipmi_fru_main(struct ipmi_intf * intf, int argc, char ** argv)\n{\n\tint rc = 0;\n\tuint8_t fru_id = 0;\n\n\tif (argc < 1) {\n\t\trc = ipmi_fru_print_all(intf);\n\t}\n\telse if (strncmp(argv[0], \"help\", 4) == 0) {\n\t\tipmi_fru_help();\n\t\treturn 0;\n\t}\n\telse if (strncmp(argv[0], \"print\", 5) == 0 ||\n\t\tstrncmp(argv[0], \"list\", 4) == 0) {\n\t\tif (argc > 1) {\n\t\t\tif (strcmp(argv[1], \"help\") == 0) {\n\t\t\t\tlprintf(LOG_NOTICE, \"fru print [fru id] - print information about FRU(s)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = __ipmi_fru_print(intf, fru_id);\n\t\t} else {\n\t\t\trc = ipmi_fru_print_all(intf);\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"read\", 5)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_read_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_read_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\tif (verbose) {\n\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\tprintf(\"FRU File         : %s\\n\", argv[2]);\n\t\t}\n\t\t/* TODO - rc is missing */\n\t\tipmi_fru_read_to_bin(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"write\", 5)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_write_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_write_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\tif (verbose) {\n\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\tprintf(\"FRU File         : %s\\n\", argv[2]);\n\t\t}\n\t\t/* TODO - rc is missing */\n\t\tipmi_fru_write_from_bin(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"upgEkey\", 7)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_upgekey_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_upgekey_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\trc = ipmi_fru_upg_ekeying(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"internaluse\", 11)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_internaluse_help();\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( (argc >= 3) && (!strncmp(argv[2], \"info\", 4)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = ipmi_fru_info_internal_use(intf, fru_id);\n\t\t}\n\t\telse if ( (argc >= 3) && (!strncmp(argv[2], \"print\", 5)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = ipmi_fru_read_internal_use(intf, fru_id, NULL);\n\t\t}\n\t\telse if ( (argc >= 4) && (!strncmp(argv[2], \"read\", 4)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* There is a file name in the parameters */\n\t\t\tif (is_valid_filename(argv[3]) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tlprintf(LOG_DEBUG, \"FRU ID           : %d\", fru_id);\n\t\t\tlprintf(LOG_DEBUG, \"FRU File         : %s\", argv[3]);\n\n\t\t\trc = ipmi_fru_read_internal_use(intf, fru_id, argv[3]);\n\t\t}\n\t\telse if ( (argc >= 4) && (!strncmp(argv[2], \"write\", 5)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* There is a file name in the parameters */\n\t\t\tif (is_valid_filename(argv[3]) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tlprintf(LOG_DEBUG, \"FRU ID           : %d\", fru_id);\n\t\t\tlprintf(LOG_DEBUG, \"FRU File         : %s\", argv[3]);\n\n\t\t\trc = ipmi_fru_write_internal_use(intf, fru_id, argv[3]);\n\t\t} else {\n\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\"Either unknown command or not enough parameters given.\");\n\t\t\tipmi_fru_internaluse_help();\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"edit\", 4)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_edit_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 2) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_edit_help();\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (argc >= 2) {\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Using default FRU ID: %d\\n\", fru_id);\n\t\t}\n\n\t\tif (argc >= 3) {\n\t\t\tif (!strncmp(argv[2], \"field\", 5)) {\n\t\t\t\tif (argc != 6) {\n\t\t\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\t\t\tipmi_fru_edit_help();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\trc = ipmi_fru_set_field_string(intf, fru_id, *argv[3], *argv[4],\n\t\t\t\t\t\t(char *) argv[5]);\n\t\t\t} else if (!strncmp(argv[2], \"oem\", 3)) {\n\t\t\t\trc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_ERR, \"Invalid command: %s\", argv[2]);\n\t\t\t\tipmi_fru_edit_help();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\trc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"get\", 4)) {\n\t\tif (argc > 1 && (strncmp(argv[1], \"help\", 4) == 0)) {\n\t\t\tipmi_fru_get_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 2) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_get_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (argc >= 2) {\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Using default FRU ID: %d\\n\", fru_id);\n\t\t}\n\n\t\tif (argc >= 3) {\n\t\t\tif (!strncmp(argv[2], \"oem\", 3)) {\n\t\t\t\trc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_ERR, \"Invalid command: %s\", argv[2]);\n\t\t\t\tipmi_fru_get_help();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\trc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);\n\t\t}\n\t}\n\telse {\n\t\tlprintf(LOG_ERR, \"Invalid FRU command: %s\", argv[0]);\n\t\tipmi_fru_help();\n\t\treturn -1;\n\t}\n\n\treturn rc;\n}\n\n/* ipmi_fru_set_field_string -  Set a field string to a new value, Need to be the same size.  If\n*                              size if not equal, the function ipmi_fru_set_field_string_rebuild\n*                              will be called.\n*\n* @intf:       ipmi interface\n* @id:         fru id\n* @f_type:    Type of the Field : c=Chassis b=Board p=Product\n* @f_index:   findex of the field, zero indexed.\n* @f_string:  NULL terminated string\n*\n* returns -1 on error\n* returns 1 if successful\n*/\nstatic int\nipmi_fru_set_field_string(struct ipmi_intf * intf, uint8_t fruId, uint8_t\nf_type, uint8_t f_index, char *f_string)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\tuint8_t checksum;\n\tint i = 0;\n\tint rc = 1;\n\tuint8_t *fru_data = NULL;\n\tuint8_t *fru_area = NULL;\n\tuint32_t fru_field_offset, fru_field_offset_tmp;\n\tuint32_t fru_section_len, header_offset;\n\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (fru.size < 1) {\n\t\tprintf(\" Invalid FRU size %d\", fru.size);\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = fruId;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t{\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tif (rsp->ccode)\n\t{\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tprintf(\" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tfru_data = malloc( fru.size );\n\tif (!fru_data) {\n\t\tprintf(\"Out of memory!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\t/* Setup offset from the field type */\n\n\t/* Chassis type field */\n\tif (f_type == 'c' ) {\n\t\theader_offset = (header.offset.chassis * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 3;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\t/* Board type field */\n\telse if (f_type == 'b' ) {\n\t\theader_offset = (header.offset.board * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 6;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\t/* Product type field */\n\telse if (f_type == 'p' ) {\n\t\theader_offset = (header.offset.product * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 3;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\telse\n\t{\n\t\tprintf(\"Wrong field type.\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tmemset(fru_data, 0, fru.size);\n\tif( read_fru_area(intf ,&fru, fruId, header_offset ,\n\t\t\t\t\tfru_section_len , fru_data) < 0 )\n\t{\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\t/* Convert index from character to decimal */\n\tf_index= f_index - 0x30;\n\n\t/*Seek to field index */\n\tfor (i=0; i <= f_index; i++) {\n\t\tfru_field_offset_tmp = fru_field_offset;\n\t\tif (fru_area) {\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tfru_area = (uint8_t *) get_fru_area_str(fru_data, &fru_field_offset);\n\t}\n\n\tif (!FRU_FIELD_VALID(fru_area)) {\n\t\tprintf(\"Field not found !\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tif ( strlen((const char *)fru_area) == strlen((const char *)f_string) )\n\t{\n\t\tprintf(\"Updating Field '%s' with '%s' ...\\n\", fru_area, f_string );\n\t\tmemcpy(fru_data + fru_field_offset_tmp + 1,\n\t\t\t\t\t\t\t\tf_string, strlen(f_string));\n\n\t\tchecksum = 0;\n\t\t/* Calculate Header Checksum */\n\t\tfor (i = 0; i < fru_section_len - 1; i++)\n\t\t{\n\t\t\tchecksum += fru_data[i];\n\t\t}\n\t\tchecksum = (~checksum) + 1;\n\t\tfru_data[fru_section_len - 1] = checksum;\n\n\t\t/* Write the updated section to the FRU data; source offset => 0 */\n\t\tif( write_fru_area(intf, &fru, fruId, 0,\n\t\t\t\theader_offset, fru_section_len, fru_data) < 0 )\n\t\t{\n\t\t\tprintf(\"Write to FRU data failed.\\n\");\n\t\t\trc = -1;\n\t\t\tgoto ipmi_fru_set_field_string_out;\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"String size are not equal, resizing fru to fit new string\\n\");\n\t\tif(\n\t\t\t\tipmi_fru_set_field_string_rebuild(intf,fruId,fru,header,f_type,f_index,f_string)\n\t\t)\n\t\t{\n\t\t\trc = -1;\n\t\t\tgoto ipmi_fru_set_field_string_out;\n\t\t}\n\t}\n\nipmi_fru_set_field_string_out:\n\tfree_n(&fru_data);\n\tfree_n(&fru_area);\n\n\treturn rc;\n}\n\n/*\n\tThis function can update a string within of the following section when the size is not equal:\n\n\tChassis\n\tProduct\n\tBoard\n*/\n/* ipmi_fru_set_field_string_rebuild -  Set a field string to a new value, When size are not\n*                                      the same size.\n*\n*  This function can update a string within of the following section when the size is not equal:\n*\n*      - Chassis\n*      - Product\n*      - Board\n*\n* @intf:     ipmi interface\n* @fruId:    fru id\n* @fru:      info about fru\n* @header:   contain the header of the FRU\n* @f_type:   Type of the Field : c=Chassis b=Board p=Product\n* @f_index:  findex of the field, zero indexed.\n* @f_string: NULL terminated string\n*\n* returns -1 on error\n* returns 1 if successful\n*/\n\n#define DBG_RESIZE_FRU\nstatic int\nipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info fru, struct fru_header header,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t f_type, uint8_t f_index, char *f_string)\n{\n\tint i = 0;\n\tuint8_t *fru_data_old = NULL;\n\tuint8_t *fru_data_new = NULL;\n\tuint8_t *fru_area = NULL;\n\tuint32_t fru_field_offset, fru_field_offset_tmp;\n\tuint32_t fru_section_len, header_offset;\n\tuint32_t chassis_offset, board_offset, product_offset;\n\tuint32_t chassis_len, board_len, product_len, product_len_new;\n\tint      num_byte_change = 0, padding_len = 0;\n\tuint32_t counter;\n\tunsigned char cksum;\n\tint rc = 1;\n\n\tfru_data_old = calloc( fru.size, sizeof(uint8_t) );\n\n\tfru_data_new = malloc( fru.size );\n\n\tif (!fru_data_old || !fru_data_new) {\n\t\tprintf(\"Out of memory!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t1) Read ALL FRU */\n\tprintf(\"Read All FRU area\\n\");\n\tprintf(\"Fru Size       : %u bytes\\n\", fru.size);\n\n\t/* Read current fru data */\n\tread_fru_area(intf ,&fru, fruId, 0, fru.size , fru_data_old);\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Copy to new FRU\\n\");\n\t#endif\n\n\t/*************************\n\t2) Copy all FRU to new FRU */\n\tmemcpy(fru_data_new, fru_data_old, fru.size);\n\n\t/* Build location of all modifiable components */\n\tchassis_offset = (header.offset.chassis * 8);\n\tboard_offset   = (header.offset.board   * 8);\n\tproduct_offset = (header.offset.product * 8);\n\n\t/* Retrieve length of all modifiable components */\n\tchassis_len    =  *(fru_data_old + chassis_offset + 1) * 8;\n\tboard_len      =  *(fru_data_old + board_offset   + 1) * 8;\n\tproduct_len    =  *(fru_data_old + product_offset + 1) * 8;\n\tproduct_len_new = product_len;\n\n\t/* Chassis type field */\n\tif (f_type == 'c' )\n\t{\n\t\theader_offset    = chassis_offset;\n\t\tfru_field_offset = chassis_offset + 3;\n\t\tfru_section_len  = chassis_len;\n\t}\n\t/* Board type field */\n\telse if (f_type == 'b' )\n\t{\n\t\theader_offset    = board_offset;\n\t\tfru_field_offset = board_offset + 6;\n\t\tfru_section_len  = board_len;\n\t}\n\t/* Product type field */\n\telse if (f_type == 'p' )\n\t{\n\t\theader_offset    = product_offset;\n\t\tfru_field_offset = product_offset + 3;\n\t\tfru_section_len  = product_len;\n\t}\n\telse\n\t{\n\t\tprintf(\"Wrong field type.\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t3) Seek to field index */\n\tfor (i = 0;i <= f_index; i++) {\n\t\tfru_field_offset_tmp = fru_field_offset;\n\t\tfree_n(&fru_area);\n\t\tfru_area = (uint8_t *) get_fru_area_str(fru_data_old, &fru_field_offset);\n\t}\n\n\tif (!FRU_FIELD_VALID(fru_area)) {\n\t\tprintf(\"Field not found (1)!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Section Length: %u\\n\", fru_section_len);\n\t#endif\n\n\t/*************************\n\t4) Check number of padding bytes and bytes changed */\n\tfor(counter = 2; counter < fru_section_len; counter ++)\n\t{\n\t\tif(*(fru_data_old + (header_offset + fru_section_len - counter)) == 0)\n\t\t\tpadding_len ++;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnum_byte_change = strlen(f_string) - strlen(fru_area);\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Padding Length: %u\\n\", padding_len);\n\tprintf(\"NumByte Change: %i\\n\", num_byte_change);\n\tprintf(\"Start SecChnge: %x\\n\", *(fru_data_old + fru_field_offset_tmp));\n\tprintf(\"End SecChnge  : %x\\n\", *(fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1));\n\n\tprintf(\"Start Section : %x\\n\", *(fru_data_old + header_offset));\n\tprintf(\"End Sec wo Pad: %x\\n\", *(fru_data_old + header_offset + fru_section_len - 2 - padding_len));\n\tprintf(\"End Section   : %x\\n\", *(fru_data_old + header_offset + fru_section_len - 1));\n\t#endif\n\n\t/* Calculate New Padding Length */\n\tpadding_len -= num_byte_change;\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"New Padding Length: %i\\n\", padding_len);\n\t#endif\n\n\t/*************************\n\t5) Check if section must be resize.  This occur when padding length is not between 0 and 7 */\n\tif( (padding_len < 0) || (padding_len >= 8))\n\t{\n\t\tuint32_t remaining_offset = ((header.offset.product * 8) + product_len);\n\t\tint change_size_by_8;\n\n\t\tif(padding_len >= 8)\n\t\t{\n\t\t\t/* Section must be set smaller */\n\t\t\tchange_size_by_8 = ((padding_len) / 8) * (-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Section must be set bigger */\n\t\t\tchange_size_by_8 = 1 + (((padding_len+1) / 8) * (-1));\n\t\t}\n\n\t\t/* Recalculate padding and section length base on the section changes */\n\t\tfru_section_len += (change_size_by_8 * 8);\n\t\tpadding_len     += (change_size_by_8 * 8);\n\n\t\t#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"change_size_by_8: %i\\n\", change_size_by_8);\n\t\tprintf(\"New Padding Length: %i\\n\", padding_len);\n\t\tprintf(\"change_size_by_8: %i\\n\", change_size_by_8);\n\t\tprintf(\"header.offset.board: %i\\n\", header.offset.board);\n\t\t#endif\n\n\t\t/* Must move sections */\n\t\t/* Section that can be modified are as follow\n\t\t\tChassis\n\t\t\tBoard\n\t\t\tproduct */\n\n\t\t/* Chassis type field */\n\t\tif (f_type == 'c' )\n\t\t{\n\t\t\tprintf(\"Moving Section Chassis, from %i to %i\\n\",\n\t\t\t\t\t\t((header.offset.board) * 8),\n\t\t\t\t\t\t((header.offset.board + change_size_by_8) * 8)\n\t\t\t\t\t);\n\t\t\tmemcpy(\n\t\t\t\t\t\t(fru_data_new + ((header.offset.board + change_size_by_8) * 8)),\n\t\t\t\t\t\t(fru_data_old + (header.offset.board) * 8),\n\t\t\t\t\t\tboard_len\n\t\t\t\t\t);\n\t\t\theader.offset.board   += change_size_by_8;\n\t\t}\n\t\t/* Board type field */\n\t\tif ((f_type == 'c' ) || (f_type == 'b' ))\n\t\t{\n\t\t\tprintf(\"Moving Section Product, from %i to %i\\n\",\n\t\t\t\t\t\t((header.offset.product) * 8),\n\t\t\t\t\t\t((header.offset.product + change_size_by_8) * 8)\n\t\t\t\t\t);\n\t\t\tmemcpy(\n\t\t\t\t\t\t(fru_data_new + ((header.offset.product + change_size_by_8) * 8)),\n\t\t\t\t\t\t(fru_data_old + (header.offset.product) * 8),\n\t\t\t\t\t\tproduct_len\n\t\t\t\t\t);\n\t\t\theader.offset.product += change_size_by_8;\n\t\t}\n\n\t\tif ((f_type == 'c' ) || (f_type == 'b' ) || (f_type == 'p' )) {\n\t\t\tprintf(\"Change multi offset from %d to %d\\n\", header.offset.multi, header.offset.multi + change_size_by_8);\n\t\t\theader.offset.multi += change_size_by_8;\n\t\t}\n\n\t\t/* Adjust length of the section */\n\t\tif (f_type == 'c')\n\t\t{\n\t\t\t*(fru_data_new + chassis_offset + 1) += change_size_by_8;\n\t\t}\n\t\telse if( f_type == 'b')\n\t\t{\n\t\t\t*(fru_data_new + board_offset + 1)   += change_size_by_8;\n\t\t}\n\t\telse if( f_type == 'p')\n\t\t{\n\t\t\t*(fru_data_new + product_offset + 1) += change_size_by_8;\n\t\t\tproduct_len_new = *(fru_data_new + product_offset + 1) * 8;\n\t\t}\n\n\t\t/* Rebuild Header checksum */\n\t\t{\n\t\t\tunsigned char * pfru_header = (unsigned char *) &header;\n\t\t\theader.checksum = 0;\n\t\t\tfor(counter = 0; counter < (sizeof(struct fru_header) -1); counter ++)\n\t\t\t{\n\t\t\t\theader.checksum += pfru_header[counter];\n\t\t\t}\n\t\t\theader.checksum = (0 - header.checksum);\n\t\t\tmemcpy(fru_data_new, pfru_header, sizeof(struct fru_header));\n\t\t}\n\n\t\t/* Move remaining sections in 1 copy */\n\t\tprintf(\"Moving Remaining Bytes (Multi-Rec , etc..), from %i to %i\\n\",\n\t\t\t\t\tremaining_offset,\n\t\t\t\t\t((header.offset.product) * 8) + product_len_new\n\t\t\t\t);\n\t\tif(((header.offset.product * 8) + product_len_new - remaining_offset) < 0)\n\t\t{\n\t\t\tmemcpy(\n\t\t\t\t\t\tfru_data_new + (header.offset.product * 8) + product_len_new,\n\t\t\t\t\t\tfru_data_old + remaining_offset,\n\t\t\t\t\t\tfru.size - remaining_offset\n\t\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(\n\t\t\t\t\t\tfru_data_new + (header.offset.product * 8) + product_len_new,\n\t\t\t\t\t\tfru_data_old + remaining_offset,\n\t\t\t\t\t\tfru.size - ((header.offset.product * 8) + product_len_new)\n\t\t\t\t\t);\n\t\t}\n\t}\n\n\t/* Update only if it's fits padding length as defined in the spec, otherwise, it's an internal\n\terror */\n\t/*************************\n\t6) Update Field and sections */\n\tif( (padding_len >=0) && (padding_len < 8))\n\t{\n\t\t/* Do not requires any change in other section */\n\n\t\t/* Change field length */\n\t\tprintf(\n\t\t\t\"Updating Field : '%s' with '%s' ... (Length from '%d' to '%d')\\n\",\n\t\t\tfru_area, f_string, \n\t\t\t(int)*(fru_data_old + fru_field_offset_tmp), \n\t\t\t(int)(0xc0 + strlen(f_string)));\n\t\t*(fru_data_new + fru_field_offset_tmp) = (0xc0 + strlen(f_string));\n\t\tmemcpy(fru_data_new + fru_field_offset_tmp + 1, f_string, strlen(f_string));\n\n\t\t/* Copy remaining bytes in section */\n#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"Copying remaining of sections: %d \\n\",\n\t\t (int)((fru_data_old + header_offset + fru_section_len - 1) -\n\t\t (fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1)));\n#endif\n\n\t\tmemcpy((fru_data_new + fru_field_offset_tmp + 1 + \n\t\t\tstrlen(f_string)),\n\t\t\t(fru_data_old + fru_field_offset_tmp + 1 + \n\t\t\tstrlen(fru_area)),\n\t\t((fru_data_old + header_offset + fru_section_len - 1) -\n\t\t(fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1)));\n\n\t\t/* Add Padding if required */\n\t\tfor(counter = 0; counter < padding_len; counter ++)\n\t\t{\n\t\t\t*(fru_data_new + header_offset + fru_section_len - 1 - \n\t\t\t  padding_len + counter) = 0;\n\t\t}\n\n\t\t/* Calculate New Checksum */\n\t\tcksum = 0;\n\t\tfor( counter = 0; counter <fru_section_len-1; counter ++ )\n\t\t{\n\t\t\tcksum += *(fru_data_new + header_offset + counter);\n\t\t}\n\t\t*(fru_data_new + header_offset + fru_section_len - 1) = (0 - cksum);\n\n\t\t#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"Calculate New Checksum: %x\\n\", (0 - cksum));\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tprintf( \"Internal error, padding length %i (must be from 0 to 7) \", padding_len );\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t7) Finally, write new FRU */\n\tprintf(\"Writing new FRU.\\n\");\n\tif( write_fru_area( intf, &fru, fruId, 0, 0, fru.size, fru_data_new ) < 0 )\n\t{\n\t\tprintf(\"Write to FRU data failed.\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\tprintf(\"Done.\\n\");\n\nipmi_fru_set_field_string_rebuild_out:\n\tfree_n(&fru_area);\n\tfree_n(&fru_data_new);\n\tfree_n(&fru_data_old);\n\n\treturn rc;\n}\n"], "fixing_code": ["/*\n* Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.\n*\n* Redistribution and use in source and binary forms, with or without\n* modification, are permitted provided that the following conditions\n* are met:\n*\n* Redistribution of source code must retain the above copyright\n* notice, this list of conditions and the following disclaimer.\n*\n* Redistribution in binary form must reproduce the above copyright\n* notice, this list of conditions and the following disclaimer in the\n* documentation and/or other materials provided with the distribution.\n*\n* Neither the name of Sun Microsystems, Inc. or the names of\n* contributors may be used to endorse or promote products derived\n* from this software without specific prior written permission.\n*\n* This software is provided \"AS IS,\" without a warranty of any kind.\n* ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,\n* INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A\n* PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.\n* SUN MICROSYSTEMS, INC. (\"SUN\") AND ITS LICENSORS SHALL NOT BE LIABLE\n* FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING\n* OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL\n* SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,\n* OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR\n* PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF\n* LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,\n* EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n*/\n\n#include <ipmitool/ipmi.h>\n#include <ipmitool/log.h>\n#include <ipmitool/helper.h>\n#include <ipmitool/ipmi_cc.h>\n#include <ipmitool/ipmi_intf.h>\n#include <ipmitool/ipmi_fru.h>\n#include <ipmitool/ipmi_mc.h>\n#include <ipmitool/ipmi_sdr.h>\n#include <ipmitool/ipmi_strings.h>  /* IANA id strings */\n#include <ipmitool/ipmi_time.h>\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n\n#if HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#define FRU_MULTIREC_CHUNK_SIZE     (255 + sizeof(struct fru_multirec_header))\n#define FRU_FIELD_VALID(a) (a && a[0])\n\nstatic const char *section_id[4] = {\n\t\"Internal Use Section\",\n\t\"Chassis Section\",\n\t\"Board Section\",\n\t\"Product Section\"\n};\n\nstatic const char * combined_voltage_desc[] = {\n\t\"12 V\",\n\t\"-12 V\",\n\t\"5 V\",\n\t\"3.3 V\"\n};\n\nstatic const char * chassis_type_desc[] = {\n\t\"Unspecified\",\n\t\"Other\",\n\t\"Unknown\",\n\t\"Desktop\",\n\t\"Low Profile Desktop\",\n\t\"Pizza Box\",\n\t\"Mini Tower\",\n\t\"Tower\",\n\t\"Portable\",\n\t\"LapTop\",\n\t\"Notebook\",\n\t\"Hand Held\",\n\t\"Docking Station\",\n\t\"All in One\",\n\t\"Sub Notebook\",\n\t\"Space-saving\",\n\t\"Lunch Box\",\n\t\"Main Server Chassis\",\n\t\"Expansion Chassis\",\n\t\"SubChassis\",\n\t\"Bus Expansion Chassis\",\n\t\"Peripheral Chassis\",\n\t\"RAID Chassis\",\n\t\"Rack Mount Chassis\",\n\t\"Sealed-case PC\",\n\t\"Multi-system Chassis\",\n\t\"CompactPCI\",\n\t\"AdvancedTCA\",\n\t\"Blade\",\n\t\"Blade Enclosure\"\n};\n\nstatic inline bool fru_cc_rq2big(int code) {\n\treturn (code == IPMI_CC_REQ_DATA_INV_LENGTH\n\t\t|| code == IPMI_CC_REQ_DATA_FIELD_EXCEED\n\t\t|| code == IPMI_CC_CANT_RET_NUM_REQ_BYTES);\n}\n\n/* From lib/dimm_spd.c: */\nint\nipmi_spd_print_fru(struct ipmi_intf * intf, uint8_t id);\n\nextern int verbose;\n\nstatic void ipmi_fru_read_to_bin(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic void ipmi_fru_write_from_bin(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic int ipmi_fru_upg_ekeying(struct ipmi_intf * intf, char * pFileName, uint8_t fruId);\nstatic int ipmi_fru_get_multirec_location_from_fru(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\tstruct fru_info *pFruInfo, uint32_t * pRetLocation,\n\t\t\t\t\t\t\tuint32_t * pRetSize);\nstatic int ipmi_fru_get_multirec_from_file(char * pFileName, uint8_t * pBufArea,\n\t\t\t\t\t\tuint32_t size, uint32_t offset);\nstatic int ipmi_fru_get_multirec_size_from_file(char * pFileName, uint32_t * pSize, uint32_t * pOffset);\nint ipmi_fru_get_adjust_size_from_buffer(uint8_t *pBufArea, uint32_t *pSize);\nstatic void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length);\n\nstatic int ipmi_fru_set_field_string(struct ipmi_intf * intf, unsigned\n\t\t\t\t\t\tchar fruId, uint8_t f_type, uint8_t f_index, char *f_string);\nstatic int\nipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info fru, struct fru_header header,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t f_type, uint8_t f_index, char *f_string);\n\nstatic void\nfru_area_print_multirec_bloc(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset);\nint\nread_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf);\nvoid free_fru_bloc(t_ipmi_fru_bloc *bloc);\n\n/* get_fru_area_str  -  Parse FRU area string from raw data\n*\n* @data:   raw FRU data\n* @offset: offset into data for area\n*\n* returns pointer to FRU area string\n*/\nchar * get_fru_area_str(uint8_t * data, uint32_t * offset)\n{\n\tstatic const char bcd_plus[] = \"0123456789 -.:,_\";\n\tchar * str;\n\tint len, off, size, i, j, k, typecode, char_idx;\n\tunion {\n\t\tuint32_t bits;\n\t\tchar chars[4];\n\t} u;\n\n\tsize = 0;\n\toff = *offset;\n\n\t/* bits 6:7 contain format */\n\ttypecode = ((data[off] & 0xC0) >> 6);\n\n\t// printf(\"Typecode:%i\\n\", typecode);\n\t/* bits 0:5 contain length */\n\tlen = data[off++];\n\tlen &= 0x3f;\n\n\tswitch (typecode) {\n\tcase 0:           /* 00b: binary/unspecified */\n\tcase 1:           /* 01b: BCD plus */\n\t\t/* hex dump or BCD -> 2x length */\n\t\tsize = (len * 2);\n\t\tbreak;\n\tcase 2:           /* 10b: 6-bit ASCII */\n\t\t/* 4 chars per group of 1-3 bytes */\n\t\tsize = (((len * 4 + 2) / 3) & ~3);\n\t\tbreak;\n\tcase 3:           /* 11b: 8-bit ASCII */\n\t\t/* no length adjustment */\n\t\tsize = len;\n\t\tbreak;\n\t}\n\n\tif (size < 1) {\n\t\t*offset = off;\n\t\treturn NULL;\n\t}\n\tstr = malloc(size+1);\n\tif (!str)\n\t\treturn NULL;\n\tmemset(str, 0, size+1);\n\n\tif (size == 0) {\n\t\tstr[0] = '\\0';\n\t\t*offset = off;\n\t\treturn str;\n\t}\n\n\tswitch (typecode) {\n\tcase 0:        /* Binary */\n\t\tstrncpy(str, buf2str(&data[off], len), size);\n\t\tbreak;\n\n\tcase 1:        /* BCD plus */\n\t\tfor (k = 0; k < size; k++)\n\t\t\tstr[k] = bcd_plus[((data[off + k / 2] >> ((k % 2) ? 0 : 4)) & 0x0f)];\n\t\tstr[k] = '\\0';\n\t\tbreak;\n\n\tcase 2:        /* 6-bit ASCII */\n\t\tfor (i = j = 0; i < len; i += 3) {\n\t\t\tu.bits = 0;\n\t\t\tk = ((len - i) < 3 ? (len - i) : 3);\n#if WORDS_BIGENDIAN\n\t\t\tu.chars[3] = data[off+i];\n\t\t\tu.chars[2] = (k > 1 ? data[off+i+1] : 0);\n\t\t\tu.chars[1] = (k > 2 ? data[off+i+2] : 0);\n\t\t\tchar_idx = 3;\n#else\n\t\t\tmemcpy((void *)&u.bits, &data[off+i], k);\n\t\t\tchar_idx = 0;\n#endif\n\t\t\tfor (k=0; k<4; k++) {\n\t\t\t\tstr[j++] = ((u.chars[char_idx] & 0x3f) + 0x20);\n\t\t\t\tu.bits >>= 6;\n\t\t\t}\n\t\t}\n\t\tstr[j] = '\\0';\n\t\tbreak;\n\n\tcase 3:\n\t\tmemcpy(str, &data[off], size);\n\t\tstr[size] = '\\0';\n\t\tbreak;\n\t}\n\n\toff += len;\n\t*offset = off;\n\n\treturn str;\n}\n\n/* is_valid_filename - checks file/path supplied by user\n *\n * input_filename - user input string\n *\n * returns   0  if path is ok\n * returns -1 if path is NULL\n * returns -2 if path is too short\n * returns -3 if path is too long\n */\nint\nis_valid_filename(const char *input_filename)\n{\n\tif (!input_filename) {\n\t\tlprintf(LOG_ERR, \"ERROR: NULL pointer passed.\");\n\t\treturn -1;\n\t}\n\n\tif (strlen(input_filename) < 1) {\n\t\tlprintf(LOG_ERR, \"File/path is invalid.\");\n\t\treturn -2;\n\t}\n\n\tif (strlen(input_filename) >= 512) {\n\t\tlprintf(LOG_ERR, \"File/path must be shorter than 512 bytes.\");\n\t\treturn -3;\n\t}\n\n\treturn 0;\n} /* is_valid_filename() */\n\n/* build_fru_bloc  -  build fru bloc for write protection\n*\n* @intf:     ipmi interface\n* @fru_info: information about FRU device\n* @id      : Fru id\n* @soffset : Source offset      (from buffer)\n* @doffset : Destination offset (in device)\n* @length  : Size of data to write (in bytes)\n* @pFrubuf : Pointer on data to write\n*\n* returns 0 on success\n* returns -1 on error\n*/\n#define FRU_NUM_BLOC_COMMON_HEADER  6\nt_ipmi_fru_bloc *\nbuild_fru_bloc(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id)\n{\n\tt_ipmi_fru_bloc * p_first, * p_bloc, * p_new;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_header header;\n\tstruct fru_multirec_header rec_hdr;\n\tuint8_t msg_data[4];\n\tuint32_t off;\n\tuint16_t i;\n\n\t/*\n\t* get COMMON Header format\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\n\tif (!rsp) {\n\t\tlprintf(LOG_ERR, \" Device not present (No Response)\");\n\t\treturn NULL;\n\t}\n\n\tif (rsp->ccode) {\n\t\tlprintf(LOG_ERR,\" Device not present (%s)\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn NULL;\n\t}\n\n\tif (verbose > 1) {\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\t}\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\t/* verify header checksum */\n\tif (ipmi_csum((uint8_t *)&header, 8)) {\n\t\tlprintf(LOG_ERR, \" Bad header checksum\");\n\t\treturn NULL;\n\t}\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\", header.version);\n\t\treturn NULL;\n\t}\n\n\t/******************************************\n\t\tMalloc and fill up the bloc contents\n\t*******************************************/\n\n\t// Common header\n\tp_first = malloc(sizeof(struct ipmi_fru_bloc));\n\tif (!p_first) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn NULL;\n\t}\n\n\tp_bloc = p_first;\n\tp_bloc->next = NULL;\n\tp_bloc->start= 0;\n\tp_bloc->size = fru->size;\n\tstrcpy((char *)p_bloc->blocId, \"Common Header Section\");\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (header.offsets[i]) {\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = header.offsets[i] * 8;\n\t\t\tp_new->size = fru->size - p_new->start;\n\n\t\t\tstrncpy((char *)p_new->blocId, section_id[i], sizeof(p_new->blocId));\n\t\t\t/* Make sure string is null terminated */\n\t\t\tp_new->blocId[sizeof(p_new->blocId)-1] = 0;\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t\tp_bloc = p_new;\n\t\t}\n\t}\n\n\t// Multi\n\tif (header.offset.multi) {\n\t\toff = header.offset.multi * 8;\n\n\t\tdo {\n\t\t\t/*\n\t\t\t * check for odd offset for the case of fru devices\n\t\t\t * accessed by words\n\t\t\t */\n\t\t\tif (fru->access && (off & 1)) {\n\t\t\t\tlprintf(LOG_ERR, \" Unaligned offset for a block: %d\", off);\n\t\t\t\t/* increment offset */\n\t\t\t\toff++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (read_fru_area(intf, fru, id, off, 5,\n\t\t\t\t\t(uint8_t *) &rec_hdr) < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = off;\n\t\t\tp_new->size = fru->size - p_new->start;\n\t\t\tsprintf((char *)p_new->blocId, \"Multi-Rec Area: Type %i\",\n\t\t\t\t\trec_hdr.type);\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t\tp_bloc = p_new;\n\n\t\t\toff += rec_hdr.len + sizeof(struct fru_multirec_header);\n\n\t\t\t/* verify record header */\n\t\t\tif (ipmi_csum((uint8_t *)&rec_hdr,\n\t\t\t\t\tsizeof(struct fru_multirec_header))) {\n\t\t\t\t/* can't reliably judge for the rest space */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!(rec_hdr.format & 0x80) && (off < fru->size));\n\n\t\tlprintf(LOG_DEBUG,\"Multi-Record area ends at: %i (%xh)\", off, off);\n\n\t\tif (fru->size > off) {\n\t\t\t// Bloc for remaining space\n\t\t\tp_new = malloc(sizeof(struct ipmi_fru_bloc));\n\t\t\tif (!p_new) {\n\t\t\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\t\t\tfree_fru_bloc(p_first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tp_new->next = NULL;\n\t\t\tp_new->start = off;\n\t\t\tp_new->size = fru->size - p_new->start;\n\t\t\tstrcpy((char *)p_new->blocId, \"Unused space\");\n\n\t\t\tp_bloc->next = p_new;\n\t\t\tp_bloc->size = p_new->start - p_bloc->start;\n\t\t}\n\t}\n\n\t/* Dump blocs */\n\tfor(p_bloc = p_first, i = 0; p_bloc; p_bloc = p_bloc->next) {\n\t\tlprintf(LOG_DEBUG ,\"Bloc Numb : %i\", i++);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Id   : %s\", p_bloc->blocId);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Start: %i\", p_bloc->start);\n\t\tlprintf(LOG_DEBUG ,\"Bloc Size : %i\", p_bloc->size);\n\t\tlprintf(LOG_DEBUG ,\"\");\n\t}\n\n\treturn p_first;\n}\n\nvoid\nfree_fru_bloc(t_ipmi_fru_bloc *bloc)\n{\n\tt_ipmi_fru_bloc * del;\n\n\twhile (bloc) {\n\t\tdel = bloc;\n\t\tbloc = bloc->next;\n\t\tfree_n(&del);\n\t}\n}\n\n/* By how many bytes to reduce a write command on a size failure. */\n#define FRU_BLOCK_SZ\t8\n/* Baseline for a large enough piece to reduce via steps instead of bytes. */\n#define FRU_AREA_MAXIMUM_BLOCK_SZ\t32\n\n/*\n * write FRU[doffset:length] from the pFrubuf[soffset:length]\n * rc=1 on success\n**/\nint\nwrite_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\t\t\tuint16_t soffset,  uint16_t doffset,\n\t\t\t\t\tuint16_t length, uint8_t *pFrubuf)\n{\n\tuint16_t tmp, finish;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[255+3];\n\tuint16_t writeLength;\n\tuint16_t found_bloc = 0;\n\n\tfinish = doffset + length;        /* destination offset */\n\tif (finish > fru->size)\n\t{\n\t\tlprintf(LOG_ERROR, \"Return error\");\n\t\treturn -1;\n\t}\n\n\tif (fru->access && ((doffset & 1) || (length & 1))) {\n\t\tlprintf(LOG_ERROR, \"Odd offset or length specified\");\n\t\treturn -1;\n\t}\n\n\tt_ipmi_fru_bloc * fru_bloc = build_fru_bloc(intf, fru, id);\n\tt_ipmi_fru_bloc * saved_fru_bloc = fru_bloc;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = SET_FRU_DATA;\n\treq.msg.data = msg_data;\n\n\t/* initialize request size only once */\n\tif (fru->max_write_size == 0) {\n\t\tuint16_t max_rq_size = ipmi_intf_get_max_request_data_size(intf);\n\n\t\t/* validate lower bound of the maximum request data size */\n\t\tif (max_rq_size <= 3) {\n\t\t\tlprintf(LOG_ERROR, \"Maximum request size is too small to send \"\n\t\t\t\t\t\"a write request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Write FRU Info command returns the number of written bytes in\n\t\t * a single byte field.\n\t\t */\n\t\tif (max_rq_size - 3 > 255) {\n\t\t\t/*  Limit the max write size with 255 bytes. */\n\t\t\tfru->max_write_size = 255;\n\t\t} else {\n\t\t\t/* subtract 1 byte for FRU ID an 2 bytes for offset */\n\t\t\tfru->max_write_size = max_rq_size - 3;\n\t\t}\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\tfru->max_write_size &= ~1;\n\t\t}\n\t}\n\n\tdo {\n\t\tuint16_t end_bloc;\n\t\tuint8_t protected_bloc = 0;\n\n\t\t/* Write per bloc, try to find the end of a bloc*/\n\t\twhile (fru_bloc && fru_bloc->start + fru_bloc->size <= doffset) {\n\t\t\tfru_bloc = fru_bloc->next;\n\t\t\tfound_bloc++;\n\t\t}\n\n\t\tif (fru_bloc && fru_bloc->start + fru_bloc->size < finish) {\n\t\t\tend_bloc = fru_bloc->start + fru_bloc->size;\n\t\t} else {\n\t\t\tend_bloc = finish;\n\t\t}\n\n\t\t/* calculate write length */\n\t\ttmp = end_bloc - doffset;\n\n\t\t/* check that write length is more than maximum request size */\n\t\tif (tmp > fru->max_write_size) {\n\t\t\twriteLength = fru->max_write_size;\n\t\t} else {\n\t\t\twriteLength = tmp;\n\t\t}\n\n\t\t/* copy fru data */\n\t\tmemcpy(&msg_data[3], pFrubuf + soffset, writeLength);\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\twriteLength &= ~1;\n\t\t}\n\n\t\ttmp = doffset;\n\t\tif (fru->access) {\n\t\t\ttmp >>= 1;\n\t\t}\n\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)tmp;\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\treq.msg.data_len = writeLength + 3;\n\n\t\tif(fru_bloc) {\n\t\t\tlprintf(LOG_INFO,\"Writing %d bytes (Bloc #%i: %s)\",\n\t\t\t\t\twriteLength, found_bloc, fru_bloc->blocId);\n\t\t} else {\n\t\t\tlprintf(LOG_INFO,\"Writing %d bytes\", writeLength);\n\t\t}\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fru_cc_rq2big(rsp->ccode)) {\n\t\t\tif (fru->max_write_size > FRU_AREA_MAXIMUM_BLOCK_SZ) {\n\t\t\t\tfru->max_write_size -= FRU_BLOCK_SZ;\n\t\t\t\tlprintf(LOG_INFO, \"Retrying FRU write with request size %d\",\n\t\t\t\t\t\tfru->max_write_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (rsp->ccode == IPMI_CC_FRU_WRITE_PROTECTED_OFFSET) {\n\t\t\trsp->ccode = IPMI_CC_OK;\n\t\t\t// Write protected section\n\t\t\tprotected_bloc = 1;\n\t\t}\n\n\t\tif (rsp->ccode)\n\t\t\tbreak;\n\n\t\tif (protected_bloc == 0) {\n\t\t\t// Write OK, bloc not protected, continue\n\t\t\tlprintf(LOG_INFO,\"Wrote %d bytes\", writeLength);\n\t\t\tdoffset += writeLength;\n\t\t\tsoffset += writeLength;\n\t\t} else {\n\t\t\tif(fru_bloc) {\n\t\t\t\t// Bloc protected, advise user and jump over protected bloc\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\t\"Bloc [%s] protected at offset: %i (size %i bytes)\",\n\t\t\t\t\t\tfru_bloc->blocId, fru_bloc->start, fru_bloc->size);\n\t\t\t\tlprintf(LOG_INFO,\"Jumping over this bloc\");\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\t\"Remaining FRU is protected following offset: %i\",\n\t\t\t\t\t\tdoffset);\n\t\t\t}\n\t\t\tsoffset += end_bloc - doffset;\n\t\t\tdoffset = end_bloc;\n\t\t}\n\t} while (doffset < finish);\n\n\tif (saved_fru_bloc) {\n\t\tfree_fru_bloc(saved_fru_bloc);\n\t}\n\n\treturn doffset >= finish;\n}\n\n/* read_fru_area  -  fill in frubuf[offset:length] from the FRU[offset:length]\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:     fru id\n* @offset: offset into buffer\n* @length: how much to read\n* @frubuf: buffer read into\n*\n* returns -1 on error\n* returns 0 if successful\n*/\nint\nread_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tuint32_t off = offset;\n\tuint32_t tmp;\n\tuint32_t finish;\n\tuint32_t size_left_in_buffer;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tmemset(frubuf + fru->size, 0, length - fru->size);\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t\tlength = finish - offset;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\tif (fru->max_read_size == 0) {\n\t\tuint16_t max_rs_size = ipmi_intf_get_max_response_data_size(intf) - 1;\n\n\t\t/* validate lower bound of the maximum response data size */\n\t\tif (max_rs_size <= 1) {\n\t\t\tlprintf(LOG_ERROR, \"Maximum response size is too small to send \"\n\t\t\t\t\t\"a read request\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/*\n\t\t * Read FRU Info command may read up to 255 bytes of data.\n\t\t */\n\t\tif (max_rs_size - 1 > 255) {\n\t\t\t/*  Limit the max read size with 255 bytes. */\n\t\t\tfru->max_read_size = 255;\n\t\t} else {\n\t\t\t/* subtract 1 byte for bytes count */\n\t\t\tfru->max_read_size = max_rs_size - 1;\n\t\t}\n\n\t\t/* check word access */\n\t\tif (fru->access) {\n\t\t\tfru->max_read_size &= ~1;\n\t\t}\n\t}\n\n\tsize_left_in_buffer = length;\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru->max_read_size)\n\t\t\tmsg_data[3] = (uint8_t)fru->max_read_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7h or C8h or CAh return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode)\n\t\t\t    && fru->max_read_size > FRU_BLOCK_SZ)\n\t\t\t{\n\t\t\t\tif (fru->max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ) {\n\t\t\t\t\t/* subtract read length more aggressively */\n\t\t\t\t\tfru->max_read_size -= FRU_BLOCK_SZ;\n\t\t\t\t} else {\n\t\t\t\t\t/* subtract length less aggressively */\n\t\t\t\t\tfru->max_read_size--;\n\t\t\t\t}\n\n\t\t\t\tlprintf(LOG_INFO, \"Retrying FRU read with request size %d\",\n\t\t\t\t\t\tfru->max_read_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tif(rsp->data_len < 1\n\t\t   || tmp > rsp->data_len - 1\n\t\t   || tmp > size_left_in_buffer)\n\t\t{\n\t\t\tprintf(\" Not enough buffer size\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemcpy(frubuf, rsp->data + 1, tmp);\n\t\toff += tmp;\n\t\tfrubuf += tmp;\n\t\tsize_left_in_buffer -= tmp;\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish) {\n\t\t\treturn 0;\n\t\t}\n\t} while (off < finish);\n\n\tif (off < finish) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* read_fru_area  -  fill in frubuf[offset:length] from the FRU[offset:length]\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:     fru id\n* @offset: offset into buffer\n* @length: how much to read\n* @frubuf: buffer read into\n*\n* returns -1 on error\n* returns 0 if successful\n*/\nint\nread_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id,\n\t\t\tuint32_t offset, uint32_t length, uint8_t *frubuf)\n{\n\tstatic uint32_t fru_data_rqst_size = 20;\n\tuint32_t off = offset;\n\tuint32_t tmp, finish;\n\tuint32_t size_left_in_buffer;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\n\tif (offset > fru->size) {\n\t\tlprintf(LOG_ERR, \"Read FRU Area offset incorrect: %d > %d\",\n\t\t\toffset, fru->size);\n\t\treturn -1;\n\t}\n\n\tfinish = offset + length;\n\tif (finish > fru->size) {\n\t\tmemset(frubuf + fru->size, 0, length - fru->size);\n\t\tfinish = fru->size;\n\t\tlprintf(LOG_NOTICE, \"Read FRU Area length %d too large, \"\n\t\t\t\"Adjusting to %d\",\n\t\t\toffset + length, finish - offset);\n\t\tlength = finish - offset;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n#ifdef LIMIT_ALL_REQUEST_SIZE\n\tif (fru_data_rqst_size > 16)\n#else\n\tif (fru->access && fru_data_rqst_size > 16)\n#endif\n\t\tfru_data_rqst_size = 16;\n\n\tsize_left_in_buffer = length;\n\tdo {\n\t\ttmp = fru->access ? off >> 1 : off;\n\t\tmsg_data[0] = id;\n\t\tmsg_data[1] = (uint8_t)(tmp & 0xff);\n\t\tmsg_data[2] = (uint8_t)(tmp >> 8);\n\t\ttmp = finish - off;\n\t\tif (tmp > fru_data_rqst_size)\n\t\t\tmsg_data[3] = (uint8_t)fru_data_rqst_size;\n\t\telse\n\t\t\tmsg_data[3] = (uint8_t)tmp;\n\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed\");\n\t\t\tbreak;\n\t\t}\n\t\tif (rsp->ccode) {\n\t\t\t/* if we get C7 or C8  or CA return code then we requested too\n\t\t\t* many bytes at once so try again with smaller size */\n\t\t\tif (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) {\n\t\t\t\tlprintf(LOG_INFO,\n\t\t\t\t\t\"Retrying FRU read with request size %d\",\n\t\t\t\t\tfru_data_rqst_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlprintf(LOG_NOTICE, \"FRU Read failed: %s\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = fru->access ? rsp->data[0] << 1 : rsp->data[0];\n\t\tif(rsp->data_len < 1\n\t\t   || tmp > rsp->data_len - 1\n\t\t   || tmp > size_left_in_buffer)\n\t\t{\n\t\t\tprintf(\" Not enough buffer size\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy((frubuf + off)-offset, rsp->data + 1, tmp);\n\t\toff += tmp;\n\t\tsize_left_in_buffer -= tmp;\n\n\t\t/* sometimes the size returned in the Info command\n\t\t* is too large.  return 0 so higher level function\n\t\t* still attempts to parse what was returned */\n\t\tif (tmp == 0 && off < finish)\n\t\t\treturn 0;\n\n\t} while (off < finish);\n\n\tif (off < finish)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n\nstatic void\nfru_area_print_multirec_bloc(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tuint8_t * fru_data = NULL;\n\tuint32_t i;\n\tstruct fru_multirec_header * h;\n\tuint32_t last_off, len;\n\n\ti = last_off = offset;\n\n\tfru_data = malloc(fru->size + 1);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru->size + 1);\n\n\tdo {\n\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t// read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time\n\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t{\n\t\t\tlen = fru->size - last_off;\n\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\tif (read_fru_area(intf, fru, id, last_off, len, fru_data) < 0)\n\t\t\t\tbreak;\n\n\t\t\tlast_off += len;\n\t\t}\n\n\t\t//printf(\"Bloc Numb : %i\\n\", counter);\n\t\tprintf(\"Bloc Start: %i\\n\", i);\n\t\tprintf(\"Bloc Size : %i\\n\", h->len);\n\t\tprintf(\"\\n\");\n\n\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t} while (!(h->format & 0x80));\n\n\ti = offset;\n\tdo {\n\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\tprintf(\"Bloc Start: %i\\n\", i);\n\t\tprintf(\"Bloc Size : %i\\n\", h->len);\n\t\tprintf(\"\\n\");\n\n\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t} while (!(h->format & 0x80));\n\n\tlprintf(LOG_DEBUG ,\"Multi-Record area ends at: %i (%xh)\",i,i);\n\n\tfree_n(&fru_data);\n}\n\n\n/* fru_area_print_chassis  -  Print FRU Chassis Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_chassis(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len, i;\n\tuint8_t tmp[2];\n\tsize_t chassis_type;\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len == 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first two bytes which specify\n\t * fru area version and fru area length\n\t */\n\ti = 2;\n\n\tchassis_type = (fru_data[i] > ARRAY_SIZE(chassis_type_desc) - 1)\n\t               ? 2\n\t               : fru_data[i];\n\tprintf(\" Chassis Type          : %s\\n\", chassis_type_desc[chassis_type]);\n\n \ti++;\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Chassis Part Number   : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Chassis Serial        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Chassis Extra         : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\n\t\tif (i == j) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_board  -  Print FRU Board Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_board(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len;\n\tuint32_t i;\n\ttime_t ts;\n\tuint8_t tmp[2];\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len <= 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first three bytes which specify\n\t * fru area version, fru area length\n\t * and fru board language\n\t */\n\ti = 3;\n\n\tts = ipmi_fru2time_t(&fru_data[i]);\n\tprintf(\" Board Mfg Date        : %s\\n\", ipmi_timestamp_string(ts));\n\ti += 3;  /* skip mfg. date time */\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Mfg             : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Product         : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Serial          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Board Part Number     : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0 && verbose > 0) {\n\t\t\tprintf(\" Board FRU ID          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Board Extra           : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tif (i == j)\n\t\t\tbreak;\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_product  -  Print FRU Product Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_product(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\t\tuint8_t id, uint32_t offset)\n{\n\tchar * fru_area;\n\tuint8_t * fru_data;\n\tuint32_t fru_len, i;\n\tuint8_t tmp[2];\n\n\tfru_len = 0;\n\n\t/* read enough to check length field */\n\tif (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {\n\t\tfru_len = 8 * tmp[1];\n\t}\n\n\tif (fru_len == 0) {\n\t\treturn;\n\t}\n\n\tfru_data = malloc(fru_len);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, fru_len);\n\n\n\t/* read in the full fru */\n\tif (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {\n\t\tfree_n(&fru_data);\n\t\treturn;\n\t}\n\n\t/*\n\t * skip first three bytes which specify\n\t * fru area version, fru area length\n\t * and fru board language\n\t */\n\ti = 3;\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Manufacturer  : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Name          : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Part Number   : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Version       : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Serial        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0) {\n\t\t\tprintf(\" Product Asset Tag     : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\tfru_area = get_fru_area_str(fru_data, &i);\n\tif (fru_area) {\n\t\tif (strlen(fru_area) > 0 && verbose > 0) {\n\t\t\tprintf(\" Product FRU ID        : %s\\n\", fru_area);\n\t\t}\n\t\tfree_n(&fru_area);\n\t}\n\n\t/* read any extra fields */\n\twhile ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {\n\t\tint j = i;\n\t\tfru_area = get_fru_area_str(fru_data, &i);\n\t\tif (fru_area) {\n\t\t\tif (strlen(fru_area) > 0) {\n\t\t\t\tprintf(\" Product Extra         : %s\\n\", fru_area);\n\t\t\t}\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tif (i == j)\n\t\t\tbreak;\n\t}\n\n\tfree_n(&fru_data);\n}\n\n/* fru_area_print_multirec  -  Print FRU Multi Record Area\n*\n* @intf:   ipmi interface\n* @fru: fru info\n* @id:  fru id\n* @offset: offset pointer\n*/\nstatic void\nfru_area_print_multirec(struct ipmi_intf * intf, struct fru_info * fru,\n\t\t\tuint8_t id, uint32_t offset)\n{\n\tuint8_t * fru_data;\n\tstruct fru_multirec_header * h;\n\tstruct fru_multirec_powersupply * ps;\n\tstruct fru_multirec_dcoutput * dc;\n\tstruct fru_multirec_dcload * dl;\n\tuint16_t peak_capacity;\n\tuint8_t peak_hold_up_time;\n\tuint32_t last_off;\n\n\tlast_off = offset;\n\n\tfru_data = malloc(FRU_MULTIREC_CHUNK_SIZE);\n\tif (!fru_data) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\treturn;\n\t}\n\n\tmemset(fru_data, 0, FRU_MULTIREC_CHUNK_SIZE);\n\n\th = (struct fru_multirec_header *) (fru_data);\n\n\tdo {\n\t\tif (read_fru_area(intf, fru, id, last_off, sizeof(*h), fru_data) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (h->len && read_fru_area(intf, fru, id,\n\t\t\t\tlast_off + sizeof(*h), h->len, fru_data + sizeof(*h)) < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast_off += h->len + sizeof(*h);\n\n\t\tswitch (h->type) {\n\t\tcase FRU_RECORD_TYPE_POWER_SUPPLY_INFORMATION:\n\t\t\tps = (struct fru_multirec_powersupply *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tps->capacity      = BSWAP_16(ps->capacity);\n\t\t\tps->peak_va    = BSWAP_16(ps->peak_va);\n\t\t\tps->lowend_input1 = BSWAP_16(ps->lowend_input1);\n\t\t\tps->highend_input1   = BSWAP_16(ps->highend_input1);\n\t\t\tps->lowend_input2 = BSWAP_16(ps->lowend_input2);\n\t\t\tps->highend_input2   = BSWAP_16(ps->highend_input2);\n\t\t\tps->combined_capacity   = BSWAP_16(ps->combined_capacity);\n\t\t\tps->peak_cap_ht      = BSWAP_16(ps->peak_cap_ht);\n#endif\n\t\t\tpeak_hold_up_time = (ps->peak_cap_ht & 0xf000) >> 12;\n\t\t\tpeak_capacity     = ps->peak_cap_ht & 0x0fff;\n\n\t\t\tprintf (\" Power Supply Record\\n\");\n\t\t\tprintf (\"  Capacity                   : %d W\\n\",\n\t\t\t\tps->capacity);\n\t\t\tprintf (\"  Peak VA                    : %d VA\\n\",\n\t\t\t\tps->peak_va);\n\t\t\tprintf (\"  Inrush Current             : %d A\\n\",\n\t\t\t\tps->inrush_current);\n\t\t\tprintf (\"  Inrush Interval            : %d ms\\n\",\n\t\t\t\tps->inrush_interval);\n\t\t\tprintf (\"  Input Voltage Range 1      : %d-%d V\\n\",\n\t\t\t\tps->lowend_input1 / 100, ps->highend_input1 / 100);\n\t\t\tprintf (\"  Input Voltage Range 2      : %d-%d V\\n\",\n\t\t\t\tps->lowend_input2 / 100, ps->highend_input2 / 100);\n\t\t\tprintf (\"  Input Frequency Range      : %d-%d Hz\\n\",\n\t\t\t\tps->lowend_freq, ps->highend_freq);\n\t\t\tprintf (\"  A/C Dropout Tolerance      : %d ms\\n\",\n\t\t\t\tps->dropout_tolerance);\n\t\t\tprintf (\"  Flags                      : %s%s%s%s%s\\n\",\n\t\t\t\tps->predictive_fail ? \"'Predictive fail' \" : \"\",\n\t\t\t\tps->pfc ? \"'Power factor correction' \" : \"\",\n\t\t\t\tps->autoswitch ? \"'Autoswitch voltage' \" : \"\",\n\t\t\t\tps->hotswap ? \"'Hot swap' \" : \"\",\n\t\t\t\tps->predictive_fail ? ps->rps_threshold ?\n\t\t\t\tps->tach ? \"'Two pulses per rotation'\" : \"'One pulse per rotation'\" :\n\t\t\t\tps->tach ? \"'Failure on pin de-assertion'\" : \"'Failure on pin assertion'\" : \"\");\n\t\t\tprintf (\"  Peak capacity              : %d W\\n\",\n\t\t\t\tpeak_capacity);\n\t\t\tprintf (\"  Peak capacity holdup       : %d s\\n\",\n\t\t\t\tpeak_hold_up_time);\n\t\t\tif (ps->combined_capacity == 0)\n\t\t\t\tprintf (\"  Combined capacity          : not specified\\n\");\n\t\t\telse\n\t\t\t\tprintf (\"  Combined capacity          : %d W (%s and %s)\\n\",\n\t\t\t\t\tps->combined_capacity,\n\t\t\t\t\tcombined_voltage_desc [ps->combined_voltage1],\n\t\t\t\t\tcombined_voltage_desc [ps->combined_voltage2]);\n\t\t\tif (ps->predictive_fail)\n\t\t\t\tprintf (\"  Fan lower threshold        : %d RPS\\n\",\n\t\t\t\t\tps->rps_threshold);\n\t\t\tbreak;\n\n\t\tcase FRU_RECORD_TYPE_DC_OUTPUT:\n\t\t\tdc = (struct fru_multirec_dcoutput *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tdc->nominal_voltage  = BSWAP_16(dc->nominal_voltage);\n\t\t\tdc->max_neg_dev      = BSWAP_16(dc->max_neg_dev);\n\t\t\tdc->max_pos_dev      = BSWAP_16(dc->max_pos_dev);\n\t\t\tdc->ripple_and_noise = BSWAP_16(dc->ripple_and_noise);\n\t\t\tdc->min_current      = BSWAP_16(dc->min_current);\n\t\t\tdc->max_current      = BSWAP_16(dc->max_current);\n#endif\n\n\t\t\tprintf (\" DC Output Record\\n\");\n\t\t\tprintf (\"  Output Number              : %d\\n\",\n\t\t\t\tdc->output_number);\n\t\t\tprintf (\"  Standby power              : %s\\n\",\n\t\t\t\tdc->standby ? \"Yes\" : \"No\");\n\t\t\tprintf (\"  Nominal voltage            : %.2f V\\n\",\n\t\t\t\t(double) dc->nominal_voltage / 100);\n\t\t\tprintf (\"  Max negative deviation     : %.2f V\\n\",\n\t\t\t\t(double) dc->max_neg_dev / 100);\n\t\t\tprintf (\"  Max positive deviation     : %.2f V\\n\",\n\t\t\t\t(double) dc->max_pos_dev / 100);\n\t\t\tprintf (\"  Ripple and noise pk-pk     : %d mV\\n\",\n\t\t\t\tdc->ripple_and_noise);\n\t\t\tprintf (\"  Minimum current draw       : %.3f A\\n\",\n\t\t\t\t(double) dc->min_current / 1000);\n\t\t\tprintf (\"  Maximum current draw       : %.3f A\\n\",\n\t\t\t\t(double) dc->max_current / 1000);\n\t\t\tbreak;\n\n\t\tcase FRU_RECORD_TYPE_DC_LOAD:\n\t\t\tdl = (struct fru_multirec_dcload *)\n\t\t\t\t(fru_data + sizeof(struct fru_multirec_header));\n\n#if WORDS_BIGENDIAN\n\t\t\tdl->nominal_voltage  = BSWAP_16(dl->nominal_voltage);\n\t\t\tdl->min_voltage      = BSWAP_16(dl->min_voltage);\n\t\t\tdl->max_voltage      = BSWAP_16(dl->max_voltage);\n\t\t\tdl->ripple_and_noise = BSWAP_16(dl->ripple_and_noise);\n\t\t\tdl->min_current      = BSWAP_16(dl->min_current);\n\t\t\tdl->max_current      = BSWAP_16(dl->max_current);\n#endif\n\n\t\t\tprintf (\" DC Load Record\\n\");\n\t\t\tprintf (\"  Output Number              : %d\\n\",\n\t\t\t\tdl->output_number);\n\t\t\tprintf (\"  Nominal voltage            : %.2f V\\n\",\n\t\t\t\t(double) dl->nominal_voltage / 100);\n\t\t\tprintf (\"  Min voltage allowed        : %.2f V\\n\",\n\t\t\t\t(double) dl->min_voltage / 100);\n\t\t\tprintf (\"  Max voltage allowed        : %.2f V\\n\",\n\t\t\t\t(double) dl->max_voltage / 100);\n\t\t\tprintf (\"  Ripple and noise pk-pk     : %d mV\\n\",\n\t\t\t\tdl->ripple_and_noise);\n\t\t\tprintf (\"  Minimum current load       : %.3f A\\n\",\n\t\t\t\t(double) dl->min_current / 1000);\n\t\t\tprintf (\"  Maximum current load       : %.3f A\\n\",\n\t\t\t\t(double) dl->max_current / 1000);\n\t\t\tbreak;\n\t\tcase FRU_RECORD_TYPE_OEM_EXTENSION:\n\t\t\t{\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\n\t\t\t\tif( iana == IPMI_OEM_PICMG ){\n\t\t\t\t\tprintf(\"  PICMG Extension Record\\n\");\n\t\t\t\t\tipmi_fru_picmg_ext_print(fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(struct fru_multirec_header),\n\t\t\t\t\t\t\t\t\t\t\t\t\th->len);\n\t\t\t\t}\n\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\telse{\n\t\t\t\t\tprintf(\"  OEM (%s) Record\\n\", val2str( iana, ipmi_oem_info));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (!(h->format & 0x80));\n\n\tlprintf(LOG_DEBUG ,\"Multi-Record area ends at: %i (%xh)\", last_off, last_off);\n\n\tfree_n(&fru_data);\n}\n\n/* ipmi_fru_query_new_value  -  Query new values to replace original FRU content\n*\n* @data:   FRU data\n* @offset: offset of the bytes to be modified in data\n* @len:    size of the modified data\n*\n* returns : TRUE if data changed\n* returns : FALSE if data not changed\n*/\nstatic\nbool\nipmi_fru_query_new_value(uint8_t *data,int offset, size_t len)\n{\n\tbool status = false;\n\tint ret;\n\tchar answer;\n\n\tprintf(\"Would you like to change this value <y/n> ? \");\n\tret = scanf(\"%c\", &answer);\n\tif (ret != 1) {\n\t\treturn false;\n\t}\n\n\tif( answer == 'y' || answer == 'Y' ){\n\t\tint i;\n\t\tunsigned int *holder;\n\n\t\tholder = malloc(len);\n\t\tprintf(\n\t\t \"Enter hex values for each of the %d entries (lsb first), \"\n\t\t \"hit <enter> between entries\\n\", (int)len);\n\n\t\t/* I can't assign scanf' %x into a single char */\n\t\tfor( i=0;i<len;i++ ){\n\t\t\tret = scanf(\"%x\", holder+i);\n\t\t\tif (ret != 1) {\n\t\t\t\tfree_n(&holder);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor( i=0;i<len;i++ ){\n\t\t\tdata[offset++] = (unsigned char) *(holder+i);\n\t\t}\n\t\t/* &data[offset++] */\n\t\tfree_n(&holder);\n\t\tstatus = true;\n\t}\n\telse{\n\t\tprintf(\"Entered %c\\n\",answer);\n\t}\n\n\treturn status;\n}\n\n/* ipmi_fru_oemkontron_edit  -\n*  Query new values to replace original FRU content\n*  This is a generic enough to support any type of 'OEM' record\n*  because the user supplies 'IANA number' , 'record Id' and 'record' version'\n*\n* However, the parser must have 'apriori' knowledge of the record format\n* The currently supported record is :\n*\n*    IANA          : 15000  (Kontron)\n*    RECORD ID     : 3\n*    RECORD VERSION: 0 (or 1)\n*\n* I would have like to put that stuff in an OEM specific file, but apart for\n* the record format information, all commands are really standard 'FRU' command\n*\n*\n* @data:   FRU data\n* @offset: start of the current multi record (start of header)\n* @len:    len of the current record (excluding header)\n* @h:      pointer to record header\n* @oh:     pointer to OEM /PICMG header\n*\n* returns: TRUE if data changed\n* returns: FALSE if data not changed\n*/\n#define OEM_KONTRON_INFORMATION_RECORD 3\n\n#define EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT    12\n#define GET_OEM_KONTRON_COMPLETE_ARG_COUNT     5\n/*\n./src/ipmitool  fru edit 0\noem 15000 3 0 name instance FIELD1 FIELD2 FIELD3 crc32\n*/\n\n#define OEM_KONTRON_SUBCOMMAND_ARG_POS   2\n#define OEM_KONTRON_IANA_ARG_POS         3\n#define OEM_KONTRON_RECORDID_ARG_POS     4\n#define OEM_KONTRON_FORMAT_ARG_POS       5\n#define OEM_KONTRON_NAME_ARG_POS         6\n#define OEM_KONTRON_INSTANCE_ARG_POS     7\n#define OEM_KONTRON_VERSION_ARG_POS      8\n#define OEM_KONTRON_BUILDDATE_ARG_POS    9\n#define OEM_KONTRON_UPDATEDATE_ARG_POS   10\n#define OEM_KONTRON_CRC32_ARG_POS        11\n\n#define OEM_KONTRON_FIELD_SIZE          8\n#define OEM_KONTRON_VERSION_FIELD_SIZE 10\n\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(1)\n#endif\ntypedef struct OemKontronInformationRecordV0{\n\tuint8_t field1TypeLength;\n\tuint8_t field1[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field2TypeLength;\n\tuint8_t field2[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field3TypeLength;\n\tuint8_t field3[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t crcTypeLength;\n\tuint8_t crc32[OEM_KONTRON_FIELD_SIZE];\n}tOemKontronInformationRecordV0;\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(0)\n#endif\n\n\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(1)\n#endif\ntypedef struct OemKontronInformationRecordV1{\n\tuint8_t field1TypeLength;\n\tuint8_t field1[OEM_KONTRON_VERSION_FIELD_SIZE];\n\tuint8_t field2TypeLength;\n\tuint8_t field2[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t field3TypeLength;\n\tuint8_t field3[OEM_KONTRON_FIELD_SIZE];\n\tuint8_t crcTypeLength;\n\tuint8_t crc32[OEM_KONTRON_FIELD_SIZE];\n}tOemKontronInformationRecordV1;\n#ifdef HAVE_PRAGMA_PACK\n#pragma pack(0)\n#endif\n\n/*\n./src/ipmitool  fru get 0 oem iana 3\n\n*/\n\nstatic void ipmi_fru_oemkontron_get(int argc,\n\t\t\t\t    char ** argv,\n\t\t\t\t    uint8_t * fru_data,\n\t\t\t\t    int off,\n\t\t\t\t    struct fru_multirec_oem_header *oh)\n{\n\tstatic bool badParams = false;\n\tint start = off;\n\tint offset = start;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tif(!badParams){\n\t\t/* the 'OEM' field is already checked in caller */\n\t\tif( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){\n\t\t\tif(strncmp(\"oem\", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){\n\t\t\t\tprintf(\"usage: fru get <id> <oem>\\n\");\n\t\t\t\tbadParams = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif( argc<GET_OEM_KONTRON_COMPLETE_ARG_COUNT ){\n\t\t\tprintf(\"usage: oem <iana> <recordid>\\n\");\n\t\t\tprintf(\"usage: oem 15000 3\\n\");\n\t\t\tbadParams = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (badParams) {\n\t\treturn;\n\t}\n\n\tif (oh->record_id != OEM_KONTRON_INFORMATION_RECORD) {\n\t\treturn;\n\t}\n\n\tuint8_t version;\n\n\tprintf(\"Kontron OEM Information Record\\n\");\n\tversion = oh->record_version;\n\n\tuint8_t blockCount;\n\tuint8_t blockIndex = 0;\n\n\tuint8_t instance = 0;\n\n\tif (str2uchar(argv[OEM_KONTRON_INSTANCE_ARG_POS], &instance) != 0) {\n\t\tlprintf(LOG_ERR,\n\t\t\t\"Instance argument '%s' is either invalid or out of range.\",\n\t\t\targv[OEM_KONTRON_INSTANCE_ARG_POS]);\n\t\tbadParams = true;\n\t\treturn;\n\t}\n\n\tblockCount = fru_data[offset++];\n\n\tfor (blockIndex = 0; blockIndex < blockCount; blockIndex++) {\n\t\tvoid *pRecordData;\n\t\tuint8_t nameLen;\n\n\t\tnameLen = (fru_data[offset++] &= 0x3F);\n\t\tprintf(\"  Name: %*.*s\\n\", nameLen, nameLen,\n\t\t       (const char *)(fru_data + offset));\n\n\t\toffset += nameLen;\n\n\t\tpRecordData = &fru_data[offset];\n\n\t\tprintf(\"  Record Version: %d\\n\", version);\n\t\tif (version == 0) {\n\t\t\tprintf(\"  Version: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field1);\n\t\t\tprintf(\"  Build Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field2);\n\t\t\tprintf(\"  Update Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->field3);\n\t\t\tprintf(\"  Checksum: %*.*s\\n\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV0 *)pRecordData)->crc32);\n\t\t\toffset += sizeof(tOemKontronInformationRecordV0);\n\t\t\toffset++;\n\t\t} else if (version == 1) {\n\t\t\tprintf(\"  Version: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_VERSION_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_VERSION_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field1);\n\t\t\tprintf(\"  Build Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field2);\n\t\t\tprintf(\"  Update Date: %*.*s\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->field3);\n\t\t\tprintf(\"  Checksum: %*.*s\\n\\n\",\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       OEM_KONTRON_FIELD_SIZE,\n\t\t\t       ((tOemKontronInformationRecordV1 *)pRecordData)->crc32);\n\t\t\toffset += sizeof(tOemKontronInformationRecordV1);\n\t\t\toffset++;\n\t\t} else {\n\t\t\tprintf(\"  Unsupported version %d\\n\", version);\n\t\t}\n\t}\n}\n\nstatic\nbool\nipmi_fru_oemkontron_edit( int argc, char ** argv,uint8_t * fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\tint off,int len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_header *h,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_oem_header *oh)\n{\n\tstatic bool badParams=false;\n\tbool hasChanged = false;\n\tint start = off;\n\tint offset = start;\n\tint length = len;\n\tint i;\n\tuint8_t record_id = 0;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tif(!badParams){\n\t\t/* the 'OEM' field is already checked in caller */\n\t\tif( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){\n\t\t\tif(strncmp(\"oem\", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){\n\t\t\t\tprintf(\"usage: fru edit <id> <oem> <args...>\\n\");\n\t\t\t\tbadParams = true;\n\t\t\t\treturn hasChanged;\n\t\t\t}\n\t\t}\n\t\tif( argc<EDIT_OEM_KONTRON_COMPLETE_ARG_COUNT ){\n\t\t\tprintf(\"usage: oem <iana> <recordid> <format> <args...>\\n\");\n\t\t\tprintf(\"usage: oem 15000 3 0 <name> <instance> <field1>\"\\\n\t\t\t\t\t\" <field2> <field3> <crc32>\\n\");\n\t\t\tbadParams = true;\n\t\t\treturn hasChanged;\n\t\t}\n\t\tif (str2uchar(argv[OEM_KONTRON_RECORDID_ARG_POS], &record_id) != 0) {\n\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\"Record ID argument '%s' is either invalid or out of range.\",\n\t\t\t\t\targv[OEM_KONTRON_RECORDID_ARG_POS]);\n\t\t\tbadParams = true;\n\t\t\treturn hasChanged;\n\t\t}\n\t\tif (record_id == OEM_KONTRON_INFORMATION_RECORD) {\n\t\t\tfor(i=OEM_KONTRON_VERSION_ARG_POS;i<=OEM_KONTRON_CRC32_ARG_POS;i++){\n\t\t\t\tif( (strlen(argv[i]) != OEM_KONTRON_FIELD_SIZE) &&\n\t\t\t\t\t(strlen(argv[i]) != OEM_KONTRON_VERSION_FIELD_SIZE)) {\n\t\t\t\t\tprintf(\"error: version fields must have %d characters\\n\",\n\t\t\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\tbadParams = true;\n\t\t\t\t\treturn hasChanged;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!badParams){\n\n\t\tif(oh->record_id == OEM_KONTRON_INFORMATION_RECORD ) {\n\t\t\tuint8_t formatVersion = 0;\n\t\t\tuint8_t version;\n\n\t\t\tif (str2uchar(argv[OEM_KONTRON_FORMAT_ARG_POS], &formatVersion) != 0) {\n\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\"Format argument '%s' is either invalid or out of range.\",\n\t\t\t\t\t\targv[OEM_KONTRON_FORMAT_ARG_POS]);\n\t\t\t\tbadParams = true;\n\t\t\t\treturn hasChanged;\n\t\t\t}\n\n\t\t\tprintf(\"   Kontron OEM Information Record\\n\");\n\t\t\tversion = oh->record_version;\n\n\t\t\tif( version == formatVersion  ){\n\t\t\t\tuint8_t blockCount;\n\t\t\t\tuint8_t blockIndex=0;\n\n\t\t\t\tuint8_t matchInstance = 0;\n\t\t\t\tuint8_t instance = 0;\n\t\t\t\t\n\t\t\t\tif (str2uchar(argv[OEM_KONTRON_INSTANCE_ARG_POS], &instance) != 0) {\n\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\"Instance argument '%s' is either invalid or out of range.\",\n\t\t\t\t\t\t\targv[OEM_KONTRON_INSTANCE_ARG_POS]);\n\t\t\t\t\tbadParams = true;\n\t\t\t\t\treturn hasChanged;\n\t\t\t\t}\n\n\t\t\t\tblockCount = fru_data[offset++];\n\t\t\t\tprintf(\"   blockCount: %d\\n\",blockCount);\n\n\t\t\t\tfor(blockIndex=0;blockIndex<blockCount;blockIndex++){\n\t\t\t\t\tvoid * pRecordData;\n\t\t\t\t\tuint8_t nameLen;\n\n\t\t\t\t\tnameLen = ( fru_data[offset++] & 0x3F );\n\n\t\t\t\t\tif( version == 0 || version == 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t(const char *)(fru_data+offset),nameLen)&& (matchInstance == instance)){\n\n\t\t\t\t\t\t\tprintf (\"Found : %s\\n\",argv[OEM_KONTRON_NAME_ARG_POS]);\n\t\t\t\t\t\t\toffset+=nameLen;\n\n\t\t\t\t\t\t\tpRecordData =  &fru_data[offset];\n\n\t\t\t\t\t\t\tif( version == 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field1 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_VERSION_ARG_POS] ,\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field2 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_BUILDDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field3 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_UPDATEDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV0 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->crc32 ,\n\t\t\t\t\t\t\targv[OEM_KONTRON_CRC32_ARG_POS] ,\n\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field1 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_VERSION_ARG_POS] ,\n\t\t\t\t\t\t\t\tOEM_KONTRON_VERSION_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field2 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_BUILDDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->field3 ,\n\t\t\t\t\t\t\t\targv[OEM_KONTRON_UPDATEDATE_ARG_POS],\n\t\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t\tmemcpy( ((tOemKontronInformationRecordV1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpRecordData)->crc32 ,\n\t\t\t\t\t\t\targv[OEM_KONTRON_CRC32_ARG_POS] ,\n\t\t\t\t\t\t\tOEM_KONTRON_FIELD_SIZE);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmatchInstance++;\n\t\t\t\t\t\t\thasChanged = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(!strncmp((char *)argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t\t(const char *)(fru_data+offset), nameLen)){\n\t\t\t\t\t\t\tprintf (\"Skipped : %s  [instance %d]\\n\",argv[OEM_KONTRON_NAME_ARG_POS],\n\t\t\t\t\t\t\t\t\t(unsigned int)matchInstance);\n\t\t\t\t\t\t\tmatchInstance++;\n\t\t\t\t\t\t\toffset+=nameLen;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\toffset+=nameLen;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( version == 0 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset+= sizeof(tOemKontronInformationRecordV0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset+= sizeof(tOemKontronInformationRecordV1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf (\"  Unsupported version %d\\n\",version);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprintf(\"   Version: %d\\n\",version);\n\t\t\t}\n\t\t}\n\t\tif( hasChanged ){\n\n\t\t\tuint8_t record_checksum =0;\n\t\t\tuint8_t header_checksum =0;\n\t\t\tint index;\n\n\t\t\tlprintf(LOG_DEBUG,\"Initial record checksum : %x\",h->record_checksum);\n\t\t\tlprintf(LOG_DEBUG,\"Initial header checksum : %x\",h->header_checksum);\n\t\t\tfor(index=0;index<length;index++){\n\t\t\t\trecord_checksum+=  fru_data[start+index];\n\t\t\t}\n\t\t\t/* Update Record checksum */\n\t\t\th->record_checksum =  ~record_checksum + 1;\n\n\n\t\t\tfor(index=0;index<(sizeof(struct fru_multirec_header) -1);index++){\n\t\t\t\tuint8_t data= *( (uint8_t *)h+ index);\n\t\t\t\theader_checksum+=data;\n\t\t\t}\n\t\t\t/* Update header checksum */\n\t\t\th->header_checksum =  ~header_checksum + 1;\n\n\t\t\tlprintf(LOG_DEBUG,\"Final record checksum : %x\",h->record_checksum);\n\t\t\tlprintf(LOG_DEBUG,\"Final header checksum : %x\",h->header_checksum);\n\n\t\t\t/* write back data */\n\t\t}\n\t}\n\n\treturn hasChanged;\n}\n\n/* ipmi_fru_picmg_ext_edit  -  Query new values to replace original FRU content\n*\n* @data:   FRU data\n* @offset: start of the current multi record (start of header)\n* @len:    len of the current record (excluding header)\n* @h:      pointer to record header\n* @oh:     pointer to OEM /PICMG header\n*\n* returns: TRUE if data changed\n* returns: FALSE if data not changed\n*/\nstatic\nbool\nipmi_fru_picmg_ext_edit(uint8_t * fru_data,\n\t\t\t\t\t\t\t\t\t\t\t\tint off,int len,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_header *h,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_multirec_oem_header *oh)\n{\n\tbool hasChanged = false;\n\tint start = off;\n\tint offset = start;\n\tint length = len;\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tswitch (oh->record_id)\n\t{\n\t\tcase FRU_AMC_ACTIVATION:\n\t\t\tprintf(\"    FRU_AMC_ACTIVATION\\n\");\n\t\t\t{\n\t\t\t\tint index=offset;\n\t\t\t\tuint16_t max_current;\n\n\t\t\t\tmax_current = fru_data[offset];\n\t\t\t\tmax_current |= fru_data[++offset]<<8;\n\n\t\t\t\tprintf(\"      Maximum Internal Current(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)max_current / 10.0f, max_current);\n\n\t\t\t\tif( ipmi_fru_query_new_value(fru_data,index,2) ){\n\t\t\t\t\tmax_current = fru_data[index];\n\t\t\t\t\tmax_current |= fru_data[++index]<<8;\n\t\t\t\t\tprintf(\"      New Maximum Internal Current(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)max_current / 10.0f, max_current);\n\t\t\t\t\thasChanged = true;\n\n\t\t\t\t}\n\n\t\t\t\tprintf(\"      Module Activation Readiness:       %i sec.\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"      Descriptor Count: %i\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tfor (++offset;\n\t\t\t\t\toffset < (off + length);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_activation_record)) {\n\t\t\t\t\tstruct fru_picmgext_activation_record * a =\n\t\t\t\t\t\t(struct fru_picmgext_activation_record *) &fru_data[offset];\n\n\t\t\t\t\tprintf(\"        IPMB-Address:         0x%x\\n\", a->ibmb_addr);\n\t\t\t\t\tprintf(\"        Max. Module Current:  %.2f A\\n\", (float)a->max_module_curr / 10.0f);\n\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CURRENT:\n\t\t\tprintf(\"    FRU_AMC_CURRENT\\n\");\n\t\t\t{\n\t\t\t\tint index=offset;\n\t\t\t\tunsigned char current;\n\n\t\t\t\tcurrent = fru_data[index];\n\n\t\t\t\tprintf(\"      Current draw(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)current / 10.0f, current);\n\n\t\t\t\tif( ipmi_fru_query_new_value(fru_data, index, 1) ){\n\t\t\t\t\tcurrent = fru_data[index];\n\n\t\t\t\t\tprintf(\"      New Current draw(@12V): %.2f A (0x%02x)\\n\",\n\t\t\t\t\t\t\t\t(float)current / 10.0f, current);\n\t\t\t\t\thasChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif( hasChanged ){\n\n\t\tuint8_t record_checksum =0;\n\t\tuint8_t header_checksum =0;\n\t\tint index;\n\n\t\tlprintf(LOG_DEBUG,\"Initial record checksum : %x\",h->record_checksum);\n\t\tlprintf(LOG_DEBUG,\"Initial header checksum : %x\",h->header_checksum);\n\t\tfor(index=0;index<length;index++){\n\t\t\trecord_checksum+=  fru_data[start+index];\n\t\t}\n\t\t/* Update Record checksum */\n\t\th->record_checksum =  ~record_checksum + 1;\n\n\n\t\tfor(index=0;index<(sizeof(struct fru_multirec_header) -1);index++){\n\t\t\tuint8_t data= *( (uint8_t *)h+ index);\n\t\t\theader_checksum+=data;\n\t\t}\n\t\t/* Update header checksum */\n\t\th->header_checksum =  ~header_checksum + 1;\n\n\t\tlprintf(LOG_DEBUG,\"Final record checksum : %x\",h->record_checksum);\n\t\tlprintf(LOG_DEBUG,\"Final header checksum : %x\",h->header_checksum);\n\n\t\t/* write back data */\n\t}\n\n\treturn hasChanged;\n}\n\n/* ipmi_fru_picmg_ext_print  - prints OEM fru record (PICMG)\n*\n* @fru_data:  FRU data\n* @offset:    offset of the bytes to be modified in data\n* @length:    size of the record\n*\n* returns : n/a\n*/\nstatic void ipmi_fru_picmg_ext_print(uint8_t * fru_data, int off, int length)\n{\n\tstruct fru_multirec_oem_header *h;\n\tint guid_count;\n\tint offset = off;\n\tint start_offset = off;\n\tint i;\n\n\th = (struct fru_multirec_oem_header *) &fru_data[offset];\n\toffset += sizeof(struct fru_multirec_oem_header);\n\n\tswitch (h->record_id)\n\t{\n\t\tcase FRU_PICMG_BACKPLANE_P2P:\n\t\t{\n\t\t\tuint8_t index;\n\t\t\tunsigned int data;\n\t\t\tstruct fru_picmgext_slot_desc *slot_d;\n\n\t\t\tslot_d =\n\t\t\t\t(struct fru_picmgext_slot_desc*)&fru_data[offset];\n\t\t\toffset += sizeof(struct fru_picmgext_slot_desc);\n\t\t\tprintf(\"    FRU_PICMG_BACKPLANE_P2P\\n\");\n\n\t\t\twhile (offset <= (start_offset+length)) {\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"    Channel Type:  \");\n\t\t\t\tswitch (slot_d->chan_type)\n\t\t\t\t{\n\t\t\t\t\tcase 0x00:\n\t\t\t\t\tcase 0x07:\n\t\t\t\t\t\tprintf(\"PICMG 2.9\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x08:\n\t\t\t\t\t\tprintf(\"Single Port Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x09:\n\t\t\t\t\t\tprintf(\"Double Port Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0a:\n\t\t\t\t\t\tprintf(\"Full Channel Fabric IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0b:\n\t\t\t\t\t\tprintf(\"Base IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0c:\n\t\t\t\t\t\tprintf(\"Update Channel IF\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x0d:\n\t\t\t\t\t\tprintf(\"ShMC Cross Connect\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"Unknown IF (0x%x)\\n\",\n\t\t\t\t\t\t\t\tslot_d->chan_type);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"    Slot Addr.   : %02x\\n\",\n\t\t\t\t\t\tslot_d->slot_addr );\n\t\t\t\tprintf(\"    Channel Count: %i\\n\",\n\t\t\t\t\t\tslot_d->chn_count);\n\n\t\t\t\tfor (index = 0;\n\t\t\t\t\t\tindex < (slot_d->chn_count);\n\t\t\t\t\t\tindex++) {\n\t\t\t\t\tstruct fru_picmgext_chn_desc *d;\n\t\t\t\t\tdata = (fru_data[offset+0]) |\n\t\t\t\t\t\t(fru_data[offset+1] << 8) |\n\t\t\t\t\t\t(fru_data[offset+2] << 16);\n\t\t\t\t\td = (struct fru_picmgext_chn_desc *)&data;\n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tprintf( \"       \"\n\t\t\t\t\t\t\t\t\"Chn: %02x  ->  \"\n\t\t\t\t\t\t\t\t\"Chn: %02x in \"\n\t\t\t\t\t\t\t\t\"Slot: %02x\\n\",\n\t\t\t\t\t\t\t\td->local_chn,\n\t\t\t\t\t\t\t\td->remote_chn,\n\t\t\t\t\t\t\t\td->remote_slot);\n\t\t\t\t\t}\n\t\t\t\t\toffset += FRU_PICMGEXT_CHN_DESC_RECORD_SIZE;\n\t\t\t\t}\n\t\t\t\tslot_d = (struct fru_picmgext_slot_desc*)&fru_data[offset];\n\t\t\t\toffset += sizeof(struct fru_picmgext_slot_desc);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_ADDRESS_TABLE:\n\t\t{\n\t\t\tunsigned int hwaddr;\n\t\t\tunsigned int sitetype;\n\t\t\tunsigned int sitenum;\n\t\t\tunsigned int entries;\n\t\t\tunsigned int i;\n\t\t\tchar *picmg_site_type_strings[] = {\n\t\t\t\t\t\"AdvancedTCA Board\",\n\t\t\t\t\t\"Power Entry\",\n\t\t\t\t\t\"Shelf FRU Information\",\n\t\t\t\t\t\"Dedicated ShMC\",\n\t\t\t\t\t\"Fan Tray\",\n\t\t\t\t\t\"Fan Filter Tray\",\n\t\t\t\t\t\"Alarm\",\n\t\t\t\t\t\"AdvancedMC Module\",\n\t\t\t\t\t\"PMC\",\n\t\t\t\t\t\"Rear Transition Module\"};\n\n\n\t\t\tprintf(\"    FRU_PICMG_ADDRESS_TABLE\\n\");\n\t\t\tprintf(\"      Type/Len:  0x%02x\\n\", fru_data[offset++]);\n\t\t\tprintf(\"      Shelf Addr: \");\n\t\t\tfor (i=0;i<20;i++) {\n\t\t\t\tprintf(\"0x%02x \", fru_data[offset++]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tentries = fru_data[offset++];\n\t\t\tprintf(\"      Addr Table Entries: 0x%02x\\n\", entries);\n\n\t\t\tfor (i=0; i<entries; i++) {\n\t\t\t\thwaddr = fru_data[offset];\n\t\t\t\tsitenum = fru_data[offset + 1];\n\t\t\t\tsitetype = fru_data[offset + 2];\n\t\t\t\tprintf(\n\t\t\t\t\t\t\"        HWAddr: 0x%02x (0x%02x) SiteNum: %d SiteType: 0x%02x %s\\n\",\n\t\t\t\t\t\thwaddr, hwaddr * 2,\n\t\t\t\t\t\tsitenum, sitetype,\n\t\t\t\t\t\t(sitetype < 0xa) ?\n\t\t\t\t\t\tpicmg_site_type_strings[sitetype] :\n\t\t\t\t\t\t\"Reserved\");\n\t\t\t\toffset += 3;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHELF_POWER_DIST:\n\t\t{\n\t\t\tunsigned int entries;\n\t\t\tunsigned int feeds;\n\t\t\tunsigned int hwaddr;\n\t\t\tunsigned int i;\n\t\t\tunsigned int id;\n\t\t\tunsigned int j;\n\t\t\tunsigned int maxext;\n\t\t\tunsigned int maxint;\n\t\t\tunsigned int minexp;\n\n\t\t\tprintf(\"    FRU_PICMG_SHELF_POWER_DIST\\n\");\n\n\t\t\tfeeds = fru_data[offset++];\n\t\t\tprintf(\"      Number of Power Feeds:   0x%02x\\n\",\n\t\t\t\t\tfeeds);\n\n\t\t\tfor (i=0; i<feeds; i++) {\n\t\t\t\tprintf(\"    Feed %d:\\n\", i);\n\t\t\t\tmaxext = fru_data[offset] |\n\t\t\t\t\t(fru_data[offset+1] << 8);\n\t\t\t\toffset += 2;\n\t\t\t\tmaxint = fru_data[offset] |\n\t\t\t\t\t(fru_data[offset+1] << 8);\n\t\t\t\toffset += 2;\n\t\t\t\tminexp = fru_data[offset];\n\t\t\t\toffset += 1;\n\t\t\t\tentries = fru_data[offset];\n\t\t\t\toffset += 1;\n\n\t\t\t\tprintf(\n\t\t\t\t\t\t\"      Max External Current:   %d.%d Amps (0x%04x)\\n\",\n\t\t\t\t\t\tmaxext / 10, maxext % 10, maxext);\n\t\t\t\tif (maxint < 0xffff) {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Max Internal Current:   %d.%d Amps (0x%04x)\\n\",\n\t\t\t\t\t\t\tmaxint / 10, maxint % 10,\n\t\t\t\t\t\t\tmaxint);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Max Internal Current:   Not Specified\\n\");\n\t\t\t\t}\n\n\t\t\t\tif (minexp >= 0x48 && minexp <= 0x90) {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Min Expected Voltage:   -%02d.%dV\\n\",\n\t\t\t\t\t\t\tminexp / 2, (minexp % 2) * 5);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"      Min Expected Voltage:   -%dV (actual invalid value 0x%x)\\n\",\n\t\t\t\t\t\t\t36, minexp);\n\t\t\t\t}\n\t\t\t\tfor (j=0; j < entries; j++) {\n\t\t\t\t\thwaddr = fru_data[offset++];\n\t\t\t\t\tid = fru_data[offset++];\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"        FRU HW Addr: 0x%02x (0x%02x)\",\n\t\t\t\t\t\t\thwaddr, hwaddr * 2);\n\t\t\t\t\tprintf(\n\t\t\t\t\t\t\t\"   FRU ID: 0x%02x\\n\",\n\t\t\t\t\t\t\tid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHELF_ACTIVATION:\n\t\t{\n\t\t\tunsigned int i;\n\t\t\tunsigned int count = 0;\n\n\t\t\tprintf(\"    FRU_PICMG_SHELF_ACTIVATION\\n\");\n\t\t\tprintf(\n\t\t\t\t\t\"      Allowance for FRU Act Readiness:   0x%02x\\n\",\n\t\t\t\t\tfru_data[offset++]);\n\n\t\t\tcount = fru_data[offset++];\n\t\t\tprintf(\n\t\t\t\t\t\"      FRU activation and Power Desc Cnt: 0x%02x\\n\",\n\t\t\t\t\tcount);\n\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tprintf(\"         HW Addr: 0x%02x \",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t\tprintf(\"         FRU ID: 0x%02x \",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t\tprintf(\"         Max FRU Power: 0x%04x \",\n\t\t\t\t\t\tfru_data[offset+0] |\n\t\t\t\t\t\t(fru_data[offset+1]<<8));\n\t\t\t\toffset += 2;\n\t\t\t\tprintf(\"         Config: 0x%02x \\n\",\n\t\t\t\t\t\tfru_data[offset++]);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_PICMG_SHMC_IP_CONN:\n\t\t\tprintf(\"    FRU_PICMG_SHMC_IP_CONN\\n\");\n\t\t\tbreak;\n\n\t\tcase FRU_PICMG_BOARD_P2P:\n\t\t\tprintf(\"    FRU_PICMG_BOARD_P2P\\n\");\n\n\t\t\tguid_count = fru_data[offset++];\n\t\t\tprintf(\"      GUID count: %2d\\n\", guid_count);\n\t\t\tfor (i = 0 ; i < guid_count; i++ ) {\n\t\t\t\tint j;\n\t\t\t\tprintf(\"        GUID [%2d]: 0x\", i);\n\n\t\t\t\tfor (j=0; j < sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\tj++) {\n\t\t\t\t\tprintf(\"%02x\", fru_data[offset+j]);\n\t\t\t\t}\n\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\toffset += sizeof(struct fru_picmgext_guid);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tfor (; offset < off + length;\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_link_desc)) {\n\n\t\t\t\t/* to solve little endian /big endian problem */\n\t\t\t\tstruct fru_picmgext_link_desc *d;\n\t\t\t\tunsigned int data = (fru_data[offset+0]) |\n\t\t\t\t\t(fru_data[offset+1] << 8) |\n\t\t\t\t\t(fru_data[offset+2] << 16) |\n\t\t\t\t\t(fru_data[offset+3] << 24);\n\t\t\t\td = (struct fru_picmgext_link_desc *) &data;\n\n\t\t\t\tprintf(\"      Link Grouping ID:     0x%02x\\n\",\n\t\t\t\t\t\td->grouping);\n\t\t\t\tprintf(\"      Link Type Extension:  0x%02x - \",\n\t\t\t\t\t\td->ext);\n\t\t\t\tif (d->type == FRU_PICMGEXT_LINK_TYPE_BASE) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"10/100/1000BASE-T Link (four-pair)\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"ShMC Cross-connect (two-pair)\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"1000Base-BX\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"10GBase-BX4 [XAUI]\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tprintf(\"FC-PI\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tprintf(\"1000Base-KX\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tprintf(\"10GBase-KX4\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET_10GBD) {\n\t\t\t\t\tswitch (d->ext) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tprintf(\"10GBase-KR\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tprintf(\"40GBase-KR4\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else if (d->type == FRU_PICMGEXT_LINK_TYPE_PCIE) {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Unknown\\n\");\n\t\t\t\t}\n\n\t\t\t\tprintf(\"      Link Type:            0x%02x - \",\n\t\t\t\t\t\td->type);\n\t\t\t\tswitch (d->type) {\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_BASE:\n\t\t\t\t\t\tprintf(\"PICMG 3.0 Base Interface 10/100/1000\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET:\n\t\t\t\t\t\tprintf(\"PICMG 3.1 Ethernet Fabric Interface\\n\");\n\t\t\t\t\t\tprintf(\"                                   Base signaling Link Class\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_INFINIBAND:\n\t\t\t\t\t\tprintf(\"PICMG 3.2 Infiniband Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_STAR:\n\t\t\t\t\t\tprintf(\"PICMG 3.3 Star Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase  FRU_PICMGEXT_LINK_TYPE_PCIE:\n\t\t\t\t\t\tprintf(\"PICMG 3.4 PCI Express Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_LINK_TYPE_FABRIC_ETHERNET_10GBD:\n\t\t\t\t\t\tprintf(\"PICMG 3.1 Ethernet Fabric Interface\\n\");\n\t\t\t\t\t\tprintf(\"                                   10.3125Gbd signaling Link Class\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (d->type == 0 || d->type == 0xff) {\n\t\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\t} else if (d->type >= 0x06 && d->type <= 0xef) {\n\t\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\t} else if (d->type >= 0xf0 && d->type <= 0xfe) {\n\t\t\t\t\t\t\tprintf(\"OEM GUID Definition\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"Invalid\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"      Link Designator: \\n\");\n\t\t\t\tprintf(\"        Port Flag:            0x%02x\\n\",\n\t\t\t\t\t\td->desig_port);\n\t\t\t\tprintf(\"        Interface:            0x%02x - \",\n\t\t\t\t\t\td->desig_if);\n\t\t\t\tswitch (d->desig_if) {\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_BASE:\n\t\t\t\t\t\tprintf(\"Base Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_FABRIC:\n\t\t\t\t\t\tprintf(\"Fabric Interface\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_UPDATE_CHANNEL:\n\t\t\t\t\t\tprintf(\"Update Channel\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase FRU_PICMGEXT_DESIGN_IF_RESERVED:\n\t\t\t\t\t\tprintf(\"Reserved\\n\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintf(\"Invalid\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprintf(\"        Channel Number:       0x%02x\\n\",\n\t\t\t\t\t\td->desig_channel);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CURRENT:\n\t\t{\n\t\t\tunsigned char current;\n\t\t\tprintf(\"    FRU_AMC_CURRENT\\n\");\n\n\t\t\tcurrent = fru_data[offset];\n\t\t\tprintf(\"      Current draw(@12V): %.2f A [ %.2f Watt ]\\n\",\n\t\t\t\t\t(float)current / 10.0f,\n\t\t\t\t\t(float)current / 10.0f * 12.0f);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_AMC_ACTIVATION:\n\t\t\tprintf(\"    FRU_AMC_ACTIVATION\\n\");\n\t\t\t{\n\t\t\t\tuint16_t max_current;\n\n\t\t\t\tmax_current = fru_data[offset];\n\t\t\t\tmax_current |= fru_data[++offset]<<8;\n\t\t\t\tprintf(\"      Maximum Internal Current(@12V): %.2f A [ %.2f Watt ]\\n\",\n\t\t\t\t\t\t(float)max_current / 10.0f,\n\t\t\t\t\t\t(float)max_current / 10.0f * 12.0f);\n\n\t\t\t\tprintf(\"      Module Activation Readiness:    %i sec.\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"      Descriptor Count: %i\\n\", fru_data[++offset]);\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tfor(++offset; offset < off + length;\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_activation_record))\n\t\t\t\t{\n\t\t\t\t\tstruct fru_picmgext_activation_record *a;\n\t\t\t\t\ta = (struct fru_picmgext_activation_record *)&fru_data[offset];\n\t\t\t\t\tprintf(\"        IPMB-Address:         0x%x\\n\",\n\t\t\t\t\t\t\ta->ibmb_addr);\n\t\t\t\t\tprintf(\"        Max. Module Current:  %.2f A\\n\",\n\t\t\t\t\t\t\t(float)a->max_module_curr / 10.0f);\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CARRIER_P2P:\n\t\t\t{\n\t\t\t\tuint16_t index;\n\t\t\t\tprintf(\"    FRU_CARRIER_P2P\\n\");\n\t\t\t\tfor(; offset < off + length; ) {\n\t\t\t\t\tstruct fru_picmgext_carrier_p2p_record * h =\n\t\t\t\t\t\t(struct fru_picmgext_carrier_p2p_record *)&fru_data[offset];\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\tprintf(\"      Resource ID:      %i\",\n\t\t\t\t\t\t\t(h->resource_id & 0x07));\n\t\t\t\t\t\tprintf(\"  Type: \");\n\t\t\t\t\tif ((h->resource_id>>7) == 1) {\n\t\t\t\t\t\tprintf(\"AMC\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintf(\"Local\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"      Descriptor Count: %i\\n\",\n\t\t\t\t\t\t\th->p2p_count);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_carrier_p2p_record);\n\t\t\t\t\tfor (index = 0; index < h->p2p_count; index++) {\n\t\t\t\t\t\t/* to solve little endian /big endian problem */\n\t\t\t\t\t\tunsigned char data[3];\n\t\t\t\t\t\tstruct fru_picmgext_carrier_p2p_descriptor * desc;\n# ifndef WORDS_BIGENDIAN\n\t\t\t\t\t\tdata[0] = fru_data[offset+0];\n\t\t\t\t\t\tdata[1] = fru_data[offset+1];\n\t\t\t\t\t\tdata[2] = fru_data[offset+2];\n# else\n\t\t\t\t\t\tdata[0] = fru_data[offset+2];\n\t\t\t\t\t\tdata[1] = fru_data[offset+1];\n\t\t\t\t\t\tdata[2] = fru_data[offset+0];\n# endif\n\t\t\t\t\t\tdesc = (struct fru_picmgext_carrier_p2p_descriptor*)&data;\n\t\t\t\t\t\tprintf(\"        Port: %02d\\t->  Remote Port: %02d\\t\",\n\t\t\t\t\t\t\t\tdesc->local_port, desc->remote_port);\n\t\t\t\t\t\tif ((desc->remote_resource_id >> 7) == 1) {\n\t\t\t\t\t\t\tprintf(\"[ AMC   ID: %02d ]\\n\",\n\t\t\t\t\t\t\t\t\tdesc->remote_resource_id & 0x0F);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprintf(\"[ local ID: %02d ]\\n\",\n\t\t\t\t\t\t\t\t\tdesc->remote_resource_id & 0x0F);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_carrier_p2p_descriptor);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_P2P:\n\t\t\t{\n\t\t\t\tunsigned int index;\n\t\t\t\tunsigned char channel_count;\n\t\t\t\tstruct fru_picmgext_amc_p2p_record * h;\n\t\t\t\tprintf(\"    FRU_AMC_P2P\\n\");\n\t\t\t\tguid_count = fru_data[offset];\n\t\t\t\tprintf(\"      GUID count: %2d\\n\", guid_count);\n\t\t\t\tfor (i = 0 ; i < guid_count; i++) {\n\t\t\t\t\tint j;\n\t\t\t\t\tprintf(\"        GUID %2d: \", i);\n\t\t\t\t\tfor (j=0; j < sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\t\tj++) {\n\t\t\t\t\t\tprintf(\"%02x\", fru_data[offset+j]);\n\t\t\t\t\t\toffset += sizeof(struct fru_picmgext_guid);\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\th = (struct fru_picmgext_amc_p2p_record *)&fru_data[++offset];\n\t\t\t\t\tprintf(\"      %s\",\n\t\t\t\t\t\t\t(h->record_type ?\n\t\t\t\t\t\t\t \"AMC Module:\" : \"On-Carrier Device\"));\n\t\t\t\t\tprintf(\"   Resource ID: %i\\n\", h->resource_id);\n\t\t\t\t\toffset += sizeof(struct fru_picmgext_amc_p2p_record);\n\t\t\t\t\tchannel_count = fru_data[offset++];\n\t\t\t\t\tprintf(\"       Descriptor Count: %i\\n\",\n\t\t\t\t\t\t\tchannel_count);\n\t\t\t\t\tfor (index = 0; index < channel_count; index++) {\n\t\t\t\t\t\tunsigned int data;\n\t\t\t\t\t\tstruct fru_picmgext_amc_channel_desc_record *d;\n\t\t\t\t\t\t/* pack the data in little endian format.\n\t\t\t\t\t\t * Stupid intel...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdata = fru_data[offset] |\n\t\t\t\t\t\t\t(fru_data[offset + 1] << 8) |\n\t\t\t\t\t\t\t(fru_data[offset + 2] << 16);\n\t\t\t\t\t\td = (struct fru_picmgext_amc_channel_desc_record *)&data;\n\t\t\t\t\t\tprintf(\"        Lane 0 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane0port);\n\t\t\t\t\t\tprintf(\"        Lane 1 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane1port);\n\t\t\t\t\t\tprintf(\"        Lane 2 Port: %i\\n\",\n\t\t\t\t\t\t\t\td->lane2port);\n\t\t\t\t\t\tprintf(\"        Lane 3 Port: %i\\n\\n\",\n\t\t\t\t\t\t\t\td->lane3port);\n\t\t\t\t\t\toffset += FRU_PICMGEXT_AMC_CHANNEL_DESC_RECORD_SIZE;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; offset < off + length;) {\n\t\t\t\t\t\tunsigned int data[2];\n\t\t\t\t\t\tstruct fru_picmgext_amc_link_desc_record *l;\n\t\t\t\t\t\tl = (struct fru_picmgext_amc_link_desc_record *)&data[0];\n\t\t\t\t\t\tdata[0] = fru_data[offset] |\n\t\t\t\t\t\t\t(fru_data[offset + 1] << 8) |\n\t\t\t\t\t\t\t(fru_data[offset + 2] << 16) |\n\t\t\t\t\t\t\t(fru_data[offset + 3] << 24);\n\t\t\t\t\t\tdata[1] = fru_data[offset + 4];\n\t\t\t\t\t\tprintf( \"      Link Designator:  Channel ID: %i\\n\"\n\t\t\t\t\t\t\t\t\"            Port Flag 0: %s%s%s%s\\n\",\n\t\t\t\t\t\t\t\tl->channel_id,\n\t\t\t\t\t\t\t\t(l->port_flag_0)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_1)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_2)?\"o\":\"-\",\n\t\t\t\t\t\t\t\t(l->port_flag_3)?\"o\":\"-\"  );\n\t\t\t\t\t\tswitch (l->type) {\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE:\n\t\t\t\t\t\t\t\t/* AMC.1 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.1 PCI Express\\n\", l->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G1_NSSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 1 capable - non SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G1_SSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 1 capable - SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G2_NSSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 2 capable - non SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_PCIE_G2_SSC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Gen 2 capable - SSC\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS1:\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_PCIE_AS2:\n\t\t\t\t\t\t\t\t/* AMC.1 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.1 PCI Express Advanced Switching\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_ETHERNET:\n\t\t\t\t\t\t\t\t/* AMC.2 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.2 Ethernet\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_ETH_1000_BX:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" 1000Base-Bx (SerDES Gigabit) Ethernet Link\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_ETH_10G_XAUI:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" 10Gbit XAUI Ethernet Link\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_STORAGE:\n\t\t\t\t\t\t\t\t/* AMC.3 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.3 Storage\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tswitch (l->type_ext) {\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_FC:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Fibre Channel\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_SATA:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Serial ATA\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase AMC_LINK_TYPE_EXT_STORAGE_SAS:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Serial Attached SCSI\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tprintf( \"        Link Type Ext:   %i - \"\n\t\t\t\t\t\t\t\t\t\t\t\t\" Invalid\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase FRU_PICMGEXT_AMC_LINK_TYPE_RAPIDIO:\n\t\t\t\t\t\t\t\t/* AMC.4 */\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"AMC.4 Serial Rapid IO\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tprintf( \"        Link Type:       %02x - \"\n\t\t\t\t\t\t\t\t\t\t\"reserved or OEM GUID\",\n\t\t\t\t\t\t\t\t\t\tl->type);\n\t\t\t\t\t\t\t\tprintf(\"        Link Type Ext:   %i\\n\",\n\t\t\t\t\t\t\t\t\t\tl->type_ext);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprintf(\"        Link group Id:   %i\\n\",\n\t\t\t\t\t\t\t\tl->group_id);\n\t\t\t\t\t\tprintf(\"        Link Asym Match: %i\\n\\n\",\n\t\t\t\t\t\t\t\tl->asym_match);\n\t\t\t\t\t\toffset += FRU_PICMGEXT_AMC_LINK_DESC_RECORD_SIZE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FRU_AMC_CARRIER_INFO:\n\t\t{\n\t\t\tunsigned char extVersion;\n\t\t\tunsigned char siteCount;\n\n\t\t\tprintf(\"    FRU_CARRIER_INFO\\n\");\n\n\t\t\textVersion = fru_data[offset++];\n\t\t\tsiteCount  = fru_data[offset++];\n\n\t\t\tprintf(\"      AMC.0 extension version: R%d.%d\\n\",\n\t\t\t\t\t(extVersion >> 0)& 0x0F,\n\t\t\t\t\t(extVersion >> 4)& 0x0F );\n\t\t\tprintf(\"      Carrier Sie Number Cnt: %d\\n\", siteCount);\n\n\t\t\tfor (i = 0 ; i < siteCount; i++ ){\n\t\t\t\tprintf(\"       Site ID: %i \\n\", fru_data[offset++]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t\tcase FRU_PICMG_CLK_CARRIER_P2P:\n\t\t{\n\t\t\tunsigned char desc_count;\n\t\t\tint i,j;\n\n\t\t\tprintf(\"    FRU_PICMG_CLK_CARRIER_P2P\\n\");\n\n\t\t\tdesc_count = fru_data[offset++];\n\n\t\t\tfor(i=0; i<desc_count; i++){\n\t\t\t\tunsigned char resource_id;\n\t\t\t\tunsigned char channel_count;\n\n\t\t\t\tresource_id   = fru_data[offset++];\n\t\t\t\tchannel_count = fru_data[offset++];\n\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"      Clock Resource ID: 0x%02x  Type: \", resource_id);\n\t\t\t\tif((resource_id & 0xC0)>>6 == 0) {printf(\"On-Carrier-Device\\n\");}\n\t\t\t\telse if((resource_id & 0xC0)>>6 == 1) {printf(\"AMC slot\\n\");}\n\t\t\t\telse if((resource_id & 0xC0)>>6 == 2) {printf(\"Backplane\\n\");}\n\t\t\t\telse{ printf(\"reserved\\n\");}\n\t\t\t\tprintf(\"      Channel Count: 0x%02x\\n\", channel_count);\n\n\t\t\t\tfor(j=0; j<channel_count; j++){\n\t\t\t\t\tunsigned char loc_channel, rem_channel, rem_resource;\n\n\t\t\t\t\tloc_channel  = fru_data[offset++];\n\t\t\t\t\trem_channel  = fru_data[offset++];\n\t\t\t\t\trem_resource = fru_data[offset++];\n\n\t\t\t\t\tprintf(\"        CLK-ID: 0x%02x    ->\", loc_channel);\n\t\t\t\t\tprintf(\" remote CLKID: 0x%02x   \", rem_channel);\n\t\t\t\t\tif((rem_resource & 0xC0)>>6 == 0) {printf(\"[ Carrier-Dev\");}\n\t\t\t\t\telse if((rem_resource & 0xC0)>>6 == 1) {printf(\"[ AMC slot   \");}\n\t\t\t\t\telse if((rem_resource & 0xC0)>>6 == 2) {printf(\"[ Backplane  \");}\n\t\t\t\t\telse{ printf(\"reserved         \");}\n\t\t\t\t\tprintf(\" 0x%02x ]\\n\", rem_resource&0xF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\t\tcase FRU_PICMG_CLK_CONFIG:\n\t\t{\n\t\t\tunsigned char resource_id, descr_count;\n\t\t\tint i,j;\n\n\t\t\tprintf(\"    FRU_PICMG_CLK_CONFIG\\n\");\n\n\t\t\tresource_id = fru_data[offset++];\n\t\t\tdescr_count = fru_data[offset++];\n\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"      Clock Resource ID: 0x%02x\\n\", resource_id);\n\t\t\tprintf(\"      Descr. Count:      0x%02x\\n\", descr_count);\n\n\t\t\tfor(i=0; i<descr_count; i++){\n\t\t\t\tunsigned char channel_id, control;\n\t\t\t\tunsigned char indirect_cnt, direct_cnt;\n\n\t\t\t\tchannel_id = fru_data[offset++];\n\t\t\t\tcontrol    = fru_data[offset++];\n\t\t\t\tprintf(\"        CLK-ID: 0x%02x  -  \", channel_id);\n\t\t\t\tprintf(\"CTRL 0x%02x [ %12s ]\\n\",\n\t\t\t\t\t\t\t\t\tcontrol,\n\t\t\t\t\t\t\t\t\t((control&0x1)==0)?\"Carrier IPMC\":\"Application\");\n\n\t\t\t\tindirect_cnt = fru_data[offset++];\n\t\t\t\tdirect_cnt   = fru_data[offset++];\n\t\t\t\tprintf(\"         Cnt: Indirect 0x%02x  /  Direct 0x%02x\\n\",\n\t\t\t\t\t\tindirect_cnt,\n\t\t\t\t\t\tdirect_cnt);\n\n\t\t\t\t/* indirect desc */\n\t\t\t\tfor(j=0; j<indirect_cnt; j++){\n\t\t\t\t\tunsigned char feature;\n\t\t\t\t\tunsigned char dep_chn_id;\n\n\t\t\t\t\tfeature    = fru_data[offset++];\n\t\t\t\t\tdep_chn_id = fru_data[offset++];\n\n\t\t\t\t\tprintf(\"          Feature: 0x%02x [%8s] - \", feature, (feature&0x1)==1?\"Source\":\"Receiver\");\n\t\t\t\t\tprintf(\"          Dep. CLK-ID: 0x%02x\\n\", dep_chn_id);\n\t\t\t\t}\n\n\t\t\t\t/* direct desc */\n\t\t\t\tfor(j=0; j<direct_cnt; j++){\n\t\t\t\t\tunsigned char feature, family, accuracy;\n\t\t\t\t\tunsigned int freq, min_freq, max_freq;\n\n\t\t\t\t\tfeature  = fru_data[offset++];\n\t\t\t\t\tfamily   = fru_data[offset++];\n\t\t\t\t\taccuracy = fru_data[offset++];\n\t\t\t\t\tfreq     = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\t\t\t\t\tmin_freq = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\t\t\t\t\tmax_freq = (fru_data[offset+0] << 0 ) | (fru_data[offset+1] << 8 )\n\t\t\t\t\t\t\t\t| (fru_data[offset+2] << 16) | (fru_data[offset+3] << 24);\n\t\t\t\t\toffset += 4;\n\n\t\t\t\t\tprintf(\"          - Feature: 0x%02x  - PLL: %x / Asym: %s\\n\",\n\t\t\t\t\t\t\tfeature,\n\t\t\t\t\t\t\t(feature > 1) & 1,\n\t\t\t\t\t\t\t(feature&1)?\"Source\":\"Receiver\");\n\t\t\t\t\tprintf(\"            Family:  0x%02x  - AccLVL: 0x%02x\\n\", family, accuracy);\n\t\t\t\t\tprintf(\"            FRQ: %-9ld - min: %-9ld - max: %-9ld\\n\",\n\t\t\t\t\t\t\tfreq, min_freq, max_freq);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tbreak;\n\n\t\tcase FRU_UTCA_FRU_INFO_TABLE:\n\t\tcase FRU_UTCA_CARRIER_MNG_IP:\n\t\tcase FRU_UTCA_CARRIER_INFO:\n\t\tcase FRU_UTCA_CARRIER_LOCATION:\n\t\tcase FRU_UTCA_SHMC_IP_LINK:\n\t\tcase FRU_UTCA_POWER_POLICY:\n\t\tcase FRU_UTCA_ACTIVATION:\n\t\tcase FRU_UTCA_PM_CAPABILTY:\n\t\tcase FRU_UTCA_FAN_GEOGRAPHY:\n\t\tcase FRU_UTCA_CLOCK_MAPPING:\n\t\tcase FRU_UTCA_MSG_BRIDGE_POLICY:\n\t\tcase FRU_UTCA_OEM_MODULE_DESC:\n\t\t\tprintf(\"    Not implemented yet. uTCA specific record found!!\\n\");\n\t\t\tprintf(\"     - Record ID: 0x%02x\\n\", h->record_id);\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"    Unknown OEM Extension Record ID: %x\\n\", h->record_id);\n\t\tbreak;\n\n\t}\n}\n\n\n/* __ipmi_fru_print  -  Do actual work to print a FRU by its ID\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\n__ipmi_fru_print(struct ipmi_intf * intf, uint8_t id)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn 1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\treturn -1;\n\t}\n\n\t/* offsets need converted to bytes\n\t* but that conversion is not done to the structure\n\t* because we may end up with offset > 255\n\t* which would overflow our 1-byte offset field */\n\n\tlprintf(LOG_DEBUG, \"fru.header.version:         0x%x\",\n\t\theader.version);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.internal: 0x%x\",\n\t\theader.offset.internal * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.chassis:  0x%x\",\n\t\theader.offset.chassis * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.board:    0x%x\",\n\t\theader.offset.board * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.product:  0x%x\",\n\t\theader.offset.product * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.multi:    0x%x\",\n\t\theader.offset.multi * 8);\n\n\t/*\n\t* rather than reading the entire part\n\t* only read the areas we'll format\n\t*/\n\t/* chassis area */\n\tif ((header.offset.chassis*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_chassis(intf, &fru, id, header.offset.chassis*8);\n\n\t/* board area */\n\tif ((header.offset.board*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_board(intf, &fru, id, header.offset.board*8);\n\n\t/* product area */\n\tif ((header.offset.product*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_product(intf, &fru, id, header.offset.product*8);\n\n\t/* multirecord area */\n\tif( verbose==0 ) /* scipp parsing multirecord */\n\t\treturn 0;\n\n\tif ((header.offset.multi*8) >= sizeof(struct fru_header))\n\t\tfru_area_print_multirec(intf, &fru, id, header.offset.multi*8);\n\n\treturn 0;\n}\n\n/* ipmi_fru_print  -  Print a FRU from its SDR locator record\n*\n* @intf:   ipmi interface\n* @fru: SDR FRU Locator Record\n*\n* returns -1 on error\n*/\nint\nipmi_fru_print(struct ipmi_intf * intf, struct sdr_record_fru_locator * fru)\n{\n\tchar desc[17];\n\tuint8_t  bridged_request = 0;\n\tuint32_t save_addr;\n\tuint32_t save_channel;\n\tint rc = 0;\n\n\tif (!fru)\n\t\treturn __ipmi_fru_print(intf, 0);\n\n\t/* Logical FRU Device\n\t*  dev_type == 0x10\n\t*  modifier\n\t*   0x00 = IPMI FRU Inventory\n\t*   0x01 = DIMM Memory ID\n\t*   0x02 = IPMI FRU Inventory\n\t*   0x03 = System Processor FRU\n\t*   0xff = unspecified\n\t*\n\t* EEPROM 24C01 or equivalent\n\t*  dev_type >= 0x08 && dev_type <= 0x0f\n\t*  modifier\n\t*   0x00 = unspecified\n\t*   0x01 = DIMM Memory ID\n\t*   0x02 = IPMI FRU Inventory\n\t*   0x03 = System Processor Cartridge\n\t*/\n\tif (fru->dev_type != 0x10 &&\n\t\t(fru->dev_type_modifier != 0x02 ||\n\t\tfru->dev_type < 0x08 || fru->dev_type > 0x0f))\n\t\treturn -1;\n\n\tif (fru->dev_slave_addr == IPMI_BMC_SLAVE_ADDR &&\n\t\tfru->device_id == 0)\n\t\treturn 0;\n\n\tmemset(desc, 0, sizeof(desc));\n\tmemcpy(desc, fru->id_string, fru->id_code & 0x01f);\n\tdesc[fru->id_code & 0x01f] = 0;\n\tprintf(\"FRU Device Description : %s (ID %d)\\n\", desc, fru->device_id);\n\n\tswitch (fru->dev_type_modifier) {\n\tcase 0x00:\n\tcase 0x02:\n\t\tif (BRIDGE_TO_SENSOR(intf, fru->dev_slave_addr,\n\t\t\t\t\t   fru->channel_num)) {\n\t\t\tbridged_request = 1;\n\t\t\tsave_addr = intf->target_addr;\n\t\t\tintf->target_addr = fru->dev_slave_addr;\n\t\t\tsave_channel = intf->target_channel;\n\t\t\tintf->target_channel = fru->channel_num;\n\t\t}\n\t\t/* print FRU */\n\t\trc = __ipmi_fru_print(intf, fru->device_id);\n\t\tif (bridged_request) {\n\t\t\tintf->target_addr = save_addr;\n\t\t\tintf->target_channel = save_channel;\n\t\t}\n\t\tbreak;\n\tcase 0x01:\n\t\trc = ipmi_spd_print_fru(intf, fru->device_id);\n\t\tbreak;\n\tdefault:\n\t\tif (verbose)\n\t\t\tprintf(\" Unsupported device 0x%02x \"\n\t\t\t\t\t\"type 0x%02x with modifier 0x%02x\\n\",\n\t\t\t\t\tfru->device_id, fru->dev_type,\n\t\t\t\t\tfru->dev_type_modifier);\n\t\telse\n\t\t\tprintf(\" Unsupported device\\n\");\n\t}\n\tprintf(\"\\n\");\n\n\treturn rc;\n}\n\n/* ipmi_fru_print_all  -  Print builtin FRU + SDR FRU Locator records\n*\n* @intf:   ipmi interface\n*\n* returns -1 on error\n*/\nstatic int\nipmi_fru_print_all(struct ipmi_intf * intf)\n{\n\tstruct ipmi_sdr_iterator * itr;\n\tstruct sdr_get_rs * header;\n\tstruct sdr_record_fru_locator * fru;\n\tint rc;\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct ipm_devid_rsp *devid;\n\tstruct sdr_record_mc_locator * mc;\n\tuint32_t save_addr;\n\n\tprintf(\"FRU Device Description : Builtin FRU Device (ID 0)\\n\");\n\t/* TODO: Figure out if FRU device 0 may show up in SDR records. */\n\n\t/* Do a Get Device ID command to determine device support */\n\tmemset (&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_APP;\n\treq.msg.cmd = BMC_GET_DEVICE_ID;\n\treq.msg.data_len = 0;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tlprintf(LOG_ERR, \"Get Device ID command failed\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tlprintf(LOG_ERR, \"Get Device ID command failed: %s\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tdevid = (struct ipm_devid_rsp *) rsp->data;\n\n\t/* Check the FRU inventory device bit to decide whether various */\n\t/* FRU commands can be issued to FRU device #0 LUN 0\t\t*/\n\n\tif (devid->adtl_device_support & 0x08) {\t/* FRU Inventory Device bit? */\n\t\trc = ipmi_fru_print(intf, NULL);\n\t\tprintf(\"\\n\");\n\t}\n\n\titr = ipmi_sdr_start(intf, 0);\n\tif (!itr)\n\t\treturn -1;\n\n\t/* Walk the SDRs looking for FRU Devices and Management Controller Devices. */\n\t/* For FRU devices, print the FRU from the SDR locator record.\t\t    */\n\t/* For MC devices, issue FRU commands to the satellite controller to print  */\n\t/* FRU data.\t\t\t\t\t\t\t\t    */\n\twhile ((header = ipmi_sdr_get_next_header(intf, itr)))\n\t{\n\t\tif (header->type == SDR_RECORD_TYPE_MC_DEVICE_LOCATOR ) {\n\t\t\t/* Check the capabilities of the Management Controller Device */\n\t\t\tmc = (struct sdr_record_mc_locator *)\n\t\t\t\tipmi_sdr_get_record(intf, header, itr);\n\t\t\t/* Does this MC device support FRU inventory device? */\n\t\t\tif (mc && (mc->dev_support & 0x08) && /* FRU inventory device? */\n\t\t\t\tintf->target_addr != mc->dev_slave_addr) {\n\t\t\t\t/* Yes. Prepare to issue FRU commands to FRU device #0 LUN 0  */\n\t\t\t\t/* using the slave address specified in the MC record.\t      */\n\n\t\t\t\t/* save current target address */\n\t\t\t\tsave_addr = intf->target_addr;\n\n\t\t\t\t/* set new target address to satellite controller */\n\t\t\t\tintf->target_addr = mc->dev_slave_addr;\n\n\t\t\t\tprintf(\"FRU Device Description : %-16s\\n\", mc->id_string);\n\n\t\t\t\t/* print the FRU by issuing FRU commands to the satellite     */\n\t\t\t\t/* controller.\t\t\t\t\t\t      */\n\t\t\t\trc = __ipmi_fru_print(intf, 0);\n\n\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\t/* restore previous target */\n\t\t\t\tintf->target_addr = save_addr;\n\t\t\t}\n\n\t\t\tfree_n(&mc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (header->type != SDR_RECORD_TYPE_FRU_DEVICE_LOCATOR)\n\t\t\tcontinue;\n\n\t\t/* Print the FRU from the SDR locator record. */\n\t\tfru = (struct sdr_record_fru_locator *)\n\t\t\tipmi_sdr_get_record(intf, header, itr);\n\t\tif (!fru || !fru->logical) {\n\t\t\tfree_n(&fru);\n\t\t\tcontinue;\n\t\t}\n\t\trc = ipmi_fru_print(intf, fru);\n\t\tfree_n(&fru);\n\t}\n\n\tipmi_sdr_end(itr);\n\n\treturn rc;\n}\n\n/* ipmi_fru_read_help() - print help text for 'read'\n *\n * returns void\n */\nvoid\nipmi_fru_read_help()\n{\n\tlprintf(LOG_NOTICE, \"fru read <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru read 0 /root/fru.bin\");\n} /* ipmi_fru_read_help() */\n\nstatic void\nipmi_fru_read_to_bin(struct ipmi_intf * intf,\n\t\t\tchar * pFileName,\n\t\t\tuint8_t fruId)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tuint8_t msg_data[4];\n\tuint8_t * pFruBuf;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t\treturn;\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (verbose) {\n\t\tprintf(\"Fru Size   = %d bytes\\n\",fru.size);\n\t\tprintf(\"Fru Access = %xh\\n\", fru.access);\n\t}\n\n\tpFruBuf = malloc(fru.size);\n\tif (pFruBuf) {\n\t\tprintf(\"Fru Size         : %d bytes\\n\",fru.size);\n\t\tread_fru_area(intf, &fru, fruId, 0, fru.size, pFruBuf);\n\t} else {\n\t\tlprintf(LOG_ERR, \"Cannot allocate %d bytes\\n\", fru.size);\n\t\treturn;\n\t}\n\n\tif(pFruBuf)\n\t{\n\t\tFILE * pFile;\n\t\tpFile = fopen(pFileName,\"wb\");\n\t\tif (pFile) {\n\t\t\tfwrite(pFruBuf, fru.size, 1, pFile);\n\t\t\tprintf(\"Done\\n\");\n\t\t} else {\n\t\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t\tfree_n(&pFruBuf);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pFile);\n\t}\n\tfree_n(&pFruBuf);\n}\n\nstatic void\nipmi_fru_write_from_bin(struct ipmi_intf * intf,\n\t\t\tchar * pFileName,\n\t\t\tuint8_t fruId)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tuint8_t msg_data[4];\n\tuint8_t *pFruBuf;\n\tuint16_t len = 0;\n\tFILE *pFile;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof (req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t\treturn;\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf(\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (verbose) {\n\t\tprintf(\"Fru Size   = %d bytes\\n\", fru.size);\n\t\tprintf(\"Fru Access = %xh\\n\", fru.access);\n\t}\n\n\tpFruBuf = malloc(fru.size);\n\tif (!pFruBuf) {\n\t\tlprintf(LOG_ERR, \"Cannot allocate %d bytes\\n\", fru.size);\n\t\treturn;\n\t}\n\n\t\tpFile = fopen(pFileName, \"rb\");\n\t\tif (pFile) {\n\t\t\tlen = fread(pFruBuf, 1, fru.size, pFile);\n\t\t\tprintf(\"Fru Size         : %d bytes\\n\", fru.size);\n\t\t\tprintf(\"Size to Write    : %d bytes\\n\", len);\n\t\t\tfclose(pFile);\n\t\t} else {\n\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t}\n\n\t\tif (len != 0) {\n\t\t\twrite_fru_area(intf, &fru, fruId,0, 0, len, pFruBuf);\n\t\t\tlprintf(LOG_INFO,\"Done\");\n\t\t}\n\n\tfree_n(&pFruBuf);\n}\n\n/* ipmi_fru_write_help() - print help text for 'write'\n *\n * returns void\n */\nvoid\nipmi_fru_write_help()\n{\n\tlprintf(LOG_NOTICE, \"fru write <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru write 0 /root/fru.bin\");\n} /* ipmi_fru_write_help() */\n\n/* ipmi_fru_edit_help - print help text for 'fru edit' command\n *\n * returns void\n */\nvoid\nipmi_fru_edit_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru edit <fruid> field <section> <index> <string> - edit FRU string\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru edit <fruid> oem iana <record> <format> <args> - limited OEM support\");\n} /* ipmi_fru_edit_help() */\n\n/* ipmi_fru_edit_multirec  -  Query new values to replace original FRU content\n*\n* @intf:   interface to use\n* @id:  FRU id to work on\n*\n* returns: nothing\n*/\n/* Work in progress, copy paste most of the stuff for other functions in this\n\tfile ... not elegant yet */\nstatic int\nipmi_fru_edit_multirec(struct ipmi_intf * intf, uint8_t id ,\n\t\t\t\t\t\t\t\t\t\t\t\tint argc, char ** argv)\n{\n\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tuint16_t retStatus = 0;\n\tuint32_t offFruMultiRec;\n\tuint32_t fruMultiRecSize = 0;\n\tstruct fru_info fruInfo;\n\tretStatus = ipmi_fru_get_multirec_location_from_fru(intf, id, &fruInfo,\n\t\t\t\t\t\t\t\t&offFruMultiRec,\n\t\t\t\t\t\t\t\t&fruMultiRecSize);\n\tif (retStatus != 0) {\n\t\treturn retStatus;\n\t}\n\n\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\n\t{\n\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\t}\n\n\t{\n\t\tuint8_t * fru_data;\n\t\tuint32_t i;\n\t\tuint32_t offset= offFruMultiRec;\n\t\tstruct fru_multirec_header * h;\n\t\tuint32_t last_off, len;\n\t\tuint8_t error=0;\n\n\t\ti = last_off = offset;\n\n\t\tmemset(&fru, 0, sizeof(fru));\n\t\tfru_data = malloc(fru.size + 1);\n\t\tif (!fru_data) {\n\t\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(fru_data, 0, fru.size + 1);\n\n\t\tdo {\n\t\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t\t/* read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time */\n\t\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t\t{\n\t\t\t\tlen = fru.size - last_off;\n\t\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\t\tif (read_fru_area(intf, &fru, id, last_off, len, fru_data) < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tlast_off += len;\n\t\t\t}\n\t\t\tif( h->type ==  FRU_RECORD_TYPE_OEM_EXTENSION ){\n\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[i + sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\tuint32_t suppliedIana = 0 ;\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\n\t\t\t\t/* Default to PICMG for backward compatibility */\n\t\t\t\tif( argc <=2 ) {\n\t\t\t\t\tsuppliedIana =  IPMI_OEM_PICMG;\n\t\t\t\t}  else {\n\t\t\t\t\tif( !strncmp( argv[2] , \"oem\" , 3 )) {\n\t\t\t\t\t\t/* Expect IANA number next */\n\t\t\t\t\t\tif( argc <= 3 ) {\n\t\t\t\t\t\t\tlprintf(LOG_ERR, \"oem iana <record> <format> [<args>]\");\n\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (str2uint(argv[3], &suppliedIana) == 0) {\n\t\t\t\t\t\t\t\tlprintf(LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\t\"using iana: %d\",\n\t\t\t\t\t\t\t\t\t\tsuppliedIana);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\t\t\t\"Given IANA '%s' is invalid.\",\n\t\t\t\t\t\t\t\t\t\targv[3]);\n\t\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( suppliedIana == iana ) {\n\t\t\t\t\tlprintf(LOG_DEBUG, \"Matching record found\" );\n\n\t\t\t\t\tif( iana == IPMI_OEM_PICMG ){\n\t\t\t\t\t\tif( ipmi_fru_picmg_ext_edit(fru_data,\n\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\th->len, h, oh )){\n\t\t\t\t\t\t\t/* The fru changed */\n\t\t\t\t\t\t\twrite_fru_area(intf,&fru,id, i,i,\n\t\t\t\t\t\th->len+ sizeof(struct fru_multirec_header), fru_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if( iana == IPMI_OEM_KONTRON ) {\n\t\t\t\t\t\tif( ipmi_fru_oemkontron_edit( argc,argv,fru_data,\n\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\th->len, h, oh )){\n\t\t\t\t\t\t\t/* The fru changed */\n\t\t\t\t\t\t\twrite_fru_area(intf,&fru,id, i,i,\n\t\t\t\t\t\th->len+ sizeof(struct fru_multirec_header), fru_data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"  OEM IANA (%s) Record not support in this mode\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tval2str( iana,  ipmi_oem_info));\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t\t} while (!(h->format & 0x80) && (error != 1));\n\n\t\tfree_n(&fru_data);\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_get_help - print help text for 'fru get'\n *\n * returns void\n */\nvoid\nipmi_fru_get_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru get <fruid> oem iana <record> <format> <args> - limited OEM support\");\n} /* ipmi_fru_get_help() */\n\nvoid\nipmi_fru_internaluse_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> info             - get internal use area size\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> print            - print internal use area in hex\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> read  <fru file> - read internal use area to file\");\n\tlprintf(LOG_NOTICE,\n\t\t\t\"fru internaluse <fru id> write <fru file> - write internal use area from file\");\n} /* void ipmi_fru_internaluse_help() */\n\n/* ipmi_fru_get_multirec   -  Query new values to replace original FRU content\n*\n* @intf:   interface to use\n* @id:  FRU id to work on\n*\n* returns: nothing\n*/\n/* Work in progress, copy paste most of the stuff for other functions in this\n\tfile ... not elegant yet */\nstatic int\nipmi_fru_get_multirec(struct ipmi_intf * intf, uint8_t id ,\n\t\t\t\t\t\t\t\t\t\t\t\tint argc, char ** argv)\n{\n\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\tuint16_t retStatus = 0;\n\tuint32_t offFruMultiRec;\n\tuint32_t fruMultiRecSize = 0;\n\tstruct fru_info fruInfo;\n\tretStatus = ipmi_fru_get_multirec_location_from_fru(intf, id, &fruInfo,\n\t\t\t\t\t\t\t\t&offFruMultiRec,\n\t\t\t\t\t\t\t\t&fruMultiRecSize);\n\tif (retStatus != 0) {\n\t\treturn retStatus;\n\t}\n\n\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\n\t{\n\n\n\tmemset(&fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru.size, fru.access ? \"words\" : \"bytes\");\n\n\tif (fru.size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru.size);\n\t\treturn -1;\n\t}\n\t}\n\n\t{\n\t\tuint8_t * fru_data;\n\t\tuint32_t i;\n\t\tuint32_t offset= offFruMultiRec;\n\t\tstruct fru_multirec_header * h;\n\t\tuint32_t last_off, len;\n\t\tuint8_t error=0;\n\n\t\ti = last_off = offset;\n\n\t\tfru_data = malloc(fru.size + 1);\n\t\tif (!fru_data) {\n\t\t\tlprintf(LOG_ERR, \" Out of memory!\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemset(fru_data, 0, fru.size + 1);\n\n\t\tdo {\n\t\t\th = (struct fru_multirec_header *) (fru_data + i);\n\n\t\t\t/* read area in (at most) FRU_MULTIREC_CHUNK_SIZE bytes at a time */\n\t\t\tif ((last_off < (i + sizeof(*h))) || (last_off < (i + h->len)))\n\t\t\t{\n\t\t\t\tlen = fru.size - last_off;\n\t\t\t\tif (len > FRU_MULTIREC_CHUNK_SIZE)\n\t\t\t\t\tlen = FRU_MULTIREC_CHUNK_SIZE;\n\n\t\t\t\tif (read_fru_area(intf, &fru, id, last_off, len, fru_data) < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tlast_off += len;\n\t\t\t}\n\t\t\tif( h->type ==  FRU_RECORD_TYPE_OEM_EXTENSION ){\n\n\t\t\t\tstruct fru_multirec_oem_header *oh=(struct fru_multirec_oem_header *)\n\t\t\t\t\t\t\t\t\t\t&fru_data[i + sizeof(struct fru_multirec_header)];\n\t\t\t\tuint32_t iana = oh->mfg_id[0] | oh->mfg_id[1]<<8 | oh->mfg_id[2]<<16;\n\n\t\t\t\tuint32_t suppliedIana = 0 ;\n\t\t\t\t/* Now makes sure this is really PICMG record */\n\t\t\t\tif( !strncmp( argv[2] , \"oem\" , 3 )) {\n\t\t\t\t\t/* Expect IANA number next */\n\t\t\t\t\tif( argc <= 3 ) {\n\t\t\t\t\t\tlprintf(LOG_ERR, \"oem iana <record> <format>\");\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (str2uint(argv[3], &suppliedIana) == 0) {\n\t\t\t\t\t\t\tlprintf(LOG_DEBUG,\n\t\t\t\t\t\t\t\t\t\"using iana: %d\",\n\t\t\t\t\t\t\t\t\tsuppliedIana);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\t\t\t\t\"Given IANA '%s' is invalid.\",\n\t\t\t\t\t\t\t\t\targv[3]);\n\t\t\t\t\t\t\terror = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( suppliedIana == iana ) {\n\t\t\t\t\tlprintf(LOG_DEBUG, \"Matching record found\" );\n\n\t\t\t\t\tif( iana == IPMI_OEM_KONTRON ) {\n\t\t\t\t\t\tipmi_fru_oemkontron_get(argc, argv, fru_data,\n\t\t\t\t\t\t\t\t\ti + sizeof(struct fru_multirec_header),\n\t\t\t\t\t\t\t\t\toh);\n\t\t\t\t\t}\n\t\t\t\t\t/* FIXME: Add OEM record support here */\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"  OEM IANA (%s) Record not supported in this mode\\n\",\n\t\t\t\t\t\t       val2str( iana,  ipmi_oem_info));\n\t\t\t\t\t\terror = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += h->len + sizeof (struct fru_multirec_header);\n\t\t} while (!(h->format & 0x80) && (error != 1));\n\n\t\tfree_n(&fru_data);\n\t}\n\treturn 0;\n}\n\n#define ERR_EXIT do { rc = -1; goto exit; } while(0)\n\nstatic\nint\nipmi_fru_upg_ekeying(struct ipmi_intf *intf, char *pFileName, uint8_t fruId)\n{\n\tstruct fru_info fruInfo = {0};\n\tuint8_t *buf = NULL;\n\tuint32_t offFruMultiRec = 0;\n\tuint32_t fruMultiRecSize = 0;\n\tuint32_t offFileMultiRec = 0;\n\tuint32_t fileMultiRecSize = 0;\n\tint rc = 0;\n\n\tif (!pFileName) {\n\t\tlprintf(LOG_ERR, \"File expected, but none given.\");\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_multirec_location_from_fru(intf, fruId, &fruInfo,\n\t\t\t\t\t\t\t&offFruMultiRec, &fruMultiRecSize) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec location from FRU.\");\n\t\tERR_EXIT;\n\t}\n\tlprintf(LOG_DEBUG, \"FRU Size        : %lu\\n\", fruMultiRecSize);\n\tlprintf(LOG_DEBUG, \"Multi Rec offset: %lu\\n\", offFruMultiRec);\n\tif (ipmi_fru_get_multirec_size_from_file(pFileName, &fileMultiRecSize,\n\t\t\t\t&offFileMultiRec) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec size from file '%s'.\", pFileName);\n\t\tERR_EXIT;\n\t}\n\tbuf = malloc(fileMultiRecSize);\n\tif (!buf) {\n\t\tlprintf(LOG_ERR, \"ipmitool: malloc failure\");\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_multirec_from_file(pFileName, buf, fileMultiRecSize,\n\t\t\t\toffFileMultiRec) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to get multirec from file '%s'.\", pFileName);\n\t\tERR_EXIT;\n\t}\n\tif (ipmi_fru_get_adjust_size_from_buffer(buf, &fileMultiRecSize) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to adjust size from buffer.\");\n\t\tERR_EXIT;\n\t}\n\tif (write_fru_area(intf, &fruInfo, fruId, 0, offFruMultiRec,\n\t\t\t\tfileMultiRecSize, buf) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to write FRU area.\");\n\t\tERR_EXIT;\n\t}\n\n\tlprintf(LOG_INFO, \"Done upgrading Ekey.\");\n\nexit:\n\tfree_n(&buf);\n\n\treturn rc;\n}\n\n/* ipmi_fru_upgekey_help - print help text for 'upgEkey'\n *\n * returns void\n */\nvoid\nipmi_fru_upgekey_help()\n{\n\tlprintf(LOG_NOTICE, \"fru upgEkey <fru id> <fru file>\");\n\tlprintf(LOG_NOTICE, \"Note: FRU ID and file(incl. full path) must be specified.\");\n\tlprintf(LOG_NOTICE, \"Example: ipmitool fru upgEkey 0 /root/fru.bin\");\n} /* ipmi_fru_upgekey_help() */\n\nstatic int\nipmi_fru_get_multirec_size_from_file(char * pFileName,\n\t\t\t\t\tuint32_t * pSize,\n\t\t\t\t\tuint32_t * pOffset)\n{\n\tstruct fru_header header;\n\tFILE * pFile;\n\tuint8_t len = 0;\n\tuint32_t end = 0;\n\t*pSize = 0;\n\n\tpFile = fopen(pFileName,\"rb\");\n\tif (pFile) {\n\t\trewind(pFile);\n\t\tlen = fread(&header, 1, 8, pFile);\n\t\tfseek(pFile, 0, SEEK_END);\n\t\tend = ftell(pFile);\n\t\tfclose(pFile);\n\t}\n\n\tlprintf(LOG_DEBUG, \"File Size = %lu\\n\", end);\n\tlprintf(LOG_DEBUG, \"Len = %u\\n\", len);\n\n\tif (len != 8) {\n\t\tprintf(\"Error with file %s in getting size\\n\", pFileName);\n\t\treturn -1;\n\t}\n\n\tif (header.version != 0x01) {\n\t\tprintf (\"Unknown FRU header version %02x.\\n\", header.version);\n\t\treturn -1;\n\t}\n\n\t/* Retrieve length */\n\tif (((header.offset.internal * 8) > (header.offset.internal * 8)) &&\n\t\t((header.offset.internal * 8) < end))\n\t\tend = (header.offset.internal * 8);\n\n\tif (((header.offset.chassis * 8) > (header.offset.chassis * 8)) &&\n\t\t((header.offset.chassis * 8) < end))\n\t\tend = (header.offset.chassis * 8);\n\n\tif (((header.offset.board * 8) > (header.offset.board * 8)) &&\n\t\t((header.offset.board * 8) < end))\n\t\tend = (header.offset.board * 8);\n\n\tif (((header.offset.product * 8) > (header.offset.product * 8)) &&\n\t\t((header.offset.product * 8) < end))\n\t\tend = (header.offset.product * 8);\n\n\t*pSize = end - (header.offset.multi * 8);\n\t*pOffset = (header.offset.multi * 8);\n\n\treturn 0;\n}\n\nint\nipmi_fru_get_adjust_size_from_buffer(uint8_t * fru_data, uint32_t *pSize)\n{\n\tstruct fru_multirec_header * head;\n\tint status = 0;\n\tuint8_t checksum = 0;\n\tuint8_t counter = 0;\n\tuint16_t count = 0;\n\tdo {\n\t\tchecksum = 0;\n\t\thead = (struct fru_multirec_header *) (fru_data + count);\n\t\tif (verbose) {\n\t\t\tprintf(\"Adding (\");\n\t\t}\n\t\tfor (counter = 0; counter < sizeof(struct fru_multirec_header); counter++) {\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\" %02X\", *(fru_data + count + counter));\n\t\t\t}\n\t\t\tchecksum += *(fru_data + count + counter);\n\t\t}\n\t\tif (verbose) {\n\t\t\tprintf(\")\");\n\t\t}\n\t\tif (checksum != 0) {\n\t\t\tlprintf(LOG_ERR, \"Bad checksum in Multi Records\");\n\t\t\tstatus = -1;\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"--> FAIL\");\n\t\t\t}\n\t\t} else if (verbose) {\n\t\t\tprintf(\"--> OK\");\n\t\t}\n\t\tif (verbose > 1 && checksum == 0) {\n\t\t\tfor (counter = 0; counter < head->len; counter++) {\n\t\t\t\tprintf(\" %02X\", *(fru_data + count + counter\n\t\t\t\t\t\t\t+ sizeof(struct fru_multirec_header)));\n\t\t\t}\n\t\t}\n\t\tif (verbose) {\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcount += head->len + sizeof (struct fru_multirec_header);\n\t} while ((!(head->format & 0x80)) && (status == 0));\n\n\t*pSize = count;\n\tlprintf(LOG_DEBUG, \"Size of multirec: %lu\\n\", *pSize);\n\treturn status;\n}\n\nstatic int\nipmi_fru_get_multirec_from_file(char * pFileName, uint8_t * pBufArea,\n\t\tuint32_t size, uint32_t offset)\n{\n\tFILE * pFile;\n\tuint32_t len = 0;\n\tif (!pFileName) {\n\t\tlprintf(LOG_ERR, \"Invalid file name given.\");\n\t\treturn -1;\n\t}\n\t\n\terrno = 0;\n\tpFile = fopen(pFileName, \"rb\");\n\tif (!pFile) {\n\t\tlprintf(LOG_ERR, \"Error opening file '%s': %i -> %s.\", pFileName, errno,\n\t\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\terrno = 0;\n\tif (fseek(pFile, offset, SEEK_SET) != 0) {\n\t\tlprintf(LOG_ERR, \"Failed to seek in file '%s': %i -> %s.\", pFileName, errno,\n\t\t\t\tstrerror(errno));\n\t\tfclose(pFile);\n\t\treturn -1;\n\t}\n\tlen = fread(pBufArea, size, 1, pFile);\n\tfclose(pFile);\n\n\tif (len != 1) {\n\t\tlprintf(LOG_ERR, \"Error in file '%s'.\", pFileName);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nipmi_fru_get_multirec_location_from_fru(struct ipmi_intf * intf,\n\t\t\t\t\tuint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct fru_info *pFruInfo,\n\t\t\t\t\tuint32_t * pRetLocation,\n\t\t\t\t\tuint32_t * pRetSize)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tuint8_t msg_data[4];\n\tuint32_t end;\n\tstruct fru_header header;\n\n\t*pRetLocation = 0;\n\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tif (verbose > 1)\n\t\t\tprintf(\"no response\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout accessing FRU info. (Device not present?)\\n\");\n\t\telse\n\t\t\tprintf (\"   CCODE = 0x%02x\\n\", rsp->ccode);\n\t\treturn -1;\n\t}\n\tpFruInfo->size = (rsp->data[1] << 8) | rsp->data[0];\n\tpFruInfo->access = rsp->data[2] & 0x1;\n\n\tif (verbose > 1)\n\t\tprintf(\"pFruInfo->size = %d bytes (accessed by %s)\\n\",\n\t\t\t\tpFruInfo->size, pFruInfo->access ? \"words\" : \"bytes\");\n\n\tif (!pFruInfo->size)\n\t\treturn -1;\n\n\tmsg_data[0] = fruId;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\n\tif (!rsp)\n\t\treturn -1;\n\tif (rsp->ccode) {\n\t\tif (rsp->ccode == IPMI_CC_TIMEOUT)\n\t\t\tprintf (\"  Timeout while reading FRU data. (Device not present?)\\n\");\n\t\treturn -1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 0x01) {\n\t\tprintf (\"  Unknown FRU header version %02x.\\n\", header.version);\n\t\treturn -1;\n\t}\n\n\tend = pFruInfo->size;\n\n\t/* Retrieve length */\n\tif (((header.offset.internal * 8) > (header.offset.internal * 8)) &&\n\t\t((header.offset.internal * 8) < end))\n\t\tend = (header.offset.internal * 8);\n\n\tif (((header.offset.chassis * 8) > (header.offset.chassis * 8)) &&\n\t\t((header.offset.chassis * 8) < end))\n\t\tend = (header.offset.chassis * 8);\n\n\tif (((header.offset.board * 8) > (header.offset.board * 8)) &&\n\t\t((header.offset.board * 8) < end))\n\t\tend = (header.offset.board * 8);\n\n\tif (((header.offset.product * 8) > (header.offset.product * 8)) &&\n\t\t((header.offset.product * 8) < end))\n\t\tend = (header.offset.product * 8);\n\n\t*pRetSize = end;\n\t*pRetLocation = 8 * header.offset.multi;\n\n\treturn 0;\n}\n\n/* ipmi_fru_get_internal_use_offset -  Retrieve internal use offset\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_get_internal_use_info(  struct ipmi_intf * intf,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t id,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info * fru,\n\t\t\t\t\t\t\t\t\t\t\tuint16_t * size,\n\t\t\t\t\t\t\t\t\t\t\tuint16_t * offset)\n{\n\tstruct ipmi_rs * rsp;\n\tstruct ipmi_rq req;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\n\t// Init output value\n\t* offset = 0;\n\t* size = 0;\n\n\tmemset(fru, 0, sizeof(struct fru_info));\n\tmemset(&header, 0, sizeof(struct fru_header));\n\n\t/*\n\t* get info about this FRU\n\t*/\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = id;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn -1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn -1;\n\t}\n\n\tfru->size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru->access = rsp->data[2] & 0x1;\n\n\tlprintf(LOG_DEBUG, \"fru.size = %d bytes (accessed by %s)\",\n\t\tfru->size, fru->access ? \"words\" : \"bytes\");\n\n\tif (fru->size < 1) {\n\t\tlprintf(LOG_ERR, \" Invalid FRU size %d\", fru->size);\n\t\treturn -1;\n\t}\n\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = id;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\treturn 1;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\treturn 1;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tlprintf(LOG_ERR, \" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\treturn -1;\n\t}\n\n\tlprintf(LOG_DEBUG, \"fru.header.version:         0x%x\",\n\t\theader.version);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.internal: 0x%x\",\n\t\theader.offset.internal * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.chassis:  0x%x\",\n\t\theader.offset.chassis * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.board:    0x%x\",\n\t\theader.offset.board * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.product:  0x%x\",\n\t\theader.offset.product * 8);\n\tlprintf(LOG_DEBUG, \"fru.header.offset.multi:    0x%x\",\n\t\theader.offset.multi * 8);\n\n\tif((header.offset.internal*8) == 0)\n\t{\n\t\t* size = 0;\n\t\t* offset = 0;\n\t}\n\telse\n\t{\n\t\t(* offset) = (header.offset.internal*8);\n\n\t\tif(header.offset.chassis != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.chassis*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.board != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.board*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.product != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.product*8)-(* offset));\n\t\t}\n\t\telse if(header.offset.multi != 0)\n\t\t{\n\t\t\t(* size) = ((header.offset.multi*8)-(* offset));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(* size) = (fru->size - (* offset));\n\t\t}\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_info_internal_use -  print internal use info\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_info_internal_use(struct ipmi_intf * intf, uint8_t id)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(          \"Internal Use Area Size  : %i\\n\", size);\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_help - print help text for FRU subcommand\n *\n * returns void\n */\nvoid\nipmi_fru_help()\n{\n\tlprintf(LOG_NOTICE,\n\t\t\t\"FRU Commands:  print read write upgEkey edit internaluse get\");\n} /* ipmi_fru_help() */\n\n/* ipmi_fru_read_internal_use -  print internal use are in hex or file\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_read_internal_use(struct ipmi_intf * intf, uint8_t id, char * pFileName)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tuint8_t * frubuf;\n\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(          \"Internal Use Area Size  : %i\\n\", size);\n\n\t\tfrubuf = malloc( size );\n\t\tif(frubuf)\n\t\t{\n\t\t\trc = read_fru_area_section(intf, &fru, id, offset, size, frubuf);\n\n\t\t\tif(rc == 0)\n\t\t\t{\n\t\t\t\tif(!pFileName)\n\t\t\t\t{\n\t\t\t\t\tuint16_t counter;\n\t\t\t\t\tfor(counter = 0; counter < size; counter ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif((counter % 16) == 0)\n\t\t\t\t\t\t\tprintf(\"\\n%02i- \", (counter / 16));\n\t\t\t\t\t\tprintf(\"%02X \", frubuf[counter]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFILE * pFile;\n\t\t\t\t\tpFile = fopen(pFileName,\"wb\");\n\t\t\t\t\tif (pFile)\n\t\t\t\t\t{\n\t\t\t\t\t\tfwrite(frubuf, size, 1, pFile);\n\t\t\t\t\t\tprintf(\"Done\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlprintf(LOG_ERR, \"Error opening file %s\\n\", pFileName);\n\t\t\t\t\t\tfree_n(&frubuf);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tfclose(pFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\n\t\t\tfree_n(&frubuf);\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t}\n\treturn 0;\n}\n\n/* ipmi_fru_write_internal_use   -  print internal use are in hex or file\n*\n* @intf:   ipmi interface\n* @id:     fru id\n*\n* returns -1 on error\n* returns 0 if successful\n* returns 1 if device not present\n*/\nstatic int\nipmi_fru_write_internal_use(struct ipmi_intf * intf, uint8_t id, char * pFileName)\n{\n\tstruct fru_info fru;\n\tuint16_t size;\n\tuint16_t offset;\n\tint rc = 0;\n\n\trc = ipmi_fru_get_internal_use_info(intf, id, &fru, &size, &offset);\n\n\tif(rc == 0)\n\t{\n\t\tuint8_t * frubuf;\n\t\tFILE * fp;\n\t\tuint32_t fileLength = 0;\n\n\t\tlprintf(LOG_DEBUG, \"Internal Use Area Offset: %i\", offset);\n\t\tprintf(            \"Internal Use Area Size  : %i\\n\", size);\n\n\t\tfp = fopen(pFileName, \"r\");\n\n\t\tif(fp)\n\t\t{\n\t\t\t/* Retrieve file length, check if it's fits the Eeprom Size */\n\t\t\tfseek(fp, 0 ,SEEK_END);\n\t\t\tfileLength = ftell(fp);\n\n\t\t\tlprintf(LOG_ERR, \"File Size: %i\", fileLength);\n\t\t\tlprintf(LOG_ERR, \"Area Size: %i\", size);\n\t\t\tif(fileLength != size)\n\t\t\t{\n\t\t\t\tlprintf(LOG_ERR, \"File size does not fit Eeprom Size\");\n\t\t\t\tfclose(fp);\n\t\t\t\tfp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfseek(fp, 0 ,SEEK_SET);\n\t\t\t}\n\t\t}\n\n\t\tif(fp)\n\t\t{\n\t\t\tfrubuf = malloc( size );\n\t\t\tif(frubuf)\n\t\t\t{\n\t\t\t\tuint16_t fru_read_size;\n\t\t\t\tfru_read_size = fread(frubuf, 1, size, fp);\n\n\t\t\t\tif(fru_read_size == size)\n\t\t\t\t{\n\t\t\t\t\trc = write_fru_area(intf, &fru, id, 0, offset, size, frubuf);\n\n\t\t\t\t\tif(rc == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlprintf(LOG_INFO, \"Done\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlprintf(LOG_ERR, \"Unable to read file: %i\\n\", fru_read_size);\n\t\t\t\t}\n\n\t\t\t\tfree_n(&frubuf);\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t\tfp = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tlprintf(LOG_ERR, \"Cannot access internal use area\");\n\t}\n\treturn 0;\n}\n\nint\nipmi_fru_main(struct ipmi_intf * intf, int argc, char ** argv)\n{\n\tint rc = 0;\n\tuint8_t fru_id = 0;\n\n\tif (argc < 1) {\n\t\trc = ipmi_fru_print_all(intf);\n\t}\n\telse if (strncmp(argv[0], \"help\", 4) == 0) {\n\t\tipmi_fru_help();\n\t\treturn 0;\n\t}\n\telse if (strncmp(argv[0], \"print\", 5) == 0 ||\n\t\tstrncmp(argv[0], \"list\", 4) == 0) {\n\t\tif (argc > 1) {\n\t\t\tif (strcmp(argv[1], \"help\") == 0) {\n\t\t\t\tlprintf(LOG_NOTICE, \"fru print [fru id] - print information about FRU(s)\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = __ipmi_fru_print(intf, fru_id);\n\t\t} else {\n\t\t\trc = ipmi_fru_print_all(intf);\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"read\", 5)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_read_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_read_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\tif (verbose) {\n\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\tprintf(\"FRU File         : %s\\n\", argv[2]);\n\t\t}\n\t\t/* TODO - rc is missing */\n\t\tipmi_fru_read_to_bin(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"write\", 5)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_write_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_write_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\tif (verbose) {\n\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\tprintf(\"FRU File         : %s\\n\", argv[2]);\n\t\t}\n\t\t/* TODO - rc is missing */\n\t\tipmi_fru_write_from_bin(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"upgEkey\", 7)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_upgekey_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 3) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_upgekey_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\treturn -1;\n\n\t\t/* There is a file name in the parameters */\n\t\tif (is_valid_filename(argv[2]) != 0)\n\t\t\treturn -1;\n\n\t\trc = ipmi_fru_upg_ekeying(intf, argv[2], fru_id);\n\t}\n\telse if (!strncmp(argv[0], \"internaluse\", 11)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_internaluse_help();\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ( (argc >= 3) && (!strncmp(argv[2], \"info\", 4)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = ipmi_fru_info_internal_use(intf, fru_id);\n\t\t}\n\t\telse if ( (argc >= 3) && (!strncmp(argv[2], \"print\", 5)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\trc = ipmi_fru_read_internal_use(intf, fru_id, NULL);\n\t\t}\n\t\telse if ( (argc >= 4) && (!strncmp(argv[2], \"read\", 4)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* There is a file name in the parameters */\n\t\t\tif (is_valid_filename(argv[3]) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tlprintf(LOG_DEBUG, \"FRU ID           : %d\", fru_id);\n\t\t\tlprintf(LOG_DEBUG, \"FRU File         : %s\", argv[3]);\n\n\t\t\trc = ipmi_fru_read_internal_use(intf, fru_id, argv[3]);\n\t\t}\n\t\telse if ( (argc >= 4) && (!strncmp(argv[2], \"write\", 5)) ) {\n\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\t/* There is a file name in the parameters */\n\t\t\tif (is_valid_filename(argv[3]) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tlprintf(LOG_DEBUG, \"FRU ID           : %d\", fru_id);\n\t\t\tlprintf(LOG_DEBUG, \"FRU File         : %s\", argv[3]);\n\n\t\t\trc = ipmi_fru_write_internal_use(intf, fru_id, argv[3]);\n\t\t} else {\n\t\t\tlprintf(LOG_ERR,\n\t\t\t\t\t\"Either unknown command or not enough parameters given.\");\n\t\t\tipmi_fru_internaluse_help();\n\t\t\treturn -1;\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"edit\", 4)) {\n\t\tif (argc > 1 && strcmp(argv[1], \"help\") == 0) {\n\t\t\tipmi_fru_edit_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 2) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_edit_help();\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tif (argc >= 2) {\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Using default FRU ID: %d\\n\", fru_id);\n\t\t}\n\n\t\tif (argc >= 3) {\n\t\t\tif (!strncmp(argv[2], \"field\", 5)) {\n\t\t\t\tif (argc != 6) {\n\t\t\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\t\t\tipmi_fru_edit_help();\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\trc = ipmi_fru_set_field_string(intf, fru_id, *argv[3], *argv[4],\n\t\t\t\t\t\t(char *) argv[5]);\n\t\t\t} else if (!strncmp(argv[2], \"oem\", 3)) {\n\t\t\t\trc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_ERR, \"Invalid command: %s\", argv[2]);\n\t\t\t\tipmi_fru_edit_help();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\trc = ipmi_fru_edit_multirec(intf, fru_id, argc, argv);\n\t\t}\n\t}\n\telse if (!strncmp(argv[0], \"get\", 4)) {\n\t\tif (argc > 1 && (strncmp(argv[1], \"help\", 4) == 0)) {\n\t\t\tipmi_fru_get_help();\n\t\t\treturn 0;\n\t\t} else if (argc < 2) {\n\t\t\tlprintf(LOG_ERR, \"Not enough parameters given.\");\n\t\t\tipmi_fru_get_help();\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (argc >= 2) {\n\t\t\tif (is_fru_id(argv[1], &fru_id) != 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (verbose) {\n\t\t\t\tprintf(\"FRU ID           : %d\\n\", fru_id);\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(\"Using default FRU ID: %d\\n\", fru_id);\n\t\t}\n\n\t\tif (argc >= 3) {\n\t\t\tif (!strncmp(argv[2], \"oem\", 3)) {\n\t\t\t\trc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);\n\t\t\t} else {\n\t\t\t\tlprintf(LOG_ERR, \"Invalid command: %s\", argv[2]);\n\t\t\t\tipmi_fru_get_help();\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\trc = ipmi_fru_get_multirec(intf, fru_id, argc, argv);\n\t\t}\n\t}\n\telse {\n\t\tlprintf(LOG_ERR, \"Invalid FRU command: %s\", argv[0]);\n\t\tipmi_fru_help();\n\t\treturn -1;\n\t}\n\n\treturn rc;\n}\n\n/* ipmi_fru_set_field_string -  Set a field string to a new value, Need to be the same size.  If\n*                              size if not equal, the function ipmi_fru_set_field_string_rebuild\n*                              will be called.\n*\n* @intf:       ipmi interface\n* @id:         fru id\n* @f_type:    Type of the Field : c=Chassis b=Board p=Product\n* @f_index:   findex of the field, zero indexed.\n* @f_string:  NULL terminated string\n*\n* returns -1 on error\n* returns 1 if successful\n*/\nstatic int\nipmi_fru_set_field_string(struct ipmi_intf * intf, uint8_t fruId, uint8_t\nf_type, uint8_t f_index, char *f_string)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\n\tstruct fru_info fru;\n\tstruct fru_header header;\n\tuint8_t msg_data[4];\n\tuint8_t checksum;\n\tint i = 0;\n\tint rc = 1;\n\tuint8_t *fru_data = NULL;\n\tuint8_t *fru_area = NULL;\n\tuint32_t fru_field_offset, fru_field_offset_tmp;\n\tuint32_t fru_section_len, header_offset;\n\n\tmemset(msg_data, 0, 4);\n\tmsg_data[0] = fruId;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_INFO;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 1;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp) {\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tif (rsp->ccode) {\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tmemset(&fru, 0, sizeof(fru));\n\tfru.size = (rsp->data[1] << 8) | rsp->data[0];\n\tfru.access = rsp->data[2] & 0x1;\n\n\tif (fru.size < 1) {\n\t\tprintf(\" Invalid FRU size %d\", fru.size);\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\t/*\n\t* retrieve the FRU header\n\t*/\n\tmsg_data[0] = fruId;\n\tmsg_data[1] = 0;\n\tmsg_data[2] = 0;\n\tmsg_data[3] = 8;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_STORAGE;\n\treq.msg.cmd = GET_FRU_DATA;\n\treq.msg.data = msg_data;\n\treq.msg.data_len = 4;\n\n\trsp = intf->sendrecv(intf, &req);\n\tif (!rsp)\n\t{\n\t\tprintf(\" Device not present (No Response)\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tif (rsp->ccode)\n\t{\n\t\tprintf(\" Device not present (%s)\\n\",\n\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tif (verbose > 1)\n\t\tprintbuf(rsp->data, rsp->data_len, \"FRU DATA\");\n\n\tmemcpy(&header, rsp->data + 1, 8);\n\n\tif (header.version != 1) {\n\t\tprintf(\" Unknown FRU header version 0x%02x\",\n\t\t\theader.version);\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tfru_data = malloc( fru.size );\n\tif (!fru_data) {\n\t\tprintf(\"Out of memory!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\t/* Setup offset from the field type */\n\n\t/* Chassis type field */\n\tif (f_type == 'c' ) {\n\t\theader_offset = (header.offset.chassis * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 3;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\t/* Board type field */\n\telse if (f_type == 'b' ) {\n\t\theader_offset = (header.offset.board * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 6;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\t/* Product type field */\n\telse if (f_type == 'p' ) {\n\t\theader_offset = (header.offset.product * 8);\n\t\tread_fru_area(intf ,&fru, fruId, header_offset , 3 , fru_data);\n\t\tfru_field_offset = 3;\n\t\tfru_section_len = *(fru_data + 1) * 8;\n\t}\n\telse\n\t{\n\t\tprintf(\"Wrong field type.\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\tmemset(fru_data, 0, fru.size);\n\tif( read_fru_area(intf ,&fru, fruId, header_offset ,\n\t\t\t\t\tfru_section_len , fru_data) < 0 )\n\t{\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\t/* Convert index from character to decimal */\n\tf_index= f_index - 0x30;\n\n\t/*Seek to field index */\n\tfor (i=0; i <= f_index; i++) {\n\t\tfru_field_offset_tmp = fru_field_offset;\n\t\tif (fru_area) {\n\t\t\tfree_n(&fru_area);\n\t\t}\n\t\tfru_area = (uint8_t *) get_fru_area_str(fru_data, &fru_field_offset);\n\t}\n\n\tif (!FRU_FIELD_VALID(fru_area)) {\n\t\tprintf(\"Field not found !\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_out;\n\t}\n\n\tif ( strlen((const char *)fru_area) == strlen((const char *)f_string) )\n\t{\n\t\tprintf(\"Updating Field '%s' with '%s' ...\\n\", fru_area, f_string );\n\t\tmemcpy(fru_data + fru_field_offset_tmp + 1,\n\t\t\t\t\t\t\t\tf_string, strlen(f_string));\n\n\t\tchecksum = 0;\n\t\t/* Calculate Header Checksum */\n\t\tfor (i = 0; i < fru_section_len - 1; i++)\n\t\t{\n\t\t\tchecksum += fru_data[i];\n\t\t}\n\t\tchecksum = (~checksum) + 1;\n\t\tfru_data[fru_section_len - 1] = checksum;\n\n\t\t/* Write the updated section to the FRU data; source offset => 0 */\n\t\tif( write_fru_area(intf, &fru, fruId, 0,\n\t\t\t\theader_offset, fru_section_len, fru_data) < 0 )\n\t\t{\n\t\t\tprintf(\"Write to FRU data failed.\\n\");\n\t\t\trc = -1;\n\t\t\tgoto ipmi_fru_set_field_string_out;\n\t\t}\n\t}\n\telse {\n\t\tprintf(\"String size are not equal, resizing fru to fit new string\\n\");\n\t\tif(\n\t\t\t\tipmi_fru_set_field_string_rebuild(intf,fruId,fru,header,f_type,f_index,f_string)\n\t\t)\n\t\t{\n\t\t\trc = -1;\n\t\t\tgoto ipmi_fru_set_field_string_out;\n\t\t}\n\t}\n\nipmi_fru_set_field_string_out:\n\tfree_n(&fru_data);\n\tfree_n(&fru_area);\n\n\treturn rc;\n}\n\n/*\n\tThis function can update a string within of the following section when the size is not equal:\n\n\tChassis\n\tProduct\n\tBoard\n*/\n/* ipmi_fru_set_field_string_rebuild -  Set a field string to a new value, When size are not\n*                                      the same size.\n*\n*  This function can update a string within of the following section when the size is not equal:\n*\n*      - Chassis\n*      - Product\n*      - Board\n*\n* @intf:     ipmi interface\n* @fruId:    fru id\n* @fru:      info about fru\n* @header:   contain the header of the FRU\n* @f_type:   Type of the Field : c=Chassis b=Board p=Product\n* @f_index:  findex of the field, zero indexed.\n* @f_string: NULL terminated string\n*\n* returns -1 on error\n* returns 1 if successful\n*/\n\n#define DBG_RESIZE_FRU\nstatic int\nipmi_fru_set_field_string_rebuild(struct ipmi_intf * intf, uint8_t fruId,\n\t\t\t\t\t\t\t\t\t\t\tstruct fru_info fru, struct fru_header header,\n\t\t\t\t\t\t\t\t\t\t\tuint8_t f_type, uint8_t f_index, char *f_string)\n{\n\tint i = 0;\n\tuint8_t *fru_data_old = NULL;\n\tuint8_t *fru_data_new = NULL;\n\tuint8_t *fru_area = NULL;\n\tuint32_t fru_field_offset, fru_field_offset_tmp;\n\tuint32_t fru_section_len, header_offset;\n\tuint32_t chassis_offset, board_offset, product_offset;\n\tuint32_t chassis_len, board_len, product_len, product_len_new;\n\tint      num_byte_change = 0, padding_len = 0;\n\tuint32_t counter;\n\tunsigned char cksum;\n\tint rc = 1;\n\n\tfru_data_old = calloc( fru.size, sizeof(uint8_t) );\n\n\tfru_data_new = malloc( fru.size );\n\n\tif (!fru_data_old || !fru_data_new) {\n\t\tprintf(\"Out of memory!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t1) Read ALL FRU */\n\tprintf(\"Read All FRU area\\n\");\n\tprintf(\"Fru Size       : %u bytes\\n\", fru.size);\n\n\t/* Read current fru data */\n\tread_fru_area(intf ,&fru, fruId, 0, fru.size , fru_data_old);\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Copy to new FRU\\n\");\n\t#endif\n\n\t/*************************\n\t2) Copy all FRU to new FRU */\n\tmemcpy(fru_data_new, fru_data_old, fru.size);\n\n\t/* Build location of all modifiable components */\n\tchassis_offset = (header.offset.chassis * 8);\n\tboard_offset   = (header.offset.board   * 8);\n\tproduct_offset = (header.offset.product * 8);\n\n\t/* Retrieve length of all modifiable components */\n\tchassis_len    =  *(fru_data_old + chassis_offset + 1) * 8;\n\tboard_len      =  *(fru_data_old + board_offset   + 1) * 8;\n\tproduct_len    =  *(fru_data_old + product_offset + 1) * 8;\n\tproduct_len_new = product_len;\n\n\t/* Chassis type field */\n\tif (f_type == 'c' )\n\t{\n\t\theader_offset    = chassis_offset;\n\t\tfru_field_offset = chassis_offset + 3;\n\t\tfru_section_len  = chassis_len;\n\t}\n\t/* Board type field */\n\telse if (f_type == 'b' )\n\t{\n\t\theader_offset    = board_offset;\n\t\tfru_field_offset = board_offset + 6;\n\t\tfru_section_len  = board_len;\n\t}\n\t/* Product type field */\n\telse if (f_type == 'p' )\n\t{\n\t\theader_offset    = product_offset;\n\t\tfru_field_offset = product_offset + 3;\n\t\tfru_section_len  = product_len;\n\t}\n\telse\n\t{\n\t\tprintf(\"Wrong field type.\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t3) Seek to field index */\n\tfor (i = 0;i <= f_index; i++) {\n\t\tfru_field_offset_tmp = fru_field_offset;\n\t\tfree_n(&fru_area);\n\t\tfru_area = (uint8_t *) get_fru_area_str(fru_data_old, &fru_field_offset);\n\t}\n\n\tif (!FRU_FIELD_VALID(fru_area)) {\n\t\tprintf(\"Field not found (1)!\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Section Length: %u\\n\", fru_section_len);\n\t#endif\n\n\t/*************************\n\t4) Check number of padding bytes and bytes changed */\n\tfor(counter = 2; counter < fru_section_len; counter ++)\n\t{\n\t\tif(*(fru_data_old + (header_offset + fru_section_len - counter)) == 0)\n\t\t\tpadding_len ++;\n\t\telse\n\t\t\tbreak;\n\t}\n\tnum_byte_change = strlen(f_string) - strlen(fru_area);\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"Padding Length: %u\\n\", padding_len);\n\tprintf(\"NumByte Change: %i\\n\", num_byte_change);\n\tprintf(\"Start SecChnge: %x\\n\", *(fru_data_old + fru_field_offset_tmp));\n\tprintf(\"End SecChnge  : %x\\n\", *(fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1));\n\n\tprintf(\"Start Section : %x\\n\", *(fru_data_old + header_offset));\n\tprintf(\"End Sec wo Pad: %x\\n\", *(fru_data_old + header_offset + fru_section_len - 2 - padding_len));\n\tprintf(\"End Section   : %x\\n\", *(fru_data_old + header_offset + fru_section_len - 1));\n\t#endif\n\n\t/* Calculate New Padding Length */\n\tpadding_len -= num_byte_change;\n\n\t#ifdef DBG_RESIZE_FRU\n\tprintf(\"New Padding Length: %i\\n\", padding_len);\n\t#endif\n\n\t/*************************\n\t5) Check if section must be resize.  This occur when padding length is not between 0 and 7 */\n\tif( (padding_len < 0) || (padding_len >= 8))\n\t{\n\t\tuint32_t remaining_offset = ((header.offset.product * 8) + product_len);\n\t\tint change_size_by_8;\n\n\t\tif(padding_len >= 8)\n\t\t{\n\t\t\t/* Section must be set smaller */\n\t\t\tchange_size_by_8 = ((padding_len) / 8) * (-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Section must be set bigger */\n\t\t\tchange_size_by_8 = 1 + (((padding_len+1) / 8) * (-1));\n\t\t}\n\n\t\t/* Recalculate padding and section length base on the section changes */\n\t\tfru_section_len += (change_size_by_8 * 8);\n\t\tpadding_len     += (change_size_by_8 * 8);\n\n\t\t#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"change_size_by_8: %i\\n\", change_size_by_8);\n\t\tprintf(\"New Padding Length: %i\\n\", padding_len);\n\t\tprintf(\"change_size_by_8: %i\\n\", change_size_by_8);\n\t\tprintf(\"header.offset.board: %i\\n\", header.offset.board);\n\t\t#endif\n\n\t\t/* Must move sections */\n\t\t/* Section that can be modified are as follow\n\t\t\tChassis\n\t\t\tBoard\n\t\t\tproduct */\n\n\t\t/* Chassis type field */\n\t\tif (f_type == 'c' )\n\t\t{\n\t\t\tprintf(\"Moving Section Chassis, from %i to %i\\n\",\n\t\t\t\t\t\t((header.offset.board) * 8),\n\t\t\t\t\t\t((header.offset.board + change_size_by_8) * 8)\n\t\t\t\t\t);\n\t\t\tmemcpy(\n\t\t\t\t\t\t(fru_data_new + ((header.offset.board + change_size_by_8) * 8)),\n\t\t\t\t\t\t(fru_data_old + (header.offset.board) * 8),\n\t\t\t\t\t\tboard_len\n\t\t\t\t\t);\n\t\t\theader.offset.board   += change_size_by_8;\n\t\t}\n\t\t/* Board type field */\n\t\tif ((f_type == 'c' ) || (f_type == 'b' ))\n\t\t{\n\t\t\tprintf(\"Moving Section Product, from %i to %i\\n\",\n\t\t\t\t\t\t((header.offset.product) * 8),\n\t\t\t\t\t\t((header.offset.product + change_size_by_8) * 8)\n\t\t\t\t\t);\n\t\t\tmemcpy(\n\t\t\t\t\t\t(fru_data_new + ((header.offset.product + change_size_by_8) * 8)),\n\t\t\t\t\t\t(fru_data_old + (header.offset.product) * 8),\n\t\t\t\t\t\tproduct_len\n\t\t\t\t\t);\n\t\t\theader.offset.product += change_size_by_8;\n\t\t}\n\n\t\tif ((f_type == 'c' ) || (f_type == 'b' ) || (f_type == 'p' )) {\n\t\t\tprintf(\"Change multi offset from %d to %d\\n\", header.offset.multi, header.offset.multi + change_size_by_8);\n\t\t\theader.offset.multi += change_size_by_8;\n\t\t}\n\n\t\t/* Adjust length of the section */\n\t\tif (f_type == 'c')\n\t\t{\n\t\t\t*(fru_data_new + chassis_offset + 1) += change_size_by_8;\n\t\t}\n\t\telse if( f_type == 'b')\n\t\t{\n\t\t\t*(fru_data_new + board_offset + 1)   += change_size_by_8;\n\t\t}\n\t\telse if( f_type == 'p')\n\t\t{\n\t\t\t*(fru_data_new + product_offset + 1) += change_size_by_8;\n\t\t\tproduct_len_new = *(fru_data_new + product_offset + 1) * 8;\n\t\t}\n\n\t\t/* Rebuild Header checksum */\n\t\t{\n\t\t\tunsigned char * pfru_header = (unsigned char *) &header;\n\t\t\theader.checksum = 0;\n\t\t\tfor(counter = 0; counter < (sizeof(struct fru_header) -1); counter ++)\n\t\t\t{\n\t\t\t\theader.checksum += pfru_header[counter];\n\t\t\t}\n\t\t\theader.checksum = (0 - header.checksum);\n\t\t\tmemcpy(fru_data_new, pfru_header, sizeof(struct fru_header));\n\t\t}\n\n\t\t/* Move remaining sections in 1 copy */\n\t\tprintf(\"Moving Remaining Bytes (Multi-Rec , etc..), from %i to %i\\n\",\n\t\t\t\t\tremaining_offset,\n\t\t\t\t\t((header.offset.product) * 8) + product_len_new\n\t\t\t\t);\n\t\tif(((header.offset.product * 8) + product_len_new - remaining_offset) < 0)\n\t\t{\n\t\t\tmemcpy(\n\t\t\t\t\t\tfru_data_new + (header.offset.product * 8) + product_len_new,\n\t\t\t\t\t\tfru_data_old + remaining_offset,\n\t\t\t\t\t\tfru.size - remaining_offset\n\t\t\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(\n\t\t\t\t\t\tfru_data_new + (header.offset.product * 8) + product_len_new,\n\t\t\t\t\t\tfru_data_old + remaining_offset,\n\t\t\t\t\t\tfru.size - ((header.offset.product * 8) + product_len_new)\n\t\t\t\t\t);\n\t\t}\n\t}\n\n\t/* Update only if it's fits padding length as defined in the spec, otherwise, it's an internal\n\terror */\n\t/*************************\n\t6) Update Field and sections */\n\tif( (padding_len >=0) && (padding_len < 8))\n\t{\n\t\t/* Do not requires any change in other section */\n\n\t\t/* Change field length */\n\t\tprintf(\n\t\t\t\"Updating Field : '%s' with '%s' ... (Length from '%d' to '%d')\\n\",\n\t\t\tfru_area, f_string, \n\t\t\t(int)*(fru_data_old + fru_field_offset_tmp), \n\t\t\t(int)(0xc0 + strlen(f_string)));\n\t\t*(fru_data_new + fru_field_offset_tmp) = (0xc0 + strlen(f_string));\n\t\tmemcpy(fru_data_new + fru_field_offset_tmp + 1, f_string, strlen(f_string));\n\n\t\t/* Copy remaining bytes in section */\n#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"Copying remaining of sections: %d \\n\",\n\t\t (int)((fru_data_old + header_offset + fru_section_len - 1) -\n\t\t (fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1)));\n#endif\n\n\t\tmemcpy((fru_data_new + fru_field_offset_tmp + 1 + \n\t\t\tstrlen(f_string)),\n\t\t\t(fru_data_old + fru_field_offset_tmp + 1 + \n\t\t\tstrlen(fru_area)),\n\t\t((fru_data_old + header_offset + fru_section_len - 1) -\n\t\t(fru_data_old + fru_field_offset_tmp + strlen(f_string) + 1)));\n\n\t\t/* Add Padding if required */\n\t\tfor(counter = 0; counter < padding_len; counter ++)\n\t\t{\n\t\t\t*(fru_data_new + header_offset + fru_section_len - 1 - \n\t\t\t  padding_len + counter) = 0;\n\t\t}\n\n\t\t/* Calculate New Checksum */\n\t\tcksum = 0;\n\t\tfor( counter = 0; counter <fru_section_len-1; counter ++ )\n\t\t{\n\t\t\tcksum += *(fru_data_new + header_offset + counter);\n\t\t}\n\t\t*(fru_data_new + header_offset + fru_section_len - 1) = (0 - cksum);\n\n\t\t#ifdef DBG_RESIZE_FRU\n\t\tprintf(\"Calculate New Checksum: %x\\n\", (0 - cksum));\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tprintf( \"Internal error, padding length %i (must be from 0 to 7) \", padding_len );\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\t/*************************\n\t7) Finally, write new FRU */\n\tprintf(\"Writing new FRU.\\n\");\n\tif( write_fru_area( intf, &fru, fruId, 0, 0, fru.size, fru_data_new ) < 0 )\n\t{\n\t\tprintf(\"Write to FRU data failed.\\n\");\n\t\trc = -1;\n\t\tgoto ipmi_fru_set_field_string_rebuild_out;\n\t}\n\n\tprintf(\"Done.\\n\");\n\nipmi_fru_set_field_string_rebuild_out:\n\tfree_n(&fru_area);\n\tfree_n(&fru_data_new);\n\tfree_n(&fru_data_old);\n\n\treturn rc;\n}\n"], "filenames": ["lib/ipmi_fru.c"], "buggy_code_start_loc": [666], "buggy_code_end_loc": [857], "fixing_code_start_loc": [666], "fixing_code_end_loc": [887], "type": "CWE-120", "message": "It's been found that multiple functions in ipmitool before 1.8.19 neglect proper checking of the data received from a remote LAN party, which may lead to buffer overflows and potentially to remote code execution on the ipmitool side. This is especially dangerous if ipmitool is run as a privileged user. This problem is fixed in version 1.8.19.", "other": {"cve": {"id": "CVE-2020-5208", "sourceIdentifier": "security-advisories@github.com", "published": "2020-02-05T14:15:11.420", "lastModified": "2021-12-30T21:13:25.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "It's been found that multiple functions in ipmitool before 1.8.19 neglect proper checking of the data received from a remote LAN party, which may lead to buffer overflows and potentially to remote code execution on the ipmitool side. This is especially dangerous if ipmitool is run as a privileged user. This problem is fixed in version 1.8.19."}, {"lang": "es", "value": "Se detect\u00f3 que varias funciones en ipmitool versiones anteriores a 1.8.19, descuidan la comprobaci\u00f3n apropiada de los datos recibidos desde una parte de la LAN remota, lo que puede conllevar a desbordamientos de b\u00fafer y potencialmente a una ejecuci\u00f3n de c\u00f3digo remota en el lado de ipmitool. Esto es especialmente peligroso si ipmitool se ejecuta como un usuario privilegiado. Este problema es corregido en la versi\u00f3n 1.8.19."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ipmitool_project:ipmitool:1.8.18:*:*:*:*:*:*:*", "matchCriteriaId": "8A93E0CF-4164-457E-8399-9ECCA4925537"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00031.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ipmitool/ipmitool/commit/e824c23316ae50beb7f7488f2055ac65e8b341f2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ipmitool/ipmitool/security/advisories/GHSA-g659-9qxw-p7cp", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00006.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/06/msg00029.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/K2BPW66KDP4H36AGZXLED57A3O2Y6EQW/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RYYEKUAUTCWICM77HOEGZDVVEUJLP4BP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202101-03", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ipmitool/ipmitool/commit/e824c23316ae50beb7f7488f2055ac65e8b341f2"}}