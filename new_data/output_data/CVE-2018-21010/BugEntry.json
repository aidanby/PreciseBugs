{"buggy_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <assert.h>\n\n#include \"opj_apps_config.h\"\n#include \"openjpeg.h\"\n#include \"color.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n\n#ifdef OPJ_USE_LEGACY\n#define OPJ_CLRSPC_GRAY CLRSPC_GRAY\n#define OPJ_CLRSPC_SRGB CLRSPC_SRGB\n#endif\n\n/*--------------------------------------------------------\nMatrix for sYCC, Amendment 1 to IEC 61966-2-1\n\nY :   0.299   0.587    0.114   :R\nCb:  -0.1687 -0.3312   0.5     :G\nCr:   0.5    -0.4187  -0.0812  :B\n\nInverse:\n\nR: 1        -3.68213e-05    1.40199      :Y\nG: 1.00003  -0.344125      -0.714128     :Cb - 2^(prec - 1)\nB: 0.999823  1.77204       -8.04142e-06  :Cr - 2^(prec - 1)\n\n-----------------------------------------------------------*/\nstatic void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,\n                        int *out_r, int *out_g, int *out_b)\n{\n    int r, g, b;\n\n    cb -= offset;\n    cr -= offset;\n    r = y + (int)(1.402 * (float)cr);\n    if (r < 0) {\n        r = 0;\n    } else if (r > upb) {\n        r = upb;\n    }\n    *out_r = r;\n\n    g = y - (int)(0.344 * (float)cb + 0.714 * (float)cr);\n    if (g < 0) {\n        g = 0;\n    } else if (g > upb) {\n        g = upb;\n    }\n    *out_g = g;\n\n    b = y + (int)(1.772 * (float)cb);\n    if (b < 0) {\n        b = 0;\n    } else if (b > upb) {\n        b = upb;\n    }\n    *out_b = b;\n}\n\nstatic void sycc444_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b;\n    const int *y, *cb, *cr;\n    size_t maxw, maxh, max, i;\n    int offset, upb;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    for (i = 0U; i < max; ++i) {\n        sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        ++y;\n        ++cb;\n        ++cr;\n        ++r;\n        ++g;\n        ++b;\n    }\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc444_to_rgb() */\n\nstatic void sycc422_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b;\n    const int *y, *cb, *cr;\n    size_t maxw, maxh, max, offx, loopmaxw;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n\n    for (i = 0U; i < maxh; ++i) {\n        size_t j;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n\n        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc422_to_rgb() */\n\nstatic void sycc420_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n    const int *y, *cb, *cr, *ny;\n    size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n    /* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n    offy = img->y0 & 1U;\n    loopmaxh = maxh - offy;\n\n    if (offy > 0U) {\n        size_t j;\n\n        for (j = 0; j < maxw; ++j) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n    }\n\n    for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {\n        size_t j;\n\n        ny = y + maxw;\n        nr = r + maxw;\n        ng = g + maxw;\n        nb = b + maxw;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n        }\n\n        for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        y += maxw;\n        r += maxw;\n        g += maxw;\n        b += maxw;\n    }\n    if (i < loopmaxh) {\n        size_t j;\n\n        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < maxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc420_to_rgb() */\n\nvoid color_sycc_to_rgb(opj_image_t *img)\n{\n    if (img->numcomps < 3) {\n        img->color_space = OPJ_CLRSPC_GRAY;\n        return;\n    }\n\n    if ((img->comps[0].dx == 1)\n            && (img->comps[1].dx == 2)\n            && (img->comps[2].dx == 2)\n            && (img->comps[0].dy == 1)\n            && (img->comps[1].dy == 2)\n            && (img->comps[2].dy == 2)) { /* horizontal and vertical sub-sample */\n        sycc420_to_rgb(img);\n    } else if ((img->comps[0].dx == 1)\n               && (img->comps[1].dx == 2)\n               && (img->comps[2].dx == 2)\n               && (img->comps[0].dy == 1)\n               && (img->comps[1].dy == 1)\n               && (img->comps[2].dy == 1)) { /* horizontal sub-sample only */\n        sycc422_to_rgb(img);\n    } else if ((img->comps[0].dx == 1)\n               && (img->comps[1].dx == 1)\n               && (img->comps[2].dx == 1)\n               && (img->comps[0].dy == 1)\n               && (img->comps[1].dy == 1)\n               && (img->comps[2].dy == 1)) { /* no sub-sample */\n        sycc444_to_rgb(img);\n    } else {\n        fprintf(stderr, \"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n}/* color_sycc_to_rgb() */\n\n#if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)\n\n#ifdef OPJ_HAVE_LIBLCMS1\n/* Bob Friesenhahn proposed:*/\n#define cmsSigXYZData   icSigXYZData\n#define cmsSigLabData   icSigLabData\n#define cmsSigCmykData  icSigCmykData\n#define cmsSigYCbCrData icSigYCbCrData\n#define cmsSigLuvData   icSigLuvData\n#define cmsSigGrayData  icSigGrayData\n#define cmsSigRgbData   icSigRgbData\n#define cmsUInt32Number DWORD\n\n#define cmsColorSpaceSignature icColorSpaceSignature\n#define cmsGetHeaderRenderingIntent cmsTakeRenderingIntent\n\n#endif /* OPJ_HAVE_LIBLCMS1 */\n\n/*#define DEBUG_PROFILE*/\nvoid color_apply_icc_profile(opj_image_t *image)\n{\n    cmsHPROFILE in_prof, out_prof;\n    cmsHTRANSFORM transform;\n    cmsColorSpaceSignature in_space, out_space;\n    cmsUInt32Number intent, in_type, out_type;\n    int *r, *g, *b;\n    size_t nr_samples, i, max, max_w, max_h;\n    int prec, ok = 0;\n    OPJ_COLOR_SPACE new_space;\n\n    in_prof = cmsOpenProfileFromMem(image->icc_profile_buf, image->icc_profile_len);\n#ifdef DEBUG_PROFILE\n    FILE *icm = fopen(\"debug.icm\", \"wb\");\n    fwrite(image->icc_profile_buf, 1, image->icc_profile_len, icm);\n    fclose(icm);\n#endif\n\n    if (in_prof == NULL) {\n        return;\n    }\n\n    in_space = cmsGetPCS(in_prof);\n    out_space = cmsGetColorSpace(in_prof);\n    intent = cmsGetHeaderRenderingIntent(in_prof);\n\n\n    max_w = image->comps[0].w;\n    max_h = image->comps[0].h;\n    prec = (int)image->comps[0].prec;\n\n    if (out_space == cmsSigRgbData) { /* enumCS 16 */\n        unsigned int i, nr_comp = image->numcomps;\n\n        if (nr_comp > 4) {\n            nr_comp = 4;\n        }\n        for (i = 1; i < nr_comp; ++i) { /* AFL test */\n            if (image->comps[0].dx != image->comps[i].dx) {\n                break;\n            }\n\n            if (image->comps[0].dy != image->comps[i].dy) {\n                break;\n            }\n\n            if (image->comps[0].prec != image->comps[i].prec) {\n                break;\n            }\n\n            if (image->comps[0].sgnd != image->comps[i].sgnd) {\n                break;\n            }\n\n        }\n        if (i != nr_comp) {\n            cmsCloseProfile(in_prof);\n            return;\n        }\n\n        if (prec <= 8) {\n            in_type = TYPE_RGB_8;\n            out_type = TYPE_RGB_8;\n        } else {\n            in_type = TYPE_RGB_16;\n            out_type = TYPE_RGB_16;\n        }\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else if (out_space == cmsSigGrayData) { /* enumCS 17 */\n        in_type = TYPE_GRAY_8;\n        out_type = TYPE_RGB_8;\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else if (out_space == cmsSigYCbCrData) { /* enumCS 18 */\n        in_type = TYPE_YCbCr_16;\n        out_type = TYPE_RGB_16;\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else {\n#ifdef DEBUG_PROFILE\n        fprintf(stderr, \"%s:%d: color_apply_icc_profile\\n\\tICC Profile has unknown \"\n                \"output colorspace(%#x)(%c%c%c%c)\\n\\tICC Profile ignored.\\n\",\n                __FILE__, __LINE__, out_space,\n                (out_space >> 24) & 0xff, (out_space >> 16) & 0xff,\n                (out_space >> 8) & 0xff, out_space & 0xff);\n#endif\n        cmsCloseProfile(in_prof);\n\n        return;\n    }\n    if (out_prof == NULL) {\n        cmsCloseProfile(in_prof);\n        return;\n    }\n\n#ifdef DEBUG_PROFILE\n    fprintf(stderr,\n            \"%s:%d:color_apply_icc_profile\\n\\tchannels(%d) prec(%d) w(%d) h(%d)\"\n            \"\\n\\tprofile: in(%p) out(%p)\\n\", __FILE__, __LINE__, image->numcomps, prec,\n            max_w, max_h, (void*)in_prof, (void*)out_prof);\n\n    fprintf(stderr, \"\\trender_intent (%u)\\n\\t\"\n            \"color_space: in(%#x)(%c%c%c%c)   out:(%#x)(%c%c%c%c)\\n\\t\"\n            \"       type: in(%u)              out:(%u)\\n\",\n            intent,\n            in_space,\n            (in_space >> 24) & 0xff, (in_space >> 16) & 0xff,\n            (in_space >> 8) & 0xff, in_space & 0xff,\n\n            out_space,\n            (out_space >> 24) & 0xff, (out_space >> 16) & 0xff,\n            (out_space >> 8) & 0xff, out_space & 0xff,\n\n            in_type, out_type\n           );\n#else\n    (void)prec;\n    (void)in_space;\n#endif /* DEBUG_PROFILE */\n\n    transform = cmsCreateTransform(in_prof, in_type, out_prof, out_type, intent, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n    /* Possible for: LCMS_VERSION >= 2000 :*/\n    cmsCloseProfile(in_prof);\n    cmsCloseProfile(out_prof);\n#endif\n\n    if (transform == NULL) {\n#ifdef DEBUG_PROFILE\n        fprintf(stderr, \"%s:%d:color_apply_icc_profile\\n\\tcmsCreateTransform failed. \"\n                \"ICC Profile ignored.\\n\", __FILE__, __LINE__);\n#endif\n\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in_prof);\n        cmsCloseProfile(out_prof);\n#endif\n        return;\n    }\n\n    if (image->numcomps > 2) { /* RGB, RGBA */\n        if (prec <= 8) {\n            unsigned char *inbuf, *outbuf, *in, *out;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3U * sizeof(unsigned char));\n            in = inbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n\n            if (inbuf == NULL || outbuf == NULL) {\n                goto fails0;\n            }\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0U; i < max; ++i) {\n                *in++ = (unsigned char) * r++;\n                *in++ = (unsigned char) * g++;\n                *in++ = (unsigned char) * b++;\n            }\n\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0U; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            ok = 1;\n\nfails0:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n        } else { /* prec > 8 */\n            unsigned short *inbuf, *outbuf, *in, *out;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3U * sizeof(unsigned short));\n            in = inbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n\n            if (inbuf == NULL || outbuf == NULL) {\n                goto fails1;\n            }\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0U  ; i < max; ++i) {\n                *in++ = (unsigned short) * r++;\n                *in++ = (unsigned short) * g++;\n                *in++ = (unsigned short) * b++;\n            }\n\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            ok = 1;\n\nfails1:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n        }\n    } else { /* image->numcomps <= 2 : GRAY, GRAYA */\n        if (prec <= 8) {\n            unsigned char *in, *inbuf, *out, *outbuf;\n            opj_image_comp_t *new_comps;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n            in = inbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n            g = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n            b = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n\n            if (inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) {\n                goto fails2;\n            }\n\n            new_comps = (opj_image_comp_t*)realloc(image->comps,\n                                                   (image->numcomps + 2) * sizeof(opj_image_comp_t));\n\n            if (new_comps == NULL) {\n                goto fails2;\n            }\n\n            image->comps = new_comps;\n\n            if (image->numcomps == 2) {\n                image->comps[3] = image->comps[1];\n            }\n\n            image->comps[1] = image->comps[0];\n            image->comps[2] = image->comps[0];\n\n            image->comps[1].data = g;\n            image->comps[2].data = b;\n\n            image->numcomps += 2;\n\n            r = image->comps[0].data;\n\n            for (i = 0U; i < max; ++i) {\n                *in++ = (unsigned char) * r++;\n            }\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0U; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            r = g = b = NULL;\n            ok = 1;\n\nfails2:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n            opj_image_data_free(g);\n            opj_image_data_free(b);\n        } else { /* prec > 8 */\n            unsigned short *in, *inbuf, *out, *outbuf;\n            opj_image_comp_t *new_comps;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3U * sizeof(unsigned short));\n            in = inbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n            g = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n            b = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n\n            if (inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) {\n                goto fails3;\n            }\n\n            new_comps = (opj_image_comp_t*)realloc(image->comps,\n                                                   (image->numcomps + 2) * sizeof(opj_image_comp_t));\n\n            if (new_comps == NULL) {\n                goto fails3;\n            }\n\n            image->comps = new_comps;\n\n            if (image->numcomps == 2) {\n                image->comps[3] = image->comps[1];\n            }\n\n            image->comps[1] = image->comps[0];\n            image->comps[2] = image->comps[0];\n\n            image->comps[1].data = g;\n            image->comps[2].data = b;\n\n            image->numcomps += 2;\n\n            r = image->comps[0].data;\n\n            for (i = 0U; i < max; ++i) {\n                *in++ = (unsigned short) * r++;\n            }\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            r = g = b = NULL;\n            ok = 1;\n\nfails3:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n            opj_image_data_free(g);\n            opj_image_data_free(b);\n        }\n    }/* if(image->numcomps > 2) */\n\n    cmsDeleteTransform(transform);\n\n#ifdef OPJ_HAVE_LIBLCMS1\n    cmsCloseProfile(in_prof);\n    cmsCloseProfile(out_prof);\n#endif\n    if (ok) {\n        image->color_space = new_space;\n    }\n}/* color_apply_icc_profile() */\n\nstatic int are_comps_same_dimensions(opj_image_t * image)\n{\n    unsigned int i;\n    for (i = 1; i < image->numcomps; i++) {\n        if (image->comps[0].dx != image->comps[i].dx ||\n                image->comps[0].dy != image->comps[i].dy) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\nvoid color_cielab_to_rgb(opj_image_t *image)\n{\n    int *row;\n    int enumcs, numcomps;\n    OPJ_COLOR_SPACE new_space;\n\n    numcomps = (int)image->numcomps;\n\n    if (numcomps != 3) {\n        fprintf(stderr, \"%s:%d:\\n\\tnumcomps %d not handled. Quitting.\\n\",\n                __FILE__, __LINE__, numcomps);\n        return;\n    }\n    if (!are_comps_same_dimensions(image)) {\n        fprintf(stderr,\n                \"%s:%d:\\n\\tcomponents are not all of the same dimension. Quitting.\\n\",\n                __FILE__, __LINE__);\n        return;\n    }\n\n    row = (int*)image->icc_profile_buf;\n    enumcs = row[0];\n\n    if (enumcs == 14) { /* CIELab */\n        int *L, *a, *b, *red, *green, *blue;\n        int *src0, *src1, *src2, *dst0, *dst1, *dst2;\n        double rl, ol, ra, oa, rb, ob, prec0, prec1, prec2;\n        double minL, maxL, mina, maxa, minb, maxb;\n        unsigned int default_type;\n        unsigned int i, max;\n        cmsHPROFILE in, out;\n        cmsHTRANSFORM transform;\n        cmsUInt16Number RGB[3];\n        cmsCIELab Lab;\n\n        in = cmsCreateLab4Profile(NULL);\n        if (in == NULL) {\n            return;\n        }\n        out = cmsCreate_sRGBProfile();\n        if (out == NULL) {\n            cmsCloseProfile(in);\n            return;\n        }\n        transform = cmsCreateTransform(in, TYPE_Lab_DBL, out, TYPE_RGB_16,\n                                       INTENT_PERCEPTUAL, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        if (transform == NULL) {\n#ifdef OPJ_HAVE_LIBLCMS1\n            cmsCloseProfile(in);\n            cmsCloseProfile(out);\n#endif\n            return;\n        }\n        new_space = OPJ_CLRSPC_SRGB;\n\n        prec0 = (double)image->comps[0].prec;\n        prec1 = (double)image->comps[1].prec;\n        prec2 = (double)image->comps[2].prec;\n\n        default_type = (unsigned int)row[1];\n\n        if (default_type == 0x44454600) { /* DEF : default */\n            rl = 100;\n            ra = 170;\n            rb = 200;\n            ol = 0;\n            oa = pow(2, prec1 - 1);\n            ob = pow(2, prec2 - 2) +  pow(2, prec2 - 3);\n        } else {\n            rl = row[2];\n            ra = row[4];\n            rb = row[6];\n            ol = row[3];\n            oa = row[5];\n            ob = row[7];\n        }\n\n        L = src0 = image->comps[0].data;\n        a = src1 = image->comps[1].data;\n        b = src2 = image->comps[2].data;\n\n        max = image->comps[0].w * image->comps[0].h;\n\n        red = dst0 = (int*)opj_image_data_alloc(max * sizeof(int));\n        green = dst1 = (int*)opj_image_data_alloc(max * sizeof(int));\n        blue = dst2 = (int*)opj_image_data_alloc(max * sizeof(int));\n\n        if (red == NULL || green == NULL || blue == NULL) {\n            goto fails;\n        }\n\n        minL = -(rl * ol) / (pow(2, prec0) - 1);\n        maxL = minL + rl;\n\n        mina = -(ra * oa) / (pow(2, prec1) - 1);\n        maxa = mina + ra;\n\n        minb = -(rb * ob) / (pow(2, prec2) - 1);\n        maxb = minb + rb;\n\n        for (i = 0; i < max; ++i) {\n            Lab.L = minL + (double)(*L) * (maxL - minL) / (pow(2, prec0) - 1);\n            ++L;\n            Lab.a = mina + (double)(*a) * (maxa - mina) / (pow(2, prec1) - 1);\n            ++a;\n            Lab.b = minb + (double)(*b) * (maxb - minb) / (pow(2, prec2) - 1);\n            ++b;\n\n            cmsDoTransform(transform, &Lab, RGB, 1);\n\n            *red++ = RGB[0];\n            *green++ = RGB[1];\n            *blue++ = RGB[2];\n        }\n        cmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        opj_image_data_free(src0);\n        image->comps[0].data = dst0;\n        opj_image_data_free(src1);\n        image->comps[1].data = dst1;\n        opj_image_data_free(src2);\n        image->comps[2].data = dst2;\n\n        image->color_space = new_space;\n        image->comps[0].prec = 16;\n        image->comps[1].prec = 16;\n        image->comps[2].prec = 16;\n\n        return;\n\nfails:\n        cmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        if (red) {\n            opj_image_data_free(red);\n        }\n        if (green) {\n            opj_image_data_free(green);\n        }\n        if (blue) {\n            opj_image_data_free(blue);\n        }\n        return;\n    }\n\n    fprintf(stderr, \"%s:%d:\\n\\tenumCS %d not handled. Ignoring.\\n\", __FILE__,\n            __LINE__, enumcs);\n}/* color_cielab_to_rgb() */\n\n#endif /* OPJ_HAVE_LIBLCMS2 || OPJ_HAVE_LIBLCMS1 */\n\nvoid color_cmyk_to_rgb(opj_image_t *image)\n{\n    float C, M, Y, K;\n    float sC, sM, sY, sK;\n    unsigned int w, h, max, i;\n\n    w = image->comps[0].w;\n    h = image->comps[0].h;\n\n    if (\n        (image->numcomps < 4)\n        || (image->comps[0].dx != image->comps[1].dx) ||\n        (image->comps[0].dx != image->comps[2].dx) ||\n        (image->comps[0].dx != image->comps[3].dx)\n        || (image->comps[0].dy != image->comps[1].dy) ||\n        (image->comps[0].dy != image->comps[2].dy) ||\n        (image->comps[0].dy != image->comps[3].dy)\n    ) {\n        fprintf(stderr, \"%s:%d:color_cmyk_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n\n    max = w * h;\n\n    sC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n    sM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n    sY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n    sK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n    for (i = 0; i < max; ++i) {\n        /* CMYK values from 0 to 1 */\n        C = (float)(image->comps[0].data[i]) * sC;\n        M = (float)(image->comps[1].data[i]) * sM;\n        Y = (float)(image->comps[2].data[i]) * sY;\n        K = (float)(image->comps[3].data[i]) * sK;\n\n        /* Invert all CMYK values */\n        C = 1.0F - C;\n        M = 1.0F - M;\n        Y = 1.0F - Y;\n        K = 1.0F - K;\n\n        /* CMYK -> RGB : RGB results from 0 to 255 */\n        image->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n        image->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n        image->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n    }\n\n    opj_image_data_free(image->comps[3].data);\n    image->comps[3].data = NULL;\n    image->comps[0].prec = 8;\n    image->comps[1].prec = 8;\n    image->comps[2].prec = 8;\n    image->numcomps -= 1;\n    image->color_space = OPJ_CLRSPC_SRGB;\n\n    for (i = 3; i < image->numcomps; ++i) {\n        memcpy(&(image->comps[i]), &(image->comps[i + 1]), sizeof(image->comps[i]));\n    }\n\n}/* color_cmyk_to_rgb() */\n\n/*\n * This code has been adopted from sjpx_openjpeg.c of ghostscript\n */\nvoid color_esycc_to_rgb(opj_image_t *image)\n{\n    int y, cb, cr, sign1, sign2, val;\n    unsigned int w, h, max, i;\n    int flip_value = (1 << (image->comps[0].prec - 1));\n    int max_value = (1 << image->comps[0].prec) - 1;\n\n    if (\n        (image->numcomps < 3)\n        || (image->comps[0].dx != image->comps[1].dx) ||\n        (image->comps[0].dx != image->comps[2].dx)\n        || (image->comps[0].dy != image->comps[1].dy) ||\n        (image->comps[0].dy != image->comps[2].dy)\n    ) {\n        fprintf(stderr, \"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n\n    w = image->comps[0].w;\n    h = image->comps[0].h;\n\n    sign1 = (int)image->comps[1].sgnd;\n    sign2 = (int)image->comps[2].sgnd;\n\n    max = w * h;\n\n    for (i = 0; i < max; ++i) {\n\n        y = image->comps[0].data[i];\n        cb = image->comps[1].data[i];\n        cr = image->comps[2].data[i];\n\n        if (!sign1) {\n            cb -= flip_value;\n        }\n        if (!sign2) {\n            cr -= flip_value;\n        }\n\n        val = (int)\n              ((float)y - (float)0.0000368 * (float)cb\n               + (float)1.40199 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[0].data[i] = val;\n\n        val = (int)\n              ((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n               - (float)0.7141128 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[1].data[i] = val;\n\n        val = (int)\n              ((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n               - (float)0.000008 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[2].data[i] = val;\n    }\n    image->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_esycc_to_rgb() */\n"], "fixing_code": ["/*\n * The copyright in this software is being made available under the 2-clauses\n * BSD License, included below. This software may be subject to other third\n * party and contributor rights, including patent rights, and no such rights\n * are granted under this license.\n *\n * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium\n * Copyright (c) 2002-2014, Professor Benoit Macq\n * Copyright (c) 2001-2003, David Janssens\n * Copyright (c) 2002-2003, Yannick Verschueren\n * Copyright (c) 2003-2007, Francois-Olivier Devaux\n * Copyright (c) 2003-2014, Antonin Descampe\n * Copyright (c) 2005, Herve Drolon, FreeImage Team\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <assert.h>\n\n#include \"opj_apps_config.h\"\n#include \"openjpeg.h\"\n#include \"color.h\"\n\n#ifdef OPJ_HAVE_LIBLCMS2\n#include <lcms2.h>\n#endif\n#ifdef OPJ_HAVE_LIBLCMS1\n#include <lcms.h>\n#endif\n\n#ifdef OPJ_USE_LEGACY\n#define OPJ_CLRSPC_GRAY CLRSPC_GRAY\n#define OPJ_CLRSPC_SRGB CLRSPC_SRGB\n#endif\n\n/*--------------------------------------------------------\nMatrix for sYCC, Amendment 1 to IEC 61966-2-1\n\nY :   0.299   0.587    0.114   :R\nCb:  -0.1687 -0.3312   0.5     :G\nCr:   0.5    -0.4187  -0.0812  :B\n\nInverse:\n\nR: 1        -3.68213e-05    1.40199      :Y\nG: 1.00003  -0.344125      -0.714128     :Cb - 2^(prec - 1)\nB: 0.999823  1.77204       -8.04142e-06  :Cr - 2^(prec - 1)\n\n-----------------------------------------------------------*/\nstatic void sycc_to_rgb(int offset, int upb, int y, int cb, int cr,\n                        int *out_r, int *out_g, int *out_b)\n{\n    int r, g, b;\n\n    cb -= offset;\n    cr -= offset;\n    r = y + (int)(1.402 * (float)cr);\n    if (r < 0) {\n        r = 0;\n    } else if (r > upb) {\n        r = upb;\n    }\n    *out_r = r;\n\n    g = y - (int)(0.344 * (float)cb + 0.714 * (float)cr);\n    if (g < 0) {\n        g = 0;\n    } else if (g > upb) {\n        g = upb;\n    }\n    *out_g = g;\n\n    b = y + (int)(1.772 * (float)cb);\n    if (b < 0) {\n        b = 0;\n    } else if (b > upb) {\n        b = upb;\n    }\n    *out_b = b;\n}\n\nstatic void sycc444_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b;\n    const int *y, *cb, *cr;\n    size_t maxw, maxh, max, i;\n    int offset, upb;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    for (i = 0U; i < max; ++i) {\n        sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        ++y;\n        ++cb;\n        ++cr;\n        ++r;\n        ++g;\n        ++b;\n    }\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc444_to_rgb() */\n\nstatic void sycc422_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b;\n    const int *y, *cb, *cr;\n    size_t maxw, maxh, max, offx, loopmaxw;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n\n    for (i = 0U; i < maxh; ++i) {\n        size_t j;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n\n        for (j = 0U; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc422_to_rgb() */\n\nstatic void sycc420_to_rgb(opj_image_t *img)\n{\n    int *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n    const int *y, *cb, *cr, *ny;\n    size_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n    int offset, upb;\n    size_t i;\n\n    upb = (int)img->comps[0].prec;\n    offset = 1 << (upb - 1);\n    upb = (1 << upb) - 1;\n\n    maxw = (size_t)img->comps[0].w;\n    maxh = (size_t)img->comps[0].h;\n    max = maxw * maxh;\n\n    y = img->comps[0].data;\n    cb = img->comps[1].data;\n    cr = img->comps[2].data;\n\n    d0 = r = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d1 = g = (int*)opj_image_data_alloc(sizeof(int) * max);\n    d2 = b = (int*)opj_image_data_alloc(sizeof(int) * max);\n\n    if (r == NULL || g == NULL || b == NULL) {\n        goto fails;\n    }\n\n    /* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n    offx = img->x0 & 1U;\n    loopmaxw = maxw - offx;\n    /* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n    offy = img->y0 & 1U;\n    loopmaxh = maxh - offy;\n\n    if (offy > 0U) {\n        size_t j;\n\n        for (j = 0; j < maxw; ++j) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n        }\n    }\n\n    for (i = 0U; i < (loopmaxh & ~(size_t)1U); i += 2U) {\n        size_t j;\n\n        ny = y + maxw;\n        nr = r + maxw;\n        ng = g + maxw;\n        nb = b + maxw;\n\n        if (offx > 0U) {\n            sycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n        }\n\n        for (j = 0; j < (loopmaxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        if (j < loopmaxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n            ++ny;\n            ++nr;\n            ++ng;\n            ++nb;\n            ++cb;\n            ++cr;\n        }\n        y += maxw;\n        r += maxw;\n        g += maxw;\n        b += maxw;\n    }\n    if (i < loopmaxh) {\n        size_t j;\n\n        for (j = 0U; j < (maxw & ~(size_t)1U); j += 2U) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n            ++y;\n            ++r;\n            ++g;\n            ++b;\n            ++cb;\n            ++cr;\n        }\n        if (j < maxw) {\n            sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n        }\n    }\n\n    opj_image_data_free(img->comps[0].data);\n    img->comps[0].data = d0;\n    opj_image_data_free(img->comps[1].data);\n    img->comps[1].data = d1;\n    opj_image_data_free(img->comps[2].data);\n    img->comps[2].data = d2;\n\n    img->comps[1].w = img->comps[2].w = img->comps[0].w;\n    img->comps[1].h = img->comps[2].h = img->comps[0].h;\n    img->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n    img->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n    img->color_space = OPJ_CLRSPC_SRGB;\n    return;\n\nfails:\n    opj_image_data_free(r);\n    opj_image_data_free(g);\n    opj_image_data_free(b);\n}/* sycc420_to_rgb() */\n\nvoid color_sycc_to_rgb(opj_image_t *img)\n{\n    if (img->numcomps < 3) {\n        img->color_space = OPJ_CLRSPC_GRAY;\n        return;\n    }\n\n    if ((img->comps[0].dx == 1)\n            && (img->comps[1].dx == 2)\n            && (img->comps[2].dx == 2)\n            && (img->comps[0].dy == 1)\n            && (img->comps[1].dy == 2)\n            && (img->comps[2].dy == 2)) { /* horizontal and vertical sub-sample */\n        sycc420_to_rgb(img);\n    } else if ((img->comps[0].dx == 1)\n               && (img->comps[1].dx == 2)\n               && (img->comps[2].dx == 2)\n               && (img->comps[0].dy == 1)\n               && (img->comps[1].dy == 1)\n               && (img->comps[2].dy == 1)) { /* horizontal sub-sample only */\n        sycc422_to_rgb(img);\n    } else if ((img->comps[0].dx == 1)\n               && (img->comps[1].dx == 1)\n               && (img->comps[2].dx == 1)\n               && (img->comps[0].dy == 1)\n               && (img->comps[1].dy == 1)\n               && (img->comps[2].dy == 1)) { /* no sub-sample */\n        sycc444_to_rgb(img);\n    } else {\n        fprintf(stderr, \"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n}/* color_sycc_to_rgb() */\n\n#if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)\n\n#ifdef OPJ_HAVE_LIBLCMS1\n/* Bob Friesenhahn proposed:*/\n#define cmsSigXYZData   icSigXYZData\n#define cmsSigLabData   icSigLabData\n#define cmsSigCmykData  icSigCmykData\n#define cmsSigYCbCrData icSigYCbCrData\n#define cmsSigLuvData   icSigLuvData\n#define cmsSigGrayData  icSigGrayData\n#define cmsSigRgbData   icSigRgbData\n#define cmsUInt32Number DWORD\n\n#define cmsColorSpaceSignature icColorSpaceSignature\n#define cmsGetHeaderRenderingIntent cmsTakeRenderingIntent\n\n#endif /* OPJ_HAVE_LIBLCMS1 */\n\n/*#define DEBUG_PROFILE*/\nvoid color_apply_icc_profile(opj_image_t *image)\n{\n    cmsHPROFILE in_prof, out_prof;\n    cmsHTRANSFORM transform;\n    cmsColorSpaceSignature in_space, out_space;\n    cmsUInt32Number intent, in_type, out_type;\n    int *r, *g, *b;\n    size_t nr_samples, i, max, max_w, max_h;\n    int prec, ok = 0;\n    OPJ_COLOR_SPACE new_space;\n\n    in_prof = cmsOpenProfileFromMem(image->icc_profile_buf, image->icc_profile_len);\n#ifdef DEBUG_PROFILE\n    FILE *icm = fopen(\"debug.icm\", \"wb\");\n    fwrite(image->icc_profile_buf, 1, image->icc_profile_len, icm);\n    fclose(icm);\n#endif\n\n    if (in_prof == NULL) {\n        return;\n    }\n\n    in_space = cmsGetPCS(in_prof);\n    out_space = cmsGetColorSpace(in_prof);\n    intent = cmsGetHeaderRenderingIntent(in_prof);\n\n\n    max_w = image->comps[0].w;\n    max_h = image->comps[0].h;\n    prec = (int)image->comps[0].prec;\n\n    if (out_space == cmsSigRgbData) { /* enumCS 16 */\n        unsigned int i, nr_comp = image->numcomps;\n\n        if (nr_comp > 4) {\n            nr_comp = 4;\n        }\n        for (i = 1; i < nr_comp; ++i) { /* AFL test */\n            if (image->comps[0].dx != image->comps[i].dx) {\n                break;\n            }\n\n            if (image->comps[0].dy != image->comps[i].dy) {\n                break;\n            }\n\n            if (image->comps[0].prec != image->comps[i].prec) {\n                break;\n            }\n\n            if (image->comps[0].sgnd != image->comps[i].sgnd) {\n                break;\n            }\n\n        }\n        if (i != nr_comp) {\n            cmsCloseProfile(in_prof);\n            return;\n        }\n\n        if (prec <= 8) {\n            in_type = TYPE_RGB_8;\n            out_type = TYPE_RGB_8;\n        } else {\n            in_type = TYPE_RGB_16;\n            out_type = TYPE_RGB_16;\n        }\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else if (out_space == cmsSigGrayData) { /* enumCS 17 */\n        in_type = TYPE_GRAY_8;\n        out_type = TYPE_RGB_8;\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else if (out_space == cmsSigYCbCrData) { /* enumCS 18 */\n        in_type = TYPE_YCbCr_16;\n        out_type = TYPE_RGB_16;\n        out_prof = cmsCreate_sRGBProfile();\n        new_space = OPJ_CLRSPC_SRGB;\n    } else {\n#ifdef DEBUG_PROFILE\n        fprintf(stderr, \"%s:%d: color_apply_icc_profile\\n\\tICC Profile has unknown \"\n                \"output colorspace(%#x)(%c%c%c%c)\\n\\tICC Profile ignored.\\n\",\n                __FILE__, __LINE__, out_space,\n                (out_space >> 24) & 0xff, (out_space >> 16) & 0xff,\n                (out_space >> 8) & 0xff, out_space & 0xff);\n#endif\n        cmsCloseProfile(in_prof);\n\n        return;\n    }\n    if (out_prof == NULL) {\n        cmsCloseProfile(in_prof);\n        return;\n    }\n\n#ifdef DEBUG_PROFILE\n    fprintf(stderr,\n            \"%s:%d:color_apply_icc_profile\\n\\tchannels(%d) prec(%d) w(%d) h(%d)\"\n            \"\\n\\tprofile: in(%p) out(%p)\\n\", __FILE__, __LINE__, image->numcomps, prec,\n            max_w, max_h, (void*)in_prof, (void*)out_prof);\n\n    fprintf(stderr, \"\\trender_intent (%u)\\n\\t\"\n            \"color_space: in(%#x)(%c%c%c%c)   out:(%#x)(%c%c%c%c)\\n\\t\"\n            \"       type: in(%u)              out:(%u)\\n\",\n            intent,\n            in_space,\n            (in_space >> 24) & 0xff, (in_space >> 16) & 0xff,\n            (in_space >> 8) & 0xff, in_space & 0xff,\n\n            out_space,\n            (out_space >> 24) & 0xff, (out_space >> 16) & 0xff,\n            (out_space >> 8) & 0xff, out_space & 0xff,\n\n            in_type, out_type\n           );\n#else\n    (void)prec;\n    (void)in_space;\n#endif /* DEBUG_PROFILE */\n\n    transform = cmsCreateTransform(in_prof, in_type, out_prof, out_type, intent, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n    /* Possible for: LCMS_VERSION >= 2000 :*/\n    cmsCloseProfile(in_prof);\n    cmsCloseProfile(out_prof);\n#endif\n\n    if (transform == NULL) {\n#ifdef DEBUG_PROFILE\n        fprintf(stderr, \"%s:%d:color_apply_icc_profile\\n\\tcmsCreateTransform failed. \"\n                \"ICC Profile ignored.\\n\", __FILE__, __LINE__);\n#endif\n\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in_prof);\n        cmsCloseProfile(out_prof);\n#endif\n        return;\n    }\n\n    if (image->numcomps > 2) { /* RGB, RGBA */\n        if ((image->comps[0].w == image->comps[1].w &&\n                image->comps[0].w == image->comps[2].w) &&\n                (image->comps[0].h == image->comps[1].h &&\n                 image->comps[0].h == image->comps[2].h)) {\n            if (prec <= 8) {\n                unsigned char *inbuf, *outbuf, *in, *out;\n\n                max = max_w * max_h;\n                nr_samples = (size_t)(max * 3U * sizeof(unsigned char));\n                in = inbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n                out = outbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n\n                if (inbuf == NULL || outbuf == NULL) {\n                    goto fails0;\n                }\n\n                r = image->comps[0].data;\n                g = image->comps[1].data;\n                b = image->comps[2].data;\n\n                for (i = 0U; i < max; ++i) {\n                    *in++ = (unsigned char) * r++;\n                    *in++ = (unsigned char) * g++;\n                    *in++ = (unsigned char) * b++;\n                }\n\n                cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n                r = image->comps[0].data;\n                g = image->comps[1].data;\n                b = image->comps[2].data;\n\n                for (i = 0U; i < max; ++i) {\n                    *r++ = (int) * out++;\n                    *g++ = (int) * out++;\n                    *b++ = (int) * out++;\n                }\n                ok = 1;\n\nfails0:\n                opj_image_data_free(inbuf);\n                opj_image_data_free(outbuf);\n            } else { /* prec > 8 */\n                unsigned short *inbuf, *outbuf, *in, *out;\n\n                max = max_w * max_h;\n                nr_samples = (size_t)(max * 3U * sizeof(unsigned short));\n                in = inbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n                out = outbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n\n                if (inbuf == NULL || outbuf == NULL) {\n                    goto fails1;\n                }\n\n                r = image->comps[0].data;\n                g = image->comps[1].data;\n                b = image->comps[2].data;\n\n                for (i = 0U  ; i < max; ++i) {\n                    *in++ = (unsigned short) * r++;\n                    *in++ = (unsigned short) * g++;\n                    *in++ = (unsigned short) * b++;\n                }\n\n                cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n                r = image->comps[0].data;\n                g = image->comps[1].data;\n                b = image->comps[2].data;\n\n                for (i = 0; i < max; ++i) {\n                    *r++ = (int) * out++;\n                    *g++ = (int) * out++;\n                    *b++ = (int) * out++;\n                }\n                ok = 1;\n\nfails1:\n                opj_image_data_free(inbuf);\n                opj_image_data_free(outbuf);\n            }\n        } else {\n            fprintf(stderr,\n                    \"[ERROR] Image components should have the same width and height\\n\");\n            cmsDeleteTransform(transform);\n            return;\n        }\n    } else { /* image->numcomps <= 2 : GRAY, GRAYA */\n        if (prec <= 8) {\n            unsigned char *in, *inbuf, *out, *outbuf;\n            opj_image_comp_t *new_comps;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3 * sizeof(unsigned char));\n            in = inbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned char*)opj_image_data_alloc(nr_samples);\n            g = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n            b = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n\n            if (inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) {\n                goto fails2;\n            }\n\n            new_comps = (opj_image_comp_t*)realloc(image->comps,\n                                                   (image->numcomps + 2) * sizeof(opj_image_comp_t));\n\n            if (new_comps == NULL) {\n                goto fails2;\n            }\n\n            image->comps = new_comps;\n\n            if (image->numcomps == 2) {\n                image->comps[3] = image->comps[1];\n            }\n\n            image->comps[1] = image->comps[0];\n            image->comps[2] = image->comps[0];\n\n            image->comps[1].data = g;\n            image->comps[2].data = b;\n\n            image->numcomps += 2;\n\n            r = image->comps[0].data;\n\n            for (i = 0U; i < max; ++i) {\n                *in++ = (unsigned char) * r++;\n            }\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0U; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            r = g = b = NULL;\n            ok = 1;\n\nfails2:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n            opj_image_data_free(g);\n            opj_image_data_free(b);\n        } else { /* prec > 8 */\n            unsigned short *in, *inbuf, *out, *outbuf;\n            opj_image_comp_t *new_comps;\n\n            max = max_w * max_h;\n            nr_samples = (size_t)(max * 3U * sizeof(unsigned short));\n            in = inbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n            out = outbuf = (unsigned short*)opj_image_data_alloc(nr_samples);\n            g = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n            b = (int*)opj_image_data_alloc((size_t)max * sizeof(int));\n\n            if (inbuf == NULL || outbuf == NULL || g == NULL || b == NULL) {\n                goto fails3;\n            }\n\n            new_comps = (opj_image_comp_t*)realloc(image->comps,\n                                                   (image->numcomps + 2) * sizeof(opj_image_comp_t));\n\n            if (new_comps == NULL) {\n                goto fails3;\n            }\n\n            image->comps = new_comps;\n\n            if (image->numcomps == 2) {\n                image->comps[3] = image->comps[1];\n            }\n\n            image->comps[1] = image->comps[0];\n            image->comps[2] = image->comps[0];\n\n            image->comps[1].data = g;\n            image->comps[2].data = b;\n\n            image->numcomps += 2;\n\n            r = image->comps[0].data;\n\n            for (i = 0U; i < max; ++i) {\n                *in++ = (unsigned short) * r++;\n            }\n            cmsDoTransform(transform, inbuf, outbuf, (cmsUInt32Number)max);\n\n            r = image->comps[0].data;\n            g = image->comps[1].data;\n            b = image->comps[2].data;\n\n            for (i = 0; i < max; ++i) {\n                *r++ = (int) * out++;\n                *g++ = (int) * out++;\n                *b++ = (int) * out++;\n            }\n            r = g = b = NULL;\n            ok = 1;\n\nfails3:\n            opj_image_data_free(inbuf);\n            opj_image_data_free(outbuf);\n            opj_image_data_free(g);\n            opj_image_data_free(b);\n        }\n    }/* if(image->numcomps > 2) */\n\n    cmsDeleteTransform(transform);\n\n#ifdef OPJ_HAVE_LIBLCMS1\n    cmsCloseProfile(in_prof);\n    cmsCloseProfile(out_prof);\n#endif\n    if (ok) {\n        image->color_space = new_space;\n    }\n}/* color_apply_icc_profile() */\n\nstatic int are_comps_same_dimensions(opj_image_t * image)\n{\n    unsigned int i;\n    for (i = 1; i < image->numcomps; i++) {\n        if (image->comps[0].dx != image->comps[i].dx ||\n                image->comps[0].dy != image->comps[i].dy) {\n            return OPJ_FALSE;\n        }\n    }\n    return OPJ_TRUE;\n}\n\nvoid color_cielab_to_rgb(opj_image_t *image)\n{\n    int *row;\n    int enumcs, numcomps;\n    OPJ_COLOR_SPACE new_space;\n\n    numcomps = (int)image->numcomps;\n\n    if (numcomps != 3) {\n        fprintf(stderr, \"%s:%d:\\n\\tnumcomps %d not handled. Quitting.\\n\",\n                __FILE__, __LINE__, numcomps);\n        return;\n    }\n    if (!are_comps_same_dimensions(image)) {\n        fprintf(stderr,\n                \"%s:%d:\\n\\tcomponents are not all of the same dimension. Quitting.\\n\",\n                __FILE__, __LINE__);\n        return;\n    }\n\n    row = (int*)image->icc_profile_buf;\n    enumcs = row[0];\n\n    if (enumcs == 14) { /* CIELab */\n        int *L, *a, *b, *red, *green, *blue;\n        int *src0, *src1, *src2, *dst0, *dst1, *dst2;\n        double rl, ol, ra, oa, rb, ob, prec0, prec1, prec2;\n        double minL, maxL, mina, maxa, minb, maxb;\n        unsigned int default_type;\n        unsigned int i, max;\n        cmsHPROFILE in, out;\n        cmsHTRANSFORM transform;\n        cmsUInt16Number RGB[3];\n        cmsCIELab Lab;\n\n        in = cmsCreateLab4Profile(NULL);\n        if (in == NULL) {\n            return;\n        }\n        out = cmsCreate_sRGBProfile();\n        if (out == NULL) {\n            cmsCloseProfile(in);\n            return;\n        }\n        transform = cmsCreateTransform(in, TYPE_Lab_DBL, out, TYPE_RGB_16,\n                                       INTENT_PERCEPTUAL, 0);\n\n#ifdef OPJ_HAVE_LIBLCMS2\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        if (transform == NULL) {\n#ifdef OPJ_HAVE_LIBLCMS1\n            cmsCloseProfile(in);\n            cmsCloseProfile(out);\n#endif\n            return;\n        }\n        new_space = OPJ_CLRSPC_SRGB;\n\n        prec0 = (double)image->comps[0].prec;\n        prec1 = (double)image->comps[1].prec;\n        prec2 = (double)image->comps[2].prec;\n\n        default_type = (unsigned int)row[1];\n\n        if (default_type == 0x44454600) { /* DEF : default */\n            rl = 100;\n            ra = 170;\n            rb = 200;\n            ol = 0;\n            oa = pow(2, prec1 - 1);\n            ob = pow(2, prec2 - 2) +  pow(2, prec2 - 3);\n        } else {\n            rl = row[2];\n            ra = row[4];\n            rb = row[6];\n            ol = row[3];\n            oa = row[5];\n            ob = row[7];\n        }\n\n        L = src0 = image->comps[0].data;\n        a = src1 = image->comps[1].data;\n        b = src2 = image->comps[2].data;\n\n        max = image->comps[0].w * image->comps[0].h;\n\n        red = dst0 = (int*)opj_image_data_alloc(max * sizeof(int));\n        green = dst1 = (int*)opj_image_data_alloc(max * sizeof(int));\n        blue = dst2 = (int*)opj_image_data_alloc(max * sizeof(int));\n\n        if (red == NULL || green == NULL || blue == NULL) {\n            goto fails;\n        }\n\n        minL = -(rl * ol) / (pow(2, prec0) - 1);\n        maxL = minL + rl;\n\n        mina = -(ra * oa) / (pow(2, prec1) - 1);\n        maxa = mina + ra;\n\n        minb = -(rb * ob) / (pow(2, prec2) - 1);\n        maxb = minb + rb;\n\n        for (i = 0; i < max; ++i) {\n            Lab.L = minL + (double)(*L) * (maxL - minL) / (pow(2, prec0) - 1);\n            ++L;\n            Lab.a = mina + (double)(*a) * (maxa - mina) / (pow(2, prec1) - 1);\n            ++a;\n            Lab.b = minb + (double)(*b) * (maxb - minb) / (pow(2, prec2) - 1);\n            ++b;\n\n            cmsDoTransform(transform, &Lab, RGB, 1);\n\n            *red++ = RGB[0];\n            *green++ = RGB[1];\n            *blue++ = RGB[2];\n        }\n        cmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        opj_image_data_free(src0);\n        image->comps[0].data = dst0;\n        opj_image_data_free(src1);\n        image->comps[1].data = dst1;\n        opj_image_data_free(src2);\n        image->comps[2].data = dst2;\n\n        image->color_space = new_space;\n        image->comps[0].prec = 16;\n        image->comps[1].prec = 16;\n        image->comps[2].prec = 16;\n\n        return;\n\nfails:\n        cmsDeleteTransform(transform);\n#ifdef OPJ_HAVE_LIBLCMS1\n        cmsCloseProfile(in);\n        cmsCloseProfile(out);\n#endif\n        if (red) {\n            opj_image_data_free(red);\n        }\n        if (green) {\n            opj_image_data_free(green);\n        }\n        if (blue) {\n            opj_image_data_free(blue);\n        }\n        return;\n    }\n\n    fprintf(stderr, \"%s:%d:\\n\\tenumCS %d not handled. Ignoring.\\n\", __FILE__,\n            __LINE__, enumcs);\n}/* color_cielab_to_rgb() */\n\n#endif /* OPJ_HAVE_LIBLCMS2 || OPJ_HAVE_LIBLCMS1 */\n\nvoid color_cmyk_to_rgb(opj_image_t *image)\n{\n    float C, M, Y, K;\n    float sC, sM, sY, sK;\n    unsigned int w, h, max, i;\n\n    w = image->comps[0].w;\n    h = image->comps[0].h;\n\n    if (\n        (image->numcomps < 4)\n        || (image->comps[0].dx != image->comps[1].dx) ||\n        (image->comps[0].dx != image->comps[2].dx) ||\n        (image->comps[0].dx != image->comps[3].dx)\n        || (image->comps[0].dy != image->comps[1].dy) ||\n        (image->comps[0].dy != image->comps[2].dy) ||\n        (image->comps[0].dy != image->comps[3].dy)\n    ) {\n        fprintf(stderr, \"%s:%d:color_cmyk_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n\n    max = w * h;\n\n    sC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n    sM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n    sY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n    sK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\n    for (i = 0; i < max; ++i) {\n        /* CMYK values from 0 to 1 */\n        C = (float)(image->comps[0].data[i]) * sC;\n        M = (float)(image->comps[1].data[i]) * sM;\n        Y = (float)(image->comps[2].data[i]) * sY;\n        K = (float)(image->comps[3].data[i]) * sK;\n\n        /* Invert all CMYK values */\n        C = 1.0F - C;\n        M = 1.0F - M;\n        Y = 1.0F - Y;\n        K = 1.0F - K;\n\n        /* CMYK -> RGB : RGB results from 0 to 255 */\n        image->comps[0].data[i] = (int)(255.0F * C * K); /* R */\n        image->comps[1].data[i] = (int)(255.0F * M * K); /* G */\n        image->comps[2].data[i] = (int)(255.0F * Y * K); /* B */\n    }\n\n    opj_image_data_free(image->comps[3].data);\n    image->comps[3].data = NULL;\n    image->comps[0].prec = 8;\n    image->comps[1].prec = 8;\n    image->comps[2].prec = 8;\n    image->numcomps -= 1;\n    image->color_space = OPJ_CLRSPC_SRGB;\n\n    for (i = 3; i < image->numcomps; ++i) {\n        memcpy(&(image->comps[i]), &(image->comps[i + 1]), sizeof(image->comps[i]));\n    }\n\n}/* color_cmyk_to_rgb() */\n\n/*\n * This code has been adopted from sjpx_openjpeg.c of ghostscript\n */\nvoid color_esycc_to_rgb(opj_image_t *image)\n{\n    int y, cb, cr, sign1, sign2, val;\n    unsigned int w, h, max, i;\n    int flip_value = (1 << (image->comps[0].prec - 1));\n    int max_value = (1 << image->comps[0].prec) - 1;\n\n    if (\n        (image->numcomps < 3)\n        || (image->comps[0].dx != image->comps[1].dx) ||\n        (image->comps[0].dx != image->comps[2].dx)\n        || (image->comps[0].dy != image->comps[1].dy) ||\n        (image->comps[0].dy != image->comps[2].dy)\n    ) {\n        fprintf(stderr, \"%s:%d:color_esycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,\n                __LINE__);\n        return;\n    }\n\n    w = image->comps[0].w;\n    h = image->comps[0].h;\n\n    sign1 = (int)image->comps[1].sgnd;\n    sign2 = (int)image->comps[2].sgnd;\n\n    max = w * h;\n\n    for (i = 0; i < max; ++i) {\n\n        y = image->comps[0].data[i];\n        cb = image->comps[1].data[i];\n        cr = image->comps[2].data[i];\n\n        if (!sign1) {\n            cb -= flip_value;\n        }\n        if (!sign2) {\n            cr -= flip_value;\n        }\n\n        val = (int)\n              ((float)y - (float)0.0000368 * (float)cb\n               + (float)1.40199 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[0].data[i] = val;\n\n        val = (int)\n              ((float)1.0003 * (float)y - (float)0.344125 * (float)cb\n               - (float)0.7141128 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[1].data[i] = val;\n\n        val = (int)\n              ((float)0.999823 * (float)y + (float)1.77204 * (float)cb\n               - (float)0.000008 * (float)cr + (float)0.5);\n\n        if (val > max_value) {\n            val = max_value;\n        } else if (val < 0) {\n            val = 0;\n        }\n        image->comps[2].data[i] = val;\n    }\n    image->color_space = OPJ_CLRSPC_SRGB;\n\n}/* color_esycc_to_rgb() */\n"], "filenames": ["src/bin/common/color.c"], "buggy_code_start_loc": [600], "buggy_code_end_loc": [676], "fixing_code_start_loc": [600], "fixing_code_end_loc": [686], "type": "CWE-787", "message": "OpenJPEG before 2.3.1 has a heap buffer overflow in color_apply_icc_profile in bin/common/color.c.", "other": {"cve": {"id": "CVE-2018-21010", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-05T13:15:10.813", "lastModified": "2022-10-29T02:31:56.940", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenJPEG before 2.3.1 has a heap buffer overflow in color_apply_icc_profile in bin/common/color.c."}, {"lang": "es", "value": "OpenJPEG versiones anteriores a 2.3.1, presenta un desbordamiento del b\u00fafer de la pila en la funci\u00f3n color_apply_icc_profile en el archivo bin/common/color.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclouvain:openjpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.1", "matchCriteriaId": "905D827A-8940-45E7-8D0A-487E7755431B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://github.com/uclouvain/openjpeg/commit/2e5ab1d9987831c981ff05862e8ccf1381ed58ea", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202101-29", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uclouvain/openjpeg/commit/2e5ab1d9987831c981ff05862e8ccf1381ed58ea"}}