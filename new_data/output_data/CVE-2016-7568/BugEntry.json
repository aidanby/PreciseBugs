{"buggy_code": ["/**\n * File: WebP IO\n *\n * Read and write WebP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n\n#ifdef HAVE_LIBWEBP\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\n\n#define GD_WEBP_ALLOC_STEP (4*1024)\n\n/*\n  Function: gdImageCreateFromWebp\n\n    <gdImageCreateFromWebp> is called to load truecolor images from\n    WebP format files. Invoke <gdImageCreateFromWebp> with an\n    already opened pointer to a file containing the desired\n    image. <gdImageCreateFromWebp> returns a <gdImagePtr> to the new\n    truecolor image, or NULL if unable to load the image (most often\n    because the file is corrupt or does not contain a WebP\n    image). <gdImageCreateFromWebp> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n    *The returned image is always a truecolor image.*\n\n  Variants:\n\n    <gdImageCreateFromJpegPtr> creates an image from WebP data\n    already in memory.\n\n    <gdImageCreateFromJpegCtx> reads its data via the function\n    pointers in a <gdIOCtx> structure.\n\n  Parameters:\n\n    infile - The input FILE pointer.\n\n  Returns:\n\n    A pointer to the new *truecolor* image.  This will need to be\n    destroyed with <gdImageDestroy> once it is no longer needed.\n\n    On error, returns NULL.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (!in) {\n\t\treturn 0;\n\t}\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromWebpPtr\n\n    See <gdImageCreateFromWebp>.\n\n  Parameters:\n\n    size            - size of WebP data in bytes.\n    data            - pointer to WebP data.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromWebpCtx\n\n    See <gdImageCreateFromWebp>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tint    width, height;\n\tuint8_t   *filedata = NULL;\n\tuint8_t    *argb = NULL;\n\tunsigned char   *read, *temp;\n\tsize_t size = 0, n;\n\tgdImagePtr im;\n\tint x, y;\n\tuint8_t *p;\n\n\tdo {\n\t\ttemp = gdRealloc(filedata, size+GD_WEBP_ALLOC_STEP);\n\t\tif (temp) {\n\t\t\tfiledata = temp;\n\t\t\tread = temp + size;\n\t\t} else {\n\t\t\tif (filedata) {\n\t\t\t\tgdFree(filedata);\n\t\t\t}\n\t\t\tgd_error(\"WebP decode: realloc failed\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tn = gdGetBuf(read, GD_WEBP_ALLOC_STEP, infile);\n\t\tif (n>0 && n!=EOF) {\n\t\t\tsize += n;\n\t\t}\n\t} while (n>0 && n!=EOF);\n\n\tif (WebPGetInfo(filedata,size, &width, &height) == 0) {\n\t\tgd_error(\"gd-webp cannot get webp info\");\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\n\tim = gdImageCreateTrueColor(width, height);\n\tif (!im) {\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\targb = WebPDecodeARGB(filedata, size, &width, &height);\n\tif (!argb) {\n\t\tgd_error(\"gd-webp cannot allocate temporary buffer\");\n\t\tgdFree(temp);\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\tfor (y = 0, p = argb;  y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tregister uint8_t a = gdAlphaMax - (*(p++) >> 1);\n\t\t\tregister uint8_t r = *(p++);\n\t\t\tregister uint8_t g = *(p++);\n\t\t\tregister uint8_t b = *(p++);\n\t\t\tim->tpixels[y][x] = gdTrueColorAlpha(r, g, b, a);\n\t\t}\n\t}\n\t/* do not use gdFree here, in case gdFree/alloc is mapped to something else than libc */\n\tfree(argb);\n\tgdFree(temp);\n\tim->saveAlphaFlag = 1;\n\treturn im;\n}\n\n/*\n  Function: gdImageWebpCtx\n\n    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n    for more details.\n\n  Parameters:\n\n    im      - The image to write.\n    outfile - The output sink.\n    quality - Image quality.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}\n\n/*\n  Function: gdImageWebpEx\n\n    <gdImageWebpEx> outputs the specified image to the specified file in\n    WebP format. The file must be open for writing. Under MSDOS and\n    all versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageWebpEx> does not close the file;\n    your code must do so.\n\n\tIf _quality_ is -1, a reasonable quality value (which should yield a\n\tgood general quality / size tradeoff for most situations) is used. Otherwise\n\t_quality_ should be a value in the range 0-100, higher quality values\n\tusually implying both higher quality and larger image sizes.\n\n  Variants:\n\n    <gdImageWebpCtx> stores the image using a <gdIOCtx> struct.\n\n    <gdImageWebpPtrEx> stores the image to RAM.\n\n  Parameters:\n\n    im      - The image to save.\n    outFile - The FILE pointer to write to.\n    quality - Compression quality (0-100).\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebp\n\n    Variant of <gdImageWebpEx> which uses the default quality (-1).\n\n  Parameters:\n\n    im      - The image to save\n    outFile - The FILE pointer to write to.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebpPtr\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}\n\n/*\n  Function: gdImageWebpPtrEx\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}\n#endif /* HAVE_LIBWEBP */\n"], "fixing_code": ["/**\n * File: WebP IO\n *\n * Read and write WebP images.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif /* HAVE_CONFIG_H */\n\n\n#ifdef HAVE_LIBWEBP\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"gd.h\"\n#include \"gd_errors.h\"\n#include \"gdhelpers.h\"\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\n\n#define GD_WEBP_ALLOC_STEP (4*1024)\n\n/*\n  Function: gdImageCreateFromWebp\n\n    <gdImageCreateFromWebp> is called to load truecolor images from\n    WebP format files. Invoke <gdImageCreateFromWebp> with an\n    already opened pointer to a file containing the desired\n    image. <gdImageCreateFromWebp> returns a <gdImagePtr> to the new\n    truecolor image, or NULL if unable to load the image (most often\n    because the file is corrupt or does not contain a WebP\n    image). <gdImageCreateFromWebp> does not close the file.\n\n    You can inspect the sx and sy members of the image to determine\n    its size. The image must eventually be destroyed using\n    <gdImageDestroy>.\n\n    *The returned image is always a truecolor image.*\n\n  Variants:\n\n    <gdImageCreateFromJpegPtr> creates an image from WebP data\n    already in memory.\n\n    <gdImageCreateFromJpegCtx> reads its data via the function\n    pointers in a <gdIOCtx> structure.\n\n  Parameters:\n\n    infile - The input FILE pointer.\n\n  Returns:\n\n    A pointer to the new *truecolor* image.  This will need to be\n    destroyed with <gdImageDestroy> once it is no longer needed.\n\n    On error, returns NULL.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewFileCtx(inFile);\n\tif (!in) {\n\t\treturn 0;\n\t}\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\n\treturn im;\n}\n\n\n/*\n  Function: gdImageCreateFromWebpPtr\n\n    See <gdImageCreateFromWebp>.\n\n  Parameters:\n\n    size            - size of WebP data in bytes.\n    data            - pointer to WebP data.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n\n/*\n  Function: gdImageCreateFromWebpCtx\n\n    See <gdImageCreateFromWebp>.\n*/\nBGD_DECLARE(gdImagePtr) gdImageCreateFromWebpCtx (gdIOCtx * infile)\n{\n\tint    width, height;\n\tuint8_t   *filedata = NULL;\n\tuint8_t    *argb = NULL;\n\tunsigned char   *read, *temp;\n\tsize_t size = 0, n;\n\tgdImagePtr im;\n\tint x, y;\n\tuint8_t *p;\n\n\tdo {\n\t\ttemp = gdRealloc(filedata, size+GD_WEBP_ALLOC_STEP);\n\t\tif (temp) {\n\t\t\tfiledata = temp;\n\t\t\tread = temp + size;\n\t\t} else {\n\t\t\tif (filedata) {\n\t\t\t\tgdFree(filedata);\n\t\t\t}\n\t\t\tgd_error(\"WebP decode: realloc failed\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tn = gdGetBuf(read, GD_WEBP_ALLOC_STEP, infile);\n\t\tif (n>0 && n!=EOF) {\n\t\t\tsize += n;\n\t\t}\n\t} while (n>0 && n!=EOF);\n\n\tif (WebPGetInfo(filedata,size, &width, &height) == 0) {\n\t\tgd_error(\"gd-webp cannot get webp info\");\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\n\tim = gdImageCreateTrueColor(width, height);\n\tif (!im) {\n\t\tgdFree(temp);\n\t\treturn NULL;\n\t}\n\targb = WebPDecodeARGB(filedata, size, &width, &height);\n\tif (!argb) {\n\t\tgd_error(\"gd-webp cannot allocate temporary buffer\");\n\t\tgdFree(temp);\n\t\tgdImageDestroy(im);\n\t\treturn NULL;\n\t}\n\tfor (y = 0, p = argb;  y < height; y++) {\n\t\tfor (x = 0; x < width; x++) {\n\t\t\tregister uint8_t a = gdAlphaMax - (*(p++) >> 1);\n\t\t\tregister uint8_t r = *(p++);\n\t\t\tregister uint8_t g = *(p++);\n\t\t\tregister uint8_t b = *(p++);\n\t\t\tim->tpixels[y][x] = gdTrueColorAlpha(r, g, b, a);\n\t\t}\n\t}\n\t/* do not use gdFree here, in case gdFree/alloc is mapped to something else than libc */\n\tfree(argb);\n\tgdFree(temp);\n\tim->saveAlphaFlag = 1;\n\treturn im;\n}\n\n/*\n  Function: gdImageWebpCtx\n\n    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>\n    for more details.\n\n  Parameters:\n\n    im      - The image to write.\n    outfile - The output sink.\n    quality - Image quality.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}\n\n/*\n  Function: gdImageWebpEx\n\n    <gdImageWebpEx> outputs the specified image to the specified file in\n    WebP format. The file must be open for writing. Under MSDOS and\n    all versions of Windows, it is important to use \"wb\" as opposed to\n    simply \"w\" as the mode when opening the file, and under Unix there\n    is no penalty for doing so. <gdImageWebpEx> does not close the file;\n    your code must do so.\n\n\tIf _quality_ is -1, a reasonable quality value (which should yield a\n\tgood general quality / size tradeoff for most situations) is used. Otherwise\n\t_quality_ should be a value in the range 0-100, higher quality values\n\tusually implying both higher quality and larger image sizes.\n\n  Variants:\n\n    <gdImageWebpCtx> stores the image using a <gdIOCtx> struct.\n\n    <gdImageWebpPtrEx> stores the image to RAM.\n\n  Parameters:\n\n    im      - The image to save.\n    outFile - The FILE pointer to write to.\n    quality - Compression quality (0-100).\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebp\n\n    Variant of <gdImageWebpEx> which uses the default quality (-1).\n\n  Parameters:\n\n    im      - The image to save\n    outFile - The FILE pointer to write to.\n\n  Returns:\n\n    Nothing.\n*/\nBGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}\n\n/*\n  Function: gdImageWebpPtr\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}\n\n/*\n  Function: gdImageWebpPtrEx\n\n    See <gdImageWebpEx>.\n*/\nBGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}\n#endif /* HAVE_LIBWEBP */\n"], "filenames": ["src/gd_webp.c"], "buggy_code_start_loc": [199], "buggy_code_end_loc": [199], "fixing_code_start_loc": [200], "fixing_code_end_loc": [208], "type": "CWE-190", "message": "Integer overflow in the gdImageWebpCtx function in gd_webp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP through 7.0.11, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted imagewebp and imagedestroy calls.", "other": {"cve": {"id": "CVE-2016-7568", "sourceIdentifier": "cve@mitre.org", "published": "2016-09-28T20:59:02.680", "lastModified": "2019-03-07T20:00:30.977", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the gdImageWebpCtx function in gd_webp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP through 7.0.11, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted imagewebp and imagedestroy calls."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n gdImageWebpCtx en gd_webp.c en la GD Graphics Library (tambi\u00e9n conocido como libgd) hasta la versi\u00f3n 2.2.3, tal como se utiliza en PHP hasta la versi\u00f3n 7.0.11, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desbordamiento de b\u00fafer basado en memoria din\u00e1mica) o tener otro posible impacto no especificado a trav\u00e9s de llamadas imagewebp e imagedestroy manipuladas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgd:libgd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.3", "matchCriteriaId": "E040BCCE-C098-492F-990F-D0196B519B10"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndIncluding": "5.6.26", "matchCriteriaId": "12280608-2E91-4DA1-885B-138369FBFE42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndIncluding": "7.0.11", "matchCriteriaId": "BA49FAED-5BAC-40D4-BCC1-6C734AEDB9DB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3693", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93184", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.php.net/bug.php?id=73003", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/libgd/libgd/commit/40bec0f38f50e8510f5bb71a82f516d46facde03", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgd/libgd/issues/308", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/php/php-src/commit/c18263e0e0769faee96a5d0ee04b750c442783c6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201612-09", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libgd/libgd/commit/40bec0f38f50e8510f5bb71a82f516d46facde03"}}