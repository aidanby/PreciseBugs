{"buggy_code": ["/*-\n * Copyright (c) 2003-2010 Tim Kientzle\n * Copyright (c) 2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#if !defined(_WIN32) || defined(__CYGWIN__)\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif\n#ifdef HAVE_SYS_EXTATTR_H\n#include <sys/extattr.h>\n#endif\n#if defined(HAVE_SYS_XATTR_H)\n#include <sys/xattr.h>\n#elif defined(HAVE_ATTR_XATTR_H)\n#include <attr/xattr.h>\n#endif\n#ifdef HAVE_SYS_EA_H\n#include <sys/ea.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_UTIME_H\n#include <sys/utime.h>\n#endif\n#ifdef HAVE_COPYFILE_H\n#include <copyfile.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n#ifdef HAVE_LINUX_FS_H\n#include <linux/fs.h>\t/* for Linux file flags */\n#endif\n/*\n * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.\n * As the include guards don't agree, the order of include is important.\n */\n#ifdef HAVE_LINUX_EXT2_FS_H\n#include <linux/ext2_fs.h>\t/* for Linux file flags */\n#endif\n#if defined(HAVE_EXT2FS_EXT2_FS_H) && !defined(__CYGWIN__)\n#include <ext2fs/ext2_fs.h>\t/* Linux file flags, broken on Cygwin */\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_UTIME_H\n#include <utime.h>\n#endif\n#ifdef F_GETTIMES /* Tru64 specific */\n#include <sys/fcntl1.h>\n#endif\n\n#if __APPLE__\n#include <TargetConditionals.h>\n#if TARGET_OS_MAC && !TARGET_OS_EMBEDDED && HAVE_QUARANTINE_H\n#include <quarantine.h>\n#define HAVE_QUARANTINE 1\n#endif\n#endif\n\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n/* TODO: Support Mac OS 'quarantine' feature.  This is really just a\n * standard tag to mark files that have been downloaded as \"tainted\".\n * On Mac OS, we should mark the extracted files as tainted if the\n * archive being read was tainted.  Windows has a similar feature; we\n * should investigate ways to support this generically. */\n\n#include \"archive.h\"\n#include \"archive_acl_private.h\"\n#include \"archive_string.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_write_disk_private.h\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC\t0\n#endif\n\nstruct fixup_entry {\n\tstruct fixup_entry\t*next;\n\tstruct archive_acl\t acl;\n\tmode_t\t\t\t mode;\n\tint64_t\t\t\t atime;\n\tint64_t                  birthtime;\n\tint64_t\t\t\t mtime;\n\tint64_t\t\t\t ctime;\n\tunsigned long\t\t atime_nanos;\n\tunsigned long            birthtime_nanos;\n\tunsigned long\t\t mtime_nanos;\n\tunsigned long\t\t ctime_nanos;\n\tunsigned long\t\t fflags_set;\n\tsize_t\t\t\t mac_metadata_size;\n\tvoid\t\t\t*mac_metadata;\n\tint\t\t\t fixup; /* bitmask of what needs fixing */\n\tchar\t\t\t*name;\n};\n\n/*\n * We use a bitmask to track which operations remain to be done for\n * this file.  In particular, this helps us avoid unnecessary\n * operations when it's possible to take care of one step as a\n * side-effect of another.  For example, mkdir() can specify the mode\n * for the newly-created object but symlink() cannot.  This means we\n * can skip chmod() if mkdir() succeeded, but we must explicitly\n * chmod() if we're trying to create a directory that already exists\n * (mkdir() failed) or if we're restoring a symlink.  Similarly, we\n * need to verify UID/GID before trying to restore SUID/SGID bits;\n * that verification can occur explicitly through a stat() call or\n * implicitly because of a successful chown() call.\n */\n#define\tTODO_MODE_FORCE\t\t0x40000000\n#define\tTODO_MODE_BASE\t\t0x20000000\n#define\tTODO_SUID\t\t0x10000000\n#define\tTODO_SUID_CHECK\t\t0x08000000\n#define\tTODO_SGID\t\t0x04000000\n#define\tTODO_SGID_CHECK\t\t0x02000000\n#define\tTODO_APPLEDOUBLE\t0x01000000\n#define\tTODO_MODE\t\t(TODO_MODE_BASE|TODO_SUID|TODO_SGID)\n#define\tTODO_TIMES\t\tARCHIVE_EXTRACT_TIME\n#define\tTODO_OWNER\t\tARCHIVE_EXTRACT_OWNER\n#define\tTODO_FFLAGS\t\tARCHIVE_EXTRACT_FFLAGS\n#define\tTODO_ACLS\t\tARCHIVE_EXTRACT_ACL\n#define\tTODO_XATTR\t\tARCHIVE_EXTRACT_XATTR\n#define\tTODO_MAC_METADATA\tARCHIVE_EXTRACT_MAC_METADATA\n#define\tTODO_HFS_COMPRESSION\tARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED\n\nstruct archive_write_disk {\n\tstruct archive\tarchive;\n\n\tmode_t\t\t\t user_umask;\n\tstruct fixup_entry\t*fixup_list;\n\tstruct fixup_entry\t*current_fixup;\n\tint64_t\t\t\t user_uid;\n\tint\t\t\t skip_file_set;\n\tint64_t\t\t\t skip_file_dev;\n\tint64_t\t\t\t skip_file_ino;\n\ttime_t\t\t\t start_time;\n\n\tint64_t (*lookup_gid)(void *private, const char *gname, int64_t gid);\n\tvoid  (*cleanup_gid)(void *private);\n\tvoid\t\t\t*lookup_gid_data;\n\tint64_t (*lookup_uid)(void *private, const char *uname, int64_t uid);\n\tvoid  (*cleanup_uid)(void *private);\n\tvoid\t\t\t*lookup_uid_data;\n\n\t/*\n\t * Full path of last file to satisfy symlink checks.\n\t */\n\tstruct archive_string\tpath_safe;\n\n\t/*\n\t * Cached stat data from disk for the current entry.\n\t * If this is valid, pst points to st.  Otherwise,\n\t * pst is null.\n\t */\n\tstruct stat\t\t st;\n\tstruct stat\t\t*pst;\n\n\t/* Information about the object being restored right now. */\n\tstruct archive_entry\t*entry; /* Entry being extracted. */\n\tchar\t\t\t*name; /* Name of entry, possibly edited. */\n\tstruct archive_string\t _name_data; /* backing store for 'name' */\n\t/* Tasks remaining for this object. */\n\tint\t\t\t todo;\n\t/* Tasks deferred until end-of-archive. */\n\tint\t\t\t deferred;\n\t/* Options requested by the client. */\n\tint\t\t\t flags;\n\t/* Handle for the file we're restoring. */\n\tint\t\t\t fd;\n\t/* Current offset for writing data to the file. */\n\tint64_t\t\t\t offset;\n\t/* Last offset actually written to disk. */\n\tint64_t\t\t\t fd_offset;\n\t/* Total bytes actually written to files. */\n\tint64_t\t\t\t total_bytes_written;\n\t/* Maximum size of file, -1 if unknown. */\n\tint64_t\t\t\t filesize;\n\t/* Dir we were in before this restore; only for deep paths. */\n\tint\t\t\t restore_pwd;\n\t/* Mode we should use for this entry; affected by _PERM and umask. */\n\tmode_t\t\t\t mode;\n\t/* UID/GID to use in restoring this entry. */\n\tint64_t\t\t\t uid;\n\tint64_t\t\t\t gid;\n\t/*\n\t * HFS+ Compression.\n\t */\n\t/* Xattr \"com.apple.decmpfs\". */\n\tuint32_t\t\t decmpfs_attr_size;\n\tunsigned char\t\t*decmpfs_header_p;\n\t/* ResourceFork set options used for fsetxattr. */\n\tint\t\t\t rsrc_xattr_options;\n\t/* Xattr \"com.apple.ResourceFork\". */\n\tunsigned char\t\t*resource_fork;\n\tsize_t\t\t\t resource_fork_allocated_size;\n\tunsigned int\t\t decmpfs_block_count;\n\tuint32_t\t\t*decmpfs_block_info;\n\t/* Buffer for compressed data. */\n\tunsigned char\t\t*compressed_buffer;\n\tsize_t\t\t\t compressed_buffer_size;\n\tsize_t\t\t\t compressed_buffer_remaining;\n\t/* The offset of the ResourceFork where compressed data will\n\t * be placed. */\n\tuint32_t\t\t compressed_rsrc_position;\n\tuint32_t\t\t compressed_rsrc_position_v;\n\t/* Buffer for uncompressed data. */\n\tchar\t\t\t*uncompressed_buffer;\n\tsize_t\t\t\t block_remaining_bytes;\n\tsize_t\t\t\t file_remaining_bytes;\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n\tint\t\t\t decmpfs_compression_level;\n#endif\n};\n\n/*\n * Default mode for dirs created automatically (will be modified by umask).\n * Note that POSIX specifies 0777 for implicitly-created dirs, \"modified\n * by the process' file creation mask.\"\n */\n#define\tDEFAULT_DIR_MODE 0777\n/*\n * Dir modes are restored in two steps:  During the extraction, the permissions\n * in the archive are modified to match the following limits.  During\n * the post-extract fixup pass, the permissions from the archive are\n * applied.\n */\n#define\tMINIMUM_DIR_MODE 0700\n#define\tMAXIMUM_DIR_MODE 0775\n\n/*\n * Maxinum uncompressed size of a decmpfs block.\n */\n#define MAX_DECMPFS_BLOCK_SIZE\t(64 * 1024)\n/*\n * HFS+ compression type.\n */\n#define CMP_XATTR\t\t3/* Compressed data in xattr. */\n#define CMP_RESOURCE_FORK\t4/* Compressed data in resource fork. */\n/*\n * HFS+ compression resource fork.\n */\n#define RSRC_H_SIZE\t260\t/* Base size of Resource fork header. */\n#define RSRC_F_SIZE\t50\t/* Size of Resource fork footer. */\n/* Size to write compressed data to resource fork. */\n#define COMPRESSED_W_SIZE\t(64 * 1024)\n/* decmpfs difinitions. */\n#define MAX_DECMPFS_XATTR_SIZE\t\t3802\n#ifndef DECMPFS_XATTR_NAME\n#define DECMPFS_XATTR_NAME\t\t\"com.apple.decmpfs\"\n#endif\n#define DECMPFS_MAGIC\t\t\t0x636d7066\n#define DECMPFS_COMPRESSION_MAGIC\t0\n#define DECMPFS_COMPRESSION_TYPE\t4\n#define DECMPFS_UNCOMPRESSED_SIZE\t8\n#define DECMPFS_HEADER_SIZE\t\t16\n\n#define HFS_BLOCKS(s)\t((s) >> 12)\n\nstatic int\tcheck_symlinks(struct archive_write_disk *);\nstatic int\tcreate_filesystem_object(struct archive_write_disk *);\nstatic struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\nstatic void\tedit_deep_directories(struct archive_write_disk *ad);\n#endif\nstatic int\tcleanup_pathname(struct archive_write_disk *);\nstatic int\tcreate_dir(struct archive_write_disk *, char *);\nstatic int\tcreate_parent_dir(struct archive_write_disk *, char *);\nstatic ssize_t\thfs_write_data_block(struct archive_write_disk *,\n\t\t    const char *, size_t);\nstatic int\tfixup_appledouble(struct archive_write_disk *, const char *);\nstatic int\tolder(struct stat *, struct archive_entry *);\nstatic int\trestore_entry(struct archive_write_disk *);\nstatic int\tset_mac_metadata(struct archive_write_disk *, const char *,\n\t\t\t\t const void *, size_t);\nstatic int\tset_xattrs(struct archive_write_disk *);\nstatic int\tclear_nochange_fflags(struct archive_write_disk *);\nstatic int\tset_fflags(struct archive_write_disk *);\nstatic int\tset_fflags_platform(struct archive_write_disk *, int fd,\n\t\t    const char *name, mode_t mode,\n\t\t    unsigned long fflags_set, unsigned long fflags_clear);\nstatic int\tset_ownership(struct archive_write_disk *);\nstatic int\tset_mode(struct archive_write_disk *, int mode);\nstatic int\tset_time(int, int, const char *, time_t, long, time_t, long);\nstatic int\tset_times(struct archive_write_disk *, int, int, const char *,\n\t\t    time_t, long, time_t, long, time_t, long, time_t, long);\nstatic int\tset_times_from_entry(struct archive_write_disk *);\nstatic struct fixup_entry *sort_dir_list(struct fixup_entry *p);\nstatic ssize_t\twrite_data_block(struct archive_write_disk *,\n\t\t    const char *, size_t);\n\nstatic struct archive_vtable *archive_write_disk_vtable(void);\n\nstatic int\t_archive_write_disk_close(struct archive *);\nstatic int\t_archive_write_disk_free(struct archive *);\nstatic int\t_archive_write_disk_header(struct archive *, struct archive_entry *);\nstatic int64_t\t_archive_write_disk_filter_bytes(struct archive *, int);\nstatic int\t_archive_write_disk_finish_entry(struct archive *);\nstatic ssize_t\t_archive_write_disk_data(struct archive *, const void *, size_t);\nstatic ssize_t\t_archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);\n\nstatic int\nlazy_stat(struct archive_write_disk *a)\n{\n\tif (a->pst != NULL) {\n\t\t/* Already have stat() data available. */\n\t\treturn (ARCHIVE_OK);\n\t}\n#ifdef HAVE_FSTAT\n\tif (a->fd >= 0 && fstat(a->fd, &a->st) == 0) {\n\t\ta->pst = &a->st;\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\t/*\n\t * XXX At this point, symlinks should not be hit, otherwise\n\t * XXX a race occurred.  Do we want to check explicitly for that?\n\t */\n\tif (lstat(a->name, &a->st) == 0) {\n\t\ta->pst = &a->st;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tarchive_set_error(&a->archive, errno, \"Couldn't stat file\");\n\treturn (ARCHIVE_WARN);\n}\n\nstatic struct archive_vtable *\narchive_write_disk_vtable(void)\n{\n\tstatic struct archive_vtable av;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tav.archive_close = _archive_write_disk_close;\n\t\tav.archive_filter_bytes = _archive_write_disk_filter_bytes;\n\t\tav.archive_free = _archive_write_disk_free;\n\t\tav.archive_write_header = _archive_write_disk_header;\n\t\tav.archive_write_finish_entry\n\t\t    = _archive_write_disk_finish_entry;\n\t\tav.archive_write_data = _archive_write_disk_data;\n\t\tav.archive_write_data_block = _archive_write_disk_data_block;\n\t\tinited = 1;\n\t}\n\treturn (&av);\n}\n\nstatic int64_t\n_archive_write_disk_filter_bytes(struct archive *_a, int n)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\t(void)n; /* UNUSED */\n\tif (n == -1 || n == 0)\n\t\treturn (a->total_bytes_written);\n\treturn (-1);\n}\n\n\nint\narchive_write_disk_set_options(struct archive *_a, int flags)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\n\ta->flags = flags;\n\treturn (ARCHIVE_OK);\n}\n\n\n/*\n * Extract this entry to disk.\n *\n * TODO: Validate hardlinks.  According to the standards, we're\n * supposed to check each extracted hardlink and squawk if it refers\n * to a file that we didn't restore.  I'm not entirely convinced this\n * is a good idea, but more importantly: Is there any way to validate\n * hardlinks without keeping a complete list of filenames from the\n * entire archive?? Ugh.\n *\n */\nstatic int\n_archive_write_disk_header(struct archive *_a, struct archive_entry *entry)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *fe;\n\tint ret, r;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_header\");\n\tarchive_clear_error(&a->archive);\n\tif (a->archive.state & ARCHIVE_STATE_DATA) {\n\t\tr = _archive_write_disk_finish_entry(&a->archive);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t}\n\n\t/* Set up for this particular entry. */\n\ta->pst = NULL;\n\ta->current_fixup = NULL;\n\ta->deferred = 0;\n\tif (a->entry) {\n\t\tarchive_entry_free(a->entry);\n\t\ta->entry = NULL;\n\t}\n\ta->entry = archive_entry_clone(entry);\n\ta->fd = -1;\n\ta->fd_offset = 0;\n\ta->offset = 0;\n\ta->restore_pwd = -1;\n\ta->uid = a->user_uid;\n\ta->mode = archive_entry_mode(a->entry);\n\tif (archive_entry_size_is_set(a->entry))\n\t\ta->filesize = archive_entry_size(a->entry);\n\telse\n\t\ta->filesize = -1;\n\tarchive_strcpy(&(a->_name_data), archive_entry_pathname(a->entry));\n\ta->name = a->_name_data.s;\n\tarchive_clear_error(&a->archive);\n\n\t/*\n\t * Clean up the requested path.  This is necessary for correct\n\t * dir restores; the dir restore logic otherwise gets messed\n\t * up by nonsense like \"dir/.\".\n\t */\n\tret = cleanup_pathname(a);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\t/*\n\t * Query the umask so we get predictable mode settings.\n\t * This gets done on every call to _write_header in case the\n\t * user edits their umask during the extraction for some\n\t * reason.\n\t */\n\tumask(a->user_umask = umask(0));\n\n\t/* Figure out what we need to do for this entry. */\n\ta->todo = TODO_MODE_BASE;\n\tif (a->flags & ARCHIVE_EXTRACT_PERM) {\n\t\ta->todo |= TODO_MODE_FORCE; /* Be pushy about permissions. */\n\t\t/*\n\t\t * SGID requires an extra \"check\" step because we\n\t\t * cannot easily predict the GID that the system will\n\t\t * assign.  (Different systems assign GIDs to files\n\t\t * based on a variety of criteria, including process\n\t\t * credentials and the gid of the enclosing\n\t\t * directory.)  We can only restore the SGID bit if\n\t\t * the file has the right GID, and we only know the\n\t\t * GID if we either set it (see set_ownership) or if\n\t\t * we've actually called stat() on the file after it\n\t\t * was restored.  Since there are several places at\n\t\t * which we might verify the GID, we need a TODO bit\n\t\t * to keep track.\n\t\t */\n\t\tif (a->mode & S_ISGID)\n\t\t\ta->todo |= TODO_SGID | TODO_SGID_CHECK;\n\t\t/*\n\t\t * Verifying the SUID is simpler, but can still be\n\t\t * done in multiple ways, hence the separate \"check\" bit.\n\t\t */\n\t\tif (a->mode & S_ISUID)\n\t\t\ta->todo |= TODO_SUID | TODO_SUID_CHECK;\n\t} else {\n\t\t/*\n\t\t * User didn't request full permissions, so don't\n\t\t * restore SUID, SGID bits and obey umask.\n\t\t */\n\t\ta->mode &= ~S_ISUID;\n\t\ta->mode &= ~S_ISGID;\n\t\ta->mode &= ~S_ISVTX;\n\t\ta->mode &= ~a->user_umask;\n\t}\n\tif (a->flags & ARCHIVE_EXTRACT_OWNER)\n\t\ta->todo |= TODO_OWNER;\n\tif (a->flags & ARCHIVE_EXTRACT_TIME)\n\t\ta->todo |= TODO_TIMES;\n\tif (a->flags & ARCHIVE_EXTRACT_ACL) {\n\t\tif (archive_entry_filetype(a->entry) == AE_IFDIR)\n\t\t\ta->deferred |= TODO_ACLS;\n\t\telse\n\t\t\ta->todo |= TODO_ACLS;\n\t}\n\tif (a->flags & ARCHIVE_EXTRACT_MAC_METADATA) {\n\t\tif (archive_entry_filetype(a->entry) == AE_IFDIR)\n\t\t\ta->deferred |= TODO_MAC_METADATA;\n\t\telse\n\t\t\ta->todo |= TODO_MAC_METADATA;\n\t}\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\tif ((a->flags & ARCHIVE_EXTRACT_NO_HFS_COMPRESSION) == 0) {\n\t\tunsigned long set, clear;\n\t\tarchive_entry_fflags(a->entry, &set, &clear);\n\t\tif ((set & ~clear) & UF_COMPRESSED) {\n\t\t\ta->todo |= TODO_HFS_COMPRESSION;\n\t\t\ta->decmpfs_block_count = (unsigned)-1;\n\t\t}\n\t}\n\tif ((a->flags & ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED) != 0 &&\n\t    (a->mode & AE_IFMT) == AE_IFREG && a->filesize > 0) {\n\t\ta->todo |= TODO_HFS_COMPRESSION;\n\t\ta->decmpfs_block_count = (unsigned)-1;\n\t}\n\t{\n\t\tconst char *p;\n\n\t\t/* Check if the current file name is a type of the\n\t\t * resource fork file. */\n\t\tp = strrchr(a->name, '/');\n\t\tif (p == NULL)\n\t\t\tp = a->name;\n\t\telse\n\t\t\tp++;\n\t\tif (p[0] == '.' && p[1] == '_') {\n\t\t\t/* Do not compress \"._XXX\" files. */\n\t\t\ta->todo &= ~TODO_HFS_COMPRESSION;\n\t\t\tif (a->filesize > 0)\n\t\t\t\ta->todo |= TODO_APPLEDOUBLE;\n\t\t}\n\t}\n#endif\n\n\tif (a->flags & ARCHIVE_EXTRACT_XATTR)\n\t\ta->todo |= TODO_XATTR;\n\tif (a->flags & ARCHIVE_EXTRACT_FFLAGS)\n\t\ta->todo |= TODO_FFLAGS;\n\tif (a->flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS) {\n\t\tret = check_symlinks(a);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n\t/* If path exceeds PATH_MAX, shorten the path. */\n\tedit_deep_directories(a);\n#endif\n\n\tret = restore_entry(a);\n\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\t/*\n\t * Check if the filesystem the file is restoring on supports\n\t * HFS+ Compression. If not, cancel HFS+ Compression.\n\t */\n\tif (a->todo | TODO_HFS_COMPRESSION) {\n\t\t/*\n\t\t * NOTE: UF_COMPRESSED is ignored even if the filesystem\n\t\t * supports HFS+ Compression because the file should\n\t\t * have at least an extended attriute \"com.apple.decmpfs\"\n\t\t * before the flag is set to indicate that the file have\n\t\t * been compressed. If hte filesystem does not support\n\t\t * HFS+ Compression the system call will fail.\n\t\t */\n\t\tif (a->fd < 0 || fchflags(a->fd, UF_COMPRESSED) != 0)\n\t\t\ta->todo &= ~TODO_HFS_COMPRESSION;\n\t}\n#endif\n\n\t/*\n\t * TODO: There are rumours that some extended attributes must\n\t * be restored before file data is written.  If this is true,\n\t * then we either need to write all extended attributes both\n\t * before and after restoring the data, or find some rule for\n\t * determining which must go first and which last.  Due to the\n\t * many ways people are using xattrs, this may prove to be an\n\t * intractable problem.\n\t */\n\n#ifdef HAVE_FCHDIR\n\t/* If we changed directory above, restore it here. */\n\tif (a->restore_pwd >= 0) {\n\t\tr = fchdir(a->restore_pwd);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, errno, \"chdir() failure\");\n\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\tclose(a->restore_pwd);\n\t\ta->restore_pwd = -1;\n\t}\n#endif\n\n\t/*\n\t * Fixup uses the unedited pathname from archive_entry_pathname(),\n\t * because it is relative to the base dir and the edited path\n\t * might be relative to some intermediate dir as a result of the\n\t * deep restore logic.\n\t */\n\tif (a->deferred & TODO_MODE) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_MODE_BASE;\n\t\tfe->mode = a->mode;\n\t}\n\n\tif ((a->deferred & TODO_TIMES)\n\t\t&& (archive_entry_mtime_is_set(entry)\n\t\t    || archive_entry_atime_is_set(entry))) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->mode = a->mode;\n\t\tfe->fixup |= TODO_TIMES;\n\t\tif (archive_entry_atime_is_set(entry)) {\n\t\t\tfe->atime = archive_entry_atime(entry);\n\t\t\tfe->atime_nanos = archive_entry_atime_nsec(entry);\n\t\t} else {\n\t\t\t/* If atime is unset, use start time. */\n\t\t\tfe->atime = a->start_time;\n\t\t\tfe->atime_nanos = 0;\n\t\t}\n\t\tif (archive_entry_mtime_is_set(entry)) {\n\t\t\tfe->mtime = archive_entry_mtime(entry);\n\t\t\tfe->mtime_nanos = archive_entry_mtime_nsec(entry);\n\t\t} else {\n\t\t\t/* If mtime is unset, use start time. */\n\t\t\tfe->mtime = a->start_time;\n\t\t\tfe->mtime_nanos = 0;\n\t\t}\n\t\tif (archive_entry_birthtime_is_set(entry)) {\n\t\t\tfe->birthtime = archive_entry_birthtime(entry);\n\t\t\tfe->birthtime_nanos = archive_entry_birthtime_nsec(entry);\n\t\t} else {\n\t\t\t/* If birthtime is unset, use mtime. */\n\t\t\tfe->birthtime = fe->mtime;\n\t\t\tfe->birthtime_nanos = fe->mtime_nanos;\n\t\t}\n\t}\n\n\tif (a->deferred & TODO_ACLS) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_ACLS;\n\t\tarchive_acl_copy(&fe->acl, archive_entry_acl(entry));\n\t}\n\n\tif (a->deferred & TODO_MAC_METADATA) {\n\t\tconst void *metadata;\n\t\tsize_t metadata_size;\n\t\tmetadata = archive_entry_mac_metadata(a->entry, &metadata_size);\n\t\tif (metadata != NULL && metadata_size > 0) {\n\t\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\t\tif (fe == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tfe->mac_metadata = malloc(metadata_size);\n\t\t\tif (fe->mac_metadata != NULL) {\n\t\t\t\tmemcpy(fe->mac_metadata, metadata, metadata_size);\n\t\t\t\tfe->mac_metadata_size = metadata_size;\n\t\t\t\tfe->fixup |= TODO_MAC_METADATA;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a->deferred & TODO_FFLAGS) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_FFLAGS;\n\t\t/* TODO: Complete this.. defer fflags from below. */\n\t}\n\n\t/* We've created the object and are ready to pour data into it. */\n\tif (ret >= ARCHIVE_WARN)\n\t\ta->archive.state = ARCHIVE_STATE_DATA;\n\t/*\n\t * If it's not open, tell our client not to try writing.\n\t * In particular, dirs, links, etc, don't get written to.\n\t */\n\tif (a->fd < 0) {\n\t\tarchive_entry_set_size(entry, 0);\n\t\ta->filesize = 0;\n\t}\n\n\treturn (ret);\n}\n\nint\narchive_write_disk_set_skip_file(struct archive *_a, int64_t d, int64_t i)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_skip_file\");\n\ta->skip_file_set = 1;\n\ta->skip_file_dev = d;\n\ta->skip_file_ino = i;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nwrite_data_block(struct archive_write_disk *a, const char *buff, size_t size)\n{\n\tuint64_t start_size = size;\n\tssize_t bytes_written = 0;\n\tssize_t block_size = 0, bytes_to_write;\n\n\tif (size == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (a->filesize == 0 || a->fd < 0) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Attempt to write to an empty file\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tif (a->flags & ARCHIVE_EXTRACT_SPARSE) {\n#if HAVE_STRUCT_STAT_ST_BLKSIZE\n\t\tint r;\n\t\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tblock_size = a->pst->st_blksize;\n#else\n\t\t/* XXX TODO XXX Is there a more appropriate choice here ? */\n\t\t/* This needn't match the filesystem allocation size. */\n\t\tblock_size = 16*1024;\n#endif\n\t}\n\n\t/* If this write would run beyond the file size, truncate it. */\n\tif (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)\n\t\tstart_size = size = (size_t)(a->filesize - a->offset);\n\n\t/* Write the data. */\n\twhile (size > 0) {\n\t\tif (block_size == 0) {\n\t\t\tbytes_to_write = size;\n\t\t} else {\n\t\t\t/* We're sparsifying the file. */\n\t\t\tconst char *p, *end;\n\t\t\tint64_t block_end;\n\n\t\t\t/* Skip leading zero bytes. */\n\t\t\tfor (p = buff, end = buff + size; p < end; ++p) {\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta->offset += p - buff;\n\t\t\tsize -= p - buff;\n\t\t\tbuff = p;\n\t\t\tif (size == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* Calculate next block boundary after offset. */\n\t\t\tblock_end\n\t\t\t    = (a->offset / block_size + 1) * block_size;\n\n\t\t\t/* If the adjusted write would cross block boundary,\n\t\t\t * truncate it to the block boundary. */\n\t\t\tbytes_to_write = size;\n\t\t\tif (a->offset + bytes_to_write > block_end)\n\t\t\t\tbytes_to_write = block_end - a->offset;\n\t\t}\n\t\t/* Seek if necessary to the specified offset. */\n\t\tif (a->offset != a->fd_offset) {\n\t\t\tif (lseek(a->fd, a->offset, SEEK_SET) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Seek failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->fd_offset = a->offset;\n\t\t}\n\t\tbytes_written = write(a->fd, buff, bytes_to_write);\n\t\tif (bytes_written < 0) {\n\t\t\tarchive_set_error(&a->archive, errno, \"Write failed\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbuff += bytes_written;\n\t\tsize -= bytes_written;\n\t\ta->total_bytes_written += bytes_written;\n\t\ta->offset += bytes_written;\n\t\ta->fd_offset = a->offset;\n\t}\n\treturn (start_size - size);\n}\n\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\\\n\t&& defined(HAVE_ZLIB_H)\n\n/*\n * Set UF_COMPRESSED file flag.\n * This have to be called after hfs_write_decmpfs() because if the\n * file does not have \"com.apple.decmpfs\" xattr the flag is ignored.\n */\nstatic int\nhfs_set_compressed_fflag(struct archive_write_disk *a)\n{\n\tint r;\n\n\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\treturn (r);\n\n\ta->st.st_flags |= UF_COMPRESSED;\n\tif (fchflags(a->fd, a->st.st_flags) != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to set UF_COMPRESSED file flag\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * HFS+ Compression decmpfs\n *\n *     +------------------------------+ +0\n *     |      Magic(LE 4 bytes)       |\n *     +------------------------------+\n *     |      Type(LE 4 bytes)        |\n *     +------------------------------+\n *     | Uncompressed size(LE 8 bytes)|\n *     +------------------------------+ +16\n *     |                              |\n *     |       Compressed data        |\n *     |  (Placed only if Type == 3)  |\n *     |                              |\n *     +------------------------------+  +3802 = MAX_DECMPFS_XATTR_SIZE\n *\n *  Type is 3: decmpfs has compressed data.\n *  Type is 4: Resource Fork has compressed data.\n */\n/*\n * Write \"com.apple.decmpfs\"\n */\nstatic int\nhfs_write_decmpfs(struct archive_write_disk *a)\n{\n\tint r;\n\tuint32_t compression_type;\n\n\tr = fsetxattr(a->fd, DECMPFS_XATTR_NAME, a->decmpfs_header_p,\n\t    a->decmpfs_attr_size, 0, 0);\n\tif (r < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Cannot restore xattr:%s\", DECMPFS_XATTR_NAME);\n\t\tcompression_type = archive_le32dec(\n\t\t    &a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE]);\n\t\tif (compression_type == CMP_RESOURCE_FORK)\n\t\t\tfremovexattr(a->fd, XATTR_RESOURCEFORK_NAME,\n\t\t\t    XATTR_SHOWCOMPRESSION);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * HFS+ Compression Resource Fork\n *\n *     +-----------------------------+\n *     |     Header(260 bytes)       |\n *     +-----------------------------+\n *     |   Block count(LE 4 bytes)   |\n *     +-----------------------------+  --+\n * +-- |     Offset (LE 4 bytes)     |    |\n * |   | [distance from Block count] |    | Block 0\n * |   +-----------------------------+    |\n * |   | Compressed size(LE 4 bytes) |    |\n * |   +-----------------------------+  --+\n * |   |                             |\n * |   |      ..................     |\n * |   |                             |\n * |   +-----------------------------+  --+\n * |   |     Offset (LE 4 bytes)     |    |\n * |   +-----------------------------+    | Block (Block count -1)\n * |   | Compressed size(LE 4 bytes) |    |\n * +-> +-----------------------------+  --+\n *     |   Compressed data(n bytes)  |  Block 0\n *     +-----------------------------+\n *     |                             |\n *     |      ..................     |\n *     |                             |\n *     +-----------------------------+\n *     |   Compressed data(n bytes)  |  Block (Block count -1)\n *     +-----------------------------+\n *     |      Footer(50 bytes)       |\n *     +-----------------------------+\n *\n */\n/*\n * Write the header of \"com.apple.ResourceFork\"\n */\nstatic int\nhfs_write_resource_fork(struct archive_write_disk *a, unsigned char *buff,\n    size_t bytes, uint32_t position)\n{\n\tint ret;\n\n\tret = fsetxattr(a->fd, XATTR_RESOURCEFORK_NAME, buff, bytes,\n\t    position, a->rsrc_xattr_options);\n\tif (ret < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Cannot restore xattr: %s at %u pos %u bytes\",\n\t\t    XATTR_RESOURCEFORK_NAME,\n\t\t    (unsigned)position,\n\t\t    (unsigned)bytes);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\ta->rsrc_xattr_options &= ~XATTR_CREATE;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_write_compressed_data(struct archive_write_disk *a, size_t bytes_compressed)\n{\n\tint ret;\n\n\tret = hfs_write_resource_fork(a, a->compressed_buffer,\n\t    bytes_compressed, a->compressed_rsrc_position);\n\tif (ret == ARCHIVE_OK)\n\t\ta->compressed_rsrc_position += bytes_compressed;\n\treturn (ret);\n}\n\nstatic int\nhfs_write_resource_fork_header(struct archive_write_disk *a)\n{\n\tunsigned char *buff;\n\tuint32_t rsrc_bytes;\n\tuint32_t rsrc_header_bytes;\n\n\t/*\n\t * Write resource fork header + block info.\n\t */\n\tbuff = a->resource_fork;\n\trsrc_bytes = a->compressed_rsrc_position - RSRC_F_SIZE;\n\trsrc_header_bytes =\n\t\tRSRC_H_SIZE +\t\t/* Header base size. */\n\t\t4 +\t\t\t/* Block count. */\n\t\t(a->decmpfs_block_count * 8);/* Block info */\n\tarchive_be32enc(buff, 0x100);\n\tarchive_be32enc(buff + 4, rsrc_bytes);\n\tarchive_be32enc(buff + 8, rsrc_bytes - 256);\n\tarchive_be32enc(buff + 12, 0x32);\n\tmemset(buff + 16, 0, 240);\n\tarchive_be32enc(buff + 256, rsrc_bytes - 260);\n\treturn hfs_write_resource_fork(a, buff, rsrc_header_bytes, 0);\n}\n\nstatic size_t\nhfs_set_resource_fork_footer(unsigned char *buff, size_t buff_size)\n{\n\tstatic const char rsrc_footer[RSRC_F_SIZE] = {\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 'c',  'm',\n\t\t'p', 'f',   0x00, 0x00, 0x00, 0x0a, 0x00, 0x01,\n\t\t0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00\n\t};\n\tif (buff_size < sizeof(rsrc_footer))\n\t\treturn (0);\n\tmemcpy(buff, rsrc_footer, sizeof(rsrc_footer));\n\treturn (sizeof(rsrc_footer));\n}\n\nstatic int\nhfs_reset_compressor(struct archive_write_disk *a)\n{\n\tint ret;\n\n\tif (a->stream_valid)\n\t\tret = deflateReset(&a->stream);\n\telse\n\t\tret = deflateInit(&a->stream, a->decmpfs_compression_level);\n\n\tif (ret != Z_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to initialize compressor\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else\n\t\ta->stream_valid = 1;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_decompress(struct archive_write_disk *a)\n{\n\tuint32_t *block_info;\n\tunsigned int block_count;\n\tuint32_t data_pos, data_size;\n\tssize_t r;\n\tssize_t bytes_written, bytes_to_write;\n\tunsigned char *b;\n\n\tblock_info = (uint32_t *)(a->resource_fork + RSRC_H_SIZE);\n\tblock_count = archive_le32dec(block_info++);\n\twhile (block_count--) {\n\t\tdata_pos = RSRC_H_SIZE + archive_le32dec(block_info++);\n\t\tdata_size = archive_le32dec(block_info++);\n\t\tr = fgetxattr(a->fd, XATTR_RESOURCEFORK_NAME,\n\t\t    a->compressed_buffer, data_size, data_pos, 0);\n\t\tif (r != data_size)  {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    (r < 0)?errno:ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read resource fork\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tif (a->compressed_buffer[0] == 0xff) {\n\t\t\tbytes_to_write = data_size -1;\n\t\t\tb = a->compressed_buffer + 1;\n\t\t} else {\n\t\t\tuLong dest_len = MAX_DECMPFS_BLOCK_SIZE;\n\t\t\tint zr;\n\n\t\t\tzr = uncompress((Bytef *)a->uncompressed_buffer,\n\t\t\t    &dest_len, a->compressed_buffer, data_size);\n\t\t\tif (zr != Z_OK) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to decompress resource fork\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tbytes_to_write = dest_len;\n\t\t\tb = (unsigned char *)a->uncompressed_buffer;\n\t\t}\n\t\tdo {\n\t\t\tbytes_written = write(a->fd, b, bytes_to_write);\n\t\t\tif (bytes_written < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Write failed\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tbytes_to_write -= bytes_written;\n\t\t\tb += bytes_written;\n\t\t} while (bytes_to_write > 0);\n\t}\n\tr = fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME, 0);\n\tif (r == -1)  {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to remove resource fork\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_drive_compressor(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tunsigned char *buffer_compressed;\n\tsize_t bytes_compressed;\n\tsize_t bytes_used;\n\tint ret;\n\n\tret = hfs_reset_compressor(a);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\tif (a->compressed_buffer == NULL) {\n\t\tsize_t block_size;\n\n\t\tblock_size = COMPRESSED_W_SIZE + RSRC_F_SIZE +\n\t\t    + compressBound(MAX_DECMPFS_BLOCK_SIZE);\n\t\ta->compressed_buffer = malloc(block_size);\n\t\tif (a->compressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Resource Fork\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\ta->compressed_buffer_size = block_size;\n\t\ta->compressed_buffer_remaining = block_size;\n\t}\n\n\tbuffer_compressed = a->compressed_buffer +\n\t    a->compressed_buffer_size - a->compressed_buffer_remaining;\n\ta->stream.next_in = (Bytef *)(uintptr_t)(const void *)buff;\n\ta->stream.avail_in = size;\n\ta->stream.next_out = buffer_compressed;\n\ta->stream.avail_out = a->compressed_buffer_remaining;\n\tdo {\n\t\tret = deflate(&a->stream, Z_FINISH);\n\t\tswitch (ret) {\n\t\tcase Z_OK:\n\t\tcase Z_STREAM_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to compress data\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} while (ret == Z_OK);\n\tbytes_compressed = a->compressed_buffer_remaining - a->stream.avail_out;\n\n\t/*\n\t * If the compressed size is larger than the original size,\n\t * throw away compressed data, use uncompressed data instead.\n\t */\n\tif (bytes_compressed > size) {\n\t\tbuffer_compressed[0] = 0xFF;/* uncompressed marker. */\n\t\tmemcpy(buffer_compressed + 1, buff, size);\n\t\tbytes_compressed = size + 1;\n\t}\n\ta->compressed_buffer_remaining -= bytes_compressed;\n\n\t/*\n\t * If the compressed size is smaller than MAX_DECMPFS_XATTR_SIZE\n\t * and the block count in the file is only one, store compressed\n\t * data to decmpfs xattr instead of the resource fork.\n\t */\n\tif (a->decmpfs_block_count == 1 &&\n\t    (a->decmpfs_attr_size + bytes_compressed)\n\t      <= MAX_DECMPFS_XATTR_SIZE) {\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],\n\t\t    CMP_XATTR);\n\t\tmemcpy(a->decmpfs_header_p + DECMPFS_HEADER_SIZE,\n\t\t    buffer_compressed, bytes_compressed);\n\t\ta->decmpfs_attr_size += bytes_compressed;\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\t\t/*\n\t\t * Finish HFS+ Compression.\n\t\t * - Write the decmpfs xattr.\n\t\t * - Set the UF_COMPRESSED file flag.\n\t\t */\n\t\tret = hfs_write_decmpfs(a);\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_set_compressed_fflag(a);\n\t\treturn (ret);\n\t}\n\n\t/* Update block info. */\n\tarchive_le32enc(a->decmpfs_block_info++,\n\t    a->compressed_rsrc_position_v - RSRC_H_SIZE);\n\tarchive_le32enc(a->decmpfs_block_info++, bytes_compressed);\n\ta->compressed_rsrc_position_v += bytes_compressed;\n\n\t/*\n\t * Write the compressed data to the resource fork.\n\t */\n\tbytes_used = a->compressed_buffer_size - a->compressed_buffer_remaining;\n\twhile (bytes_used >= COMPRESSED_W_SIZE) {\n\t\tret = hfs_write_compressed_data(a, COMPRESSED_W_SIZE);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t\tbytes_used -= COMPRESSED_W_SIZE;\n\t\tif (bytes_used > COMPRESSED_W_SIZE)\n\t\t\tmemmove(a->compressed_buffer,\n\t\t\t    a->compressed_buffer + COMPRESSED_W_SIZE,\n\t\t\t    bytes_used);\n\t\telse\n\t\t\tmemcpy(a->compressed_buffer,\n\t\t\t    a->compressed_buffer + COMPRESSED_W_SIZE,\n\t\t\t    bytes_used);\n\t}\n\ta->compressed_buffer_remaining = a->compressed_buffer_size - bytes_used;\n\n\t/*\n\t * If the current block is the last block, write the remaining\n\t * compressed data and the resource fork footer.\n\t */\n\tif (a->file_remaining_bytes == 0) {\n\t\tsize_t rsrc_size;\n\t\tint64_t bk;\n\n\t\t/* Append the resource footer. */\n\t\trsrc_size = hfs_set_resource_fork_footer(\n\t\t    a->compressed_buffer + bytes_used,\n\t\t    a->compressed_buffer_remaining);\n\t\tret = hfs_write_compressed_data(a, bytes_used + rsrc_size);\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\n\t\t/* If the compressed size is not enouph smaller than\n\t\t * the uncompressed size. cancel HFS+ compression.\n\t\t * TODO: study a behavior of ditto utility and improve\n\t\t * the condition to fall back into no HFS+ compression. */\n\t\tbk = HFS_BLOCKS(a->compressed_rsrc_position);\n\t\tbk += bk >> 7;\n\t\tif (bk > HFS_BLOCKS(a->filesize))\n\t\t\treturn hfs_decompress(a);\n\t\t/*\n\t\t * Write the resourcefork header.\n\t\t */\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_write_resource_fork_header(a);\n\t\t/*\n\t\t * Finish HFS+ Compression.\n\t\t * - Write the decmpfs xattr.\n\t\t * - Set the UF_COMPRESSED file flag.\n\t\t */\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_write_decmpfs(a);\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_set_compressed_fflag(a);\n\t}\n\treturn (ret);\n}\n\nstatic ssize_t\nhfs_write_decmpfs_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tconst char *buffer_to_write;\n\tsize_t bytes_to_write;\n\tint ret;\n\n\tif (a->decmpfs_block_count == (unsigned)-1) {\n\t\tvoid *new_block;\n\t\tsize_t new_size;\n\t\tunsigned int block_count;\n\n\t\tif (a->decmpfs_header_p == NULL) {\n\t\t\tnew_block = malloc(MAX_DECMPFS_XATTR_SIZE\n\t\t\t    + sizeof(uint32_t));\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for decmpfs\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->decmpfs_header_p = new_block;\n\t\t}\n\t\ta->decmpfs_attr_size = DECMPFS_HEADER_SIZE;\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_MAGIC],\n\t\t    DECMPFS_MAGIC);\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],\n\t\t    CMP_RESOURCE_FORK);\n\t\tarchive_le64enc(&a->decmpfs_header_p[DECMPFS_UNCOMPRESSED_SIZE],\n\t\t    a->filesize);\n\n\t\t/* Calculate a block count of the file. */\n\t\tblock_count =\n\t\t    (a->filesize + MAX_DECMPFS_BLOCK_SIZE -1) /\n\t\t\tMAX_DECMPFS_BLOCK_SIZE;\n\t\t/*\n\t\t * Allocate buffer for resource fork.\n\t\t * Set up related pointers;\n\t\t */\n\t\tnew_size =\n\t\t    RSRC_H_SIZE + /* header */\n\t\t    4 + /* Block count */\n\t\t    (block_count * sizeof(uint32_t) * 2) +\n\t\t    RSRC_F_SIZE; /* footer */\n\t\tif (new_size > a->resource_fork_allocated_size) {\n\t\t\tnew_block = realloc(a->resource_fork, new_size);\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for ResourceFork\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->resource_fork_allocated_size = new_size;\n\t\t\ta->resource_fork = new_block;\n\t\t}\n\n\t\t/* Allocate uncompressed buffer */\n\t\tif (a->uncompressed_buffer == NULL) {\n\t\t\tnew_block = malloc(MAX_DECMPFS_BLOCK_SIZE);\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for decmpfs\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->uncompressed_buffer = new_block;\n\t\t}\n\t\ta->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;\n\t\ta->file_remaining_bytes = a->filesize;\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\n\t\t/*\n\t\t * Set up a resource fork.\n\t\t */\n\t\ta->rsrc_xattr_options = XATTR_CREATE;\n\t\t/* Get the position where we are going to set a bunch\n\t\t * of block info. */\n\t\ta->decmpfs_block_info =\n\t\t    (uint32_t *)(a->resource_fork + RSRC_H_SIZE);\n\t\t/* Set the block count to the resource fork. */\n\t\tarchive_le32enc(a->decmpfs_block_info++, block_count);\n\t\t/* Get the position where we are goint to set compressed\n\t\t * data. */\n\t\ta->compressed_rsrc_position =\n\t\t    RSRC_H_SIZE + 4 + (block_count * 8);\n\t\ta->compressed_rsrc_position_v = a->compressed_rsrc_position;\n\t\ta->decmpfs_block_count = block_count;\n\t}\n\n\t/* Ignore redundant bytes. */\n\tif (a->file_remaining_bytes == 0)\n\t\treturn ((ssize_t)size);\n\n\t/* Do not overrun a block size. */\n\tif (size > a->block_remaining_bytes)\n\t\tbytes_to_write = a->block_remaining_bytes;\n\telse\n\t\tbytes_to_write = size;\n\t/* Do not overrun the file size. */\n\tif (bytes_to_write > a->file_remaining_bytes)\n\t\tbytes_to_write = a->file_remaining_bytes;\n\n\t/* For efficiency, if a copy length is full of the uncompressed\n\t * buffer size, do not copy writing data to it. */\n\tif (bytes_to_write == MAX_DECMPFS_BLOCK_SIZE)\n\t\tbuffer_to_write = buff;\n\telse {\n\t\tmemcpy(a->uncompressed_buffer +\n\t\t    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes,\n\t\t    buff, bytes_to_write);\n\t\tbuffer_to_write = a->uncompressed_buffer;\n\t}\n\ta->block_remaining_bytes -= bytes_to_write;\n\ta->file_remaining_bytes -= bytes_to_write;\n\n\tif (a->block_remaining_bytes == 0 || a->file_remaining_bytes == 0) {\n\t\tret = hfs_drive_compressor(a, buffer_to_write,\n\t\t    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes);\n\t\tif (ret < 0)\n\t\t\treturn (ret);\n\t\ta->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;\n\t}\n\t/* Ignore redundant bytes. */\n\tif (a->file_remaining_bytes == 0)\n\t\treturn ((ssize_t)size);\n\treturn (bytes_to_write);\n}\n\nstatic ssize_t\nhfs_write_data_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tuint64_t start_size = size;\n\tssize_t bytes_written = 0;\n\tssize_t bytes_to_write;\n\n\tif (size == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (a->filesize == 0 || a->fd < 0) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Attempt to write to an empty file\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* If this write would run beyond the file size, truncate it. */\n\tif (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)\n\t\tstart_size = size = (size_t)(a->filesize - a->offset);\n\n\t/* Write the data. */\n\twhile (size > 0) {\n\t\tbytes_to_write = size;\n\t\t/* Seek if necessary to the specified offset. */\n\t\tif (a->offset < a->fd_offset) {\n\t\t\t/* Can't support backword move. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Seek failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else if (a->offset > a->fd_offset) {\n\t\t\tint64_t skip = a->offset - a->fd_offset;\n\t\t\tchar nullblock[1024];\n\n\t\t\tmemset(nullblock, 0, sizeof(nullblock));\n\t\t\twhile (skip > 0) {\n\t\t\t\tif (skip > (int64_t)sizeof(nullblock))\n\t\t\t\t\tbytes_written = hfs_write_decmpfs_block(\n\t\t\t\t\t    a, nullblock, sizeof(nullblock));\n\t\t\t\telse\n\t\t\t\t\tbytes_written = hfs_write_decmpfs_block(\n\t\t\t\t\t    a, nullblock, skip);\n\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Write failed\");\n\t\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t\t}\n\t\t\t\tskip -= bytes_written;\n\t\t\t}\n\n\t\t\ta->fd_offset = a->offset;\n\t\t}\n\t\tbytes_written =\n\t\t    hfs_write_decmpfs_block(a, buff, bytes_to_write);\n\t\tif (bytes_written < 0)\n\t\t\treturn (bytes_written);\n\t\tbuff += bytes_written;\n\t\tsize -= bytes_written;\n\t\ta->total_bytes_written += bytes_written;\n\t\ta->offset += bytes_written;\n\t\ta->fd_offset = a->offset;\n\t}\n\treturn (start_size - size);\n}\n#else\nstatic ssize_t\nhfs_write_data_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\treturn (write_data_block(a, buff, size));\n}\n#endif\n\nstatic ssize_t\n_archive_write_disk_data_block(struct archive *_a,\n    const void *buff, size_t size, int64_t offset)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tssize_t r;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data_block\");\n\n\ta->offset = offset;\n\tif (a->todo & TODO_HFS_COMPRESSION)\n\t\tr = hfs_write_data_block(a, buff, size);\n\telse\n\t\tr = write_data_block(a, buff, size);\n\tif (r < ARCHIVE_OK)\n\t\treturn (r);\n\tif ((size_t)r < size) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Too much data: Truncating file at %ju bytes\", (uintmax_t)a->filesize);\n\t\treturn (ARCHIVE_WARN);\n\t}\n#if ARCHIVE_VERSION_NUMBER < 3999000\n\treturn (ARCHIVE_OK);\n#else\n\treturn (size);\n#endif\n}\n\nstatic ssize_t\n_archive_write_disk_data(struct archive *_a, const void *buff, size_t size)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\n\tif (a->todo & TODO_HFS_COMPRESSION)\n\t\treturn (hfs_write_data_block(a, buff, size));\n\treturn (write_data_block(a, buff, size));\n}\n\nstatic int\n_archive_write_disk_finish_entry(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tint ret = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_finish_entry\");\n\tif (a->archive.state & ARCHIVE_STATE_HEADER)\n\t\treturn (ARCHIVE_OK);\n\tarchive_clear_error(&a->archive);\n\n\t/* Pad or truncate file to the right size. */\n\tif (a->fd < 0) {\n\t\t/* There's no file. */\n\t} else if (a->filesize < 0) {\n\t\t/* File size is unknown, so we can't set the size. */\n\t} else if (a->fd_offset == a->filesize) {\n\t\t/* Last write ended at exactly the filesize; we're done. */\n\t\t/* Hopefully, this is the common case. */\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\t} else if (a->todo & TODO_HFS_COMPRESSION) {\n\t\tchar null_d[1024];\n\t\tssize_t r;\n\n\t\tif (a->file_remaining_bytes)\n\t\t\tmemset(null_d, 0, sizeof(null_d));\n\t\twhile (a->file_remaining_bytes) {\n\t\t\tif (a->file_remaining_bytes > sizeof(null_d))\n\t\t\t\tr = hfs_write_data_block(\n\t\t\t\t    a, null_d, sizeof(null_d));\n\t\t\telse\n\t\t\t\tr = hfs_write_data_block(\n\t\t\t\t    a, null_d, a->file_remaining_bytes);\n\t\t\tif (r < 0)\n\t\t\t\treturn ((int)r);\n\t\t}\n#endif\n\t} else {\n#if HAVE_FTRUNCATE\n\t\tif (ftruncate(a->fd, a->filesize) == -1 &&\n\t\t    a->filesize == 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"File size could not be restored\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n#endif\n\t\t/*\n\t\t * Not all platforms implement the XSI option to\n\t\t * extend files via ftruncate.  Stat() the file again\n\t\t * to see what happened.\n\t\t */\n\t\ta->pst = NULL;\n\t\tif ((ret = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t\t/* We can use lseek()/write() to extend the file if\n\t\t * ftruncate didn't work or isn't available. */\n\t\tif (a->st.st_size < a->filesize) {\n\t\t\tconst char nul = '\\0';\n\t\t\tif (lseek(a->fd, a->filesize - 1, SEEK_SET) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Seek failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tif (write(a->fd, &nul, 1) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Write to restore size failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->pst = NULL;\n\t\t}\n\t}\n\n\t/* Restore metadata. */\n\n\t/*\n\t * This is specific to Mac OS X.\n\t * If the current file is an AppleDouble file, it should be\n\t * linked with the data fork file and remove it.\n\t */\n\tif (a->todo & TODO_APPLEDOUBLE) {\n\t\tint r2 = fixup_appledouble(a, a->name);\n\t\tif (r2 == ARCHIVE_EOF) {\n\t\t\t/* The current file has been successfully linked\n\t\t\t * with the data fork file and removed. So there\n\t\t\t * is nothing to do on the current file.  */\n\t\t\tgoto finish_metadata;\n\t\t}\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Look up the \"real\" UID only if we're going to need it.\n\t * TODO: the TODO_SGID condition can be dropped here, can't it?\n\t */\n\tif (a->todo & (TODO_OWNER | TODO_SUID | TODO_SGID)) {\n\t\ta->uid = archive_write_disk_uid(&a->archive,\n\t\t    archive_entry_uname(a->entry),\n\t\t    archive_entry_uid(a->entry));\n\t}\n\t/* Look up the \"real\" GID only if we're going to need it. */\n\t/* TODO: the TODO_SUID condition can be dropped here, can't it? */\n\tif (a->todo & (TODO_OWNER | TODO_SGID | TODO_SUID)) {\n\t\ta->gid = archive_write_disk_gid(&a->archive,\n\t\t    archive_entry_gname(a->entry),\n\t\t    archive_entry_gid(a->entry));\n\t }\n\n\t/*\n\t * Restore ownership before set_mode tries to restore suid/sgid\n\t * bits.  If we set the owner, we know what it is and can skip\n\t * a stat() call to examine the ownership of the file on disk.\n\t */\n\tif (a->todo & TODO_OWNER) {\n\t\tint r2 = set_ownership(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * set_mode must precede ACLs on systems such as Solaris and\n\t * FreeBSD where setting the mode implicitly clears extended ACLs\n\t */\n\tif (a->todo & TODO_MODE) {\n\t\tint r2 = set_mode(a, a->mode);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Security-related extended attributes (such as\n\t * security.capability on Linux) have to be restored last,\n\t * since they're implicitly removed by other file changes.\n\t */\n\tif (a->todo & TODO_XATTR) {\n\t\tint r2 = set_xattrs(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Some flags prevent file modification; they must be restored after\n\t * file contents are written.\n\t */\n\tif (a->todo & TODO_FFLAGS) {\n\t\tint r2 = set_fflags(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Time must follow most other metadata;\n\t * otherwise atime will get changed.\n\t */\n\tif (a->todo & TODO_TIMES) {\n\t\tint r2 = set_times_from_entry(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Mac extended metadata includes ACLs.\n\t */\n\tif (a->todo & TODO_MAC_METADATA) {\n\t\tconst void *metadata;\n\t\tsize_t metadata_size;\n\t\tmetadata = archive_entry_mac_metadata(a->entry, &metadata_size);\n\t\tif (metadata != NULL && metadata_size > 0) {\n\t\t\tint r2 = set_mac_metadata(a, archive_entry_pathname(\n\t\t\t    a->entry), metadata, metadata_size);\n\t\t\tif (r2 < ret) ret = r2;\n\t\t}\n\t}\n\n\t/*\n\t * ACLs must be restored after timestamps because there are\n\t * ACLs that prevent attribute changes (including time).\n\t */\n\tif (a->todo & TODO_ACLS) {\n\t\tint r2 = archive_write_disk_set_acls(&a->archive, a->fd,\n\t\t\t\t  archive_entry_pathname(a->entry),\n\t\t\t\t  archive_entry_acl(a->entry));\n\t\tif (r2 < ret) ret = r2;\n\t}\n\nfinish_metadata:\n\t/* If there's an fd, we can close it now. */\n\tif (a->fd >= 0) {\n\t\tclose(a->fd);\n\t\ta->fd = -1;\n\t}\n\t/* If there's an entry, we can release it now. */\n\tif (a->entry) {\n\t\tarchive_entry_free(a->entry);\n\t\ta->entry = NULL;\n\t}\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\treturn (ret);\n}\n\nint\narchive_write_disk_set_group_lookup(struct archive *_a,\n    void *private_data,\n    int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid),\n    void (*cleanup_gid)(void *private))\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_group_lookup\");\n\n\tif (a->cleanup_gid != NULL && a->lookup_gid_data != NULL)\n\t\t(a->cleanup_gid)(a->lookup_gid_data);\n\n\ta->lookup_gid = lookup_gid;\n\ta->cleanup_gid = cleanup_gid;\n\ta->lookup_gid_data = private_data;\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_user_lookup(struct archive *_a,\n    void *private_data,\n    int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),\n    void (*cleanup_uid)(void *private))\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_user_lookup\");\n\n\tif (a->cleanup_uid != NULL && a->lookup_uid_data != NULL)\n\t\t(a->cleanup_uid)(a->lookup_uid_data);\n\n\ta->lookup_uid = lookup_uid;\n\ta->cleanup_uid = cleanup_uid;\n\ta->lookup_uid_data = private_data;\n\treturn (ARCHIVE_OK);\n}\n\nint64_t\narchive_write_disk_gid(struct archive *_a, const char *name, int64_t id)\n{\n       struct archive_write_disk *a = (struct archive_write_disk *)_a;\n       archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n           ARCHIVE_STATE_ANY, \"archive_write_disk_gid\");\n       if (a->lookup_gid)\n               return (a->lookup_gid)(a->lookup_gid_data, name, id);\n       return (id);\n}\n \nint64_t\narchive_write_disk_uid(struct archive *_a, const char *name, int64_t id)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_uid\");\n\tif (a->lookup_uid)\n\t\treturn (a->lookup_uid)(a->lookup_uid_data, name, id);\n\treturn (id);\n}\n\n/*\n * Create a new archive_write_disk object and initialize it with global state.\n */\nstruct archive *\narchive_write_disk_new(void)\n{\n\tstruct archive_write_disk *a;\n\n\ta = (struct archive_write_disk *)malloc(sizeof(*a));\n\tif (a == NULL)\n\t\treturn (NULL);\n\tmemset(a, 0, sizeof(*a));\n\ta->archive.magic = ARCHIVE_WRITE_DISK_MAGIC;\n\t/* We're ready to write a header immediately. */\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\ta->archive.vtable = archive_write_disk_vtable();\n\ta->start_time = time(NULL);\n\t/* Query and restore the umask. */\n\tumask(a->user_umask = umask(0));\n#ifdef HAVE_GETEUID\n\ta->user_uid = geteuid();\n#endif /* HAVE_GETEUID */\n\tif (archive_string_ensure(&a->path_safe, 512) == NULL) {\n\t\tfree(a);\n\t\treturn (NULL);\n\t}\n#ifdef HAVE_ZLIB_H\n\ta->decmpfs_compression_level = 5;\n#endif\n\treturn (&a->archive);\n}\n\n\n/*\n * If pathname is longer than PATH_MAX, chdir to a suitable\n * intermediate dir and edit the path down to a shorter suffix.  Note\n * that this routine never returns an error; if the chdir() attempt\n * fails for any reason, we just go ahead with the long pathname.  The\n * object creation is likely to fail, but any error will get handled\n * at that time.\n */\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\nstatic void\nedit_deep_directories(struct archive_write_disk *a)\n{\n\tint ret;\n\tchar *tail = a->name;\n\n\t/* If path is short, avoid the open() below. */\n\tif (strlen(tail) < PATH_MAX)\n\t\treturn;\n\n\t/* Try to record our starting dir. */\n\ta->restore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);\n\t__archive_ensure_cloexec_flag(a->restore_pwd);\n\tif (a->restore_pwd < 0)\n\t\treturn;\n\n\t/* As long as the path is too long... */\n\twhile (strlen(tail) >= PATH_MAX) {\n\t\t/* Locate a dir prefix shorter than PATH_MAX. */\n\t\ttail += PATH_MAX - 8;\n\t\twhile (tail > a->name && *tail != '/')\n\t\t\ttail--;\n\t\t/* Exit if we find a too-long path component. */\n\t\tif (tail <= a->name)\n\t\t\treturn;\n\t\t/* Create the intermediate dir and chdir to it. */\n\t\t*tail = '\\0'; /* Terminate dir portion */\n\t\tret = create_dir(a, a->name);\n\t\tif (ret == ARCHIVE_OK && chdir(a->name) != 0)\n\t\t\tret = ARCHIVE_FAILED;\n\t\t*tail = '/'; /* Restore the / we removed. */\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn;\n\t\ttail++;\n\t\t/* The chdir() succeeded; we've now shortened the path. */\n\t\ta->name = tail;\n\t}\n\treturn;\n}\n#endif\n\n/*\n * The main restore function.\n */\nstatic int\nrestore_entry(struct archive_write_disk *a)\n{\n\tint ret = ARCHIVE_OK, en;\n\n\tif (a->flags & ARCHIVE_EXTRACT_UNLINK && !S_ISDIR(a->mode)) {\n\t\t/*\n\t\t * TODO: Fix this.  Apparently, there are platforms\n\t\t * that still allow root to hose the entire filesystem\n\t\t * by unlinking a dir.  The S_ISDIR() test above\n\t\t * prevents us from using unlink() here if the new\n\t\t * object is a dir, but that doesn't mean the old\n\t\t * object isn't a dir.\n\t\t */\n\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t(void)clear_nochange_fflags(a);\n\t\tif (unlink(a->name) == 0) {\n\t\t\t/* We removed it, reset cached stat. */\n\t\t\ta->pst = NULL;\n\t\t} else if (errno == ENOENT) {\n\t\t\t/* File didn't exist, that's just as good. */\n\t\t} else if (rmdir(a->name) == 0) {\n\t\t\t/* It was a dir, but now it's gone. */\n\t\t\ta->pst = NULL;\n\t\t} else {\n\t\t\t/* We tried, but couldn't get rid of it. */\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Could not unlink\");\n\t\t\treturn(ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\t/* Try creating it first; if this fails, we'll try to recover. */\n\ten = create_filesystem_object(a);\n\n\tif ((en == ENOTDIR || en == ENOENT)\n\t    && !(a->flags & ARCHIVE_EXTRACT_NO_AUTODIR)) {\n\t\t/* If the parent dir doesn't exist, try creating it. */\n\t\tcreate_parent_dir(a, a->name);\n\t\t/* Now try to create the object again. */\n\t\ten = create_filesystem_object(a);\n\t}\n\n\tif ((en == ENOENT) && (archive_entry_hardlink(a->entry) != NULL)) {\n\t\tarchive_set_error(&a->archive, en,\n\t\t    \"Hard-link target '%s' does not exist.\",\n\t\t    archive_entry_hardlink(a->entry));\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif ((en == EISDIR || en == EEXIST)\n\t    && (a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {\n\t\t/* If we're not overwriting, we're done. */\n\t\tarchive_entry_unset_size(a->entry);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Some platforms return EISDIR if you call\n\t * open(O_WRONLY | O_EXCL | O_CREAT) on a directory, some\n\t * return EEXIST.  POSIX is ambiguous, requiring EISDIR\n\t * for open(O_WRONLY) on a dir and EEXIST for open(O_EXCL | O_CREAT)\n\t * on an existing item.\n\t */\n\tif (en == EISDIR) {\n\t\t/* A dir is in the way of a non-dir, rmdir it. */\n\t\tif (rmdir(a->name) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't remove already-existing dir\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\ta->pst = NULL;\n\t\t/* Try again. */\n\t\ten = create_filesystem_object(a);\n\t} else if (en == EEXIST) {\n\t\t/*\n\t\t * We know something is in the way, but we don't know what;\n\t\t * we need to find out before we go any further.\n\t\t */\n\t\tint r = 0;\n\t\t/*\n\t\t * The SECURE_SYMLINKS logic has already removed a\n\t\t * symlink to a dir if the client wants that.  So\n\t\t * follow the symlink if we're creating a dir.\n\t\t */\n\t\tif (S_ISDIR(a->mode))\n\t\t\tr = stat(a->name, &a->st);\n\t\t/*\n\t\t * If it's not a dir (or it's a broken symlink),\n\t\t * then don't follow it.\n\t\t */\n\t\tif (r != 0 || !S_ISDIR(a->mode))\n\t\t\tr = lstat(a->name, &a->st);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't stat existing object\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/*\n\t\t * NO_OVERWRITE_NEWER doesn't apply to directories.\n\t\t */\n\t\tif ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER)\n\t\t    &&  !S_ISDIR(a->st.st_mode)) {\n\t\t\tif (!older(&(a->st), a->entry)) {\n\t\t\t\tarchive_entry_unset_size(a->entry);\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t}\n\n\t\t/* If it's our archive, we're done. */\n\t\tif (a->skip_file_set &&\n\t\t    a->st.st_dev == (dev_t)a->skip_file_dev &&\n\t\t    a->st.st_ino == (ino_t)a->skip_file_ino) {\n\t\t\tarchive_set_error(&a->archive, 0,\n\t\t\t    \"Refusing to overwrite archive\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tif (!S_ISDIR(a->st.st_mode)) {\n\t\t\t/* A non-dir is in the way, unlink it. */\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t\t(void)clear_nochange_fflags(a);\n\t\t\tif (unlink(a->name) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't unlink already-existing object\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\ta->pst = NULL;\n\t\t\t/* Try again. */\n\t\t\ten = create_filesystem_object(a);\n\t\t} else if (!S_ISDIR(a->mode)) {\n\t\t\t/* A dir is in the way of a non-dir, rmdir it. */\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t\t(void)clear_nochange_fflags(a);\n\t\t\tif (rmdir(a->name) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't replace existing directory with non-directory\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\t/* Try again. */\n\t\t\ten = create_filesystem_object(a);\n\t\t} else {\n\t\t\t/*\n\t\t\t * There's a dir in the way of a dir.  Don't\n\t\t\t * waste time with rmdir()/mkdir(), just fix\n\t\t\t * up the permissions on the existing dir.\n\t\t\t * Note that we don't change perms on existing\n\t\t\t * dirs unless _EXTRACT_PERM is specified.\n\t\t\t */\n\t\t\tif ((a->mode != a->st.st_mode)\n\t\t\t    && (a->todo & TODO_MODE_FORCE))\n\t\t\t\ta->deferred |= (a->todo & TODO_MODE);\n\t\t\t/* Ownership doesn't need deferred fixup. */\n\t\t\ten = 0; /* Forget the EEXIST. */\n\t\t}\n\t}\n\n\tif (en) {\n\t\t/* Everything failed; give up here. */\n\t\tarchive_set_error(&a->archive, en, \"Can't create '%s'\",\n\t\t    a->name);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\ta->pst = NULL; /* Cached stat data no longer valid. */\n\treturn (ret);\n}\n\n/*\n * Returns 0 if creation succeeds, or else returns errno value from\n * the failed system call.   Note:  This function should only ever perform\n * a single system call.\n */\nstatic int\ncreate_filesystem_object(struct archive_write_disk *a)\n{\n\t/* Create the entry. */\n\tconst char *linkname;\n\tmode_t final_mode, mode;\n\tint r;\n\n\t/* We identify hard/symlinks according to the link names. */\n\t/* Since link(2) and symlink(2) don't handle modes, we're done here. */\n\tlinkname = archive_entry_hardlink(a->entry);\n\tif (linkname != NULL) {\n#if !HAVE_LINK\n\t\treturn (EPERM);\n#else\n\t\tr = link(linkname, a->name) ? errno : 0;\n\t\t/*\n\t\t * New cpio and pax formats allow hardlink entries\n\t\t * to carry data, so we may have to open the file\n\t\t * for hardlink entries.\n\t\t *\n\t\t * If the hardlink was successfully created and\n\t\t * the archive doesn't have carry data for it,\n\t\t * consider it to be non-authoritative for meta data.\n\t\t * This is consistent with GNU tar and BSD pax.\n\t\t * If the hardlink does carry data, let the last\n\t\t * archive entry decide ownership.\n\t\t */\n\t\tif (r == 0 && a->filesize <= 0) {\n\t\t\ta->todo = 0;\n\t\t\ta->deferred = 0;\n\t\t} else if (r == 0 && a->filesize > 0) {\n\t\t\ta->fd = open(a->name,\n\t\t\t\t     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\t\tif (a->fd < 0)\n\t\t\t\tr = errno;\n\t\t}\n\t\treturn (r);\n#endif\n\t}\n\tlinkname = archive_entry_symlink(a->entry);\n\tif (linkname != NULL) {\n#if HAVE_SYMLINK\n\t\treturn symlink(linkname, a->name) ? errno : 0;\n#else\n\t\treturn (EPERM);\n#endif\n\t}\n\n\t/*\n\t * The remaining system calls all set permissions, so let's\n\t * try to take advantage of that to avoid an extra chmod()\n\t * call.  (Recall that umask is set to zero right now!)\n\t */\n\n\t/* Mode we want for the final restored object (w/o file type bits). */\n\tfinal_mode = a->mode & 07777;\n\t/*\n\t * The mode that will actually be restored in this step.  Note\n\t * that SUID, SGID, etc, require additional work to ensure\n\t * security, so we never restore them at this point.\n\t */\n\tmode = final_mode & 0777 & ~a->user_umask;\n\n\tswitch (a->mode & AE_IFMT) {\n\tdefault:\n\t\t/* POSIX requires that we fall through here. */\n\t\t/* FALLTHROUGH */\n\tcase AE_IFREG:\n\t\ta->fd = open(a->name,\n\t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);\n\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\tr = (a->fd < 0);\n\t\tbreak;\n\tcase AE_IFCHR:\n#ifdef HAVE_MKNOD\n\t\t/* Note: we use AE_IFCHR for the case label, and\n\t\t * S_IFCHR for the mknod() call.  This is correct.  */\n\t\tr = mknod(a->name, mode | S_IFCHR,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a char device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFBLK:\n#ifdef HAVE_MKNOD\n\t\tr = mknod(a->name, mode | S_IFBLK,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a block device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFDIR:\n\t\tmode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;\n\t\tr = mkdir(a->name, mode);\n\t\tif (r == 0) {\n\t\t\t/* Defer setting dir times. */\n\t\t\ta->deferred |= (a->todo & TODO_TIMES);\n\t\t\ta->todo &= ~TODO_TIMES;\n\t\t\t/* Never use an immediate chmod(). */\n\t\t\t/* We can't avoid the chmod() entirely if EXTRACT_PERM\n\t\t\t * because of SysV SGID inheritance. */\n\t\t\tif ((mode != final_mode)\n\t\t\t    || (a->flags & ARCHIVE_EXTRACT_PERM))\n\t\t\t\ta->deferred |= (a->todo & TODO_MODE);\n\t\t\ta->todo &= ~TODO_MODE;\n\t\t}\n\t\tbreak;\n\tcase AE_IFIFO:\n#ifdef HAVE_MKFIFO\n\t\tr = mkfifo(a->name, mode);\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a fifo. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKFIFO */\n\t}\n\n\t/* All the system calls above set errno on failure. */\n\tif (r)\n\t\treturn (errno);\n\n\t/* If we managed to set the final mode, we've avoided a chmod(). */\n\tif (mode == final_mode)\n\t\ta->todo &= ~TODO_MODE;\n\treturn (0);\n}\n\n/*\n * Cleanup function for archive_extract.  Mostly, this involves processing\n * the fixup list, which is used to address a number of problems:\n *   * Dir permissions might prevent us from restoring a file in that\n *     dir, so we restore the dir with minimum 0700 permissions first,\n *     then correct the mode at the end.\n *   * Similarly, the act of restoring a file touches the directory\n *     and changes the timestamp on the dir, so we have to touch-up dir\n *     timestamps at the end as well.\n *   * Some file flags can interfere with the restore by, for example,\n *     preventing the creation of hardlinks to those files.\n *   * Mac OS extended metadata includes ACLs, so must be deferred on dirs.\n *\n * Note that tar/cpio do not require that archives be in a particular\n * order; there is no way to know when the last file has been restored\n * within a directory, so there's no way to optimize the memory usage\n * here by fixing up the directory any earlier than the\n * end-of-archive.\n *\n * XXX TODO: Directory ACLs should be restored here, for the same\n * reason we set directory perms here. XXX\n */\nstatic int\n_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t/* Sort dir list so directories are fixed up in depth-first order. */\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\ta->pst = NULL; /* Mark stat cache as out-of-date. */\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, -1, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE)\n\t\t\tchmod(p->name, p->mode);\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive,\n\t\t\t\t\t\t    -1, p->name, &p->acl);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, -1, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}\n\nstatic int\n_archive_write_disk_free(struct archive *_a)\n{\n\tstruct archive_write_disk *a;\n\tint ret;\n\tif (_a == NULL)\n\t\treturn (ARCHIVE_OK);\n\tarchive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_disk_free\");\n\ta = (struct archive_write_disk *)_a;\n\tret = _archive_write_disk_close(&a->archive);\n\tarchive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);\n\tarchive_write_disk_set_user_lookup(&a->archive, NULL, NULL, NULL);\n\tif (a->entry)\n\t\tarchive_entry_free(a->entry);\n\tarchive_string_free(&a->_name_data);\n\tarchive_string_free(&a->archive.error_string);\n\tarchive_string_free(&a->path_safe);\n\ta->archive.magic = 0;\n\t__archive_clean(&a->archive);\n\tfree(a->decmpfs_header_p);\n\tfree(a->resource_fork);\n\tfree(a->compressed_buffer);\n\tfree(a->uncompressed_buffer);\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\\\n\t&& defined(HAVE_ZLIB_H)\n\tif (a->stream_valid) {\n\t\tswitch (deflateEnd(&a->stream)) {\n\t\tcase Z_OK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up compressor\");\n\t\t\tret = ARCHIVE_FATAL;\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tfree(a);\n\treturn (ret);\n}\n\n/*\n * Simple O(n log n) merge sort to order the fixup list.  In\n * particular, we want to restore dir timestamps depth-first.\n */\nstatic struct fixup_entry *\nsort_dir_list(struct fixup_entry *p)\n{\n\tstruct fixup_entry *a, *b, *t;\n\n\tif (p == NULL)\n\t\treturn (NULL);\n\t/* A one-item list is already sorted. */\n\tif (p->next == NULL)\n\t\treturn (p);\n\n\t/* Step 1: split the list. */\n\tt = p;\n\ta = p->next->next;\n\twhile (a != NULL) {\n\t\t/* Step a twice, t once. */\n\t\ta = a->next;\n\t\tif (a != NULL)\n\t\t\ta = a->next;\n\t\tt = t->next;\n\t}\n\t/* Now, t is at the mid-point, so break the list here. */\n\tb = t->next;\n\tt->next = NULL;\n\ta = p;\n\n\t/* Step 2: Recursively sort the two sub-lists. */\n\ta = sort_dir_list(a);\n\tb = sort_dir_list(b);\n\n\t/* Step 3: Merge the returned lists. */\n\t/* Pick the first element for the merged list. */\n\tif (strcmp(a->name, b->name) > 0) {\n\t\tt = p = a;\n\t\ta = a->next;\n\t} else {\n\t\tt = p = b;\n\t\tb = b->next;\n\t}\n\n\t/* Always put the later element on the list first. */\n\twhile (a != NULL && b != NULL) {\n\t\tif (strcmp(a->name, b->name) > 0) {\n\t\t\tt->next = a;\n\t\t\ta = a->next;\n\t\t} else {\n\t\t\tt->next = b;\n\t\t\tb = b->next;\n\t\t}\n\t\tt = t->next;\n\t}\n\n\t/* Only one list is non-empty, so just splice it on. */\n\tif (a != NULL)\n\t\tt->next = a;\n\tif (b != NULL)\n\t\tt->next = b;\n\n\treturn (p);\n}\n\n/*\n * Returns a new, initialized fixup entry.\n *\n * TODO: Reduce the memory requirements for this list by using a tree\n * structure rather than a simple list of names.\n */\nstatic struct fixup_entry *\nnew_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}\n\n/*\n * Returns a fixup structure for the current entry.\n */\nstatic struct fixup_entry *\ncurrent_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tif (a->current_fixup == NULL)\n\t\ta->current_fixup = new_fixup(a, pathname);\n\treturn (a->current_fixup);\n}\n\n/* TODO: Make this work. */\n/*\n * TODO: The deep-directory support bypasses this; disable deep directory\n * support if we're doing symlink checks.\n */\n/*\n * TODO: Someday, integrate this with the deep dir support; they both\n * scan the path and both can be optimized by comparing against other\n * recent paths.\n */\n/* TODO: Extend this to support symlinks on Windows Vista and later. */\nstatic int\ncheck_symlinks(struct archive_write_disk *a)\n{\n#if !defined(HAVE_LSTAT)\n\t/* Platform doesn't have lstat, so we can't look for symlinks. */\n\t(void)a; /* UNUSED */\n\treturn (ARCHIVE_OK);\n#else\n\tchar *pn;\n\tchar c;\n\tint r;\n\tstruct stat st;\n\n\t/*\n\t * Guard against symlink tricks.  Reject any archive entry whose\n\t * destination would be altered by a symlink.\n\t */\n\t/* Whatever we checked last time doesn't need to be re-checked. */\n\tpn = a->name;\n\tif (archive_strlen(&(a->path_safe)) > 0) {\n\t\tchar *p = a->path_safe.s;\n\t\twhile ((*pn != '\\0') && (*p == *pn))\n\t\t\t++p, ++pn;\n\t}\n\t/* Skip the root directory if the path is absolute. */\n\tif(pn == a->name && pn[0] == '/')\n\t\t++pn;\n\tc = pn[0];\n\t/* Keep going until we've checked the entire name. */\n\twhile (pn[0] != '\\0' && (pn[0] != '/' || pn[1] != '\\0')) {\n\t\t/* Skip the next path element. */\n\t\twhile (*pn != '\\0' && *pn != '/')\n\t\t\t++pn;\n\t\tc = pn[0];\n\t\tpn[0] = '\\0';\n\t\t/* Check that we haven't hit a symlink. */\n\t\tr = lstat(a->name, &st);\n\t\tif (r != 0) {\n\t\t\t/* We've hit a dir that doesn't exist; stop now. */\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Note: This effectively disables deep directory\n\t\t\t\t * support when security checks are enabled.\n\t\t\t\t * Otherwise, very long pathnames that trigger\n\t\t\t\t * an error here could evade the sandbox.\n\t\t\t\t * TODO: We could do better, but it would probably\n\t\t\t\t * require merging the symlink checks with the\n\t\t\t\t * deep-directory editing. */\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t} else if (S_ISLNK(st.st_mode)) {\n\t\t\tif (c == '\\0') {\n\t\t\t\t/*\n\t\t\t\t * Last element is symlink; remove it\n\t\t\t\t * so we can overwrite it with the\n\t\t\t\t * item being extracted.\n\t\t\t\t */\n\t\t\t\tif (unlink(a->name)) {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Could not remove symlink %s\",\n\t\t\t\t\t    a->name);\n\t\t\t\t\tpn[0] = c;\n\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t}\n\t\t\t\ta->pst = NULL;\n\t\t\t\t/*\n\t\t\t\t * Even if we did remove it, a warning\n\t\t\t\t * is in order.  The warning is silly,\n\t\t\t\t * though, if we're just replacing one\n\t\t\t\t * symlink with another symlink.\n\t\t\t\t */\n\t\t\t\tif (!S_ISLNK(a->mode)) {\n\t\t\t\t\tarchive_set_error(&a->archive, 0,\n\t\t\t\t\t    \"Removing symlink %s\",\n\t\t\t\t\t    a->name);\n\t\t\t\t}\n\t\t\t\t/* Symlink gone.  No more problem! */\n\t\t\t\tpn[0] = c;\n\t\t\t\treturn (0);\n\t\t\t} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {\n\t\t\t\t/* User asked us to remove problems. */\n\t\t\t\tif (unlink(a->name) != 0) {\n\t\t\t\t\tarchive_set_error(&a->archive, 0,\n\t\t\t\t\t    \"Cannot remove intervening symlink %s\",\n\t\t\t\t\t    a->name);\n\t\t\t\t\tpn[0] = c;\n\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t}\n\t\t\t\ta->pst = NULL;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(&a->archive, 0,\n\t\t\t\t    \"Cannot extract through symlink %s\",\n\t\t\t\t    a->name);\n\t\t\t\tpn[0] = c;\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t}\n\t\tpn[0] = c;\n\t\tif (pn[0] != '\\0')\n\t\t\tpn++; /* Advance to the next segment. */\n\t}\n\tpn[0] = c;\n\t/* We've checked and/or cleaned the whole path, so remember it. */\n\tarchive_strcpy(&a->path_safe, a->name);\n\treturn (ARCHIVE_OK);\n#endif\n}\n\n#if defined(__CYGWIN__)\n/*\n * 1. Convert a path separator from '\\' to '/' .\n *    We shouldn't check multibyte character directly because some\n *    character-set have been using the '\\' character for a part of\n *    its multibyte character code.\n * 2. Replace unusable characters in Windows with underscore('_').\n * See also : http://msdn.microsoft.com/en-us/library/aa365247.aspx\n */\nstatic void\ncleanup_pathname_win(struct archive_write_disk *a)\n{\n\twchar_t wc;\n\tchar *p;\n\tsize_t alen, l;\n\tint mb, complete, utf8;\n\n\talen = 0;\n\tmb = 0;\n\tcomplete = 1;\n\tutf8 = (strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0)? 1: 0;\n\tfor (p = a->name; *p != '\\0'; p++) {\n\t\t++alen;\n\t\tif (*p == '\\\\') {\n\t\t\t/* If previous byte is smaller than 128,\n\t\t\t * this is not second byte of multibyte characters,\n\t\t\t * so we can replace '\\' with '/'. */\n\t\t\tif (utf8 || !mb)\n\t\t\t\t*p = '/';\n\t\t\telse\n\t\t\t\tcomplete = 0;/* uncompleted. */\n\t\t} else if (*(unsigned char *)p > 127)\n\t\t\tmb = 1;\n\t\telse\n\t\t\tmb = 0;\n\t\t/* Rewrite the path name if its next character is unusable. */\n\t\tif (*p == ':' || *p == '*' || *p == '?' || *p == '\"' ||\n\t\t    *p == '<' || *p == '>' || *p == '|')\n\t\t\t*p = '_';\n\t}\n\tif (complete)\n\t\treturn;\n\n\t/*\n\t * Convert path separator in wide-character.\n\t */\n\tp = a->name;\n\twhile (*p != '\\0' && alen) {\n\t\tl = mbtowc(&wc, p, alen);\n\t\tif (l == (size_t)-1) {\n\t\t\twhile (*p != '\\0') {\n\t\t\t\tif (*p == '\\\\')\n\t\t\t\t\t*p = '/';\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (l == 1 && wc == L'\\\\')\n\t\t\t*p = '/';\n\t\tp += l;\n\t\talen -= l;\n\t}\n}\n#endif\n\n/*\n * Canonicalize the pathname.  In particular, this strips duplicate\n * '/' characters, '.' elements, and trailing '/'.  It also raises an\n * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is\n * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n * is set) if the path is absolute.\n */\nstatic int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = a->name;\n\tif (*src == '\\0') {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t                  \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == a->name) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * Create the parent directory of the specified path, assuming path\n * is already in mutable storage.\n */\nstatic int\ncreate_parent_dir(struct archive_write_disk *a, char *path)\n{\n\tchar *slash;\n\tint r;\n\n\t/* Remove tail element to obtain parent name. */\n\tslash = strrchr(path, '/');\n\tif (slash == NULL)\n\t\treturn (ARCHIVE_OK);\n\t*slash = '\\0';\n\tr = create_dir(a, path);\n\t*slash = '/';\n\treturn (r);\n}\n\n/*\n * Create the specified dir, recursing to create parents as necessary.\n *\n * Returns ARCHIVE_OK if the path exists when we're done here.\n * Otherwise, returns ARCHIVE_FAILED.\n * Assumes path is in mutable storage; path is unchanged on exit.\n */\nstatic int\ncreate_dir(struct archive_write_disk *a, char *path)\n{\n\tstruct stat st;\n\tstruct fixup_entry *le;\n\tchar *slash, *base;\n\tmode_t mode_final, mode;\n\tint r;\n\n\t/* Check for special names and just skip them. */\n\tslash = strrchr(path, '/');\n\tif (slash == NULL)\n\t\tbase = path;\n\telse\n\t\tbase = slash + 1;\n\n\tif (base[0] == '\\0' ||\n\t    (base[0] == '.' && base[1] == '\\0') ||\n\t    (base[0] == '.' && base[1] == '.' && base[2] == '\\0')) {\n\t\t/* Don't bother trying to create null path, '.', or '..'. */\n\t\tif (slash != NULL) {\n\t\t\t*slash = '\\0';\n\t\t\tr = create_dir(a, path);\n\t\t\t*slash = '/';\n\t\t\treturn (r);\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Yes, this should be stat() and not lstat().  Using lstat()\n\t * here loses the ability to extract through symlinks.  Also note\n\t * that this should not use the a->st cache.\n\t */\n\tif (stat(path, &st) == 0) {\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\treturn (ARCHIVE_OK);\n\t\tif ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {\n\t\t\tarchive_set_error(&a->archive, EEXIST,\n\t\t\t    \"Can't create directory '%s'\", path);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tif (unlink(path) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't create directory '%s': \"\n\t\t\t    \"Conflicting file cannot be removed\",\n\t\t\t    path);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} else if (errno != ENOENT && errno != ENOTDIR) {\n\t\t/* Stat failed? */\n\t\tarchive_set_error(&a->archive, errno, \"Can't test directory '%s'\", path);\n\t\treturn (ARCHIVE_FAILED);\n\t} else if (slash != NULL) {\n\t\t*slash = '\\0';\n\t\tr = create_dir(a, path);\n\t\t*slash = '/';\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\t/*\n\t * Mode we want for the final restored directory.  Per POSIX,\n\t * implicitly-created dirs must be created obeying the umask.\n\t * There's no mention whether this is different for privileged\n\t * restores (which the rest of this code handles by pretending\n\t * umask=0).  I've chosen here to always obey the user's umask for\n\t * implicit dirs, even if _EXTRACT_PERM was specified.\n\t */\n\tmode_final = DEFAULT_DIR_MODE & ~a->user_umask;\n\t/* Mode we want on disk during the restore process. */\n\tmode = mode_final;\n\tmode |= MINIMUM_DIR_MODE;\n\tmode &= MAXIMUM_DIR_MODE;\n\tif (mkdir(path, mode) == 0) {\n\t\tif (mode != mode_final) {\n\t\t\tle = new_fixup(a, path);\n\t\t\tif (le == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tle->fixup |=TODO_MODE_BASE;\n\t\t\tle->mode = mode_final;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Without the following check, a/b/../b/c/d fails at the\n\t * second visit to 'b', so 'd' can't be created.  Note that we\n\t * don't add it to the fixup list here, as it's already been\n\t * added.\n\t */\n\tif (stat(path, &st) == 0 && S_ISDIR(st.st_mode))\n\t\treturn (ARCHIVE_OK);\n\n\tarchive_set_error(&a->archive, errno, \"Failed to create dir '%s'\",\n\t    path);\n\treturn (ARCHIVE_FAILED);\n}\n\n/*\n * Note: Although we can skip setting the user id if the desired user\n * id matches the current user, we cannot skip setting the group, as\n * many systems set the gid based on the containing directory.  So\n * we have to perform a chown syscall if we want to set the SGID\n * bit.  (The alternative is to stat() and then possibly chown(); it's\n * more efficient to skip the stat() and just always chown().)  Note\n * that a successful chown() here clears the TODO_SGID_CHECK bit, which\n * allows set_mode to skip the stat() check for the GID.\n */\nstatic int\nset_ownership(struct archive_write_disk *a)\n{\n#ifndef __CYGWIN__\n/* unfortunately, on win32 there is no 'root' user with uid 0,\n   so we just have to try the chown and see if it works */\n\n\t/* If we know we can't change it, don't bother trying. */\n\tif (a->user_uid != 0  &&  a->user_uid != a->uid) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Can't set UID=%jd\", (intmax_t)a->uid);\n\t\treturn (ARCHIVE_WARN);\n\t}\n#endif\n\n#ifdef HAVE_FCHOWN\n\t/* If we have an fd, we can avoid a race. */\n\tif (a->fd >= 0 && fchown(a->fd, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\n\t/* We prefer lchown() but will use chown() if that's all we have. */\n\t/* Of course, if we have neither, this will always fail. */\n#ifdef HAVE_LCHOWN\n\tif (lchown(a->name, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#elif HAVE_CHOWN\n\tif (!S_ISLNK(a->mode) && chown(a->name, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\n\tarchive_set_error(&a->archive, errno,\n\t    \"Can't set user=%jd/group=%jd for %s\",\n\t    (intmax_t)a->uid, (intmax_t)a->gid, a->name);\n\treturn (ARCHIVE_WARN);\n}\n\n/*\n * Note: Returns 0 on success, non-zero on failure.\n */\nstatic int\nset_time(int fd, int mode, const char *name,\n    time_t atime, long atime_nsec,\n    time_t mtime, long mtime_nsec)\n{\n\t/* Select the best implementation for this platform. */\n#if defined(HAVE_UTIMENSAT) && defined(HAVE_FUTIMENS)\n\t/*\n\t * utimensat() and futimens() are defined in\n\t * POSIX.1-2008. They support ns resolution and setting times\n\t * on fds and symlinks.\n\t */\n\tstruct timespec ts[2];\n\t(void)mode; /* UNUSED */\n\tts[0].tv_sec = atime;\n\tts[0].tv_nsec = atime_nsec;\n\tts[1].tv_sec = mtime;\n\tts[1].tv_nsec = mtime_nsec;\n\tif (fd >= 0)\n\t\treturn futimens(fd, ts);\n\treturn utimensat(AT_FDCWD, name, ts, AT_SYMLINK_NOFOLLOW);\n\n#elif HAVE_UTIMES\n\t/*\n\t * The utimes()-family functions support \u00b5s-resolution and\n\t * setting times fds and symlinks.  utimes() is documented as\n\t * LEGACY by POSIX, futimes() and lutimes() are not described\n\t * in POSIX.\n\t */\n\tstruct timeval times[2];\n\n\ttimes[0].tv_sec = atime;\n\ttimes[0].tv_usec = atime_nsec / 1000;\n\ttimes[1].tv_sec = mtime;\n\ttimes[1].tv_usec = mtime_nsec / 1000;\n\n#ifdef HAVE_FUTIMES\n\tif (fd >= 0)\n\t\treturn (futimes(fd, times));\n#else\n\t(void)fd; /* UNUSED */\n#endif\n#ifdef HAVE_LUTIMES\n\t(void)mode; /* UNUSED */\n\treturn (lutimes(name, times));\n#else\n\tif (S_ISLNK(mode))\n\t\treturn (0);\n\treturn (utimes(name, times));\n#endif\n\n#elif defined(HAVE_UTIME)\n\t/*\n\t * utime() is POSIX-standard but only supports 1s resolution and\n\t * does not support fds or symlinks.\n\t */\n\tstruct utimbuf times;\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)atime_nsec; /* UNUSED */\n\t(void)mtime_nsec; /* UNUSED */\n\ttimes.actime = atime;\n\ttimes.modtime = mtime;\n\tif (S_ISLNK(mode))\n\t\treturn (ARCHIVE_OK);\n\treturn (utime(name, &times));\n\n#else\n\t/*\n\t * We don't know how to set the time on this platform.\n\t */\n\t(void)fd; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)atime_nsec; /* UNUSED */\n\t(void)mtime_nsec; /* UNUSED */\n\treturn (ARCHIVE_WARN);\n#endif\n}\n\n#ifdef F_SETTIMES\nstatic int\nset_time_tru64(int fd, int mode, const char *name,\n    time_t atime, long atime_nsec,\n    time_t mtime, long mtime_nsec,\n    time_t ctime, long ctime_nsec)\n{\n\tstruct attr_timbuf tstamp;\n\ttstamp.atime.tv_sec = atime;\n\ttstamp.mtime.tv_sec = mtime;\n\ttstamp.ctime.tv_sec = ctime;\n#if defined (__hpux) && defined (__ia64)\n\ttstamp.atime.tv_nsec = atime_nsec;\n\ttstamp.mtime.tv_nsec = mtime_nsec;\n\ttstamp.ctime.tv_nsec = ctime_nsec;\n#else\n\ttstamp.atime.tv_usec = atime_nsec / 1000;\n\ttstamp.mtime.tv_usec = mtime_nsec / 1000;\n\ttstamp.ctime.tv_usec = ctime_nsec / 1000;\n#endif\n\treturn (fcntl(fd,F_SETTIMES,&tstamp));\n}\n#endif /* F_SETTIMES */\n\nstatic int\nset_times(struct archive_write_disk *a,\n    int fd, int mode, const char *name,\n    time_t atime, long atime_nanos,\n    time_t birthtime, long birthtime_nanos,\n    time_t mtime, long mtime_nanos,\n    time_t cctime, long ctime_nanos)\n{\n\t/* Note: set_time doesn't use libarchive return conventions!\n\t * It uses syscall conventions.  So 0 here instead of ARCHIVE_OK. */\n\tint r1 = 0, r2 = 0;\n\n#ifdef F_SETTIMES\n\t /*\n\t * on Tru64 try own fcntl first which can restore even the\n\t * ctime, fall back to default code path below if it fails\n\t * or if we are not running as root\n\t */\n\tif (a->user_uid == 0 &&\n\t    set_time_tru64(fd, mode, name,\n\t\t\t   atime, atime_nanos, mtime,\n\t\t\t   mtime_nanos, cctime, ctime_nanos) == 0) {\n\t\treturn (ARCHIVE_OK);\n\t}\n#else /* Tru64 */\n\t(void)cctime; /* UNUSED */\n\t(void)ctime_nanos; /* UNUSED */\n#endif /* Tru64 */\n\n#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME\n\t/*\n\t * If you have struct stat.st_birthtime, we assume BSD\n\t * birthtime semantics, in which {f,l,}utimes() updates\n\t * birthtime to earliest mtime.  So we set the time twice,\n\t * first using the birthtime, then using the mtime.  If\n\t * birthtime == mtime, this isn't necessary, so we skip it.\n\t * If birthtime > mtime, then this won't work, so we skip it.\n\t */\n\tif (birthtime < mtime\n\t    || (birthtime == mtime && birthtime_nanos < mtime_nanos))\n\t\tr1 = set_time(fd, mode, name,\n\t\t\t      atime, atime_nanos,\n\t\t\t      birthtime, birthtime_nanos);\n#else\n\t(void)birthtime; /* UNUSED */\n\t(void)birthtime_nanos; /* UNUSED */\n#endif\n\tr2 = set_time(fd, mode, name,\n\t\t      atime, atime_nanos,\n\t\t      mtime, mtime_nanos);\n\tif (r1 != 0 || r2 != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Can't restore time\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_times_from_entry(struct archive_write_disk *a)\n{\n\ttime_t atime, birthtime, mtime, cctime;\n\tlong atime_nsec, birthtime_nsec, mtime_nsec, ctime_nsec;\n\n\t/* Suitable defaults. */\n\tatime = birthtime = mtime = cctime = a->start_time;\n\tatime_nsec = birthtime_nsec = mtime_nsec = ctime_nsec = 0;\n\n\t/* If no time was provided, we're done. */\n\tif (!archive_entry_atime_is_set(a->entry)\n#if HAVE_STRUCT_STAT_ST_BIRTHTIME\n\t    && !archive_entry_birthtime_is_set(a->entry)\n#endif\n\t    && !archive_entry_mtime_is_set(a->entry))\n\t\treturn (ARCHIVE_OK);\n\n\tif (archive_entry_atime_is_set(a->entry)) {\n\t\tatime = archive_entry_atime(a->entry);\n\t\tatime_nsec = archive_entry_atime_nsec(a->entry);\n\t}\n\tif (archive_entry_birthtime_is_set(a->entry)) {\n\t\tbirthtime = archive_entry_birthtime(a->entry);\n\t\tbirthtime_nsec = archive_entry_birthtime_nsec(a->entry);\n\t}\n\tif (archive_entry_mtime_is_set(a->entry)) {\n\t\tmtime = archive_entry_mtime(a->entry);\n\t\tmtime_nsec = archive_entry_mtime_nsec(a->entry);\n\t}\n\tif (archive_entry_ctime_is_set(a->entry)) {\n\t\tcctime = archive_entry_ctime(a->entry);\n\t\tctime_nsec = archive_entry_ctime_nsec(a->entry);\n\t}\n\n\treturn set_times(a, a->fd, a->mode, a->name,\n\t\t\t atime, atime_nsec,\n\t\t\t birthtime, birthtime_nsec,\n\t\t\t mtime, mtime_nsec,\n\t\t\t cctime, ctime_nsec);\n}\n\nstatic int\nset_mode(struct archive_write_disk *a, int mode)\n{\n\tint r = ARCHIVE_OK;\n\tmode &= 07777; /* Strip off file type bits. */\n\n\tif (a->todo & TODO_SGID_CHECK) {\n\t\t/*\n\t\t * If we don't know the GID is right, we must stat()\n\t\t * to verify it.  We can't just check the GID of this\n\t\t * process, since systems sometimes set GID from\n\t\t * the enclosing dir or based on ACLs.\n\t\t */\n\t\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tif (a->pst->st_gid != a->gid) {\n\t\t\tmode &= ~ S_ISGID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\t/*\n\t\t\t\t * This is only an error if you\n\t\t\t\t * requested owner restore.  If you\n\t\t\t\t * didn't, we'll try to restore\n\t\t\t\t * sgid/suid, but won't consider it a\n\t\t\t\t * problem if we can't.\n\t\t\t\t */\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't restore SGID bit\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\t/* While we're here, double-check the UID. */\n\t\tif (a->pst->st_uid != a->uid\n\t\t    && (a->todo & TODO_SUID)) {\n\t\t\tmode &= ~ S_ISUID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't restore SUID bit\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\ta->todo &= ~TODO_SGID_CHECK;\n\t\ta->todo &= ~TODO_SUID_CHECK;\n\t} else if (a->todo & TODO_SUID_CHECK) {\n\t\t/*\n\t\t * If we don't know the UID is right, we can just check\n\t\t * the user, since all systems set the file UID from\n\t\t * the process UID.\n\t\t */\n\t\tif (a->user_uid != a->uid) {\n\t\t\tmode &= ~ S_ISUID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't make file SUID\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\ta->todo &= ~TODO_SUID_CHECK;\n\t}\n\n\tif (S_ISLNK(a->mode)) {\n#ifdef HAVE_LCHMOD\n\t\t/*\n\t\t * If this is a symlink, use lchmod().  If the\n\t\t * platform doesn't support lchmod(), just skip it.  A\n\t\t * platform that doesn't provide a way to set\n\t\t * permissions on symlinks probably ignores\n\t\t * permissions on symlinks, so a failure here has no\n\t\t * impact.\n\t\t */\n\t\tif (lchmod(a->name, mode) != 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase ENOTSUP:\n\t\t\tcase ENOSYS:\n#if ENOTSUP != EOPNOTSUPP\n\t\t\tcase EOPNOTSUPP:\n#endif\n\t\t\t\t/*\n\t\t\t\t * if lchmod is defined but the platform\n\t\t\t\t * doesn't support it, silently ignore\n\t\t\t\t * error\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n#endif\n\t} else if (!S_ISDIR(a->mode)) {\n\t\t/*\n\t\t * If it's not a symlink and not a dir, then use\n\t\t * fchmod() or chmod(), depending on whether we have\n\t\t * an fd.  Dirs get their perms set during the\n\t\t * post-extract fixup, which is handled elsewhere.\n\t\t */\n#ifdef HAVE_FCHMOD\n\t\tif (a->fd >= 0) {\n\t\t\tif (fchmod(a->fd, mode) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n#endif\n\t\t\t/* If this platform lacks fchmod(), then\n\t\t\t * we'll just use chmod(). */\n\t\t\tif (chmod(a->name, mode) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t}\n\treturn (r);\n}\n\nstatic int\nset_fflags(struct archive_write_disk *a)\n{\n\tstruct fixup_entry *le;\n\tunsigned long\tset, clear;\n\tint\t\tr;\n\tint\t\tcritical_flags;\n\tmode_t\t\tmode = archive_entry_mode(a->entry);\n\n\t/*\n\t * Make 'critical_flags' hold all file flags that can't be\n\t * immediately restored.  For example, on BSD systems,\n\t * SF_IMMUTABLE prevents hardlinks from being created, so\n\t * should not be set until after any hardlinks are created.  To\n\t * preserve some semblance of portability, this uses #ifdef\n\t * extensively.  Ugly, but it works.\n\t *\n\t * Yes, Virginia, this does create a security race.  It's mitigated\n\t * somewhat by the practice of creating dirs 0700 until the extract\n\t * is done, but it would be nice if we could do more than that.\n\t * People restoring critical file systems should be wary of\n\t * other programs that might try to muck with files as they're\n\t * being restored.\n\t */\n\t/* Hopefully, the compiler will optimize this mess into a constant. */\n\tcritical_flags = 0;\n#ifdef SF_IMMUTABLE\n\tcritical_flags |= SF_IMMUTABLE;\n#endif\n#ifdef UF_IMMUTABLE\n\tcritical_flags |= UF_IMMUTABLE;\n#endif\n#ifdef SF_APPEND\n\tcritical_flags |= SF_APPEND;\n#endif\n#ifdef UF_APPEND\n\tcritical_flags |= UF_APPEND;\n#endif\n#ifdef EXT2_APPEND_FL\n\tcritical_flags |= EXT2_APPEND_FL;\n#endif\n#ifdef EXT2_IMMUTABLE_FL\n\tcritical_flags |= EXT2_IMMUTABLE_FL;\n#endif\n\n\tif (a->todo & TODO_FFLAGS) {\n\t\tarchive_entry_fflags(a->entry, &set, &clear);\n\n\t\t/*\n\t\t * The first test encourages the compiler to eliminate\n\t\t * all of this if it's not necessary.\n\t\t */\n\t\tif ((critical_flags != 0)  &&  (set & critical_flags)) {\n\t\t\tle = current_fixup(a, a->name);\n\t\t\tif (le == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tle->fixup |= TODO_FFLAGS;\n\t\t\tle->fflags_set = set;\n\t\t\t/* Store the mode if it's not already there. */\n\t\t\tif ((le->fixup & TODO_MODE) == 0)\n\t\t\t\tle->mode = mode;\n\t\t} else {\n\t\t\tr = set_fflags_platform(a, a->fd,\n\t\t\t    a->name, mode, set, clear);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nclear_nochange_fflags(struct archive_write_disk *a)\n{\n\tint\t\tnochange_flags;\n\tmode_t\t\tmode = archive_entry_mode(a->entry);\n\n\t/* Hopefully, the compiler will optimize this mess into a constant. */\n\tnochange_flags = 0;\n#ifdef SF_IMMUTABLE\n\tnochange_flags |= SF_IMMUTABLE;\n#endif\n#ifdef UF_IMMUTABLE\n\tnochange_flags |= UF_IMMUTABLE;\n#endif\n#ifdef SF_APPEND\n\tnochange_flags |= SF_APPEND;\n#endif\n#ifdef UF_APPEND\n\tnochange_flags |= UF_APPEND;\n#endif\n#ifdef EXT2_APPEND_FL\n\tnochange_flags |= EXT2_APPEND_FL;\n#endif\n#ifdef EXT2_IMMUTABLE_FL\n\tnochange_flags |= EXT2_IMMUTABLE_FL;\n#endif\n\n\treturn (set_fflags_platform(a, a->fd, a->name, mode, 0, nochange_flags));\n}\n\n\n#if ( defined(HAVE_LCHFLAGS) || defined(HAVE_CHFLAGS) || defined(HAVE_FCHFLAGS) ) && defined(HAVE_STRUCT_STAT_ST_FLAGS)\n/*\n * BSD reads flags using stat() and sets them with one of {f,l,}chflags()\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint r;\n\n\t(void)mode; /* UNUSED */\n\tif (set == 0  && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * XXX Is the stat here really necessary?  Or can I just use\n\t * the 'set' flags directly?  In particular, I'm not sure\n\t * about the correct approach if we're overwriting an existing\n\t * file that already has flags on it. XXX\n\t */\n\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\treturn (r);\n\n\ta->st.st_flags &= ~clear;\n\ta->st.st_flags |= set;\n#ifdef HAVE_FCHFLAGS\n\t/* If platform has fchflags() and we were given an fd, use it. */\n\tif (fd >= 0 && fchflags(fd, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#endif\n\t/*\n\t * If we can't use the fd to set the flags, we'll use the\n\t * pathname to set flags.  We prefer lchflags() but will use\n\t * chflags() if we must.\n\t */\n#ifdef HAVE_LCHFLAGS\n\tif (lchflags(name, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#elif defined(HAVE_CHFLAGS)\n\tif (S_ISLNK(a->st.st_mode)) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Can't set file flags on symlink.\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (chflags(name, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#endif\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\treturn (ARCHIVE_WARN);\n}\n\n#elif defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(HAVE_WORKING_EXT2_IOC_GETFLAGS)\n/*\n * Linux uses ioctl() to read and write file flags.\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tint sf_mask = 0;\n\n\tif (set == 0  && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\t/* Only regular files and dirs can have flags. */\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\n\t/* If we weren't given an fd, open it ourselves. */\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * Linux has no define for the flags that are only settable by\n\t * the root user.  This code may seem a little complex, but\n\t * there seem to be some Linux systems that lack these\n\t * defines. (?)  The code below degrades reasonably gracefully\n\t * if sf_mask is incomplete.\n\t */\n#ifdef EXT2_IMMUTABLE_FL\n\tsf_mask |= EXT2_IMMUTABLE_FL;\n#endif\n#ifdef EXT2_APPEND_FL\n\tsf_mask |= EXT2_APPEND_FL;\n#endif\n\t/*\n\t * XXX As above, this would be way simpler if we didn't have\n\t * to read the current flags from disk. XXX\n\t */\n\tret = ARCHIVE_OK;\n\n\t/* Read the current file flags. */\n\tif (ioctl(myfd, EXT2_IOC_GETFLAGS, &oldflags) < 0)\n\t\tgoto fail;\n\n\t/* Try setting the flags as given. */\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\n\t/* If we couldn't set all the flags, try again with a subset. */\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)\n\t\tgoto cleanup;\n\n\t/* We couldn't set the flags, so report the failure. */\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}\n\n#else\n\n/*\n * Of course, some systems have neither BSD chflags() nor Linux' flags\n * support through ioctl().\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\n#endif /* __linux */\n\n#ifndef HAVE_COPYFILE_H\n/* Default is to simply drop Mac extended metadata. */\nstatic int\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\t(void)metadata; /* UNUSED */\n\t(void)metadata_size; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nfixup_appledouble(struct archive_write_disk *a, const char *pathname)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n#else\n\n/*\n * On Mac OS, we use copyfile() to unpack the metadata and\n * apply it to the target file.\n */\n\n#if defined(HAVE_SYS_XATTR_H)\nstatic int\ncopy_xattrs(struct archive_write_disk *a, int tmpfd, int dffd)\n{\n\tssize_t xattr_size;\n\tchar *xattr_names = NULL, *xattr_val = NULL;\n\tint ret = ARCHIVE_OK, xattr_i;\n\n\txattr_size = flistxattr(tmpfd, NULL, 0, 0);\n\tif (xattr_size == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read metadata(xattr)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_xattr;\n\t}\n\txattr_names = malloc(xattr_size);\n\tif (xattr_names == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for metadata(xattr)\");\n\t\tret = ARCHIVE_FATAL;\n\t\tgoto exit_xattr;\n\t}\n\txattr_size = flistxattr(tmpfd, xattr_names, xattr_size, 0);\n\tif (xattr_size == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read metadata(xattr)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_xattr;\n\t}\n\tfor (xattr_i = 0; xattr_i < xattr_size;\n\t    xattr_i += strlen(xattr_names + xattr_i) + 1) {\n\t\tchar *xattr_val_saved;\n\t\tssize_t s;\n\t\tint f;\n\n\t\ts = fgetxattr(tmpfd, xattr_names + xattr_i, NULL, 0, 0, 0);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\txattr_val_saved = xattr_val;\n\t\txattr_val = realloc(xattr_val, s);\n\t\tif (xattr_val == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tfree(xattr_val_saved);\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\ts = fgetxattr(tmpfd, xattr_names + xattr_i, xattr_val, s, 0, 0);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\tf = fsetxattr(dffd, xattr_names + xattr_i, xattr_val, s, 0, 0);\n\t\tif (f == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t}\nexit_xattr:\n\tfree(xattr_names);\n\tfree(xattr_val);\n\treturn (ret);\n}\n#endif\n\nstatic int\ncopy_acls(struct archive_write_disk *a, int tmpfd, int dffd)\n{\n#ifndef HAVE_SYS_ACL_H\n\treturn 0;\n#else\n\tacl_t acl, dfacl = NULL;\n\tint acl_r, ret = ARCHIVE_OK;\n\n\tacl = acl_get_fd(tmpfd);\n\tif (acl == NULL) {\n\t\tif (errno == ENOENT)\n\t\t\t/* There are not any ACLs. */\n\t\t\treturn (ret);\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get metadata(acl)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_acl;\n\t}\n\tdfacl = acl_dup(acl);\n\tacl_r = acl_set_fd(dffd, dfacl);\n\tif (acl_r == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get metadata(acl)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_acl;\n\t}\nexit_acl:\n\tif (acl)\n\t\tacl_free(acl);\n\tif (dfacl)\n\t\tacl_free(dfacl);\n\treturn (ret);\n#endif\n}\n\nstatic int\ncreate_tempdatafork(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct archive_string tmpdatafork;\n\tint tmpfd;\n\n\tarchive_string_init(&tmpdatafork);\n\tarchive_strcpy(&tmpdatafork, \"tar.md.XXXXXX\");\n\ttmpfd = mkstemp(tmpdatafork.s);\n\tif (tmpfd < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to mkstemp\");\n\t\tarchive_string_free(&tmpdatafork);\n\t\treturn (-1);\n\t}\n\tif (copyfile(pathname, tmpdatafork.s, 0,\n\t    COPYFILE_UNPACK | COPYFILE_NOFOLLOW\n\t    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to restore metadata\");\n\t\tclose(tmpfd);\n\t\ttmpfd = -1;\n\t}\n\tunlink(tmpdatafork.s);\n\tarchive_string_free(&tmpdatafork);\n\treturn (tmpfd);\n}\n\nstatic int\ncopy_metadata(struct archive_write_disk *a, const char *metadata,\n    const char *datafork, int datafork_compressed)\n{\n\tint ret = ARCHIVE_OK;\n\n\tif (datafork_compressed) {\n\t\tint dffd, tmpfd;\n\n\t\ttmpfd = create_tempdatafork(a, metadata);\n\t\tif (tmpfd == -1)\n\t\t\treturn (ARCHIVE_WARN);\n\n\t\t/*\n\t\t * Do not open the data fork compressed by HFS+ compression\n\t\t * with at least a writing mode(O_RDWR or O_WRONLY). it\n\t\t * makes the data fork uncompressed.\n\t\t */\n\t\tdffd = open(datafork, 0);\n\t\tif (dffd == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to open the data fork for metadata\");\n\t\t\tclose(tmpfd);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n#if defined(HAVE_SYS_XATTR_H)\n\t\tret = copy_xattrs(a, tmpfd, dffd);\n\t\tif (ret == ARCHIVE_OK)\n#endif\n\t\t\tret = copy_acls(a, tmpfd, dffd);\n\t\tclose(tmpfd);\n\t\tclose(dffd);\n\t} else {\n\t\tif (copyfile(metadata, datafork, 0,\n\t\t    COPYFILE_UNPACK | COPYFILE_NOFOLLOW\n\t\t    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to restore metadata\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\tstruct archive_string tmp;\n\tssize_t written;\n\tint fd;\n\tint ret = ARCHIVE_OK;\n\n\t/* This would be simpler if copyfile() could just accept the\n\t * metadata as a block of memory; then we could sidestep this\n\t * silly dance of writing the data to disk just so that\n\t * copyfile() can read it back in again. */\n\tarchive_string_init(&tmp);\n\tarchive_strcpy(&tmp, pathname);\n\tarchive_strcat(&tmp, \".XXXXXX\");\n\tfd = mkstemp(tmp.s);\n\n\tif (fd < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Failed to restore metadata\");\n\t\tarchive_string_free(&tmp);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\twritten = write(fd, metadata, metadata_size);\n\tclose(fd);\n\tif ((size_t)written != metadata_size) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Failed to restore metadata\");\n\t\tret = ARCHIVE_WARN;\n\t} else {\n\t\tint compressed;\n\n#if defined(UF_COMPRESSED)\n\t\tif ((a->todo & TODO_HFS_COMPRESSION) != 0 &&\n\t\t    (ret = lazy_stat(a)) == ARCHIVE_OK)\n\t\t\tcompressed = a->st.st_flags & UF_COMPRESSED;\n\t\telse\n#endif\n\t\t\tcompressed = 0;\n\t\tret = copy_metadata(a, tmp.s, pathname, compressed);\n\t}\n\tunlink(tmp.s);\n\tarchive_string_free(&tmp);\n\treturn (ret);\n}\n\nstatic int\nfixup_appledouble(struct archive_write_disk *a, const char *pathname)\n{\n\tchar buff[8];\n\tstruct stat st;\n\tconst char *p;\n\tstruct archive_string datafork;\n\tint fd = -1, ret = ARCHIVE_OK;\n\n\tarchive_string_init(&datafork);\n\t/* Check if the current file name is a type of the resource\n\t * fork file. */\n\tp = strrchr(pathname, '/');\n\tif (p == NULL)\n\t\tp = pathname;\n\telse\n\t\tp++;\n\tif (p[0] != '.' || p[1] != '_')\n\t\tgoto skip_appledouble;\n\n\t/*\n\t * Check if the data fork file exists.\n\t *\n\t * TODO: Check if this write disk object has handled it.\n\t */\n\tarchive_strncpy(&datafork, pathname, p - pathname);\n\tarchive_strcat(&datafork, p + 2);\n\tif (lstat(datafork.s, &st) == -1 ||\n\t    (st.st_mode & AE_IFMT) != AE_IFREG)\n\t\tgoto skip_appledouble;\n\n\t/*\n\t * Check if the file is in the AppleDouble form.\n\t */\n\tfd = open(pathname, O_RDONLY | O_BINARY | O_CLOEXEC);\n\t__archive_ensure_cloexec_flag(fd);\n\tif (fd == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to open a restoring file\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto skip_appledouble;\n\t}\n\tif (read(fd, buff, 8) == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read a restoring file\");\n\t\tclose(fd);\n\t\tret = ARCHIVE_WARN;\n\t\tgoto skip_appledouble;\n\t}\n\tclose(fd);\n\t/* Check AppleDouble Magic Code. */\n\tif (archive_be32dec(buff) != 0x00051607)\n\t\tgoto skip_appledouble;\n\t/* Check AppleDouble Version. */\n\tif (archive_be32dec(buff+4) != 0x00020000)\n\t\tgoto skip_appledouble;\n\n\tret = copy_metadata(a, pathname, datafork.s,\n#if defined(UF_COMPRESSED)\n\t    st.st_flags & UF_COMPRESSED);\n#else\n\t    0);\n#endif\n\tif (ret == ARCHIVE_OK) {\n\t\tunlink(pathname);\n\t\tret = ARCHIVE_EOF;\n\t}\nskip_appledouble:\n\tarchive_string_free(&datafork);\n\treturn (ret);\n}\n#endif\n\n#if HAVE_LSETXATTR || HAVE_LSETEA\n/*\n * Restore extended attributes -  Linux and AIX implementations:\n * AIX' ea interface is syntaxwise identical to the Linux xattr interface.\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstruct archive_entry *entry = a->entry;\n\tstatic int warning_done = 0;\n\tint ret = ARCHIVE_OK;\n\tint i = archive_entry_xattr_reset(entry);\n\n\twhile (i--) {\n\t\tconst char *name;\n\t\tconst void *value;\n\t\tsize_t size;\n\t\tarchive_entry_xattr_next(entry, &name, &value, &size);\n\t\tif (name != NULL &&\n\t\t\t\tstrncmp(name, \"xfsroot.\", 8) != 0 &&\n\t\t\t\tstrncmp(name, \"system.\", 7) != 0) {\n\t\t\tint e;\n#if HAVE_FSETXATTR\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = fsetxattr(a->fd, name, value, size, 0);\n\t\t\telse\n#elif HAVE_FSETEA\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = fsetea(a->fd, name, value, size, 0);\n\t\t\telse\n#endif\n\t\t\t{\n#if HAVE_LSETXATTR\n\t\t\t\te = lsetxattr(archive_entry_pathname(entry),\n\t\t\t\t    name, value, size, 0);\n#elif HAVE_LSETEA\n\t\t\t\te = lsetea(archive_entry_pathname(entry),\n\t\t\t\t    name, value, size, 0);\n#endif\n\t\t\t}\n\t\t\tif (e == -1) {\n\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {\n\t\t\t\t\tif (!warning_done) {\n\t\t\t\t\t\twarning_done = 1;\n\t\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t    \"Cannot restore extended \"\n\t\t\t\t\t\t    \"attributes on this file \"\n\t\t\t\t\t\t    \"system\");\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to set extended attribute\");\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Invalid extended attribute encountered\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\treturn (ret);\n}\n#elif HAVE_EXTATTR_SET_FILE && HAVE_DECL_EXTATTR_NAMESPACE_USER\n/*\n * Restore extended attributes -  FreeBSD implementation\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstruct archive_entry *entry = a->entry;\n\tstatic int warning_done = 0;\n\tint ret = ARCHIVE_OK;\n\tint i = archive_entry_xattr_reset(entry);\n\n\twhile (i--) {\n\t\tconst char *name;\n\t\tconst void *value;\n\t\tsize_t size;\n\t\tarchive_entry_xattr_next(entry, &name, &value, &size);\n\t\tif (name != NULL) {\n\t\t\tint e;\n\t\t\tint namespace;\n\n\t\t\tif (strncmp(name, \"user.\", 5) == 0) {\n\t\t\t\t/* \"user.\" attributes go to user namespace */\n\t\t\t\tname += 5;\n\t\t\t\tnamespace = EXTATTR_NAMESPACE_USER;\n\t\t\t} else {\n\t\t\t\t/* Warn about other extended attributes. */\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Can't restore extended attribute ``%s''\",\n\t\t\t\t    name);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terrno = 0;\n#if HAVE_EXTATTR_SET_FD\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = extattr_set_fd(a->fd, namespace, name, value, size);\n\t\t\telse\n#endif\n\t\t\t/* TODO: should we use extattr_set_link() instead? */\n\t\t\t{\n\t\t\t\te = extattr_set_file(archive_entry_pathname(entry),\n\t\t\t\t    namespace, name, value, size);\n\t\t\t}\n\t\t\tif (e != (int)size) {\n\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {\n\t\t\t\t\tif (!warning_done) {\n\t\t\t\t\t\twarning_done = 1;\n\t\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t    \"Cannot restore extended \"\n\t\t\t\t\t\t    \"attributes on this file \"\n\t\t\t\t\t\t    \"system\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to set extended attribute\");\n\t\t\t\t}\n\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n\treturn (ret);\n}\n#else\n/*\n * Restore extended attributes - stub implementation for unsupported systems\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstatic int warning_done = 0;\n\n\t/* If there aren't any extended attributes, then it's okay not\n\t * to extract them, otherwise, issue a single warning. */\n\tif (archive_entry_xattr_count(a->entry) != 0 && !warning_done) {\n\t\twarning_done = 1;\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Cannot restore extended attributes on this system\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\t/* Warning was already emitted; suppress further warnings. */\n\treturn (ARCHIVE_OK);\n}\n#endif\n\n/*\n * Test if file on disk is older than entry.\n */\nstatic int\nolder(struct stat *st, struct archive_entry *entry)\n{\n\t/* First, test the seconds and return if we have a definite answer. */\n\t/* Definitely older. */\n\tif (st->st_mtime < archive_entry_mtime(entry))\n\t\treturn (1);\n\t/* Definitely younger. */\n\tif (st->st_mtime > archive_entry_mtime(entry))\n\t\treturn (0);\n\t/* If this platform supports fractional seconds, try those. */\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\t/* Definitely older. */\n\tif (st->st_mtimespec.tv_nsec < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t/* Definitely older. */\n\tif (st->st_mtim.tv_nsec < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIME_N\n\t/* older. */\n\tif (st->st_mtime_n < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_UMTIME\n\t/* older. */\n\tif (st->st_umtime * 1000 < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIME_USEC\n\t/* older. */\n\tif (st->st_mtime_usec * 1000 < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#else\n\t/* This system doesn't have high-res timestamps. */\n#endif\n\t/* Same age or newer, so not older. */\n\treturn (0);\n}\n\n#endif /* !_WIN32 || __CYGWIN__ */\n\n"], "fixing_code": ["/*-\n * Copyright (c) 2003-2010 Tim Kientzle\n * Copyright (c) 2012 Michihiro NAKAJIMA\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer\n *    in this position and unchanged.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"archive_platform.h\"\n__FBSDID(\"$FreeBSD$\");\n\n#if !defined(_WIN32) || defined(__CYGWIN__)\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_ACL_H\n#include <sys/acl.h>\n#endif\n#ifdef HAVE_SYS_EXTATTR_H\n#include <sys/extattr.h>\n#endif\n#if defined(HAVE_SYS_XATTR_H)\n#include <sys/xattr.h>\n#elif defined(HAVE_ATTR_XATTR_H)\n#include <attr/xattr.h>\n#endif\n#ifdef HAVE_SYS_EA_H\n#include <sys/ea.h>\n#endif\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_UTIME_H\n#include <sys/utime.h>\n#endif\n#ifdef HAVE_COPYFILE_H\n#include <copyfile.h>\n#endif\n#ifdef HAVE_ERRNO_H\n#include <errno.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#ifdef HAVE_LANGINFO_H\n#include <langinfo.h>\n#endif\n#ifdef HAVE_LINUX_FS_H\n#include <linux/fs.h>\t/* for Linux file flags */\n#endif\n/*\n * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.\n * As the include guards don't agree, the order of include is important.\n */\n#ifdef HAVE_LINUX_EXT2_FS_H\n#include <linux/ext2_fs.h>\t/* for Linux file flags */\n#endif\n#if defined(HAVE_EXT2FS_EXT2_FS_H) && !defined(__CYGWIN__)\n#include <ext2fs/ext2_fs.h>\t/* Linux file flags, broken on Cygwin */\n#endif\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\n#endif\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_UTIME_H\n#include <utime.h>\n#endif\n#ifdef F_GETTIMES /* Tru64 specific */\n#include <sys/fcntl1.h>\n#endif\n\n#if __APPLE__\n#include <TargetConditionals.h>\n#if TARGET_OS_MAC && !TARGET_OS_EMBEDDED && HAVE_QUARANTINE_H\n#include <quarantine.h>\n#define HAVE_QUARANTINE 1\n#endif\n#endif\n\n#ifdef HAVE_ZLIB_H\n#include <zlib.h>\n#endif\n\n/* TODO: Support Mac OS 'quarantine' feature.  This is really just a\n * standard tag to mark files that have been downloaded as \"tainted\".\n * On Mac OS, we should mark the extracted files as tainted if the\n * archive being read was tainted.  Windows has a similar feature; we\n * should investigate ways to support this generically. */\n\n#include \"archive.h\"\n#include \"archive_acl_private.h\"\n#include \"archive_string.h\"\n#include \"archive_endian.h\"\n#include \"archive_entry.h\"\n#include \"archive_private.h\"\n#include \"archive_write_disk_private.h\"\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC\t0\n#endif\n\nstruct fixup_entry {\n\tstruct fixup_entry\t*next;\n\tstruct archive_acl\t acl;\n\tmode_t\t\t\t mode;\n\tint64_t\t\t\t atime;\n\tint64_t                  birthtime;\n\tint64_t\t\t\t mtime;\n\tint64_t\t\t\t ctime;\n\tunsigned long\t\t atime_nanos;\n\tunsigned long            birthtime_nanos;\n\tunsigned long\t\t mtime_nanos;\n\tunsigned long\t\t ctime_nanos;\n\tunsigned long\t\t fflags_set;\n\tsize_t\t\t\t mac_metadata_size;\n\tvoid\t\t\t*mac_metadata;\n\tint\t\t\t fixup; /* bitmask of what needs fixing */\n\tchar\t\t\t*name;\n};\n\n/*\n * We use a bitmask to track which operations remain to be done for\n * this file.  In particular, this helps us avoid unnecessary\n * operations when it's possible to take care of one step as a\n * side-effect of another.  For example, mkdir() can specify the mode\n * for the newly-created object but symlink() cannot.  This means we\n * can skip chmod() if mkdir() succeeded, but we must explicitly\n * chmod() if we're trying to create a directory that already exists\n * (mkdir() failed) or if we're restoring a symlink.  Similarly, we\n * need to verify UID/GID before trying to restore SUID/SGID bits;\n * that verification can occur explicitly through a stat() call or\n * implicitly because of a successful chown() call.\n */\n#define\tTODO_MODE_FORCE\t\t0x40000000\n#define\tTODO_MODE_BASE\t\t0x20000000\n#define\tTODO_SUID\t\t0x10000000\n#define\tTODO_SUID_CHECK\t\t0x08000000\n#define\tTODO_SGID\t\t0x04000000\n#define\tTODO_SGID_CHECK\t\t0x02000000\n#define\tTODO_APPLEDOUBLE\t0x01000000\n#define\tTODO_MODE\t\t(TODO_MODE_BASE|TODO_SUID|TODO_SGID)\n#define\tTODO_TIMES\t\tARCHIVE_EXTRACT_TIME\n#define\tTODO_OWNER\t\tARCHIVE_EXTRACT_OWNER\n#define\tTODO_FFLAGS\t\tARCHIVE_EXTRACT_FFLAGS\n#define\tTODO_ACLS\t\tARCHIVE_EXTRACT_ACL\n#define\tTODO_XATTR\t\tARCHIVE_EXTRACT_XATTR\n#define\tTODO_MAC_METADATA\tARCHIVE_EXTRACT_MAC_METADATA\n#define\tTODO_HFS_COMPRESSION\tARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED\n\nstruct archive_write_disk {\n\tstruct archive\tarchive;\n\n\tmode_t\t\t\t user_umask;\n\tstruct fixup_entry\t*fixup_list;\n\tstruct fixup_entry\t*current_fixup;\n\tint64_t\t\t\t user_uid;\n\tint\t\t\t skip_file_set;\n\tint64_t\t\t\t skip_file_dev;\n\tint64_t\t\t\t skip_file_ino;\n\ttime_t\t\t\t start_time;\n\n\tint64_t (*lookup_gid)(void *private, const char *gname, int64_t gid);\n\tvoid  (*cleanup_gid)(void *private);\n\tvoid\t\t\t*lookup_gid_data;\n\tint64_t (*lookup_uid)(void *private, const char *uname, int64_t uid);\n\tvoid  (*cleanup_uid)(void *private);\n\tvoid\t\t\t*lookup_uid_data;\n\n\t/*\n\t * Full path of last file to satisfy symlink checks.\n\t */\n\tstruct archive_string\tpath_safe;\n\n\t/*\n\t * Cached stat data from disk for the current entry.\n\t * If this is valid, pst points to st.  Otherwise,\n\t * pst is null.\n\t */\n\tstruct stat\t\t st;\n\tstruct stat\t\t*pst;\n\n\t/* Information about the object being restored right now. */\n\tstruct archive_entry\t*entry; /* Entry being extracted. */\n\tchar\t\t\t*name; /* Name of entry, possibly edited. */\n\tstruct archive_string\t _name_data; /* backing store for 'name' */\n\t/* Tasks remaining for this object. */\n\tint\t\t\t todo;\n\t/* Tasks deferred until end-of-archive. */\n\tint\t\t\t deferred;\n\t/* Options requested by the client. */\n\tint\t\t\t flags;\n\t/* Handle for the file we're restoring. */\n\tint\t\t\t fd;\n\t/* Current offset for writing data to the file. */\n\tint64_t\t\t\t offset;\n\t/* Last offset actually written to disk. */\n\tint64_t\t\t\t fd_offset;\n\t/* Total bytes actually written to files. */\n\tint64_t\t\t\t total_bytes_written;\n\t/* Maximum size of file, -1 if unknown. */\n\tint64_t\t\t\t filesize;\n\t/* Dir we were in before this restore; only for deep paths. */\n\tint\t\t\t restore_pwd;\n\t/* Mode we should use for this entry; affected by _PERM and umask. */\n\tmode_t\t\t\t mode;\n\t/* UID/GID to use in restoring this entry. */\n\tint64_t\t\t\t uid;\n\tint64_t\t\t\t gid;\n\t/*\n\t * HFS+ Compression.\n\t */\n\t/* Xattr \"com.apple.decmpfs\". */\n\tuint32_t\t\t decmpfs_attr_size;\n\tunsigned char\t\t*decmpfs_header_p;\n\t/* ResourceFork set options used for fsetxattr. */\n\tint\t\t\t rsrc_xattr_options;\n\t/* Xattr \"com.apple.ResourceFork\". */\n\tunsigned char\t\t*resource_fork;\n\tsize_t\t\t\t resource_fork_allocated_size;\n\tunsigned int\t\t decmpfs_block_count;\n\tuint32_t\t\t*decmpfs_block_info;\n\t/* Buffer for compressed data. */\n\tunsigned char\t\t*compressed_buffer;\n\tsize_t\t\t\t compressed_buffer_size;\n\tsize_t\t\t\t compressed_buffer_remaining;\n\t/* The offset of the ResourceFork where compressed data will\n\t * be placed. */\n\tuint32_t\t\t compressed_rsrc_position;\n\tuint32_t\t\t compressed_rsrc_position_v;\n\t/* Buffer for uncompressed data. */\n\tchar\t\t\t*uncompressed_buffer;\n\tsize_t\t\t\t block_remaining_bytes;\n\tsize_t\t\t\t file_remaining_bytes;\n#ifdef HAVE_ZLIB_H\n\tz_stream\t\t stream;\n\tint\t\t\t stream_valid;\n\tint\t\t\t decmpfs_compression_level;\n#endif\n};\n\n/*\n * Default mode for dirs created automatically (will be modified by umask).\n * Note that POSIX specifies 0777 for implicitly-created dirs, \"modified\n * by the process' file creation mask.\"\n */\n#define\tDEFAULT_DIR_MODE 0777\n/*\n * Dir modes are restored in two steps:  During the extraction, the permissions\n * in the archive are modified to match the following limits.  During\n * the post-extract fixup pass, the permissions from the archive are\n * applied.\n */\n#define\tMINIMUM_DIR_MODE 0700\n#define\tMAXIMUM_DIR_MODE 0775\n\n/*\n * Maxinum uncompressed size of a decmpfs block.\n */\n#define MAX_DECMPFS_BLOCK_SIZE\t(64 * 1024)\n/*\n * HFS+ compression type.\n */\n#define CMP_XATTR\t\t3/* Compressed data in xattr. */\n#define CMP_RESOURCE_FORK\t4/* Compressed data in resource fork. */\n/*\n * HFS+ compression resource fork.\n */\n#define RSRC_H_SIZE\t260\t/* Base size of Resource fork header. */\n#define RSRC_F_SIZE\t50\t/* Size of Resource fork footer. */\n/* Size to write compressed data to resource fork. */\n#define COMPRESSED_W_SIZE\t(64 * 1024)\n/* decmpfs difinitions. */\n#define MAX_DECMPFS_XATTR_SIZE\t\t3802\n#ifndef DECMPFS_XATTR_NAME\n#define DECMPFS_XATTR_NAME\t\t\"com.apple.decmpfs\"\n#endif\n#define DECMPFS_MAGIC\t\t\t0x636d7066\n#define DECMPFS_COMPRESSION_MAGIC\t0\n#define DECMPFS_COMPRESSION_TYPE\t4\n#define DECMPFS_UNCOMPRESSED_SIZE\t8\n#define DECMPFS_HEADER_SIZE\t\t16\n\n#define HFS_BLOCKS(s)\t((s) >> 12)\n\nstatic int\tcheck_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);\nstatic int\tcheck_symlinks(struct archive_write_disk *);\nstatic int\tcreate_filesystem_object(struct archive_write_disk *);\nstatic struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\nstatic void\tedit_deep_directories(struct archive_write_disk *ad);\n#endif\nstatic int\tcleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags);\nstatic int\tcleanup_pathname(struct archive_write_disk *);\nstatic int\tcreate_dir(struct archive_write_disk *, char *);\nstatic int\tcreate_parent_dir(struct archive_write_disk *, char *);\nstatic ssize_t\thfs_write_data_block(struct archive_write_disk *,\n\t\t    const char *, size_t);\nstatic int\tfixup_appledouble(struct archive_write_disk *, const char *);\nstatic int\tolder(struct stat *, struct archive_entry *);\nstatic int\trestore_entry(struct archive_write_disk *);\nstatic int\tset_mac_metadata(struct archive_write_disk *, const char *,\n\t\t\t\t const void *, size_t);\nstatic int\tset_xattrs(struct archive_write_disk *);\nstatic int\tclear_nochange_fflags(struct archive_write_disk *);\nstatic int\tset_fflags(struct archive_write_disk *);\nstatic int\tset_fflags_platform(struct archive_write_disk *, int fd,\n\t\t    const char *name, mode_t mode,\n\t\t    unsigned long fflags_set, unsigned long fflags_clear);\nstatic int\tset_ownership(struct archive_write_disk *);\nstatic int\tset_mode(struct archive_write_disk *, int mode);\nstatic int\tset_time(int, int, const char *, time_t, long, time_t, long);\nstatic int\tset_times(struct archive_write_disk *, int, int, const char *,\n\t\t    time_t, long, time_t, long, time_t, long, time_t, long);\nstatic int\tset_times_from_entry(struct archive_write_disk *);\nstatic struct fixup_entry *sort_dir_list(struct fixup_entry *p);\nstatic ssize_t\twrite_data_block(struct archive_write_disk *,\n\t\t    const char *, size_t);\n\nstatic struct archive_vtable *archive_write_disk_vtable(void);\n\nstatic int\t_archive_write_disk_close(struct archive *);\nstatic int\t_archive_write_disk_free(struct archive *);\nstatic int\t_archive_write_disk_header(struct archive *, struct archive_entry *);\nstatic int64_t\t_archive_write_disk_filter_bytes(struct archive *, int);\nstatic int\t_archive_write_disk_finish_entry(struct archive *);\nstatic ssize_t\t_archive_write_disk_data(struct archive *, const void *, size_t);\nstatic ssize_t\t_archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);\n\nstatic int\nlazy_stat(struct archive_write_disk *a)\n{\n\tif (a->pst != NULL) {\n\t\t/* Already have stat() data available. */\n\t\treturn (ARCHIVE_OK);\n\t}\n#ifdef HAVE_FSTAT\n\tif (a->fd >= 0 && fstat(a->fd, &a->st) == 0) {\n\t\ta->pst = &a->st;\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\t/*\n\t * XXX At this point, symlinks should not be hit, otherwise\n\t * XXX a race occurred.  Do we want to check explicitly for that?\n\t */\n\tif (lstat(a->name, &a->st) == 0) {\n\t\ta->pst = &a->st;\n\t\treturn (ARCHIVE_OK);\n\t}\n\tarchive_set_error(&a->archive, errno, \"Couldn't stat file\");\n\treturn (ARCHIVE_WARN);\n}\n\nstatic struct archive_vtable *\narchive_write_disk_vtable(void)\n{\n\tstatic struct archive_vtable av;\n\tstatic int inited = 0;\n\n\tif (!inited) {\n\t\tav.archive_close = _archive_write_disk_close;\n\t\tav.archive_filter_bytes = _archive_write_disk_filter_bytes;\n\t\tav.archive_free = _archive_write_disk_free;\n\t\tav.archive_write_header = _archive_write_disk_header;\n\t\tav.archive_write_finish_entry\n\t\t    = _archive_write_disk_finish_entry;\n\t\tav.archive_write_data = _archive_write_disk_data;\n\t\tav.archive_write_data_block = _archive_write_disk_data_block;\n\t\tinited = 1;\n\t}\n\treturn (&av);\n}\n\nstatic int64_t\n_archive_write_disk_filter_bytes(struct archive *_a, int n)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\t(void)n; /* UNUSED */\n\tif (n == -1 || n == 0)\n\t\treturn (a->total_bytes_written);\n\treturn (-1);\n}\n\n\nint\narchive_write_disk_set_options(struct archive *_a, int flags)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\n\ta->flags = flags;\n\treturn (ARCHIVE_OK);\n}\n\n\n/*\n * Extract this entry to disk.\n *\n * TODO: Validate hardlinks.  According to the standards, we're\n * supposed to check each extracted hardlink and squawk if it refers\n * to a file that we didn't restore.  I'm not entirely convinced this\n * is a good idea, but more importantly: Is there any way to validate\n * hardlinks without keeping a complete list of filenames from the\n * entire archive?? Ugh.\n *\n */\nstatic int\n_archive_write_disk_header(struct archive *_a, struct archive_entry *entry)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *fe;\n\tint ret, r;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_header\");\n\tarchive_clear_error(&a->archive);\n\tif (a->archive.state & ARCHIVE_STATE_DATA) {\n\t\tr = _archive_write_disk_finish_entry(&a->archive);\n\t\tif (r == ARCHIVE_FATAL)\n\t\t\treturn (r);\n\t}\n\n\t/* Set up for this particular entry. */\n\ta->pst = NULL;\n\ta->current_fixup = NULL;\n\ta->deferred = 0;\n\tif (a->entry) {\n\t\tarchive_entry_free(a->entry);\n\t\ta->entry = NULL;\n\t}\n\ta->entry = archive_entry_clone(entry);\n\ta->fd = -1;\n\ta->fd_offset = 0;\n\ta->offset = 0;\n\ta->restore_pwd = -1;\n\ta->uid = a->user_uid;\n\ta->mode = archive_entry_mode(a->entry);\n\tif (archive_entry_size_is_set(a->entry))\n\t\ta->filesize = archive_entry_size(a->entry);\n\telse\n\t\ta->filesize = -1;\n\tarchive_strcpy(&(a->_name_data), archive_entry_pathname(a->entry));\n\ta->name = a->_name_data.s;\n\tarchive_clear_error(&a->archive);\n\n\t/*\n\t * Clean up the requested path.  This is necessary for correct\n\t * dir restores; the dir restore logic otherwise gets messed\n\t * up by nonsense like \"dir/.\".\n\t */\n\tret = cleanup_pathname(a);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\t/*\n\t * Query the umask so we get predictable mode settings.\n\t * This gets done on every call to _write_header in case the\n\t * user edits their umask during the extraction for some\n\t * reason.\n\t */\n\tumask(a->user_umask = umask(0));\n\n\t/* Figure out what we need to do for this entry. */\n\ta->todo = TODO_MODE_BASE;\n\tif (a->flags & ARCHIVE_EXTRACT_PERM) {\n\t\ta->todo |= TODO_MODE_FORCE; /* Be pushy about permissions. */\n\t\t/*\n\t\t * SGID requires an extra \"check\" step because we\n\t\t * cannot easily predict the GID that the system will\n\t\t * assign.  (Different systems assign GIDs to files\n\t\t * based on a variety of criteria, including process\n\t\t * credentials and the gid of the enclosing\n\t\t * directory.)  We can only restore the SGID bit if\n\t\t * the file has the right GID, and we only know the\n\t\t * GID if we either set it (see set_ownership) or if\n\t\t * we've actually called stat() on the file after it\n\t\t * was restored.  Since there are several places at\n\t\t * which we might verify the GID, we need a TODO bit\n\t\t * to keep track.\n\t\t */\n\t\tif (a->mode & S_ISGID)\n\t\t\ta->todo |= TODO_SGID | TODO_SGID_CHECK;\n\t\t/*\n\t\t * Verifying the SUID is simpler, but can still be\n\t\t * done in multiple ways, hence the separate \"check\" bit.\n\t\t */\n\t\tif (a->mode & S_ISUID)\n\t\t\ta->todo |= TODO_SUID | TODO_SUID_CHECK;\n\t} else {\n\t\t/*\n\t\t * User didn't request full permissions, so don't\n\t\t * restore SUID, SGID bits and obey umask.\n\t\t */\n\t\ta->mode &= ~S_ISUID;\n\t\ta->mode &= ~S_ISGID;\n\t\ta->mode &= ~S_ISVTX;\n\t\ta->mode &= ~a->user_umask;\n\t}\n\tif (a->flags & ARCHIVE_EXTRACT_OWNER)\n\t\ta->todo |= TODO_OWNER;\n\tif (a->flags & ARCHIVE_EXTRACT_TIME)\n\t\ta->todo |= TODO_TIMES;\n\tif (a->flags & ARCHIVE_EXTRACT_ACL) {\n\t\tif (archive_entry_filetype(a->entry) == AE_IFDIR)\n\t\t\ta->deferred |= TODO_ACLS;\n\t\telse\n\t\t\ta->todo |= TODO_ACLS;\n\t}\n\tif (a->flags & ARCHIVE_EXTRACT_MAC_METADATA) {\n\t\tif (archive_entry_filetype(a->entry) == AE_IFDIR)\n\t\t\ta->deferred |= TODO_MAC_METADATA;\n\t\telse\n\t\t\ta->todo |= TODO_MAC_METADATA;\n\t}\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\tif ((a->flags & ARCHIVE_EXTRACT_NO_HFS_COMPRESSION) == 0) {\n\t\tunsigned long set, clear;\n\t\tarchive_entry_fflags(a->entry, &set, &clear);\n\t\tif ((set & ~clear) & UF_COMPRESSED) {\n\t\t\ta->todo |= TODO_HFS_COMPRESSION;\n\t\t\ta->decmpfs_block_count = (unsigned)-1;\n\t\t}\n\t}\n\tif ((a->flags & ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED) != 0 &&\n\t    (a->mode & AE_IFMT) == AE_IFREG && a->filesize > 0) {\n\t\ta->todo |= TODO_HFS_COMPRESSION;\n\t\ta->decmpfs_block_count = (unsigned)-1;\n\t}\n\t{\n\t\tconst char *p;\n\n\t\t/* Check if the current file name is a type of the\n\t\t * resource fork file. */\n\t\tp = strrchr(a->name, '/');\n\t\tif (p == NULL)\n\t\t\tp = a->name;\n\t\telse\n\t\t\tp++;\n\t\tif (p[0] == '.' && p[1] == '_') {\n\t\t\t/* Do not compress \"._XXX\" files. */\n\t\t\ta->todo &= ~TODO_HFS_COMPRESSION;\n\t\t\tif (a->filesize > 0)\n\t\t\t\ta->todo |= TODO_APPLEDOUBLE;\n\t\t}\n\t}\n#endif\n\n\tif (a->flags & ARCHIVE_EXTRACT_XATTR)\n\t\ta->todo |= TODO_XATTR;\n\tif (a->flags & ARCHIVE_EXTRACT_FFLAGS)\n\t\ta->todo |= TODO_FFLAGS;\n\tif (a->flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS) {\n\t\tret = check_symlinks(a);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t}\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n\t/* If path exceeds PATH_MAX, shorten the path. */\n\tedit_deep_directories(a);\n#endif\n\n\tret = restore_entry(a);\n\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\t/*\n\t * Check if the filesystem the file is restoring on supports\n\t * HFS+ Compression. If not, cancel HFS+ Compression.\n\t */\n\tif (a->todo | TODO_HFS_COMPRESSION) {\n\t\t/*\n\t\t * NOTE: UF_COMPRESSED is ignored even if the filesystem\n\t\t * supports HFS+ Compression because the file should\n\t\t * have at least an extended attriute \"com.apple.decmpfs\"\n\t\t * before the flag is set to indicate that the file have\n\t\t * been compressed. If hte filesystem does not support\n\t\t * HFS+ Compression the system call will fail.\n\t\t */\n\t\tif (a->fd < 0 || fchflags(a->fd, UF_COMPRESSED) != 0)\n\t\t\ta->todo &= ~TODO_HFS_COMPRESSION;\n\t}\n#endif\n\n\t/*\n\t * TODO: There are rumours that some extended attributes must\n\t * be restored before file data is written.  If this is true,\n\t * then we either need to write all extended attributes both\n\t * before and after restoring the data, or find some rule for\n\t * determining which must go first and which last.  Due to the\n\t * many ways people are using xattrs, this may prove to be an\n\t * intractable problem.\n\t */\n\n#ifdef HAVE_FCHDIR\n\t/* If we changed directory above, restore it here. */\n\tif (a->restore_pwd >= 0) {\n\t\tr = fchdir(a->restore_pwd);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, errno, \"chdir() failure\");\n\t\t\tret = ARCHIVE_FATAL;\n\t\t}\n\t\tclose(a->restore_pwd);\n\t\ta->restore_pwd = -1;\n\t}\n#endif\n\n\t/*\n\t * Fixup uses the unedited pathname from archive_entry_pathname(),\n\t * because it is relative to the base dir and the edited path\n\t * might be relative to some intermediate dir as a result of the\n\t * deep restore logic.\n\t */\n\tif (a->deferred & TODO_MODE) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_MODE_BASE;\n\t\tfe->mode = a->mode;\n\t}\n\n\tif ((a->deferred & TODO_TIMES)\n\t\t&& (archive_entry_mtime_is_set(entry)\n\t\t    || archive_entry_atime_is_set(entry))) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->mode = a->mode;\n\t\tfe->fixup |= TODO_TIMES;\n\t\tif (archive_entry_atime_is_set(entry)) {\n\t\t\tfe->atime = archive_entry_atime(entry);\n\t\t\tfe->atime_nanos = archive_entry_atime_nsec(entry);\n\t\t} else {\n\t\t\t/* If atime is unset, use start time. */\n\t\t\tfe->atime = a->start_time;\n\t\t\tfe->atime_nanos = 0;\n\t\t}\n\t\tif (archive_entry_mtime_is_set(entry)) {\n\t\t\tfe->mtime = archive_entry_mtime(entry);\n\t\t\tfe->mtime_nanos = archive_entry_mtime_nsec(entry);\n\t\t} else {\n\t\t\t/* If mtime is unset, use start time. */\n\t\t\tfe->mtime = a->start_time;\n\t\t\tfe->mtime_nanos = 0;\n\t\t}\n\t\tif (archive_entry_birthtime_is_set(entry)) {\n\t\t\tfe->birthtime = archive_entry_birthtime(entry);\n\t\t\tfe->birthtime_nanos = archive_entry_birthtime_nsec(entry);\n\t\t} else {\n\t\t\t/* If birthtime is unset, use mtime. */\n\t\t\tfe->birthtime = fe->mtime;\n\t\t\tfe->birthtime_nanos = fe->mtime_nanos;\n\t\t}\n\t}\n\n\tif (a->deferred & TODO_ACLS) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_ACLS;\n\t\tarchive_acl_copy(&fe->acl, archive_entry_acl(entry));\n\t}\n\n\tif (a->deferred & TODO_MAC_METADATA) {\n\t\tconst void *metadata;\n\t\tsize_t metadata_size;\n\t\tmetadata = archive_entry_mac_metadata(a->entry, &metadata_size);\n\t\tif (metadata != NULL && metadata_size > 0) {\n\t\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\t\tif (fe == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tfe->mac_metadata = malloc(metadata_size);\n\t\t\tif (fe->mac_metadata != NULL) {\n\t\t\t\tmemcpy(fe->mac_metadata, metadata, metadata_size);\n\t\t\t\tfe->mac_metadata_size = metadata_size;\n\t\t\t\tfe->fixup |= TODO_MAC_METADATA;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a->deferred & TODO_FFLAGS) {\n\t\tfe = current_fixup(a, archive_entry_pathname(entry));\n\t\tif (fe == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfe->fixup |= TODO_FFLAGS;\n\t\t/* TODO: Complete this.. defer fflags from below. */\n\t}\n\n\t/* We've created the object and are ready to pour data into it. */\n\tif (ret >= ARCHIVE_WARN)\n\t\ta->archive.state = ARCHIVE_STATE_DATA;\n\t/*\n\t * If it's not open, tell our client not to try writing.\n\t * In particular, dirs, links, etc, don't get written to.\n\t */\n\tif (a->fd < 0) {\n\t\tarchive_entry_set_size(entry, 0);\n\t\ta->filesize = 0;\n\t}\n\n\treturn (ret);\n}\n\nint\narchive_write_disk_set_skip_file(struct archive *_a, int64_t d, int64_t i)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_skip_file\");\n\ta->skip_file_set = 1;\n\ta->skip_file_dev = d;\n\ta->skip_file_ino = i;\n\treturn (ARCHIVE_OK);\n}\n\nstatic ssize_t\nwrite_data_block(struct archive_write_disk *a, const char *buff, size_t size)\n{\n\tuint64_t start_size = size;\n\tssize_t bytes_written = 0;\n\tssize_t block_size = 0, bytes_to_write;\n\n\tif (size == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (a->filesize == 0 || a->fd < 0) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Attempt to write to an empty file\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tif (a->flags & ARCHIVE_EXTRACT_SPARSE) {\n#if HAVE_STRUCT_STAT_ST_BLKSIZE\n\t\tint r;\n\t\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tblock_size = a->pst->st_blksize;\n#else\n\t\t/* XXX TODO XXX Is there a more appropriate choice here ? */\n\t\t/* This needn't match the filesystem allocation size. */\n\t\tblock_size = 16*1024;\n#endif\n\t}\n\n\t/* If this write would run beyond the file size, truncate it. */\n\tif (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)\n\t\tstart_size = size = (size_t)(a->filesize - a->offset);\n\n\t/* Write the data. */\n\twhile (size > 0) {\n\t\tif (block_size == 0) {\n\t\t\tbytes_to_write = size;\n\t\t} else {\n\t\t\t/* We're sparsifying the file. */\n\t\t\tconst char *p, *end;\n\t\t\tint64_t block_end;\n\n\t\t\t/* Skip leading zero bytes. */\n\t\t\tfor (p = buff, end = buff + size; p < end; ++p) {\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta->offset += p - buff;\n\t\t\tsize -= p - buff;\n\t\t\tbuff = p;\n\t\t\tif (size == 0)\n\t\t\t\tbreak;\n\n\t\t\t/* Calculate next block boundary after offset. */\n\t\t\tblock_end\n\t\t\t    = (a->offset / block_size + 1) * block_size;\n\n\t\t\t/* If the adjusted write would cross block boundary,\n\t\t\t * truncate it to the block boundary. */\n\t\t\tbytes_to_write = size;\n\t\t\tif (a->offset + bytes_to_write > block_end)\n\t\t\t\tbytes_to_write = block_end - a->offset;\n\t\t}\n\t\t/* Seek if necessary to the specified offset. */\n\t\tif (a->offset != a->fd_offset) {\n\t\t\tif (lseek(a->fd, a->offset, SEEK_SET) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Seek failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->fd_offset = a->offset;\n\t\t}\n\t\tbytes_written = write(a->fd, buff, bytes_to_write);\n\t\tif (bytes_written < 0) {\n\t\t\tarchive_set_error(&a->archive, errno, \"Write failed\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tbuff += bytes_written;\n\t\tsize -= bytes_written;\n\t\ta->total_bytes_written += bytes_written;\n\t\ta->offset += bytes_written;\n\t\ta->fd_offset = a->offset;\n\t}\n\treturn (start_size - size);\n}\n\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\\\n\t&& defined(HAVE_ZLIB_H)\n\n/*\n * Set UF_COMPRESSED file flag.\n * This have to be called after hfs_write_decmpfs() because if the\n * file does not have \"com.apple.decmpfs\" xattr the flag is ignored.\n */\nstatic int\nhfs_set_compressed_fflag(struct archive_write_disk *a)\n{\n\tint r;\n\n\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\treturn (r);\n\n\ta->st.st_flags |= UF_COMPRESSED;\n\tif (fchflags(a->fd, a->st.st_flags) != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to set UF_COMPRESSED file flag\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * HFS+ Compression decmpfs\n *\n *     +------------------------------+ +0\n *     |      Magic(LE 4 bytes)       |\n *     +------------------------------+\n *     |      Type(LE 4 bytes)        |\n *     +------------------------------+\n *     | Uncompressed size(LE 8 bytes)|\n *     +------------------------------+ +16\n *     |                              |\n *     |       Compressed data        |\n *     |  (Placed only if Type == 3)  |\n *     |                              |\n *     +------------------------------+  +3802 = MAX_DECMPFS_XATTR_SIZE\n *\n *  Type is 3: decmpfs has compressed data.\n *  Type is 4: Resource Fork has compressed data.\n */\n/*\n * Write \"com.apple.decmpfs\"\n */\nstatic int\nhfs_write_decmpfs(struct archive_write_disk *a)\n{\n\tint r;\n\tuint32_t compression_type;\n\n\tr = fsetxattr(a->fd, DECMPFS_XATTR_NAME, a->decmpfs_header_p,\n\t    a->decmpfs_attr_size, 0, 0);\n\tif (r < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Cannot restore xattr:%s\", DECMPFS_XATTR_NAME);\n\t\tcompression_type = archive_le32dec(\n\t\t    &a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE]);\n\t\tif (compression_type == CMP_RESOURCE_FORK)\n\t\t\tfremovexattr(a->fd, XATTR_RESOURCEFORK_NAME,\n\t\t\t    XATTR_SHOWCOMPRESSION);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\n/*\n * HFS+ Compression Resource Fork\n *\n *     +-----------------------------+\n *     |     Header(260 bytes)       |\n *     +-----------------------------+\n *     |   Block count(LE 4 bytes)   |\n *     +-----------------------------+  --+\n * +-- |     Offset (LE 4 bytes)     |    |\n * |   | [distance from Block count] |    | Block 0\n * |   +-----------------------------+    |\n * |   | Compressed size(LE 4 bytes) |    |\n * |   +-----------------------------+  --+\n * |   |                             |\n * |   |      ..................     |\n * |   |                             |\n * |   +-----------------------------+  --+\n * |   |     Offset (LE 4 bytes)     |    |\n * |   +-----------------------------+    | Block (Block count -1)\n * |   | Compressed size(LE 4 bytes) |    |\n * +-> +-----------------------------+  --+\n *     |   Compressed data(n bytes)  |  Block 0\n *     +-----------------------------+\n *     |                             |\n *     |      ..................     |\n *     |                             |\n *     +-----------------------------+\n *     |   Compressed data(n bytes)  |  Block (Block count -1)\n *     +-----------------------------+\n *     |      Footer(50 bytes)       |\n *     +-----------------------------+\n *\n */\n/*\n * Write the header of \"com.apple.ResourceFork\"\n */\nstatic int\nhfs_write_resource_fork(struct archive_write_disk *a, unsigned char *buff,\n    size_t bytes, uint32_t position)\n{\n\tint ret;\n\n\tret = fsetxattr(a->fd, XATTR_RESOURCEFORK_NAME, buff, bytes,\n\t    position, a->rsrc_xattr_options);\n\tif (ret < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Cannot restore xattr: %s at %u pos %u bytes\",\n\t\t    XATTR_RESOURCEFORK_NAME,\n\t\t    (unsigned)position,\n\t\t    (unsigned)bytes);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\ta->rsrc_xattr_options &= ~XATTR_CREATE;\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_write_compressed_data(struct archive_write_disk *a, size_t bytes_compressed)\n{\n\tint ret;\n\n\tret = hfs_write_resource_fork(a, a->compressed_buffer,\n\t    bytes_compressed, a->compressed_rsrc_position);\n\tif (ret == ARCHIVE_OK)\n\t\ta->compressed_rsrc_position += bytes_compressed;\n\treturn (ret);\n}\n\nstatic int\nhfs_write_resource_fork_header(struct archive_write_disk *a)\n{\n\tunsigned char *buff;\n\tuint32_t rsrc_bytes;\n\tuint32_t rsrc_header_bytes;\n\n\t/*\n\t * Write resource fork header + block info.\n\t */\n\tbuff = a->resource_fork;\n\trsrc_bytes = a->compressed_rsrc_position - RSRC_F_SIZE;\n\trsrc_header_bytes =\n\t\tRSRC_H_SIZE +\t\t/* Header base size. */\n\t\t4 +\t\t\t/* Block count. */\n\t\t(a->decmpfs_block_count * 8);/* Block info */\n\tarchive_be32enc(buff, 0x100);\n\tarchive_be32enc(buff + 4, rsrc_bytes);\n\tarchive_be32enc(buff + 8, rsrc_bytes - 256);\n\tarchive_be32enc(buff + 12, 0x32);\n\tmemset(buff + 16, 0, 240);\n\tarchive_be32enc(buff + 256, rsrc_bytes - 260);\n\treturn hfs_write_resource_fork(a, buff, rsrc_header_bytes, 0);\n}\n\nstatic size_t\nhfs_set_resource_fork_footer(unsigned char *buff, size_t buff_size)\n{\n\tstatic const char rsrc_footer[RSRC_F_SIZE] = {\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 'c',  'm',\n\t\t'p', 'f',   0x00, 0x00, 0x00, 0x0a, 0x00, 0x01,\n\t\t0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00\n\t};\n\tif (buff_size < sizeof(rsrc_footer))\n\t\treturn (0);\n\tmemcpy(buff, rsrc_footer, sizeof(rsrc_footer));\n\treturn (sizeof(rsrc_footer));\n}\n\nstatic int\nhfs_reset_compressor(struct archive_write_disk *a)\n{\n\tint ret;\n\n\tif (a->stream_valid)\n\t\tret = deflateReset(&a->stream);\n\telse\n\t\tret = deflateInit(&a->stream, a->decmpfs_compression_level);\n\n\tif (ret != Z_OK) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"Failed to initialize compressor\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else\n\t\ta->stream_valid = 1;\n\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_decompress(struct archive_write_disk *a)\n{\n\tuint32_t *block_info;\n\tunsigned int block_count;\n\tuint32_t data_pos, data_size;\n\tssize_t r;\n\tssize_t bytes_written, bytes_to_write;\n\tunsigned char *b;\n\n\tblock_info = (uint32_t *)(a->resource_fork + RSRC_H_SIZE);\n\tblock_count = archive_le32dec(block_info++);\n\twhile (block_count--) {\n\t\tdata_pos = RSRC_H_SIZE + archive_le32dec(block_info++);\n\t\tdata_size = archive_le32dec(block_info++);\n\t\tr = fgetxattr(a->fd, XATTR_RESOURCEFORK_NAME,\n\t\t    a->compressed_buffer, data_size, data_pos, 0);\n\t\tif (r != data_size)  {\n\t\t\tarchive_set_error(&a->archive,\n\t\t\t    (r < 0)?errno:ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to read resource fork\");\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\t\tif (a->compressed_buffer[0] == 0xff) {\n\t\t\tbytes_to_write = data_size -1;\n\t\t\tb = a->compressed_buffer + 1;\n\t\t} else {\n\t\t\tuLong dest_len = MAX_DECMPFS_BLOCK_SIZE;\n\t\t\tint zr;\n\n\t\t\tzr = uncompress((Bytef *)a->uncompressed_buffer,\n\t\t\t    &dest_len, a->compressed_buffer, data_size);\n\t\t\tif (zr != Z_OK) {\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_MISC,\n\t\t\t\t    \"Failed to decompress resource fork\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tbytes_to_write = dest_len;\n\t\t\tb = (unsigned char *)a->uncompressed_buffer;\n\t\t}\n\t\tdo {\n\t\t\tbytes_written = write(a->fd, b, bytes_to_write);\n\t\t\tif (bytes_written < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Write failed\");\n\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t}\n\t\t\tbytes_to_write -= bytes_written;\n\t\t\tb += bytes_written;\n\t\t} while (bytes_to_write > 0);\n\t}\n\tr = fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME, 0);\n\tif (r == -1)  {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to remove resource fork\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nhfs_drive_compressor(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tunsigned char *buffer_compressed;\n\tsize_t bytes_compressed;\n\tsize_t bytes_used;\n\tint ret;\n\n\tret = hfs_reset_compressor(a);\n\tif (ret != ARCHIVE_OK)\n\t\treturn (ret);\n\n\tif (a->compressed_buffer == NULL) {\n\t\tsize_t block_size;\n\n\t\tblock_size = COMPRESSED_W_SIZE + RSRC_F_SIZE +\n\t\t    + compressBound(MAX_DECMPFS_BLOCK_SIZE);\n\t\ta->compressed_buffer = malloc(block_size);\n\t\tif (a->compressed_buffer == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Can't allocate memory for Resource Fork\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\ta->compressed_buffer_size = block_size;\n\t\ta->compressed_buffer_remaining = block_size;\n\t}\n\n\tbuffer_compressed = a->compressed_buffer +\n\t    a->compressed_buffer_size - a->compressed_buffer_remaining;\n\ta->stream.next_in = (Bytef *)(uintptr_t)(const void *)buff;\n\ta->stream.avail_in = size;\n\ta->stream.next_out = buffer_compressed;\n\ta->stream.avail_out = a->compressed_buffer_remaining;\n\tdo {\n\t\tret = deflate(&a->stream, Z_FINISH);\n\t\tswitch (ret) {\n\t\tcase Z_OK:\n\t\tcase Z_STREAM_END:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to compress data\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} while (ret == Z_OK);\n\tbytes_compressed = a->compressed_buffer_remaining - a->stream.avail_out;\n\n\t/*\n\t * If the compressed size is larger than the original size,\n\t * throw away compressed data, use uncompressed data instead.\n\t */\n\tif (bytes_compressed > size) {\n\t\tbuffer_compressed[0] = 0xFF;/* uncompressed marker. */\n\t\tmemcpy(buffer_compressed + 1, buff, size);\n\t\tbytes_compressed = size + 1;\n\t}\n\ta->compressed_buffer_remaining -= bytes_compressed;\n\n\t/*\n\t * If the compressed size is smaller than MAX_DECMPFS_XATTR_SIZE\n\t * and the block count in the file is only one, store compressed\n\t * data to decmpfs xattr instead of the resource fork.\n\t */\n\tif (a->decmpfs_block_count == 1 &&\n\t    (a->decmpfs_attr_size + bytes_compressed)\n\t      <= MAX_DECMPFS_XATTR_SIZE) {\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],\n\t\t    CMP_XATTR);\n\t\tmemcpy(a->decmpfs_header_p + DECMPFS_HEADER_SIZE,\n\t\t    buffer_compressed, bytes_compressed);\n\t\ta->decmpfs_attr_size += bytes_compressed;\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\t\t/*\n\t\t * Finish HFS+ Compression.\n\t\t * - Write the decmpfs xattr.\n\t\t * - Set the UF_COMPRESSED file flag.\n\t\t */\n\t\tret = hfs_write_decmpfs(a);\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_set_compressed_fflag(a);\n\t\treturn (ret);\n\t}\n\n\t/* Update block info. */\n\tarchive_le32enc(a->decmpfs_block_info++,\n\t    a->compressed_rsrc_position_v - RSRC_H_SIZE);\n\tarchive_le32enc(a->decmpfs_block_info++, bytes_compressed);\n\ta->compressed_rsrc_position_v += bytes_compressed;\n\n\t/*\n\t * Write the compressed data to the resource fork.\n\t */\n\tbytes_used = a->compressed_buffer_size - a->compressed_buffer_remaining;\n\twhile (bytes_used >= COMPRESSED_W_SIZE) {\n\t\tret = hfs_write_compressed_data(a, COMPRESSED_W_SIZE);\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t\tbytes_used -= COMPRESSED_W_SIZE;\n\t\tif (bytes_used > COMPRESSED_W_SIZE)\n\t\t\tmemmove(a->compressed_buffer,\n\t\t\t    a->compressed_buffer + COMPRESSED_W_SIZE,\n\t\t\t    bytes_used);\n\t\telse\n\t\t\tmemcpy(a->compressed_buffer,\n\t\t\t    a->compressed_buffer + COMPRESSED_W_SIZE,\n\t\t\t    bytes_used);\n\t}\n\ta->compressed_buffer_remaining = a->compressed_buffer_size - bytes_used;\n\n\t/*\n\t * If the current block is the last block, write the remaining\n\t * compressed data and the resource fork footer.\n\t */\n\tif (a->file_remaining_bytes == 0) {\n\t\tsize_t rsrc_size;\n\t\tint64_t bk;\n\n\t\t/* Append the resource footer. */\n\t\trsrc_size = hfs_set_resource_fork_footer(\n\t\t    a->compressed_buffer + bytes_used,\n\t\t    a->compressed_buffer_remaining);\n\t\tret = hfs_write_compressed_data(a, bytes_used + rsrc_size);\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\n\t\t/* If the compressed size is not enouph smaller than\n\t\t * the uncompressed size. cancel HFS+ compression.\n\t\t * TODO: study a behavior of ditto utility and improve\n\t\t * the condition to fall back into no HFS+ compression. */\n\t\tbk = HFS_BLOCKS(a->compressed_rsrc_position);\n\t\tbk += bk >> 7;\n\t\tif (bk > HFS_BLOCKS(a->filesize))\n\t\t\treturn hfs_decompress(a);\n\t\t/*\n\t\t * Write the resourcefork header.\n\t\t */\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_write_resource_fork_header(a);\n\t\t/*\n\t\t * Finish HFS+ Compression.\n\t\t * - Write the decmpfs xattr.\n\t\t * - Set the UF_COMPRESSED file flag.\n\t\t */\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_write_decmpfs(a);\n\t\tif (ret == ARCHIVE_OK)\n\t\t\tret = hfs_set_compressed_fflag(a);\n\t}\n\treturn (ret);\n}\n\nstatic ssize_t\nhfs_write_decmpfs_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tconst char *buffer_to_write;\n\tsize_t bytes_to_write;\n\tint ret;\n\n\tif (a->decmpfs_block_count == (unsigned)-1) {\n\t\tvoid *new_block;\n\t\tsize_t new_size;\n\t\tunsigned int block_count;\n\n\t\tif (a->decmpfs_header_p == NULL) {\n\t\t\tnew_block = malloc(MAX_DECMPFS_XATTR_SIZE\n\t\t\t    + sizeof(uint32_t));\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for decmpfs\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->decmpfs_header_p = new_block;\n\t\t}\n\t\ta->decmpfs_attr_size = DECMPFS_HEADER_SIZE;\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_MAGIC],\n\t\t    DECMPFS_MAGIC);\n\t\tarchive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],\n\t\t    CMP_RESOURCE_FORK);\n\t\tarchive_le64enc(&a->decmpfs_header_p[DECMPFS_UNCOMPRESSED_SIZE],\n\t\t    a->filesize);\n\n\t\t/* Calculate a block count of the file. */\n\t\tblock_count =\n\t\t    (a->filesize + MAX_DECMPFS_BLOCK_SIZE -1) /\n\t\t\tMAX_DECMPFS_BLOCK_SIZE;\n\t\t/*\n\t\t * Allocate buffer for resource fork.\n\t\t * Set up related pointers;\n\t\t */\n\t\tnew_size =\n\t\t    RSRC_H_SIZE + /* header */\n\t\t    4 + /* Block count */\n\t\t    (block_count * sizeof(uint32_t) * 2) +\n\t\t    RSRC_F_SIZE; /* footer */\n\t\tif (new_size > a->resource_fork_allocated_size) {\n\t\t\tnew_block = realloc(a->resource_fork, new_size);\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for ResourceFork\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->resource_fork_allocated_size = new_size;\n\t\t\ta->resource_fork = new_block;\n\t\t}\n\n\t\t/* Allocate uncompressed buffer */\n\t\tif (a->uncompressed_buffer == NULL) {\n\t\t\tnew_block = malloc(MAX_DECMPFS_BLOCK_SIZE);\n\t\t\tif (new_block == NULL) {\n\t\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t\t    \"Can't allocate memory for decmpfs\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->uncompressed_buffer = new_block;\n\t\t}\n\t\ta->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;\n\t\ta->file_remaining_bytes = a->filesize;\n\t\ta->compressed_buffer_remaining = a->compressed_buffer_size;\n\n\t\t/*\n\t\t * Set up a resource fork.\n\t\t */\n\t\ta->rsrc_xattr_options = XATTR_CREATE;\n\t\t/* Get the position where we are going to set a bunch\n\t\t * of block info. */\n\t\ta->decmpfs_block_info =\n\t\t    (uint32_t *)(a->resource_fork + RSRC_H_SIZE);\n\t\t/* Set the block count to the resource fork. */\n\t\tarchive_le32enc(a->decmpfs_block_info++, block_count);\n\t\t/* Get the position where we are goint to set compressed\n\t\t * data. */\n\t\ta->compressed_rsrc_position =\n\t\t    RSRC_H_SIZE + 4 + (block_count * 8);\n\t\ta->compressed_rsrc_position_v = a->compressed_rsrc_position;\n\t\ta->decmpfs_block_count = block_count;\n\t}\n\n\t/* Ignore redundant bytes. */\n\tif (a->file_remaining_bytes == 0)\n\t\treturn ((ssize_t)size);\n\n\t/* Do not overrun a block size. */\n\tif (size > a->block_remaining_bytes)\n\t\tbytes_to_write = a->block_remaining_bytes;\n\telse\n\t\tbytes_to_write = size;\n\t/* Do not overrun the file size. */\n\tif (bytes_to_write > a->file_remaining_bytes)\n\t\tbytes_to_write = a->file_remaining_bytes;\n\n\t/* For efficiency, if a copy length is full of the uncompressed\n\t * buffer size, do not copy writing data to it. */\n\tif (bytes_to_write == MAX_DECMPFS_BLOCK_SIZE)\n\t\tbuffer_to_write = buff;\n\telse {\n\t\tmemcpy(a->uncompressed_buffer +\n\t\t    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes,\n\t\t    buff, bytes_to_write);\n\t\tbuffer_to_write = a->uncompressed_buffer;\n\t}\n\ta->block_remaining_bytes -= bytes_to_write;\n\ta->file_remaining_bytes -= bytes_to_write;\n\n\tif (a->block_remaining_bytes == 0 || a->file_remaining_bytes == 0) {\n\t\tret = hfs_drive_compressor(a, buffer_to_write,\n\t\t    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes);\n\t\tif (ret < 0)\n\t\t\treturn (ret);\n\t\ta->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;\n\t}\n\t/* Ignore redundant bytes. */\n\tif (a->file_remaining_bytes == 0)\n\t\treturn ((ssize_t)size);\n\treturn (bytes_to_write);\n}\n\nstatic ssize_t\nhfs_write_data_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\tuint64_t start_size = size;\n\tssize_t bytes_written = 0;\n\tssize_t bytes_to_write;\n\n\tif (size == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (a->filesize == 0 || a->fd < 0) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Attempt to write to an empty file\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\t/* If this write would run beyond the file size, truncate it. */\n\tif (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)\n\t\tstart_size = size = (size_t)(a->filesize - a->offset);\n\n\t/* Write the data. */\n\twhile (size > 0) {\n\t\tbytes_to_write = size;\n\t\t/* Seek if necessary to the specified offset. */\n\t\tif (a->offset < a->fd_offset) {\n\t\t\t/* Can't support backword move. */\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Seek failed\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t} else if (a->offset > a->fd_offset) {\n\t\t\tint64_t skip = a->offset - a->fd_offset;\n\t\t\tchar nullblock[1024];\n\n\t\t\tmemset(nullblock, 0, sizeof(nullblock));\n\t\t\twhile (skip > 0) {\n\t\t\t\tif (skip > (int64_t)sizeof(nullblock))\n\t\t\t\t\tbytes_written = hfs_write_decmpfs_block(\n\t\t\t\t\t    a, nullblock, sizeof(nullblock));\n\t\t\t\telse\n\t\t\t\t\tbytes_written = hfs_write_decmpfs_block(\n\t\t\t\t\t    a, nullblock, skip);\n\t\t\t\tif (bytes_written < 0) {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Write failed\");\n\t\t\t\t\treturn (ARCHIVE_WARN);\n\t\t\t\t}\n\t\t\t\tskip -= bytes_written;\n\t\t\t}\n\n\t\t\ta->fd_offset = a->offset;\n\t\t}\n\t\tbytes_written =\n\t\t    hfs_write_decmpfs_block(a, buff, bytes_to_write);\n\t\tif (bytes_written < 0)\n\t\t\treturn (bytes_written);\n\t\tbuff += bytes_written;\n\t\tsize -= bytes_written;\n\t\ta->total_bytes_written += bytes_written;\n\t\ta->offset += bytes_written;\n\t\ta->fd_offset = a->offset;\n\t}\n\treturn (start_size - size);\n}\n#else\nstatic ssize_t\nhfs_write_data_block(struct archive_write_disk *a, const char *buff,\n    size_t size)\n{\n\treturn (write_data_block(a, buff, size));\n}\n#endif\n\nstatic ssize_t\n_archive_write_disk_data_block(struct archive *_a,\n    const void *buff, size_t size, int64_t offset)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tssize_t r;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data_block\");\n\n\ta->offset = offset;\n\tif (a->todo & TODO_HFS_COMPRESSION)\n\t\tr = hfs_write_data_block(a, buff, size);\n\telse\n\t\tr = write_data_block(a, buff, size);\n\tif (r < ARCHIVE_OK)\n\t\treturn (r);\n\tif ((size_t)r < size) {\n\t\tarchive_set_error(&a->archive, 0,\n\t\t    \"Too much data: Truncating file at %ju bytes\", (uintmax_t)a->filesize);\n\t\treturn (ARCHIVE_WARN);\n\t}\n#if ARCHIVE_VERSION_NUMBER < 3999000\n\treturn (ARCHIVE_OK);\n#else\n\treturn (size);\n#endif\n}\n\nstatic ssize_t\n_archive_write_disk_data(struct archive *_a, const void *buff, size_t size)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\n\tif (a->todo & TODO_HFS_COMPRESSION)\n\t\treturn (hfs_write_data_block(a, buff, size));\n\treturn (write_data_block(a, buff, size));\n}\n\nstatic int\n_archive_write_disk_finish_entry(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tint ret = ARCHIVE_OK;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_finish_entry\");\n\tif (a->archive.state & ARCHIVE_STATE_HEADER)\n\t\treturn (ARCHIVE_OK);\n\tarchive_clear_error(&a->archive);\n\n\t/* Pad or truncate file to the right size. */\n\tif (a->fd < 0) {\n\t\t/* There's no file. */\n\t} else if (a->filesize < 0) {\n\t\t/* File size is unknown, so we can't set the size. */\n\t} else if (a->fd_offset == a->filesize) {\n\t\t/* Last write ended at exactly the filesize; we're done. */\n\t\t/* Hopefully, this is the common case. */\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n\t} else if (a->todo & TODO_HFS_COMPRESSION) {\n\t\tchar null_d[1024];\n\t\tssize_t r;\n\n\t\tif (a->file_remaining_bytes)\n\t\t\tmemset(null_d, 0, sizeof(null_d));\n\t\twhile (a->file_remaining_bytes) {\n\t\t\tif (a->file_remaining_bytes > sizeof(null_d))\n\t\t\t\tr = hfs_write_data_block(\n\t\t\t\t    a, null_d, sizeof(null_d));\n\t\t\telse\n\t\t\t\tr = hfs_write_data_block(\n\t\t\t\t    a, null_d, a->file_remaining_bytes);\n\t\t\tif (r < 0)\n\t\t\t\treturn ((int)r);\n\t\t}\n#endif\n\t} else {\n#if HAVE_FTRUNCATE\n\t\tif (ftruncate(a->fd, a->filesize) == -1 &&\n\t\t    a->filesize == 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"File size could not be restored\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n#endif\n\t\t/*\n\t\t * Not all platforms implement the XSI option to\n\t\t * extend files via ftruncate.  Stat() the file again\n\t\t * to see what happened.\n\t\t */\n\t\ta->pst = NULL;\n\t\tif ((ret = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (ret);\n\t\t/* We can use lseek()/write() to extend the file if\n\t\t * ftruncate didn't work or isn't available. */\n\t\tif (a->st.st_size < a->filesize) {\n\t\t\tconst char nul = '\\0';\n\t\t\tif (lseek(a->fd, a->filesize - 1, SEEK_SET) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Seek failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\tif (write(a->fd, &nul, 1) < 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Write to restore size failed\");\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->pst = NULL;\n\t\t}\n\t}\n\n\t/* Restore metadata. */\n\n\t/*\n\t * This is specific to Mac OS X.\n\t * If the current file is an AppleDouble file, it should be\n\t * linked with the data fork file and remove it.\n\t */\n\tif (a->todo & TODO_APPLEDOUBLE) {\n\t\tint r2 = fixup_appledouble(a, a->name);\n\t\tif (r2 == ARCHIVE_EOF) {\n\t\t\t/* The current file has been successfully linked\n\t\t\t * with the data fork file and removed. So there\n\t\t\t * is nothing to do on the current file.  */\n\t\t\tgoto finish_metadata;\n\t\t}\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Look up the \"real\" UID only if we're going to need it.\n\t * TODO: the TODO_SGID condition can be dropped here, can't it?\n\t */\n\tif (a->todo & (TODO_OWNER | TODO_SUID | TODO_SGID)) {\n\t\ta->uid = archive_write_disk_uid(&a->archive,\n\t\t    archive_entry_uname(a->entry),\n\t\t    archive_entry_uid(a->entry));\n\t}\n\t/* Look up the \"real\" GID only if we're going to need it. */\n\t/* TODO: the TODO_SUID condition can be dropped here, can't it? */\n\tif (a->todo & (TODO_OWNER | TODO_SGID | TODO_SUID)) {\n\t\ta->gid = archive_write_disk_gid(&a->archive,\n\t\t    archive_entry_gname(a->entry),\n\t\t    archive_entry_gid(a->entry));\n\t }\n\n\t/*\n\t * Restore ownership before set_mode tries to restore suid/sgid\n\t * bits.  If we set the owner, we know what it is and can skip\n\t * a stat() call to examine the ownership of the file on disk.\n\t */\n\tif (a->todo & TODO_OWNER) {\n\t\tint r2 = set_ownership(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * set_mode must precede ACLs on systems such as Solaris and\n\t * FreeBSD where setting the mode implicitly clears extended ACLs\n\t */\n\tif (a->todo & TODO_MODE) {\n\t\tint r2 = set_mode(a, a->mode);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Security-related extended attributes (such as\n\t * security.capability on Linux) have to be restored last,\n\t * since they're implicitly removed by other file changes.\n\t */\n\tif (a->todo & TODO_XATTR) {\n\t\tint r2 = set_xattrs(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Some flags prevent file modification; they must be restored after\n\t * file contents are written.\n\t */\n\tif (a->todo & TODO_FFLAGS) {\n\t\tint r2 = set_fflags(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Time must follow most other metadata;\n\t * otherwise atime will get changed.\n\t */\n\tif (a->todo & TODO_TIMES) {\n\t\tint r2 = set_times_from_entry(a);\n\t\tif (r2 < ret) ret = r2;\n\t}\n\n\t/*\n\t * Mac extended metadata includes ACLs.\n\t */\n\tif (a->todo & TODO_MAC_METADATA) {\n\t\tconst void *metadata;\n\t\tsize_t metadata_size;\n\t\tmetadata = archive_entry_mac_metadata(a->entry, &metadata_size);\n\t\tif (metadata != NULL && metadata_size > 0) {\n\t\t\tint r2 = set_mac_metadata(a, archive_entry_pathname(\n\t\t\t    a->entry), metadata, metadata_size);\n\t\t\tif (r2 < ret) ret = r2;\n\t\t}\n\t}\n\n\t/*\n\t * ACLs must be restored after timestamps because there are\n\t * ACLs that prevent attribute changes (including time).\n\t */\n\tif (a->todo & TODO_ACLS) {\n\t\tint r2 = archive_write_disk_set_acls(&a->archive, a->fd,\n\t\t\t\t  archive_entry_pathname(a->entry),\n\t\t\t\t  archive_entry_acl(a->entry));\n\t\tif (r2 < ret) ret = r2;\n\t}\n\nfinish_metadata:\n\t/* If there's an fd, we can close it now. */\n\tif (a->fd >= 0) {\n\t\tclose(a->fd);\n\t\ta->fd = -1;\n\t}\n\t/* If there's an entry, we can release it now. */\n\tif (a->entry) {\n\t\tarchive_entry_free(a->entry);\n\t\ta->entry = NULL;\n\t}\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\treturn (ret);\n}\n\nint\narchive_write_disk_set_group_lookup(struct archive *_a,\n    void *private_data,\n    int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid),\n    void (*cleanup_gid)(void *private))\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_group_lookup\");\n\n\tif (a->cleanup_gid != NULL && a->lookup_gid_data != NULL)\n\t\t(a->cleanup_gid)(a->lookup_gid_data);\n\n\ta->lookup_gid = lookup_gid;\n\ta->cleanup_gid = cleanup_gid;\n\ta->lookup_gid_data = private_data;\n\treturn (ARCHIVE_OK);\n}\n\nint\narchive_write_disk_set_user_lookup(struct archive *_a,\n    void *private_data,\n    int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),\n    void (*cleanup_uid)(void *private))\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_set_user_lookup\");\n\n\tif (a->cleanup_uid != NULL && a->lookup_uid_data != NULL)\n\t\t(a->cleanup_uid)(a->lookup_uid_data);\n\n\ta->lookup_uid = lookup_uid;\n\ta->cleanup_uid = cleanup_uid;\n\ta->lookup_uid_data = private_data;\n\treturn (ARCHIVE_OK);\n}\n\nint64_t\narchive_write_disk_gid(struct archive *_a, const char *name, int64_t id)\n{\n       struct archive_write_disk *a = (struct archive_write_disk *)_a;\n       archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n           ARCHIVE_STATE_ANY, \"archive_write_disk_gid\");\n       if (a->lookup_gid)\n               return (a->lookup_gid)(a->lookup_gid_data, name, id);\n       return (id);\n}\n \nint64_t\narchive_write_disk_uid(struct archive *_a, const char *name, int64_t id)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY, \"archive_write_disk_uid\");\n\tif (a->lookup_uid)\n\t\treturn (a->lookup_uid)(a->lookup_uid_data, name, id);\n\treturn (id);\n}\n\n/*\n * Create a new archive_write_disk object and initialize it with global state.\n */\nstruct archive *\narchive_write_disk_new(void)\n{\n\tstruct archive_write_disk *a;\n\n\ta = (struct archive_write_disk *)malloc(sizeof(*a));\n\tif (a == NULL)\n\t\treturn (NULL);\n\tmemset(a, 0, sizeof(*a));\n\ta->archive.magic = ARCHIVE_WRITE_DISK_MAGIC;\n\t/* We're ready to write a header immediately. */\n\ta->archive.state = ARCHIVE_STATE_HEADER;\n\ta->archive.vtable = archive_write_disk_vtable();\n\ta->start_time = time(NULL);\n\t/* Query and restore the umask. */\n\tumask(a->user_umask = umask(0));\n#ifdef HAVE_GETEUID\n\ta->user_uid = geteuid();\n#endif /* HAVE_GETEUID */\n\tif (archive_string_ensure(&a->path_safe, 512) == NULL) {\n\t\tfree(a);\n\t\treturn (NULL);\n\t}\n#ifdef HAVE_ZLIB_H\n\ta->decmpfs_compression_level = 5;\n#endif\n\treturn (&a->archive);\n}\n\n\n/*\n * If pathname is longer than PATH_MAX, chdir to a suitable\n * intermediate dir and edit the path down to a shorter suffix.  Note\n * that this routine never returns an error; if the chdir() attempt\n * fails for any reason, we just go ahead with the long pathname.  The\n * object creation is likely to fail, but any error will get handled\n * at that time.\n */\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\nstatic void\nedit_deep_directories(struct archive_write_disk *a)\n{\n\tint ret;\n\tchar *tail = a->name;\n\n\t/* If path is short, avoid the open() below. */\n\tif (strlen(tail) < PATH_MAX)\n\t\treturn;\n\n\t/* Try to record our starting dir. */\n\ta->restore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);\n\t__archive_ensure_cloexec_flag(a->restore_pwd);\n\tif (a->restore_pwd < 0)\n\t\treturn;\n\n\t/* As long as the path is too long... */\n\twhile (strlen(tail) >= PATH_MAX) {\n\t\t/* Locate a dir prefix shorter than PATH_MAX. */\n\t\ttail += PATH_MAX - 8;\n\t\twhile (tail > a->name && *tail != '/')\n\t\t\ttail--;\n\t\t/* Exit if we find a too-long path component. */\n\t\tif (tail <= a->name)\n\t\t\treturn;\n\t\t/* Create the intermediate dir and chdir to it. */\n\t\t*tail = '\\0'; /* Terminate dir portion */\n\t\tret = create_dir(a, a->name);\n\t\tif (ret == ARCHIVE_OK && chdir(a->name) != 0)\n\t\t\tret = ARCHIVE_FAILED;\n\t\t*tail = '/'; /* Restore the / we removed. */\n\t\tif (ret != ARCHIVE_OK)\n\t\t\treturn;\n\t\ttail++;\n\t\t/* The chdir() succeeded; we've now shortened the path. */\n\t\ta->name = tail;\n\t}\n\treturn;\n}\n#endif\n\n/*\n * The main restore function.\n */\nstatic int\nrestore_entry(struct archive_write_disk *a)\n{\n\tint ret = ARCHIVE_OK, en;\n\n\tif (a->flags & ARCHIVE_EXTRACT_UNLINK && !S_ISDIR(a->mode)) {\n\t\t/*\n\t\t * TODO: Fix this.  Apparently, there are platforms\n\t\t * that still allow root to hose the entire filesystem\n\t\t * by unlinking a dir.  The S_ISDIR() test above\n\t\t * prevents us from using unlink() here if the new\n\t\t * object is a dir, but that doesn't mean the old\n\t\t * object isn't a dir.\n\t\t */\n\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t(void)clear_nochange_fflags(a);\n\t\tif (unlink(a->name) == 0) {\n\t\t\t/* We removed it, reset cached stat. */\n\t\t\ta->pst = NULL;\n\t\t} else if (errno == ENOENT) {\n\t\t\t/* File didn't exist, that's just as good. */\n\t\t} else if (rmdir(a->name) == 0) {\n\t\t\t/* It was a dir, but now it's gone. */\n\t\t\ta->pst = NULL;\n\t\t} else {\n\t\t\t/* We tried, but couldn't get rid of it. */\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Could not unlink\");\n\t\t\treturn(ARCHIVE_FAILED);\n\t\t}\n\t}\n\n\t/* Try creating it first; if this fails, we'll try to recover. */\n\ten = create_filesystem_object(a);\n\n\tif ((en == ENOTDIR || en == ENOENT)\n\t    && !(a->flags & ARCHIVE_EXTRACT_NO_AUTODIR)) {\n\t\t/* If the parent dir doesn't exist, try creating it. */\n\t\tcreate_parent_dir(a, a->name);\n\t\t/* Now try to create the object again. */\n\t\ten = create_filesystem_object(a);\n\t}\n\n\tif ((en == ENOENT) && (archive_entry_hardlink(a->entry) != NULL)) {\n\t\tarchive_set_error(&a->archive, en,\n\t\t    \"Hard-link target '%s' does not exist.\",\n\t\t    archive_entry_hardlink(a->entry));\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif ((en == EISDIR || en == EEXIST)\n\t    && (a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {\n\t\t/* If we're not overwriting, we're done. */\n\t\tarchive_entry_unset_size(a->entry);\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Some platforms return EISDIR if you call\n\t * open(O_WRONLY | O_EXCL | O_CREAT) on a directory, some\n\t * return EEXIST.  POSIX is ambiguous, requiring EISDIR\n\t * for open(O_WRONLY) on a dir and EEXIST for open(O_EXCL | O_CREAT)\n\t * on an existing item.\n\t */\n\tif (en == EISDIR) {\n\t\t/* A dir is in the way of a non-dir, rmdir it. */\n\t\tif (rmdir(a->name) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't remove already-existing dir\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\ta->pst = NULL;\n\t\t/* Try again. */\n\t\ten = create_filesystem_object(a);\n\t} else if (en == EEXIST) {\n\t\t/*\n\t\t * We know something is in the way, but we don't know what;\n\t\t * we need to find out before we go any further.\n\t\t */\n\t\tint r = 0;\n\t\t/*\n\t\t * The SECURE_SYMLINKS logic has already removed a\n\t\t * symlink to a dir if the client wants that.  So\n\t\t * follow the symlink if we're creating a dir.\n\t\t */\n\t\tif (S_ISDIR(a->mode))\n\t\t\tr = stat(a->name, &a->st);\n\t\t/*\n\t\t * If it's not a dir (or it's a broken symlink),\n\t\t * then don't follow it.\n\t\t */\n\t\tif (r != 0 || !S_ISDIR(a->mode))\n\t\t\tr = lstat(a->name, &a->st);\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't stat existing object\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\t/*\n\t\t * NO_OVERWRITE_NEWER doesn't apply to directories.\n\t\t */\n\t\tif ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER)\n\t\t    &&  !S_ISDIR(a->st.st_mode)) {\n\t\t\tif (!older(&(a->st), a->entry)) {\n\t\t\t\tarchive_entry_unset_size(a->entry);\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t}\n\n\t\t/* If it's our archive, we're done. */\n\t\tif (a->skip_file_set &&\n\t\t    a->st.st_dev == (dev_t)a->skip_file_dev &&\n\t\t    a->st.st_ino == (ino_t)a->skip_file_ino) {\n\t\t\tarchive_set_error(&a->archive, 0,\n\t\t\t    \"Refusing to overwrite archive\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tif (!S_ISDIR(a->st.st_mode)) {\n\t\t\t/* A non-dir is in the way, unlink it. */\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t\t(void)clear_nochange_fflags(a);\n\t\t\tif (unlink(a->name) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't unlink already-existing object\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\ta->pst = NULL;\n\t\t\t/* Try again. */\n\t\t\ten = create_filesystem_object(a);\n\t\t} else if (!S_ISDIR(a->mode)) {\n\t\t\t/* A dir is in the way of a non-dir, rmdir it. */\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)\n\t\t\t\t(void)clear_nochange_fflags(a);\n\t\t\tif (rmdir(a->name) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't replace existing directory with non-directory\");\n\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t}\n\t\t\t/* Try again. */\n\t\t\ten = create_filesystem_object(a);\n\t\t} else {\n\t\t\t/*\n\t\t\t * There's a dir in the way of a dir.  Don't\n\t\t\t * waste time with rmdir()/mkdir(), just fix\n\t\t\t * up the permissions on the existing dir.\n\t\t\t * Note that we don't change perms on existing\n\t\t\t * dirs unless _EXTRACT_PERM is specified.\n\t\t\t */\n\t\t\tif ((a->mode != a->st.st_mode)\n\t\t\t    && (a->todo & TODO_MODE_FORCE))\n\t\t\t\ta->deferred |= (a->todo & TODO_MODE);\n\t\t\t/* Ownership doesn't need deferred fixup. */\n\t\t\ten = 0; /* Forget the EEXIST. */\n\t\t}\n\t}\n\n\tif (en) {\n\t\t/* Everything failed; give up here. */\n\t\tarchive_set_error(&a->archive, en, \"Can't create '%s'\",\n\t\t    a->name);\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\ta->pst = NULL; /* Cached stat data no longer valid. */\n\treturn (ret);\n}\n\n/*\n * Returns 0 if creation succeeds, or else returns errno value from\n * the failed system call.   Note:  This function should only ever perform\n * a single system call.\n */\nstatic int\ncreate_filesystem_object(struct archive_write_disk *a)\n{\n\t/* Create the entry. */\n\tconst char *linkname;\n\tmode_t final_mode, mode;\n\tint r;\n\t/* these for check_symlinks_fsobj */\n\tchar *linkname_copy;\t/* non-const copy of linkname */\n\tstruct archive_string error_string;\n\tint error_number;\n\n\t/* We identify hard/symlinks according to the link names. */\n\t/* Since link(2) and symlink(2) don't handle modes, we're done here. */\n\tlinkname = archive_entry_hardlink(a->entry);\n\tif (linkname != NULL) {\n#if !HAVE_LINK\n\t\treturn (EPERM);\n#else\n\t\tarchive_string_init(&error_string);\n\t\tlinkname_copy = strdup(linkname);\n\t\tif (linkname_copy == NULL) {\n\t\t    return (EPERM);\n\t\t}\n\t\t/* TODO: consider using the cleaned-up path as the link target? */\n\t\tr = cleanup_pathname_fsobj(linkname_copy, &error_number, &error_string, a->flags);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t\t\tfree(linkname_copy);\n\t\t\t/* EPERM is more appropriate than error_number for our callers */\n\t\t\treturn (EPERM);\n\t\t}\n\t\tr = check_symlinks_fsobj(linkname_copy, &error_number, &error_string, a->flags);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t\t\tfree(linkname_copy);\n\t\t\t/* EPERM is more appropriate than error_number for our callers */\n\t\t\treturn (EPERM);\n\t\t}\n\t\tfree(linkname_copy);\n\t\tr = link(linkname, a->name) ? errno : 0;\n\t\t/*\n\t\t * New cpio and pax formats allow hardlink entries\n\t\t * to carry data, so we may have to open the file\n\t\t * for hardlink entries.\n\t\t *\n\t\t * If the hardlink was successfully created and\n\t\t * the archive doesn't have carry data for it,\n\t\t * consider it to be non-authoritative for meta data.\n\t\t * This is consistent with GNU tar and BSD pax.\n\t\t * If the hardlink does carry data, let the last\n\t\t * archive entry decide ownership.\n\t\t */\n\t\tif (r == 0 && a->filesize <= 0) {\n\t\t\ta->todo = 0;\n\t\t\ta->deferred = 0;\n\t\t} else if (r == 0 && a->filesize > 0) {\n\t\t\ta->fd = open(a->name,\n\t\t\t\t     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);\n\t\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\t\tif (a->fd < 0)\n\t\t\t\tr = errno;\n\t\t}\n\t\treturn (r);\n#endif\n\t}\n\tlinkname = archive_entry_symlink(a->entry);\n\tif (linkname != NULL) {\n#if HAVE_SYMLINK\n\t\treturn symlink(linkname, a->name) ? errno : 0;\n#else\n\t\treturn (EPERM);\n#endif\n\t}\n\n\t/*\n\t * The remaining system calls all set permissions, so let's\n\t * try to take advantage of that to avoid an extra chmod()\n\t * call.  (Recall that umask is set to zero right now!)\n\t */\n\n\t/* Mode we want for the final restored object (w/o file type bits). */\n\tfinal_mode = a->mode & 07777;\n\t/*\n\t * The mode that will actually be restored in this step.  Note\n\t * that SUID, SGID, etc, require additional work to ensure\n\t * security, so we never restore them at this point.\n\t */\n\tmode = final_mode & 0777 & ~a->user_umask;\n\n\tswitch (a->mode & AE_IFMT) {\n\tdefault:\n\t\t/* POSIX requires that we fall through here. */\n\t\t/* FALLTHROUGH */\n\tcase AE_IFREG:\n\t\ta->fd = open(a->name,\n\t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);\n\t\t__archive_ensure_cloexec_flag(a->fd);\n\t\tr = (a->fd < 0);\n\t\tbreak;\n\tcase AE_IFCHR:\n#ifdef HAVE_MKNOD\n\t\t/* Note: we use AE_IFCHR for the case label, and\n\t\t * S_IFCHR for the mknod() call.  This is correct.  */\n\t\tr = mknod(a->name, mode | S_IFCHR,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a char device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFBLK:\n#ifdef HAVE_MKNOD\n\t\tr = mknod(a->name, mode | S_IFBLK,\n\t\t    archive_entry_rdev(a->entry));\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a block device node. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKNOD */\n\tcase AE_IFDIR:\n\t\tmode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;\n\t\tr = mkdir(a->name, mode);\n\t\tif (r == 0) {\n\t\t\t/* Defer setting dir times. */\n\t\t\ta->deferred |= (a->todo & TODO_TIMES);\n\t\t\ta->todo &= ~TODO_TIMES;\n\t\t\t/* Never use an immediate chmod(). */\n\t\t\t/* We can't avoid the chmod() entirely if EXTRACT_PERM\n\t\t\t * because of SysV SGID inheritance. */\n\t\t\tif ((mode != final_mode)\n\t\t\t    || (a->flags & ARCHIVE_EXTRACT_PERM))\n\t\t\t\ta->deferred |= (a->todo & TODO_MODE);\n\t\t\ta->todo &= ~TODO_MODE;\n\t\t}\n\t\tbreak;\n\tcase AE_IFIFO:\n#ifdef HAVE_MKFIFO\n\t\tr = mkfifo(a->name, mode);\n\t\tbreak;\n#else\n\t\t/* TODO: Find a better way to warn about our inability\n\t\t * to restore a fifo. */\n\t\treturn (EINVAL);\n#endif /* HAVE_MKFIFO */\n\t}\n\n\t/* All the system calls above set errno on failure. */\n\tif (r)\n\t\treturn (errno);\n\n\t/* If we managed to set the final mode, we've avoided a chmod(). */\n\tif (mode == final_mode)\n\t\ta->todo &= ~TODO_MODE;\n\treturn (0);\n}\n\n/*\n * Cleanup function for archive_extract.  Mostly, this involves processing\n * the fixup list, which is used to address a number of problems:\n *   * Dir permissions might prevent us from restoring a file in that\n *     dir, so we restore the dir with minimum 0700 permissions first,\n *     then correct the mode at the end.\n *   * Similarly, the act of restoring a file touches the directory\n *     and changes the timestamp on the dir, so we have to touch-up dir\n *     timestamps at the end as well.\n *   * Some file flags can interfere with the restore by, for example,\n *     preventing the creation of hardlinks to those files.\n *   * Mac OS extended metadata includes ACLs, so must be deferred on dirs.\n *\n * Note that tar/cpio do not require that archives be in a particular\n * order; there is no way to know when the last file has been restored\n * within a directory, so there's no way to optimize the memory usage\n * here by fixing up the directory any earlier than the\n * end-of-archive.\n *\n * XXX TODO: Directory ACLs should be restored here, for the same\n * reason we set directory perms here. XXX\n */\nstatic int\n_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t/* Sort dir list so directories are fixed up in depth-first order. */\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\ta->pst = NULL; /* Mark stat cache as out-of-date. */\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, -1, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE)\n\t\t\tchmod(p->name, p->mode);\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive,\n\t\t\t\t\t\t    -1, p->name, &p->acl);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, -1, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}\n\nstatic int\n_archive_write_disk_free(struct archive *_a)\n{\n\tstruct archive_write_disk *a;\n\tint ret;\n\tif (_a == NULL)\n\t\treturn (ARCHIVE_OK);\n\tarchive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, \"archive_write_disk_free\");\n\ta = (struct archive_write_disk *)_a;\n\tret = _archive_write_disk_close(&a->archive);\n\tarchive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);\n\tarchive_write_disk_set_user_lookup(&a->archive, NULL, NULL, NULL);\n\tif (a->entry)\n\t\tarchive_entry_free(a->entry);\n\tarchive_string_free(&a->_name_data);\n\tarchive_string_free(&a->archive.error_string);\n\tarchive_string_free(&a->path_safe);\n\ta->archive.magic = 0;\n\t__archive_clean(&a->archive);\n\tfree(a->decmpfs_header_p);\n\tfree(a->resource_fork);\n\tfree(a->compressed_buffer);\n\tfree(a->uncompressed_buffer);\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\\\n\t&& defined(HAVE_ZLIB_H)\n\tif (a->stream_valid) {\n\t\tswitch (deflateEnd(&a->stream)) {\n\t\tcase Z_OK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Failed to clean up compressor\");\n\t\t\tret = ARCHIVE_FATAL;\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tfree(a);\n\treturn (ret);\n}\n\n/*\n * Simple O(n log n) merge sort to order the fixup list.  In\n * particular, we want to restore dir timestamps depth-first.\n */\nstatic struct fixup_entry *\nsort_dir_list(struct fixup_entry *p)\n{\n\tstruct fixup_entry *a, *b, *t;\n\n\tif (p == NULL)\n\t\treturn (NULL);\n\t/* A one-item list is already sorted. */\n\tif (p->next == NULL)\n\t\treturn (p);\n\n\t/* Step 1: split the list. */\n\tt = p;\n\ta = p->next->next;\n\twhile (a != NULL) {\n\t\t/* Step a twice, t once. */\n\t\ta = a->next;\n\t\tif (a != NULL)\n\t\t\ta = a->next;\n\t\tt = t->next;\n\t}\n\t/* Now, t is at the mid-point, so break the list here. */\n\tb = t->next;\n\tt->next = NULL;\n\ta = p;\n\n\t/* Step 2: Recursively sort the two sub-lists. */\n\ta = sort_dir_list(a);\n\tb = sort_dir_list(b);\n\n\t/* Step 3: Merge the returned lists. */\n\t/* Pick the first element for the merged list. */\n\tif (strcmp(a->name, b->name) > 0) {\n\t\tt = p = a;\n\t\ta = a->next;\n\t} else {\n\t\tt = p = b;\n\t\tb = b->next;\n\t}\n\n\t/* Always put the later element on the list first. */\n\twhile (a != NULL && b != NULL) {\n\t\tif (strcmp(a->name, b->name) > 0) {\n\t\t\tt->next = a;\n\t\t\ta = a->next;\n\t\t} else {\n\t\t\tt->next = b;\n\t\t\tb = b->next;\n\t\t}\n\t\tt = t->next;\n\t}\n\n\t/* Only one list is non-empty, so just splice it on. */\n\tif (a != NULL)\n\t\tt->next = a;\n\tif (b != NULL)\n\t\tt->next = b;\n\n\treturn (p);\n}\n\n/*\n * Returns a new, initialized fixup entry.\n *\n * TODO: Reduce the memory requirements for this list by using a tree\n * structure rather than a simple list of names.\n */\nstatic struct fixup_entry *\nnew_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}\n\n/*\n * Returns a fixup structure for the current entry.\n */\nstatic struct fixup_entry *\ncurrent_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tif (a->current_fixup == NULL)\n\t\ta->current_fixup = new_fixup(a, pathname);\n\treturn (a->current_fixup);\n}\n\n/* TODO: Make this work. */\n/*\n * TODO: The deep-directory support bypasses this; disable deep directory\n * support if we're doing symlink checks.\n */\n/*\n * TODO: Someday, integrate this with the deep dir support; they both\n * scan the path and both can be optimized by comparing against other\n * recent paths.\n */\n/* TODO: Extend this to support symlinks on Windows Vista and later. */\n\n/*\n * Checks the given path to see if any elements along it are symlinks.  Returns\n * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.\n */\nstatic int\ncheck_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n#if !defined(HAVE_LSTAT)\n\t/* Platform doesn't have lstat, so we can't look for symlinks. */\n\t(void)a; /* UNUSED */\n\t(void)path; /* UNUSED */\n\t(void)error_number; /* UNUSED */\n\t(void)error_string; /* UNUSED */\n\t(void)flags; /* UNUSED */\n\treturn (ARCHIVE_OK);\n#else\n\tint res = ARCHIVE_OK;\n\tchar *tail;\n\tchar *head;\n\tint last;\n\tchar c;\n\tint r;\n\tstruct stat st;\n\tint restore_pwd;\n\n\t/* Nothing to do here if name is empty */\n\tif(path[0] == '\\0')\n\t    return (ARCHIVE_OK);\n\n\t/*\n\t * Guard against symlink tricks.  Reject any archive entry whose\n\t * destination would be altered by a symlink.\n\t *\n\t * Walk the filename in chunks separated by '/'.  For each segment:\n\t *  - if it doesn't exist, continue\n\t *  - if it's symlink, abort or remove it\n\t *  - if it's a directory and it's not the last chunk, cd into it\n\t * As we go:\n\t *  head points to the current (relative) path\n\t *  tail points to the temporary \\0 terminating the segment we're currently examining\n\t *  c holds what used to be in *tail\n\t *  last is 1 if this is the last tail\n\t */\n\trestore_pwd = open(\".\", O_RDONLY | O_BINARY | O_CLOEXEC);\n\t__archive_ensure_cloexec_flag(restore_pwd);\n\tif (restore_pwd < 0)\n\t\treturn (ARCHIVE_FATAL);\n\thead = path;\n\ttail = path;\n\tlast = 0;\n\t/* TODO: reintroduce a safe cache here? */\n\t/* Skip the root directory if the path is absolute. */\n\tif(tail == path && tail[0] == '/')\n\t\t++tail;\n\t/* Keep going until we've checked the entire name.\n\t * head, tail, path all alias the same string, which is\n\t * temporarily zeroed at tail, so be careful restoring the\n\t * stashed (c=tail[0]) for error messages.\n\t * Exiting the loop with break is okay; continue is not.\n\t */\n\twhile (!last) {\n\t\t/* Skip the separator we just consumed, plus any adjacent ones */\n\t\twhile (*tail == '/')\n\t\t    ++tail;\n\t\t/* Skip the next path element. */\n\t\twhile (*tail != '\\0' && *tail != '/')\n\t\t\t++tail;\n\t\t/* is this the last path component? */\n\t\tlast = (tail[0] == '\\0') || (tail[0] == '/' && tail[1] == '\\0');\n\t\t/* temporarily truncate the string here */\n\t\tc = tail[0];\n\t\ttail[0] = '\\0';\n\t\t/* Check that we haven't hit a symlink. */\n\t\tr = lstat(head, &st);\n\t\tif (r != 0) {\n\t\t\ttail[0] = c;\n\t\t\t/* We've hit a dir that doesn't exist; stop now. */\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Treat any other error as fatal - best to be paranoid here\n\t\t\t\t * Note: This effectively disables deep directory\n\t\t\t\t * support when security checks are enabled.\n\t\t\t\t * Otherwise, very long pathnames that trigger\n\t\t\t\t * an error here could evade the sandbox.\n\t\t\t\t * TODO: We could do better, but it would probably\n\t\t\t\t * require merging the symlink checks with the\n\t\t\t\t * deep-directory editing. */\n\t\t\t\tif (error_number) *error_number = errno;\n\t\t\t\tif (error_string)\n\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\"Could not stat %s\",\n\t\t\t\t\t\t\tpath);\n\t\t\t\tres = ARCHIVE_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (S_ISDIR(st.st_mode)) {\n\t\t\tif (!last) {\n\t\t\t\tif (chdir(head) != 0) {\n\t\t\t\t\ttail[0] = c;\n\t\t\t\t\tif (error_number) *error_number = errno;\n\t\t\t\t\tif (error_string)\n\t\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\t\"Could not chdir %s\",\n\t\t\t\t\t\t\t\tpath);\n\t\t\t\t\tres = (ARCHIVE_FATAL);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* Our view is now from inside this dir: */\n\t\t\t\thead = tail + 1;\n\t\t\t}\n\t\t} else if (S_ISLNK(st.st_mode)) {\n\t\t\tif (last) {\n\t\t\t\t/*\n\t\t\t\t * Last element is symlink; remove it\n\t\t\t\t * so we can overwrite it with the\n\t\t\t\t * item being extracted.\n\t\t\t\t */\n\t\t\t\tif (unlink(head)) {\n\t\t\t\t\ttail[0] = c;\n\t\t\t\t\tif (error_number) *error_number = errno;\n\t\t\t\t\tif (error_string)\n\t\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\t\"Could not remove symlink %s\",\n\t\t\t\t\t\t\t\tpath);\n\t\t\t\t\tres = ARCHIVE_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Even if we did remove it, a warning\n\t\t\t\t * is in order.  The warning is silly,\n\t\t\t\t * though, if we're just replacing one\n\t\t\t\t * symlink with another symlink.\n\t\t\t\t */\n\t\t\t\ttail[0] = c;\n\t\t\t\t/* FIXME:  not sure how important this is to restore\n\t\t\t\tif (!S_ISLNK(path)) {\n\t\t\t\t\tif (error_number) *error_number = 0;\n\t\t\t\t\tif (error_string)\n\t\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\t\"Removing symlink %s\",\n\t\t\t\t\t\t\t\tpath);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t/* Symlink gone.  No more problem! */\n\t\t\t\tres = ARCHIVE_OK;\n\t\t\t\tbreak;\n\t\t\t} else if (flags & ARCHIVE_EXTRACT_UNLINK) {\n\t\t\t\t/* User asked us to remove problems. */\n\t\t\t\tif (unlink(head) != 0) {\n\t\t\t\t\ttail[0] = c;\n\t\t\t\t\tif (error_number) *error_number = 0;\n\t\t\t\t\tif (error_string)\n\t\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\t\"Cannot remove intervening symlink %s\",\n\t\t\t\t\t\t\t\tpath);\n\t\t\t\t\tres = ARCHIVE_FAILED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttail[0] = c;\n\t\t\t} else {\n\t\t\t\ttail[0] = c;\n\t\t\t\tif (error_number) *error_number = 0;\n\t\t\t\tif (error_string)\n\t\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\t\"Cannot extract through symlink %s\",\n\t\t\t\t\t\t\tpath);\n\t\t\t\tres = ARCHIVE_FAILED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* be sure to always maintain this */\n\t\ttail[0] = c;\n\t\tif (tail[0] != '\\0')\n\t\t\ttail++; /* Advance to the next segment. */\n\t}\n\t/* Catches loop exits via break */\n\ttail[0] = c;\n#ifdef HAVE_FCHDIR\n\t/* If we changed directory above, restore it here. */\n\tif (restore_pwd >= 0) {\n\t\tr = fchdir(restore_pwd);\n\t\tif (r != 0) {\n\t\t\tif(error_number) *error_number = errno;\n\t\t\tif(error_string)\n\t\t\t\tarchive_string_sprintf(error_string,\n\t\t\t\t\t\t\"chdir() failure\");\n\t\t}\n\t\tclose(restore_pwd);\n\t\trestore_pwd = -1;\n\t\tif (r != 0) {\n\t\t\tres = (ARCHIVE_FATAL);\n\t\t}\n\t}\n#endif\n\t/* TODO: reintroduce a safe cache here? */\n\treturn res;\n#endif\n}\n\n/*\n * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise\n * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}\n */\nstatic int\ncheck_symlinks(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\ta->pst = NULL;\t/* to be safe */\n\treturn rc;\n}\n\n\n#if defined(__CYGWIN__)\n/*\n * 1. Convert a path separator from '\\' to '/' .\n *    We shouldn't check multibyte character directly because some\n *    character-set have been using the '\\' character for a part of\n *    its multibyte character code.\n * 2. Replace unusable characters in Windows with underscore('_').\n * See also : http://msdn.microsoft.com/en-us/library/aa365247.aspx\n */\nstatic void\ncleanup_pathname_win(struct archive_write_disk *a)\n{\n\twchar_t wc;\n\tchar *p;\n\tsize_t alen, l;\n\tint mb, complete, utf8;\n\n\talen = 0;\n\tmb = 0;\n\tcomplete = 1;\n\tutf8 = (strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0)? 1: 0;\n\tfor (p = a->name; *p != '\\0'; p++) {\n\t\t++alen;\n\t\tif (*p == '\\\\') {\n\t\t\t/* If previous byte is smaller than 128,\n\t\t\t * this is not second byte of multibyte characters,\n\t\t\t * so we can replace '\\' with '/'. */\n\t\t\tif (utf8 || !mb)\n\t\t\t\t*p = '/';\n\t\t\telse\n\t\t\t\tcomplete = 0;/* uncompleted. */\n\t\t} else if (*(unsigned char *)p > 127)\n\t\t\tmb = 1;\n\t\telse\n\t\t\tmb = 0;\n\t\t/* Rewrite the path name if its next character is unusable. */\n\t\tif (*p == ':' || *p == '*' || *p == '?' || *p == '\"' ||\n\t\t    *p == '<' || *p == '>' || *p == '|')\n\t\t\t*p = '_';\n\t}\n\tif (complete)\n\t\treturn;\n\n\t/*\n\t * Convert path separator in wide-character.\n\t */\n\tp = a->name;\n\twhile (*p != '\\0' && alen) {\n\t\tl = mbtowc(&wc, p, alen);\n\t\tif (l == (size_t)-1) {\n\t\t\twhile (*p != '\\0') {\n\t\t\t\tif (*p == '\\\\')\n\t\t\t\t\t*p = '/';\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (l == 1 && wc == L'\\\\')\n\t\t\t*p = '/';\n\t\tp += l;\n\t\talen -= l;\n\t}\n}\n#endif\n\n/*\n * Canonicalize the pathname.  In particular, this strips duplicate\n * '/' characters, '.' elements, and trailing '/'.  It also raises an\n * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is\n * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS\n * is set) if the path is absolute.\n */\nstatic int\ncleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\n\tdest = src = path;\n\tif (*src == '\\0') {\n\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\tif (error_string)\n\t\t    archive_string_sprintf(error_string,\n\t\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\t/* Skip leading '/'. */\n\tif (*src == '/') {\n\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\tif (error_string)\n\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t    \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\n\t\tseparator = *src++;\n\t}\n\n\t/* Scan the pathname one element at a time. */\n\tfor (;;) {\n\t\t/* src points to first char after '/' */\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\t/* Found '//', ignore second one. */\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\t/* Ignore trailing '.' */\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\t/* Skip './'. */\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\t/* Conditionally warn about '..' */\n\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\t\t\t\tif (error_string)\n\t\t\t\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Note: Under no circumstances do we\n\t\t\t\t * remove '..' elements.  In\n\t\t\t\t * particular, restoring\n\t\t\t\t * '/foo/../bar/' should create the\n\t\t\t\t * 'foo' dir as a side-effect.\n\t\t\t\t */\n\t\t\t}\n\t\t}\n\n\t\t/* Copy current element, including leading '/'. */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\n\t\t/* Skip '/' separator. */\n\t\tseparator = *src++;\n\t}\n\t/*\n\t * We've just copied zero or more path elements, not including the\n\t * final '/'.\n\t */\n\tif (dest == path) {\n\t\t/*\n\t\t * Nothing got copied.  The path must have been something\n\t\t * like '.' or '/' or './' or '/././././/./'.\n\t\t */\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t/* Terminate the result. */\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\ncleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\treturn rc;\n}\n\n/*\n * Create the parent directory of the specified path, assuming path\n * is already in mutable storage.\n */\nstatic int\ncreate_parent_dir(struct archive_write_disk *a, char *path)\n{\n\tchar *slash;\n\tint r;\n\n\t/* Remove tail element to obtain parent name. */\n\tslash = strrchr(path, '/');\n\tif (slash == NULL)\n\t\treturn (ARCHIVE_OK);\n\t*slash = '\\0';\n\tr = create_dir(a, path);\n\t*slash = '/';\n\treturn (r);\n}\n\n/*\n * Create the specified dir, recursing to create parents as necessary.\n *\n * Returns ARCHIVE_OK if the path exists when we're done here.\n * Otherwise, returns ARCHIVE_FAILED.\n * Assumes path is in mutable storage; path is unchanged on exit.\n */\nstatic int\ncreate_dir(struct archive_write_disk *a, char *path)\n{\n\tstruct stat st;\n\tstruct fixup_entry *le;\n\tchar *slash, *base;\n\tmode_t mode_final, mode;\n\tint r;\n\n\t/* Check for special names and just skip them. */\n\tslash = strrchr(path, '/');\n\tif (slash == NULL)\n\t\tbase = path;\n\telse\n\t\tbase = slash + 1;\n\n\tif (base[0] == '\\0' ||\n\t    (base[0] == '.' && base[1] == '\\0') ||\n\t    (base[0] == '.' && base[1] == '.' && base[2] == '\\0')) {\n\t\t/* Don't bother trying to create null path, '.', or '..'. */\n\t\tif (slash != NULL) {\n\t\t\t*slash = '\\0';\n\t\t\tr = create_dir(a, path);\n\t\t\t*slash = '/';\n\t\t\treturn (r);\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Yes, this should be stat() and not lstat().  Using lstat()\n\t * here loses the ability to extract through symlinks.  Also note\n\t * that this should not use the a->st cache.\n\t */\n\tif (stat(path, &st) == 0) {\n\t\tif (S_ISDIR(st.st_mode))\n\t\t\treturn (ARCHIVE_OK);\n\t\tif ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {\n\t\t\tarchive_set_error(&a->archive, EEXIST,\n\t\t\t    \"Can't create directory '%s'\", path);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tif (unlink(path) != 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't create directory '%s': \"\n\t\t\t    \"Conflicting file cannot be removed\",\n\t\t\t    path);\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t} else if (errno != ENOENT && errno != ENOTDIR) {\n\t\t/* Stat failed? */\n\t\tarchive_set_error(&a->archive, errno, \"Can't test directory '%s'\", path);\n\t\treturn (ARCHIVE_FAILED);\n\t} else if (slash != NULL) {\n\t\t*slash = '\\0';\n\t\tr = create_dir(a, path);\n\t\t*slash = '/';\n\t\tif (r != ARCHIVE_OK)\n\t\t\treturn (r);\n\t}\n\n\t/*\n\t * Mode we want for the final restored directory.  Per POSIX,\n\t * implicitly-created dirs must be created obeying the umask.\n\t * There's no mention whether this is different for privileged\n\t * restores (which the rest of this code handles by pretending\n\t * umask=0).  I've chosen here to always obey the user's umask for\n\t * implicit dirs, even if _EXTRACT_PERM was specified.\n\t */\n\tmode_final = DEFAULT_DIR_MODE & ~a->user_umask;\n\t/* Mode we want on disk during the restore process. */\n\tmode = mode_final;\n\tmode |= MINIMUM_DIR_MODE;\n\tmode &= MAXIMUM_DIR_MODE;\n\tif (mkdir(path, mode) == 0) {\n\t\tif (mode != mode_final) {\n\t\t\tle = new_fixup(a, path);\n\t\t\tif (le == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tle->fixup |=TODO_MODE_BASE;\n\t\t\tle->mode = mode_final;\n\t\t}\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\t/*\n\t * Without the following check, a/b/../b/c/d fails at the\n\t * second visit to 'b', so 'd' can't be created.  Note that we\n\t * don't add it to the fixup list here, as it's already been\n\t * added.\n\t */\n\tif (stat(path, &st) == 0 && S_ISDIR(st.st_mode))\n\t\treturn (ARCHIVE_OK);\n\n\tarchive_set_error(&a->archive, errno, \"Failed to create dir '%s'\",\n\t    path);\n\treturn (ARCHIVE_FAILED);\n}\n\n/*\n * Note: Although we can skip setting the user id if the desired user\n * id matches the current user, we cannot skip setting the group, as\n * many systems set the gid based on the containing directory.  So\n * we have to perform a chown syscall if we want to set the SGID\n * bit.  (The alternative is to stat() and then possibly chown(); it's\n * more efficient to skip the stat() and just always chown().)  Note\n * that a successful chown() here clears the TODO_SGID_CHECK bit, which\n * allows set_mode to skip the stat() check for the GID.\n */\nstatic int\nset_ownership(struct archive_write_disk *a)\n{\n#ifndef __CYGWIN__\n/* unfortunately, on win32 there is no 'root' user with uid 0,\n   so we just have to try the chown and see if it works */\n\n\t/* If we know we can't change it, don't bother trying. */\n\tif (a->user_uid != 0  &&  a->user_uid != a->uid) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Can't set UID=%jd\", (intmax_t)a->uid);\n\t\treturn (ARCHIVE_WARN);\n\t}\n#endif\n\n#ifdef HAVE_FCHOWN\n\t/* If we have an fd, we can avoid a race. */\n\tif (a->fd >= 0 && fchown(a->fd, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\n\t/* We prefer lchown() but will use chown() if that's all we have. */\n\t/* Of course, if we have neither, this will always fail. */\n#ifdef HAVE_LCHOWN\n\tif (lchown(a->name, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#elif HAVE_CHOWN\n\tif (!S_ISLNK(a->mode) && chown(a->name, a->uid, a->gid) == 0) {\n\t\t/* We've set owner and know uid/gid are correct. */\n\t\ta->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);\n\t\treturn (ARCHIVE_OK);\n\t}\n#endif\n\n\tarchive_set_error(&a->archive, errno,\n\t    \"Can't set user=%jd/group=%jd for %s\",\n\t    (intmax_t)a->uid, (intmax_t)a->gid, a->name);\n\treturn (ARCHIVE_WARN);\n}\n\n/*\n * Note: Returns 0 on success, non-zero on failure.\n */\nstatic int\nset_time(int fd, int mode, const char *name,\n    time_t atime, long atime_nsec,\n    time_t mtime, long mtime_nsec)\n{\n\t/* Select the best implementation for this platform. */\n#if defined(HAVE_UTIMENSAT) && defined(HAVE_FUTIMENS)\n\t/*\n\t * utimensat() and futimens() are defined in\n\t * POSIX.1-2008. They support ns resolution and setting times\n\t * on fds and symlinks.\n\t */\n\tstruct timespec ts[2];\n\t(void)mode; /* UNUSED */\n\tts[0].tv_sec = atime;\n\tts[0].tv_nsec = atime_nsec;\n\tts[1].tv_sec = mtime;\n\tts[1].tv_nsec = mtime_nsec;\n\tif (fd >= 0)\n\t\treturn futimens(fd, ts);\n\treturn utimensat(AT_FDCWD, name, ts, AT_SYMLINK_NOFOLLOW);\n\n#elif HAVE_UTIMES\n\t/*\n\t * The utimes()-family functions support \u00b5s-resolution and\n\t * setting times fds and symlinks.  utimes() is documented as\n\t * LEGACY by POSIX, futimes() and lutimes() are not described\n\t * in POSIX.\n\t */\n\tstruct timeval times[2];\n\n\ttimes[0].tv_sec = atime;\n\ttimes[0].tv_usec = atime_nsec / 1000;\n\ttimes[1].tv_sec = mtime;\n\ttimes[1].tv_usec = mtime_nsec / 1000;\n\n#ifdef HAVE_FUTIMES\n\tif (fd >= 0)\n\t\treturn (futimes(fd, times));\n#else\n\t(void)fd; /* UNUSED */\n#endif\n#ifdef HAVE_LUTIMES\n\t(void)mode; /* UNUSED */\n\treturn (lutimes(name, times));\n#else\n\tif (S_ISLNK(mode))\n\t\treturn (0);\n\treturn (utimes(name, times));\n#endif\n\n#elif defined(HAVE_UTIME)\n\t/*\n\t * utime() is POSIX-standard but only supports 1s resolution and\n\t * does not support fds or symlinks.\n\t */\n\tstruct utimbuf times;\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)atime_nsec; /* UNUSED */\n\t(void)mtime_nsec; /* UNUSED */\n\ttimes.actime = atime;\n\ttimes.modtime = mtime;\n\tif (S_ISLNK(mode))\n\t\treturn (ARCHIVE_OK);\n\treturn (utime(name, &times));\n\n#else\n\t/*\n\t * We don't know how to set the time on this platform.\n\t */\n\t(void)fd; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)atime_nsec; /* UNUSED */\n\t(void)mtime_nsec; /* UNUSED */\n\treturn (ARCHIVE_WARN);\n#endif\n}\n\n#ifdef F_SETTIMES\nstatic int\nset_time_tru64(int fd, int mode, const char *name,\n    time_t atime, long atime_nsec,\n    time_t mtime, long mtime_nsec,\n    time_t ctime, long ctime_nsec)\n{\n\tstruct attr_timbuf tstamp;\n\ttstamp.atime.tv_sec = atime;\n\ttstamp.mtime.tv_sec = mtime;\n\ttstamp.ctime.tv_sec = ctime;\n#if defined (__hpux) && defined (__ia64)\n\ttstamp.atime.tv_nsec = atime_nsec;\n\ttstamp.mtime.tv_nsec = mtime_nsec;\n\ttstamp.ctime.tv_nsec = ctime_nsec;\n#else\n\ttstamp.atime.tv_usec = atime_nsec / 1000;\n\ttstamp.mtime.tv_usec = mtime_nsec / 1000;\n\ttstamp.ctime.tv_usec = ctime_nsec / 1000;\n#endif\n\treturn (fcntl(fd,F_SETTIMES,&tstamp));\n}\n#endif /* F_SETTIMES */\n\nstatic int\nset_times(struct archive_write_disk *a,\n    int fd, int mode, const char *name,\n    time_t atime, long atime_nanos,\n    time_t birthtime, long birthtime_nanos,\n    time_t mtime, long mtime_nanos,\n    time_t cctime, long ctime_nanos)\n{\n\t/* Note: set_time doesn't use libarchive return conventions!\n\t * It uses syscall conventions.  So 0 here instead of ARCHIVE_OK. */\n\tint r1 = 0, r2 = 0;\n\n#ifdef F_SETTIMES\n\t /*\n\t * on Tru64 try own fcntl first which can restore even the\n\t * ctime, fall back to default code path below if it fails\n\t * or if we are not running as root\n\t */\n\tif (a->user_uid == 0 &&\n\t    set_time_tru64(fd, mode, name,\n\t\t\t   atime, atime_nanos, mtime,\n\t\t\t   mtime_nanos, cctime, ctime_nanos) == 0) {\n\t\treturn (ARCHIVE_OK);\n\t}\n#else /* Tru64 */\n\t(void)cctime; /* UNUSED */\n\t(void)ctime_nanos; /* UNUSED */\n#endif /* Tru64 */\n\n#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME\n\t/*\n\t * If you have struct stat.st_birthtime, we assume BSD\n\t * birthtime semantics, in which {f,l,}utimes() updates\n\t * birthtime to earliest mtime.  So we set the time twice,\n\t * first using the birthtime, then using the mtime.  If\n\t * birthtime == mtime, this isn't necessary, so we skip it.\n\t * If birthtime > mtime, then this won't work, so we skip it.\n\t */\n\tif (birthtime < mtime\n\t    || (birthtime == mtime && birthtime_nanos < mtime_nanos))\n\t\tr1 = set_time(fd, mode, name,\n\t\t\t      atime, atime_nanos,\n\t\t\t      birthtime, birthtime_nanos);\n#else\n\t(void)birthtime; /* UNUSED */\n\t(void)birthtime_nanos; /* UNUSED */\n#endif\n\tr2 = set_time(fd, mode, name,\n\t\t      atime, atime_nanos,\n\t\t      mtime, mtime_nanos);\n\tif (r1 != 0 || r2 != 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Can't restore time\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nset_times_from_entry(struct archive_write_disk *a)\n{\n\ttime_t atime, birthtime, mtime, cctime;\n\tlong atime_nsec, birthtime_nsec, mtime_nsec, ctime_nsec;\n\n\t/* Suitable defaults. */\n\tatime = birthtime = mtime = cctime = a->start_time;\n\tatime_nsec = birthtime_nsec = mtime_nsec = ctime_nsec = 0;\n\n\t/* If no time was provided, we're done. */\n\tif (!archive_entry_atime_is_set(a->entry)\n#if HAVE_STRUCT_STAT_ST_BIRTHTIME\n\t    && !archive_entry_birthtime_is_set(a->entry)\n#endif\n\t    && !archive_entry_mtime_is_set(a->entry))\n\t\treturn (ARCHIVE_OK);\n\n\tif (archive_entry_atime_is_set(a->entry)) {\n\t\tatime = archive_entry_atime(a->entry);\n\t\tatime_nsec = archive_entry_atime_nsec(a->entry);\n\t}\n\tif (archive_entry_birthtime_is_set(a->entry)) {\n\t\tbirthtime = archive_entry_birthtime(a->entry);\n\t\tbirthtime_nsec = archive_entry_birthtime_nsec(a->entry);\n\t}\n\tif (archive_entry_mtime_is_set(a->entry)) {\n\t\tmtime = archive_entry_mtime(a->entry);\n\t\tmtime_nsec = archive_entry_mtime_nsec(a->entry);\n\t}\n\tif (archive_entry_ctime_is_set(a->entry)) {\n\t\tcctime = archive_entry_ctime(a->entry);\n\t\tctime_nsec = archive_entry_ctime_nsec(a->entry);\n\t}\n\n\treturn set_times(a, a->fd, a->mode, a->name,\n\t\t\t atime, atime_nsec,\n\t\t\t birthtime, birthtime_nsec,\n\t\t\t mtime, mtime_nsec,\n\t\t\t cctime, ctime_nsec);\n}\n\nstatic int\nset_mode(struct archive_write_disk *a, int mode)\n{\n\tint r = ARCHIVE_OK;\n\tmode &= 07777; /* Strip off file type bits. */\n\n\tif (a->todo & TODO_SGID_CHECK) {\n\t\t/*\n\t\t * If we don't know the GID is right, we must stat()\n\t\t * to verify it.  We can't just check the GID of this\n\t\t * process, since systems sometimes set GID from\n\t\t * the enclosing dir or based on ACLs.\n\t\t */\n\t\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\t\treturn (r);\n\t\tif (a->pst->st_gid != a->gid) {\n\t\t\tmode &= ~ S_ISGID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\t/*\n\t\t\t\t * This is only an error if you\n\t\t\t\t * requested owner restore.  If you\n\t\t\t\t * didn't, we'll try to restore\n\t\t\t\t * sgid/suid, but won't consider it a\n\t\t\t\t * problem if we can't.\n\t\t\t\t */\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't restore SGID bit\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\t/* While we're here, double-check the UID. */\n\t\tif (a->pst->st_uid != a->uid\n\t\t    && (a->todo & TODO_SUID)) {\n\t\t\tmode &= ~ S_ISUID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't restore SUID bit\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\ta->todo &= ~TODO_SGID_CHECK;\n\t\ta->todo &= ~TODO_SUID_CHECK;\n\t} else if (a->todo & TODO_SUID_CHECK) {\n\t\t/*\n\t\t * If we don't know the UID is right, we can just check\n\t\t * the user, since all systems set the file UID from\n\t\t * the process UID.\n\t\t */\n\t\tif (a->user_uid != a->uid) {\n\t\t\tmode &= ~ S_ISUID;\n\t\t\tif (a->flags & ARCHIVE_EXTRACT_OWNER) {\n\t\t\t\tarchive_set_error(&a->archive, -1,\n\t\t\t\t    \"Can't make file SUID\");\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\ta->todo &= ~TODO_SUID_CHECK;\n\t}\n\n\tif (S_ISLNK(a->mode)) {\n#ifdef HAVE_LCHMOD\n\t\t/*\n\t\t * If this is a symlink, use lchmod().  If the\n\t\t * platform doesn't support lchmod(), just skip it.  A\n\t\t * platform that doesn't provide a way to set\n\t\t * permissions on symlinks probably ignores\n\t\t * permissions on symlinks, so a failure here has no\n\t\t * impact.\n\t\t */\n\t\tif (lchmod(a->name, mode) != 0) {\n\t\t\tswitch (errno) {\n\t\t\tcase ENOTSUP:\n\t\t\tcase ENOSYS:\n#if ENOTSUP != EOPNOTSUPP\n\t\t\tcase EOPNOTSUPP:\n#endif\n\t\t\t\t/*\n\t\t\t\t * if lchmod is defined but the platform\n\t\t\t\t * doesn't support it, silently ignore\n\t\t\t\t * error\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n#endif\n\t} else if (!S_ISDIR(a->mode)) {\n\t\t/*\n\t\t * If it's not a symlink and not a dir, then use\n\t\t * fchmod() or chmod(), depending on whether we have\n\t\t * an fd.  Dirs get their perms set during the\n\t\t * post-extract fixup, which is handled elsewhere.\n\t\t */\n#ifdef HAVE_FCHMOD\n\t\tif (a->fd >= 0) {\n\t\t\tif (fchmod(a->fd, mode) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else\n#endif\n\t\t\t/* If this platform lacks fchmod(), then\n\t\t\t * we'll just use chmod(). */\n\t\t\tif (chmod(a->name, mode) != 0) {\n\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t    \"Can't set permissions to 0%o\", (int)mode);\n\t\t\t\tr = ARCHIVE_WARN;\n\t\t\t}\n\t}\n\treturn (r);\n}\n\nstatic int\nset_fflags(struct archive_write_disk *a)\n{\n\tstruct fixup_entry *le;\n\tunsigned long\tset, clear;\n\tint\t\tr;\n\tint\t\tcritical_flags;\n\tmode_t\t\tmode = archive_entry_mode(a->entry);\n\n\t/*\n\t * Make 'critical_flags' hold all file flags that can't be\n\t * immediately restored.  For example, on BSD systems,\n\t * SF_IMMUTABLE prevents hardlinks from being created, so\n\t * should not be set until after any hardlinks are created.  To\n\t * preserve some semblance of portability, this uses #ifdef\n\t * extensively.  Ugly, but it works.\n\t *\n\t * Yes, Virginia, this does create a security race.  It's mitigated\n\t * somewhat by the practice of creating dirs 0700 until the extract\n\t * is done, but it would be nice if we could do more than that.\n\t * People restoring critical file systems should be wary of\n\t * other programs that might try to muck with files as they're\n\t * being restored.\n\t */\n\t/* Hopefully, the compiler will optimize this mess into a constant. */\n\tcritical_flags = 0;\n#ifdef SF_IMMUTABLE\n\tcritical_flags |= SF_IMMUTABLE;\n#endif\n#ifdef UF_IMMUTABLE\n\tcritical_flags |= UF_IMMUTABLE;\n#endif\n#ifdef SF_APPEND\n\tcritical_flags |= SF_APPEND;\n#endif\n#ifdef UF_APPEND\n\tcritical_flags |= UF_APPEND;\n#endif\n#ifdef EXT2_APPEND_FL\n\tcritical_flags |= EXT2_APPEND_FL;\n#endif\n#ifdef EXT2_IMMUTABLE_FL\n\tcritical_flags |= EXT2_IMMUTABLE_FL;\n#endif\n\n\tif (a->todo & TODO_FFLAGS) {\n\t\tarchive_entry_fflags(a->entry, &set, &clear);\n\n\t\t/*\n\t\t * The first test encourages the compiler to eliminate\n\t\t * all of this if it's not necessary.\n\t\t */\n\t\tif ((critical_flags != 0)  &&  (set & critical_flags)) {\n\t\t\tle = current_fixup(a, a->name);\n\t\t\tif (le == NULL)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\tle->fixup |= TODO_FFLAGS;\n\t\t\tle->fflags_set = set;\n\t\t\t/* Store the mode if it's not already there. */\n\t\t\tif ((le->fixup & TODO_MODE) == 0)\n\t\t\t\tle->mode = mode;\n\t\t} else {\n\t\t\tr = set_fflags_platform(a, a->fd,\n\t\t\t    a->name, mode, set, clear);\n\t\t\tif (r != ARCHIVE_OK)\n\t\t\t\treturn (r);\n\t\t}\n\t}\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nclear_nochange_fflags(struct archive_write_disk *a)\n{\n\tint\t\tnochange_flags;\n\tmode_t\t\tmode = archive_entry_mode(a->entry);\n\n\t/* Hopefully, the compiler will optimize this mess into a constant. */\n\tnochange_flags = 0;\n#ifdef SF_IMMUTABLE\n\tnochange_flags |= SF_IMMUTABLE;\n#endif\n#ifdef UF_IMMUTABLE\n\tnochange_flags |= UF_IMMUTABLE;\n#endif\n#ifdef SF_APPEND\n\tnochange_flags |= SF_APPEND;\n#endif\n#ifdef UF_APPEND\n\tnochange_flags |= UF_APPEND;\n#endif\n#ifdef EXT2_APPEND_FL\n\tnochange_flags |= EXT2_APPEND_FL;\n#endif\n#ifdef EXT2_IMMUTABLE_FL\n\tnochange_flags |= EXT2_IMMUTABLE_FL;\n#endif\n\n\treturn (set_fflags_platform(a, a->fd, a->name, mode, 0, nochange_flags));\n}\n\n\n#if ( defined(HAVE_LCHFLAGS) || defined(HAVE_CHFLAGS) || defined(HAVE_FCHFLAGS) ) && defined(HAVE_STRUCT_STAT_ST_FLAGS)\n/*\n * BSD reads flags using stat() and sets them with one of {f,l,}chflags()\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint r;\n\n\t(void)mode; /* UNUSED */\n\tif (set == 0  && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * XXX Is the stat here really necessary?  Or can I just use\n\t * the 'set' flags directly?  In particular, I'm not sure\n\t * about the correct approach if we're overwriting an existing\n\t * file that already has flags on it. XXX\n\t */\n\tif ((r = lazy_stat(a)) != ARCHIVE_OK)\n\t\treturn (r);\n\n\ta->st.st_flags &= ~clear;\n\ta->st.st_flags |= set;\n#ifdef HAVE_FCHFLAGS\n\t/* If platform has fchflags() and we were given an fd, use it. */\n\tif (fd >= 0 && fchflags(fd, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#endif\n\t/*\n\t * If we can't use the fd to set the flags, we'll use the\n\t * pathname to set flags.  We prefer lchflags() but will use\n\t * chflags() if we must.\n\t */\n#ifdef HAVE_LCHFLAGS\n\tif (lchflags(name, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#elif defined(HAVE_CHFLAGS)\n\tif (S_ISLNK(a->st.st_mode)) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Can't set file flags on symlink.\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\tif (chflags(name, a->st.st_flags) == 0)\n\t\treturn (ARCHIVE_OK);\n#endif\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\treturn (ARCHIVE_WARN);\n}\n\n#elif defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(HAVE_WORKING_EXT2_IOC_GETFLAGS)\n/*\n * Linux uses ioctl() to read and write file flags.\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tint sf_mask = 0;\n\n\tif (set == 0  && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\t/* Only regular files and dirs can have flags. */\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\n\t/* If we weren't given an fd, open it ourselves. */\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\n\t/*\n\t * Linux has no define for the flags that are only settable by\n\t * the root user.  This code may seem a little complex, but\n\t * there seem to be some Linux systems that lack these\n\t * defines. (?)  The code below degrades reasonably gracefully\n\t * if sf_mask is incomplete.\n\t */\n#ifdef EXT2_IMMUTABLE_FL\n\tsf_mask |= EXT2_IMMUTABLE_FL;\n#endif\n#ifdef EXT2_APPEND_FL\n\tsf_mask |= EXT2_APPEND_FL;\n#endif\n\t/*\n\t * XXX As above, this would be way simpler if we didn't have\n\t * to read the current flags from disk. XXX\n\t */\n\tret = ARCHIVE_OK;\n\n\t/* Read the current file flags. */\n\tif (ioctl(myfd, EXT2_IOC_GETFLAGS, &oldflags) < 0)\n\t\tgoto fail;\n\n\t/* Try setting the flags as given. */\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\n\t/* If we couldn't set all the flags, try again with a subset. */\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)\n\t\tgoto cleanup;\n\n\t/* We couldn't set the flags, so report the failure. */\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}\n\n#else\n\n/*\n * Of course, some systems have neither BSD chflags() nor Linux' flags\n * support through ioctl().\n */\nstatic int\nset_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\n#endif /* __linux */\n\n#ifndef HAVE_COPYFILE_H\n/* Default is to simply drop Mac extended metadata. */\nstatic int\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\t(void)metadata; /* UNUSED */\n\t(void)metadata_size; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\nstatic int\nfixup_appledouble(struct archive_write_disk *a, const char *pathname)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n#else\n\n/*\n * On Mac OS, we use copyfile() to unpack the metadata and\n * apply it to the target file.\n */\n\n#if defined(HAVE_SYS_XATTR_H)\nstatic int\ncopy_xattrs(struct archive_write_disk *a, int tmpfd, int dffd)\n{\n\tssize_t xattr_size;\n\tchar *xattr_names = NULL, *xattr_val = NULL;\n\tint ret = ARCHIVE_OK, xattr_i;\n\n\txattr_size = flistxattr(tmpfd, NULL, 0, 0);\n\tif (xattr_size == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read metadata(xattr)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_xattr;\n\t}\n\txattr_names = malloc(xattr_size);\n\tif (xattr_names == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for metadata(xattr)\");\n\t\tret = ARCHIVE_FATAL;\n\t\tgoto exit_xattr;\n\t}\n\txattr_size = flistxattr(tmpfd, xattr_names, xattr_size, 0);\n\tif (xattr_size == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read metadata(xattr)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_xattr;\n\t}\n\tfor (xattr_i = 0; xattr_i < xattr_size;\n\t    xattr_i += strlen(xattr_names + xattr_i) + 1) {\n\t\tchar *xattr_val_saved;\n\t\tssize_t s;\n\t\tint f;\n\n\t\ts = fgetxattr(tmpfd, xattr_names + xattr_i, NULL, 0, 0, 0);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\txattr_val_saved = xattr_val;\n\t\txattr_val = realloc(xattr_val, s);\n\t\tif (xattr_val == NULL) {\n\t\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tfree(xattr_val_saved);\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\ts = fgetxattr(tmpfd, xattr_names + xattr_i, xattr_val, s, 0, 0);\n\t\tif (s == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t\tf = fsetxattr(dffd, xattr_names + xattr_i, xattr_val, s, 0, 0);\n\t\tif (f == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to get metadata(xattr)\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t\tgoto exit_xattr;\n\t\t}\n\t}\nexit_xattr:\n\tfree(xattr_names);\n\tfree(xattr_val);\n\treturn (ret);\n}\n#endif\n\nstatic int\ncopy_acls(struct archive_write_disk *a, int tmpfd, int dffd)\n{\n#ifndef HAVE_SYS_ACL_H\n\treturn 0;\n#else\n\tacl_t acl, dfacl = NULL;\n\tint acl_r, ret = ARCHIVE_OK;\n\n\tacl = acl_get_fd(tmpfd);\n\tif (acl == NULL) {\n\t\tif (errno == ENOENT)\n\t\t\t/* There are not any ACLs. */\n\t\t\treturn (ret);\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get metadata(acl)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_acl;\n\t}\n\tdfacl = acl_dup(acl);\n\tacl_r = acl_set_fd(dffd, dfacl);\n\tif (acl_r == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to get metadata(acl)\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto exit_acl;\n\t}\nexit_acl:\n\tif (acl)\n\t\tacl_free(acl);\n\tif (dfacl)\n\t\tacl_free(dfacl);\n\treturn (ret);\n#endif\n}\n\nstatic int\ncreate_tempdatafork(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct archive_string tmpdatafork;\n\tint tmpfd;\n\n\tarchive_string_init(&tmpdatafork);\n\tarchive_strcpy(&tmpdatafork, \"tar.md.XXXXXX\");\n\ttmpfd = mkstemp(tmpdatafork.s);\n\tif (tmpfd < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to mkstemp\");\n\t\tarchive_string_free(&tmpdatafork);\n\t\treturn (-1);\n\t}\n\tif (copyfile(pathname, tmpdatafork.s, 0,\n\t    COPYFILE_UNPACK | COPYFILE_NOFOLLOW\n\t    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to restore metadata\");\n\t\tclose(tmpfd);\n\t\ttmpfd = -1;\n\t}\n\tunlink(tmpdatafork.s);\n\tarchive_string_free(&tmpdatafork);\n\treturn (tmpfd);\n}\n\nstatic int\ncopy_metadata(struct archive_write_disk *a, const char *metadata,\n    const char *datafork, int datafork_compressed)\n{\n\tint ret = ARCHIVE_OK;\n\n\tif (datafork_compressed) {\n\t\tint dffd, tmpfd;\n\n\t\ttmpfd = create_tempdatafork(a, metadata);\n\t\tif (tmpfd == -1)\n\t\t\treturn (ARCHIVE_WARN);\n\n\t\t/*\n\t\t * Do not open the data fork compressed by HFS+ compression\n\t\t * with at least a writing mode(O_RDWR or O_WRONLY). it\n\t\t * makes the data fork uncompressed.\n\t\t */\n\t\tdffd = open(datafork, 0);\n\t\tif (dffd == -1) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to open the data fork for metadata\");\n\t\t\tclose(tmpfd);\n\t\t\treturn (ARCHIVE_WARN);\n\t\t}\n\n#if defined(HAVE_SYS_XATTR_H)\n\t\tret = copy_xattrs(a, tmpfd, dffd);\n\t\tif (ret == ARCHIVE_OK)\n#endif\n\t\t\tret = copy_acls(a, tmpfd, dffd);\n\t\tclose(tmpfd);\n\t\tclose(dffd);\n\t} else {\n\t\tif (copyfile(metadata, datafork, 0,\n\t\t    COPYFILE_UNPACK | COPYFILE_NOFOLLOW\n\t\t    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Failed to restore metadata\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\treturn (ret);\n}\n\nstatic int\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\tstruct archive_string tmp;\n\tssize_t written;\n\tint fd;\n\tint ret = ARCHIVE_OK;\n\n\t/* This would be simpler if copyfile() could just accept the\n\t * metadata as a block of memory; then we could sidestep this\n\t * silly dance of writing the data to disk just so that\n\t * copyfile() can read it back in again. */\n\tarchive_string_init(&tmp);\n\tarchive_strcpy(&tmp, pathname);\n\tarchive_strcat(&tmp, \".XXXXXX\");\n\tfd = mkstemp(tmp.s);\n\n\tif (fd < 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Failed to restore metadata\");\n\t\tarchive_string_free(&tmp);\n\t\treturn (ARCHIVE_WARN);\n\t}\n\twritten = write(fd, metadata, metadata_size);\n\tclose(fd);\n\tif ((size_t)written != metadata_size) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t  \"Failed to restore metadata\");\n\t\tret = ARCHIVE_WARN;\n\t} else {\n\t\tint compressed;\n\n#if defined(UF_COMPRESSED)\n\t\tif ((a->todo & TODO_HFS_COMPRESSION) != 0 &&\n\t\t    (ret = lazy_stat(a)) == ARCHIVE_OK)\n\t\t\tcompressed = a->st.st_flags & UF_COMPRESSED;\n\t\telse\n#endif\n\t\t\tcompressed = 0;\n\t\tret = copy_metadata(a, tmp.s, pathname, compressed);\n\t}\n\tunlink(tmp.s);\n\tarchive_string_free(&tmp);\n\treturn (ret);\n}\n\nstatic int\nfixup_appledouble(struct archive_write_disk *a, const char *pathname)\n{\n\tchar buff[8];\n\tstruct stat st;\n\tconst char *p;\n\tstruct archive_string datafork;\n\tint fd = -1, ret = ARCHIVE_OK;\n\n\tarchive_string_init(&datafork);\n\t/* Check if the current file name is a type of the resource\n\t * fork file. */\n\tp = strrchr(pathname, '/');\n\tif (p == NULL)\n\t\tp = pathname;\n\telse\n\t\tp++;\n\tif (p[0] != '.' || p[1] != '_')\n\t\tgoto skip_appledouble;\n\n\t/*\n\t * Check if the data fork file exists.\n\t *\n\t * TODO: Check if this write disk object has handled it.\n\t */\n\tarchive_strncpy(&datafork, pathname, p - pathname);\n\tarchive_strcat(&datafork, p + 2);\n\tif (lstat(datafork.s, &st) == -1 ||\n\t    (st.st_mode & AE_IFMT) != AE_IFREG)\n\t\tgoto skip_appledouble;\n\n\t/*\n\t * Check if the file is in the AppleDouble form.\n\t */\n\tfd = open(pathname, O_RDONLY | O_BINARY | O_CLOEXEC);\n\t__archive_ensure_cloexec_flag(fd);\n\tif (fd == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to open a restoring file\");\n\t\tret = ARCHIVE_WARN;\n\t\tgoto skip_appledouble;\n\t}\n\tif (read(fd, buff, 8) == -1) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Failed to read a restoring file\");\n\t\tclose(fd);\n\t\tret = ARCHIVE_WARN;\n\t\tgoto skip_appledouble;\n\t}\n\tclose(fd);\n\t/* Check AppleDouble Magic Code. */\n\tif (archive_be32dec(buff) != 0x00051607)\n\t\tgoto skip_appledouble;\n\t/* Check AppleDouble Version. */\n\tif (archive_be32dec(buff+4) != 0x00020000)\n\t\tgoto skip_appledouble;\n\n\tret = copy_metadata(a, pathname, datafork.s,\n#if defined(UF_COMPRESSED)\n\t    st.st_flags & UF_COMPRESSED);\n#else\n\t    0);\n#endif\n\tif (ret == ARCHIVE_OK) {\n\t\tunlink(pathname);\n\t\tret = ARCHIVE_EOF;\n\t}\nskip_appledouble:\n\tarchive_string_free(&datafork);\n\treturn (ret);\n}\n#endif\n\n#if HAVE_LSETXATTR || HAVE_LSETEA\n/*\n * Restore extended attributes -  Linux and AIX implementations:\n * AIX' ea interface is syntaxwise identical to the Linux xattr interface.\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstruct archive_entry *entry = a->entry;\n\tstatic int warning_done = 0;\n\tint ret = ARCHIVE_OK;\n\tint i = archive_entry_xattr_reset(entry);\n\n\twhile (i--) {\n\t\tconst char *name;\n\t\tconst void *value;\n\t\tsize_t size;\n\t\tarchive_entry_xattr_next(entry, &name, &value, &size);\n\t\tif (name != NULL &&\n\t\t\t\tstrncmp(name, \"xfsroot.\", 8) != 0 &&\n\t\t\t\tstrncmp(name, \"system.\", 7) != 0) {\n\t\t\tint e;\n#if HAVE_FSETXATTR\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = fsetxattr(a->fd, name, value, size, 0);\n\t\t\telse\n#elif HAVE_FSETEA\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = fsetea(a->fd, name, value, size, 0);\n\t\t\telse\n#endif\n\t\t\t{\n#if HAVE_LSETXATTR\n\t\t\t\te = lsetxattr(archive_entry_pathname(entry),\n\t\t\t\t    name, value, size, 0);\n#elif HAVE_LSETEA\n\t\t\t\te = lsetea(archive_entry_pathname(entry),\n\t\t\t\t    name, value, size, 0);\n#endif\n\t\t\t}\n\t\t\tif (e == -1) {\n\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {\n\t\t\t\t\tif (!warning_done) {\n\t\t\t\t\t\twarning_done = 1;\n\t\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t    \"Cannot restore extended \"\n\t\t\t\t\t\t    \"attributes on this file \"\n\t\t\t\t\t\t    \"system\");\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to set extended attribute\");\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t} else {\n\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Invalid extended attribute encountered\");\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\n\treturn (ret);\n}\n#elif HAVE_EXTATTR_SET_FILE && HAVE_DECL_EXTATTR_NAMESPACE_USER\n/*\n * Restore extended attributes -  FreeBSD implementation\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstruct archive_entry *entry = a->entry;\n\tstatic int warning_done = 0;\n\tint ret = ARCHIVE_OK;\n\tint i = archive_entry_xattr_reset(entry);\n\n\twhile (i--) {\n\t\tconst char *name;\n\t\tconst void *value;\n\t\tsize_t size;\n\t\tarchive_entry_xattr_next(entry, &name, &value, &size);\n\t\tif (name != NULL) {\n\t\t\tint e;\n\t\t\tint namespace;\n\n\t\t\tif (strncmp(name, \"user.\", 5) == 0) {\n\t\t\t\t/* \"user.\" attributes go to user namespace */\n\t\t\t\tname += 5;\n\t\t\t\tnamespace = EXTATTR_NAMESPACE_USER;\n\t\t\t} else {\n\t\t\t\t/* Warn about other extended attributes. */\n\t\t\t\tarchive_set_error(&a->archive,\n\t\t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Can't restore extended attribute ``%s''\",\n\t\t\t\t    name);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terrno = 0;\n#if HAVE_EXTATTR_SET_FD\n\t\t\tif (a->fd >= 0)\n\t\t\t\te = extattr_set_fd(a->fd, namespace, name, value, size);\n\t\t\telse\n#endif\n\t\t\t/* TODO: should we use extattr_set_link() instead? */\n\t\t\t{\n\t\t\t\te = extattr_set_file(archive_entry_pathname(entry),\n\t\t\t\t    namespace, name, value, size);\n\t\t\t}\n\t\t\tif (e != (int)size) {\n\t\t\t\tif (errno == ENOTSUP || errno == ENOSYS) {\n\t\t\t\t\tif (!warning_done) {\n\t\t\t\t\t\twarning_done = 1;\n\t\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t\t    \"Cannot restore extended \"\n\t\t\t\t\t\t    \"attributes on this file \"\n\t\t\t\t\t\t    \"system\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t\t\t    \"Failed to set extended attribute\");\n\t\t\t\t}\n\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n\treturn (ret);\n}\n#else\n/*\n * Restore extended attributes - stub implementation for unsupported systems\n */\nstatic int\nset_xattrs(struct archive_write_disk *a)\n{\n\tstatic int warning_done = 0;\n\n\t/* If there aren't any extended attributes, then it's okay not\n\t * to extract them, otherwise, issue a single warning. */\n\tif (archive_entry_xattr_count(a->entry) != 0 && !warning_done) {\n\t\twarning_done = 1;\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t    \"Cannot restore extended attributes on this system\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\t/* Warning was already emitted; suppress further warnings. */\n\treturn (ARCHIVE_OK);\n}\n#endif\n\n/*\n * Test if file on disk is older than entry.\n */\nstatic int\nolder(struct stat *st, struct archive_entry *entry)\n{\n\t/* First, test the seconds and return if we have a definite answer. */\n\t/* Definitely older. */\n\tif (st->st_mtime < archive_entry_mtime(entry))\n\t\treturn (1);\n\t/* Definitely younger. */\n\tif (st->st_mtime > archive_entry_mtime(entry))\n\t\treturn (0);\n\t/* If this platform supports fractional seconds, try those. */\n#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC\n\t/* Definitely older. */\n\tif (st->st_mtimespec.tv_nsec < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC\n\t/* Definitely older. */\n\tif (st->st_mtim.tv_nsec < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIME_N\n\t/* older. */\n\tif (st->st_mtime_n < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_UMTIME\n\t/* older. */\n\tif (st->st_umtime * 1000 < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#elif HAVE_STRUCT_STAT_ST_MTIME_USEC\n\t/* older. */\n\tif (st->st_mtime_usec * 1000 < archive_entry_mtime_nsec(entry))\n\t\treturn (1);\n#else\n\t/* This system doesn't have high-res timestamps. */\n#endif\n\t/* Same age or newer, so not older. */\n\treturn (0);\n}\n\n#endif /* !_WIN32 || __CYGWIN__ */\n\n"], "filenames": ["libarchive/archive_write_disk_posix.c"], "buggy_code_start_loc": [328], "buggy_code_end_loc": [2639], "fixing_code_start_loc": [329], "fixing_code_end_loc": [2800], "type": "CWE-19", "message": "The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file.", "other": {"cve": {"id": "CVE-2016-5418", "sourceIdentifier": "secalert@redhat.com", "published": "2016-09-21T14:25:13.457", "lastModified": "2019-12-27T16:08:55.810", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The sandboxing code in libarchive 3.2.0 and earlier mishandles hardlink archive entries of non-zero data size, which might allow remote attackers to write to arbitrary files via a crafted archive file."}, {"lang": "es", "value": "El c\u00f3digo sandboxing en libarchive 3.2.0 y versiones anteriores no maneja adecuadamente entradas de archivo de v\u00ednculo f\u00edsico de datos de tama\u00f1o distinto de cero, lo que podr\u00eda permitir a atacantes remotos escribir a archivos arbitrarios a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-19"}, {"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2FAC325-6EEB-466D-9EBA-8ED4DBC9CFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:*:*:*:*:*:*:*", "matchCriteriaId": "CC7A498A-A669-4C42-8134-86103C799D13"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:*:*:*:*:*:*:*", "matchCriteriaId": "104DA87B-DEE4-4262-AE50-8E6BC43B228B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift:3.1:*:*:*:enterprise:*:*:*", "matchCriteriaId": "F8E35FAB-695F-44DA-945D-60B47C1F200B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift:3.2:*:*:*:enterprise:*:*:*", "matchCriteriaId": "F33CEF04-05FA-444C-BB14-F3E3434AF61F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libarchive:libarchive:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.2.0", "matchCriteriaId": "6A6EFED3-4FD3-413D-85C2-73F746F346E8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "39A901D6-0874-46A4-92A8-5F72C7A89E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "1C8D871B-AEA1-4407-AEE3-47EC782250FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "44B067C7-735E-43C9-9188-7E1522A02491"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2016-1844.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-1850.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/08/09/2", "source": "secalert@redhat.com", "tags": ["Exploit", "Technical Description"]}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93165", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2016:1852", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1853", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1362601", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://gist.github.com/anonymous/e48209b03f1dd9625a992717e7b89c4f", "source": "secalert@redhat.com", "tags": ["Exploit", "Technical Description"]}, {"url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/libarchive/libarchive/issues/746", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201701-03", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/libarchive/libarchive/commit/dfd6b54ce33960e420fb206d8872fb759b577ad9"}}