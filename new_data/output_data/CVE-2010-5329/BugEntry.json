{"buggy_code": ["/*\n * Video capture interface for Linux version 2\n *\n * A generic framework to process V4L2 ioctl commands.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * Authors:\tAlan Cox, <alan@lxorguk.ukuu.org.uk> (version 1)\n *              Mauro Carvalho Chehab <mchehab@infradead.org> (version 2)\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-chip-ident.h>\n\n#define dbgarg(cmd, fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG) {\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \",  vfd->name);\t\t\\\n\t\t\tv4l_printk_ioctl(cmd);\t\t\t\t\\\n\t\t\tprintk(\" \" fmt,  ## arg);\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t} while (0)\n\n#define dbgarg2(fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG)\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" fmt, vfd->name, ## arg);\\\n\t\t} while (0)\n\n#define dbgarg3(fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG)\t\t\\\n\t\t\tprintk(KERN_CONT \"%s: \" fmt, vfd->name, ## arg);\\\n\t\t} while (0)\n\n/* Zero out the end of the struct pointed to by p.  Everthing after, but\n * not including, the specified field is cleared. */\n#define CLEAR_AFTER_FIELD(p, field) \\\n\tmemset((u8 *)(p) + offsetof(typeof(*(p)), field) + sizeof((p)->field), \\\n\t0, sizeof(*(p)) - offsetof(typeof(*(p)), field) - sizeof((p)->field))\n\nstruct std_descr {\n\tv4l2_std_id std;\n\tconst char *descr;\n};\n\nstatic const struct std_descr standards[] = {\n\t{ V4L2_STD_NTSC, \t\"NTSC\"      },\n\t{ V4L2_STD_NTSC_M, \t\"NTSC-M\"    },\n\t{ V4L2_STD_NTSC_M_JP, \t\"NTSC-M-JP\" },\n\t{ V4L2_STD_NTSC_M_KR,\t\"NTSC-M-KR\" },\n\t{ V4L2_STD_NTSC_443, \t\"NTSC-443\"  },\n\t{ V4L2_STD_PAL, \t\"PAL\"       },\n\t{ V4L2_STD_PAL_BG, \t\"PAL-BG\"    },\n\t{ V4L2_STD_PAL_B, \t\"PAL-B\"     },\n\t{ V4L2_STD_PAL_B1, \t\"PAL-B1\"    },\n\t{ V4L2_STD_PAL_G, \t\"PAL-G\"     },\n\t{ V4L2_STD_PAL_H, \t\"PAL-H\"     },\n\t{ V4L2_STD_PAL_I, \t\"PAL-I\"     },\n\t{ V4L2_STD_PAL_DK, \t\"PAL-DK\"    },\n\t{ V4L2_STD_PAL_D, \t\"PAL-D\"     },\n\t{ V4L2_STD_PAL_D1, \t\"PAL-D1\"    },\n\t{ V4L2_STD_PAL_K, \t\"PAL-K\"     },\n\t{ V4L2_STD_PAL_M, \t\"PAL-M\"     },\n\t{ V4L2_STD_PAL_N, \t\"PAL-N\"     },\n\t{ V4L2_STD_PAL_Nc, \t\"PAL-Nc\"    },\n\t{ V4L2_STD_PAL_60, \t\"PAL-60\"    },\n\t{ V4L2_STD_SECAM, \t\"SECAM\"     },\n\t{ V4L2_STD_SECAM_B, \t\"SECAM-B\"   },\n\t{ V4L2_STD_SECAM_G, \t\"SECAM-G\"   },\n\t{ V4L2_STD_SECAM_H, \t\"SECAM-H\"   },\n\t{ V4L2_STD_SECAM_DK, \t\"SECAM-DK\"  },\n\t{ V4L2_STD_SECAM_D, \t\"SECAM-D\"   },\n\t{ V4L2_STD_SECAM_K, \t\"SECAM-K\"   },\n\t{ V4L2_STD_SECAM_K1, \t\"SECAM-K1\"  },\n\t{ V4L2_STD_SECAM_L, \t\"SECAM-L\"   },\n\t{ V4L2_STD_SECAM_LC, \t\"SECAM-Lc\"  },\n\t{ 0, \t\t\t\"Unknown\"   }\n};\n\n/* video4linux standard ID conversion to standard name\n */\nconst char *v4l2_norm_to_name(v4l2_std_id id)\n{\n\tu32 myid = id;\n\tint i;\n\n\t/* HACK: ppc32 architecture doesn't have __ucmpdi2 function to handle\n\t   64 bit comparations. So, on that architecture, with some gcc\n\t   variants, compilation fails. Currently, the max value is 30bit wide.\n\t */\n\tBUG_ON(myid != id);\n\n\tfor (i = 0; standards[i].std; i++)\n\t\tif (myid == standards[i].std)\n\t\t\tbreak;\n\treturn standards[i].descr;\n}\nEXPORT_SYMBOL(v4l2_norm_to_name);\n\n/* Returns frame period for the given standard */\nvoid v4l2_video_std_frame_period(int id, struct v4l2_fract *frameperiod)\n{\n\tif (id & V4L2_STD_525_60) {\n\t\tframeperiod->numerator = 1001;\n\t\tframeperiod->denominator = 30000;\n\t} else {\n\t\tframeperiod->numerator = 1;\n\t\tframeperiod->denominator = 25;\n\t}\n}\nEXPORT_SYMBOL(v4l2_video_std_frame_period);\n\n/* Fill in the fields of a v4l2_standard structure according to the\n   'id' and 'transmission' parameters.  Returns negative on error.  */\nint v4l2_video_std_construct(struct v4l2_standard *vs,\n\t\t\t     int id, const char *name)\n{\n\tvs->id = id;\n\tv4l2_video_std_frame_period(id, &vs->frameperiod);\n\tvs->framelines = (id & V4L2_STD_525_60) ? 525 : 625;\n\tstrlcpy(vs->name, name, sizeof(vs->name));\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_video_std_construct);\n\n/* ----------------------------------------------------------------- */\n/* some arrays for pretty-printing debug messages of enum types      */\n\nconst char *v4l2_field_names[] = {\n\t[V4L2_FIELD_ANY]        = \"any\",\n\t[V4L2_FIELD_NONE]       = \"none\",\n\t[V4L2_FIELD_TOP]        = \"top\",\n\t[V4L2_FIELD_BOTTOM]     = \"bottom\",\n\t[V4L2_FIELD_INTERLACED] = \"interlaced\",\n\t[V4L2_FIELD_SEQ_TB]     = \"seq-tb\",\n\t[V4L2_FIELD_SEQ_BT]     = \"seq-bt\",\n\t[V4L2_FIELD_ALTERNATE]  = \"alternate\",\n\t[V4L2_FIELD_INTERLACED_TB] = \"interlaced-tb\",\n\t[V4L2_FIELD_INTERLACED_BT] = \"interlaced-bt\",\n};\nEXPORT_SYMBOL(v4l2_field_names);\n\nconst char *v4l2_type_names[] = {\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE]      = \"vid-cap\",\n\t[V4L2_BUF_TYPE_VIDEO_OVERLAY]      = \"vid-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT]       = \"vid-out\",\n\t[V4L2_BUF_TYPE_VBI_CAPTURE]        = \"vbi-cap\",\n\t[V4L2_BUF_TYPE_VBI_OUTPUT]         = \"vbi-out\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_CAPTURE] = \"sliced-vbi-cap\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_OUTPUT]  = \"sliced-vbi-out\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY] = \"vid-out-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE] = \"vid-cap-mplane\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE] = \"vid-out-mplane\",\n};\nEXPORT_SYMBOL(v4l2_type_names);\n\nstatic const char *v4l2_memory_names[] = {\n\t[V4L2_MEMORY_MMAP]    = \"mmap\",\n\t[V4L2_MEMORY_USERPTR] = \"userptr\",\n\t[V4L2_MEMORY_OVERLAY] = \"overlay\",\n};\n\n#define prt_names(a, arr) ((((a) >= 0) && ((a) < ARRAY_SIZE(arr))) ? \\\n\t\t\t   arr[a] : \"unknown\")\n\n/* ------------------------------------------------------------------ */\n/* debug help functions                                               */\nstatic const char *v4l2_ioctls[] = {\n\t[_IOC_NR(VIDIOC_QUERYCAP)]         = \"VIDIOC_QUERYCAP\",\n\t[_IOC_NR(VIDIOC_RESERVED)]         = \"VIDIOC_RESERVED\",\n\t[_IOC_NR(VIDIOC_ENUM_FMT)]         = \"VIDIOC_ENUM_FMT\",\n\t[_IOC_NR(VIDIOC_G_FMT)]            = \"VIDIOC_G_FMT\",\n\t[_IOC_NR(VIDIOC_S_FMT)]            = \"VIDIOC_S_FMT\",\n\t[_IOC_NR(VIDIOC_REQBUFS)]          = \"VIDIOC_REQBUFS\",\n\t[_IOC_NR(VIDIOC_QUERYBUF)]         = \"VIDIOC_QUERYBUF\",\n\t[_IOC_NR(VIDIOC_G_FBUF)]           = \"VIDIOC_G_FBUF\",\n\t[_IOC_NR(VIDIOC_S_FBUF)]           = \"VIDIOC_S_FBUF\",\n\t[_IOC_NR(VIDIOC_OVERLAY)]          = \"VIDIOC_OVERLAY\",\n\t[_IOC_NR(VIDIOC_QBUF)]             = \"VIDIOC_QBUF\",\n\t[_IOC_NR(VIDIOC_DQBUF)]            = \"VIDIOC_DQBUF\",\n\t[_IOC_NR(VIDIOC_STREAMON)]         = \"VIDIOC_STREAMON\",\n\t[_IOC_NR(VIDIOC_STREAMOFF)]        = \"VIDIOC_STREAMOFF\",\n\t[_IOC_NR(VIDIOC_G_PARM)]           = \"VIDIOC_G_PARM\",\n\t[_IOC_NR(VIDIOC_S_PARM)]           = \"VIDIOC_S_PARM\",\n\t[_IOC_NR(VIDIOC_G_STD)]            = \"VIDIOC_G_STD\",\n\t[_IOC_NR(VIDIOC_S_STD)]            = \"VIDIOC_S_STD\",\n\t[_IOC_NR(VIDIOC_ENUMSTD)]          = \"VIDIOC_ENUMSTD\",\n\t[_IOC_NR(VIDIOC_ENUMINPUT)]        = \"VIDIOC_ENUMINPUT\",\n\t[_IOC_NR(VIDIOC_G_CTRL)]           = \"VIDIOC_G_CTRL\",\n\t[_IOC_NR(VIDIOC_S_CTRL)]           = \"VIDIOC_S_CTRL\",\n\t[_IOC_NR(VIDIOC_G_TUNER)]          = \"VIDIOC_G_TUNER\",\n\t[_IOC_NR(VIDIOC_S_TUNER)]          = \"VIDIOC_S_TUNER\",\n\t[_IOC_NR(VIDIOC_G_AUDIO)]          = \"VIDIOC_G_AUDIO\",\n\t[_IOC_NR(VIDIOC_S_AUDIO)]          = \"VIDIOC_S_AUDIO\",\n\t[_IOC_NR(VIDIOC_QUERYCTRL)]        = \"VIDIOC_QUERYCTRL\",\n\t[_IOC_NR(VIDIOC_QUERYMENU)]        = \"VIDIOC_QUERYMENU\",\n\t[_IOC_NR(VIDIOC_G_INPUT)]          = \"VIDIOC_G_INPUT\",\n\t[_IOC_NR(VIDIOC_S_INPUT)]          = \"VIDIOC_S_INPUT\",\n\t[_IOC_NR(VIDIOC_G_OUTPUT)]         = \"VIDIOC_G_OUTPUT\",\n\t[_IOC_NR(VIDIOC_S_OUTPUT)]         = \"VIDIOC_S_OUTPUT\",\n\t[_IOC_NR(VIDIOC_ENUMOUTPUT)]       = \"VIDIOC_ENUMOUTPUT\",\n\t[_IOC_NR(VIDIOC_G_AUDOUT)]         = \"VIDIOC_G_AUDOUT\",\n\t[_IOC_NR(VIDIOC_S_AUDOUT)]         = \"VIDIOC_S_AUDOUT\",\n\t[_IOC_NR(VIDIOC_G_MODULATOR)]      = \"VIDIOC_G_MODULATOR\",\n\t[_IOC_NR(VIDIOC_S_MODULATOR)]      = \"VIDIOC_S_MODULATOR\",\n\t[_IOC_NR(VIDIOC_G_FREQUENCY)]      = \"VIDIOC_G_FREQUENCY\",\n\t[_IOC_NR(VIDIOC_S_FREQUENCY)]      = \"VIDIOC_S_FREQUENCY\",\n\t[_IOC_NR(VIDIOC_CROPCAP)]          = \"VIDIOC_CROPCAP\",\n\t[_IOC_NR(VIDIOC_G_CROP)]           = \"VIDIOC_G_CROP\",\n\t[_IOC_NR(VIDIOC_S_CROP)]           = \"VIDIOC_S_CROP\",\n\t[_IOC_NR(VIDIOC_G_JPEGCOMP)]       = \"VIDIOC_G_JPEGCOMP\",\n\t[_IOC_NR(VIDIOC_S_JPEGCOMP)]       = \"VIDIOC_S_JPEGCOMP\",\n\t[_IOC_NR(VIDIOC_QUERYSTD)]         = \"VIDIOC_QUERYSTD\",\n\t[_IOC_NR(VIDIOC_TRY_FMT)]          = \"VIDIOC_TRY_FMT\",\n\t[_IOC_NR(VIDIOC_ENUMAUDIO)]        = \"VIDIOC_ENUMAUDIO\",\n\t[_IOC_NR(VIDIOC_ENUMAUDOUT)]       = \"VIDIOC_ENUMAUDOUT\",\n\t[_IOC_NR(VIDIOC_G_PRIORITY)]       = \"VIDIOC_G_PRIORITY\",\n\t[_IOC_NR(VIDIOC_S_PRIORITY)]       = \"VIDIOC_S_PRIORITY\",\n\t[_IOC_NR(VIDIOC_G_SLICED_VBI_CAP)] = \"VIDIOC_G_SLICED_VBI_CAP\",\n\t[_IOC_NR(VIDIOC_LOG_STATUS)]       = \"VIDIOC_LOG_STATUS\",\n\t[_IOC_NR(VIDIOC_G_EXT_CTRLS)]      = \"VIDIOC_G_EXT_CTRLS\",\n\t[_IOC_NR(VIDIOC_S_EXT_CTRLS)]      = \"VIDIOC_S_EXT_CTRLS\",\n\t[_IOC_NR(VIDIOC_TRY_EXT_CTRLS)]    = \"VIDIOC_TRY_EXT_CTRLS\",\n#if 1\n\t[_IOC_NR(VIDIOC_ENUM_FRAMESIZES)]  = \"VIDIOC_ENUM_FRAMESIZES\",\n\t[_IOC_NR(VIDIOC_ENUM_FRAMEINTERVALS)] = \"VIDIOC_ENUM_FRAMEINTERVALS\",\n\t[_IOC_NR(VIDIOC_G_ENC_INDEX)] \t   = \"VIDIOC_G_ENC_INDEX\",\n\t[_IOC_NR(VIDIOC_ENCODER_CMD)] \t   = \"VIDIOC_ENCODER_CMD\",\n\t[_IOC_NR(VIDIOC_TRY_ENCODER_CMD)]  = \"VIDIOC_TRY_ENCODER_CMD\",\n\n\t[_IOC_NR(VIDIOC_DBG_S_REGISTER)]   = \"VIDIOC_DBG_S_REGISTER\",\n\t[_IOC_NR(VIDIOC_DBG_G_REGISTER)]   = \"VIDIOC_DBG_G_REGISTER\",\n\n\t[_IOC_NR(VIDIOC_DBG_G_CHIP_IDENT)] = \"VIDIOC_DBG_G_CHIP_IDENT\",\n\t[_IOC_NR(VIDIOC_S_HW_FREQ_SEEK)]   = \"VIDIOC_S_HW_FREQ_SEEK\",\n#endif\n\t[_IOC_NR(VIDIOC_ENUM_DV_PRESETS)]  = \"VIDIOC_ENUM_DV_PRESETS\",\n\t[_IOC_NR(VIDIOC_S_DV_PRESET)]\t   = \"VIDIOC_S_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_G_DV_PRESET)]\t   = \"VIDIOC_G_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_QUERY_DV_PRESET)]  = \"VIDIOC_QUERY_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_S_DV_TIMINGS)]     = \"VIDIOC_S_DV_TIMINGS\",\n\t[_IOC_NR(VIDIOC_G_DV_TIMINGS)]     = \"VIDIOC_G_DV_TIMINGS\",\n\t[_IOC_NR(VIDIOC_DQEVENT)]\t   = \"VIDIOC_DQEVENT\",\n\t[_IOC_NR(VIDIOC_SUBSCRIBE_EVENT)]  = \"VIDIOC_SUBSCRIBE_EVENT\",\n\t[_IOC_NR(VIDIOC_UNSUBSCRIBE_EVENT)] = \"VIDIOC_UNSUBSCRIBE_EVENT\",\n};\n#define V4L2_IOCTLS ARRAY_SIZE(v4l2_ioctls)\n\n/* Common ioctl debug function. This function can be used by\n   external ioctl messages as well as internal V4L ioctl */\nvoid v4l_printk_ioctl(unsigned int cmd)\n{\n\tchar *dir, *type;\n\n\tswitch (_IOC_TYPE(cmd)) {\n\tcase 'd':\n\t\ttype = \"v4l2_int\";\n\t\tbreak;\n\tcase 'V':\n\t\tif (_IOC_NR(cmd) >= V4L2_IOCTLS) {\n\t\t\ttype = \"v4l2\";\n\t\t\tbreak;\n\t\t}\n\t\tprintk(\"%s\", v4l2_ioctls[_IOC_NR(cmd)]);\n\t\treturn;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:              dir = \"--\"; break;\n\tcase _IOC_READ:              dir = \"r-\"; break;\n\tcase _IOC_WRITE:             dir = \"-w\"; break;\n\tcase _IOC_READ | _IOC_WRITE: dir = \"rw\"; break;\n\tdefault:                     dir = \"*ERR*\"; break;\n\t}\n\tprintk(\"%s ioctl '%c', dir=%s, #%d (0x%08x)\",\n\t\ttype, _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);\n}\nEXPORT_SYMBOL(v4l_printk_ioctl);\n\n/*\n * helper function -- handles userspace copying for ioctl arguments\n * Obsolete usercopy function - Should be removed soon\n */\nlong\nvideo_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\tv4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = NULL;\n\tlong\terr  = -EINVAL;\n\tint     is_ext_ctrl;\n\tsize_t  ctrls_size = 0;\n\tvoid __user *user_ptr = NULL;\n\n\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\tparg = NULL;\n\t\tbreak;\n\tcase _IOC_READ:\n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\t/* In case of an error, tell the caller that it wasn't\n\t\t   a specific control that caused it. */\n\t\tp->error_idx = p->count;\n\t\tuser_ptr = (void __user *)p->controls;\n\t\tif (p->count) {\n\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n\t\t\t/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. */\n\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n\t\t\terr = -ENOMEM;\n\t\t\tif (NULL == mbuf)\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\tp->controls = mbuf;\n\t\t}\n\t}\n\n\t/* call driver */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\tp->controls = (void *)user_ptr;\n\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_ext_ctrl;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_ext_ctrl:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}\nEXPORT_SYMBOL(video_usercopy);\n\nstatic void dbgbuf(unsigned int cmd, struct video_device *vfd,\n\t\t\t\t\tstruct v4l2_buffer *p)\n{\n\tstruct v4l2_timecode *tc = &p->timecode;\n\tstruct v4l2_plane *plane;\n\tint i;\n\n\tdbgarg(cmd, \"%02ld:%02d:%02d.%08ld index=%d, type=%s, \"\n\t\t\"flags=0x%08d, field=%0d, sequence=%d, memory=%s\\n\",\n\t\t\tp->timestamp.tv_sec / 3600,\n\t\t\t(int)(p->timestamp.tv_sec / 60) % 60,\n\t\t\t(int)(p->timestamp.tv_sec % 60),\n\t\t\t(long)p->timestamp.tv_usec,\n\t\t\tp->index,\n\t\t\tprt_names(p->type, v4l2_type_names),\n\t\t\tp->flags, p->field, p->sequence,\n\t\t\tprt_names(p->memory, v4l2_memory_names));\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {\n\t\tfor (i = 0; i < p->length; ++i) {\n\t\t\tplane = &p->m.planes[i];\n\t\t\tdbgarg2(\"plane %d: bytesused=%d, data_offset=0x%08x \"\n\t\t\t\t\"offset/userptr=0x%08lx, length=%d\\n\",\n\t\t\t\ti, plane->bytesused, plane->data_offset,\n\t\t\t\tplane->m.userptr, plane->length);\n\t\t}\n\t} else {\n\t\tdbgarg2(\"bytesused=%d, offset/userptr=0x%08lx, length=%d\\n\",\n\t\t\tp->bytesused, p->m.userptr, p->length);\n\t}\n\n\tdbgarg2(\"timecode=%02d:%02d:%02d type=%d, \"\n\t\t\"flags=0x%08d, frames=%d, userbits=0x%08x\\n\",\n\t\t\ttc->hours, tc->minutes, tc->seconds,\n\t\t\ttc->type, tc->flags, tc->frames, *(__u32 *)tc->userbits);\n}\n\nstatic inline void dbgrect(struct video_device *vfd, char *s,\n\t\t\t\t\t\t\tstruct v4l2_rect *r)\n{\n\tdbgarg2(\"%sRect start at %dx%d, size=%dx%d\\n\", s, r->left, r->top,\n\t\t\t\t\t\tr->width, r->height);\n};\n\nstatic inline void v4l_print_pix_fmt(struct video_device *vfd,\n\t\t\t\t\t\tstruct v4l2_pix_format *fmt)\n{\n\tdbgarg2(\"width=%d, height=%d, format=%c%c%c%c, field=%s, \"\n\t\t\"bytesperline=%d sizeimage=%d, colorspace=%d\\n\",\n\t\tfmt->width, fmt->height,\n\t\t(fmt->pixelformat & 0xff),\n\t\t(fmt->pixelformat >>  8) & 0xff,\n\t\t(fmt->pixelformat >> 16) & 0xff,\n\t\t(fmt->pixelformat >> 24) & 0xff,\n\t\tprt_names(fmt->field, v4l2_field_names),\n\t\tfmt->bytesperline, fmt->sizeimage, fmt->colorspace);\n};\n\nstatic inline void v4l_print_pix_fmt_mplane(struct video_device *vfd,\n\t\t\t\t\t    struct v4l2_pix_format_mplane *fmt)\n{\n\tint i;\n\n\tdbgarg2(\"width=%d, height=%d, format=%c%c%c%c, field=%s, \"\n\t\t\"colorspace=%d, num_planes=%d\\n\",\n\t\tfmt->width, fmt->height,\n\t\t(fmt->pixelformat & 0xff),\n\t\t(fmt->pixelformat >>  8) & 0xff,\n\t\t(fmt->pixelformat >> 16) & 0xff,\n\t\t(fmt->pixelformat >> 24) & 0xff,\n\t\tprt_names(fmt->field, v4l2_field_names),\n\t\tfmt->colorspace, fmt->num_planes);\n\n\tfor (i = 0; i < fmt->num_planes; ++i)\n\t\tdbgarg2(\"plane %d: bytesperline=%d sizeimage=%d\\n\", i,\n\t\t\tfmt->plane_fmt[i].bytesperline,\n\t\t\tfmt->plane_fmt[i].sizeimage);\n}\n\nstatic inline void v4l_print_ext_ctrls(unsigned int cmd,\n\tstruct video_device *vfd, struct v4l2_ext_controls *c, int show_vals)\n{\n\t__u32 i;\n\n\tif (!(vfd->debug & V4L2_DEBUG_IOCTL_ARG))\n\t\treturn;\n\tdbgarg(cmd, \"\");\n\tprintk(KERN_CONT \"class=0x%x\", c->ctrl_class);\n\tfor (i = 0; i < c->count; i++) {\n\t\tif (show_vals && !c->controls[i].size)\n\t\t\tprintk(KERN_CONT \" id/val=0x%x/0x%x\",\n\t\t\t\tc->controls[i].id, c->controls[i].value);\n\t\telse\n\t\t\tprintk(KERN_CONT \" id=0x%x,size=%u\",\n\t\t\t\tc->controls[i].id, c->controls[i].size);\n\t}\n\tprintk(KERN_CONT \"\\n\");\n};\n\nstatic inline int check_ext_ctrls(struct v4l2_ext_controls *c, int allow_priv)\n{\n\t__u32 i;\n\n\t/* zero the reserved fields */\n\tc->reserved[0] = c->reserved[1] = 0;\n\tfor (i = 0; i < c->count; i++)\n\t\tc->controls[i].reserved2[0] = 0;\n\n\t/* V4L2_CID_PRIVATE_BASE cannot be used as control class\n\t   when using extended controls.\n\t   Only when passed in through VIDIOC_G_CTRL and VIDIOC_S_CTRL\n\t   is it allowed for backwards compatibility.\n\t */\n\tif (!allow_priv && c->ctrl_class == V4L2_CID_PRIVATE_BASE)\n\t\treturn 0;\n\t/* Check that all controls are from the same control class. */\n\tfor (i = 0; i < c->count; i++) {\n\t\tif (V4L2_CTRL_ID2CLASS(c->controls[i].id) != c->ctrl_class) {\n\t\t\tc->error_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int check_fmt(const struct v4l2_ioctl_ops *ops, enum v4l2_buf_type type)\n{\n\tif (ops == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_vid_cap ||\n\t\t\t\tops->vidioc_g_fmt_vid_cap_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (ops->vidioc_g_fmt_vid_cap_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (ops->vidioc_g_fmt_vid_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_vid_out ||\n\t\t\t\tops->vidioc_g_fmt_vid_out_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (ops->vidioc_g_fmt_vid_out_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (ops->vidioc_g_fmt_vid_out_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_sliced_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_sliced_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\tif (ops->vidioc_g_fmt_type_private)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * fmt_sp_to_mp() - Convert a single-plane format to its multi-planar 1-plane\n * equivalent\n */\nstatic int fmt_sp_to_mp(const struct v4l2_format *f_sp,\n\t\t\tstruct v4l2_format *f_mp)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;\n\tconst struct v4l2_pix_format *pix = &f_sp->fmt.pix;\n\n\tif (f_sp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tf_mp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\telse if (f_sp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tf_mp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\telse\n\t\treturn -EINVAL;\n\n\tpix_mp->width = pix->width;\n\tpix_mp->height = pix->height;\n\tpix_mp->pixelformat = pix->pixelformat;\n\tpix_mp->field = pix->field;\n\tpix_mp->colorspace = pix->colorspace;\n\tpix_mp->num_planes = 1;\n\tpix_mp->plane_fmt[0].sizeimage = pix->sizeimage;\n\tpix_mp->plane_fmt[0].bytesperline = pix->bytesperline;\n\n\treturn 0;\n}\n\n/**\n * fmt_mp_to_sp() - Convert a multi-planar 1-plane format to its single-planar\n * equivalent\n */\nstatic int fmt_mp_to_sp(const struct v4l2_format *f_mp,\n\t\t\tstruct v4l2_format *f_sp)\n{\n\tconst struct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;\n\tstruct v4l2_pix_format *pix = &f_sp->fmt.pix;\n\n\tif (f_mp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tf_sp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (f_mp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tf_sp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\telse\n\t\treturn -EINVAL;\n\n\tpix->width = pix_mp->width;\n\tpix->height = pix_mp->height;\n\tpix->pixelformat = pix_mp->pixelformat;\n\tpix->field = pix_mp->field;\n\tpix->colorspace = pix_mp->colorspace;\n\tpix->sizeimage = pix_mp->plane_fmt[0].sizeimage;\n\tpix->bytesperline = pix_mp->plane_fmt[0].bytesperline;\n\n\treturn 0;\n}\n\nstatic long __video_do_ioctl(struct file *file,\n\t\tunsigned int cmd, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\n\tvoid *fh = file->private_data;\n\tstruct v4l2_format f_copy;\n\tlong ret = -EINVAL;\n\n\tif (ops == NULL) {\n\t\tprintk(KERN_WARNING \"videodev: \\\"%s\\\" has no ioctl_ops.\\n\",\n\t\t\t\tvfd->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vfd->debug & V4L2_DEBUG_IOCTL) &&\n\t\t\t\t!(vfd->debug & V4L2_DEBUG_IOCTL_ARG)) {\n\t\tv4l_print_ioctl(vfd->name, cmd);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tswitch (cmd) {\n\n\t/* --- capabilities ------------------------------------------ */\n\tcase VIDIOC_QUERYCAP:\n\t{\n\t\tstruct v4l2_capability *cap = (struct v4l2_capability *)arg;\n\n\t\tif (!ops->vidioc_querycap)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_querycap(file, fh, cap);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"driver=%s, card=%s, bus=%s, \"\n\t\t\t\t\t\"version=0x%08x, \"\n\t\t\t\t\t\"capabilities=0x%08x\\n\",\n\t\t\t\t\tcap->driver, cap->card, cap->bus_info,\n\t\t\t\t\tcap->version,\n\t\t\t\t\tcap->capabilities);\n\t\tbreak;\n\t}\n\n\t/* --- priority ------------------------------------------ */\n\tcase VIDIOC_G_PRIORITY:\n\t{\n\t\tenum v4l2_priority *p = arg;\n\n\t\tif (!ops->vidioc_g_priority)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_priority(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"priority is %d\\n\", *p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_PRIORITY:\n\t{\n\t\tenum v4l2_priority *p = arg;\n\n\t\tif (!ops->vidioc_s_priority)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"setting priority to %d\\n\", *p);\n\t\tret = ops->vidioc_s_priority(file, fh, *p);\n\t\tbreak;\n\t}\n\n\t/* --- capture ioctls ---------------------------------------- */\n\tcase VIDIOC_ENUM_FMT:\n\t{\n\t\tstruct v4l2_fmtdesc *f = arg;\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_cap)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_cap_mplane)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tif (ops->vidioc_enum_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tif (ops->vidioc_enum_fmt_vid_out)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_out_mplane)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\tif (ops->vidioc_enum_fmt_type_private)\n\t\t\t\tret = ops->vidioc_enum_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, type=%d, flags=%d, \"\n\t\t\t\t\"pixelformat=%c%c%c%c, description='%s'\\n\",\n\t\t\t\tf->index, f->type, f->flags,\n\t\t\t\t(f->pixelformat & 0xff),\n\t\t\t\t(f->pixelformat >>  8) & 0xff,\n\t\t\t\t(f->pixelformat >> 16) & 0xff,\n\t\t\t\t(f->pixelformat >> 24) & 0xff,\n\t\t\t\tf->description);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type, v4l2_type_names));\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap_mplane(file, fh,\n\t\t\t\t\t\t\t\t       &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Driver is currently in multi-planar format,\n\t\t\t\t * we can't return it in single-planar API*/\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tif (ops->vidioc_g_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_cap) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tif (ops->vidioc_g_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_g_fmt_vid_overlay(file,\n\t\t\t\t\t\t\t\t    fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Driver is currently in multi-planar format,\n\t\t\t\t * we can't return it in single-planar API*/\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tif (ops->vidioc_g_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_out) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tif (ops->vidioc_g_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_overlay(file,\n\t\t\t\t       fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_g_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_g_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_g_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_g_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\tif (ops->vidioc_g_fmt_type_private)\n\t\t\t\tret = ops->vidioc_g_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type, v4l2_type_names));\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tif (ops->vidioc_s_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tif (ops->vidioc_s_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_cap &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_s_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_s_fmt_vid_overlay(file,\n\t\t\t\t\t\t\t\t    fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tif (ops->vidioc_s_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tif (ops->vidioc_s_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_out &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_s_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_s_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_s_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_s_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_s_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_s_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_s_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_s_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_s_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\t/* CLEAR_AFTER_FIELD(f, fmt.raw_data); <- does nothing */\n\t\t\tif (ops->vidioc_s_fmt_type_private)\n\t\t\t\tret = ops->vidioc_s_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type,\n\t\t\t\t\t\tv4l2_type_names));\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tif (ops->vidioc_try_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tif (ops->vidioc_try_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\t fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_cap &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\t  fh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_try_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_try_fmt_vid_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tif (ops->vidioc_try_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tif (ops->vidioc_try_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\t fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_out &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out(file,\n\t\t\t\t\t\t\t\t  fh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_try_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_overlay(file,\n\t\t\t\t       fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_try_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_try_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_try_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_try_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_try_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_try_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_try_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_try_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\t/* CLEAR_AFTER_FIELD(f, fmt.raw_data); <- does nothing */\n\t\t\tif (ops->vidioc_try_fmt_type_private)\n\t\t\t\tret = ops->vidioc_try_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\t/* FIXME: Those buf reqs could be handled here,\n\t   with some changes on videobuf to allow its header to be included at\n\t   videodev2.h or being merged at videodev2.\n\t */\n\tcase VIDIOC_REQBUFS:\n\t{\n\t\tstruct v4l2_requestbuffers *p = arg;\n\n\t\tif (!ops->vidioc_reqbufs)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (p->type < V4L2_BUF_TYPE_PRIVATE)\n\t\t\tCLEAR_AFTER_FIELD(p, memory);\n\n\t\tret = ops->vidioc_reqbufs(file, fh, p);\n\t\tdbgarg(cmd, \"count=%d, type=%s, memory=%s\\n\",\n\t\t\t\tp->count,\n\t\t\t\tprt_names(p->type, v4l2_type_names),\n\t\t\t\tprt_names(p->memory, v4l2_memory_names));\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_querybuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_querybuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_qbuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_qbuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_DQBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_dqbuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_dqbuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_OVERLAY:\n\t{\n\t\tint *i = arg;\n\n\t\tif (!ops->vidioc_overlay)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_overlay(file, fh, *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FBUF:\n\t{\n\t\tstruct v4l2_framebuffer *p = arg;\n\n\t\tif (!ops->vidioc_g_fbuf)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_fbuf(file, fh, arg);\n\t\tif (!ret) {\n\t\t\tdbgarg(cmd, \"capability=0x%x, flags=%d, base=0x%08lx\\n\",\n\t\t\t\t\tp->capability, p->flags,\n\t\t\t\t\t(unsigned long)p->base);\n\t\t\tv4l_print_pix_fmt(vfd, &p->fmt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FBUF:\n\t{\n\t\tstruct v4l2_framebuffer *p = arg;\n\n\t\tif (!ops->vidioc_s_fbuf)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"capability=0x%x, flags=%d, base=0x%08lx\\n\",\n\t\t\tp->capability, p->flags, (unsigned long)p->base);\n\t\tv4l_print_pix_fmt(vfd, &p->fmt);\n\t\tret = ops->vidioc_s_fbuf(file, fh, arg);\n\t\tbreak;\n\t}\n\tcase VIDIOC_STREAMON:\n\t{\n\t\tenum v4l2_buf_type i = *(int *)arg;\n\n\t\tif (!ops->vidioc_streamon)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(i, v4l2_type_names));\n\t\tret = ops->vidioc_streamon(file, fh, i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_STREAMOFF:\n\t{\n\t\tenum v4l2_buf_type i = *(int *)arg;\n\n\t\tif (!ops->vidioc_streamoff)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(i, v4l2_type_names));\n\t\tret = ops->vidioc_streamoff(file, fh, i);\n\t\tbreak;\n\t}\n\t/* ---------- tv norms ---------- */\n\tcase VIDIOC_ENUMSTD:\n\t{\n\t\tstruct v4l2_standard *p = arg;\n\t\tv4l2_std_id id = vfd->tvnorms, curr_id = 0;\n\t\tunsigned int index = p->index, i, j = 0;\n\t\tconst char *descr = \"\";\n\n\t\t/* Return norm array in a canonical way */\n\t\tfor (i = 0; i <= index && id; i++) {\n\t\t\t/* last std value in the standards array is 0, so this\n\t\t\t   while always ends there since (id & 0) == 0. */\n\t\t\twhile ((id & standards[j].std) != standards[j].std)\n\t\t\t\tj++;\n\t\t\tcurr_id = standards[j].std;\n\t\t\tdescr = standards[j].descr;\n\t\t\tj++;\n\t\t\tif (curr_id == 0)\n\t\t\t\tbreak;\n\t\t\tif (curr_id != V4L2_STD_PAL &&\n\t\t\t    curr_id != V4L2_STD_SECAM &&\n\t\t\t    curr_id != V4L2_STD_NTSC)\n\t\t\t\tid &= ~curr_id;\n\t\t}\n\t\tif (i <= index)\n\t\t\tbreak;\n\n\t\tv4l2_video_std_construct(p, curr_id, descr);\n\n\t\tdbgarg(cmd, \"index=%d, id=0x%Lx, name=%s, fps=%d/%d, \"\n\t\t\t\t\"framelines=%d\\n\", p->index,\n\t\t\t\t(unsigned long long)p->id, p->name,\n\t\t\t\tp->frameperiod.numerator,\n\t\t\t\tp->frameperiod.denominator,\n\t\t\t\tp->framelines);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_STD:\n\t{\n\t\tv4l2_std_id *id = arg;\n\n\t\tret = 0;\n\t\t/* Calls the specific handler */\n\t\tif (ops->vidioc_g_std)\n\t\t\tret = ops->vidioc_g_std(file, fh, id);\n\t\telse if (vfd->current_norm)\n\t\t\t*id = vfd->current_norm;\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"std=0x%08Lx\\n\", (long long unsigned)*id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_STD:\n\t{\n\t\tv4l2_std_id *id = arg, norm;\n\n\t\tdbgarg(cmd, \"std=%08Lx\\n\", (long long unsigned)*id);\n\n\t\tnorm = (*id) & vfd->tvnorms;\n\t\tif (vfd->tvnorms && !norm)\t/* Check if std is supported */\n\t\t\tbreak;\n\n\t\t/* Calls the specific handler */\n\t\tif (ops->vidioc_s_std)\n\t\t\tret = ops->vidioc_s_std(file, fh, &norm);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\t/* Updates standard information */\n\t\tif (ret >= 0)\n\t\t\tvfd->current_norm = norm;\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYSTD:\n\t{\n\t\tv4l2_std_id *p = arg;\n\n\t\tif (!ops->vidioc_querystd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_querystd(file, fh, arg);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"detected std=%08Lx\\n\",\n\t\t\t\t\t\t(unsigned long long)*p);\n\t\tbreak;\n\t}\n\t/* ------ input switching ---------- */\n\t/* FIXME: Inputs can be handled inside videodev2 */\n\tcase VIDIOC_ENUMINPUT:\n\t{\n\t\tstruct v4l2_input *p = arg;\n\n\t\t/*\n\t\t * We set the flags for CAP_PRESETS, CAP_CUSTOM_TIMINGS &\n\t\t * CAP_STD here based on ioctl handler provided by the\n\t\t * driver. If the driver doesn't support these\n\t\t * for a specific input, it must override these flags.\n\t\t */\n\t\tif (ops->vidioc_s_std)\n\t\t\tp->capabilities |= V4L2_IN_CAP_STD;\n\t\tif (ops->vidioc_s_dv_preset)\n\t\t\tp->capabilities |= V4L2_IN_CAP_PRESETS;\n\t\tif (ops->vidioc_s_dv_timings)\n\t\t\tp->capabilities |= V4L2_IN_CAP_CUSTOM_TIMINGS;\n\n\t\tif (!ops->vidioc_enum_input)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_input(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"audioset=%d, \"\n\t\t\t\t\"tuner=%d, std=%08Lx, status=%d\\n\",\n\t\t\t\tp->index, p->name, p->type, p->audioset,\n\t\t\t\tp->tuner,\n\t\t\t\t(unsigned long long)p->std,\n\t\t\t\tp->status);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_INPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_g_input)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_input(file, fh, i);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_INPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_s_input)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_s_input(file, fh, *i);\n\t\tbreak;\n\t}\n\n\t/* ------ output switching ---------- */\n\tcase VIDIOC_ENUMOUTPUT:\n\t{\n\t\tstruct v4l2_output *p = arg;\n\n\t\tif (!ops->vidioc_enum_output)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We set the flags for CAP_PRESETS, CAP_CUSTOM_TIMINGS &\n\t\t * CAP_STD here based on ioctl handler provided by the\n\t\t * driver. If the driver doesn't support these\n\t\t * for a specific output, it must override these flags.\n\t\t */\n\t\tif (ops->vidioc_s_std)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_STD;\n\t\tif (ops->vidioc_s_dv_preset)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_PRESETS;\n\t\tif (ops->vidioc_s_dv_timings)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_CUSTOM_TIMINGS;\n\n\t\tret = ops->vidioc_enum_output(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"audioset=0x%x, \"\n\t\t\t\t\"modulator=%d, std=0x%08Lx\\n\",\n\t\t\t\tp->index, p->name, p->type, p->audioset,\n\t\t\t\tp->modulator, (unsigned long long)p->std);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_OUTPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_g_output)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_output(file, fh, i);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_OUTPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_s_output)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_s_output(file, fh, *i);\n\t\tbreak;\n\t}\n\n\t/* --- controls ---------------------------------------------- */\n\tcase VIDIOC_QUERYCTRL:\n\t{\n\t\tstruct v4l2_queryctrl *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_queryctrl(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_queryctrl)\n\t\t\tret = ops->vidioc_queryctrl(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, type=%d, name=%s, min/max=%d/%d, \"\n\t\t\t\t\t\"step=%d, default=%d, flags=0x%08x\\n\",\n\t\t\t\t\tp->id, p->type, p->name,\n\t\t\t\t\tp->minimum, p->maximum,\n\t\t\t\t\tp->step, p->default_value, p->flags);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x\\n\", p->id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_CTRL:\n\t{\n\t\tstruct v4l2_control *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_g_ctrl(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_g_ctrl)\n\t\t\tret = ops->vidioc_g_ctrl(file, fh, p);\n\t\telse if (ops->vidioc_g_ext_ctrls) {\n\t\t\tstruct v4l2_ext_controls ctrls;\n\t\t\tstruct v4l2_ext_control ctrl;\n\n\t\t\tctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\n\t\t\tctrls.count = 1;\n\t\t\tctrls.controls = &ctrl;\n\t\t\tctrl.id = p->id;\n\t\t\tctrl.value = p->value;\n\t\t\tif (check_ext_ctrls(&ctrls, 1)) {\n\t\t\t\tret = ops->vidioc_g_ext_ctrls(file, fh, &ctrls);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tp->value = ctrl.value;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, value=%d\\n\", p->id, p->value);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x\\n\", p->id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_CTRL:\n\t{\n\t\tstruct v4l2_control *p = arg;\n\t\tstruct v4l2_ext_controls ctrls;\n\t\tstruct v4l2_ext_control ctrl;\n\n\t\tif (!vfd->ctrl_handler &&\n\t\t\t!ops->vidioc_s_ctrl && !ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"id=0x%x, value=%d\\n\", p->id, p->value);\n\n\t\tif (vfd->ctrl_handler) {\n\t\t\tret = v4l2_s_ctrl(vfd->ctrl_handler, p);\n\t\t\tbreak;\n\t\t}\n\t\tif (ops->vidioc_s_ctrl) {\n\t\t\tret = ops->vidioc_s_ctrl(file, fh, p);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\n\t\tctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\n\t\tctrls.count = 1;\n\t\tctrls.controls = &ctrl;\n\t\tctrl.id = p->id;\n\t\tctrl.value = p->value;\n\t\tif (check_ext_ctrls(&ctrls, 1))\n\t\t\tret = ops->vidioc_s_ext_ctrls(file, fh, &ctrls);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_g_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_g_ext_ctrls && check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_g_ext_ctrls(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, !ret);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (!vfd->ctrl_handler && !ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, 1);\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_s_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_s_ext_ctrls(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (!vfd->ctrl_handler && !ops->vidioc_try_ext_ctrls)\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, 1);\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_try_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_try_ext_ctrls(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYMENU:\n\t{\n\t\tstruct v4l2_querymenu *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_querymenu(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_querymenu)\n\t\t\tret = ops->vidioc_querymenu(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, index=%d, name=%s\\n\",\n\t\t\t\tp->id, p->index, p->name);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x, index=%d\\n\",\n\t\t\t\tp->id, p->index);\n\t\tbreak;\n\t}\n\t/* --- audio ---------------------------------------------- */\n\tcase VIDIOC_ENUMAUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_enumaudio)\n\t\t\tbreak;\n\t\tret = ops->vidioc_enumaudio(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\telse\n\t\t\tdbgarg(cmd, \"index=%d\\n\", p->index);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_AUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_g_audio)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_audio(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index,\n\t\t\t\t\tp->name, p->capability, p->mode);\n\t\telse\n\t\t\tdbgarg(cmd, \"index=%d\\n\", p->index);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_AUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_s_audio)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tret = ops->vidioc_s_audio(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUMAUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_enumaudout)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"Enum for index=%d\\n\", p->index);\n\t\tret = ops->vidioc_enumaudout(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_AUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_g_audout)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_audout(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_AUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_s_audout)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\n\t\tret = ops->vidioc_s_audout(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_MODULATOR:\n\t{\n\t\tstruct v4l2_modulator *p = arg;\n\n\t\tif (!ops->vidioc_g_modulator)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_modulator(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, \"\n\t\t\t\t\t\"capability=%d, rangelow=%d,\"\n\t\t\t\t\t\" rangehigh=%d, txsubchans=%d\\n\",\n\t\t\t\t\tp->index, p->name, p->capability,\n\t\t\t\t\tp->rangelow, p->rangehigh,\n\t\t\t\t\tp->txsubchans);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_MODULATOR:\n\t{\n\t\tstruct v4l2_modulator *p = arg;\n\n\t\tif (!ops->vidioc_s_modulator)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\"rangelow=%d, rangehigh=%d, txsubchans=%d\\n\",\n\t\t\t\tp->index, p->name, p->capability, p->rangelow,\n\t\t\t\tp->rangehigh, p->txsubchans);\n\t\t\tret = ops->vidioc_s_modulator(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_CROP:\n\t{\n\t\tstruct v4l2_crop *p = arg;\n\n\t\tif (!ops->vidioc_g_crop)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_g_crop(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgrect(vfd, \"\", &p->c);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_CROP:\n\t{\n\t\tstruct v4l2_crop *p = arg;\n\n\t\tif (!ops->vidioc_s_crop)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tdbgrect(vfd, \"\", &p->c);\n\t\tret = ops->vidioc_s_crop(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_CROPCAP:\n\t{\n\t\tstruct v4l2_cropcap *p = arg;\n\n\t\t/*FIXME: Should also show v4l2_fract pixelaspect */\n\t\tif (!ops->vidioc_cropcap)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_cropcap(file, fh, p);\n\t\tif (!ret) {\n\t\t\tdbgrect(vfd, \"bounds \", &p->bounds);\n\t\t\tdbgrect(vfd, \"defrect \", &p->defrect);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_JPEGCOMP:\n\t{\n\t\tstruct v4l2_jpegcompression *p = arg;\n\n\t\tif (!ops->vidioc_g_jpegcomp)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_jpegcomp(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"quality=%d, APPn=%d, \"\n\t\t\t\t\t\"APP_len=%d, COM_len=%d, \"\n\t\t\t\t\t\"jpeg_markers=%d\\n\",\n\t\t\t\t\tp->quality, p->APPn, p->APP_len,\n\t\t\t\t\tp->COM_len, p->jpeg_markers);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_JPEGCOMP:\n\t{\n\t\tstruct v4l2_jpegcompression *p = arg;\n\n\t\tif (!ops->vidioc_g_jpegcomp)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"quality=%d, APPn=%d, APP_len=%d, \"\n\t\t\t\t\t\"COM_len=%d, jpeg_markers=%d\\n\",\n\t\t\t\t\tp->quality, p->APPn, p->APP_len,\n\t\t\t\t\tp->COM_len, p->jpeg_markers);\n\t\t\tret = ops->vidioc_s_jpegcomp(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_ENC_INDEX:\n\t{\n\t\tstruct v4l2_enc_idx *p = arg;\n\n\t\tif (!ops->vidioc_g_enc_index)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_enc_index(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"entries=%d, entries_cap=%d\\n\",\n\t\t\t\t\tp->entries, p->entries_cap);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENCODER_CMD:\n\t{\n\t\tstruct v4l2_encoder_cmd *p = arg;\n\n\t\tif (!ops->vidioc_encoder_cmd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_encoder_cmd(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"cmd=%d, flags=%x\\n\", p->cmd, p->flags);\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_ENCODER_CMD:\n\t{\n\t\tstruct v4l2_encoder_cmd *p = arg;\n\n\t\tif (!ops->vidioc_try_encoder_cmd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_try_encoder_cmd(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"cmd=%d, flags=%x\\n\", p->cmd, p->flags);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_PARM:\n\t{\n\t\tstruct v4l2_streamparm *p = arg;\n\n\t\tif (ops->vidioc_g_parm) {\n\t\t\tret = check_fmt(ops, p->type);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = ops->vidioc_g_parm(file, fh, p);\n\t\t} else {\n\t\t\tv4l2_std_id std = vfd->current_norm;\n\n\t\t\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\t\tbreak;\n\n\t\t\tret = 0;\n\t\t\tif (ops->vidioc_g_std)\n\t\t\t\tret = ops->vidioc_g_std(file, fh, &std);\n\t\t\telse if (std == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tif (ret == 0)\n\t\t\t\tv4l2_video_std_frame_period(std,\n\t\t\t\t\t\t    &p->parm.capture.timeperframe);\n\t\t}\n\n\t\tdbgarg(cmd, \"type=%d\\n\", p->type);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_PARM:\n\t{\n\t\tstruct v4l2_streamparm *p = arg;\n\n\t\tif (!ops->vidioc_s_parm)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%d\\n\", p->type);\n\t\tret = ops->vidioc_s_parm(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_TUNER:\n\t{\n\t\tstruct v4l2_tuner *p = arg;\n\n\t\tif (!ops->vidioc_g_tuner)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_tuner(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\t\"capability=0x%x, rangelow=%d, \"\n\t\t\t\t\t\"rangehigh=%d, signal=%d, afc=%d, \"\n\t\t\t\t\t\"rxsubchans=0x%x, audmode=%d\\n\",\n\t\t\t\t\tp->index, p->name, p->type,\n\t\t\t\t\tp->capability, p->rangelow,\n\t\t\t\t\tp->rangehigh, p->signal, p->afc,\n\t\t\t\t\tp->rxsubchans, p->audmode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_TUNER:\n\t{\n\t\tstruct v4l2_tuner *p = arg;\n\n\t\tif (!ops->vidioc_s_tuner)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"capability=0x%x, rangelow=%d, \"\n\t\t\t\t\"rangehigh=%d, signal=%d, afc=%d, \"\n\t\t\t\t\"rxsubchans=0x%x, audmode=%d\\n\",\n\t\t\t\tp->index, p->name, p->type,\n\t\t\t\tp->capability, p->rangelow,\n\t\t\t\tp->rangehigh, p->signal, p->afc,\n\t\t\t\tp->rxsubchans, p->audmode);\n\t\tret = ops->vidioc_s_tuner(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FREQUENCY:\n\t{\n\t\tstruct v4l2_frequency *p = arg;\n\n\t\tif (!ops->vidioc_g_frequency)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_frequency(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"tuner=%d, type=%d, frequency=%d\\n\",\n\t\t\t\t\tp->tuner, p->type, p->frequency);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FREQUENCY:\n\t{\n\t\tstruct v4l2_frequency *p = arg;\n\n\t\tif (!ops->vidioc_s_frequency)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"tuner=%d, type=%d, frequency=%d\\n\",\n\t\t\t\tp->tuner, p->type, p->frequency);\n\t\tret = ops->vidioc_s_frequency(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_SLICED_VBI_CAP:\n\t{\n\t\tstruct v4l2_sliced_vbi_cap *p = arg;\n\n\t\tif (!ops->vidioc_g_sliced_vbi_cap)\n\t\t\tbreak;\n\n\t\t/* Clear up to type, everything after type is zerod already */\n\t\tmemset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_g_sliced_vbi_cap(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"service_set=%d\\n\", p->service_set);\n\t\tbreak;\n\t}\n\tcase VIDIOC_LOG_STATUS:\n\t{\n\t\tif (!ops->vidioc_log_status)\n\t\t\tbreak;\n\t\tret = ops->vidioc_log_status(file, fh);\n\t\tbreak;\n\t}\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tcase VIDIOC_DBG_G_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (ops->vidioc_g_register) {\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\tret = -EPERM;\n\t\t\telse\n\t\t\t\tret = ops->vidioc_g_register(file, fh, p);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_DBG_S_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (ops->vidioc_s_register) {\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\tret = -EPERM;\n\t\t\telse\n\t\t\t\tret = ops->vidioc_s_register(file, fh, p);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tcase VIDIOC_DBG_G_CHIP_IDENT:\n\t{\n\t\tstruct v4l2_dbg_chip_ident *p = arg;\n\n\t\tif (!ops->vidioc_g_chip_ident)\n\t\t\tbreak;\n\t\tp->ident = V4L2_IDENT_NONE;\n\t\tp->revision = 0;\n\t\tret = ops->vidioc_g_chip_ident(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"chip_ident=%u, revision=0x%x\\n\", p->ident, p->revision);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_HW_FREQ_SEEK:\n\t{\n\t\tstruct v4l2_hw_freq_seek *p = arg;\n\n\t\tif (!ops->vidioc_s_hw_freq_seek)\n\t\t\tbreak;\n\t\tdbgarg(cmd,\n\t\t\t\"tuner=%d, type=%d, seek_upward=%d, wrap_around=%d\\n\",\n\t\t\tp->tuner, p->type, p->seek_upward, p->wrap_around);\n\t\tret = ops->vidioc_s_hw_freq_seek(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_FRAMESIZES:\n\t{\n\t\tstruct v4l2_frmsizeenum *p = arg;\n\n\t\tif (!ops->vidioc_enum_framesizes)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_framesizes(file, fh, p);\n\t\tdbgarg(cmd,\n\t\t\t\"index=%d, pixelformat=%c%c%c%c, type=%d \",\n\t\t\tp->index,\n\t\t\t(p->pixel_format & 0xff),\n\t\t\t(p->pixel_format >>  8) & 0xff,\n\t\t\t(p->pixel_format >> 16) & 0xff,\n\t\t\t(p->pixel_format >> 24) & 0xff,\n\t\t\tp->type);\n\t\tswitch (p->type) {\n\t\tcase V4L2_FRMSIZE_TYPE_DISCRETE:\n\t\t\tdbgarg3(\"width = %d, height=%d\\n\",\n\t\t\t\tp->discrete.width, p->discrete.height);\n\t\t\tbreak;\n\t\tcase V4L2_FRMSIZE_TYPE_STEPWISE:\n\t\t\tdbgarg3(\"min %dx%d, max %dx%d, step %dx%d\\n\",\n\t\t\t\tp->stepwise.min_width,  p->stepwise.min_height,\n\t\t\t\tp->stepwise.step_width, p->stepwise.step_height,\n\t\t\t\tp->stepwise.max_width,  p->stepwise.max_height);\n\t\t\tbreak;\n\t\tcase V4L2_FRMSIZE_TYPE_CONTINUOUS:\n\t\t\tdbgarg3(\"continuous\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg3(\"- Unknown type!\\n\");\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_FRAMEINTERVALS:\n\t{\n\t\tstruct v4l2_frmivalenum *p = arg;\n\n\t\tif (!ops->vidioc_enum_frameintervals)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_frameintervals(file, fh, p);\n\t\tdbgarg(cmd,\n\t\t\t\"index=%d, pixelformat=%d, width=%d, height=%d, type=%d \",\n\t\t\tp->index, p->pixel_format,\n\t\t\tp->width, p->height, p->type);\n\t\tswitch (p->type) {\n\t\tcase V4L2_FRMIVAL_TYPE_DISCRETE:\n\t\t\tdbgarg2(\"fps=%d/%d\\n\",\n\t\t\t\tp->discrete.numerator,\n\t\t\t\tp->discrete.denominator);\n\t\t\tbreak;\n\t\tcase V4L2_FRMIVAL_TYPE_STEPWISE:\n\t\t\tdbgarg2(\"min=%d/%d, max=%d/%d, step=%d/%d\\n\",\n\t\t\t\tp->stepwise.min.numerator,\n\t\t\t\tp->stepwise.min.denominator,\n\t\t\t\tp->stepwise.max.numerator,\n\t\t\t\tp->stepwise.max.denominator,\n\t\t\t\tp->stepwise.step.numerator,\n\t\t\t\tp->stepwise.step.denominator);\n\t\t\tbreak;\n\t\tcase V4L2_FRMIVAL_TYPE_CONTINUOUS:\n\t\t\tdbgarg2(\"continuous\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg2(\"- Unknown type!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_DV_PRESETS:\n\t{\n\t\tstruct v4l2_dv_enum_preset *p = arg;\n\n\t\tif (!ops->vidioc_enum_dv_presets)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_dv_presets(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd,\n\t\t\t\t\"index=%d, preset=%d, name=%s, width=%d,\"\n\t\t\t\t\" height=%d \",\n\t\t\t\tp->index, p->preset, p->name, p->width,\n\t\t\t\tp->height);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_s_dv_preset)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tret = ops->vidioc_s_dv_preset(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_g_dv_preset)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_dv_preset(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERY_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_query_dv_preset)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_query_dv_preset(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_DV_TIMINGS:\n\t{\n\t\tstruct v4l2_dv_timings *p = arg;\n\n\t\tif (!ops->vidioc_s_dv_timings)\n\t\t\tbreak;\n\n\t\tswitch (p->type) {\n\t\tcase V4L2_DV_BT_656_1120:\n\t\t\tdbgarg2(\"bt-656/1120:interlaced=%d, pixelclock=%lld,\"\n\t\t\t\t\" width=%d, height=%d, polarities=%x,\"\n\t\t\t\t\" hfrontporch=%d, hsync=%d, hbackporch=%d,\"\n\t\t\t\t\" vfrontporch=%d, vsync=%d, vbackporch=%d,\"\n\t\t\t\t\" il_vfrontporch=%d, il_vsync=%d,\"\n\t\t\t\t\" il_vbackporch=%d\\n\",\n\t\t\t\tp->bt.interlaced, p->bt.pixelclock,\n\t\t\t\tp->bt.width, p->bt.height, p->bt.polarities,\n\t\t\t\tp->bt.hfrontporch, p->bt.hsync,\n\t\t\t\tp->bt.hbackporch, p->bt.vfrontporch,\n\t\t\t\tp->bt.vsync, p->bt.vbackporch,\n\t\t\t\tp->bt.il_vfrontporch, p->bt.il_vsync,\n\t\t\t\tp->bt.il_vbackporch);\n\t\t\tret = ops->vidioc_s_dv_timings(file, fh, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg2(\"Unknown type %d!\\n\", p->type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_DV_TIMINGS:\n\t{\n\t\tstruct v4l2_dv_timings *p = arg;\n\n\t\tif (!ops->vidioc_g_dv_timings)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_dv_timings(file, fh, p);\n\t\tif (!ret) {\n\t\t\tswitch (p->type) {\n\t\t\tcase V4L2_DV_BT_656_1120:\n\t\t\t\tdbgarg2(\"bt-656/1120:interlaced=%d,\"\n\t\t\t\t\t\" pixelclock=%lld,\"\n\t\t\t\t\t\" width=%d, height=%d, polarities=%x,\"\n\t\t\t\t\t\" hfrontporch=%d, hsync=%d,\"\n\t\t\t\t\t\" hbackporch=%d, vfrontporch=%d,\"\n\t\t\t\t\t\" vsync=%d, vbackporch=%d,\"\n\t\t\t\t\t\" il_vfrontporch=%d, il_vsync=%d,\"\n\t\t\t\t\t\" il_vbackporch=%d\\n\",\n\t\t\t\t\tp->bt.interlaced, p->bt.pixelclock,\n\t\t\t\t\tp->bt.width, p->bt.height,\n\t\t\t\t\tp->bt.polarities, p->bt.hfrontporch,\n\t\t\t\t\tp->bt.hsync, p->bt.hbackporch,\n\t\t\t\t\tp->bt.vfrontporch, p->bt.vsync,\n\t\t\t\t\tp->bt.vbackporch, p->bt.il_vfrontporch,\n\t\t\t\t\tp->bt.il_vsync, p->bt.il_vbackporch);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdbgarg2(\"Unknown type %d!\\n\", p->type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_DQEVENT:\n\t{\n\t\tstruct v4l2_event *ev = arg;\n\n\t\tif (!ops->vidioc_subscribe_event)\n\t\t\tbreak;\n\n\t\tret = v4l2_event_dequeue(fh, ev, file->f_flags & O_NONBLOCK);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"no pending events?\");\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd,\n\t\t       \"pending=%d, type=0x%8.8x, sequence=%d, \"\n\t\t       \"timestamp=%lu.%9.9lu \",\n\t\t       ev->pending, ev->type, ev->sequence,\n\t\t       ev->timestamp.tv_sec, ev->timestamp.tv_nsec);\n\t\tbreak;\n\t}\n\tcase VIDIOC_SUBSCRIBE_EVENT:\n\t{\n\t\tstruct v4l2_event_subscription *sub = arg;\n\n\t\tif (!ops->vidioc_subscribe_event)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_subscribe_event(fh, sub);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"failed, ret=%ld\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd, \"type=0x%8.8x\", sub->type);\n\t\tbreak;\n\t}\n\tcase VIDIOC_UNSUBSCRIBE_EVENT:\n\t{\n\t\tstruct v4l2_event_subscription *sub = arg;\n\n\t\tif (!ops->vidioc_unsubscribe_event)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_unsubscribe_event(fh, sub);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"failed, ret=%ld\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd, \"type=0x%8.8x\", sub->type);\n\t\tbreak;\n\t}\n\tdefault:\n\t{\n\t\tif (!ops->vidioc_default)\n\t\t\tbreak;\n\t\tret = ops->vidioc_default(file, fh, cmd, arg);\n\t\tbreak;\n\t}\n\t} /* switch */\n\n\tif (vfd->debug & V4L2_DEBUG_IOCTL_ARG) {\n\t\tif (ret < 0) {\n\t\t\tv4l_print_ioctl(vfd->name, cmd);\n\t\t\tprintk(KERN_CONT \" error %ld\\n\", ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* In some cases, only a few fields are used as input, i.e. when the app sets\n * \"index\" and then the driver fills in the rest of the structure for the thing\n * with that index.  We only need to copy up the first non-input field.  */\nstatic unsigned long cmd_input_size(unsigned int cmd)\n{\n\t/* Size of structure up to and including 'field' */\n#define CMDINSIZE(cmd, type, field) \t\t\t\t\\\n\tcase VIDIOC_##cmd: \t\t\t\t\t\\\n\t\treturn offsetof(struct v4l2_##type, field) + \t\\\n\t\t\tsizeof(((struct v4l2_##type *)0)->field);\n\n\tswitch (cmd) {\n\t\tCMDINSIZE(ENUM_FMT,\t\tfmtdesc,\ttype);\n\t\tCMDINSIZE(G_FMT,\t\tformat,\t\ttype);\n\t\tCMDINSIZE(QUERYBUF,\t\tbuffer,\t\tlength);\n\t\tCMDINSIZE(G_PARM,\t\tstreamparm,\ttype);\n\t\tCMDINSIZE(ENUMSTD,\t\tstandard,\tindex);\n\t\tCMDINSIZE(ENUMINPUT,\t\tinput,\t\tindex);\n\t\tCMDINSIZE(G_CTRL,\t\tcontrol,\tid);\n\t\tCMDINSIZE(G_TUNER,\t\ttuner,\t\tindex);\n\t\tCMDINSIZE(QUERYCTRL,\t\tqueryctrl,\tid);\n\t\tCMDINSIZE(QUERYMENU,\t\tquerymenu,\tindex);\n\t\tCMDINSIZE(ENUMOUTPUT,\t\toutput,\t\tindex);\n\t\tCMDINSIZE(G_MODULATOR,\t\tmodulator,\tindex);\n\t\tCMDINSIZE(G_FREQUENCY,\t\tfrequency,\ttuner);\n\t\tCMDINSIZE(CROPCAP,\t\tcropcap,\ttype);\n\t\tCMDINSIZE(G_CROP,\t\tcrop,\t\ttype);\n\t\tCMDINSIZE(ENUMAUDIO,\t\taudio, \t\tindex);\n\t\tCMDINSIZE(ENUMAUDOUT,\t\taudioout, \tindex);\n\t\tCMDINSIZE(ENCODER_CMD,\t\tencoder_cmd,\tflags);\n\t\tCMDINSIZE(TRY_ENCODER_CMD,\tencoder_cmd,\tflags);\n\t\tCMDINSIZE(G_SLICED_VBI_CAP,\tsliced_vbi_cap,\ttype);\n\t\tCMDINSIZE(ENUM_FRAMESIZES,\tfrmsizeenum,\tpixel_format);\n\t\tCMDINSIZE(ENUM_FRAMEINTERVALS,\tfrmivalenum,\theight);\n\tdefault:\n\t\treturn _IOC_SIZE(cmd);\n\t}\n}\n\nstatic int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\n\t\t\t    void * __user *user_ptr, void ***kernel_ptr)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase VIDIOC_QUERYBUF:\n\tcase VIDIOC_QBUF:\n\tcase VIDIOC_DQBUF: {\n\t\tstruct v4l2_buffer *buf = parg;\n\n\t\tif (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {\n\t\t\tif (buf->length > VIDEO_MAX_PLANES) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*user_ptr = (void __user *)buf->m.planes;\n\t\t\t*kernel_ptr = (void **)&buf->m.planes;\n\t\t\t*array_size = sizeof(struct v4l2_plane) * buf->length;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase VIDIOC_S_EXT_CTRLS:\n\tcase VIDIOC_G_EXT_CTRLS:\n\tcase VIDIOC_TRY_EXT_CTRLS: {\n\t\tstruct v4l2_ext_controls *ctrls = parg;\n\n\t\tif (ctrls->count != 0) {\n\t\t\t*user_ptr = (void __user *)ctrls->controls;\n\t\t\t*kernel_ptr = (void **)&ctrls->controls;\n\t\t\t*array_size = sizeof(struct v4l2_ext_control)\n\t\t\t\t    * ctrls->count;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\treturn ret;\n}\n\nlong video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = __video_do_ioctl(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}\nEXPORT_SYMBOL(video_ioctl2);\n"], "fixing_code": ["/*\n * Video capture interface for Linux version 2\n *\n * A generic framework to process V4L2 ioctl commands.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * Authors:\tAlan Cox, <alan@lxorguk.ukuu.org.uk> (version 1)\n *              Mauro Carvalho Chehab <mchehab@infradead.org> (version 2)\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\n#include <linux/videodev2.h>\n\n#include <media/v4l2-common.h>\n#include <media/v4l2-ioctl.h>\n#include <media/v4l2-ctrls.h>\n#include <media/v4l2-fh.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-chip-ident.h>\n\n#define dbgarg(cmd, fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG) {\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \",  vfd->name);\t\t\\\n\t\t\tv4l_printk_ioctl(cmd);\t\t\t\t\\\n\t\t\tprintk(\" \" fmt,  ## arg);\t\t\t\\\n\t\t    }\t\t\t\t\t\t\t\\\n\t\t} while (0)\n\n#define dbgarg2(fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG)\t\t\\\n\t\t\tprintk(KERN_DEBUG \"%s: \" fmt, vfd->name, ## arg);\\\n\t\t} while (0)\n\n#define dbgarg3(fmt, arg...) \\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t    if (vfd->debug & V4L2_DEBUG_IOCTL_ARG)\t\t\\\n\t\t\tprintk(KERN_CONT \"%s: \" fmt, vfd->name, ## arg);\\\n\t\t} while (0)\n\n/* Zero out the end of the struct pointed to by p.  Everthing after, but\n * not including, the specified field is cleared. */\n#define CLEAR_AFTER_FIELD(p, field) \\\n\tmemset((u8 *)(p) + offsetof(typeof(*(p)), field) + sizeof((p)->field), \\\n\t0, sizeof(*(p)) - offsetof(typeof(*(p)), field) - sizeof((p)->field))\n\nstruct std_descr {\n\tv4l2_std_id std;\n\tconst char *descr;\n};\n\nstatic const struct std_descr standards[] = {\n\t{ V4L2_STD_NTSC, \t\"NTSC\"      },\n\t{ V4L2_STD_NTSC_M, \t\"NTSC-M\"    },\n\t{ V4L2_STD_NTSC_M_JP, \t\"NTSC-M-JP\" },\n\t{ V4L2_STD_NTSC_M_KR,\t\"NTSC-M-KR\" },\n\t{ V4L2_STD_NTSC_443, \t\"NTSC-443\"  },\n\t{ V4L2_STD_PAL, \t\"PAL\"       },\n\t{ V4L2_STD_PAL_BG, \t\"PAL-BG\"    },\n\t{ V4L2_STD_PAL_B, \t\"PAL-B\"     },\n\t{ V4L2_STD_PAL_B1, \t\"PAL-B1\"    },\n\t{ V4L2_STD_PAL_G, \t\"PAL-G\"     },\n\t{ V4L2_STD_PAL_H, \t\"PAL-H\"     },\n\t{ V4L2_STD_PAL_I, \t\"PAL-I\"     },\n\t{ V4L2_STD_PAL_DK, \t\"PAL-DK\"    },\n\t{ V4L2_STD_PAL_D, \t\"PAL-D\"     },\n\t{ V4L2_STD_PAL_D1, \t\"PAL-D1\"    },\n\t{ V4L2_STD_PAL_K, \t\"PAL-K\"     },\n\t{ V4L2_STD_PAL_M, \t\"PAL-M\"     },\n\t{ V4L2_STD_PAL_N, \t\"PAL-N\"     },\n\t{ V4L2_STD_PAL_Nc, \t\"PAL-Nc\"    },\n\t{ V4L2_STD_PAL_60, \t\"PAL-60\"    },\n\t{ V4L2_STD_SECAM, \t\"SECAM\"     },\n\t{ V4L2_STD_SECAM_B, \t\"SECAM-B\"   },\n\t{ V4L2_STD_SECAM_G, \t\"SECAM-G\"   },\n\t{ V4L2_STD_SECAM_H, \t\"SECAM-H\"   },\n\t{ V4L2_STD_SECAM_DK, \t\"SECAM-DK\"  },\n\t{ V4L2_STD_SECAM_D, \t\"SECAM-D\"   },\n\t{ V4L2_STD_SECAM_K, \t\"SECAM-K\"   },\n\t{ V4L2_STD_SECAM_K1, \t\"SECAM-K1\"  },\n\t{ V4L2_STD_SECAM_L, \t\"SECAM-L\"   },\n\t{ V4L2_STD_SECAM_LC, \t\"SECAM-Lc\"  },\n\t{ 0, \t\t\t\"Unknown\"   }\n};\n\n/* video4linux standard ID conversion to standard name\n */\nconst char *v4l2_norm_to_name(v4l2_std_id id)\n{\n\tu32 myid = id;\n\tint i;\n\n\t/* HACK: ppc32 architecture doesn't have __ucmpdi2 function to handle\n\t   64 bit comparations. So, on that architecture, with some gcc\n\t   variants, compilation fails. Currently, the max value is 30bit wide.\n\t */\n\tBUG_ON(myid != id);\n\n\tfor (i = 0; standards[i].std; i++)\n\t\tif (myid == standards[i].std)\n\t\t\tbreak;\n\treturn standards[i].descr;\n}\nEXPORT_SYMBOL(v4l2_norm_to_name);\n\n/* Returns frame period for the given standard */\nvoid v4l2_video_std_frame_period(int id, struct v4l2_fract *frameperiod)\n{\n\tif (id & V4L2_STD_525_60) {\n\t\tframeperiod->numerator = 1001;\n\t\tframeperiod->denominator = 30000;\n\t} else {\n\t\tframeperiod->numerator = 1;\n\t\tframeperiod->denominator = 25;\n\t}\n}\nEXPORT_SYMBOL(v4l2_video_std_frame_period);\n\n/* Fill in the fields of a v4l2_standard structure according to the\n   'id' and 'transmission' parameters.  Returns negative on error.  */\nint v4l2_video_std_construct(struct v4l2_standard *vs,\n\t\t\t     int id, const char *name)\n{\n\tvs->id = id;\n\tv4l2_video_std_frame_period(id, &vs->frameperiod);\n\tvs->framelines = (id & V4L2_STD_525_60) ? 525 : 625;\n\tstrlcpy(vs->name, name, sizeof(vs->name));\n\treturn 0;\n}\nEXPORT_SYMBOL(v4l2_video_std_construct);\n\n/* ----------------------------------------------------------------- */\n/* some arrays for pretty-printing debug messages of enum types      */\n\nconst char *v4l2_field_names[] = {\n\t[V4L2_FIELD_ANY]        = \"any\",\n\t[V4L2_FIELD_NONE]       = \"none\",\n\t[V4L2_FIELD_TOP]        = \"top\",\n\t[V4L2_FIELD_BOTTOM]     = \"bottom\",\n\t[V4L2_FIELD_INTERLACED] = \"interlaced\",\n\t[V4L2_FIELD_SEQ_TB]     = \"seq-tb\",\n\t[V4L2_FIELD_SEQ_BT]     = \"seq-bt\",\n\t[V4L2_FIELD_ALTERNATE]  = \"alternate\",\n\t[V4L2_FIELD_INTERLACED_TB] = \"interlaced-tb\",\n\t[V4L2_FIELD_INTERLACED_BT] = \"interlaced-bt\",\n};\nEXPORT_SYMBOL(v4l2_field_names);\n\nconst char *v4l2_type_names[] = {\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE]      = \"vid-cap\",\n\t[V4L2_BUF_TYPE_VIDEO_OVERLAY]      = \"vid-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT]       = \"vid-out\",\n\t[V4L2_BUF_TYPE_VBI_CAPTURE]        = \"vbi-cap\",\n\t[V4L2_BUF_TYPE_VBI_OUTPUT]         = \"vbi-out\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_CAPTURE] = \"sliced-vbi-cap\",\n\t[V4L2_BUF_TYPE_SLICED_VBI_OUTPUT]  = \"sliced-vbi-out\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY] = \"vid-out-overlay\",\n\t[V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE] = \"vid-cap-mplane\",\n\t[V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE] = \"vid-out-mplane\",\n};\nEXPORT_SYMBOL(v4l2_type_names);\n\nstatic const char *v4l2_memory_names[] = {\n\t[V4L2_MEMORY_MMAP]    = \"mmap\",\n\t[V4L2_MEMORY_USERPTR] = \"userptr\",\n\t[V4L2_MEMORY_OVERLAY] = \"overlay\",\n};\n\n#define prt_names(a, arr) ((((a) >= 0) && ((a) < ARRAY_SIZE(arr))) ? \\\n\t\t\t   arr[a] : \"unknown\")\n\n/* ------------------------------------------------------------------ */\n/* debug help functions                                               */\nstatic const char *v4l2_ioctls[] = {\n\t[_IOC_NR(VIDIOC_QUERYCAP)]         = \"VIDIOC_QUERYCAP\",\n\t[_IOC_NR(VIDIOC_RESERVED)]         = \"VIDIOC_RESERVED\",\n\t[_IOC_NR(VIDIOC_ENUM_FMT)]         = \"VIDIOC_ENUM_FMT\",\n\t[_IOC_NR(VIDIOC_G_FMT)]            = \"VIDIOC_G_FMT\",\n\t[_IOC_NR(VIDIOC_S_FMT)]            = \"VIDIOC_S_FMT\",\n\t[_IOC_NR(VIDIOC_REQBUFS)]          = \"VIDIOC_REQBUFS\",\n\t[_IOC_NR(VIDIOC_QUERYBUF)]         = \"VIDIOC_QUERYBUF\",\n\t[_IOC_NR(VIDIOC_G_FBUF)]           = \"VIDIOC_G_FBUF\",\n\t[_IOC_NR(VIDIOC_S_FBUF)]           = \"VIDIOC_S_FBUF\",\n\t[_IOC_NR(VIDIOC_OVERLAY)]          = \"VIDIOC_OVERLAY\",\n\t[_IOC_NR(VIDIOC_QBUF)]             = \"VIDIOC_QBUF\",\n\t[_IOC_NR(VIDIOC_DQBUF)]            = \"VIDIOC_DQBUF\",\n\t[_IOC_NR(VIDIOC_STREAMON)]         = \"VIDIOC_STREAMON\",\n\t[_IOC_NR(VIDIOC_STREAMOFF)]        = \"VIDIOC_STREAMOFF\",\n\t[_IOC_NR(VIDIOC_G_PARM)]           = \"VIDIOC_G_PARM\",\n\t[_IOC_NR(VIDIOC_S_PARM)]           = \"VIDIOC_S_PARM\",\n\t[_IOC_NR(VIDIOC_G_STD)]            = \"VIDIOC_G_STD\",\n\t[_IOC_NR(VIDIOC_S_STD)]            = \"VIDIOC_S_STD\",\n\t[_IOC_NR(VIDIOC_ENUMSTD)]          = \"VIDIOC_ENUMSTD\",\n\t[_IOC_NR(VIDIOC_ENUMINPUT)]        = \"VIDIOC_ENUMINPUT\",\n\t[_IOC_NR(VIDIOC_G_CTRL)]           = \"VIDIOC_G_CTRL\",\n\t[_IOC_NR(VIDIOC_S_CTRL)]           = \"VIDIOC_S_CTRL\",\n\t[_IOC_NR(VIDIOC_G_TUNER)]          = \"VIDIOC_G_TUNER\",\n\t[_IOC_NR(VIDIOC_S_TUNER)]          = \"VIDIOC_S_TUNER\",\n\t[_IOC_NR(VIDIOC_G_AUDIO)]          = \"VIDIOC_G_AUDIO\",\n\t[_IOC_NR(VIDIOC_S_AUDIO)]          = \"VIDIOC_S_AUDIO\",\n\t[_IOC_NR(VIDIOC_QUERYCTRL)]        = \"VIDIOC_QUERYCTRL\",\n\t[_IOC_NR(VIDIOC_QUERYMENU)]        = \"VIDIOC_QUERYMENU\",\n\t[_IOC_NR(VIDIOC_G_INPUT)]          = \"VIDIOC_G_INPUT\",\n\t[_IOC_NR(VIDIOC_S_INPUT)]          = \"VIDIOC_S_INPUT\",\n\t[_IOC_NR(VIDIOC_G_OUTPUT)]         = \"VIDIOC_G_OUTPUT\",\n\t[_IOC_NR(VIDIOC_S_OUTPUT)]         = \"VIDIOC_S_OUTPUT\",\n\t[_IOC_NR(VIDIOC_ENUMOUTPUT)]       = \"VIDIOC_ENUMOUTPUT\",\n\t[_IOC_NR(VIDIOC_G_AUDOUT)]         = \"VIDIOC_G_AUDOUT\",\n\t[_IOC_NR(VIDIOC_S_AUDOUT)]         = \"VIDIOC_S_AUDOUT\",\n\t[_IOC_NR(VIDIOC_G_MODULATOR)]      = \"VIDIOC_G_MODULATOR\",\n\t[_IOC_NR(VIDIOC_S_MODULATOR)]      = \"VIDIOC_S_MODULATOR\",\n\t[_IOC_NR(VIDIOC_G_FREQUENCY)]      = \"VIDIOC_G_FREQUENCY\",\n\t[_IOC_NR(VIDIOC_S_FREQUENCY)]      = \"VIDIOC_S_FREQUENCY\",\n\t[_IOC_NR(VIDIOC_CROPCAP)]          = \"VIDIOC_CROPCAP\",\n\t[_IOC_NR(VIDIOC_G_CROP)]           = \"VIDIOC_G_CROP\",\n\t[_IOC_NR(VIDIOC_S_CROP)]           = \"VIDIOC_S_CROP\",\n\t[_IOC_NR(VIDIOC_G_JPEGCOMP)]       = \"VIDIOC_G_JPEGCOMP\",\n\t[_IOC_NR(VIDIOC_S_JPEGCOMP)]       = \"VIDIOC_S_JPEGCOMP\",\n\t[_IOC_NR(VIDIOC_QUERYSTD)]         = \"VIDIOC_QUERYSTD\",\n\t[_IOC_NR(VIDIOC_TRY_FMT)]          = \"VIDIOC_TRY_FMT\",\n\t[_IOC_NR(VIDIOC_ENUMAUDIO)]        = \"VIDIOC_ENUMAUDIO\",\n\t[_IOC_NR(VIDIOC_ENUMAUDOUT)]       = \"VIDIOC_ENUMAUDOUT\",\n\t[_IOC_NR(VIDIOC_G_PRIORITY)]       = \"VIDIOC_G_PRIORITY\",\n\t[_IOC_NR(VIDIOC_S_PRIORITY)]       = \"VIDIOC_S_PRIORITY\",\n\t[_IOC_NR(VIDIOC_G_SLICED_VBI_CAP)] = \"VIDIOC_G_SLICED_VBI_CAP\",\n\t[_IOC_NR(VIDIOC_LOG_STATUS)]       = \"VIDIOC_LOG_STATUS\",\n\t[_IOC_NR(VIDIOC_G_EXT_CTRLS)]      = \"VIDIOC_G_EXT_CTRLS\",\n\t[_IOC_NR(VIDIOC_S_EXT_CTRLS)]      = \"VIDIOC_S_EXT_CTRLS\",\n\t[_IOC_NR(VIDIOC_TRY_EXT_CTRLS)]    = \"VIDIOC_TRY_EXT_CTRLS\",\n#if 1\n\t[_IOC_NR(VIDIOC_ENUM_FRAMESIZES)]  = \"VIDIOC_ENUM_FRAMESIZES\",\n\t[_IOC_NR(VIDIOC_ENUM_FRAMEINTERVALS)] = \"VIDIOC_ENUM_FRAMEINTERVALS\",\n\t[_IOC_NR(VIDIOC_G_ENC_INDEX)] \t   = \"VIDIOC_G_ENC_INDEX\",\n\t[_IOC_NR(VIDIOC_ENCODER_CMD)] \t   = \"VIDIOC_ENCODER_CMD\",\n\t[_IOC_NR(VIDIOC_TRY_ENCODER_CMD)]  = \"VIDIOC_TRY_ENCODER_CMD\",\n\n\t[_IOC_NR(VIDIOC_DBG_S_REGISTER)]   = \"VIDIOC_DBG_S_REGISTER\",\n\t[_IOC_NR(VIDIOC_DBG_G_REGISTER)]   = \"VIDIOC_DBG_G_REGISTER\",\n\n\t[_IOC_NR(VIDIOC_DBG_G_CHIP_IDENT)] = \"VIDIOC_DBG_G_CHIP_IDENT\",\n\t[_IOC_NR(VIDIOC_S_HW_FREQ_SEEK)]   = \"VIDIOC_S_HW_FREQ_SEEK\",\n#endif\n\t[_IOC_NR(VIDIOC_ENUM_DV_PRESETS)]  = \"VIDIOC_ENUM_DV_PRESETS\",\n\t[_IOC_NR(VIDIOC_S_DV_PRESET)]\t   = \"VIDIOC_S_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_G_DV_PRESET)]\t   = \"VIDIOC_G_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_QUERY_DV_PRESET)]  = \"VIDIOC_QUERY_DV_PRESET\",\n\t[_IOC_NR(VIDIOC_S_DV_TIMINGS)]     = \"VIDIOC_S_DV_TIMINGS\",\n\t[_IOC_NR(VIDIOC_G_DV_TIMINGS)]     = \"VIDIOC_G_DV_TIMINGS\",\n\t[_IOC_NR(VIDIOC_DQEVENT)]\t   = \"VIDIOC_DQEVENT\",\n\t[_IOC_NR(VIDIOC_SUBSCRIBE_EVENT)]  = \"VIDIOC_SUBSCRIBE_EVENT\",\n\t[_IOC_NR(VIDIOC_UNSUBSCRIBE_EVENT)] = \"VIDIOC_UNSUBSCRIBE_EVENT\",\n};\n#define V4L2_IOCTLS ARRAY_SIZE(v4l2_ioctls)\n\n/* Common ioctl debug function. This function can be used by\n   external ioctl messages as well as internal V4L ioctl */\nvoid v4l_printk_ioctl(unsigned int cmd)\n{\n\tchar *dir, *type;\n\n\tswitch (_IOC_TYPE(cmd)) {\n\tcase 'd':\n\t\ttype = \"v4l2_int\";\n\t\tbreak;\n\tcase 'V':\n\t\tif (_IOC_NR(cmd) >= V4L2_IOCTLS) {\n\t\t\ttype = \"v4l2\";\n\t\t\tbreak;\n\t\t}\n\t\tprintk(\"%s\", v4l2_ioctls[_IOC_NR(cmd)]);\n\t\treturn;\n\tdefault:\n\t\ttype = \"unknown\";\n\t}\n\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:              dir = \"--\"; break;\n\tcase _IOC_READ:              dir = \"r-\"; break;\n\tcase _IOC_WRITE:             dir = \"-w\"; break;\n\tcase _IOC_READ | _IOC_WRITE: dir = \"rw\"; break;\n\tdefault:                     dir = \"*ERR*\"; break;\n\t}\n\tprintk(\"%s ioctl '%c', dir=%s, #%d (0x%08x)\",\n\t\ttype, _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);\n}\nEXPORT_SYMBOL(v4l_printk_ioctl);\n\nstatic void dbgbuf(unsigned int cmd, struct video_device *vfd,\n\t\t\t\t\tstruct v4l2_buffer *p)\n{\n\tstruct v4l2_timecode *tc = &p->timecode;\n\tstruct v4l2_plane *plane;\n\tint i;\n\n\tdbgarg(cmd, \"%02ld:%02d:%02d.%08ld index=%d, type=%s, \"\n\t\t\"flags=0x%08d, field=%0d, sequence=%d, memory=%s\\n\",\n\t\t\tp->timestamp.tv_sec / 3600,\n\t\t\t(int)(p->timestamp.tv_sec / 60) % 60,\n\t\t\t(int)(p->timestamp.tv_sec % 60),\n\t\t\t(long)p->timestamp.tv_usec,\n\t\t\tp->index,\n\t\t\tprt_names(p->type, v4l2_type_names),\n\t\t\tp->flags, p->field, p->sequence,\n\t\t\tprt_names(p->memory, v4l2_memory_names));\n\n\tif (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {\n\t\tfor (i = 0; i < p->length; ++i) {\n\t\t\tplane = &p->m.planes[i];\n\t\t\tdbgarg2(\"plane %d: bytesused=%d, data_offset=0x%08x \"\n\t\t\t\t\"offset/userptr=0x%08lx, length=%d\\n\",\n\t\t\t\ti, plane->bytesused, plane->data_offset,\n\t\t\t\tplane->m.userptr, plane->length);\n\t\t}\n\t} else {\n\t\tdbgarg2(\"bytesused=%d, offset/userptr=0x%08lx, length=%d\\n\",\n\t\t\tp->bytesused, p->m.userptr, p->length);\n\t}\n\n\tdbgarg2(\"timecode=%02d:%02d:%02d type=%d, \"\n\t\t\"flags=0x%08d, frames=%d, userbits=0x%08x\\n\",\n\t\t\ttc->hours, tc->minutes, tc->seconds,\n\t\t\ttc->type, tc->flags, tc->frames, *(__u32 *)tc->userbits);\n}\n\nstatic inline void dbgrect(struct video_device *vfd, char *s,\n\t\t\t\t\t\t\tstruct v4l2_rect *r)\n{\n\tdbgarg2(\"%sRect start at %dx%d, size=%dx%d\\n\", s, r->left, r->top,\n\t\t\t\t\t\tr->width, r->height);\n};\n\nstatic inline void v4l_print_pix_fmt(struct video_device *vfd,\n\t\t\t\t\t\tstruct v4l2_pix_format *fmt)\n{\n\tdbgarg2(\"width=%d, height=%d, format=%c%c%c%c, field=%s, \"\n\t\t\"bytesperline=%d sizeimage=%d, colorspace=%d\\n\",\n\t\tfmt->width, fmt->height,\n\t\t(fmt->pixelformat & 0xff),\n\t\t(fmt->pixelformat >>  8) & 0xff,\n\t\t(fmt->pixelformat >> 16) & 0xff,\n\t\t(fmt->pixelformat >> 24) & 0xff,\n\t\tprt_names(fmt->field, v4l2_field_names),\n\t\tfmt->bytesperline, fmt->sizeimage, fmt->colorspace);\n};\n\nstatic inline void v4l_print_pix_fmt_mplane(struct video_device *vfd,\n\t\t\t\t\t    struct v4l2_pix_format_mplane *fmt)\n{\n\tint i;\n\n\tdbgarg2(\"width=%d, height=%d, format=%c%c%c%c, field=%s, \"\n\t\t\"colorspace=%d, num_planes=%d\\n\",\n\t\tfmt->width, fmt->height,\n\t\t(fmt->pixelformat & 0xff),\n\t\t(fmt->pixelformat >>  8) & 0xff,\n\t\t(fmt->pixelformat >> 16) & 0xff,\n\t\t(fmt->pixelformat >> 24) & 0xff,\n\t\tprt_names(fmt->field, v4l2_field_names),\n\t\tfmt->colorspace, fmt->num_planes);\n\n\tfor (i = 0; i < fmt->num_planes; ++i)\n\t\tdbgarg2(\"plane %d: bytesperline=%d sizeimage=%d\\n\", i,\n\t\t\tfmt->plane_fmt[i].bytesperline,\n\t\t\tfmt->plane_fmt[i].sizeimage);\n}\n\nstatic inline void v4l_print_ext_ctrls(unsigned int cmd,\n\tstruct video_device *vfd, struct v4l2_ext_controls *c, int show_vals)\n{\n\t__u32 i;\n\n\tif (!(vfd->debug & V4L2_DEBUG_IOCTL_ARG))\n\t\treturn;\n\tdbgarg(cmd, \"\");\n\tprintk(KERN_CONT \"class=0x%x\", c->ctrl_class);\n\tfor (i = 0; i < c->count; i++) {\n\t\tif (show_vals && !c->controls[i].size)\n\t\t\tprintk(KERN_CONT \" id/val=0x%x/0x%x\",\n\t\t\t\tc->controls[i].id, c->controls[i].value);\n\t\telse\n\t\t\tprintk(KERN_CONT \" id=0x%x,size=%u\",\n\t\t\t\tc->controls[i].id, c->controls[i].size);\n\t}\n\tprintk(KERN_CONT \"\\n\");\n};\n\nstatic inline int check_ext_ctrls(struct v4l2_ext_controls *c, int allow_priv)\n{\n\t__u32 i;\n\n\t/* zero the reserved fields */\n\tc->reserved[0] = c->reserved[1] = 0;\n\tfor (i = 0; i < c->count; i++)\n\t\tc->controls[i].reserved2[0] = 0;\n\n\t/* V4L2_CID_PRIVATE_BASE cannot be used as control class\n\t   when using extended controls.\n\t   Only when passed in through VIDIOC_G_CTRL and VIDIOC_S_CTRL\n\t   is it allowed for backwards compatibility.\n\t */\n\tif (!allow_priv && c->ctrl_class == V4L2_CID_PRIVATE_BASE)\n\t\treturn 0;\n\t/* Check that all controls are from the same control class. */\n\tfor (i = 0; i < c->count; i++) {\n\t\tif (V4L2_CTRL_ID2CLASS(c->controls[i].id) != c->ctrl_class) {\n\t\t\tc->error_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int check_fmt(const struct v4l2_ioctl_ops *ops, enum v4l2_buf_type type)\n{\n\tif (ops == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_vid_cap ||\n\t\t\t\tops->vidioc_g_fmt_vid_cap_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (ops->vidioc_g_fmt_vid_cap_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (ops->vidioc_g_fmt_vid_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_vid_out ||\n\t\t\t\tops->vidioc_g_fmt_vid_out_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (ops->vidioc_g_fmt_vid_out_mplane)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\tif (ops->vidioc_g_fmt_vid_out_overlay)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\tif (ops->vidioc_g_fmt_sliced_vbi_cap)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\tif (ops->vidioc_g_fmt_sliced_vbi_out)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\tif (ops->vidioc_g_fmt_type_private)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * fmt_sp_to_mp() - Convert a single-plane format to its multi-planar 1-plane\n * equivalent\n */\nstatic int fmt_sp_to_mp(const struct v4l2_format *f_sp,\n\t\t\tstruct v4l2_format *f_mp)\n{\n\tstruct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;\n\tconst struct v4l2_pix_format *pix = &f_sp->fmt.pix;\n\n\tif (f_sp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tf_mp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\n\telse if (f_sp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\n\t\tf_mp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\n\telse\n\t\treturn -EINVAL;\n\n\tpix_mp->width = pix->width;\n\tpix_mp->height = pix->height;\n\tpix_mp->pixelformat = pix->pixelformat;\n\tpix_mp->field = pix->field;\n\tpix_mp->colorspace = pix->colorspace;\n\tpix_mp->num_planes = 1;\n\tpix_mp->plane_fmt[0].sizeimage = pix->sizeimage;\n\tpix_mp->plane_fmt[0].bytesperline = pix->bytesperline;\n\n\treturn 0;\n}\n\n/**\n * fmt_mp_to_sp() - Convert a multi-planar 1-plane format to its single-planar\n * equivalent\n */\nstatic int fmt_mp_to_sp(const struct v4l2_format *f_mp,\n\t\t\tstruct v4l2_format *f_sp)\n{\n\tconst struct v4l2_pix_format_mplane *pix_mp = &f_mp->fmt.pix_mp;\n\tstruct v4l2_pix_format *pix = &f_sp->fmt.pix;\n\n\tif (f_mp->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\n\t\tf_sp->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\telse if (f_mp->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\n\t\tf_sp->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\n\telse\n\t\treturn -EINVAL;\n\n\tpix->width = pix_mp->width;\n\tpix->height = pix_mp->height;\n\tpix->pixelformat = pix_mp->pixelformat;\n\tpix->field = pix_mp->field;\n\tpix->colorspace = pix_mp->colorspace;\n\tpix->sizeimage = pix_mp->plane_fmt[0].sizeimage;\n\tpix->bytesperline = pix_mp->plane_fmt[0].bytesperline;\n\n\treturn 0;\n}\n\nstatic long __video_do_ioctl(struct file *file,\n\t\tunsigned int cmd, void *arg)\n{\n\tstruct video_device *vfd = video_devdata(file);\n\tconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\n\tvoid *fh = file->private_data;\n\tstruct v4l2_format f_copy;\n\tlong ret = -EINVAL;\n\n\tif (ops == NULL) {\n\t\tprintk(KERN_WARNING \"videodev: \\\"%s\\\" has no ioctl_ops.\\n\",\n\t\t\t\tvfd->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vfd->debug & V4L2_DEBUG_IOCTL) &&\n\t\t\t\t!(vfd->debug & V4L2_DEBUG_IOCTL_ARG)) {\n\t\tv4l_print_ioctl(vfd->name, cmd);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\n\tswitch (cmd) {\n\n\t/* --- capabilities ------------------------------------------ */\n\tcase VIDIOC_QUERYCAP:\n\t{\n\t\tstruct v4l2_capability *cap = (struct v4l2_capability *)arg;\n\n\t\tif (!ops->vidioc_querycap)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_querycap(file, fh, cap);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"driver=%s, card=%s, bus=%s, \"\n\t\t\t\t\t\"version=0x%08x, \"\n\t\t\t\t\t\"capabilities=0x%08x\\n\",\n\t\t\t\t\tcap->driver, cap->card, cap->bus_info,\n\t\t\t\t\tcap->version,\n\t\t\t\t\tcap->capabilities);\n\t\tbreak;\n\t}\n\n\t/* --- priority ------------------------------------------ */\n\tcase VIDIOC_G_PRIORITY:\n\t{\n\t\tenum v4l2_priority *p = arg;\n\n\t\tif (!ops->vidioc_g_priority)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_priority(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"priority is %d\\n\", *p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_PRIORITY:\n\t{\n\t\tenum v4l2_priority *p = arg;\n\n\t\tif (!ops->vidioc_s_priority)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"setting priority to %d\\n\", *p);\n\t\tret = ops->vidioc_s_priority(file, fh, *p);\n\t\tbreak;\n\t}\n\n\t/* --- capture ioctls ---------------------------------------- */\n\tcase VIDIOC_ENUM_FMT:\n\t{\n\t\tstruct v4l2_fmtdesc *f = arg;\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_cap)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_cap_mplane)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tif (ops->vidioc_enum_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tif (ops->vidioc_enum_fmt_vid_out)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tif (ops->vidioc_enum_fmt_vid_out_mplane)\n\t\t\t\tret = ops->vidioc_enum_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\tif (ops->vidioc_enum_fmt_type_private)\n\t\t\t\tret = ops->vidioc_enum_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, type=%d, flags=%d, \"\n\t\t\t\t\"pixelformat=%c%c%c%c, description='%s'\\n\",\n\t\t\t\tf->index, f->type, f->flags,\n\t\t\t\t(f->pixelformat & 0xff),\n\t\t\t\t(f->pixelformat >>  8) & 0xff,\n\t\t\t\t(f->pixelformat >> 16) & 0xff,\n\t\t\t\t(f->pixelformat >> 24) & 0xff,\n\t\t\t\tf->description);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type, v4l2_type_names));\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap_mplane(file, fh,\n\t\t\t\t\t\t\t\t       &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Driver is currently in multi-planar format,\n\t\t\t\t * we can't return it in single-planar API*/\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tif (ops->vidioc_g_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_cap) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tif (ops->vidioc_g_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_g_fmt_vid_overlay(file,\n\t\t\t\t\t\t\t\t    fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\t/* Driver is currently in multi-planar format,\n\t\t\t\t * we can't return it in single-planar API*/\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tif (ops->vidioc_g_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_g_fmt_vid_out) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tif (ops->vidioc_g_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_g_fmt_vid_out_overlay(file,\n\t\t\t\t       fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_g_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_g_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tif (ops->vidioc_g_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_g_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tif (ops->vidioc_g_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_g_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\tif (ops->vidioc_g_fmt_type_private)\n\t\t\t\tret = ops->vidioc_g_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type, v4l2_type_names));\n\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tif (ops->vidioc_s_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tif (ops->vidioc_s_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_cap &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_s_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_s_fmt_vid_overlay(file,\n\t\t\t\t\t\t\t\t    fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tif (ops->vidioc_s_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_mplane(file, fh,\n\t\t\t\t\t\t\t\t\t&f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tif (ops->vidioc_s_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\t} else if (ops->vidioc_s_fmt_vid_out &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_s_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_s_fmt_vid_out_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_s_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_s_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_s_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_s_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_s_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_s_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_s_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_s_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\t/* CLEAR_AFTER_FIELD(f, fmt.raw_data); <- does nothing */\n\t\t\tif (ops->vidioc_s_fmt_type_private)\n\t\t\t\tret = ops->vidioc_s_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_FMT:\n\t{\n\t\tstruct v4l2_format *f = (struct v4l2_format *)arg;\n\n\t\t/* FIXME: Should be one dump per type */\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(f->type,\n\t\t\t\t\t\tv4l2_type_names));\n\t\tswitch (f->type) {\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tif (ops->vidioc_try_fmt_vid_cap) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap(file, fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_cap_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tif (ops->vidioc_try_fmt_vid_cap_mplane) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap_mplane(file,\n\t\t\t\t\t\t\t\t\t fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_cap &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_cap(file,\n\t\t\t\t\t\t\t\t  fh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_try_fmt_vid_overlay)\n\t\t\t\tret = ops->vidioc_try_fmt_vid_overlay(file,\n\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix);\n\t\t\tif (ops->vidioc_try_fmt_vid_out) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out(file, fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_out_mplane) {\n\t\t\t\tif (fmt_sp_to_mp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\tfh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (f_copy.fmt.pix_mp.num_planes > 1) {\n\t\t\t\t\t/* Drivers shouldn't adjust from 1-plane\n\t\t\t\t\t * to more than 1-plane formats */\n\t\t\t\t\tret = -EBUSY;\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tret = fmt_mp_to_sp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt(vfd, &f->fmt.pix);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.pix_mp);\n\t\t\tif (ops->vidioc_try_fmt_vid_out_mplane) {\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_mplane(file,\n\t\t\t\t\t\t\t\t\t fh, f);\n\t\t\t} else if (ops->vidioc_try_fmt_vid_out &&\n\t\t\t\t\tf->fmt.pix_mp.num_planes == 1) {\n\t\t\t\tif (fmt_mp_to_sp(f, &f_copy))\n\t\t\t\t\tbreak;\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out(file,\n\t\t\t\t\t\t\t\t  fh, &f_copy);\n\t\t\t\tif (ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = fmt_sp_to_mp(&f_copy, f);\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tv4l_print_pix_fmt_mplane(vfd, &f->fmt.pix_mp);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.win);\n\t\t\tif (ops->vidioc_try_fmt_vid_out_overlay)\n\t\t\t\tret = ops->vidioc_try_fmt_vid_out_overlay(file,\n\t\t\t\t       fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_try_fmt_vbi_cap)\n\t\t\t\tret = ops->vidioc_try_fmt_vbi_cap(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.vbi);\n\t\t\tif (ops->vidioc_try_fmt_vbi_out)\n\t\t\t\tret = ops->vidioc_try_fmt_vbi_out(file, fh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_try_fmt_sliced_vbi_cap)\n\t\t\t\tret = ops->vidioc_try_fmt_sliced_vbi_cap(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\n\t\t\tCLEAR_AFTER_FIELD(f, fmt.sliced);\n\t\t\tif (ops->vidioc_try_fmt_sliced_vbi_out)\n\t\t\t\tret = ops->vidioc_try_fmt_sliced_vbi_out(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\tcase V4L2_BUF_TYPE_PRIVATE:\n\t\t\t/* CLEAR_AFTER_FIELD(f, fmt.raw_data); <- does nothing */\n\t\t\tif (ops->vidioc_try_fmt_type_private)\n\t\t\t\tret = ops->vidioc_try_fmt_type_private(file,\n\t\t\t\t\t\t\t\tfh, f);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\t/* FIXME: Those buf reqs could be handled here,\n\t   with some changes on videobuf to allow its header to be included at\n\t   videodev2.h or being merged at videodev2.\n\t */\n\tcase VIDIOC_REQBUFS:\n\t{\n\t\tstruct v4l2_requestbuffers *p = arg;\n\n\t\tif (!ops->vidioc_reqbufs)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (p->type < V4L2_BUF_TYPE_PRIVATE)\n\t\t\tCLEAR_AFTER_FIELD(p, memory);\n\n\t\tret = ops->vidioc_reqbufs(file, fh, p);\n\t\tdbgarg(cmd, \"count=%d, type=%s, memory=%s\\n\",\n\t\t\t\tp->count,\n\t\t\t\tprt_names(p->type, v4l2_type_names),\n\t\t\t\tprt_names(p->memory, v4l2_memory_names));\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_querybuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_querybuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_qbuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_qbuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_DQBUF:\n\t{\n\t\tstruct v4l2_buffer *p = arg;\n\n\t\tif (!ops->vidioc_dqbuf)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_dqbuf(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgbuf(cmd, vfd, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_OVERLAY:\n\t{\n\t\tint *i = arg;\n\n\t\tif (!ops->vidioc_overlay)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_overlay(file, fh, *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FBUF:\n\t{\n\t\tstruct v4l2_framebuffer *p = arg;\n\n\t\tif (!ops->vidioc_g_fbuf)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_fbuf(file, fh, arg);\n\t\tif (!ret) {\n\t\t\tdbgarg(cmd, \"capability=0x%x, flags=%d, base=0x%08lx\\n\",\n\t\t\t\t\tp->capability, p->flags,\n\t\t\t\t\t(unsigned long)p->base);\n\t\t\tv4l_print_pix_fmt(vfd, &p->fmt);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FBUF:\n\t{\n\t\tstruct v4l2_framebuffer *p = arg;\n\n\t\tif (!ops->vidioc_s_fbuf)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"capability=0x%x, flags=%d, base=0x%08lx\\n\",\n\t\t\tp->capability, p->flags, (unsigned long)p->base);\n\t\tv4l_print_pix_fmt(vfd, &p->fmt);\n\t\tret = ops->vidioc_s_fbuf(file, fh, arg);\n\t\tbreak;\n\t}\n\tcase VIDIOC_STREAMON:\n\t{\n\t\tenum v4l2_buf_type i = *(int *)arg;\n\n\t\tif (!ops->vidioc_streamon)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(i, v4l2_type_names));\n\t\tret = ops->vidioc_streamon(file, fh, i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_STREAMOFF:\n\t{\n\t\tenum v4l2_buf_type i = *(int *)arg;\n\n\t\tif (!ops->vidioc_streamoff)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(i, v4l2_type_names));\n\t\tret = ops->vidioc_streamoff(file, fh, i);\n\t\tbreak;\n\t}\n\t/* ---------- tv norms ---------- */\n\tcase VIDIOC_ENUMSTD:\n\t{\n\t\tstruct v4l2_standard *p = arg;\n\t\tv4l2_std_id id = vfd->tvnorms, curr_id = 0;\n\t\tunsigned int index = p->index, i, j = 0;\n\t\tconst char *descr = \"\";\n\n\t\t/* Return norm array in a canonical way */\n\t\tfor (i = 0; i <= index && id; i++) {\n\t\t\t/* last std value in the standards array is 0, so this\n\t\t\t   while always ends there since (id & 0) == 0. */\n\t\t\twhile ((id & standards[j].std) != standards[j].std)\n\t\t\t\tj++;\n\t\t\tcurr_id = standards[j].std;\n\t\t\tdescr = standards[j].descr;\n\t\t\tj++;\n\t\t\tif (curr_id == 0)\n\t\t\t\tbreak;\n\t\t\tif (curr_id != V4L2_STD_PAL &&\n\t\t\t    curr_id != V4L2_STD_SECAM &&\n\t\t\t    curr_id != V4L2_STD_NTSC)\n\t\t\t\tid &= ~curr_id;\n\t\t}\n\t\tif (i <= index)\n\t\t\tbreak;\n\n\t\tv4l2_video_std_construct(p, curr_id, descr);\n\n\t\tdbgarg(cmd, \"index=%d, id=0x%Lx, name=%s, fps=%d/%d, \"\n\t\t\t\t\"framelines=%d\\n\", p->index,\n\t\t\t\t(unsigned long long)p->id, p->name,\n\t\t\t\tp->frameperiod.numerator,\n\t\t\t\tp->frameperiod.denominator,\n\t\t\t\tp->framelines);\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_STD:\n\t{\n\t\tv4l2_std_id *id = arg;\n\n\t\tret = 0;\n\t\t/* Calls the specific handler */\n\t\tif (ops->vidioc_g_std)\n\t\t\tret = ops->vidioc_g_std(file, fh, id);\n\t\telse if (vfd->current_norm)\n\t\t\t*id = vfd->current_norm;\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"std=0x%08Lx\\n\", (long long unsigned)*id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_STD:\n\t{\n\t\tv4l2_std_id *id = arg, norm;\n\n\t\tdbgarg(cmd, \"std=%08Lx\\n\", (long long unsigned)*id);\n\n\t\tnorm = (*id) & vfd->tvnorms;\n\t\tif (vfd->tvnorms && !norm)\t/* Check if std is supported */\n\t\t\tbreak;\n\n\t\t/* Calls the specific handler */\n\t\tif (ops->vidioc_s_std)\n\t\t\tret = ops->vidioc_s_std(file, fh, &norm);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\t/* Updates standard information */\n\t\tif (ret >= 0)\n\t\t\tvfd->current_norm = norm;\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYSTD:\n\t{\n\t\tv4l2_std_id *p = arg;\n\n\t\tif (!ops->vidioc_querystd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_querystd(file, fh, arg);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"detected std=%08Lx\\n\",\n\t\t\t\t\t\t(unsigned long long)*p);\n\t\tbreak;\n\t}\n\t/* ------ input switching ---------- */\n\t/* FIXME: Inputs can be handled inside videodev2 */\n\tcase VIDIOC_ENUMINPUT:\n\t{\n\t\tstruct v4l2_input *p = arg;\n\n\t\t/*\n\t\t * We set the flags for CAP_PRESETS, CAP_CUSTOM_TIMINGS &\n\t\t * CAP_STD here based on ioctl handler provided by the\n\t\t * driver. If the driver doesn't support these\n\t\t * for a specific input, it must override these flags.\n\t\t */\n\t\tif (ops->vidioc_s_std)\n\t\t\tp->capabilities |= V4L2_IN_CAP_STD;\n\t\tif (ops->vidioc_s_dv_preset)\n\t\t\tp->capabilities |= V4L2_IN_CAP_PRESETS;\n\t\tif (ops->vidioc_s_dv_timings)\n\t\t\tp->capabilities |= V4L2_IN_CAP_CUSTOM_TIMINGS;\n\n\t\tif (!ops->vidioc_enum_input)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_input(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"audioset=%d, \"\n\t\t\t\t\"tuner=%d, std=%08Lx, status=%d\\n\",\n\t\t\t\tp->index, p->name, p->type, p->audioset,\n\t\t\t\tp->tuner,\n\t\t\t\t(unsigned long long)p->std,\n\t\t\t\tp->status);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_INPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_g_input)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_input(file, fh, i);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_INPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_s_input)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_s_input(file, fh, *i);\n\t\tbreak;\n\t}\n\n\t/* ------ output switching ---------- */\n\tcase VIDIOC_ENUMOUTPUT:\n\t{\n\t\tstruct v4l2_output *p = arg;\n\n\t\tif (!ops->vidioc_enum_output)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * We set the flags for CAP_PRESETS, CAP_CUSTOM_TIMINGS &\n\t\t * CAP_STD here based on ioctl handler provided by the\n\t\t * driver. If the driver doesn't support these\n\t\t * for a specific output, it must override these flags.\n\t\t */\n\t\tif (ops->vidioc_s_std)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_STD;\n\t\tif (ops->vidioc_s_dv_preset)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_PRESETS;\n\t\tif (ops->vidioc_s_dv_timings)\n\t\t\tp->capabilities |= V4L2_OUT_CAP_CUSTOM_TIMINGS;\n\n\t\tret = ops->vidioc_enum_output(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"audioset=0x%x, \"\n\t\t\t\t\"modulator=%d, std=0x%08Lx\\n\",\n\t\t\t\tp->index, p->name, p->type, p->audioset,\n\t\t\t\tp->modulator, (unsigned long long)p->std);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_OUTPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_g_output)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_output(file, fh, i);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_OUTPUT:\n\t{\n\t\tunsigned int *i = arg;\n\n\t\tif (!ops->vidioc_s_output)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"value=%d\\n\", *i);\n\t\tret = ops->vidioc_s_output(file, fh, *i);\n\t\tbreak;\n\t}\n\n\t/* --- controls ---------------------------------------------- */\n\tcase VIDIOC_QUERYCTRL:\n\t{\n\t\tstruct v4l2_queryctrl *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_queryctrl(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_queryctrl)\n\t\t\tret = ops->vidioc_queryctrl(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, type=%d, name=%s, min/max=%d/%d, \"\n\t\t\t\t\t\"step=%d, default=%d, flags=0x%08x\\n\",\n\t\t\t\t\tp->id, p->type, p->name,\n\t\t\t\t\tp->minimum, p->maximum,\n\t\t\t\t\tp->step, p->default_value, p->flags);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x\\n\", p->id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_CTRL:\n\t{\n\t\tstruct v4l2_control *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_g_ctrl(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_g_ctrl)\n\t\t\tret = ops->vidioc_g_ctrl(file, fh, p);\n\t\telse if (ops->vidioc_g_ext_ctrls) {\n\t\t\tstruct v4l2_ext_controls ctrls;\n\t\t\tstruct v4l2_ext_control ctrl;\n\n\t\t\tctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\n\t\t\tctrls.count = 1;\n\t\t\tctrls.controls = &ctrl;\n\t\t\tctrl.id = p->id;\n\t\t\tctrl.value = p->value;\n\t\t\tif (check_ext_ctrls(&ctrls, 1)) {\n\t\t\t\tret = ops->vidioc_g_ext_ctrls(file, fh, &ctrls);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tp->value = ctrl.value;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, value=%d\\n\", p->id, p->value);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x\\n\", p->id);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_CTRL:\n\t{\n\t\tstruct v4l2_control *p = arg;\n\t\tstruct v4l2_ext_controls ctrls;\n\t\tstruct v4l2_ext_control ctrl;\n\n\t\tif (!vfd->ctrl_handler &&\n\t\t\t!ops->vidioc_s_ctrl && !ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"id=0x%x, value=%d\\n\", p->id, p->value);\n\n\t\tif (vfd->ctrl_handler) {\n\t\t\tret = v4l2_s_ctrl(vfd->ctrl_handler, p);\n\t\t\tbreak;\n\t\t}\n\t\tif (ops->vidioc_s_ctrl) {\n\t\t\tret = ops->vidioc_s_ctrl(file, fh, p);\n\t\t\tbreak;\n\t\t}\n\t\tif (!ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\n\t\tctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\n\t\tctrls.count = 1;\n\t\tctrls.controls = &ctrl;\n\t\tctrl.id = p->id;\n\t\tctrl.value = p->value;\n\t\tif (check_ext_ctrls(&ctrls, 1))\n\t\t\tret = ops->vidioc_s_ext_ctrls(file, fh, &ctrls);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_g_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_g_ext_ctrls && check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_g_ext_ctrls(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, !ret);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (!vfd->ctrl_handler && !ops->vidioc_s_ext_ctrls)\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, 1);\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_s_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_s_ext_ctrls(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_EXT_CTRLS:\n\t{\n\t\tstruct v4l2_ext_controls *p = arg;\n\n\t\tp->error_idx = p->count;\n\t\tif (!vfd->ctrl_handler && !ops->vidioc_try_ext_ctrls)\n\t\t\tbreak;\n\t\tv4l_print_ext_ctrls(cmd, vfd, p, 1);\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_try_ext_ctrls(vfd->ctrl_handler, p);\n\t\telse if (check_ext_ctrls(p, 0))\n\t\t\tret = ops->vidioc_try_ext_ctrls(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERYMENU:\n\t{\n\t\tstruct v4l2_querymenu *p = arg;\n\n\t\tif (vfd->ctrl_handler)\n\t\t\tret = v4l2_querymenu(vfd->ctrl_handler, p);\n\t\telse if (ops->vidioc_querymenu)\n\t\t\tret = ops->vidioc_querymenu(file, fh, p);\n\t\telse\n\t\t\tbreak;\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"id=0x%x, index=%d, name=%s\\n\",\n\t\t\t\tp->id, p->index, p->name);\n\t\telse\n\t\t\tdbgarg(cmd, \"id=0x%x, index=%d\\n\",\n\t\t\t\tp->id, p->index);\n\t\tbreak;\n\t}\n\t/* --- audio ---------------------------------------------- */\n\tcase VIDIOC_ENUMAUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_enumaudio)\n\t\t\tbreak;\n\t\tret = ops->vidioc_enumaudio(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\telse\n\t\t\tdbgarg(cmd, \"index=%d\\n\", p->index);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_AUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_g_audio)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_audio(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index,\n\t\t\t\t\tp->name, p->capability, p->mode);\n\t\telse\n\t\t\tdbgarg(cmd, \"index=%d\\n\", p->index);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_AUDIO:\n\t{\n\t\tstruct v4l2_audio *p = arg;\n\n\t\tif (!ops->vidioc_s_audio)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=0x%x, \"\n\t\t\t\t\t\"mode=0x%x\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tret = ops->vidioc_s_audio(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUMAUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_enumaudout)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"Enum for index=%d\\n\", p->index);\n\t\tret = ops->vidioc_enumaudout(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_AUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_g_audout)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_audout(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_AUDOUT:\n\t{\n\t\tstruct v4l2_audioout *p = arg;\n\n\t\tif (!ops->vidioc_s_audout)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\t\"mode=%d\\n\", p->index, p->name,\n\t\t\t\t\tp->capability, p->mode);\n\n\t\tret = ops->vidioc_s_audout(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_MODULATOR:\n\t{\n\t\tstruct v4l2_modulator *p = arg;\n\n\t\tif (!ops->vidioc_g_modulator)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_modulator(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, \"\n\t\t\t\t\t\"capability=%d, rangelow=%d,\"\n\t\t\t\t\t\" rangehigh=%d, txsubchans=%d\\n\",\n\t\t\t\t\tp->index, p->name, p->capability,\n\t\t\t\t\tp->rangelow, p->rangehigh,\n\t\t\t\t\tp->txsubchans);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_MODULATOR:\n\t{\n\t\tstruct v4l2_modulator *p = arg;\n\n\t\tif (!ops->vidioc_s_modulator)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, capability=%d, \"\n\t\t\t\t\"rangelow=%d, rangehigh=%d, txsubchans=%d\\n\",\n\t\t\t\tp->index, p->name, p->capability, p->rangelow,\n\t\t\t\tp->rangehigh, p->txsubchans);\n\t\t\tret = ops->vidioc_s_modulator(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_CROP:\n\t{\n\t\tstruct v4l2_crop *p = arg;\n\n\t\tif (!ops->vidioc_g_crop)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_g_crop(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgrect(vfd, \"\", &p->c);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_CROP:\n\t{\n\t\tstruct v4l2_crop *p = arg;\n\n\t\tif (!ops->vidioc_s_crop)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tdbgrect(vfd, \"\", &p->c);\n\t\tret = ops->vidioc_s_crop(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_CROPCAP:\n\t{\n\t\tstruct v4l2_cropcap *p = arg;\n\n\t\t/*FIXME: Should also show v4l2_fract pixelaspect */\n\t\tif (!ops->vidioc_cropcap)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_cropcap(file, fh, p);\n\t\tif (!ret) {\n\t\t\tdbgrect(vfd, \"bounds \", &p->bounds);\n\t\t\tdbgrect(vfd, \"defrect \", &p->defrect);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_JPEGCOMP:\n\t{\n\t\tstruct v4l2_jpegcompression *p = arg;\n\n\t\tif (!ops->vidioc_g_jpegcomp)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_jpegcomp(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"quality=%d, APPn=%d, \"\n\t\t\t\t\t\"APP_len=%d, COM_len=%d, \"\n\t\t\t\t\t\"jpeg_markers=%d\\n\",\n\t\t\t\t\tp->quality, p->APPn, p->APP_len,\n\t\t\t\t\tp->COM_len, p->jpeg_markers);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_JPEGCOMP:\n\t{\n\t\tstruct v4l2_jpegcompression *p = arg;\n\n\t\tif (!ops->vidioc_g_jpegcomp)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"quality=%d, APPn=%d, APP_len=%d, \"\n\t\t\t\t\t\"COM_len=%d, jpeg_markers=%d\\n\",\n\t\t\t\t\tp->quality, p->APPn, p->APP_len,\n\t\t\t\t\tp->COM_len, p->jpeg_markers);\n\t\t\tret = ops->vidioc_s_jpegcomp(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_ENC_INDEX:\n\t{\n\t\tstruct v4l2_enc_idx *p = arg;\n\n\t\tif (!ops->vidioc_g_enc_index)\n\t\t\tbreak;\n\t\tret = ops->vidioc_g_enc_index(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"entries=%d, entries_cap=%d\\n\",\n\t\t\t\t\tp->entries, p->entries_cap);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENCODER_CMD:\n\t{\n\t\tstruct v4l2_encoder_cmd *p = arg;\n\n\t\tif (!ops->vidioc_encoder_cmd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_encoder_cmd(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"cmd=%d, flags=%x\\n\", p->cmd, p->flags);\n\t\tbreak;\n\t}\n\tcase VIDIOC_TRY_ENCODER_CMD:\n\t{\n\t\tstruct v4l2_encoder_cmd *p = arg;\n\n\t\tif (!ops->vidioc_try_encoder_cmd)\n\t\t\tbreak;\n\t\tret = ops->vidioc_try_encoder_cmd(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"cmd=%d, flags=%x\\n\", p->cmd, p->flags);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_PARM:\n\t{\n\t\tstruct v4l2_streamparm *p = arg;\n\n\t\tif (ops->vidioc_g_parm) {\n\t\t\tret = check_fmt(ops, p->type);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = ops->vidioc_g_parm(file, fh, p);\n\t\t} else {\n\t\t\tv4l2_std_id std = vfd->current_norm;\n\n\t\t\tif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\t\t\tbreak;\n\n\t\t\tret = 0;\n\t\t\tif (ops->vidioc_g_std)\n\t\t\t\tret = ops->vidioc_g_std(file, fh, &std);\n\t\t\telse if (std == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tif (ret == 0)\n\t\t\t\tv4l2_video_std_frame_period(std,\n\t\t\t\t\t\t    &p->parm.capture.timeperframe);\n\t\t}\n\n\t\tdbgarg(cmd, \"type=%d\\n\", p->type);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_PARM:\n\t{\n\t\tstruct v4l2_streamparm *p = arg;\n\n\t\tif (!ops->vidioc_s_parm)\n\t\t\tbreak;\n\t\tret = check_fmt(ops, p->type);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"type=%d\\n\", p->type);\n\t\tret = ops->vidioc_s_parm(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_TUNER:\n\t{\n\t\tstruct v4l2_tuner *p = arg;\n\n\t\tif (!ops->vidioc_g_tuner)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_tuner(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\t\"capability=0x%x, rangelow=%d, \"\n\t\t\t\t\t\"rangehigh=%d, signal=%d, afc=%d, \"\n\t\t\t\t\t\"rxsubchans=0x%x, audmode=%d\\n\",\n\t\t\t\t\tp->index, p->name, p->type,\n\t\t\t\t\tp->capability, p->rangelow,\n\t\t\t\t\tp->rangehigh, p->signal, p->afc,\n\t\t\t\t\tp->rxsubchans, p->audmode);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_TUNER:\n\t{\n\t\tstruct v4l2_tuner *p = arg;\n\n\t\tif (!ops->vidioc_s_tuner)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"index=%d, name=%s, type=%d, \"\n\t\t\t\t\"capability=0x%x, rangelow=%d, \"\n\t\t\t\t\"rangehigh=%d, signal=%d, afc=%d, \"\n\t\t\t\t\"rxsubchans=0x%x, audmode=%d\\n\",\n\t\t\t\tp->index, p->name, p->type,\n\t\t\t\tp->capability, p->rangelow,\n\t\t\t\tp->rangehigh, p->signal, p->afc,\n\t\t\t\tp->rxsubchans, p->audmode);\n\t\tret = ops->vidioc_s_tuner(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_FREQUENCY:\n\t{\n\t\tstruct v4l2_frequency *p = arg;\n\n\t\tif (!ops->vidioc_g_frequency)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_frequency(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"tuner=%d, type=%d, frequency=%d\\n\",\n\t\t\t\t\tp->tuner, p->type, p->frequency);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_FREQUENCY:\n\t{\n\t\tstruct v4l2_frequency *p = arg;\n\n\t\tif (!ops->vidioc_s_frequency)\n\t\t\tbreak;\n\t\tdbgarg(cmd, \"tuner=%d, type=%d, frequency=%d\\n\",\n\t\t\t\tp->tuner, p->type, p->frequency);\n\t\tret = ops->vidioc_s_frequency(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_SLICED_VBI_CAP:\n\t{\n\t\tstruct v4l2_sliced_vbi_cap *p = arg;\n\n\t\tif (!ops->vidioc_g_sliced_vbi_cap)\n\t\t\tbreak;\n\n\t\t/* Clear up to type, everything after type is zerod already */\n\t\tmemset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));\n\n\t\tdbgarg(cmd, \"type=%s\\n\", prt_names(p->type, v4l2_type_names));\n\t\tret = ops->vidioc_g_sliced_vbi_cap(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg2(\"service_set=%d\\n\", p->service_set);\n\t\tbreak;\n\t}\n\tcase VIDIOC_LOG_STATUS:\n\t{\n\t\tif (!ops->vidioc_log_status)\n\t\t\tbreak;\n\t\tret = ops->vidioc_log_status(file, fh);\n\t\tbreak;\n\t}\n#ifdef CONFIG_VIDEO_ADV_DEBUG\n\tcase VIDIOC_DBG_G_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (ops->vidioc_g_register) {\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\tret = -EPERM;\n\t\t\telse\n\t\t\t\tret = ops->vidioc_g_register(file, fh, p);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_DBG_S_REGISTER:\n\t{\n\t\tstruct v4l2_dbg_register *p = arg;\n\n\t\tif (ops->vidioc_s_register) {\n\t\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\t\tret = -EPERM;\n\t\t\telse\n\t\t\t\tret = ops->vidioc_s_register(file, fh, p);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tcase VIDIOC_DBG_G_CHIP_IDENT:\n\t{\n\t\tstruct v4l2_dbg_chip_ident *p = arg;\n\n\t\tif (!ops->vidioc_g_chip_ident)\n\t\t\tbreak;\n\t\tp->ident = V4L2_IDENT_NONE;\n\t\tp->revision = 0;\n\t\tret = ops->vidioc_g_chip_ident(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"chip_ident=%u, revision=0x%x\\n\", p->ident, p->revision);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_HW_FREQ_SEEK:\n\t{\n\t\tstruct v4l2_hw_freq_seek *p = arg;\n\n\t\tif (!ops->vidioc_s_hw_freq_seek)\n\t\t\tbreak;\n\t\tdbgarg(cmd,\n\t\t\t\"tuner=%d, type=%d, seek_upward=%d, wrap_around=%d\\n\",\n\t\t\tp->tuner, p->type, p->seek_upward, p->wrap_around);\n\t\tret = ops->vidioc_s_hw_freq_seek(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_FRAMESIZES:\n\t{\n\t\tstruct v4l2_frmsizeenum *p = arg;\n\n\t\tif (!ops->vidioc_enum_framesizes)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_framesizes(file, fh, p);\n\t\tdbgarg(cmd,\n\t\t\t\"index=%d, pixelformat=%c%c%c%c, type=%d \",\n\t\t\tp->index,\n\t\t\t(p->pixel_format & 0xff),\n\t\t\t(p->pixel_format >>  8) & 0xff,\n\t\t\t(p->pixel_format >> 16) & 0xff,\n\t\t\t(p->pixel_format >> 24) & 0xff,\n\t\t\tp->type);\n\t\tswitch (p->type) {\n\t\tcase V4L2_FRMSIZE_TYPE_DISCRETE:\n\t\t\tdbgarg3(\"width = %d, height=%d\\n\",\n\t\t\t\tp->discrete.width, p->discrete.height);\n\t\t\tbreak;\n\t\tcase V4L2_FRMSIZE_TYPE_STEPWISE:\n\t\t\tdbgarg3(\"min %dx%d, max %dx%d, step %dx%d\\n\",\n\t\t\t\tp->stepwise.min_width,  p->stepwise.min_height,\n\t\t\t\tp->stepwise.step_width, p->stepwise.step_height,\n\t\t\t\tp->stepwise.max_width,  p->stepwise.max_height);\n\t\t\tbreak;\n\t\tcase V4L2_FRMSIZE_TYPE_CONTINUOUS:\n\t\t\tdbgarg3(\"continuous\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg3(\"- Unknown type!\\n\");\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_FRAMEINTERVALS:\n\t{\n\t\tstruct v4l2_frmivalenum *p = arg;\n\n\t\tif (!ops->vidioc_enum_frameintervals)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_frameintervals(file, fh, p);\n\t\tdbgarg(cmd,\n\t\t\t\"index=%d, pixelformat=%d, width=%d, height=%d, type=%d \",\n\t\t\tp->index, p->pixel_format,\n\t\t\tp->width, p->height, p->type);\n\t\tswitch (p->type) {\n\t\tcase V4L2_FRMIVAL_TYPE_DISCRETE:\n\t\t\tdbgarg2(\"fps=%d/%d\\n\",\n\t\t\t\tp->discrete.numerator,\n\t\t\t\tp->discrete.denominator);\n\t\t\tbreak;\n\t\tcase V4L2_FRMIVAL_TYPE_STEPWISE:\n\t\t\tdbgarg2(\"min=%d/%d, max=%d/%d, step=%d/%d\\n\",\n\t\t\t\tp->stepwise.min.numerator,\n\t\t\t\tp->stepwise.min.denominator,\n\t\t\t\tp->stepwise.max.numerator,\n\t\t\t\tp->stepwise.max.denominator,\n\t\t\t\tp->stepwise.step.numerator,\n\t\t\t\tp->stepwise.step.denominator);\n\t\t\tbreak;\n\t\tcase V4L2_FRMIVAL_TYPE_CONTINUOUS:\n\t\t\tdbgarg2(\"continuous\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg2(\"- Unknown type!\\n\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_ENUM_DV_PRESETS:\n\t{\n\t\tstruct v4l2_dv_enum_preset *p = arg;\n\n\t\tif (!ops->vidioc_enum_dv_presets)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_enum_dv_presets(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd,\n\t\t\t\t\"index=%d, preset=%d, name=%s, width=%d,\"\n\t\t\t\t\" height=%d \",\n\t\t\t\tp->index, p->preset, p->name, p->width,\n\t\t\t\tp->height);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_s_dv_preset)\n\t\t\tbreak;\n\n\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tret = ops->vidioc_s_dv_preset(file, fh, p);\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_g_dv_preset)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_dv_preset(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tbreak;\n\t}\n\tcase VIDIOC_QUERY_DV_PRESET:\n\t{\n\t\tstruct v4l2_dv_preset *p = arg;\n\n\t\tif (!ops->vidioc_query_dv_preset)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_query_dv_preset(file, fh, p);\n\t\tif (!ret)\n\t\t\tdbgarg(cmd, \"preset=%d\\n\", p->preset);\n\t\tbreak;\n\t}\n\tcase VIDIOC_S_DV_TIMINGS:\n\t{\n\t\tstruct v4l2_dv_timings *p = arg;\n\n\t\tif (!ops->vidioc_s_dv_timings)\n\t\t\tbreak;\n\n\t\tswitch (p->type) {\n\t\tcase V4L2_DV_BT_656_1120:\n\t\t\tdbgarg2(\"bt-656/1120:interlaced=%d, pixelclock=%lld,\"\n\t\t\t\t\" width=%d, height=%d, polarities=%x,\"\n\t\t\t\t\" hfrontporch=%d, hsync=%d, hbackporch=%d,\"\n\t\t\t\t\" vfrontporch=%d, vsync=%d, vbackporch=%d,\"\n\t\t\t\t\" il_vfrontporch=%d, il_vsync=%d,\"\n\t\t\t\t\" il_vbackporch=%d\\n\",\n\t\t\t\tp->bt.interlaced, p->bt.pixelclock,\n\t\t\t\tp->bt.width, p->bt.height, p->bt.polarities,\n\t\t\t\tp->bt.hfrontporch, p->bt.hsync,\n\t\t\t\tp->bt.hbackporch, p->bt.vfrontporch,\n\t\t\t\tp->bt.vsync, p->bt.vbackporch,\n\t\t\t\tp->bt.il_vfrontporch, p->bt.il_vsync,\n\t\t\t\tp->bt.il_vbackporch);\n\t\t\tret = ops->vidioc_s_dv_timings(file, fh, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdbgarg2(\"Unknown type %d!\\n\", p->type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_G_DV_TIMINGS:\n\t{\n\t\tstruct v4l2_dv_timings *p = arg;\n\n\t\tif (!ops->vidioc_g_dv_timings)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_g_dv_timings(file, fh, p);\n\t\tif (!ret) {\n\t\t\tswitch (p->type) {\n\t\t\tcase V4L2_DV_BT_656_1120:\n\t\t\t\tdbgarg2(\"bt-656/1120:interlaced=%d,\"\n\t\t\t\t\t\" pixelclock=%lld,\"\n\t\t\t\t\t\" width=%d, height=%d, polarities=%x,\"\n\t\t\t\t\t\" hfrontporch=%d, hsync=%d,\"\n\t\t\t\t\t\" hbackporch=%d, vfrontporch=%d,\"\n\t\t\t\t\t\" vsync=%d, vbackporch=%d,\"\n\t\t\t\t\t\" il_vfrontporch=%d, il_vsync=%d,\"\n\t\t\t\t\t\" il_vbackporch=%d\\n\",\n\t\t\t\t\tp->bt.interlaced, p->bt.pixelclock,\n\t\t\t\t\tp->bt.width, p->bt.height,\n\t\t\t\t\tp->bt.polarities, p->bt.hfrontporch,\n\t\t\t\t\tp->bt.hsync, p->bt.hbackporch,\n\t\t\t\t\tp->bt.vfrontporch, p->bt.vsync,\n\t\t\t\t\tp->bt.vbackporch, p->bt.il_vfrontporch,\n\t\t\t\t\tp->bt.il_vsync, p->bt.il_vbackporch);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdbgarg2(\"Unknown type %d!\\n\", p->type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_DQEVENT:\n\t{\n\t\tstruct v4l2_event *ev = arg;\n\n\t\tif (!ops->vidioc_subscribe_event)\n\t\t\tbreak;\n\n\t\tret = v4l2_event_dequeue(fh, ev, file->f_flags & O_NONBLOCK);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"no pending events?\");\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd,\n\t\t       \"pending=%d, type=0x%8.8x, sequence=%d, \"\n\t\t       \"timestamp=%lu.%9.9lu \",\n\t\t       ev->pending, ev->type, ev->sequence,\n\t\t       ev->timestamp.tv_sec, ev->timestamp.tv_nsec);\n\t\tbreak;\n\t}\n\tcase VIDIOC_SUBSCRIBE_EVENT:\n\t{\n\t\tstruct v4l2_event_subscription *sub = arg;\n\n\t\tif (!ops->vidioc_subscribe_event)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_subscribe_event(fh, sub);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"failed, ret=%ld\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd, \"type=0x%8.8x\", sub->type);\n\t\tbreak;\n\t}\n\tcase VIDIOC_UNSUBSCRIBE_EVENT:\n\t{\n\t\tstruct v4l2_event_subscription *sub = arg;\n\n\t\tif (!ops->vidioc_unsubscribe_event)\n\t\t\tbreak;\n\n\t\tret = ops->vidioc_unsubscribe_event(fh, sub);\n\t\tif (ret < 0) {\n\t\t\tdbgarg(cmd, \"failed, ret=%ld\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tdbgarg(cmd, \"type=0x%8.8x\", sub->type);\n\t\tbreak;\n\t}\n\tdefault:\n\t{\n\t\tif (!ops->vidioc_default)\n\t\t\tbreak;\n\t\tret = ops->vidioc_default(file, fh, cmd, arg);\n\t\tbreak;\n\t}\n\t} /* switch */\n\n\tif (vfd->debug & V4L2_DEBUG_IOCTL_ARG) {\n\t\tif (ret < 0) {\n\t\t\tv4l_print_ioctl(vfd->name, cmd);\n\t\t\tprintk(KERN_CONT \" error %ld\\n\", ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/* In some cases, only a few fields are used as input, i.e. when the app sets\n * \"index\" and then the driver fills in the rest of the structure for the thing\n * with that index.  We only need to copy up the first non-input field.  */\nstatic unsigned long cmd_input_size(unsigned int cmd)\n{\n\t/* Size of structure up to and including 'field' */\n#define CMDINSIZE(cmd, type, field) \t\t\t\t\\\n\tcase VIDIOC_##cmd: \t\t\t\t\t\\\n\t\treturn offsetof(struct v4l2_##type, field) + \t\\\n\t\t\tsizeof(((struct v4l2_##type *)0)->field);\n\n\tswitch (cmd) {\n\t\tCMDINSIZE(ENUM_FMT,\t\tfmtdesc,\ttype);\n\t\tCMDINSIZE(G_FMT,\t\tformat,\t\ttype);\n\t\tCMDINSIZE(QUERYBUF,\t\tbuffer,\t\tlength);\n\t\tCMDINSIZE(G_PARM,\t\tstreamparm,\ttype);\n\t\tCMDINSIZE(ENUMSTD,\t\tstandard,\tindex);\n\t\tCMDINSIZE(ENUMINPUT,\t\tinput,\t\tindex);\n\t\tCMDINSIZE(G_CTRL,\t\tcontrol,\tid);\n\t\tCMDINSIZE(G_TUNER,\t\ttuner,\t\tindex);\n\t\tCMDINSIZE(QUERYCTRL,\t\tqueryctrl,\tid);\n\t\tCMDINSIZE(QUERYMENU,\t\tquerymenu,\tindex);\n\t\tCMDINSIZE(ENUMOUTPUT,\t\toutput,\t\tindex);\n\t\tCMDINSIZE(G_MODULATOR,\t\tmodulator,\tindex);\n\t\tCMDINSIZE(G_FREQUENCY,\t\tfrequency,\ttuner);\n\t\tCMDINSIZE(CROPCAP,\t\tcropcap,\ttype);\n\t\tCMDINSIZE(G_CROP,\t\tcrop,\t\ttype);\n\t\tCMDINSIZE(ENUMAUDIO,\t\taudio, \t\tindex);\n\t\tCMDINSIZE(ENUMAUDOUT,\t\taudioout, \tindex);\n\t\tCMDINSIZE(ENCODER_CMD,\t\tencoder_cmd,\tflags);\n\t\tCMDINSIZE(TRY_ENCODER_CMD,\tencoder_cmd,\tflags);\n\t\tCMDINSIZE(G_SLICED_VBI_CAP,\tsliced_vbi_cap,\ttype);\n\t\tCMDINSIZE(ENUM_FRAMESIZES,\tfrmsizeenum,\tpixel_format);\n\t\tCMDINSIZE(ENUM_FRAMEINTERVALS,\tfrmivalenum,\theight);\n\tdefault:\n\t\treturn _IOC_SIZE(cmd);\n\t}\n}\n\nstatic int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\n\t\t\t    void * __user *user_ptr, void ***kernel_ptr)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase VIDIOC_QUERYBUF:\n\tcase VIDIOC_QBUF:\n\tcase VIDIOC_DQBUF: {\n\t\tstruct v4l2_buffer *buf = parg;\n\n\t\tif (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {\n\t\t\tif (buf->length > VIDEO_MAX_PLANES) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*user_ptr = (void __user *)buf->m.planes;\n\t\t\t*kernel_ptr = (void **)&buf->m.planes;\n\t\t\t*array_size = sizeof(struct v4l2_plane) * buf->length;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase VIDIOC_S_EXT_CTRLS:\n\tcase VIDIOC_G_EXT_CTRLS:\n\tcase VIDIOC_TRY_EXT_CTRLS: {\n\t\tstruct v4l2_ext_controls *ctrls = parg;\n\n\t\tif (ctrls->count != 0) {\n\t\t\t*user_ptr = (void __user *)ctrls->controls;\n\t\t\t*kernel_ptr = (void **)&ctrls->controls;\n\t\t\t*array_size = sizeof(struct v4l2_ext_control)\n\t\t\t\t    * ctrls->count;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\treturn ret;\n}\n\nlong\nvideo_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:\n\tkfree(mbuf);\n\treturn err;\n}\nEXPORT_SYMBOL(video_usercopy);\n\nlong video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\treturn video_usercopy(file, cmd, arg, __video_do_ioctl);\n}\nEXPORT_SYMBOL(video_ioctl2);\n"], "filenames": ["drivers/media/video/v4l2-ioctl.c"], "buggy_code_start_loc": [297], "buggy_code_end_loc": [2424], "fixing_code_start_loc": [296], "fixing_code_end_loc": [2338], "type": "CWE-399", "message": "The video_usercopy function in drivers/media/video/v4l2-ioctl.c in the Linux kernel before 2.6.39 relies on the count value of a v4l2_ext_controls data structure to determine a kmalloc size, which might allow local users to cause a denial of service (memory consumption) via a large value.", "other": {"cve": {"id": "CVE-2010-5329", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-24T06:59:00.257", "lastModified": "2017-04-27T01:59:00.257", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The video_usercopy function in drivers/media/video/v4l2-ioctl.c in the Linux kernel before 2.6.39 relies on the count value of a v4l2_ext_controls data structure to determine a kmalloc size, which might allow local users to cause a denial of service (memory consumption) via a large value."}, {"lang": "es", "value": "La funci\u00f3n video_usercopy en drivers/media/video/v4l2-ioctl.c en el kernel de Linux en versiones anteriores a 2.6.39 se basa en el valor de conteo de una estructura de datos v4l2_ext_controls para determinar un tama\u00f1o de kmalloc, lo que podr\u00eda permitir a usuarios locales causar una denegaci\u00f3n de servicio (consumo de memoria) a trav\u00e9s de un gran valor."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}]}]}], "references": [{"url": "http://linuxtv.org/irc/v4l/index.php?date=2010-07-29", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/02/08/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/97986", "source": "cve@mitre.org"}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fc0a80798576f80ca10b3f6c9c7097f12fd1d64e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fc0a80798576f80ca10b3f6c9c7097f12fd1d64e"}}