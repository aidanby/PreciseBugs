{"buggy_code": ["/*\n * Snd_fx.cpp\n * -----------\n * Purpose: Processing of pattern commands, song length calculation...\n * Notes  : This needs some heavy refactoring.\n *          I thought of actually adding an effect interface class. Every pattern effect\n *          could then be moved into its own class that inherits from the effect interface.\n *          If effect handling differs severly between module formats, every format would have\n *          its own class for that effect. Then, a call chain of effect classes could be set up\n *          for each format, since effects cannot be processed in the same order in all formats.\n * Authors: Olivier Lapicque\n *          OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n */\n\n\n#include \"stdafx.h\"\n#include \"Sndfile.h\"\n#include \"mod_specifications.h\"\n#ifdef MODPLUG_TRACKER\n#include \"../mptrack/Moddoc.h\"\n#endif // MODPLUG_TRACKER\n#include \"tuning.h\"\n#include \"Tables.h\"\n#include \"modsmp_ctrl.h\"\t// For updating the loop wraparound data with the invert loop effect\n#include \"plugins/PlugInterface.h\"\n\nOPENMPT_NAMESPACE_BEGIN\n\n// Formats which have 7-bit (0...128) instead of 6-bit (0...64) global volume commands, or which are imported to this range (mostly formats which are converted to IT internally)\n#ifdef MODPLUG_TRACKER\n#define GLOBALVOL_7BIT_FORMATS_EXT (MOD_TYPE_MT2)\n#else\n#define GLOBALVOL_7BIT_FORMATS_EXT Enum<MODTYPE>::value_type()\n#endif // MODPLUG_TRACKER\n#define GLOBALVOL_7BIT_FORMATS (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM | MOD_TYPE_PTM | MOD_TYPE_MDL | MOD_TYPE_DTM | GLOBALVOL_7BIT_FORMATS_EXT)\n\n\n// Compensate frequency slide LUTs depending on whether we are handling periods or frequency - \"up\" and \"down\" in function name are seen from frequency perspective.\nstatic uint32 GetLinearSlideDownTable    (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideDownTable[i]     : LinearSlideUpTable[i]; }\nstatic uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }\nstatic uint32 GetFineLinearSlideDownTable(const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(FineLinearSlideDownTable)); return sndFile->m_playBehaviour[kHertzInLinearMode] ? FineLinearSlideDownTable[i] : FineLinearSlideUpTable[i]; }\nstatic uint32 GetFineLinearSlideUpTable  (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(FineLinearSlideDownTable)); return sndFile->m_playBehaviour[kHertzInLinearMode] ? FineLinearSlideUpTable[i]   : FineLinearSlideDownTable[i]; }\n\n\n////////////////////////////////////////////////////////////\n// Length\n\n\n// Memory class for GetLength() code\nclass GetLengthMemory\n{\nprotected:\n\tconst CSoundFile &sndFile;\n\npublic:\n\tstd::unique_ptr<CSoundFile::PlayState> state;\n\tstruct ChnSettings\n\t{\n\t\tdouble patLoop = 0.0;\n\t\tCSoundFile::samplecount_t patLoopSmp = 0;\n\t\tROWINDEX patLoopStart = 0;\n\t\tuint32 ticksToRender = 0;\t// When using sample sync, we still need to render this many ticks\n\t\tbool incChanged = false;\t// When using sample sync, note frequency has changed\n\t\tuint8 vol = 0xFF;\n\t};\n\n#ifndef NO_PLUGINS\n\ttypedef std::map<std::pair<ModCommand::INSTR, uint16>, uint16> PlugParamMap;\n\tPlugParamMap plugParams;\n#endif\n\tstd::vector<ChnSettings> chnSettings;\n\tdouble elapsedTime;\n\tstatic const uint32 IGNORE_CHANNEL = uint32_max;\n\n\tGetLengthMemory(const CSoundFile &sf)\n\t\t: sndFile(sf)\n\t\t, state(mpt::make_unique<CSoundFile::PlayState>(sf.m_PlayState))\n\t{\n\t\tReset();\n\t}\n\n\tvoid Reset()\n\t{\n\t\tplugParams.clear();\n\t\telapsedTime = 0.0;\n\t\tstate->m_lTotalSampleCount = 0;\n\t\tstate->m_nMusicSpeed = sndFile.m_nDefaultSpeed;\n\t\tstate->m_nMusicTempo = sndFile.m_nDefaultTempo;\n\t\tstate->m_nGlobalVolume = sndFile.m_nDefaultGlobalVolume;\n\t\tchnSettings.assign(sndFile.GetNumChannels(), ChnSettings());\n\t\tfor(CHANNELINDEX chn = 0; chn < sndFile.GetNumChannels(); chn++)\n\t\t{\n\t\t\tstate->Chn[chn].Reset(ModChannel::resetTotal, sndFile, chn);\n\t\t\tstate->Chn[chn].nOldGlobalVolSlide = 0;\n\t\t\tstate->Chn[chn].nOldChnVolSlide = 0;\n\t\t\tstate->Chn[chn].nNote = state->Chn[chn].nNewNote = state->Chn[chn].nLastNote = NOTE_NONE;\n\t\t}\n\t}\n\n\t// Increment playback position of sample and envelopes on a channel\n\tvoid RenderChannel(CHANNELINDEX channel, uint32 tickDuration, uint32 portaStart = uint32_max)\n\t{\n\t\tModChannel &chn = state->Chn[channel];\n\t\tuint32 numTicks = chnSettings[channel].ticksToRender;\n\t\tif(numTicks == IGNORE_CHANNEL || numTicks == 0 || (!chn.IsSamplePlaying() && !chnSettings[channel].incChanged) || chn.pModSample == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tconst SmpLength sampleEnd = chn.dwFlags[CHN_LOOP] ? chn.nLoopEnd : chn.nLength;\n\t\tconst SmpLength loopLength = chn.nLoopEnd - chn.nLoopStart;\n\t\tconst bool itEnvMode = sndFile.m_playBehaviour[kITEnvelopePositionHandling];\n\t\tconst bool updatePitchEnv = (chn.PitchEnv.flags & (ENV_ENABLED | ENV_FILTER)) == ENV_ENABLED;\n\t\tbool stopNote = false;\n\n\t\tSamplePosition inc = chn.increment * tickDuration;\n\t\tif(chn.dwFlags[CHN_PINGPONGFLAG]) inc.Negate();\n\n\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t{\n\t\t\tbool updateInc = (chn.PitchEnv.flags & (ENV_ENABLED | ENV_FILTER)) == ENV_ENABLED;\n\t\t\tif(i >= portaStart)\n\t\t\t{\n\t\t\t\tchn.isFirstTick = false;\n\t\t\t\tconst ModCommand &p = *sndFile.Patterns[state->m_nPattern].GetpModCommand(state->m_nRow, channel);\n\t\t\t\tif(p.command == CMD_TONEPORTAMENTO) sndFile.TonePortamento(&chn, p.param);\n\t\t\t\telse if(p.command == CMD_TONEPORTAVOL) sndFile.TonePortamento(&chn, 0);\n\t\t\t\tif(p.volcmd == VOLCMD_TONEPORTAMENTO)\n\t\t\t\t{\n\t\t\t\t\tuint32 param = p.vol;\n\t\t\t\t\tif(sndFile.GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DMF | MOD_TYPE_DBM | MOD_TYPE_IMF | MOD_TYPE_PSM | MOD_TYPE_J2B | MOD_TYPE_ULT | MOD_TYPE_OKT | MOD_TYPE_MT2 | MOD_TYPE_MDL))\n\t\t\t\t\t{\n\t\t\t\t\t\tparam = ImpulseTrackerPortaVolCmd[param & 0x0F];\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Close enough. Do not bother with idiosyncratic FT2 behaviour here.\n\t\t\t\t\t\tparam <<= 4;\n\t\t\t\t\t}\n\t\t\t\t\tsndFile.TonePortamento(&chn, param);\n\t\t\t\t}\n\t\t\t\tupdateInc = true;\n\t\t\t}\n\n\t\t\tint period = chn.nPeriod;\n\t\t\tif(itEnvMode) sndFile.IncrementEnvelopePositions(&chn);\n\t\t\tif(updatePitchEnv)\n\t\t\t{\n\t\t\t\tsndFile.ProcessPitchFilterEnvelope(&chn, period);\n\t\t\t\tupdateInc = true;\n\t\t\t}\n\t\t\tif(!itEnvMode) sndFile.IncrementEnvelopePositions(&chn);\n\t\t\tint vol = 0;\n\t\t\tsndFile.ProcessInstrumentFade(&chn, vol);\n\n\t\t\tif(updateInc || chnSettings[channel].incChanged)\n\t\t\t{\n\t\t\t\tchn.increment = sndFile.GetChannelIncrement(&chn, period, 0);\n\t\t\t\tchnSettings[channel].incChanged = false;\n\t\t\t\tinc = chn.increment * tickDuration;\n\t\t\t\tif(chn.dwFlags[CHN_PINGPONGFLAG]) inc.Negate();\n\t\t\t}\n\n\t\t\tchn.position += inc;\n\n\t\t\tif(chn.position.GetUInt() >= sampleEnd)\n\t\t\t{\n\t\t\t\tif(chn.dwFlags[CHN_LOOP])\n\t\t\t\t{\n\t\t\t\t\t// We exceeded the sample loop, go back to loop start.\n\t\t\t\t\tif(chn.dwFlags[CHN_PINGPONGLOOP])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chn.position < SamplePosition(chn.nLoopStart, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchn.position = SamplePosition(chn.nLoopStart + chn.nLoopStart, 0) - chn.position;\n\t\t\t\t\t\t\tchn.dwFlags.flip(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tinc.Negate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSmpLength posInt = chn.position.GetUInt() - chn.nLoopStart;\n\t\t\t\t\t\tSmpLength pingpongLength = loopLength * 2;\n\t\t\t\t\t\tif(sndFile.m_playBehaviour[kITPingPongMode]) pingpongLength--;\n\t\t\t\t\t\tposInt %= pingpongLength;\n\t\t\t\t\t\tbool forward = (posInt < loopLength);\n\t\t\t\t\t\tif(forward)\n\t\t\t\t\t\t\tchn.position.SetInt(chn.nLoopStart + posInt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tchn.position.SetInt(chn.nLoopEnd - (posInt - loopLength));\n\t\t\t\t\t\tif(forward == chn.dwFlags[CHN_PINGPONGFLAG])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchn.dwFlags.flip(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tinc.Negate();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength posInt = chn.position.GetUInt();\n\t\t\t\t\t\tif(posInt >= chn.nLoopEnd + loopLength)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst SmpLength overshoot = posInt - chn.nLoopEnd;\n\t\t\t\t\t\t\tposInt -= (overshoot / loopLength) * loopLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(posInt >= chn.nLoopEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tposInt -= loopLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchn.position.SetInt(posInt);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// Past sample end.\n\t\t\t\t\tstopNote = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(stopNote)\n\t\t{\n\t\t\tchn.Stop();\n\t\t\tchn.nPortamentoDest = 0;\n\t\t}\n\t\tchnSettings[channel].ticksToRender = 0;\n\t}\n};\n\n\n// Get mod length in various cases. Parameters:\n// [in]  adjustMode: See enmGetLengthResetMode for possible adjust modes.\n// [in]  target: Time or position target which should be reached, or no target to get length of the first sub song. Use GetLengthTarget::StartPos to also specify a position from where the seeking should begin.\n// [out] See definition of type GetLengthType for the returned values.\nstd::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMode, GetLengthTarget target)\n{\n\tstd::vector<GetLengthType> results;\n\tGetLengthType retval;\n\tretval.startOrder = target.startOrder;\n\tretval.startRow = target.startRow;\n\n\t// Are we trying to reach a certain pattern position?\n\tconst bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;\n\tconst bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;\n\n\tSEQUENCEINDEX sequence = target.sequence;\n\tif(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();\n\tconst ModSequence &orderList = Order(sequence);\n\n\tGetLengthMemory memory(*this);\n\tCSoundFile::PlayState &playState = *memory.state;\n\t// Temporary visited rows vector (so that GetLength() won't interfere with the player code if the module is playing at the same time)\n\tRowVisitor visitedRows(*this, sequence);\n\n\tplayState.m_nNextRow = playState.m_nRow = target.startRow;\n\tplayState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;\n\n\t// Fast LUTs for commands that are too weird / complicated / whatever to emulate in sample position adjust mode.\n\tstd::bitset<MAX_EFFECTS> forbiddenCommands;\n\tstd::bitset<MAX_VOLCMDS> forbiddenVolCommands;\n\n\tif(adjustSamplePos)\n\t{\n\t\tforbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);\n\t\tforbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);\n\t\tforbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);\n\n\t\t// Optimize away channels for which it's pointless to adjust sample positions\n\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t{\n\t\t\tif(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t}\n\t\tif(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())\n\t\t{\n\t\t\t// If we know where to seek, we can directly rule out any channels on which a new note would be triggered right at the start.\n\t\t\tconst PATTERNINDEX seekPat = orderList[target.pos.order];\n\t\t\tif(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))\n\t\t\t{\n\t\t\t\tconst ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)\n\t\t\t\t{\n\t\t\t\t\tif(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t\t|| (m->IsNote() && !m->IsPortamento()))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If samples are being synced, force them to resync if tick duration changes\n\tuint32 oldTickDuration = 0;\n\n\tfor (;;)\n\t{\n\t\t// Time target reached.\n\t\tif(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tuint32 rowDelay = 0, tickDelay = 0;\n\t\tplayState.m_nRow = playState.m_nNextRow;\n\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\n\t\tif(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t\tif(m_playBehaviour[kFT2LoopE60Restart])\n\t\t\t{\n\t\t\t\tplayState.m_nRow = playState.m_nNextPatStartRow;\n\t\t\t\tplayState.m_nNextPatStartRow = 0;\n\t\t\t}\n\t\t\tplayState.m_nCurrentOrder = ++playState.m_nNextOrder;\n\t\t}\n\n\t\t// Check if pattern is valid\n\t\tplayState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\tbool positionJumpOnThisRow = false;\n\t\tbool patternBreakOnThisRow = false;\n\t\tbool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;\n\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)\n\t\t{\n\t\t\t// Early test: Target is inside +++ or non-existing pattern\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(playState.m_nPattern >= Patterns.Size())\n\t\t{\n\t\t\t// End of song?\n\t\t\tif((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))\n\t\t\t{\n\t\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tplayState.m_nCurrentOrder = orderList.GetRestartPos();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tplayState.m_nCurrentOrder++;\n\t\t\t}\n\t\t\tplayState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder;\n\t\t\tif((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\n\t\t\t\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\t\t\t\t\tplayState.m_nPattern = orderList[playState.m_nCurrentOrder];\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(playState.m_nNextOrder == ORDERINDEX_INVALID)\n\t\t{\n\t\t\t// GetFirstUnvisitedRow failed, so there is nothing more to play\n\t\t\tbreak;\n\t\t}\n\n\t\t// Skip non-existing patterns\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern))\n\t\t{\n\t\t\t// If there isn't even a tune, we should probably stop here.\n\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// Should never happen\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t\tplayState.m_nRow = 0;\n\n\t\t// Check whether target was reached.\n\t\tif(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))\n\t\t{\n\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t{\n\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\tresults.push_back(retval);\n\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\tmemory.Reset();\n\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tretval.endOrder = playState.m_nCurrentOrder;\n\t\tretval.endRow = playState.m_nRow;\n\n\t\t// Update next position\n\t\tplayState.m_nNextRow = playState.m_nRow + 1;\n\n\t\t// Jumped to invalid pattern row?\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t}\n\t\t// New pattern?\n\t\tif(!playState.m_nRow)\n\t\t{\n\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t{\n\t\t\t\tmemory.chnSettings[chn].patLoop = memory.elapsedTime;\n\t\t\t\tmemory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t}\n\t\t}\n\n\t\tModChannel *pChn = playState.Chn;\n\t\t\n\t\t// For various effects, we need to know first how many ticks there are in this row.\n\t\tconst ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tif(p->IsPcNote())\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)\n\t\t\t\t{\n\t\t\t\t\tmemory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();\n\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\tpChn[nChn].rowCommand.Clear();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpChn[nChn].rowCommand = *p;\n\t\t\tswitch(p->command)\n\t\t\t{\n\t\t\tcase CMD_SPEED:\n\t\t\t\tSetSpeed(playState, p->param);\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\t\tif(p->param != 0) SetSpeed(playState, p->param);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0x60)\n\t\t\t\t{\n\t\t\t\t\t// Fine Pattern Delay\n\t\t\t\t\ttickDelay += (p->param & 0x0F);\n\t\t\t\t} else if((p->param & 0xF0) == 0xE0 && !rowDelay)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\tif(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(rowDelay == 0) rowDelay = 1;\n\t\tconst uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;\n\t\tconst uint32 nonRowTicks = numTicks - rowDelay;\n\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\n\t\t\tif (pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->nNewIns = pChn->rowCommand.instr;\n\t\t\t\tpChn->nLastNote = NOTE_NONE;\n\t\t\t\tmemory.chnSettings[nChn].vol = 0xFF;\n\t\t\t}\n\t\t\tif (pChn->rowCommand.IsNote()) pChn->nLastNote = note;\n\n\t\t\t// Update channel panning\n\t\t\tif(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tSAMPLEINDEX smp = 0;\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\tModInstrument *pIns;\n\t\t\t\t\tif(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(pIns->dwFlags[INS_SETPANNING])\n\t\t\t\t\t\t\tpChn->nPan = pIns->nPan;\n\t\t\t\t\t\tif(ModCommand::IsNote(note))\n\t\t\t\t\t\t\tsmp = pIns->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tsmp = pChn->nNewIns;\n\t\t\t\t}\n\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = Samples[smp].nPan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\tif(pChn->rowCommand.vol != 0)\n\t\t\t\t\tpChn->nOldVolParam = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Position Jump\n\t\t\tcase CMD_POSITIONJUMP:\n\t\t\t\tpositionJumpOnThisRow = true;\n\t\t\t\tplayState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));\n\t\t\t\tplayState.m_nNextPatStartRow = 0;  // FT2 E60 bug\n\t\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t\t// Test case: PatternJump.mod\n\t\t\t\tif(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t\t\t\t\tplayState.m_nNextRow = 0;\n\n\t\t\t\tif (adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Pattern Break\n\t\t\tcase CMD_PATTERNBREAK:\n\t\t\t\t{\n\t\t\t\t\tROWINDEX row = PatternBreak(playState, nChn, param);\n\t\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternBreakOnThisRow = true;\n\t\t\t\t\t\tplayState.m_nNextRow = row;\n\n\t\t\t\t\t\tif(!positionJumpOnThisRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Set Tempo\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(!m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\tTEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);\n\t\t\t\t\tif ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Tempo Slide\n\t\t\t\t\t\tTEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);\n\t\t\t\t\t\tif ((tempo.GetInt() & 0xF0) == 0x10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nMusicTempo += tempoDiff;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tempoDiff < playState.m_nMusicTempo)\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo -= tempoDiff;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo.Set(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();\n\t\t\t\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t\t\t\t{\n\t\t\t\t\t\ttempoMax.Set(255);\n\t\t\t\t\t}\n\t\t\t\t\tLimit(playState.m_nMusicTempo, tempoMin, tempoMax);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x90:\n\t\t\t\t\tif(param <= 0x91)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_SURROUND, param == 0x91);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xA0:\n\t\t\t\t\t// High sample offset\n\t\t\t\t\tpChn->nOldHiOffset = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 0xB0:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ST3 has only one global loop memory.\n\t\t\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\t\t\tlastChn = GetNumChannels() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopStart = playState.m_nRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x60:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart; // FT2 E60 bug\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\t\t// ignore high offset in compatible mode\n\t\t\t\tif(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The following calculations are not interesting if we just want to get the song length.\n\t\t\tif (!(adjustMode & eAdjust)) continue;\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Portamento Up/Down\n\t\t\tcase CMD_PORTAMENTOUP:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PORTAMENTODOWN:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Tone-Portamento\n\t\t\tcase CMD_TONEPORTAMENTO:\n\t\t\t\tif (param) pChn->nPortamentoSlide = param << 2;\n\t\t\t\tbreak;\n\t\t\t// Offset\n\t\t\tcase CMD_OFFSET:\n\t\t\t\tif (param) pChn->oldOffset = param << 8;\n\t\t\t\tbreak;\n\t\t\t// Volume Slide\n\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tbreak;\n\t\t\t// Set Volume\n\t\t\tcase CMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = param;\n\t\t\t\tbreak;\n\t\t\t// Global Volume\n\t\t\tcase CMD_GLOBALVOLUME:\n\t\t\t\tif(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;\n\t\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values\n\t\t\t\tif(param <= 128)\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = param * 2;\n\t\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = 256;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Global Volume Slide\n\t\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 16. Global volume slide params are stored per channel (FT2/IT)\n\t\t\t\t\tif (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;\n\t\t\t\t}\n\t\t\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param << 1;\n\t\t\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param;\n\t\t\t\t} else if (param & 0xF0)\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tparam <<= 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param * nonRowTicks;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param * nonRowTicks;\n\t\t\t\t}\n\t\t\t\tLimit(playState.m_nGlobalVolume, 0, 256);\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLUME:\n\t\t\t\tif (param <= 64) pChn->nGlobalVol = param;\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\t\t\t\t\tint32 volume = pChn->nGlobalVol;\n\t\t\t\t\tif((param & 0x0F) == 0x0F && (param & 0xF0))\n\t\t\t\t\t\tvolume += (param >> 4);\t\t// Fine Up\n\t\t\t\t\telse if((param & 0xF0) == 0xF0 && (param & 0x0F))\n\t\t\t\t\t\tvolume -= (param & 0x0F);\t// Fine Down\n\t\t\t\t\telse if(param & 0x0F)\t\t\t// Down\n\t\t\t\t\t\tvolume -= (param & 0x0F) * nonRowTicks;\n\t\t\t\t\telse\t\t\t\t\t\t\t// Up\n\t\t\t\t\t\tvolume += ((param & 0xF0) >> 4) * nonRowTicks;\n\t\t\t\t\tLimit(volume, 0, 64);\n\t\t\t\t\tpChn->nGlobalVol = volume;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANNING8:\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t\tbreak;\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif(param < 0x10)\n\t\t\t\t{\n\t\t\t\t\t// LED filter\n\t\t\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((param & 0xF0) == 0x80)\n\t\t\t\t{\n\t\t\t\t\tPanning(pChn, (param & 0x0F), Pan4bit);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tparam = 0;\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_VIBRATO:\n\t\t\t\tVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\t\tFineVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tTremolo(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tPanbrello(pChn, param);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_PANNING:\n\t\t\t\tPanning(pChn, pChn->rowCommand.vol, Pan6bit);\n\t\t\t\tbreak;\n\n\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\tpChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;\n\t\t\t\telse\n\t\t\t\t\tVibrato(pChn, pChn->rowCommand.vol << 4);\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\tVibrato(pChn, pChn->rowCommand.vol);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Process vibrato / tremolo / panbrello\n\t\t\tswitch(pChn->rowCommand.command)\n\t\t\t{\n\t\t\tcase CMD_VIBRATO:\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nVibratoSpeed * vibTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nVibratoPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nTremoloSpeed * tremTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nTremoloPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\t// Panbrello effect is permanent in compatible mode, so actually apply panbrello for the last tick of this row\n\t\t\t\t\tpChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));\n\t\t\t\t\tProcessPanbrello(pChn);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Interpret F00 effect in XM files as \"stop song\"\n\t\tif(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tplayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tif(Patterns[playState.m_nPattern].GetOverrideSignature())\n\t\t{\n\t\t\tplayState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();\n\t\t}\n\n\t\tconst uint32 tickDuration = GetTickDuration(playState);\n\t\tconst uint32 rowDuration = tickDuration * numTicks;\n\t\tmemory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);\n\t\tplayState.m_lTotalSampleCount += rowDuration;\n\n\t\tif(adjustSamplePos)\n\t\t{\n\t\t\t// Super experimental and dirty sample seeking\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)\n\t\t\t{\n\t\t\t\tif(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32 startTick = 0;\n\t\t\t\tconst ModCommand &m = pChn->rowCommand;\n\t\t\t\tuint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;\n\t\t\t\tbool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;\n\t\t\t\tbool stopNote = patternLoopStartedOnThisRow;\t// It's too much trouble to keep those pattern loops in sync...\n\n\t\t\t\tif(m.instr) pChn->proTrackerOffset = 0;\n\t\t\t\tif(m.IsNote())\n\t\t\t\t{\n\t\t\t\t\tif(porta && memory.chnSettings[nChn].incChanged)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a portamento, the current channel increment mustn't be 0 in NoteChange()\n\t\t\t\t\t\tpChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);\n\t\t\t\t\t}\n\t\t\t\t\tint32 setPan = pChn->nPan;\n\t\t\t\t\tpChn->nNewNote = pChn->nLastNote;\n\t\t\t\t\tif(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);\n\t\t\t\t\tNoteChange(pChn, m.note, porta);\n\t\t\t\t\tmemory.chnSettings[nChn].incChanged = true;\n\n\t\t\t\t\tif((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramLo;\n\t\t\t\t\t} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramHi;\n\t\t\t\t\t}\n\t\t\t\t\tif(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!porta) memory.chnSettings[nChn].ticksToRender = 0;\n\n\t\t\t\t\t// Panning commands have to be re-applied after a note change with potential pan change.\n\t\t\t\t\tif(m.command == CMD_PANNING8\n\t\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)\n\t\t\t\t\t\t|| m.volcmd == VOLCMD_PANNING)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nPan = setPan;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.command == CMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool isExtended = false;\n\t\t\t\t\t\tSmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);\n\t\t\t\t\t\tif(!isExtended)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset <<= 8;\n\t\t\t\t\t\t\tif(offset == 0) offset = pChn->oldOffset;\n\t\t\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t} else if(m.command == CMD_OFFSETPERCENTAGE)\n\t\t\t\t\t{\n\t\t\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));\n\t\t\t\t\t} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\tReverseSampleOffset(*pChn, m.param);\n\t\t\t\t\t\tstartTick = playState.m_nMusicSpeed - 1;\n\t\t\t\t\t} else if(m.volcmd == VOLCMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\t\tif(m.vol == 0)\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];\n\t\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)\n\t\t\t\t\t|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))\n\t\t\t\t{\n\t\t\t\t\tstopNote = true;\n\t\t\t\t}\n\n\t\t\t\tif(m.command == CMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.param * 4;\n\t\t\t\t} else if(m.volcmd == VOLCMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.vol * 4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pChn->pModSample && !stopNote)\n\t\t\t\t{\n\t\t\t\t\t// Check if we don't want to emulate some effect and thus stop processing.\n\t\t\t\t\tif(m.command < MAX_EFFECTS)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(forbiddenCommands[m.command])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t} else if(m.command == CMD_MODCMDEX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Special case: Slides using extended commands\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])\n\t\t\t\t\t{\n\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(stopNote)\n\t\t\t\t{\n\t\t\t\t\tpChn->Stop();\n\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(oldTickDuration != tickDuration && oldTickDuration != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(m.command)\n\t\t\t\t\t{\n\t\t\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\t\t\tif(m.param || (GetType() != MOD_TYPE_MOD))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, m.param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_MODCMDEX:\n\t\t\t\t\t\tif((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\tcase 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\t\t\tif(m.param == 0x9E)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Play forward\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t} else if(m.param == 0x9F)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Reverse\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tif(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((m.param & 0xF0) == 0x70)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO\n\t\t\t\t\t\t\t//ExtendedS3MCommands(nChn, param);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\tswitch(m.volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\t\tModCommand::VOL vol = m.vol;\n\t\t\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(m.volcmd == VOLCMD_VOLSLIDEUP)\n\t\t\t\t\t\t\t\tvol <<= 4;\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, vol);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(porta)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Portamento needs immediate syncing, as the pitch changes on each tick\n\t\t\t\t\t\tuint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += numTicks;\n\t\t\t\t\t\tmemory.RenderChannel(nChn, tickDuration, portaTick);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += (numTicks - startTick);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toldTickDuration = tickDuration;\n\n\t\t// Pattern loop is not executed in FT2 if there are any position jump or pattern break commands on the same row.\n\t\t// Pattern loop is not executed in IT if there are any position jump commands on the same row.\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif(patternLoopEndedOnThisRow\n\t\t\t&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))\n\t\t\t&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))\n\t\t{\n\t\t\tstd::map<double, int> startTimes;\n\t\t\t// This is really just a simple estimation for nested pattern loops. It should handle cases correctly where all parallel loops start and end on the same row.\n\t\t\t// If one of them starts or ends \"in between\", it will most likely calculate a wrong duration.\n\t\t\t// For S3M files, it's also way off.\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t{\n\t\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\t\tif((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)\n\t\t\t\t\t|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))\n\t\t\t\t{\n\t\t\t\t\tconst double start = memory.chnSettings[nChn].patLoop;\n\t\t\t\t\tif(!startTimes[start]) startTimes[start] = 1;\n\t\t\t\t\tstartTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const auto &i : startTimes)\n\t\t\t{\n\t\t\t\tmemory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif(memory.chnSettings[nChn].patLoop == i.first)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);\n\t\t\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(GetType() == MOD_TYPE_IT)\n\t\t\t{\n\t\t\t\t// IT pattern loop start row update - at the end of a pattern loop, set pattern loop start to next row (for upcoming pattern loops with missing SB0)\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t\t\t{\n\t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now advance the sample positions for sample seeking on channels that are still playing\n\tif(adjustSamplePos)\n\t{\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t{\n\t\t\tif(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t{\n\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t{\n\t\tretval.lastOrder = playState.m_nCurrentOrder;\n\t\tretval.lastRow = playState.m_nRow;\n\t}\n\tretval.duration = memory.elapsedTime;\n\tresults.push_back(retval);\n\n\t// Store final variables\n\tif(adjustMode & eAdjust)\n\t{\n\t\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t\t{\n\t\t\t// Target found, or there is no target (i.e. play whole song)...\n\t\t\tm_PlayState = std::move(playState);\n\t\t\tm_PlayState.m_nNextRow = m_PlayState.m_nRow;\n\t\t\tm_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;\n\t\t\tm_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;\n\t\t\tm_PlayState.m_bPositionChanged = true;\n\t\t\tfor(CHANNELINDEX n = 0; n < GetNumChannels(); n++)\n\t\t\t{\n\t\t\t\tif(m_PlayState.Chn[n].nLastNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;\n\t\t\t\t}\n\t\t\t\tif(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\t// If there were any PC events, update plugin parameters to their latest value.\n\t\t\tstd::bitset<MAX_MIXPLUGINS> plugSetProgram;\n\t\t\tfor(const auto &param : memory.plugParams)\n\t\t\t{\n\t\t\t\tPLUGINDEX plug = param.first.first - 1;\n\t\t\t\tIMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;\n\t\t\t\tif(plugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!plugSetProgram[plug])\n\t\t\t\t\t{\n\t\t\t\t\t\t// Used for bridged plugins to avoid sending out individual messages for each parameter.\n\t\t\t\t\t\tplugSetProgram.set(plug);\n\t\t\t\t\t\tplugin->BeginSetProgram();\n\t\t\t\t\t}\n\t\t\t\t\tplugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(plugSetProgram.any())\n\t\t\t{\n\t\t\t\tfor(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)\n\t\t\t\t{\n\t\t\t\t\tif(plugSetProgram[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MixPlugins[i].pMixPlugin->EndSetProgram();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t} else if(adjustMode != eAdjustOnSuccess)\n\t\t{\n\t\t\t// Target not found (e.g. when jumping to a hidden sub song), reset global variables...\n\t\t\tm_PlayState.m_nMusicSpeed = m_nDefaultSpeed;\n\t\t\tm_PlayState.m_nMusicTempo = m_nDefaultTempo;\n\t\t\tm_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;\n\t\t}\n\t\t// When adjusting the playback status, we will also want to update the visited rows vector according to the current position.\n\t\tif(sequence != Order.GetCurrentSequenceIndex())\n\t\t{\n\t\t\tOrder.SetSequence(sequence);\n\t\t}\n\t\tvisitedSongRows.Set(visitedRows);\n\t}\n\n\treturn results;\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n// Effects\n\n// Change sample or instrument number.\nvoid CSoundFile::InstrumentChange(ModChannel *pChn, uint32 instr, bool bPorta, bool bUpdVol, bool bResetEnv) const\n{\n\tconst ModInstrument *pIns = instr <= GetNumInstruments() ? Instruments[instr] : nullptr;\n\tconst ModSample *pSmp = &Samples[instr];\n\tModCommand::NOTE note = pChn->nNewNote;\n\n\tif(note == NOTE_NONE && m_playBehaviour[kITInstrWithoutNote]) return;\n\n\tif(pIns != nullptr && ModCommand::IsNote(note))\n\t{\n\t\t// Impulse Tracker ignores empty slots.\n\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\tif(pIns->Keyboard[note - NOTE_MIN] == 0 && m_playBehaviour[kITEmptyNoteMapSlot] && !pIns->HasValidMIDIChannel())\n\t\t{\n\t\t\tpChn->pModInstrument = pIns;\n\t\t\treturn;\n\t\t}\n\n\t\tif(pIns->NoteMap[note - NOTE_MIN] > NOTE_MAX) return;\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tpSmp = ((n) && (n < MAX_SAMPLES)) ? &Samples[n] : nullptr;\n\t} else if(GetNumInstruments())\n\t{\n\t\t// No valid instrument, or not a valid note.\n\t\tif (note >= NOTE_MIN_SPECIAL) return;\n\t\tif(m_playBehaviour[kITEmptyNoteMapSlot] && (pIns == nullptr || !pIns->HasValidMIDIChannel()))\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\tpChn->pModInstrument = nullptr;\n\t\t\tpChn->nNewIns = 0;\n\t\t\treturn;\n\t\t}\n\t\tpSmp = nullptr;\n\t}\n\n\tbool returnAfterVolumeAdjust = false;\n\n\t// instrumentChanged is used for IT carry-on env option\n\tbool instrumentChanged = (pIns != pChn->pModInstrument);\n\tconst bool sampleChanged = (pChn->pModSample != nullptr) && (pSmp != pChn->pModSample);\n\n\tconst bool newTuning = (GetType() == MOD_TYPE_MPT && pIns && pIns->pTuning);\n\t// Playback behavior change for MPT: With portamento don't change sample if it is in\n\t// the same instrument as previous sample.\n\tif(bPorta && newTuning && pIns == pChn->pModInstrument && sampleChanged)\n\t\treturn;\n\n\tif(sampleChanged && bPorta)\n\t{\n\t\t// IT compatibility: No sample change (also within multi-sample instruments) during portamento when using Compatible Gxx.\n\t\t// Test case: PortaInsNumCompat.it, PortaSampleCompat.it, PortaCutCompat.it\n\t\tif(m_playBehaviour[kITPortamentoInstrument] && m_SongFlags[SONG_ITCOMPATGXX] && !pChn->increment.IsZero())\n\t\t{\n\t\t\tpSmp = pChn->pModSample;\n\t\t}\n\n\t\t// Special XM hack (also applies to MOD / S3M, except when playing IT-style S3Ms, such as k_vision.s3m)\n\t\t// Test case: PortaSmpChange.mod, PortaSmpChange.s3m\n\t\tif((!instrumentChanged && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)) && pIns)\n\t\t\t|| (GetType() == MOD_TYPE_PLM)\n\t\t\t|| (GetType() == MOD_TYPE_MOD && pChn->IsSamplePlaying())\n\t\t\t|| m_playBehaviour[kST3PortaSampleChange])\n\t\t{\n\t\t\t// FT2 doesn't change the sample in this case,\n\t\t\t// but still uses the sample info from the old one (bug?)\n\t\t\treturnAfterVolumeAdjust = true;\n\t\t}\n\t}\n\t// IT compatibility: A lone instrument number should only reset sample properties to those of the corresponding sample in instrument mode.\n\t// C#5 01 ... <-- sample 1\n\t// C-5 .. g02 <-- sample 2\n\t// ... 01 ... <-- still sample 1, but with properties of sample 2\n\t// In the above example, no sample change happens on the second row. In the third row, sample 1 keeps playing but with the\n\t// volume and panning properties of sample 2.\n\t// Test case: InstrAfterMultisamplePorta.it\n\tif(m_nInstruments && !instrumentChanged && sampleChanged && pChn->pCurrentSample != nullptr && m_playBehaviour[kITMultiSampleInstrumentNumber] && !pChn->rowCommand.IsNote())\n\t{\n\t\treturnAfterVolumeAdjust = true;\n\t}\n\n\t// IT Compatibility: Envelope pickup after SCx cut (but don't do this when working with plugins, or else envelope carry stops working)\n\t// Test case: cut-carry.it\n\tif(!pChn->IsSamplePlaying() && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && (!pIns || !pIns->HasValidMIDIChannel()))\n\t{\n\t\tinstrumentChanged = true;\n\t}\n\n\t// FT2 compatibility: new instrument + portamento = ignore new instrument number, but reload old instrument settings (the world of XM is upside down...)\n\t// And this does *not* happen if volume column portamento is used together with note delay... (handled in ProcessEffects(), where all the other note delay stuff is.)\n\t// Test case: porta-delay.xm\n\tif(instrumentChanged && bPorta && m_playBehaviour[kFT2PortaIgnoreInstr] && (pChn->pModInstrument != nullptr || pChn->pModSample != nullptr))\n\t{\n\t\tpIns = pChn->pModInstrument;\n\t\tpSmp = pChn->pModSample;\n\t\tinstrumentChanged = false;\n\t} else\n\t{\n\t\tpChn->pModInstrument = pIns;\n\t}\n\n\t// Update Volume\n\tif (bUpdVol && (!(GetType() & (MOD_TYPE_MOD | MOD_TYPE_S3M)) || ((pSmp != nullptr && pSmp->HasSampleData()) || pChn->HasMIDIOutput())))\n\t{\n\t\tif(pSmp)\n\t\t{\n\t\t\tif(!pSmp->uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\tpChn->nVolume = pSmp->nVolume;\n\t\t} else if(pIns && pIns->nMixPlug)\n\t\t{\n\t\t\tpChn->nVolume = pChn->GetVSTVolume();\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolume = 0;\n\t\t}\n\t}\n\n\tif(returnAfterVolumeAdjust && sampleChanged && m_playBehaviour[kMODSampleSwap] && pSmp != nullptr)\n\t{\n\t\t// ProTracker applies new instrument's finetune but keeps the old sample playing.\n\t\t// Test case: PortaSwapPT.mod\n\t\tpChn->nFineTune = pSmp->nFineTune;\n\t}\n\n\tif(returnAfterVolumeAdjust) return;\n\n\n\t// Instrument adjust\n\tpChn->nNewIns = 0;\n\n\t// IT Compatiblity: NNA is reset on every note change, not every instrument change (fixes s7xinsnum.it).\n\tif (pIns && ((!m_playBehaviour[kITNNAReset] && pSmp) || pIns->nMixPlug))\n\t\tpChn->nNNA = pIns->nNNA;\n\n\t// Update volume\n\tpChn->UpdateInstrumentVolume(pSmp, pIns);\n\n\t// Update panning\n\t// FT2 compatibility: Only reset panning on instrument numbers, not notes (bUpdVol condition)\n\t// Test case: PanMemory.xm\n\t// IT compatibility: Sample and instrument panning is only applied on note change, not instrument change\n\t// Test case: PanReset.it\n\tif((bUpdVol || !(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))) && !m_playBehaviour[kITPanningReset])\n\t{\n\t\tApplyInstrumentPanning(pChn, pIns, pSmp);\n\t}\n\n\t// Reset envelopes\n\tif(bResetEnv)\n\t{\n\t\t// Blurb by Storlek (from the SchismTracker code):\n\t\t// Conditions experimentally determined to cause envelope reset in Impulse Tracker:\n\t\t// - no note currently playing (of course)\n\t\t// - note given, no portamento\n\t\t// - instrument number given, portamento, compat gxx enabled\n\t\t// - instrument number given, no portamento, after keyoff, old effects enabled\n\t\t// If someone can enlighten me to what the logic really is here, I'd appreciate it.\n\t\t// Seems like it's just a total mess though, probably to get XMs to play right.\n\n\t\tbool reset, resetAlways;\n\n\t\t// IT Compatibility: Envelope reset\n\t\t// Test case: EnvReset.it\n\t\tif(m_playBehaviour[kITEnvelopeReset])\n\t\t{\n\t\t\tconst bool insNumber = (instr != 0);\n\t\t\treset = (!pChn->nLength\n\t\t\t\t|| (insNumber && bPorta && m_SongFlags[SONG_ITCOMPATGXX])\n\t\t\t\t|| (insNumber && !bPorta && pChn->dwFlags[CHN_NOTEFADE | CHN_KEYOFF] && m_SongFlags[SONG_ITOLDEFFECTS]));\n\t\t\t// NOTE: IT2.14 with SB/GUS/etc. output is different. We are going after IT's WAV writer here.\n\t\t\t// For SB/GUS/etc. emulation, envelope carry should only apply when the NNA isn't set to \"Note Cut\".\n\t\t\t// Test case: CarryNNA.it\n\t\t\tresetAlways = (!pChn->nFadeOutVol || instrumentChanged || pChn->dwFlags[CHN_KEYOFF]);\n\t\t} else\n\t\t{\n\t\t\treset = (!bPorta || !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) || m_SongFlags[SONG_ITCOMPATGXX]\n\t\t\t\t|| !pChn->nLength || (pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol));\n\t\t\tresetAlways = !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) || instrumentChanged || pIns == nullptr || pChn->dwFlags[CHN_KEYOFF | CHN_NOTEFADE];\n\t\t}\n\n\t\tif(reset)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\tif(pIns != nullptr)\n\t\t\t{\n\t\t\t\tif(resetAlways)\n\t\t\t\t{\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(!pIns->VolEnv.dwFlags[ENV_CARRY]) pChn->VolEnv.Reset();\n\t\t\t\t\tif(!pIns->PanEnv.dwFlags[ENV_CARRY]) pChn->PanEnv.Reset();\n\t\t\t\t\tif(!pIns->PitchEnv.dwFlags[ENV_CARRY]) pChn->PitchEnv.Reset();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// IT Compatibility: Autovibrato reset\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t{\n\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t}\n\t\t} else if(pIns != nullptr && !pIns->VolEnv.dwFlags[ENV_ENABLED])\n\t\t{\n\t\t\tif(m_playBehaviour[kITPortamentoInstrument])\n\t\t\t{\n\t\t\t\tpChn->VolEnv.Reset();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t}\n\t\t}\n\t}\n\t// Invalid sample ?\n\tif(pSmp == nullptr && (pIns == nullptr || !pIns->HasValidMIDIChannel()))\n\t{\n\t\tpChn->pModSample = nullptr;\n\t\tpChn->nInsVol = 0;\n\t\treturn;\n\t}\n\n\t// Tone-Portamento doesn't reset the pingpong direction flag\n\tif(bPorta && pSmp == pChn->pModSample && pSmp != nullptr)\n\t{\n\t\t// If channel length is 0, we cut a previous sample using SCx. In that case, we have to update sample length, loop points, etc...\n\t\tif(GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT) && pChn->nLength != 0) return;\n\t\tpChn->dwFlags.reset(CHN_KEYOFF | CHN_NOTEFADE);\n\t\tpChn->dwFlags = (pChn->dwFlags & (CHN_CHANNELFLAGS | CHN_PINGPONGFLAG));\n\t} else //if(!instrumentChanged || pChn->rowCommand.instr != 0 || !IsCompatibleMode(TRK_FASTTRACKER2))\t// SampleChange.xm?\n\t{\n\t\tpChn->dwFlags.reset(CHN_KEYOFF | CHN_NOTEFADE);\n\n\t\t// IT compatibility tentative fix: Don't change bidi loop direction when\n\t\t// no sample nor instrument is changed.\n\t\tif((m_playBehaviour[kITPingPongNoReset] || !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) && pSmp == pChn->pModSample && !instrumentChanged)\n\t\t\tpChn->dwFlags = (pChn->dwFlags & (CHN_CHANNELFLAGS | CHN_PINGPONGFLAG));\n\t\telse\n\t\t\tpChn->dwFlags = (pChn->dwFlags & CHN_CHANNELFLAGS);\n\n\t\tif(pIns)\n\t\t{\n\t\t\t// Copy envelope flags (we actually only need the \"enabled\" and \"pitch\" flag)\n\t\t\tpChn->VolEnv.flags = pIns->VolEnv.dwFlags;\n\t\t\tpChn->PanEnv.flags = pIns->PanEnv.dwFlags;\n\t\t\tpChn->PitchEnv.flags = pIns->PitchEnv.dwFlags;\n\n\t\t\t// A cutoff frequency of 0 should not be reset just because the filter envelope is enabled.\n\t\t\t// Test case: FilterEnvReset.it\n\t\t\tif((pIns->PitchEnv.dwFlags & (ENV_ENABLED | ENV_FILTER)) == (ENV_ENABLED | ENV_FILTER) && !m_playBehaviour[kITFilterBehaviour])\n\t\t\t{\n\t\t\t\tif(!pChn->nCutOff) pChn->nCutOff = 0x7F;\n\t\t\t}\n\n\t\t\tif(pIns->IsCutoffEnabled()) pChn->nCutOff = pIns->GetCutoff();\n\t\t\tif(pIns->IsResonanceEnabled()) pChn->nResonance = pIns->GetResonance();\n\t\t}\n\t}\n\n\tif(pSmp == nullptr)\n\t{\n\t\tpChn->pModSample = nullptr;\n\t\tpChn->nLength = 0;\n\t\treturn;\n\t}\n\n\tif(bPorta && pChn->nLength == 0 && (m_playBehaviour[kFT2PortaNoNote] || m_playBehaviour[kITPortaNoNote]))\n\t{\n\t\t// IT/FT2 compatibility: If the note just stopped on the previous tick, prevent it from restarting.\n\t\t// Test cases: PortaJustStoppedNote.xm, PortaJustStoppedNote.it\n\t\tpChn->increment.Set(0);\n\t}\n\n\tpChn->pModSample = pSmp;\n\tpChn->nLength = pSmp->nLength;\n\tpChn->nLoopStart = pSmp->nLoopStart;\n\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t// ProTracker \"oneshot\" loops (if loop start is 0, play the whole sample once and then repeat until loop end)\n\tif(m_playBehaviour[kMODOneShotLoops] && pChn->nLoopStart == 0) pChn->nLoopEnd = pSmp->nLength;\n\tpChn->dwFlags |= (pSmp->uFlags & (CHN_SAMPLEFLAGS | CHN_SURROUND));\n\n\t// IT Compatibility: Autovibrato reset\n\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t{\n\t\tpChn->nAutoVibDepth = 0;\n\t\tpChn->nAutoVibPos = 0;\n\t}\n\n\tif(newTuning)\n\t{\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\t\tpChn->m_CalculateFreq = true;\n\t\tpChn->nFineTune = 0;\n\t} else if(!bPorta || sampleChanged || !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t{\n\t\t// Don't reset finetune changed by \"set finetune\" command.\n\t\t// Test case: finetune.xm, finetune.mod\n\t\t// But *do* change the finetune if we switch to a different sample, to fix\n\t\t// Miranda`s axe by Jamson (jam007.xm) - this file doesn't use compatible play mode,\n\t\t// so we may want to use IsCompatibleMode instead if further problems arise.\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\t\tpChn->nFineTune = pSmp->nFineTune;\n\t}\n\n\n\tpChn->nTranspose = pSmp->RelativeTone;\n\n\t// FT2 compatibility: Don't reset portamento target with new instrument numbers.\n\t// Test case: Porta-Pickup.xm\n\t// ProTracker does the same.\n\t// Test case: PortaTarget.mod\n\tif(!m_playBehaviour[kFT2PortaTargetNoReset] && GetType() != MOD_TYPE_MOD)\n\t{\n\t\tpChn->nPortamentoDest = 0;\n\t}\n\tpChn->m_PortamentoFineSteps = 0;\n\n\tif(pChn->dwFlags[CHN_SUSTAINLOOP])\n\t{\n\t\tpChn->nLoopStart = pSmp->nSustainStart;\n\t\tpChn->nLoopEnd = pSmp->nSustainEnd;\n\t\tif(pChn->dwFlags[CHN_PINGPONGSUSTAIN]) pChn->dwFlags.set(CHN_PINGPONGLOOP);\n\t\tpChn->dwFlags.set(CHN_LOOP);\n\t}\n\tif(pChn->dwFlags[CHN_LOOP] && pChn->nLoopEnd < pChn->nLength) pChn->nLength = pChn->nLoopEnd;\n\n\t// Fix sample position on instrument change. This is needed for IT \"on the fly\" sample change.\n\t// XXX is this actually called? In ProcessEffects(), a note-on effect is emulated if there's an on the fly sample change!\n\tif(pChn->position.GetUInt() >= pChn->nLength)\n\t{\n\t\tif((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t{\n\t\t\tpChn->position.Set(0);\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::NoteChange(ModChannel *pChn, int note, bool bPorta, bool bResetEnv, bool bManual) const\n{\n\tif (note < NOTE_MIN) return;\n\tconst ModSample *pSmp = pChn->pModSample;\n\tconst ModInstrument *pIns = pChn->pModInstrument;\n\n\tconst bool newTuning = (GetType() == MOD_TYPE_MPT && pIns != nullptr && pIns->pTuning);\n\t// save the note that's actually used, as it's necessary to properly calculate PPS and stuff\n\tconst int realnote = note;\n\n\tif((pIns) && (note - NOTE_MIN < (int)CountOf(pIns->Keyboard)))\n\t{\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tif((n) && (n < MAX_SAMPLES))\n\t\t{\n\t\t\tpSmp = &Samples[n];\n\t\t} else if(m_playBehaviour[kITEmptyNoteMapSlot] && !pChn->HasMIDIOutput())\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\treturn;\n\t\t}\n\t\tnote = pIns->NoteMap[note - NOTE_MIN];\n\t}\n\t// Key Off\n\tif(note > NOTE_MAX)\n\t{\n\t\t// Key Off (+ Invalid Note for XM - TODO is this correct?)\n\t\tif(note == NOTE_KEYOFF || !(GetType() & (MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\t{\n\t\t\tKeyOff(pChn);\n\t\t} else // Invalid Note -> Note Fade\n\t\t{\n\t\t\tif(/*note == NOTE_FADE && */ GetNumInstruments())\n\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t}\n\n\t\t// Note Cut\n\t\tif (note == NOTE_NOTECUT)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t// IT compatibility: Stopping sample playback by setting sample increment to 0 rather than volume\n\t\t\t// Test case: NoteOffInstr.it\n\t\t\tif ((!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) || (m_nInstruments != 0 && !m_playBehaviour[kITInstrWithNoteOff])) pChn->nVolume = 0;\n\t\t\tif(m_playBehaviour[kITInstrWithNoteOff]) pChn->increment.Set(0);\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t}\n\n\t\t// IT compatibility tentative fix: Clear channel note memory.\n\t\tif(m_playBehaviour[kITClearOldNoteAfterCut])\n\t\t{\n\t\t\tpChn->nNote = pChn->nNewNote = NOTE_NONE;\n\t\t}\n\t\treturn;\n\t}\n\n\tif(newTuning)\n\t{\n\t\tif(!bPorta || pChn->nNote == NOTE_NONE)\n\t\t\tpChn->nPortamentoDest = 0;\n\t\telse\n\t\t{\n\t\t\tpChn->nPortamentoDest = pIns->pTuning->GetStepDistance(pChn->nNote, pChn->m_PortamentoFineSteps, static_cast<Tuning::NOTEINDEXTYPE>(note), 0);\n\t\t\t//Here pChn->nPortamentoDest means 'steps to slide'.\n\t\t\tpChn->m_PortamentoFineSteps = -pChn->nPortamentoDest;\n\t\t}\n\t}\n\n\tif(!bPorta && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MED | MOD_TYPE_MT2)))\n\t{\n\t\tif(pSmp)\n\t\t{\n\t\t\tpChn->nTranspose = pSmp->RelativeTone;\n\t\t\tpChn->nFineTune = pSmp->nFineTune;\n\t\t}\n\t}\n\t// IT Compatibility: Update multisample instruments frequency even if instrument is not specified (fixes the guitars in spx-shuttledeparture.it)\n\t// Test case: freqreset-noins.it\n\tif(!bPorta && pSmp && m_playBehaviour[kITMultiSampleBehaviour])\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\n\tif(bPorta && !pChn->IsSamplePlaying())\n\t{\n\t\tif(m_playBehaviour[kFT2PortaNoNote])\n\t\t{\n\t\t\t// FT2 Compatibility: Ignore notes with portamento if there was no note playing.\n\t\t\t// Test case: 3xx-no-old-samp.xm\n\t\t\tpChn->nPeriod = 0;\n\t\t\treturn;\n\t\t} else if(m_playBehaviour[kITPortaNoNote])\n\t\t{\n\t\t\t// IT Compatibility: Ignore portamento command if no note was playing (e.g. if a previous note has faded out).\n\t\t\t// Test case: Fade-Porta.it\n\t\t\tbPorta = false;\n\t\t}\n\t}\n\n\tif(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2|MOD_TYPE_MED|MOD_TYPE_MOD))\n\t{\n\t\tnote += pChn->nTranspose;\n\t\t// RealNote = PatternNote + RelativeTone; (0..118, 0 = C-0, 118 = A#9)\n\t\tLimit(note, NOTE_MIN + 11, NOTE_MIN + 130);\t// 119 possible notes\n\t} else\n\t{\n\t\tLimit(note, NOTE_MIN, NOTE_MAX);\n\t}\n\tif(m_playBehaviour[kITRealNoteMapping])\n\t{\n\t\t// need to memorize the original note for various effects (e.g. PPS)\n\t\tpChn->nNote = static_cast<ModCommand::NOTE>(Clamp(realnote, NOTE_MIN, NOTE_MAX));\n\t} else\n\t{\n\t\tpChn->nNote = static_cast<ModCommand::NOTE>(note);\n\t}\n\tpChn->m_CalculateFreq = true;\n\n\tif ((!bPorta) || (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\tpChn->nNewIns = 0;\n\n\tuint32 period = GetPeriodFromNote(note, pChn->nFineTune, pChn->nC5Speed);\n\tpChn->nPanbrelloOffset = 0;\n\n\t// IT compatibility: Sample and instrument panning is only applied on note change, not instrument change\n\t// Test case: PanReset.it\n\tif(m_playBehaviour[kITPanningReset]) ApplyInstrumentPanning(pChn, pIns, pSmp);\n\n\tif(bResetEnv && !bPorta)\n\t{\n\t\tpChn->nVolSwing = pChn->nPanSwing = 0;\n\t\tpChn->nResSwing = pChn->nCutSwing = 0;\n\t\tif(pIns)\n\t\t{\n\t\t\t// IT Compatiblity: NNA is reset on every note change, not every instrument change (fixes spx-farspacedance.it).\n\t\t\tif(m_playBehaviour[kITNNAReset]) pChn->nNNA = pIns->nNNA;\n\n\t\t\tif(!pIns->VolEnv.dwFlags[ENV_CARRY]) pChn->VolEnv.Reset();\n\t\t\tif(!pIns->PanEnv.dwFlags[ENV_CARRY]) pChn->PanEnv.Reset();\n\t\t\tif(!pIns->PitchEnv.dwFlags[ENV_CARRY]) pChn->PitchEnv.Reset();\n\n\t\t\t// Volume Swing\n\t\t\tif(pIns->nVolSwing)\n\t\t\t{\n\t\t\t\tpChn->nVolSwing = static_cast<int16>(((mpt::random<int8>(AccessPRNG()) * pIns->nVolSwing) / 64 + 1) * (m_playBehaviour[kITSwingBehaviour] ? pChn->nInsVol : ((pChn->nVolume + 1) / 2)) / 199);\n\t\t\t}\n\t\t\t// Pan Swing\n\t\t\tif(pIns->nPanSwing)\n\t\t\t{\n\t\t\t\tpChn->nPanSwing = static_cast<int16>(((mpt::random<int8>(AccessPRNG()) * pIns->nPanSwing * 4) / 128));\n\t\t\t\tif(!m_playBehaviour[kITSwingBehaviour])\n\t\t\t\t{\n\t\t\t\t\tpChn->nRestorePanOnNewNote = static_cast<int16>(pChn->nPan + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cutoff Swing\n\t\t\tif(pIns->nCutSwing)\n\t\t\t{\n\t\t\t\tint32 d = ((int32)pIns->nCutSwing * (int32)(static_cast<int32>(mpt::random<int8>(AccessPRNG())) + 1)) / 128;\n\t\t\t\tpChn->nCutSwing = static_cast<int16>((d * pChn->nCutOff + 1) / 128);\n\t\t\t\tpChn->nRestoreCutoffOnNewNote = pChn->nCutOff + 1;\n\t\t\t}\n\t\t\t// Resonance Swing\n\t\t\tif(pIns->nResSwing)\n\t\t\t{\n\t\t\t\tint32 d = ((int32)pIns->nResSwing * (int32)(static_cast<int32>(mpt::random<int8>(AccessPRNG())) + 1)) / 128;\n\t\t\t\tpChn->nResSwing = static_cast<int16>((d * pChn->nResonance + 1) / 128);\n\t\t\t\tpChn->nRestoreResonanceOnNewNote = pChn->nResonance + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!pSmp) return;\n\tif(period)\n\t{\n\t\tif((!bPorta) || (!pChn->nPeriod)) pChn->nPeriod = period;\n\t\tif(!newTuning)\n\t\t{\n\t\t\t// FT2 compatibility: Don't reset portamento target with new notes.\n\t\t\t// Test case: Porta-Pickup.xm\n\t\t\t// ProTracker does the same.\n\t\t\t// Test case: PortaTarget.mod\n\t\t\t// IT compatibility: Portamento target is completely cleared with new notes.\n\t\t\t// Test case: PortaReset.it\n\t\t\tif(bPorta || !(m_playBehaviour[kFT2PortaTargetNoReset] || m_playBehaviour[kITClearPortaTarget] || GetType() == MOD_TYPE_MOD))\n\t\t\t{\n\t\t\t\tpChn->nPortamentoDest = period;\n\t\t\t}\n\t\t}\n\n\t\tif(!bPorta || (!pChn->nLength && !(GetType() & MOD_TYPE_S3M)))\n\t\t{\n\t\t\tpChn->pModSample = pSmp;\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t\tpChn->nLoopEnd = pSmp->nLength;\n\t\t\tpChn->nLoopStart = 0;\n\t\t\tpChn->position.Set(0);\n\t\t\tif(m_SongFlags[SONG_PT_MODE] && !pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->position.SetInt(std::min<SmpLength>(pChn->proTrackerOffset, pChn->nLength - 1));\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->proTrackerOffset = 0;\n\t\t\t}\n\t\t\tpChn->dwFlags = (pChn->dwFlags & CHN_CHANNELFLAGS) | (pSmp->uFlags & (CHN_SAMPLEFLAGS | CHN_SURROUND));\n\t\t\tpChn->dwFlags.reset(CHN_PORTAMENTO);\n\t\t\tif(pChn->dwFlags[CHN_SUSTAINLOOP])\n\t\t\t{\n\t\t\t\tpChn->nLoopStart = pSmp->nSustainStart;\n\t\t\t\tpChn->nLoopEnd = pSmp->nSustainEnd;\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGLOOP, pChn->dwFlags[CHN_PINGPONGSUSTAIN]);\n\t\t\t\tpChn->dwFlags.set(CHN_LOOP);\n\t\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\t} else if(pChn->dwFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tpChn->nLoopStart = pSmp->nLoopStart;\n\t\t\t\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\t}\n\t\t\t// ProTracker \"oneshot\" loops (if loop start is 0, play the whole sample once and then repeat until loop end)\n\t\t\tif(m_playBehaviour[kMODOneShotLoops] && pChn->nLoopStart == 0) pChn->nLoopEnd = pChn->nLength = pSmp->nLength;\n\n\t\t\tif(pChn->dwFlags[CHN_REVERSE])\n\t\t\t{\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\tpChn->position.SetInt(pChn->nLength - 1);\n\t\t\t}\n\n\t\t\t// Handle \"retrigger\" waveform type\n\t\t\tif(pChn->nVibratoType < 4)\n\t\t\t{\n\t\t\t\t// IT Compatibilty: Slightly different waveform offsets (why does MPT have two different offsets here with IT old effects enabled and disabled?)\n\t\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello] && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t\tpChn->nVibratoPos = 0x10;\n\t\t\t\telse if(GetType() == MOD_TYPE_MTM)\n\t\t\t\t\tpChn->nVibratoPos = 0x20;\n\t\t\t\telse if(!(GetType() & (MOD_TYPE_DIGI | MOD_TYPE_DBM)))\n\t\t\t\t\tpChn->nVibratoPos = 0;\n\t\t\t}\n\t\t\t// IT Compatibility: No \"retrigger\" waveform here\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello] && pChn->nTremoloType < 4)\n\t\t\t{\n\t\t\t\tpChn->nTremoloPos = 0;\n\t\t\t}\n\t\t}\n\t\tif(pChn->position.GetUInt() >= pChn->nLength) pChn->position.SetInt(pChn->nLoopStart);\n\t} else\n\t{\n\t\tbPorta = false;\n\t}\n\n\tif (!bPorta\n\t\t|| (!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)))\n\t\t|| (pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol)\n\t\t|| (m_SongFlags[SONG_ITCOMPATGXX] && pChn->rowCommand.instr != 0))\n\t{\n\t\tif((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) && pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol)\n\t\t{\n\t\t\tpChn->ResetEnvelopes();\n\t\t\t// IT Compatibility: Autovibrato reset\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t{\n\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t}\n\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\tpChn->nFadeOutVol = 65536;\n\t\t}\n\t\tif ((!bPorta) || (!m_SongFlags[SONG_ITCOMPATGXX]) || (pChn->rowCommand.instr))\n\t\t{\n\t\t\tif ((!(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) || (pChn->rowCommand.instr))\n\t\t\t{\n\t\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\t\tpChn->nFadeOutVol = 65536;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IT compatibility: Don't reset key-off flag on porta notes unless Compat Gxx is enabled\n\t// Test case: Off-Porta.it, Off-Porta-CompatGxx.it\n\tif(m_playBehaviour[kITDontResetNoteOffOnPorta] && bPorta && (!m_SongFlags[SONG_ITCOMPATGXX] || pChn->rowCommand.instr == 0))\n\t\tpChn->dwFlags.reset(CHN_EXTRALOUD);\n\telse\n\t\tpChn->dwFlags.reset(CHN_EXTRALOUD | CHN_KEYOFF);\n\n\t// Enable Ramping\n\tif(!bPorta)\n\t{\n\t\tpChn->nLeftVU = pChn->nRightVU = 0xFF;\n\t\tpChn->dwFlags.reset(CHN_FILTER);\n\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\n\t\t// IT compatibility 15. Retrigger is reset in RetrigNote (Tremor doesn't store anything here, so we just don't reset this as well)\n\t\tif(!m_playBehaviour[kITRetrigger] && !m_playBehaviour[kITTremor])\n\t\t{\n\t\t\t// FT2 compatibility: Retrigger is reset in RetrigNote, tremor in ProcessEffects\n\t\t\tif(!m_playBehaviour[kFT2Retrigger] && !m_playBehaviour[kFT2Tremor])\n\t\t\t{\n\t\t\t\tpChn->nRetrigCount = 0;\n\t\t\t\tpChn->nTremorCount = 0;\n\t\t\t}\n\t\t}\n\n\t\tif(bResetEnv)\n\t\t{\n\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\tpChn->nAutoVibPos = 0;\n\t\t}\n\t\tpChn->rightVol = pChn->leftVol = 0;\n\t\tbool useFilter = !m_SongFlags[SONG_MPTFILTERMODE];\n\t\t// Setup Initial Filter for this note\n\t\tif(pIns)\n\t\t{\n\t\t\tif(pIns->IsResonanceEnabled())\n\t\t\t{\n\t\t\t\tpChn->nResonance = pIns->GetResonance();\n\t\t\t\tuseFilter = true;\n\t\t\t}\n\t\t\tif(pIns->IsCutoffEnabled())\n\t\t\t{\n\t\t\t\tpChn->nCutOff = pIns->GetCutoff();\n\t\t\t\tuseFilter = true;\n\t\t\t}\n\t\t\tif(useFilter && (pIns->nFilterMode != FLTMODE_UNCHANGED))\n\t\t\t{\n\t\t\t\tpChn->nFilterMode = pIns->nFilterMode;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolSwing = pChn->nPanSwing = 0;\n\t\t\tpChn->nCutSwing = pChn->nResSwing = 0;\n\t\t}\n\t\tif((pChn->nCutOff < 0x7F || m_playBehaviour[kITFilterBehaviour]) && useFilter)\n\t\t{\n\t\t\tSetupChannelFilter(pChn, true);\n\t\t}\n\t}\n\t// Special case for MPT\n\tif (bManual) pChn->dwFlags.reset(CHN_MUTE);\n\tif((pChn->dwFlags[CHN_MUTE] && (m_MixerSettings.MixerFlags & SNDMIX_MUTECHNMODE))\n\t\t|| (pChn->pModSample != nullptr && pChn->pModSample->uFlags[CHN_MUTE] && !bManual)\n\t\t|| (pChn->pModInstrument != nullptr && pChn->pModInstrument->dwFlags[INS_MUTE] && !bManual))\n\t{\n\t\tif (!bManual) pChn->nPeriod = 0;\n\t}\n\n\t// Reset the Amiga resampler for this channel\n\tif(!bPorta)\n\t{\n\t\tpChn->paulaState.Reset();\n\t}\n}\n\n\n// Apply sample or instrumernt panning\nvoid CSoundFile::ApplyInstrumentPanning(ModChannel *pChn, const ModInstrument *instr, const ModSample *smp) const\n{\n\tint32 newPan = int32_min;\n\t// Default instrument panning\n\tif(instr != nullptr && instr->dwFlags[INS_SETPANNING])\n\t\tnewPan = instr->nPan;\n\t// Default sample panning\n\tif(smp != nullptr && smp->uFlags[CHN_PANNING])\n\t\tnewPan = smp->nPan;\n\n\tif(newPan != int32_min)\n\t{\n\t\tpChn->nPan = newPan;\n\t\t// IT compatibility: Sample and instrument panning overrides channel surround status.\n\t\t// Test case: SmpInsPanSurround.it\n\t\tif(m_playBehaviour[kPanOverride] && !m_SongFlags[SONG_SURROUNDPAN])\n\t\t{\n\t\t\tpChn->dwFlags.reset(CHN_SURROUND);\n\t\t}\n\t}\n}\n\n\nCHANNELINDEX CSoundFile::GetNNAChannel(CHANNELINDEX nChn) const\n{\n\tconst ModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\t// Check for empty channel\n\tconst ModChannel *pi = &m_PlayState.Chn[m_nChannels];\n\tfor (CHANNELINDEX i = m_nChannels; i < MAX_CHANNELS; i++, pi++) if (!pi->nLength) return i;\n\tif (!pChn->nFadeOutVol) return 0;\n\n\t// All channels are used: check for lowest volume\n\tCHANNELINDEX result = 0;\n\tuint32 vol = (1u << (14 + 9)) / 4u;\t// 25%\n\tuint32 envpos = uint32_max;\n\tconst ModChannel *pj = &m_PlayState.Chn[m_nChannels];\n\tfor (CHANNELINDEX j = m_nChannels; j < MAX_CHANNELS; j++, pj++)\n\t{\n\t\tif (!pj->nFadeOutVol) return j;\n\t\t// Use a combination of real volume [14 bit] (which includes volume envelopes, but also potentially global volume) and note volume [9 bit].\n\t\t// Rationale: We need volume envelopes in case e.g. all NNA channels are playing at full volume but are looping on a 0-volume envelope node.\n\t\t// But if global volume is not applied to master and the global volume temporarily drops to 0, we would kill arbitrary channels. Hence, add the note volume as well.\n\t\tuint32 v = (pj->nRealVolume << 9) | pj->nVolume;\n\t\tif(pj->dwFlags[CHN_LOOP]) v >>= 1;\n\t\tif ((v < vol) || ((v == vol) && (pj->VolEnv.nEnvPosition > envpos)))\n\t\t{\n\t\t\tenvpos = pj->VolEnv.nEnvPosition;\n\t\t\tvol = v;\n\t\t\tresult = j;\n\t\t}\n\t}\n\treturn result;\n}\n\n\nCHANNELINDEX CSoundFile::CheckNNA(CHANNELINDEX nChn, uint32 instr, int note, bool forceCut)\n{\n\tCHANNELINDEX nnaChn = CHANNELINDEX_INVALID;\n\tModChannel &srcChn = m_PlayState.Chn[nChn];\n\tconst ModInstrument *pIns = nullptr;\n\tif(!ModCommand::IsNote(static_cast<ModCommand::NOTE>(note)))\n\t{\n\t\treturn nnaChn;\n\t}\n\t// Always NNA cut - using\n\tif((!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_MT2)) || !m_nInstruments || forceCut) && !srcChn.HasMIDIOutput())\n\t{\n\t\tif(!srcChn.nLength || srcChn.dwFlags[CHN_MUTE] || !(srcChn.rightVol | srcChn.leftVol))\n\t\t{\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(!nnaChn) return CHANNELINDEX_INVALID;\n\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\t// Copy Channel\n\t\tchn = srcChn;\n\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_MUTE | CHN_PORTAMENTO);\n\t\tchn.nPanbrelloOffset = 0;\n\t\tchn.nMasterChn = nChn + 1;\n\t\tchn.nCommand = CMD_NONE;\n\t\tchn.rowCommand.Clear();\n\t\t// Cut the note\n\t\tchn.nFadeOutVol = 0;\n\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t// Stop this channel\n\t\tsrcChn.nLength = 0;\n\t\tsrcChn.position.Set(0);\n\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\tsrcChn.rightVol = srcChn.leftVol = 0;\n\t\treturn nnaChn;\n\t}\n\tif(instr > GetNumInstruments()) instr = 0;\n\tconst ModSample *pSample = srcChn.pModSample;\n\t// If no instrument is given, assume previous instrument to still be valid.\n\t// Test case: DNA-NoInstr.it\n\tpIns = instr > 0 ? Instruments[instr] : srcChn.pModInstrument;\n\tif(pIns != nullptr)\n\t{\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tnote = pIns->NoteMap[note - NOTE_MIN];\n\t\tif ((n) && (n < MAX_SAMPLES))\n\t\t{\n\t\t\tpSample = &Samples[n];\n\t\t} else if(m_playBehaviour[kITEmptyNoteMapSlot] && !pIns->HasValidMIDIChannel())\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\t}\n\tif (srcChn.dwFlags[CHN_MUTE])\n\t\treturn CHANNELINDEX_INVALID;\n\n\tfor(CHANNELINDEX i = nChn; i < MAX_CHANNELS; i++)\n\tif(i >= m_nChannels || i == nChn)\n\t{\n\t\tModChannel &chn = m_PlayState.Chn[i];\n\t\tbool applyDNAtoPlug = false;\n\t\tif((chn.nMasterChn == nChn + 1 || i == nChn) && chn.pModInstrument != nullptr)\n\t\t{\n\t\t\tbool bOk = false;\n\t\t\t// Duplicate Check Type\n\t\t\tswitch(chn.pModInstrument->nDCT)\n\t\t\t{\n\t\t\t// Note\n\t\t\tcase DCT_NOTE:\n\t\t\t\tif(note && chn.nNote == note && pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\t// Sample\n\t\t\tcase DCT_SAMPLE:\n\t\t\t\tif(pSample != nullptr && pSample == chn.pModSample) bOk = true;\n\t\t\t\tbreak;\n\t\t\t// Instrument\n\t\t\tcase DCT_INSTRUMENT:\n\t\t\t\tif(pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\t// Plugin\n\t\t\tcase DCT_PLUGIN:\n\t\t\t\tif(pIns && (pIns->nMixPlug) && (pIns->nMixPlug == chn.pModInstrument->nMixPlug))\n\t\t\t\t{\n\t\t\t\t\tapplyDNAtoPlug = true;\n\t\t\t\t\tbOk = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\t// Duplicate Note Action\n\t\t\tif (bOk)\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif (applyDNAtoPlug && chn.nNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t\t{\n\t\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\t\t// Switch off duplicated note played on this plugin\n\t\t\t\t\t\tSendMIDINote(i, chn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]) + NOTE_MAX_SPECIAL, 0);\n\t\t\t\t\t\tchn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t{\n\t\t\t\t// Cut\n\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tchn.nVolume = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t// Note Off\n\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tbreak;\n\t\t\t\t// Note Fade\n\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!chn.nVolume)\n\t\t\t\t{\n\t\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do we need to apply New/Duplicate Note Action to a VSTi?\n\tbool applyNNAtoPlug = false;\n#ifndef NO_PLUGINS\n\tIMixPlugin *pPlugin = nullptr;\n\tif(srcChn.HasMIDIOutput() && ModCommand::IsNote(srcChn.nNote)) // instro sends to a midi chan\n\t{\n\t\tPLUGINDEX nPlugin = GetBestPlugin(nChn, PrioritiseInstrument, RespectMutes);\n\n\t\tif(nPlugin > 0 && nPlugin <= MAX_MIXPLUGINS)\n\t\t{\n\t\t\tpPlugin =  m_MixPlugins[nPlugin-1].pMixPlugin;\n\t\t\tif(pPlugin)\n\t\t\t{\n\t\t\t\t// apply NNA to this plugin iff it is currently playing a note on this tracker channel\n\t\t\t\t// (and if it is playing a note, we know that would be the last note played on this chan).\n\t\t\t\tapplyNNAtoPlug = pPlugin->IsNotePlaying(srcChn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]), GetBestMidiChannel(nChn), nChn);\n\t\t\t}\n\t\t}\n\t}\n#endif // NO_PLUGINS\n\n\t// New Note Action\n\tif((srcChn.nRealVolume > 0 && srcChn.nLength > 0) || applyNNAtoPlug)\n\t{\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(nnaChn != 0)\n\t\t{\n\t\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\t\t// Copy Channel\n\t\t\tchn = srcChn;\n\t\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_PORTAMENTO);\n\t\t\tchn.nPanbrelloOffset = 0;\n\n\t\t\tchn.nMasterChn = nChn < GetNumChannels() ? nChn + 1 : 0;\n\t\t\tchn.nCommand = CMD_NONE;\n#ifndef NO_PLUGINS\n\t\t\tif(applyNNAtoPlug && pPlugin)\n\t\t\t{\n\t\t\t\t//Move note to the NNA channel (odd, but makes sense with DNA stuff).\n\t\t\t\t//Actually a bad idea since it then become very hard to kill some notes.\n\t\t\t\t//pPlugin->MoveNote(pChn.nNote, pChn.pModInstrument->nMidiChannel, nChn, n);\n\t\t\t\tswitch(srcChn.nNNA)\n\t\t\t\t{\n\t\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tcase NNA_NOTECUT:\n\t\t\t\tcase NNA_NOTEFADE:\n\t\t\t\t\t//switch off note played on this plugin, on this tracker channel and midi channel\n\t\t\t\t\t//pPlugin->MidiCommand(pChn.pModInstrument->nMidiChannel, pChn.pModInstrument->nMidiProgram, pChn.nNote + NOTE_MAX_SPECIAL, 0, n);\n\t\t\t\t\tSendMIDINote(nChn, NOTE_KEYOFF, 0);\n\t\t\t\t\tsrcChn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\t// Key Off the note\n\t\t\tswitch(srcChn.nNNA)\n\t\t\t{\n\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tKeyOff(&chn);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTECUT:\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTEFADE:\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!chn.nVolume)\n\t\t\t{\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\t// Stop this channel\n\t\t\tsrcChn.nLength = 0;\n\t\t\tsrcChn.position.Set(0);\n\t\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\t}\n\t}\n\treturn nnaChn;\n}\n\n\nbool CSoundFile::ProcessEffects()\n{\n\tModChannel *pChn = m_PlayState.Chn;\n\tROWINDEX nBreakRow = ROWINDEX_INVALID;\t\t// Is changed if a break to row command is encountered\n\tROWINDEX nPatLoopRow = ROWINDEX_INVALID;\t// Is changed if a pattern loop jump-back is executed\n\tORDERINDEX nPosJump = ORDERINDEX_INVALID;\n\n\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t{\n\t\tconst uint32 tickCount = m_PlayState.m_nTickCount % (m_PlayState.m_nMusicSpeed + m_PlayState.m_nFrameDelay);\n\t\tuint32 instr = pChn->rowCommand.instr;\n\t\tModCommand::VOLCMD volcmd = pChn->rowCommand.volcmd;\n\t\tuint32 vol = pChn->rowCommand.vol;\n\t\tModCommand::COMMAND cmd = pChn->rowCommand.command;\n\t\tuint32 param = pChn->rowCommand.param;\n\t\tbool bPorta = pChn->rowCommand.IsPortamento();\n\n\t\tuint32 nStartTick = 0;\n\t\tpChn->isFirstTick = m_SongFlags[SONG_FIRSTTICK];\n\n\t\t// Process parameter control note.\n\t\tif(pChn->rowCommand.note == NOTE_PC)\n\t\t{\n#ifndef NO_PLUGINS\n\t\t\tconst PLUGINDEX plug = pChn->rowCommand.instr;\n\t\t\tconst PlugParamIndex plugparam = pChn->rowCommand.GetValueVolCol();\n\t\t\tconst PlugParamValue value = pChn->rowCommand.GetValueEffectCol() / PlugParamValue(ModCommand::maxColumnValue);\n\n\t\t\tif(plug > 0 && plug <= MAX_MIXPLUGINS && m_MixPlugins[plug - 1].pMixPlugin)\n\t\t\t\tm_MixPlugins[plug-1].pMixPlugin->SetParameter(plugparam, value);\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// Process continuous parameter control note.\n\t\t// Row data is cleared after first tick so on following\n\t\t// ticks using channels m_nPlugParamValueStep to identify\n\t\t// the need for parameter control. The condition cmd == 0\n\t\t// is to make sure that m_nPlugParamValueStep != 0 because\n\t\t// of NOTE_PCS, not because of macro.\n\t\tif(pChn->rowCommand.note == NOTE_PCS || (cmd == CMD_NONE && pChn->m_plugParamValueStep != 0))\n\t\t{\n#ifndef NO_PLUGINS\n\t\t\tconst bool isFirstTick = m_SongFlags[SONG_FIRSTTICK];\n\t\t\tif(isFirstTick)\n\t\t\t\tpChn->m_RowPlug = pChn->rowCommand.instr;\n\t\t\tconst PLUGINDEX nPlug = pChn->m_RowPlug;\n\t\t\tconst bool hasValidPlug = (nPlug > 0 && nPlug <= MAX_MIXPLUGINS && m_MixPlugins[nPlug-1].pMixPlugin);\n\t\t\tif(hasValidPlug)\n\t\t\t{\n\t\t\t\tif(isFirstTick)\n\t\t\t\t\tpChn->m_RowPlugParam = ModCommand::GetValueVolCol(pChn->rowCommand.volcmd, pChn->rowCommand.vol);\n\t\t\t\tconst PlugParamIndex plugparam = pChn->m_RowPlugParam;\n\t\t\t\tif(isFirstTick)\n\t\t\t\t{\n\t\t\t\t\tPlugParamValue targetvalue = ModCommand::GetValueEffectCol(pChn->rowCommand.command, pChn->rowCommand.param) / PlugParamValue(ModCommand::maxColumnValue);\n\t\t\t\t\tpChn->m_plugParamTargetValue = targetvalue;\n\t\t\t\t\tpChn->m_plugParamValueStep = (targetvalue - m_MixPlugins[nPlug-1].pMixPlugin->GetParameter(plugparam)) / float(GetNumTicksOnCurrentRow());\n\t\t\t\t}\n\t\t\t\tif(m_PlayState.m_nTickCount + 1 == GetNumTicksOnCurrentRow())\n\t\t\t\t{\t// On last tick, set parameter exactly to target value.\n\t\t\t\t\tm_MixPlugins[nPlug-1].pMixPlugin->SetParameter(plugparam, pChn->m_plugParamTargetValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_MixPlugins[nPlug-1].pMixPlugin->ModifyParameter(plugparam, pChn->m_plugParamValueStep);\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// Apart from changing parameters, parameter control notes are intended to be 'invisible'.\n\t\t// To achieve this, clearing the note data so that rest of the process sees the row as empty row.\n\t\tif(ModCommand::IsPcNote(pChn->rowCommand.note))\n\t\t{\n\t\t\tpChn->ClearRowCmd();\n\t\t\tinstr = 0;\n\t\t\tvolcmd = VOLCMD_NONE;\n\t\t\tvol = 0;\n\t\t\tcmd = CMD_NONE;\n\t\t\tparam = 0;\n\t\t\tbPorta = false;\n\t\t}\n\n\t\t// Process Invert Loop (MOD Effect, called every row if it's active)\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tInvertLoop(&m_PlayState.Chn[nChn]);\n\t\t} else\n\t\t{\n\t\t\tif(instr) m_PlayState.Chn[nChn].nEFxOffset = 0;\n\t\t}\n\n\t\t// Process special effects (note delay, pattern delay, pattern loop)\n\t\tif (cmd == CMD_DELAYCUT)\n\t\t{\n\t\t\t//:xy --> note delay until tick x, note cut at tick x+y\n\t\t\tnStartTick = (param & 0xF0) >> 4;\n\t\t\tconst uint32 cutAtTick = nStartTick + (param & 0x0F);\n\t\t\tNoteCut(nChn, cutAtTick, m_playBehaviour[kITSCxStopsSample]);\n\t\t} else if ((cmd == CMD_MODCMDEX) || (cmd == CMD_S3MCMDEX))\n\t\t{\n\t\t\tif ((!param) && (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\t\t\tparam = pChn->nOldCmdEx;\n\t\t\telse\n\t\t\t\tpChn->nOldCmdEx = static_cast<ModCommand::PARAM>(param);\n\n\t\t\t// Note Delay ?\n\t\t\tif ((param & 0xF0) == 0xD0)\n\t\t\t{\n\t\t\t\tnStartTick = param & 0x0F;\n\t\t\t\tif(nStartTick == 0)\n\t\t\t\t{\n\t\t\t\t\t//IT compatibility 22. SD0 == SD1\n\t\t\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))\n\t\t\t\t\t\tnStartTick = 1;\n\t\t\t\t\t//ST3 ignores notes with SD0 completely\n\t\t\t\t\telse if(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if(nStartTick >= (m_PlayState.m_nMusicSpeed + m_PlayState.m_nFrameDelay) && m_playBehaviour[kITOutOfRangeDelay])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 08. Handling of out-of-range delay command.\n\t\t\t\t\t// Additional test case: tickdelay.it\n\t\t\t\t\tif(instr)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\t// Pattern Loop ?\n\t\t\t\tif((((param & 0xF0) == 0x60 && cmd == CMD_MODCMDEX)\n\t\t\t\t\t|| ((param & 0xF0) == 0xB0 && cmd == CMD_S3MCMDEX))\n\t\t\t\t\t&& !(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE]))\t// not even effects are processed on muted S3M channels\n\t\t\t\t{\n\t\t\t\t\tROWINDEX nloop = PatternLoop(pChn, param & 0x0F);\n\t\t\t\t\tif (nloop != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\t// FT2 compatibility: E6x overwrites jump targets of Dxx effects that are located left of the E6x effect.\n\t\t\t\t\t\t// Test cases: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t\t\t\t\tif(nBreakRow != ROWINDEX_INVALID && m_playBehaviour[kFT2PatternLoopWithJumps])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnBreakRow = nloop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnPatLoopRow = nloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ST3 doesn't have per-channel pattern loop memory, so spam all changes to other channels as well.\n\t\t\t\t\t\tfor (CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_PlayState.Chn[i].nPatternLoop = pChn->nPatternLoop;\n\t\t\t\t\t\t\tm_PlayState.Chn[i].nPatternLoopCount = pChn->nPatternLoopCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ((param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\t// In Scream Tracker 3 / Impulse Tracker, only the first delay command on this row is considered.\n\t\t\t\t\t// Test cases: PatternDelays.it, PatternDelays.s3m, PatternDelays.xm\n\t\t\t\t\t// XXX In Scream Tracker 3, the \"left\" channels are evaluated before the \"right\" channels, which is not emulated here!\n\t\t\t\t\tif(!(GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)) || !m_PlayState.m_nPatternDelay)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(GetType() & (MOD_TYPE_S3M)) || (param & 0x0F) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\t\tm_PlayState.m_nPatternDelay = 1 + (param & 0x0F);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(GetType() == MOD_TYPE_MTM && cmd == CMD_MODCMDEX && (param & 0xF0) == 0xD0)\n\t\t{\n\t\t\t// Apparently, retrigger and note delay have the same behaviour in MultiTracker:\n\t\t\t// They both restart the note at tick x, and if there is a note on the same row,\n\t\t\t// this note is started on the first tick.\n\t\t\tnStartTick = 0;\n\t\t\tparam = 0x90 | (param & 0x0F);\n\t\t}\n\n\t\tif(nStartTick != 0 && pChn->rowCommand.note == NOTE_KEYOFF && pChn->rowCommand.volcmd == VOLCMD_PANNING && m_playBehaviour[kFT2PanWithDelayedNoteOff])\n\t\t{\n\t\t\t// FT2 compatibility: If there's a delayed note off, panning commands are ignored. WTF!\n\t\t\t// Test case: PanOff.xm\n\t\t\tpChn->rowCommand.volcmd = VOLCMD_NONE;\n\t\t}\n\n\t\tbool triggerNote = (m_PlayState.m_nTickCount == nStartTick);\t// Can be delayed by a note delay effect\n\t\tif(m_playBehaviour[kFT2OutOfRangeDelay] && nStartTick >= m_PlayState.m_nMusicSpeed)\n\t\t{\n\t\t\t// FT2 compatibility: Note delays greater than the song speed should be ignored.\n\t\t\t// However, EEx pattern delay is *not* considered at all.\n\t\t\t// Test case: DelayCombination.xm, PortaDelay.xm\n\t\t\ttriggerNote = false;\n\t\t} else if(m_playBehaviour[kRowDelayWithNoteDelay] && nStartTick > 0 && tickCount == nStartTick)\n\t\t{\n\t\t\t// IT compatibility: Delayed notes (using SDx) that are on the same row as a Row Delay effect are retriggered.\n\t\t\t// ProTracker / Scream Tracker 3 / FastTracker 2 do the same.\n\t\t\t// Test case: PatternDelay-NoteDelay.it, PatternDelay-NoteDelay.xm, PatternDelaysRetrig.mod\n\t\t\ttriggerNote = true;\n\t\t}\n\n\t\t// IT compatibility: Tick-0 vs non-tick-0 effect distinction is always based on tick delay.\n\t\t// Test case: SlideDelay.it\n\t\tif(m_playBehaviour[kITFirstTickHandling])\n\t\t{\n\t\t\tpChn->isFirstTick = tickCount == nStartTick;\n\t\t}\n\n\t\t// FT2 compatibility: Note + portamento + note delay = no portamento\n\t\t// Test case: PortaDelay.xm\n\t\tif(m_playBehaviour[kFT2PortaDelay] && nStartTick != 0)\n\t\t{\n\t\t\tbPorta = false;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_PT_MODE] && instr && !m_PlayState.m_nTickCount)\n\t\t{\n\t\t\t// Instrument number resets the stacked ProTracker offset.\n\t\t\t// Test case: ptoffset.mod\n\t\t\tpChn->proTrackerOffset = 0;\n\t\t\t// ProTracker compatibility: Sample properties are always loaded on the first tick, even when there is a note delay.\n\t\t\t// Test case: InstrDelay.mod\n\t\t\tif(!triggerNote && pChn->IsSamplePlaying())\n\t\t\t{\n\t\t\t\tpChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\t\t\t\tif(instr <= GetNumSamples())\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = Samples[instr].nVolume;\n\t\t\t\t\tpChn->nFineTune = Samples[instr].nFineTune;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handles note/instrument/volume changes\n\t\tif(triggerNote)\n\t\t{\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\t\t\tif(instr) pChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\n\t\t\tif(ModCommand::IsNote(note) && m_playBehaviour[kFT2Transpose])\n\t\t\t{\n\t\t\t\t// Notes that exceed FT2's limit are completely ignored.\n\t\t\t\t// Test case: NoteLimit.xm\n\t\t\t\tint transpose = pChn->nTranspose;\n\t\t\t\tif(instr && !bPorta)\n\t\t\t\t{\n\t\t\t\t\t// Refresh transpose\n\t\t\t\t\t// Test case: NoteLimit2.xm\n\t\t\t\t\tSAMPLEINDEX sample = SAMPLEINDEX_INVALID;\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Instrument mode\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && Instruments[instr] != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsample = Instruments[instr]->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Sample mode\n\t\t\t\t\t\tsample = static_cast<SAMPLEINDEX>(instr);\n\t\t\t\t\t}\n\t\t\t\t\tif(sample <= GetNumSamples())\n\t\t\t\t\t{\n\t\t\t\t\t\ttranspose = GetSample(sample).RelativeTone;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst int computedNote = note + transpose;\n\t\t\t\tif((computedNote < NOTE_MIN + 11 || computedNote > NOTE_MIN + 130))\n\t\t\t\t{\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t}\n\t\t\t} else if((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && GetNumInstruments() != 0 && ModCommand::IsNoteOrEmpty(static_cast<ModCommand::NOTE>(note)))\n\t\t\t{\n\t\t\t\t// IT compatibility: Invalid instrument numbers do nothing, but they are remembered for upcoming notes and do not trigger a note in that case.\n\t\t\t\t// Test case: InstrumentNumberChange.it\n\t\t\t\tINSTRUMENTINDEX instrToCheck = static_cast<INSTRUMENTINDEX>((instr != 0) ? instr : pChn->nOldIns);\n\t\t\t\tif(instrToCheck != 0 && (instrToCheck > GetNumInstruments() || Instruments[instrToCheck] == nullptr))\n\t\t\t\t{\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\tinstr = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XM: FT2 ignores a note next to a K00 effect, and a fade-out seems to be done when no volume envelope is present (not exactly the Kxx behaviour)\n\t\t\tif(cmd == CMD_KEYOFF && param == 0 && m_playBehaviour[kFT2KeyOff])\n\t\t\t{\n\t\t\t\tnote = NOTE_NONE;\n\t\t\t\tinstr = 0;\n\t\t\t}\n\n\t\t\tbool retrigEnv = note == NOTE_NONE && instr != 0;\n\n\t\t\t// Apparently, any note number in a pattern causes instruments to recall their original volume settings - no matter if there's a Note Off next to it or whatever.\n\t\t\t// Test cases: keyoff+instr.xm, delay.xm\n\t\t\tbool reloadSampleSettings = (m_playBehaviour[kFT2ReloadSampleSettings] && instr != 0);\n\t\t\t// ProTracker Compatibility: If a sample was stopped before, lone instrument numbers can retrigger it\n\t\t\t// Test case: PTSwapEmpty.mod\n\t\t\tbool keepInstr = (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (m_playBehaviour[kMODSampleSwap] && !pChn->IsSamplePlaying() && pChn->pModSample != nullptr && !pChn->pModSample->HasSampleData());\n\n\t\t\t// Now it's time for some FT2 crap...\n\t\t\tif (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))\n\t\t\t{\n\n\t\t\t\t// XM: Key-Off + Sample == Note Cut (BUT: Only if no instr number or volume effect is present!)\n\t\t\t\t// Test case: NoteOffVolume.xm\n\t\t\t\tif(note == NOTE_KEYOFF\n\t\t\t\t\t&& ((!instr && volcmd != VOLCMD_VOLUME && cmd != CMD_VOLUME) || !m_playBehaviour[kFT2KeyOff])\n\t\t\t\t\t&& (pChn->pModInstrument == nullptr || !pChn->pModInstrument->VolEnv.dwFlags[ENV_ENABLED]))\n\t\t\t\t{\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->nVolume = 0;\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\tinstr = 0;\n\t\t\t\t\tretrigEnv = false;\n\t\t\t\t\t// FT2 Compatbility: Start fading the note for notes with no delay. Only relevant when a volume command is encountered after the note-off.\n\t\t\t\t\t// Test case: NoteOffFadeNoEnv.xm\n\t\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && m_playBehaviour[kFT2NoteOffFlags])\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t} else if(m_playBehaviour[kFT2RetrigWithNoteDelay] && !m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\t// FT2 Compatibility: Some special hacks for rogue note delays... (EDx with x > 0)\n\t\t\t\t\t// Apparently anything that is next to a note delay behaves totally unpredictable in FT2. Swedish tracker logic. :)\n\n\t\t\t\t\tretrigEnv = true;\n\n\t\t\t\t\t// Portamento + Note Delay = No Portamento\n\t\t\t\t\t// Test case: porta-delay.xm\n\t\t\t\t\tbPorta = false;\n\n\t\t\t\t\tif(note == NOTE_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a note delay but no real note, retrig the last note.\n\t\t\t\t\t\t// Test case: delay2.xm, delay3.xm\n\t\t\t\t\t\tnote = static_cast<ModCommand::NOTE>(pChn->nNote - pChn->nTranspose);\n\t\t\t\t\t} else if(note >= NOTE_MIN_SPECIAL)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Gah! Even Note Off + Note Delay will cause envelopes to *retrigger*! How stupid is that?\n\t\t\t\t\t\t// ... Well, and that is actually all it does if there's an envelope. No fade out, no nothing. *sigh*\n\t\t\t\t\t\t// Test case: OffDelay.xm\n\t\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\t\tkeepInstr = false;\n\t\t\t\t\t\treloadSampleSettings = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Normal note\n\t\t\t\t\t\tkeepInstr = true;\n\t\t\t\t\t\treloadSampleSettings = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif((retrigEnv && !m_playBehaviour[kFT2ReloadSampleSettings]) || reloadSampleSettings)\n\t\t\t{\n\t\t\t\tconst ModSample *oldSample = nullptr;\n\t\t\t\t// Reset default volume when retriggering envelopes\n\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\toldSample = pChn->pModSample;\n\t\t\t\t} else if (instr <= GetNumSamples())\n\t\t\t\t{\n\t\t\t\t\t// Case: Only samples are used; no instruments.\n\t\t\t\t\toldSample = &Samples[instr];\n\t\t\t\t}\n\n\t\t\t\tif(oldSample != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!oldSample->uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\t\t\tpChn->nVolume = oldSample->nVolume;\n\t\t\t\t\tif(reloadSampleSettings)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Also reload panning\n\t\t\t\t\t\tpChn->nPan = oldSample->nPan;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FT2 compatibility: Instrument number disables tremor effect\n\t\t\t// Test case: TremorInstr.xm, TremoRecover.xm\n\t\t\tif(m_playBehaviour[kFT2Tremor] && instr != 0)\n\t\t\t{\n\t\t\t\tpChn->nTremorCount = 0x20;\n\t\t\t}\n\n\t\t\tif(retrigEnv) //Case: instrument with no note data.\n\t\t\t{\n\t\t\t\t//IT compatibility: Instrument with no note.\n\t\t\t\tif(m_playBehaviour[kITInstrWithoutNote] || GetType() == MOD_TYPE_PLM)\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Completely retrigger note after sample end to also reset portamento.\n\t\t\t\t\t// Test case: PortaResetAfterRetrigger.it\n\t\t\t\t\tbool triggerAfterSmpEnd = m_playBehaviour[kITMultiSampleInstrumentNumber] && !pChn->IsSamplePlaying();\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Instrument mode\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && (pChn->pModInstrument != Instruments[instr] || triggerAfterSmpEnd))\n\t\t\t\t\t\t\tnote = pChn->nNote;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Sample mode\n\t\t\t\t\t\tif(instr < MAX_SAMPLES && (pChn->pModSample != &Samples[instr] || triggerAfterSmpEnd))\n\t\t\t\t\t\t\tnote = pChn->nNote;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (GetNumInstruments() && (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)))\n\t\t\t\t{\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t\t\tpChn->nFadeOutVol = 65536;\n\t\t\t\t\t// FT2 Compatbility: Reset key-off status with instrument number\n\t\t\t\t\t// Test case: NoteOffInstrChange.xm\n\t\t\t\t\tif(m_playBehaviour[kFT2NoteOffFlags])\n\t\t\t\t\t\tpChn->dwFlags.reset(CHN_KEYOFF);\n\t\t\t\t}\n\t\t\t\tif (!keepInstr) instr = 0;\n\t\t\t}\n\n\t\t\t// Note Cut/Off/Fade => ignore instrument\n\t\t\tif (note >= NOTE_MIN_SPECIAL)\n\t\t\t{\n\t\t\t\t// IT compatibility: Default volume of sample is recalled if instrument number is next to a note-off.\n\t\t\t\t// Test case: NoteOffInstr.it, noteoff2.it\n\t\t\t\tif(m_playBehaviour[kITInstrWithNoteOff] && instr)\n\t\t\t\t{\n\t\t\t\t\tSAMPLEINDEX smp = static_cast<SAMPLEINDEX>(instr);\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\tsmp = 0;\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && Instruments[instr] != nullptr && ModCommand::IsNote(pChn->nLastNote))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmp = Instruments[instr]->Keyboard[pChn->nLastNote - NOTE_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && !Samples[smp].uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\t\t\tpChn->nVolume = Samples[smp].nVolume;\n\t\t\t\t}\n\t\t\t\tinstr = 0;\n\t\t\t}\n\n\t\t\tif(ModCommand::IsNote(note))\n\t\t\t{\n\t\t\t\tpChn->nNewNote = pChn->nLastNote = note;\n\n\t\t\t\t// New Note Action ?\n\t\t\t\tif(!bPorta)\n\t\t\t\t{\n\t\t\t\t\tCheckNNA(nChn, instr, note, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(note)\n\t\t\t{\n\t\t\t\tif(pChn->nRestorePanOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = pChn->nRestorePanOnNewNote - 1;\n\t\t\t\t\tpChn->nRestorePanOnNewNote = 0;\n\t\t\t\t}\n\t\t\t\tif(pChn->nRestoreResonanceOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nResonance = pChn->nRestoreResonanceOnNewNote - 1;\n\t\t\t\t\tpChn->nRestoreResonanceOnNewNote = 0;\n\t\t\t\t}\n\t\t\t\tif(pChn->nRestoreCutoffOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nCutOff = pChn->nRestoreCutoffOnNewNote - 1;\n\t\t\t\t\tpChn->nRestoreCutoffOnNewNote = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Instrument Change ?\n\t\t\tif(instr)\n\t\t\t{\n\t\t\t\tconst ModSample *oldSample = pChn->pModSample;\n\t\t\t\t//const ModInstrument *oldInstrument = pChn->pModInstrument;\n\n\t\t\t\tInstrumentChange(pChn, instr, bPorta, true);\n\t\t\t\t// IT compatibility: Keep new instrument number for next instrument-less note even if sample playback is stopped\n\t\t\t\t// Test case: StoppedInstrSwap.it\n\t\t\t\tif(GetType() == MOD_TYPE_MOD)\n\t\t\t\t{\n\t\t\t\t\t// Test case: PortaSwapPT.mod\n\t\t\t\t\tif(!bPorta || !m_playBehaviour[kMODSampleSwap]) pChn->nNewIns = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(!m_playBehaviour[kITInstrWithNoteOff] || ModCommand::IsNote(note)) pChn->nNewIns = 0;\n\t\t\t\t}\n\n\t\t\t\tif(m_playBehaviour[kITPortamentoSwapResetsPos])\n\t\t\t\t{\n\t\t\t\t\t// Test cases: PortaInsNum.it, PortaSample.it\n\t\t\t\t\tif(ModCommand::IsNote(note) && oldSample != pChn->pModSample)\n\t\t\t\t\t{\n\t\t\t\t\t\t//const bool newInstrument = oldInstrument != pChn->pModInstrument && pChn->pModInstrument->Keyboard[pChn->nNewNote - NOTE_MIN] != 0;\n\t\t\t\t\t\tpChn->position.Set(0);\n\t\t\t\t\t}\n\t\t\t\t} else if ((GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT) && oldSample != pChn->pModSample && ModCommand::IsNote(note)))\n\t\t\t\t{\n\t\t\t\t\t// Special IT case: portamento+note causes sample change -> ignore portamento\n\t\t\t\t\tbPorta = false;\n\t\t\t\t} else if(m_playBehaviour[kMODSampleSwap] && pChn->increment.IsZero())\n\t\t\t\t{\n\t\t\t\t\t// If channel was paused and is resurrected by a lone instrument number, reset the sample position.\n\t\t\t\t\t// Test case: PTSwapEmpty.mod\n\t\t\t\t\tpChn->position.Set(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// New Note ?\n\t\t\tif (note)\n\t\t\t{\n\t\t\t\tif ((!instr) && (pChn->nNewIns) && (note < 0x80))\n\t\t\t\t{\n\t\t\t\t\tInstrumentChange(pChn, pChn->nNewIns, bPorta, pChn->pModSample == nullptr && pChn->pModInstrument == nullptr, !(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)));\n\t\t\t\t\tpChn->nNewIns = 0;\n\t\t\t\t}\n\t\t\t\tNoteChange(pChn, note, bPorta, !(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)));\n\t\t\t\tif ((bPorta) && (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)) && (instr))\n\t\t\t\t{\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Tick-0 only volume commands\n\t\t\tif (volcmd == VOLCMD_VOLUME)\n\t\t\t{\n\t\t\t\tif (vol > 64) vol = 64;\n\t\t\t\tpChn->nVolume = vol << 2;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t} else\n\t\t\tif (volcmd == VOLCMD_PANNING)\n\t\t\t{\n\t\t\t\tPanning(pChn, vol, Pan6bit);\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\tif (m_nInstruments) ProcessMidiOut(nChn);\n#endif // NO_PLUGINS\n\t\t}\n\n\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\tcontinue;\n\n\t\t// Volume Column Effect (except volume & panning)\n\t\t/*\tA few notes, paraphrased from ITTECH.TXT by Storlek (creator of schismtracker):\n\t\t\tEx/Fx/Gx are shared with Exx/Fxx/Gxx; Ex/Fx are 4x the 'normal' slide value\n\t\t\tGx is linked with Ex/Fx if Compat Gxx is off, just like Gxx is with Exx/Fxx\n\t\t\tGx values: 1, 4, 8, 16, 32, 64, 96, 128, 255\n\t\t\tAx/Bx/Cx/Dx values are used directly (i.e. D9 == D09), and are NOT shared with Dxx\n\t\t\t(value is stored into nOldVolParam and used by A0/B0/C0/D0)\n\t\t\tHx uses the same value as Hxx and Uxx, and affects the *depth*\n\t\t\tso... hxx = (hx | (oldhxx & 0xf0))  ???\n\t\t\tTODO is this done correctly?\n\t\t*/\n\t\tbool doVolumeColumn = m_PlayState.m_nTickCount >= nStartTick;\n\t\t// FT2 compatibility: If there's a note delay, volume column effects are NOT executed\n\t\t// on the first tick and, if there's an instrument number, on the delayed tick.\n\t\t// Test case: VolColDelay.xm, PortaDelay.xm\n\t\tif(m_playBehaviour[kFT2VolColDelay] && nStartTick != 0)\n\t\t{\n\t\t\tdoVolumeColumn = m_PlayState.m_nTickCount != 0 && (m_PlayState.m_nTickCount != nStartTick || (pChn->rowCommand.instr == 0 && volcmd != VOLCMD_TONEPORTAMENTO));\n\t\t}\n\t\tif(volcmd > VOLCMD_PANNING && doVolumeColumn)\n\t\t{\n\t\t\tif (volcmd == VOLCMD_TONEPORTAMENTO)\n\t\t\t{\n\t\t\t\tuint32 porta = 0;\n\t\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DMF | MOD_TYPE_DBM | MOD_TYPE_IMF | MOD_TYPE_PSM | MOD_TYPE_J2B | MOD_TYPE_ULT | MOD_TYPE_OKT | MOD_TYPE_MT2 | MOD_TYPE_MDL))\n\t\t\t\t{\n\t\t\t\t\tporta = ImpulseTrackerPortaVolCmd[vol & 0x0F];\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(cmd == CMD_TONEPORTAMENTO && GetType() == MOD_TYPE_XM)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Yes, FT2 is *that* weird. If there is a Mx command in the volume column\n\t\t\t\t\t\t// and a normal 3xx command, the 3xx command is ignored but the Mx command's\n\t\t\t\t\t\t// effectiveness is doubled.\n\t\t\t\t\t\t// Test case: TonePortamentoMemory.xm\n\t\t\t\t\t\tcmd = CMD_NONE;\n\t\t\t\t\t\tvol *= 2;\n\t\t\t\t\t}\n\t\t\t\t\tporta = vol << 4;\n\n\t\t\t\t\t// FT2 compatibility: If there's a portamento and a note delay, execute the portamento, but don't update the parameter\n\t\t\t\t\t// Test case: PortaDelay.xm\n\t\t\t\t\tif(m_playBehaviour[kFT2PortaDelay] && nStartTick != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tporta = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTonePortamento(pChn, porta);\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// FT2 Compatibility: FT2 ignores some volume commands with parameter = 0.\n\t\t\t\tif(m_playBehaviour[kFT2VolColMemory] && vol == 0)\n\t\t\t\t{\n\t\t\t\t\tswitch(volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\t\tcase VOLCMD_PANNING:\n\t\t\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VOLCMD_PANSLIDELEFT:\n\t\t\t\t\t\t// FT2 Compatibility: Pan slide left with zero parameter causes panning to be set to full left on every non-row tick.\n\t\t\t\t\t\t// Test case: PanSlideZero.xm\n\t\t\t\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPan = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMPT_FALLTHROUGH;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// no memory here.\n\t\t\t\t\t\tvolcmd = VOLCMD_NONE;\n\t\t\t\t\t}\n\n\t\t\t\t} else if(!m_playBehaviour[kITVolColMemory])\n\t\t\t\t{\n\t\t\t\t\t// IT Compatibility: Effects in the volume column don't have an unified memory.\n\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\tif(vol) pChn->nOldVolParam = static_cast<ModCommand::PARAM>(vol); else vol = pChn->nOldVolParam;\n\t\t\t\t}\n\n\t\t\t\tswitch(volcmd)\n\t\t\t\t{\n\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nOldVolParam = static_cast<ModCommand::PARAM>(vol);\n\t\t\t\t\t}\n\t\t\t\t\tVolumeSlide(pChn, static_cast<ModCommand::PARAM>(volcmd == VOLCMD_VOLSLIDEUP ? (vol << 4) : vol));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_FINEVOLUP:\n\t\t\t\t\t// IT Compatibility: Fine volume slides in the volume column are only executed on the first tick, not on multiples of the first tick in case of pattern delay\n\t\t\t\t\t// Test case: FineVolColSlide.it\n\t\t\t\t\tif(m_PlayState.m_nTickCount == nStartTick || !m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\tFineVolumeUp(pChn, static_cast<ModCommand::PARAM>(vol), m_playBehaviour[kITVolColMemory]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_FINEVOLDOWN:\n\t\t\t\t\t// IT Compatibility: Fine volume slides in the volume column are only executed on the first tick, not on multiples of the first tick in case of pattern delay\n\t\t\t\t\t// Test case: FineVolColSlide.it\n\t\t\t\t\tif(m_PlayState.m_nTickCount == nStartTick || !m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\tFineVolumeDown(pChn, static_cast<ModCommand::PARAM>(vol), m_playBehaviour[kITVolColMemory]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\t\tpChn->nVibratoSpeed = vol & 0x0F;\n\t\t\t\t\telse\n\t\t\t\t\t\tVibrato(pChn, vol << 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\t\tVibrato(pChn, vol);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PANSLIDELEFT:\n\t\t\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(vol), !m_playBehaviour[kFT2VolColMemory]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PANSLIDERIGHT:\n\t\t\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(vol << 4), !m_playBehaviour[kFT2VolColMemory]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PORTAUP:\n\t\t\t\t\t// IT compatibility (one of the first testcases - link effect memory)\n\t\t\t\t\tPortamentoUp(nChn, static_cast<ModCommand::PARAM>(vol << 2), m_playBehaviour[kITVolColFinePortamento]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PORTADOWN:\n\t\t\t\t\t// IT compatibility (one of the first testcases - link effect memory)\n\t\t\t\t\tPortamentoDown(nChn, static_cast<ModCommand::PARAM>(vol << 2), m_playBehaviour[kITVolColFinePortamento]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_OFFSET:\n\t\t\t\t\tif (triggerNote && pChn->pModSample && vol <= CountOf(pChn->pModSample->cues))\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[vol - 1];\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Effects\n\t\tif(cmd != CMD_NONE) switch (cmd)\n\t\t{\n\t\t// Set Volume\n\t\tcase CMD_VOLUME:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tpChn->nVolume = (param < 64) ? param * 4 : 256;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Portamento Up\n\t\tcase CMD_PORTAMENTOUP:\n\t\t\tif ((!param) && (GetType() & MOD_TYPE_MOD)) break;\n\t\t\tPortamentoUp(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Portamento Down\n\t\tcase CMD_PORTAMENTODOWN:\n\t\t\tif ((!param) && (GetType() & MOD_TYPE_MOD)) break;\n\t\t\tPortamentoDown(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Volume Slide\n\t\tcase CMD_VOLUMESLIDE:\n\t\t\tif (param || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Tone-Portamento\n\t\tcase CMD_TONEPORTAMENTO:\n\t\t\tTonePortamento(pChn, param);\n\t\t\tbreak;\n\n\t\t// Tone-Portamento + Volume Slide\n\t\tcase CMD_TONEPORTAVOL:\n\t\t\tif ((param) || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tTonePortamento(pChn, 0);\n\t\t\tbreak;\n\n\t\t// Vibrato\n\t\tcase CMD_VIBRATO:\n\t\t\tVibrato(pChn, param);\n\t\t\tbreak;\n\n\t\t// Vibrato + Volume Slide\n\t\tcase CMD_VIBRATOVOL:\n\t\t\tif ((param) || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tVibrato(pChn, 0);\n\t\t\tbreak;\n\n\t\t// Set Speed\n\t\tcase CMD_SPEED:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\tSetSpeed(m_PlayState, param);\n\t\t\tbreak;\n\n\t\t// Set Tempo\n\t\tcase CMD_TEMPO:\n\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t{\n\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && param != 0) SetSpeed(m_PlayState, param);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tparam = CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn);\n\t\t\t\tif (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldTempo = static_cast<ModCommand::PARAM>(param); else param = pChn->nOldTempo;\n\t\t\t\t}\n\t\t\t\tTEMPO t(param, 0);\n\t\t\t\tLimitMax(t, GetModSpecifications().GetTempoMax());\n\t\t\t\tSetTempo(t);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Set Offset\n\t\tcase CMD_OFFSET:\n\t\t\tif (triggerNote)\n\t\t\t{\n\t\t\t\t// FT2 compatibility: Portamento + Offset = Ignore offset\n\t\t\t\t// Test case: porta-offset.xm\n\t\t\t\tif(bPorta && GetType() == MOD_TYPE_XM)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbool isExtended = false;\n\t\t\t\tSmpLength offset = CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn, &isExtended);\n\t\t\t\tif(!isExtended)\n\t\t\t\t{\n\t\t\t\t\t// No X-param (normal behaviour)\n\t\t\t\t\toffset <<= 8;\n\t\t\t\t\tif (offset) pChn->oldOffset = offset; else offset = pChn->oldOffset;\n\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t}\n\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Disorder Tracker 2 percentage offset\n\t\tcase CMD_OFFSETPERCENTAGE:\n\t\t\tif(triggerNote)\n\t\t\t{\n\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, param, 255));\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Arpeggio\n\t\tcase CMD_ARPEGGIO:\n\t\t\t// IT compatibility 01. Don't ignore Arpeggio if no note is playing (also valid for ST3)\n\t\t\tif(m_PlayState.m_nTickCount) break;\n\t\t\tif((!pChn->nPeriod || !pChn->nNote)\n\t\t\t\t&& (pChn->pModInstrument == nullptr || !pChn->pModInstrument->HasValidMIDIChannel())\t// Plugin arpeggio\n\t\t\t\t&& !m_playBehaviour[kITArpeggio] && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) break;\n\t\t\tif (!param && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MOD))) break;\t// Only important when editing MOD/XM files (000 effects are removed when loading files where this means \"no effect\")\n\t\t\tpChn->nCommand = CMD_ARPEGGIO;\n\t\t\tif (param) pChn->nArpeggio = static_cast<ModCommand::PARAM>(param);\n\t\t\tbreak;\n\n\t\t// Retrig\n\t\tcase CMD_RETRIG:\n\t\t\tif (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))\n\t\t\t{\n\t\t\t\tif (!(param & 0xF0)) param |= pChn->nRetrigParam & 0xF0;\n\t\t\t\tif (!(param & 0x0F)) param |= pChn->nRetrigParam & 0x0F;\n\t\t\t\tparam |= 0x100; // increment retrig count on first row\n\t\t\t}\n\t\t\t// IT compatibility 15. Retrigger\n\t\t\tif(m_playBehaviour[kITRetrigger])\n\t\t\t{\n\t\t\t\tif (param) pChn->nRetrigParam = static_cast<uint8>(param & 0xFF);\n\t\t\t\tRetrigNote(nChn, pChn->nRetrigParam, (volcmd == VOLCMD_OFFSET) ? vol + 1 : 0);\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// XM Retrig\n\t\t\t\tif (param) pChn->nRetrigParam = static_cast<uint8>(param & 0xFF); else param = pChn->nRetrigParam;\n\t\t\t\tRetrigNote(nChn, param, (volcmd == VOLCMD_OFFSET) ? vol + 1 : 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Tremor\n\t\tcase CMD_TREMOR:\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// IT compatibility 12. / 13. Tremor (using modified DUMB's Tremor logic here because of old effects - http://dumb.sf.net/)\n\t\t\tif(m_playBehaviour[kITTremor])\n\t\t\t{\n\t\t\t\tif(param && !m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t{\n\t\t\t\t\t// Old effects have different length interpretation (+1 for both on and off)\n\t\t\t\t\tif(param & 0xF0) param -= 0x10;\n\t\t\t\t\tif(param & 0x0F) param -= 0x01;\n\t\t\t\t}\n\t\t\t\tpChn->nTremorCount |= 0x80; // set on/off flag\n\t\t\t} else if(m_playBehaviour[kFT2Tremor])\n\t\t\t{\n\t\t\t\t// XM Tremor. Logic is being processed in sndmix.cpp\n\t\t\t\tpChn->nTremorCount |= 0x80; // set on/off flag\n\t\t\t}\n\n\t\t\tpChn->nCommand = CMD_TREMOR;\n\t\t\tif (param) pChn->nTremorParam = static_cast<ModCommand::PARAM>(param);\n\n\t\t\tbreak;\n\n\t\t// Set Global Volume\n\t\tcase CMD_GLOBALVOLUME:\n\t\t\t// IT compatibility: Only apply global volume on first tick (and multiples)\n\t\t\t// Test case: GlobalVolFirstTick.it\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\tbreak;\n\t\t\t// ST3 applies global volume on tick 1 and does other weird things, but we won't emulate this for now.\n// \t\t\tif(((GetType() & MOD_TYPE_S3M) && m_nTickCount != 1)\n// \t\t\t\t|| (!(GetType() & MOD_TYPE_S3M) && !m_SongFlags[SONG_FIRSTTICK]))\n// \t\t\t{\n// \t\t\t\tbreak;\n// \t\t\t}\n\n\t\t\t// FT2 compatibility: On channels that are \"left\" of the global volume command, the new global volume is not applied\n\t\t\t// until the second tick of the row. Since we apply global volume on the mix buffer rather than note volumes, this\n\t\t\t// cannot be fixed for now.\n\t\t\t// Test case: GlobalVolume.xm\n// \t\t\tif(IsCompatibleMode(TRK_FASTTRACKER2) && m_SongFlags[SONG_FIRSTTICK] && m_nMusicSpeed > 1)\n// \t\t\t{\n// \t\t\t\tbreak;\n// \t\t\t}\n\n\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param *= 2;\n\n\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values.\n\t\t\t// Test case: globalvol-invalid.it\n\t\t\tif(param <= 128)\n\t\t\t{\n\t\t\t\tm_PlayState.m_nGlobalVolume = param * 2;\n\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t{\n\t\t\t\tm_PlayState.m_nGlobalVolume = 256;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Global Volume Slide\n\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t//IT compatibility 16. Saving last global volume slide param per channel (FT2/IT)\n\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\tGlobalVolSlide(static_cast<ModCommand::PARAM>(param), pChn->nOldGlobalVolSlide);\n\t\t\telse\n\t\t\t\tGlobalVolSlide(static_cast<ModCommand::PARAM>(param), m_PlayState.Chn[0].nOldGlobalVolSlide);\n\t\t\tbreak;\n\n\t\t// Set 8-bit Panning\n\t\tcase CMD_PANNING8:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Panning Slide\n\t\tcase CMD_PANNINGSLIDE:\n\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Tremolo\n\t\tcase CMD_TREMOLO:\n\t\t\tTremolo(pChn, param);\n\t\t\tbreak;\n\n\t\t// Fine Vibrato\n\t\tcase CMD_FINEVIBRATO:\n\t\t\tFineVibrato(pChn, param);\n\t\t\tbreak;\n\n\t\t// MOD/XM Exx Extended Commands\n\t\tcase CMD_MODCMDEX:\n\t\t\tExtendedMODCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// S3M/IT Sxx Extended Commands\n\t\tcase CMD_S3MCMDEX:\n\t\t\tif(m_playBehaviour[kST3EffectMemory] && param == 0)\n\t\t\t{\n\t\t\t\tparam = pChn->nArpeggio;\t// S00 uses the last non-zero effect parameter as memory, like other effects including Arpeggio, so we \"borrow\" our memory there.\n\t\t\t}\n\t\t\tExtendedS3MCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Key Off\n\t\tcase CMD_KEYOFF:\n\t\t\t// This is how Key Off is supposed to sound... (in FT2 at least)\n\t\t\tif(m_playBehaviour[kFT2KeyOff])\n\t\t\t{\n\t\t\t\tif (m_PlayState.m_nTickCount == param)\n\t\t\t\t{\n\t\t\t\t\t// XM: Key-Off + Sample == Note Cut\n\t\t\t\t\tif(pChn->pModInstrument == nullptr || !pChn->pModInstrument->VolEnv.dwFlags[ENV_ENABLED])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(param == 0 && (pChn->rowCommand.instr || pChn->rowCommand.volcmd != VOLCMD_NONE)) // FT2 is weird....\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\t\t\tpChn->nVolume = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tKeyOff(pChn);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is how it's NOT supposed to sound...\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t\tKeyOff(pChn);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Extra-fine porta up/down\n\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\tswitch(param & 0xF0)\n\t\t\t{\n\t\t\tcase 0x10: ExtraFinePortamentoUp(pChn, param & 0x0F); break;\n\t\t\tcase 0x20: ExtraFinePortamentoDown(pChn, param & 0x0F); break;\n\t\t\t// ModPlug XM Extensions (ignore in compatible mode)\n\t\t\tcase 0x50:\n\t\t\tcase 0x60:\n\t\t\tcase 0x70:\n\t\t\tcase 0x90:\n\t\t\tcase 0xA0:\n\t\t\t\tif(!m_playBehaviour[kFT2RestrictXCommand]) ExtendedS3MCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Set Channel Global Volume\n\t\tcase CMD_CHANNELVOLUME:\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\tif (param <= 64)\n\t\t\t{\n\t\t\t\tpChn->nGlobalVol = param;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Channel volume slide\n\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\tChannelVolSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Panbrello (IT)\n\t\tcase CMD_PANBRELLO:\n\t\t\tPanbrello(pChn, param);\n\t\t\tbreak;\n\n\t\t// Set Envelope Position\n\t\tcase CMD_SETENVPOSITION:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tpChn->VolEnv.nEnvPosition = param;\n\n\t\t\t\t// FT2 compatibility: FT2 only sets the position of the panning envelope if the volume envelope's sustain flag is set\n\t\t\t\t// Test case: SetEnvPos.xm\n\t\t\t\tif(!m_playBehaviour[kFT2SetPanEnvPos] || pChn->VolEnv.flags[ENV_SUSTAIN])\n\t\t\t\t{\n\t\t\t\t\tpChn->PanEnv.nEnvPosition = param;\n\t\t\t\t\tpChn->PitchEnv.nEnvPosition = param;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Position Jump\n\t\tcase CMD_POSITIONJUMP:\n\t\t\tm_PlayState.m_nNextPatStartRow = 0; // FT2 E60 bug\n\t\t\tnPosJump = static_cast<ORDERINDEX>(CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn));\n\n\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t// Test case: PatternJump.mod\n\t\t\tif((GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)) && nBreakRow != ROWINDEX_INVALID)\n\t\t\t{\n\t\t\t\tnBreakRow = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Pattern Break\n\t\tcase CMD_PATTERNBREAK:\n\t\t\t{\n\t\t\t\tROWINDEX row = PatternBreak(m_PlayState, nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t{\n\t\t\t\t\tnBreakRow = row;\n\t\t\t\t\tif(m_SongFlags[SONG_PATTERNLOOP])\n\t\t\t\t\t{\n\t\t\t\t\t\t//If song is set to loop and a pattern break occurs we should stay on the same pattern.\n\t\t\t\t\t\t//Use nPosJump to force playback to \"jump to this pattern\" rather than move to next, as by default.\n\t\t\t\t\t\t//rewbs.to\n\t\t\t\t\t\tnPosJump = m_PlayState.m_nCurrentOrder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// IMF / PTM Note Slides\n\t\tcase CMD_NOTESLIDEUP:\n\t\tcase CMD_NOTESLIDEDOWN:\n\t\tcase CMD_NOTESLIDEUPRETRIG:\n\t\tcase CMD_NOTESLIDEDOWNRETRIG:\n\t\t\t// Note that this command seems to be a bit buggy in Polytracker... Luckily, no tune seems to seriously use this\n\t\t\t// (Vic uses it e.g. in Spaceman or Perfect Reason to slide effect samples, noone will notice the difference :)\n\t\t\tNoteSlide(pChn, param, cmd == CMD_NOTESLIDEUP || cmd == CMD_NOTESLIDEUPRETRIG, cmd == CMD_NOTESLIDEUPRETRIG || cmd == CMD_NOTESLIDEDOWNRETRIG);\n\t\t\tbreak;\n\n\t\t// PTM Reverse sample + offset (executed on every tick)\n\t\tcase CMD_REVERSEOFFSET:\n\t\t\tReverseSampleOffset(*pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n#ifndef NO_PLUGINS\n\t\t// DBM: Toggle DSP Echo\n\t\tcase CMD_DBMECHO:\n\t\t\tif(m_PlayState.m_nTickCount == 0)\n\t\t\t{\n\t\t\t\tuint32 chns = (param >> 4), enable = (param & 0x0F);\n\t\t\t\tif(chns > 1 || enable > 2)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\tif(chns == 1)\n\t\t\t\t{\n\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\tlastChn = m_nChannels - 1;\n\t\t\t\t}\n\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t{\n\t\t\t\t\tChnSettings[c].dwFlags.set(CHN_NOFX, enable == 1);\n\t\t\t\t\tm_PlayState.Chn[c].dwFlags.set(CHN_NOFX, enable == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif // NO_PLUGINS\n\t\t}\n\n\t\tif(m_playBehaviour[kST3EffectMemory] && param != 0)\n\t\t{\n\t\t\tUpdateS3MEffectMemory(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t}\n\n\t\tif(pChn->rowCommand.instr)\n\t\t{\n\t\t\t// Not necessarily consistent with actually playing instrument for IT compatibility\n\t\t\tpChn->nOldIns = pChn->rowCommand.instr;\n\t\t}\n\n\t} // for(...) end\n\n\t// Navigation Effects\n\tif(m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\tconst bool doPatternLoop = (nPatLoopRow != ROWINDEX_INVALID);\n\t\tconst bool doBreakRow = (nBreakRow != ROWINDEX_INVALID);\n\t\tconst bool doPosJump = (nPosJump != ORDERINDEX_INVALID);\n\n\t\t// Pattern Loop\n\t\tif(doPatternLoop)\n\t\t{\n\t\t\tm_PlayState.m_nNextOrder = m_PlayState.m_nCurrentOrder;\n\t\t\tm_PlayState.m_nNextRow = nPatLoopRow;\n\t\t\tif(m_PlayState.m_nPatternDelay)\n\t\t\t{\n\t\t\t\tm_PlayState.m_nNextRow++;\n\t\t\t}\n\n\t\t\t// IT Compatibility: If the restart row is past the end of the current pattern\n\t\t\t// (e.g. when continued from a previous pattern without explicit SB0 effect), continue the next pattern.\n\t\t\t// Test case: LoopStartAfterPatternEnd.it\n\t\t\tif(nPatLoopRow >= Patterns[m_PlayState.m_nPattern].GetNumRows())\n\t\t\t{\n\t\t\t\tm_PlayState.m_nNextOrder++;\n\t\t\t\tm_PlayState.m_nNextRow = 0;\n\t\t\t}\n\n\t\t\t// As long as the pattern loop is running, mark the looped rows as not visited yet\n\t\t\tvisitedSongRows.ResetPatternLoop(m_PlayState.m_nCurrentOrder, nPatLoopRow);\n\t\t}\n\n\t\t// Pattern Break / Position Jump only if no loop running\n\t\t// Exception: FastTracker 2 in all cases, Impulse Tracker in case of position jump\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif((doBreakRow || doPosJump)\n\t\t\t&& (!doPatternLoop || m_playBehaviour[kFT2PatternLoopWithJumps] || (m_playBehaviour[kITPatternLoopWithJumps] && doPosJump)))\n\t\t{\n\t\t\tif(!doPosJump) nPosJump = m_PlayState.m_nCurrentOrder + 1;\n\t\t\tif(!doBreakRow) nBreakRow = 0;\n\t\t\tm_SongFlags.set(SONG_BREAKTOROW);\n\n\t\t\tif(nPosJump >= Order().size())\n\t\t\t{\n\t\t\t\tnPosJump = Order().GetRestartPos();\n\t\t\t}\n\n\t\t\t// IT / FT2 compatibility: don't reset loop count on pattern break.\n\t\t\t// Test case: gm-trippy01.it, PatLoop-Break.xm, PatLoop-Weird.xm, PatLoop-Break.mod\n\t\t\tif(nPosJump != m_PlayState.m_nCurrentOrder\n\t\t\t\t&& !m_playBehaviour[kITPatternLoopBreak] && !m_playBehaviour[kFT2PatternLoopWithJumps] && GetType() != MOD_TYPE_MOD)\n\t\t\t{\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[i].nPatternLoopCount = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm_PlayState.m_nNextRow = nBreakRow;\n\t\t\tif(!m_SongFlags[SONG_PATTERNLOOP])\n\t\t\t\tm_PlayState.m_nNextOrder = nPosJump;\n\t\t}\n\n\t}\n\treturn true;\n}\n\n\n////////////////////////////////////////////////////////////\n// Channels effects\n\n\n// Update the effect memory of all S3M effects that use the last non-zero effect parameter as memory (Dxy, Exx, Fxx, Ixy, Jxy, Kxy, Lxy, Qxy, Rxy, Sxy)\n// Test case: ParamMemory.s3m\nvoid CSoundFile::UpdateS3MEffectMemory(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tpChn->nOldVolumeSlide = param;\t// Dxy / Kxy / Lxy\n\tpChn->nOldPortaUp = param;\t\t// Exx / Fxx\n\tpChn->nOldPortaDown = param;\t// Exx / Fxx\n\tpChn->nTremorParam = param;\t\t// Ixy\n\tpChn->nArpeggio = param;\t\t// Jxy\n\tpChn->nRetrigParam = param;\t\t// Qxy\n\tpChn->nTremoloDepth = (param & 0x0F) << 2;\t// Rxy\n\tpChn->nTremoloSpeed = (param >> 4) & 0x0F;\t// Rxy\n\t// Sxy is not handled here.\n}\n\n\n// Calculate full parameter for effects that support parameter extension at the given pattern location.\n// maxCommands sets the maximum number of XParam commands to look at for this effect\n// isExtended returns if the command is actually using any XParam extensions.\nuint32 CSoundFile::CalculateXParam(PATTERNINDEX pat, ROWINDEX row, CHANNELINDEX chn, bool *isExtended) const\n{\n\tif(isExtended != nullptr) *isExtended = false;\n\tROWINDEX maxCommands = 4;\n\tconst ModCommand *m = Patterns[pat].GetpModCommand(row, chn);\n\tuint32 val = m->param;\n\n\tswitch(m->command)\n\t{\n\tcase CMD_OFFSET:\n\t\t// 24 bit command\n\t\tmaxCommands = 2;\n\t\tbreak;\n\tcase CMD_TEMPO:\n\tcase CMD_PATTERNBREAK:\n\tcase CMD_POSITIONJUMP:\n\t\t// 16 bit command\n\t\tmaxCommands = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn val;\n\t}\n\n\tconst bool xmTempoFix = m->command == CMD_TEMPO && GetType() == MOD_TYPE_XM;\n\tROWINDEX numRows = std::min(Patterns[pat].GetNumRows() - row - 1, maxCommands);\n\twhile(numRows > 0)\n\t{\n\t\tm += Patterns[pat].GetNumChannels();\n\t\tif(m->command != CMD_XPARAM)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif(xmTempoFix && val < 256)\n\t\t{\n\t\t\t// With XM, 0x20 is the lowest tempo. Anything below changes ticks per row.\n\t\t\tval -= 0x20;\n\t\t}\n\t\tval = (val << 8) | m->param;\n\t\tnumRows--;\n\t\tif(isExtended != nullptr) *isExtended = true;\n\t}\n\treturn val;\n}\n\n\nROWINDEX CSoundFile::PatternBreak(PlayState &state, CHANNELINDEX chn, uint8 param) const\n{\n\tif(param >= 64 && (GetType() & MOD_TYPE_S3M))\n\t{\n\t\t// ST3 ignores invalid pattern breaks.\n\t\treturn ROWINDEX_INVALID;\n\t}\n\n\tstate.m_nNextPatStartRow = 0; // FT2 E60 bug\n\n\treturn static_cast<ROWINDEX>(CalculateXParam(state.m_nPattern, state.m_nRow, chn));\n}\n\n\nvoid CSoundFile::PortamentoUp(CHANNELINDEX nChn, ModCommand::PARAM param, const bool doFinePortamentoAsRegular)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\tif(param)\n\t{\n\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\tpChn->nOldPortaDown = param;\n\t\tpChn->nOldPortaUp = param;\n\t} else\n\t{\n\t\tparam = pChn->nOldPortaUp;\n\t}\n\n\tconst bool doFineSlides = !doFinePortamentoAsRegular && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_AMF0 | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM));\n\n\t// Process MIDI pitch bend for instrument plugins\n\tMidiPortamento(nChn, param, doFineSlides);\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t// Portamento for instruments with custom tuning\n\t\tif(param >= 0xF0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoFineMPT(pChn, param - 0xF0);\n\t\telse if(param >= 0xE0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoExtraFineMPT(pChn, param - 0xE0);\n\t\telse\n\t\t\tPortamentoMPT(pChn, param);\n\t\treturn;\n\t} else if(GetType() == MOD_TYPE_PLM)\n\t{\n\t\t// A normal portamento up or down makes a follow-up tone portamento go the same direction.\n\t\tpChn->nPortamentoDest = 1;\n\t}\n\n\tif (doFineSlides && param >= 0xE0)\n\t{\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif ((param & 0xF0) == 0xF0)\n\t\t\t{\n\t\t\t\tFinePortamentoUp(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t} else if ((param & 0xF0) == 0xE0 && GetType() != MOD_TYPE_DBM)\n\t\t\t{\n\t\t\t\tExtraFinePortamentoUp(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(GetType() != MOD_TYPE_DBM)\n\t\t{\n\t\t\t// DBM only has fine slides, no extra-fine slides.\n\t\t\treturn;\n\t\t}\n\t}\n\t// Regular Slide\n\tif(!pChn->isFirstTick || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]) || GetType() == MOD_TYPE_669)\n\t{\n\t\tDoFreqSlide(pChn, -int(param) * 4);\n\t}\n}\n\n\nvoid CSoundFile::PortamentoDown(CHANNELINDEX nChn, ModCommand::PARAM param, const bool doFinePortamentoAsRegular)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\tif(param)\n\t{\n\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\tpChn->nOldPortaUp = param;\n\t\tpChn->nOldPortaDown = param;\n\t} else\n\t{\n\t\tparam = pChn->nOldPortaDown;\n\t}\n\n\tconst bool doFineSlides = !doFinePortamentoAsRegular && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_AMF0 | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM));\n\n\t// Process MIDI pitch bend for instrument plugins\n\tMidiPortamento(nChn, -static_cast<int>(param), doFineSlides);\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t// Portamento for instruments with custom tuning\n\t\tif(param >= 0xF0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoFineMPT(pChn, -static_cast<int>(param - 0xF0));\n\t\telse if(param >= 0xE0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoExtraFineMPT(pChn, -static_cast<int>(param - 0xE0));\n\t\telse\n\t\t\tPortamentoMPT(pChn, -static_cast<int>(param));\n\t\treturn;\n\t} else if(GetType() == MOD_TYPE_PLM)\n\t{\n\t\t// A normal portamento up or down makes a follow-up tone portamento go the same direction.\n\t\tpChn->nPortamentoDest = 65535;\n\t}\n\n\tif(doFineSlides && param >= 0xE0)\n\t{\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif ((param & 0xF0) == 0xF0)\n\t\t\t{\n\t\t\t\tFinePortamentoDown(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t} else if ((param & 0xF0) == 0xE0 && GetType() != MOD_TYPE_DBM)\n\t\t\t{\n\t\t\t\tExtraFinePortamentoDown(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(GetType() != MOD_TYPE_DBM)\n\t\t{\n\t\t\t// DBM only has fine slides, no extra-fine slides.\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(!pChn->isFirstTick || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]) || GetType() == MOD_TYPE_669)\n\t{\n\t\tDoFreqSlide(pChn, int(param) * 4);\n\t}\n}\n\n\n// Send portamento commands to plugins\nvoid CSoundFile::MidiPortamento(CHANNELINDEX nChn, int param, bool doFineSlides)\n{\n\tint actualParam = mpt::abs(param);\n\tint pitchBend = 0;\n\n\t// Old MIDI Pitch Bends:\n\t// - Applied on every tick\n\t// - No fine pitch slides (they are interpreted as normal slides)\n\t// New MIDI Pitch Bends:\n\t// - Behaviour identical to sample pitch bends if the instrument's PWD parameter corresponds to the actual VSTi setting.\n\n\tif(doFineSlides && actualParam >= 0xE0 && !m_playBehaviour[kOldMIDIPitchBends])\n\t{\n\t\tif(m_PlayState.Chn[nChn].isFirstTick)\n\t\t{\n\t\t\t// Extra fine slide...\n\t\t\tpitchBend = (actualParam & 0x0F) * sgn(param);\n\t\t\tif(actualParam >= 0xF0)\n\t\t\t{\n\t\t\t\t// ... or just a fine slide!\n\t\t\t\tpitchBend *= 4;\n\t\t\t}\n\t\t}\n\t} else if(!m_PlayState.Chn[nChn].isFirstTick || m_playBehaviour[kOldMIDIPitchBends])\n\t{\n\t\t// Regular slide\n\t\tpitchBend = param * 4;\n\t}\n\n\tif(pitchBend)\n\t{\n#ifndef NO_PLUGINS\n\t\tIMixPlugin *plugin = GetChannelInstrumentPlugin(nChn);\n\t\tif(plugin != nullptr)\n\t\t{\n\t\t\tint8 pwd = 13;\t// Early OpenMPT legacy... Actually it's not *exactly* 13, but close enough...\n\t\t\tif(m_PlayState.Chn[nChn].pModInstrument != nullptr)\n\t\t\t{\n\t\t\t\tpwd = m_PlayState.Chn[nChn].pModInstrument->midiPWD;\n\t\t\t}\n\t\t\tplugin->MidiPitchBend(GetBestMidiChannel(nChn), pitchBend, pwd);\n\t\t}\n#endif // NO_PLUGINS\n\t}\n}\n\n\nvoid CSoundFile::FinePortamentoUp(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldFinePortaUpDown = (pChn->nOldFinePortaUpDown & 0x0F) | (param << 4); else param = (pChn->nOldFinePortaUpDown >> 4);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tconst auto oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetLinearSlideUpTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod)\n\t\t\t\t{\n\t\t\t\t\tif(m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\t\telse if(!m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod > 1)\n\t\t\t\t\t\tpChn->nPeriod--;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod -= (int)(param * 4);\n\t\t\t\tif (pChn->nPeriod < 1)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPeriod = 1;\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nFadeOutVol = 0;\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::FinePortamentoDown(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldFinePortaUpDown = (pChn->nOldFinePortaUpDown & 0xF0) | (param & 0x0F); else param = (pChn->nOldFinePortaUpDown & 0x0F);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif (m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tconst auto oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetLinearSlideDownTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod)\n\t\t\t\t{\n\t\t\t\t\tif(!m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\t\telse if(m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod > 1)\n\t\t\t\t\t\tpChn->nPeriod--;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod += (int)(param * 4);\n\t\t\t\tif (pChn->nPeriod > 0xFFFF) pChn->nPeriod = 0xFFFF;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::ExtraFinePortamentoUp(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldExtraFinePortaUpDown = (pChn->nOldExtraFinePortaUpDown & 0x0F) | (param << 4); else param = (pChn->nOldExtraFinePortaUpDown >> 4);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tint oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetFineLinearSlideUpTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod) pChn->nPeriod++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod -= (int)(param);\n\t\t\t\tif (pChn->nPeriod < 1)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPeriod = 1;\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nFadeOutVol = 0;\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::ExtraFinePortamentoDown(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldExtraFinePortaUpDown = (pChn->nOldExtraFinePortaUpDown & 0xF0) | (param & 0x0F); else param = (pChn->nOldExtraFinePortaUpDown & 0x0F);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tint oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetFineLinearSlideDownTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod) pChn->nPeriod--;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod += (int)(param);\n\t\t\t\tif (pChn->nPeriod > 0xFFFF) pChn->nPeriod = 0xFFFF;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Implemented for IMF compatibility, can't actually save this in any formats\n// Slide up / down every x ticks by y semitones\nvoid CSoundFile::NoteSlide(ModChannel *pChn, uint32 param, bool slideUp, bool retrig) const\n{\n\tuint8 x, y;\n\tif(m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\tx = param & 0xF0;\n\t\tif (x)\n\t\t\tpChn->nNoteSlideSpeed = (x >> 4);\n\t\ty = param & 0x0F;\n\t\tif (y)\n\t\t\tpChn->nNoteSlideStep = y;\n\t\tpChn->nNoteSlideCounter = pChn->nNoteSlideSpeed;\n\t} else\n\t{\n\t\tif (--pChn->nNoteSlideCounter == 0)\n\t\t{\n\t\t\tpChn->nNoteSlideCounter = pChn->nNoteSlideSpeed;\n\t\t\t// update it\n\t\t\tpChn->nPeriod = GetPeriodFromNote\n\t\t\t\t((slideUp ? 1 : -1)  * pChn->nNoteSlideStep + GetNoteFromPeriod(pChn->nPeriod), 8363, 0);\n\n\t\t\tif(retrig)\n\t\t\t{\n\t\t\t\tpChn->position.Set(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Portamento Slide\nvoid CSoundFile::TonePortamento(ModChannel *pChn, uint32 param) const\n{\n\tpChn->dwFlags.set(CHN_PORTAMENTO);\n\n\t//IT compatibility 03: Share effect memory with portamento up/down\n\tif((!m_SongFlags[SONG_ITCOMPATGXX] && m_playBehaviour[kITPortaMemoryShare]) || GetType() == MOD_TYPE_PLM)\n\t{\n\t\tif(param == 0) param = pChn->nOldPortaUp;\n\t\tpChn->nOldPortaUp = pChn->nOldPortaDown = static_cast<uint8>(param);\n\t}\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t//Behavior: Param tells number of finesteps(or 'fullsteps'(notes) with glissando)\n\t\t//to slide per row(not per tick).\n\t\tconst int32 old_PortamentoTickSlide = (m_PlayState.m_nTickCount != 0) ? pChn->m_PortamentoTickSlide : 0;\n\n\t\tif(param)\n\t\t\tpChn->nPortamentoSlide = param;\n\t\telse\n\t\t\tif(pChn->nPortamentoSlide == 0)\n\t\t\t\treturn;\n\n\n\t\tif((pChn->nPortamentoDest > 0 && pChn->nPortamentoSlide < 0) ||\n\t\t\t(pChn->nPortamentoDest < 0 && pChn->nPortamentoSlide > 0))\n\t\t\tpChn->nPortamentoSlide = -pChn->nPortamentoSlide;\n\n\t\tpChn->m_PortamentoTickSlide = static_cast<int32>((m_PlayState.m_nTickCount + 1.0) * pChn->nPortamentoSlide / m_PlayState.m_nMusicSpeed);\n\n\t\tif(pChn->dwFlags[CHN_GLISSANDO])\n\t\t{\n\t\t\tpChn->m_PortamentoTickSlide *= pChn->pModInstrument->pTuning->GetFineStepCount() + 1;\n\t\t\t//With glissando interpreting param as notes instead of finesteps.\n\t\t}\n\n\t\tconst int32 slide = pChn->m_PortamentoTickSlide - old_PortamentoTickSlide;\n\n\t\tif(mpt::abs(pChn->nPortamentoDest) <= mpt::abs(slide))\n\t\t{\n\t\t\tif(pChn->nPortamentoDest != 0)\n\t\t\t{\n\t\t\t\tpChn->m_PortamentoFineSteps += pChn->nPortamentoDest;\n\t\t\t\tpChn->nPortamentoDest = 0;\n\t\t\t\tpChn->m_CalculateFreq = true;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->m_PortamentoFineSteps += slide;\n\t\t\tpChn->nPortamentoDest -= slide;\n\t\t\tpChn->m_CalculateFreq = true;\n\t\t}\n\n\t\treturn;\n\t} //End candidate MPT behavior.\n\n\tbool doPorta = !pChn->isFirstTick || (GetType() & (MOD_TYPE_DBM | MOD_TYPE_669)) || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]);\n\tif(GetType() == MOD_TYPE_PLM && param >= 0xF0)\n\t{\n\t\tparam -= 0xF0;\n\t\tdoPorta = pChn->isFirstTick;\n\t}\n\n\tif(param)\n\t{\n\t\tif(GetType() == MOD_TYPE_669)\n\t\t{\n\t\t\tparam *= 10;\n\t\t}\n\t\tpChn->nPortamentoSlide = param * 4;\n\t}\n\n\tif(pChn->nPeriod && pChn->nPortamentoDest && doPorta)\n\t{\n\t\tif (pChn->nPeriod < pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\t// Return (a*b+c/2)/c - no divide error\n\t\t\t\t// Table is 65536*2(n/192)\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideUpTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta < 1) delta = 1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod > pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t} else\n\t\tif (pChn->nPeriod > pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = -pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideDownTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta > -1) delta = -1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod < pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t}\n\t}\n\n\t// IT compatibility 23. Portamento with no note\n\t// ProTracker also disables portamento once the target is reached.\n\t// Test case: PortaTarget.mod\n\tif(pChn->nPeriod == pChn->nPortamentoDest && (m_playBehaviour[kITPortaTargetReached] || GetType() == MOD_TYPE_MOD))\n\t\tpChn->nPortamentoDest = 0;\n\n}\n\n\nvoid CSoundFile::Vibrato(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nVibratoDepth = (param & 0x0F) * 4;\n\tif (param & 0xF0) p->nVibratoSpeed = (param >> 4) & 0x0F;\n\tp->dwFlags.set(CHN_VIBRATO);\n}\n\n\nvoid CSoundFile::FineVibrato(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nVibratoDepth = param & 0x0F;\n\tif (param & 0xF0) p->nVibratoSpeed = (param >> 4) & 0x0F;\n\tp->dwFlags.set(CHN_VIBRATO);\n\t// ST3 compatibility: Do not distinguish between vibrato types in effect memory\n\t// Test case: VibratoTypeChange.s3m\n\tif(m_playBehaviour[kST3VibratoMemory] && (param & 0x0F))\n\t{\n\t\tp->nVibratoDepth *= 4u;\n\t}\n}\n\n\nvoid CSoundFile::Panbrello(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nPanbrelloDepth = param & 0x0F;\n\tif (param & 0xF0) p->nPanbrelloSpeed = (param >> 4) & 0x0F;\n}\n\n\nvoid CSoundFile::Panning(ModChannel *pChn, uint32 param, PanningType panBits) const\n{\n\t// No panning in ProTracker mode\n\tif(m_playBehaviour[kMODIgnorePanning])\n\t{\n\t\treturn;\n\t}\n\t// IT Compatibility (and other trackers as well): panning disables surround (unless panning in rear channels is enabled, which is not supported by the original trackers anyway)\n\tif (!m_SongFlags[SONG_SURROUNDPAN] && (panBits == Pan8bit || m_playBehaviour[kPanOverride]))\n\t{\n\t\tpChn->dwFlags.reset(CHN_SURROUND);\n\t}\n\tif(panBits == Pan4bit)\n\t{\n\t\t// 0...15 panning\n\t\tpChn->nPan = (param * 256 + 8) / 15;\n\t} else if(panBits == Pan6bit)\n\t{\n\t\t// 0...64 panning\n\t\tif(param > 64) param = 64;\n\t\tpChn->nPan = param * 4;\n\t} else\n\t{\n\t\tif(!(GetType() & (MOD_TYPE_S3M | MOD_TYPE_DSM | MOD_TYPE_AMF | MOD_TYPE_MTM)))\n\t\t{\n\t\t\t// Real 8-bit panning\n\t\t\tpChn->nPan = param;\n\t\t} else\n\t\t{\n\t\t\t// 7-bit panning + surround\n\t\t\tif(param <= 0x80)\n\t\t\t{\n\t\t\t\tpChn->nPan = param << 1;\n\t\t\t} else if(param == 0xA4)\n\t\t\t{\n\t\t\t\tpChn->dwFlags.set(CHN_SURROUND);\n\t\t\t\tpChn->nPan = 0x80;\n\t\t\t}\n\t\t}\n\t}\n\n\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\tpChn->nRestorePanOnNewNote = 0;\n\t//IT compatibility 20. Set pan overrides random pan\n\tif(m_playBehaviour[kPanOverride])\n\t{\n\t\tpChn->nPanSwing = 0;\n\t\tpChn->nPanbrelloOffset = 0;\n\t}\n}\n\n\nvoid CSoundFile::VolumeSlide(ModChannel *pChn, ModCommand::PARAM param)\n{\n\tif (param)\n\t\tpChn->nOldVolumeSlide = param;\n\telse\n\t\tparam = pChn->nOldVolumeSlide;\n\n\tif((GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM)))\n\t{\n\t\t// MOD / XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tint newvolume = pChn->nVolume;\n\tif(!(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_AMF0 | MOD_TYPE_MED | MOD_TYPE_DIGI)))\n\t{\n\t\tif ((param & 0x0F) == 0x0F) //Fine upslide or slide -15\n\t\t{\n\t\t\tif (param & 0xF0) //Fine upslide\n\t\t\t{\n\t\t\t\tFineVolumeUp(pChn, (param >> 4), false);\n\t\t\t\treturn;\n\t\t\t} else //Slide -15\n\t\t\t{\n\t\t\t\tif(pChn->isFirstTick && !m_SongFlags[SONG_FASTVOLSLIDES])\n\t\t\t\t{\n\t\t\t\t\tnewvolume -= 0x0F * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\tif ((param & 0xF0) == 0xF0) //Fine downslide or slide +15\n\t\t{\n\t\t\tif (param & 0x0F) //Fine downslide\n\t\t\t{\n\t\t\t\tFineVolumeDown(pChn, (param & 0x0F), false);\n\t\t\t\treturn;\n\t\t\t} else //Slide +15\n\t\t\t{\n\t\t\t\tif(pChn->isFirstTick && !m_SongFlags[SONG_FASTVOLSLIDES])\n\t\t\t\t{\n\t\t\t\t\tnewvolume += 0x0F * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!pChn->isFirstTick || m_SongFlags[SONG_FASTVOLSLIDES] || (m_PlayState.m_nMusicSpeed == 1 && GetType() == MOD_TYPE_DBM))\n\t{\n\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (param & 0xF0) == 0)\n\t\t\t\tnewvolume -= (int)((param & 0x0F) * 4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewvolume += (int)((param & 0xF0) >> 2);\n\t\t}\n\t\tif (GetType() == MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n\tnewvolume = Clamp(newvolume, 0, 256);\n\n\tpChn->nVolume = newvolume;\n}\n\n\nvoid CSoundFile::PanningSlide(ModChannel *pChn, ModCommand::PARAM param, bool memory)\n{\n\tif(memory)\n\t{\n\t\t// FT2 compatibility: Use effect memory (lxx and rxx in XM shouldn't use effect memory).\n\t\t// Test case: PanSlideMem.xm\n\t\tif(param)\n\t\t\tpChn->nOldPanSlide = param;\n\t\telse\n\t\t\tparam = pChn->nOldPanSlide;\n\t}\n\n\tif((GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\t// XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tint32 nPanSlide = 0;\n\n\tif(!(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tparam = (param & 0xF0) / 4u;\n\t\t\t\tnPanSlide = - (int)param;\n\t\t\t}\n\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tnPanSlide = (param & 0x0F) * 4u;\n\t\t\t}\n\t\t} else if(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0x0F)\n\t\t\t{\n\t\t\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (param & 0xF0) == 0)\n\t\t\t\t\tnPanSlide = (int)((param & 0x0F) * 4u);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnPanSlide = -(int)((param & 0xF0) / 4u);\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0xF0)\n\t\t\t{\n\t\t\t\tnPanSlide = (int)((param & 0xF0) / 4u);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnPanSlide = -(int)((param & 0x0F) * 4u);\n\t\t\t}\n\t\t\t// FT2 compatibility: FT2's panning slide is like IT's fine panning slide (not as deep)\n\t\t\tif(m_playBehaviour[kFT2PanSlide])\n\t\t\t\tnPanSlide /= 4;\n\t\t}\n\t}\n\tif (nPanSlide)\n\t{\n\t\tnPanSlide += pChn->nPan;\n\t\tnPanSlide = Clamp(nPanSlide, 0, 256);\n\t\tpChn->nPan = nPanSlide;\n\t\tpChn->nRestorePanOnNewNote = 0;\n\t}\n}\n\n\nvoid CSoundFile::FineVolumeUp(ModChannel *pChn, ModCommand::PARAM param, bool volCol) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: EAx / EBx memory is not linked\n\t\t// Test case: FineVol-LinkMem.xm\n\t\tif(param) pChn->nOldFineVolUpDown = (param << 4) | (pChn->nOldFineVolUpDown & 0x0F); else param = (pChn->nOldFineVolUpDown >> 4);\n\t} else if(volCol)\n\t{\n\t\tif(param) pChn->nOldVolParam = param; else param = pChn->nOldVolParam;\n\t} else\n\t{\n\t\tif(param) pChn->nOldFineVolUpDown = param; else param = pChn->nOldFineVolUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->nVolume += param * 4;\n\t\tif(pChn->nVolume > 256) pChn->nVolume = 256;\n\t\tif(GetType() & MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n}\n\n\nvoid CSoundFile::FineVolumeDown(ModChannel *pChn, ModCommand::PARAM param, bool volCol) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: EAx / EBx memory is not linked\n\t\t// Test case: FineVol-LinkMem.xm\n\t\tif(param) pChn->nOldFineVolUpDown = param | (pChn->nOldFineVolUpDown & 0xF0); else param = (pChn->nOldFineVolUpDown & 0x0F);\n\t} else if(volCol)\n\t{\n\t\tif(param) pChn->nOldVolParam = param; else param = pChn->nOldVolParam;\n\t} else\n\t{\n\t\tif(param) pChn->nOldFineVolUpDown = param; else param = pChn->nOldFineVolUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->nVolume -= param * 4;\n\t\tif(pChn->nVolume < 0) pChn->nVolume = 0;\n\t\tif(GetType() & MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n}\n\n\nvoid CSoundFile::Tremolo(ModChannel *pChn, uint32 param) const\n{\n\tif (param & 0x0F) pChn->nTremoloDepth = (param & 0x0F) << 2;\n\tif (param & 0xF0) pChn->nTremoloSpeed = (param >> 4) & 0x0F;\n\tpChn->dwFlags.set(CHN_TREMOLO);\n}\n\n\nvoid CSoundFile::ChannelVolSlide(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tint32 nChnSlide = 0;\n\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\n\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nChnSlide = param >> 4;\n\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nChnSlide = - (int)(param & 0x0F);\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0x0F)\n\t\t\t{\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_J2B | MOD_TYPE_DBM)) || (param & 0xF0) == 0)\n\t\t\t\t\tnChnSlide = -(int)(param & 0x0F);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnChnSlide = (int)((param & 0xF0) >> 4);\n\t\t\t}\n\t\t}\n\t}\n\tif (nChnSlide)\n\t{\n\t\tnChnSlide += pChn->nGlobalVol;\n\t\tnChnSlide = Clamp(nChnSlide, 0, 64);\n\t\tpChn->nGlobalVol = nChnSlide;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedMODCommands(CHANNELINDEX nChn, ModCommand::PARAM param)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\tuint8 command = param & 0xF0;\n\tparam &= 0x0F;\n\tswitch(command)\n\t{\n\t// E0x: Set Filter\n\tcase 0x00:\n\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t{\n\t\t\tm_PlayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t}\n\t\tbreak;\n\t// E1x: Fine Portamento Up\n\tcase 0x10:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FinePortamentoUp(pChn, param); break;\n\t// E2x: Fine Portamento Down\n\tcase 0x20:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FinePortamentoDown(pChn, param); break;\n\t// E3x: Set Glissando Control\n\tcase 0x30:\tpChn->dwFlags.set(CHN_GLISSANDO, param != 0); break;\n\t// E4x: Set Vibrato WaveForm\n\tcase 0x40:\tpChn->nVibratoType = param & 0x07; break;\n\t// E5x: Set FineTune\n\tcase 0x50:\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(GetType() & (MOD_TYPE_MOD | MOD_TYPE_DIGI | MOD_TYPE_AMF0 | MOD_TYPE_MED))\n\t\t\t\t{\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param);\n\t\t\t\t\tif(pChn->nPeriod && pChn->rowCommand.IsNote()) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t} else if(pChn->rowCommand.IsNote())\n\t\t\t\t{\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param - 8);\n\t\t\t\t\tif(pChn->nPeriod) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// E6x: Pattern Loop\n\t// E7x: Set Tremolo WaveForm\n\tcase 0x70:\tpChn->nTremoloType = param & 0x07; break;\n\t// E8x: Set 4-bit Panning\n\tcase 0x80:\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tPanning(pChn, param, Pan4bit);\n\t\t}\n\t\tbreak;\n\t// E9x: Retrig\n\tcase 0x90:\tRetrigNote(nChn, param); break;\n\t// EAx: Fine Volume Up\n\tcase 0xA0:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FineVolumeUp(pChn, param, false); break;\n\t// EBx: Fine Volume Down\n\tcase 0xB0:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FineVolumeDown(pChn, param, false); break;\n\t// ECx: Note Cut\n\tcase 0xC0:\tNoteCut(nChn, param, false); break;\n\t// EDx: Note Delay\n\t// EEx: Pattern Delay\n\tcase 0xF0:\n\t\tif(GetType() == MOD_TYPE_MOD) // MOD: Invert Loop\n\t\t{\n\t\t\tpChn->nEFxSpeed = param;\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK]) InvertLoop(pChn);\n\t\t} else // XM: Set Active Midi Macro\n\t\t{\n\t\t\tpChn->nActiveMacro = param;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedS3MCommands(CHANNELINDEX nChn, ModCommand::PARAM param)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\tuint8 command = param & 0xF0;\n\tparam &= 0x0F;\n\tswitch(command)\n\t{\n\t// S0x: Set Filter\n\t// S1x: Set Glissando Control\n\tcase 0x10:\tpChn->dwFlags.set(CHN_GLISSANDO, param != 0); break;\n\t// S2x: Set FineTune\n\tcase 0x20:\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\t\tif(GetType() != MOD_TYPE_669)\n\t\t\t\t{\n\t\t\t\t\tpChn->nC5Speed = S3MFineTuneTable[param];\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param);\n\t\t\t\t\tif (pChn->nPeriod) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t} else if(pChn->pModSample != nullptr)\n\t\t\t\t{\n\t\t\t\t\tpChn->nC5Speed = pChn->pModSample->nC5Speed + param * 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S3x: Set Vibrato Waveform\n\tcase 0x30:\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVibratoType = param & 0x03;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tpChn->nVibratoType = (param < 0x04) ? param : 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tpChn->nVibratoType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S4x: Set Tremolo Waveform\n\tcase 0x40:\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t{\n\t\t\t\t\tpChn->nTremoloType = param & 0x03;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tpChn->nTremoloType = (param < 0x04) ? param : 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tpChn->nTremoloType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S5x: Set Panbrello Waveform\n\tcase 0x50:\n\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPanbrelloType = (param < 0x04) ? param : 0;\n\t\t\t\t\tpChn->nPanbrelloPos = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tpChn->nPanbrelloType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S6x: Pattern Delay for x frames\n\tcase 0x60:\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && m_PlayState.m_nTickCount == 0)\n\t\t\t\t{\n\t\t\t\t\t// Tick delays are added up.\n\t\t\t\t\t// Scream Tracker 3 does actually not support this command.\n\t\t\t\t\t// We'll use the same behaviour as for Impulse Tracker, as we can assume that\n\t\t\t\t\t// most S3Ms that make use of this command were made with Impulse Tracker.\n\t\t\t\t\t// MPT added this command to the XM format through the X6x effect, so we will use\n\t\t\t\t\t// the same behaviour here as well.\n\t\t\t\t\t// Test cases: PatternDelays.it, PatternDelays.s3m, PatternDelays.xm\n\t\t\t\t\tm_PlayState.m_nFrameDelay += param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S7x: Envelope Control / Instrument Control\n\tcase 0x70:\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\t\tswitch(param)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\t\t{\n\t\t\t\t\t\tModChannel *bkp = &m_PlayState.Chn[m_nChannels];\n\t\t\t\t\t\tfor (CHANNELINDEX i=m_nChannels; i<MAX_CHANNELS; i++, bkp++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (bkp->nMasterChn == nChn+1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (param == 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyOff(bkp);\n\t\t\t\t\t\t\t\t} else if (param == 2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbkp->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbkp->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t\t\t\tbkp->nFadeOutVol = 0;\n\t\t\t\t\t\t\t\t}\n#ifndef NO_PLUGINS\n\t\t\t\t\t\t\t\tconst ModInstrument *pIns = bkp->pModInstrument;\n\t\t\t\t\t\t\t\tIMixPlugin *pPlugin;\n\t\t\t\t\t\t\t\tif(pIns != nullptr && pIns->nMixPlug && (pPlugin = m_MixPlugins[pIns->nMixPlug - 1].pMixPlugin) != nullptr)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpPlugin->MidiCommand(GetBestMidiChannel(nChn), pIns->nMidiProgram, pIns->wMidiBank, bkp->nNote + NOTE_MAX_SPECIAL, 0, nChn);\n\t\t\t\t\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t\tpChn->nNNA = NNA_NOTECUT; break;\n\t\t\t\tcase 4:\t\tpChn->nNNA = NNA_CONTINUE; break;\n\t\t\t\tcase 5:\t\tpChn->nNNA = NNA_NOTEOFF; break;\n\t\t\t\tcase 6:\t\tpChn->nNNA = NNA_NOTEFADE; break;\n\t\t\t\tcase 7:\t\tpChn->VolEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 8:\t\tpChn->VolEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 9:\t\tpChn->PanEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 10:\tpChn->PanEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 11:\tpChn->PitchEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 12:\tpChn->PitchEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 13:\t// S7D: Enable pitch envelope, force to play as pitch envelope\n\t\t\t\tcase 14:\t// S7E: Enable pitch envelope, force to play as filter envelope\n\t\t\t\t\tif(GetType() == MOD_TYPE_MPT)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->PitchEnv.flags.set(ENV_ENABLED);\n\t\t\t\t\t\tpChn->PitchEnv.flags.set(ENV_FILTER, param != 13);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S8x: Set 4-bit Panning\n\tcase 0x80:\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tPanning(pChn, param, Pan4bit);\n\t\t}\n\t\tbreak;\n\t// S9x: Sound Control\n\tcase 0x90:\tExtendedChannelEffect(pChn, param); break;\n\t// SAx: Set 64k Offset\n\tcase 0xA0:\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\tpChn->nOldHiOffset = static_cast<uint8>(param);\n\t\t\t\t\tif (!m_playBehaviour[kITHighOffsetNoRetrig] && pChn->rowCommand.IsNote())\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength pos = param << 16;\n\t\t\t\t\t\tif (pos < pChn->nLength) pChn->position.SetInt(pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// SBx: Pattern Loop\n\t// SCx: Note Cut\n\tcase 0xC0:\n\t\tif(param == 0)\n\t\t{\n\t\t\t//IT compatibility 22. SC0 == SC1\n\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))\n\t\t\t\tparam = 1;\n\t\t\t// ST3 doesn't cut notes with SC0\n\t\t\telse if(GetType() == MOD_TYPE_S3M)\n\t\t\t\treturn;\n\t\t}\n\t\t// S3M/IT compatibility: Note Cut really cuts notes and does not just mute them (so that following volume commands could restore the sample)\n\t\t// Test case: scx.it\n\t\tNoteCut(nChn, param, m_playBehaviour[kITSCxStopsSample] || GetType() == MOD_TYPE_S3M);\n\t\tbreak;\n\t// SDx: Note Delay\n\t// SEx: Pattern Delay for x rows\n\t// SFx: S3M: Not used, IT: Set Active Midi Macro\n\tcase 0xF0:\n\t\tif(GetType() != MOD_TYPE_S3M)\n\t\t{\n\t\t\tpChn->nActiveMacro = static_cast<uint8>(param);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedChannelEffect(ModChannel *pChn, uint32 param)\n{\n\t// S9x and X9x commands (S3M/XM/IT only)\n\tif(!m_SongFlags[SONG_FIRSTTICK]) return;\n\tswitch(param & 0x0F)\n\t{\n\t// S90: Surround Off\n\tcase 0x00:\tpChn->dwFlags.reset(CHN_SURROUND);\tbreak;\n\t// S91: Surround On\n\tcase 0x01:\tpChn->dwFlags.set(CHN_SURROUND); pChn->nPan = 128; break;\n\n\t////////////////////////////////////////////////////////////\n\t// ModPlug Extensions\n\t// S98: Reverb Off\n\tcase 0x08:\n\t\tpChn->dwFlags.reset(CHN_REVERB);\n\t\tpChn->dwFlags.set(CHN_NOREVERB);\n\t\tbreak;\n\t// S99: Reverb On\n\tcase 0x09:\n\t\tpChn->dwFlags.reset(CHN_NOREVERB);\n\t\tpChn->dwFlags.set(CHN_REVERB);\n\t\tbreak;\n\t// S9A: 2-Channels surround mode\n\tcase 0x0A:\n\t\tm_SongFlags.reset(SONG_SURROUNDPAN);\n\t\tbreak;\n\t// S9B: 4-Channels surround mode\n\tcase 0x0B:\n\t\tm_SongFlags.set(SONG_SURROUNDPAN);\n\t\tbreak;\n\t// S9C: IT Filter Mode\n\tcase 0x0C:\n\t\tm_SongFlags.reset(SONG_MPTFILTERMODE);\n\t\tbreak;\n\t// S9D: MPT Filter Mode\n\tcase 0x0D:\n\t\tm_SongFlags.set(SONG_MPTFILTERMODE);\n\t\tbreak;\n\t// S9E: Go forward\n\tcase 0x0E:\n\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\tbreak;\n\t// S9F: Go backward (and set playback position to the end if sample just started)\n\tcase 0x0F:\n\t\tif(pChn->position.IsZero() && pChn->nLength && (pChn->rowCommand.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t{\n\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t}\n\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::InvertLoop(ModChannel *pChn)\n{\n\t// EFx implementation for MOD files (PT 1.1A and up: Invert Loop)\n\t// This effect trashes samples. Thanks to 8bitbubsy for making this work. :)\n\tif(GetType() != MOD_TYPE_MOD || pChn->nEFxSpeed == 0) return;\n\n\t// we obviously also need a sample for this\n\tModSample *pModSample = const_cast<ModSample *>(pChn->pModSample);\n\tif(pModSample == nullptr || !pModSample->HasSampleData() || !pModSample->uFlags[CHN_LOOP] || pModSample->uFlags[CHN_16BIT]) return;\n\n\tpChn->nEFxDelay += ModEFxTable[pChn->nEFxSpeed & 0x0F];\n\tif((pChn->nEFxDelay & 0x80) == 0) return; // only applied if the \"delay\" reaches 128\n\tpChn->nEFxDelay = 0;\n\n\tif (++pChn->nEFxOffset >= pModSample->nLoopEnd - pModSample->nLoopStart)\n\t\tpChn->nEFxOffset = 0;\n\n\t// TRASH IT!!! (Yes, the sample!)\n\tuint8 &sample = mpt::byte_cast<uint8 *>(pModSample->sampleb())[pModSample->nLoopStart + pChn->nEFxOffset];\n\tsample = ~sample;\n\tctrlSmp::PrecomputeLoops(*pModSample, *this, false);\n}\n\n\n// Process a MIDI Macro.\n// Parameters:\n// [in] nChn: Mod channel to apply macro on\n// [in] isSmooth: If true, internal macros are interpolated between two rows\n// [in] macro: Actual MIDI Macro string\n// [in] param: Parameter for parametric macros (Z00 - Z7F)\n// [in] plugin: Plugin to send MIDI message to (if not specified but needed, it is autodetected)\nvoid CSoundFile::ProcessMIDIMacro(CHANNELINDEX nChn, bool isSmooth, const char *macro, uint8 param, PLUGINDEX plugin)\n{\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tconst ModInstrument *pIns = GetNumInstruments() ? chn.pModInstrument : nullptr;\n\n\tuint8 out[MACRO_LENGTH];\n\tuint32 outPos = 0;\t// output buffer position, which also equals the number of complete bytes\n\tconst uint8 lastZxxParam = chn.lastZxxParam;\n\tbool firstNibble = true;\n\n\tfor(uint32 pos = 0; pos < (MACRO_LENGTH - 1) && macro[pos]; pos++)\n\t{\n\t\tbool isNibble = false;\t\t// did we parse a nibble or a byte value?\n\t\tuint8 data = 0;\t\t// data that has just been parsed\n\n\t\t// Parse next macro byte... See Impulse Tracker's MIDI.TXT for detailed information on each possible character.\n\t\tif(macro[pos] >= '0' && macro[pos] <= '9')\n\t\t{\n\t\t\tisNibble = true;\n\t\t\tdata = static_cast<uint8>(macro[pos] - '0');\n\t\t}\n\t\telse if(macro[pos] >= 'A' && macro[pos] <= 'F')\n\t\t{\n\t\t\tisNibble = true;\n\t\t\tdata = static_cast<uint8>(macro[pos] - 'A' + 0x0A);\n\t\t} else if(macro[pos] == 'c')\n\t\t{\n\t\t\t// MIDI channel\n\t\t\tisNibble = true;\n\t\t\tdata = GetBestMidiChannel(nChn);\n\t\t} else if(macro[pos] == 'n')\n\t\t{\n\t\t\t// Last triggered note\n\t\t\tif(ModCommand::IsNote(chn.nLastNote))\n\t\t\t{\n\t\t\t\tdata = chn.nLastNote - NOTE_MIN;\n\t\t\t}\n\t\t} else if(macro[pos] == 'v')\n\t\t{\n\t\t\t// Velocity\n\t\t\t// This is \"almost\" how IT does it - apparently, IT seems to lag one row behind on global volume or channel volume changes.\n\t\t\tconst int swing = (m_playBehaviour[kITSwingBehaviour] || m_playBehaviour[kMPTOldSwingBehaviour]) ? chn.nVolSwing : 0;\n\t\t\tconst int vol = Util::muldiv((chn.nVolume + swing) * m_PlayState.m_nGlobalVolume, chn.nGlobalVol * chn.nInsVol, 1 << 20);\n\t\t\tdata = static_cast<uint8>(Clamp(vol / 2, 1, 127));\n\t\t\t//data = (unsigned char)MIN((chn.nVolume * chn.nGlobalVol * m_nGlobalVolume) >> (1 + 6 + 8), 127);\n\t\t} else if(macro[pos] == 'u')\n\t\t{\n\t\t\t// Calculated volume\n\t\t\t// Same note as with velocity applies here, but apparently also for instrument / sample volumes?\n\t\t\tconst int vol = Util::muldiv(chn.nCalcVolume * m_PlayState.m_nGlobalVolume, chn.nGlobalVol * chn.nInsVol, 1 << 26);\n\t\t\tdata = static_cast<uint8>(Clamp(vol / 2, 1, 127));\n\t\t\t//data = (unsigned char)MIN((chn.nCalcVolume * chn.nGlobalVol * m_nGlobalVolume) >> (7 + 6 + 8), 127);\n\t\t} else if(macro[pos] == 'x')\n\t\t{\n\t\t\t// Pan set\n\t\t\tdata = static_cast<uint8>(std::min(chn.nPan / 2, 127));\n\t\t} else if(macro[pos] == 'y')\n\t\t{\n\t\t\t// Calculated pan\n\t\t\tdata = static_cast<uint8>(std::min(chn.nRealPan / 2, 127));\n\t\t} else if(macro[pos] == 'a')\n\t\t{\n\t\t\t// High byte of bank select\n\t\t\tif(pIns && pIns->wMidiBank)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>(((pIns->wMidiBank - 1) >> 7) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'b')\n\t\t{\n\t\t\t// Low byte of bank select\n\t\t\tif(pIns && pIns->wMidiBank)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>((pIns->wMidiBank - 1) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'o')\n\t\t{\n\t\t\t// Offset (ignoring high offset)\n\t\t\tdata = static_cast<uint8>((chn.oldOffset >> 8) & 0xFF);\n\t\t} else if(macro[pos] == 'h')\n\t\t{\n\t\t\t// Host channel number\n\t\t\tdata = static_cast<uint8>((nChn >= GetNumChannels() ? (chn.nMasterChn - 1) : nChn) & 0x7F);\n\t\t} else if(macro[pos] == 'm')\n\t\t{\n\t\t\t// Loop direction (judging from the character, it was supposed to be loop type, though)\n\t\t\tdata = chn.dwFlags[CHN_PINGPONGFLAG] ? 1 : 0;\n\t\t} else if(macro[pos] == 'p')\n\t\t{\n\t\t\t// Program select\n\t\t\tif(pIns && pIns->nMidiProgram)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>((pIns->nMidiProgram - 1) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'z')\n\t\t{\n\t\t\t// Zxx parameter\n\t\t\tdata = param & 0x7F;\n\t\t\tif(isSmooth && chn.lastZxxParam < 0x80\n\t\t\t\t&& (outPos < 3 || out[outPos - 3] != 0xF0 || out[outPos - 2] < 0xF0))\n\t\t\t{\n\t\t\t\t// Interpolation for external MIDI messages - interpolation for internal messages\n\t\t\t\t// is handled separately to allow for more than 7-bit granularity where it's possible\n\t\t\t\tdata = static_cast<uint8>(CalculateSmoothParamChange((float)lastZxxParam, (float)data));\n\t\t\t}\n\t\t\tchn.lastZxxParam = data;\n\t\t} else if(macro[pos] == 's')\n\t\t{\n\t\t\t// SysEx Checksum (not an original Impulse Tracker macro variable, but added for convenience)\n\t\t\tuint32 startPos = outPos;\n\t\t\twhile(startPos > 0 && out[--startPos] != 0xF0);\n\t\t\tif(outPos - startPos < 5 || out[startPos] != 0xF0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(uint32 p = startPos + 5; p != outPos; p++)\n\t\t\t{\n\t\t\t\tdata += out[p];\n\t\t\t}\n\t\t\tdata = (~data + 1) & 0x7F;\n\t\t} else\n\t\t{\n\t\t\t// Unrecognized byte (e.g. space char)\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Append parsed data\n\t\tif(isNibble)\t// parsed a nibble (constant or 'c' variable)\n\t\t{\n\t\t\tif(firstNibble)\n\t\t\t{\n\t\t\t\tout[outPos] = data;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tout[outPos] = (out[outPos] << 4) | data;\n\t\t\t\toutPos++;\n\t\t\t}\n\t\t\tfirstNibble = !firstNibble;\n\t\t} else\t\t\t// parsed a byte (variable)\n\t\t{\n\t\t\tif(!firstNibble)\t// From MIDI.TXT: '9n' is exactly the same as '09 n' or '9 n' -- so finish current byte first\n\t\t\t{\n\t\t\t\toutPos++;\n\t\t\t}\n\t\t\tout[outPos++] = data;\n\t\t\tfirstNibble = true;\n\t\t}\n\t}\n\tif(!firstNibble)\n\t{\n\t\t// Finish current byte\n\t\toutPos++;\n\t}\n\n\t// Macro string has been parsed and translated, now send the message(s)...\n\tuint32 sendPos = 0;\n\tuint8 runningStatus = 0;\n\twhile(sendPos < outPos)\n\t{\n\t\tuint32 sendLen = 0;\n\t\tif(out[sendPos] == 0xF0)\n\t\t{\n\t\t\t// SysEx start\n\t\t\tif((outPos - sendPos >= 4) && (out[sendPos + 1] == 0xF0 || out[sendPos + 1] == 0xF1))\n\t\t\t{\n\t\t\t\t// Internal macro (normal (F0F0) or extended (F0F1)), 4 bytes long\n\t\t\t\tsendLen = 4;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// SysEx message, find end of message\n\t\t\t\tfor(uint32 i = sendPos + 1; i < outPos; i++)\n\t\t\t\t{\n\t\t\t\t\tif(out[i] == 0xF7)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Found end of SysEx message\n\t\t\t\t\t\tsendLen = i - sendPos + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sendLen == 0)\n\t\t\t\t{\n\t\t\t\t\t// Didn't find end, so \"invent\" end of SysEx message\n\t\t\t\t\tout[outPos++] = 0xF7;\n\t\t\t\t\tsendLen = outPos - sendPos;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(!(out[sendPos] & 0x80))\n\t\t{\n\t\t\t// Missing status byte? Try inserting running status\n\t\t\tif(runningStatus != 0)\n\t\t\t{\n\t\t\t\tsendPos--;\n\t\t\t\tout[sendPos] = runningStatus;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// No running status to re-use; skip this byte\n\t\t\t\tsendPos++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else\n\t\t{\n\t\t\t// Other MIDI messages\n\t\t\tsendLen = std::min<uint32>(MIDIEvents::GetEventLength(out[sendPos]), outPos - sendPos);\n\t\t}\n\n\t\tif(sendLen == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif(out[sendPos] < 0xF0)\n\t\t{\n\t\t\trunningStatus = out[sendPos];\n\t\t}\n\t\tuint32 bytesSent = SendMIDIData(nChn, isSmooth, out + sendPos, sendLen, plugin);\n\t\t// If there's no error in the macro data (e.g. unrecognized internal MIDI macro), we have sendLen == bytesSent.\n\t\tif(bytesSent > 0)\n\t\t{\n\t\t\tsendPos += bytesSent;\n\t\t} else\n\t\t{\n\t\t\tsendPos += sendLen;\n\t\t}\n\t}\n}\n\n\n// Calculate smooth MIDI macro slide parameter for current tick.\nfloat CSoundFile::CalculateSmoothParamChange(float currentValue, float param) const\n{\n\tMPT_ASSERT(GetNumTicksOnCurrentRow() > m_PlayState.m_nTickCount);\n\tconst uint32 ticksLeft = GetNumTicksOnCurrentRow() - m_PlayState.m_nTickCount;\n\tif(ticksLeft > 1)\n\t{\n\t\t// Slide param\n\t\tconst float step = (param - currentValue) / (float)ticksLeft;\n\t\treturn (currentValue + step);\n\t} else\n\t{\n\t\t// On last tick, set exact value.\n\t\treturn param;\n\t}\n}\n\n\n// Process exactly one MIDI message parsed by ProcessMIDIMacro. Returns bytes sent on success, 0 on (parse) failure.\nuint32 CSoundFile::SendMIDIData(CHANNELINDEX nChn, bool isSmooth, const unsigned char *macro, uint32 macroLen, PLUGINDEX plugin)\n{\n\tif(macroLen < 1)\n\t{\n\t\treturn 0;\n\t}\n\n\tif(macro[0] == 0xFA || macro[0] == 0xFC || macro[0] == 0xFF)\n\t{\n\t\t// Start Song, Stop Song, MIDI Reset - both interpreted internally and sent to plugins\n\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t{\n\t\t\tm_PlayState.Chn[chn].nCutOff = 0x7F;\n\t\t\tm_PlayState.Chn[chn].nResonance = 0x00;\n\t\t}\n\t}\n\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tif(macro[0] == 0xF0 && (macro[1] == 0xF0 || macro[1] == 0xF1))\n\t{\n\t\t// Internal device.\n\t\tif(macroLen < 4)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tconst bool isExtended = (macro[1] == 0xF1);\n\t\tconst uint8 macroCode = macro[2];\n\t\tconst uint8 param = macro[3];\n\n\t\tif(macroCode == 0x00 && !isExtended && param < 0x80)\n\t\t{\n\t\t\t// F0.F0.00.xx: Set CutOff\n\t\t\tif(!isSmooth)\n\t\t\t{\n\t\t\t\tchn.nCutOff = param;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tchn.nCutOff = Util::Round<uint8>(CalculateSmoothParamChange(chn.nCutOff, param));\n\t\t\t}\n\t\t\tchn.nRestoreCutoffOnNewNote = 0;\n\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\n\t\t\treturn 4;\n\t\t} else if(macroCode == 0x01 && !isExtended && param < 0x80)\n\t\t{\n\t\t\t// F0.F0.01.xx: Set Resonance\n\t\t\tif(!isSmooth)\n\t\t\t{\n\t\t\t\tchn.nResonance = param;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tchn.nResonance = (uint8)CalculateSmoothParamChange((float)chn.nResonance, (float)param);\n\t\t\t}\n\t\t\tchn.nRestoreResonanceOnNewNote = 0;\n\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\n\t\t\treturn 4;\n\t\t} else if(macroCode == 0x02 && !isExtended)\n\t\t{\n\t\t\t// F0.F0.02.xx: Set filter mode (high nibble determines filter mode)\n\t\t\tif(param < 0x20)\n\t\t\t{\n\t\t\t\tchn.nFilterMode = (param >> 4);\n\t\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\t\t\t}\n\n\t\t\treturn 4;\n#ifndef NO_PLUGINS\n\t\t} else if(macroCode == 0x03 && !isExtended)\n\t\t{\n\t\t\t// F0.F0.03.xx: Set plug dry/wet\n\t\t\tconst PLUGINDEX nPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\tif ((nPlug) && (nPlug <= MAX_MIXPLUGINS) && param < 0x80)\n\t\t\t{\n\t\t\t\tconst float newRatio = (0x7F - (param & 0x7F)) / 127.0f;\n\t\t\t\tif(!isSmooth)\n\t\t\t\t{\n\t\t\t\t\tm_MixPlugins[nPlug - 1].fDryRatio = newRatio;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tm_MixPlugins[nPlug - 1].fDryRatio = CalculateSmoothParamChange(m_MixPlugins[nPlug - 1].fDryRatio, newRatio);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t} else if((macroCode & 0x80) || isExtended)\n\t\t{\n\t\t\t// F0.F0.{80|n}.xx / F0.F1.n.xx: Set VST effect parameter n to xx\n\t\t\tconst PLUGINDEX nPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\tconst uint32 plugParam = isExtended ? (0x80 + macroCode) : (macroCode & 0x7F);\n\t\t\tif((nPlug) && (nPlug <= MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tIMixPlugin *pPlugin = m_MixPlugins[nPlug - 1].pMixPlugin;\n\t\t\t\tif(pPlugin && param < 0x80)\n\t\t\t\t{\n\t\t\t\t\tconst float fParam = param / 127.0f;\n\t\t\t\t\tif(!isSmooth)\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->SetParameter(plugParam, fParam);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->SetParameter(plugParam, CalculateSmoothParamChange(pPlugin->GetParameter(plugParam), fParam));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 4;\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// If we reach this point, the internal macro was invalid.\n\n\t} else\n\t{\n#ifndef NO_PLUGINS\n\t\t// Not an internal device. Pass on to appropriate plugin.\n\t\tconst CHANNELINDEX plugChannel = (nChn < GetNumChannels()) ? nChn + 1 : chn.nMasterChn;\n\t\tif(plugChannel > 0 && plugChannel <= GetNumChannels())\t// XXX do we need this? I guess it might be relevant for previewing notes in the pattern... Or when using this mechanism for volume/panning!\n\t\t{\n\t\t\tPLUGINDEX nPlug = 0;\n\t\t\tif(!chn.dwFlags[CHN_NOFX])\n\t\t\t{\n\t\t\t\tnPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\t}\n\n\t\t\tif(nPlug > 0 && nPlug <= MAX_MIXPLUGINS)\n\t\t\t{\n\t\t\t\tIMixPlugin *pPlugin = m_MixPlugins[nPlug - 1].pMixPlugin;\n\t\t\t\tif (pPlugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(macro[0] == 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->MidiSysexSend(macro, macroLen);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 len = std::min<uint32>(MIDIEvents::GetEventLength(macro[0]), macroLen);\n\t\t\t\t\t\tuint32 curData = 0;\n\t\t\t\t\t\tmemcpy(&curData, macro, len);\n\t\t\t\t\t\tpPlugin->MidiSend(curData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tMPT_UNREFERENCED_PARAMETER(plugin);\n#endif // NO_PLUGINS\n\n\t\treturn macroLen;\n\n\t}\n\n\treturn 0;\n\n}\n\n\nvoid CSoundFile::SendMIDINote(CHANNELINDEX chn, uint16 note, uint16 volume)\n{\n#ifndef NO_PLUGINS\n\tauto &channel = m_PlayState.Chn[chn];\n\tconst ModInstrument *pIns = channel.pModInstrument;\n\t// instro sends to a midi chan\n\tif (pIns && pIns->HasValidMIDIChannel())\n\t{\n\t\tPLUGINDEX nPlug = pIns->nMixPlug;\n\t\tif ((nPlug) && (nPlug <= MAX_MIXPLUGINS))\n\t\t{\n\t\t\tIMixPlugin *pPlug = m_MixPlugins[nPlug-1].pMixPlugin;\n\t\t\tif (pPlug != nullptr)\n\t\t\t{\n\t\t\t\tpPlug->MidiCommand(GetBestMidiChannel(chn), pIns->nMidiProgram, pIns->wMidiBank, note, volume, chn);\n\t\t\t\tif(note < NOTE_MIN_SPECIAL)\n\t\t\t\t\tchannel.nLeftVU = channel.nRightVU = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n#endif // NO_PLUGINS\n}\n\n\nvoid CSoundFile::SampleOffset(ModChannel &chn, SmpLength param) const\n{\n\tchn.proTrackerOffset += param;\n\n\tif(param >= chn.nLoopEnd && GetType() == MOD_TYPE_MTM && chn.dwFlags[CHN_LOOP] && chn.nLoopEnd > 0)\n\t{\n\t\t// Offset wrap-around\n\t\tparam = (param - chn.nLoopStart) % (chn.nLoopEnd - chn.nLoopStart) + chn.nLoopStart;\n\t}\n\n\tif(GetType() == MOD_TYPE_MDL && chn.dwFlags[CHN_16BIT])\n\t{\n\t\t// Digitrakker really uses byte offsets, not sample offsets. WTF!\n\t\tparam /= 2u;\n\t}\n\n\tif(chn.rowCommand.IsNote())\n\t{\n\t\t// IT compatibility: If this note is not mapped to a sample, ignore it.\n\t\t// Test case: empty_sample_offset.it\n\t\tif(chn.pModInstrument != nullptr)\n\t\t{\n\t\t\tSAMPLEINDEX smp = chn.pModInstrument->Keyboard[chn.rowCommand.note - NOTE_MIN];\n\t\t\tif(smp == 0 || smp > GetNumSamples())\n\t\t\t\treturn;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_PT_MODE])\n\t\t{\n\t\t\t// ProTracker compatbility: PT1/2-style funky 9xx offset command\n\t\t\t// Test case: ptoffset.mod\n\t\t\tchn.position.Set(chn.proTrackerOffset);\n\t\t\tchn.proTrackerOffset += param;\n\t\t} else\n\t\t{\n\t\t\tchn.position.Set(param);\n\t\t}\n\n\t\tif (chn.position.GetUInt() >= chn.nLength || (chn.dwFlags[CHN_LOOP] && chn.position.GetUInt() >= chn.nLoopEnd))\n\t\t{\n\t\t\t// Offset beyond sample size\n\t\t\tif (!(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MOD | MOD_TYPE_MTM)))\n\t\t\t{\n\t\t\t\t// IT Compatibility: Offset\n\t\t\t\tif(m_playBehaviour[kITOffset])\n\t\t\t\t{\n\t\t\t\t\tif(m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t\t\tchn.position.Set(chn.nLength); // Old FX: Clip to end of sample\n\t\t\t\t\telse\n\t\t\t\t\t\tchn.position.Set(0); // Reset to beginning of sample\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tchn.position.Set(chn.nLoopStart);\n\t\t\t\t\tif(m_SongFlags[SONG_ITOLDEFFECTS] && chn.nLength > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tchn.position.Set(chn.nLength - 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(m_playBehaviour[kFT2OffsetOutOfRange] || GetType() == MOD_TYPE_MTM)\n\t\t\t{\n\t\t\t\t// FT2 Compatibility: Don't play note if offset is beyond sample length\n\t\t\t\t// Test case: 3xx-no-old-samp.xm\n\t\t\t\tchn.dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\tchn.nPeriod = 0;\n\t\t\t} else if(GetType() == MOD_TYPE_MOD && chn.dwFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tchn.position.Set(chn.nLoopStart);\n\t\t\t}\n\t\t}\n\t} else if ((param < chn.nLength) && (GetType() & (MOD_TYPE_MTM | MOD_TYPE_DMF | MOD_TYPE_MDL | MOD_TYPE_PLM)))\n\t{\n\t\t// Some trackers can also call offset effects without notes next to them...\n\t\tchn.position.Set(param);\n\t}\n}\n\n\n// \nvoid CSoundFile::ReverseSampleOffset(ModChannel &chn, ModCommand::PARAM param) const\n{\n\tif(chn.pModSample != nullptr)\n\t{\n\t\tchn.dwFlags.set(CHN_PINGPONGFLAG);\n\t\tchn.dwFlags.reset(CHN_LOOP);\n\t\tchn.nLength = chn.pModSample->nLength;\t// If there was a loop, extend sample to whole length.\n\t\tchn.position.Set((chn.nLength - 1) - std::min<SmpLength>(SmpLength(param) << 8, chn.nLength - 1), 0);\n\t}\n}\n\n\nvoid CSoundFile::RetrigNote(CHANNELINDEX nChn, int param, int offset)\n{\n\t// Retrig: bit 8 is set if it's the new XM retrig\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tint retrigSpeed = param & 0x0F;\n\tint16 retrigCount = chn.nRetrigCount;\n\tbool doRetrig = false;\n\n\t// IT compatibility 15. Retrigger\n\tif(m_playBehaviour[kITRetrigger])\n\t{\n\t\tif(m_PlayState.m_nTickCount == 0 && chn.rowCommand.note)\n\t\t{\n\t\t\tchn.nRetrigCount = param & 0xf;\n\t\t} else if(!chn.nRetrigCount || !--chn.nRetrigCount)\n\t\t{\n\t\t\tchn.nRetrigCount = param & 0xf;\n\t\t\tdoRetrig = true;\n\t\t}\n\t} else if(m_playBehaviour[kFT2Retrigger] && (param & 0x100))\n\t{\n\t\t// Buggy-like-hell FT2 Rxy retrig!\n\t\t// Test case: retrig.xm\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\t// Here are some really stupid things FT2 does on the first tick.\n\t\t\t// Test case: RetrigTick0.xm\n\t\t\tif(chn.rowCommand.instr > 0 && chn.rowCommand.IsNoteOrEmpty()) retrigCount = 1;\n\t\t\tif(chn.rowCommand.volcmd == VOLCMD_VOLUME && chn.rowCommand.vol != 0)\n\t\t\t{\n\t\t\t\t// I guess this condition simply checked if the volume byte was != 0 in FT2.\n\t\t\t\tchn.nRetrigCount = retrigCount;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(retrigCount >= retrigSpeed)\n\t\t{\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK] || !chn.rowCommand.IsNote())\n\t\t\t{\n\t\t\t\tdoRetrig = true;\n\t\t\t\tretrigCount = 0;\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\t// old routines\n\t\tif (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))\n\t\t{\n\t\t\tif (!retrigSpeed) retrigSpeed = 1;\n\t\t\tif ((retrigCount) && (!(retrigCount % retrigSpeed))) doRetrig = true;\n\t\t\tretrigCount++;\n\t\t} else if(GetType() == MOD_TYPE_MTM)\n\t\t{\n\t\t\t// In MultiTracker, E9x retriggers the last note at exactly the x-th tick of the row\n\t\t\tdoRetrig = m_PlayState.m_nTickCount == static_cast<uint32>(param & 0x0F) && retrigSpeed != 0;\n\t\t} else\n\t\t{\n\t\t\tint realspeed = retrigSpeed;\n\t\t\t// FT2 bug: if a retrig (Rxy) occurs together with a volume command, the first retrig interval is increased by one tick\n\t\t\tif ((param & 0x100) && (chn.rowCommand.volcmd == VOLCMD_VOLUME) && (chn.rowCommand.param & 0xF0)) realspeed++;\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK] || (param & 0x100))\n\t\t\t{\n\t\t\t\tif (!realspeed) realspeed = 1;\n\t\t\t\tif ((!(param & 0x100)) && (m_PlayState.m_nMusicSpeed) && (!(m_PlayState.m_nTickCount % realspeed))) doRetrig = true;\n\t\t\t\tretrigCount++;\n\t\t\t} else if (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)) retrigCount = 0;\n\t\t\tif (retrigCount >= realspeed)\n\t\t\t{\n\t\t\t\tif ((m_PlayState.m_nTickCount) || ((param & 0x100) && (!chn.rowCommand.note))) doRetrig = true;\n\t\t\t}\n\t\t\tif(m_playBehaviour[kFT2Retrigger] && param == 0)\n\t\t\t{\n\t\t\t\t// E90 = Retrig instantly, and only once\n\t\t\t\tdoRetrig = (m_PlayState.m_nTickCount == 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// IT compatibility: If a sample is shorter than the retrig time (i.e. it stops before the retrig counter hits zero), it is not retriggered.\n\t// Test case: retrig-short.it\n\tif(chn.nLength == 0 && m_playBehaviour[kITShortSampleRetrig] && !chn.HasMIDIOutput())\n\t{\n\t\treturn;\n\t}\n\n\tif(doRetrig)\n\t{\n\t\tuint32 dv = (param >> 4) & 0x0F;\n\t\tint vol = chn.nVolume;\n\t\tif (dv)\n\t\t{\n\n\t\t\t// FT2 compatibility: Retrig + volume will not change volume of retrigged notes\n\t\t\tif(!m_playBehaviour[kFT2Retrigger] || !(chn.rowCommand.volcmd == VOLCMD_VOLUME))\n\t\t\t{\n\t\t\t\tif (retrigTable1[dv])\n\t\t\t\t\tvol = (vol * retrigTable1[dv]) >> 4;\n\t\t\t\telse\n\t\t\t\t\tvol += ((int)retrigTable2[dv]) << 2;\n\t\t\t}\n\t\t\tLimit(vol, 0, 256);\n\n\t\t\tchn.dwFlags.set(CHN_FASTVOLRAMP);\n\t\t}\n\t\tuint32 note = chn.nNewNote;\n\t\tint32 oldPeriod = chn.nPeriod;\n\t\tif (note >= NOTE_MIN && note <= NOTE_MAX && chn.nLength)\n\t\t\tCheckNNA(nChn, 0, note, true);\n\t\tbool resetEnv = false;\n\t\tif(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))\n\t\t{\n\t\t\tif((chn.rowCommand.instr) && (param < 0x100))\n\t\t\t{\n\t\t\t\tInstrumentChange(&chn, chn.rowCommand.instr, false, false);\n\t\t\t\tresetEnv = true;\n\t\t\t}\n\t\t\tif (param < 0x100) resetEnv = true;\n\t\t}\n\t\tbool fading = chn.dwFlags[CHN_NOTEFADE];\n\t\t// IT compatibility: Really weird combination of envelopes and retrigger (see Storlek's q.it testcase)\n\t\t// Test case: retrig.it\n\t\tNoteChange(&chn, note, m_playBehaviour[kITRetrigger], resetEnv);\n\t\t// XM compatibility: Prevent NoteChange from resetting the fade flag in case an instrument number + note-off is present.\n\t\t// Test case: RetrigFade.xm\n\t\tif(fading && GetType() == MOD_TYPE_XM)\n\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\tchn.nVolume = vol;\n\t\tif(m_nInstruments)\n\t\t{\n\t\t\tchn.rowCommand.note = static_cast<ModCommand::NOTE>(note);\t// No retrig without note...\n#ifndef NO_PLUGINS\n\t\t\tProcessMidiOut(nChn);\t//Send retrig to Midi\n#endif // NO_PLUGINS\n\t\t}\n\t\tif ((GetType() & (MOD_TYPE_IT|MOD_TYPE_MPT)) && (!chn.rowCommand.note) && (oldPeriod)) chn.nPeriod = oldPeriod;\n\t\tif (!(GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))) retrigCount = 0;\n\t\t// IT compatibility: see previous IT compatibility comment =)\n\t\tif(m_playBehaviour[kITRetrigger]) chn.position.Set(0);\n\n\t\toffset--;\n\t\tif(offset >= 0 && offset <= static_cast<int>(CountOf(chn.pModSample->cues)) && chn.pModSample != nullptr)\n\t\t{\n\t\t\tif(offset == 0) offset = chn.oldOffset;\n\t\t\telse offset = chn.oldOffset = chn.pModSample->cues[offset - 1];\n\t\t\tSampleOffset(chn, offset);\n\t\t}\n\t}\n\n\t// buggy-like-hell FT2 Rxy retrig!\n\tif(m_playBehaviour[kFT2Retrigger] && (param & 0x100)) retrigCount++;\n\n\t// Now we can also store the retrig value for IT...\n\tif(!m_playBehaviour[kITRetrigger])\n\t\tchn.nRetrigCount = retrigCount;\n}\n\n\nvoid CSoundFile::DoFreqSlide(ModChannel *pChn, int32 nFreqSlide) const\n{\n\tif(!pChn->nPeriod) return;\n\tif(GetType() == MOD_TYPE_669)\n\t{\n\t\t// Like other oldskool trackers, Composer 669 doesn't have linear slides...\n\t\t// But the slides are done in Hertz rather than periods, meaning that they\n\t\t// are more effective in the lower notes (rather than the higher notes).\n\t\tnFreqSlide *= -20;\n\t}\n\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t{\n\t\t// IT Linear slides\n\t\tconst auto nOldPeriod = pChn->nPeriod;\n\t\tuint32 n = mpt::abs(nFreqSlide) / 4u;\n\t\tLimitMax(n, 255u);\n\t\tif(n != 0)\n\t\t{\n\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, nFreqSlide < 0 ? GetLinearSlideUpTable(this, n) : GetLinearSlideDownTable(this, n), 65536);\n\t\t\tif(pChn->nPeriod == nOldPeriod)\n\t\t\t{\n\t\t\t\tconst bool incPeriod = m_playBehaviour[kHertzInLinearMode] == (nFreqSlide < 0);\n\t\t\t\tif(incPeriod && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\telse if(!incPeriod && pChn->nPeriod > 1)\n\t\t\t\t\tpChn->nPeriod--;\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\tpChn->nPeriod += nFreqSlide;\n\t}\n\tif (pChn->nPeriod < 1)\n\t{\n\t\tpChn->nPeriod = 1;\n\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t{\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::NoteCut(CHANNELINDEX nChn, uint32 nTick, bool cutSample)\n{\n\tif (m_PlayState.m_nTickCount == nTick)\n\t{\n\t\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\t\tif(cutSample)\n\t\t{\n\t\t\tpChn->increment.Set(0);\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolume = 0;\n\t\t}\n\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\n\t\t// instro sends to a midi chan\n\t\tSendMIDINote(nChn, /*pChn->nNote+*/NOTE_MAX_SPECIAL, 0);\n\t}\n}\n\n\nvoid CSoundFile::KeyOff(ModChannel *pChn) const\n{\n\tconst bool bKeyOn = !pChn->dwFlags[CHN_KEYOFF];\n\tpChn->dwFlags.set(CHN_KEYOFF);\n\tif(pChn->pModInstrument != nullptr && !pChn->VolEnv.flags[ENV_ENABLED])\n\t{\n\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t}\n\tif (!pChn->nLength) return;\n\tif (pChn->dwFlags[CHN_SUSTAINLOOP] && pChn->pModSample && bKeyOn)\n\t{\n\t\tconst ModSample *pSmp = pChn->pModSample;\n\t\tif(pSmp->uFlags[CHN_LOOP])\n\t\t{\n\t\t\tif (pSmp->uFlags[CHN_PINGPONGLOOP])\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGLOOP);\n\t\t\telse\n\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGLOOP | CHN_PINGPONGFLAG);\n\t\t\tpChn->dwFlags.set(CHN_LOOP);\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t\tpChn->nLoopStart = pSmp->nLoopStart;\n\t\t\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\tif(pChn->position.GetUInt() > pChn->nLength)\n\t\t\t{\n\t\t\t\t// Test case: SusAfterLoop.it\n\t\t\t\tpChn->position.Set(pChn->position.GetInt() - pChn->nLength + pChn->nLoopStart);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->dwFlags.reset(CHN_LOOP | CHN_PINGPONGLOOP | CHN_PINGPONGFLAG);\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t}\n\t}\n\n\tif (pChn->pModInstrument)\n\t{\n\t\tconst ModInstrument *pIns = pChn->pModInstrument;\n\t\tif((pIns->VolEnv.dwFlags[ENV_LOOP] || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MDL))) && pIns->nFadeOut != 0)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t}\n\n\t\tif (pIns->VolEnv.nReleaseNode != ENV_RELEASE_NODE_UNSET && pChn->VolEnv.nEnvValueAtReleaseJump == NOT_YET_RELEASED)\n\t\t{\n\t\t\tpChn->VolEnv.nEnvValueAtReleaseJump = pIns->VolEnv.GetValueFromPosition(pChn->VolEnv.nEnvPosition, 256);\n\t\t\tpChn->VolEnv.nEnvPosition = pIns->VolEnv[pIns->VolEnv.nReleaseNode].tick;\n\t\t}\n\t}\n}\n\n\n//////////////////////////////////////////////////////////\n// CSoundFile: Global Effects\n\n\nvoid CSoundFile::SetSpeed(PlayState &playState, uint32 param) const\n{\n#ifdef MODPLUG_TRACKER\n\t// FT2 appears to be decrementing the tick count before checking for zero,\n\t// so it effectively counts down 65536 ticks with speed = 0 (song speed is a 16-bit variable in FT2)\n\tif(GetType() == MOD_TYPE_XM && !param)\n\t{\n\t\tplayState.m_nMusicSpeed = uint16_max;\n\t}\n#endif\t// MODPLUG_TRACKER\n\tif(param > 0) playState.m_nMusicSpeed = param;\n\tif(GetType() == MOD_TYPE_STM && param > 0)\n\t{\n\t\tplayState.m_nMusicSpeed = std::max<uint32>(param >> 4u, 1);\n\t\tplayState.m_nMusicTempo = ConvertST2Tempo(static_cast<uint8>(param));\n\t}\n}\n\n\n// Convert a ST2 tempo byte to classic tempo and speed combination\nTEMPO CSoundFile::ConvertST2Tempo(uint8 tempo)\n{\n\tstatic const uint8 ST2TempoFactor[] = { 140, 50, 25, 15, 10, 7, 6, 4, 3, 3, 2, 2, 2, 2, 1, 1 };\n\tstatic const uint32 st2MixingRate = 23863; // Highest possible setting in ST2\n\n\t// This underflows at tempo 06...0F, and the resulting tick lengths depend on the mixing rate.\n\tint32 samplesPerTick = st2MixingRate / (49 - ((ST2TempoFactor[tempo >> 4u] * (tempo & 0x0F)) >> 4u));\n\tif(samplesPerTick <= 0)\n\t\tsamplesPerTick += 65536;\n\treturn TEMPO().SetRaw(Util::muldivrfloor(st2MixingRate, 5 * TEMPO::fractFact, samplesPerTick * 2));\n}\n\n\nvoid CSoundFile::SetTempo(TEMPO param, bool setFromUI)\n{\n\tconst CModSpecifications &specs = GetModSpecifications();\n\n\t// Anything lower than the minimum tempo is considered to be a tempo slide\n\tconst TEMPO minTempo = (GetType() == MOD_TYPE_MDL) ? TEMPO(1, 0) : TEMPO(32, 0);\n\n\tif(setFromUI)\n\t{\n\t\t// Set tempo from UI - ignore slide commands and such.\n\t\tm_PlayState.m_nMusicTempo = Clamp(param, specs.GetTempoMin(), specs.GetTempoMax());\n\t} else if(param >= minTempo && m_SongFlags[SONG_FIRSTTICK] == !m_playBehaviour[kMODTempoOnSecondTick])\n\t{\n\t\t// ProTracker sets the tempo after the first tick.\n\t\t// Note: The case of one tick per row is handled in ProcessRow() instead.\n\t\t// Test case: TempoChange.mod\n\t\tm_PlayState.m_nMusicTempo = std::min(param, specs.GetTempoMax());\n\t} else if(param < minTempo && !m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\t// Tempo Slide\n\t\tTEMPO tempDiff(param.GetInt() & 0x0F, 0);\n\t\tif((param.GetInt() & 0xF0) == 0x10)\n\t\t\tm_PlayState.m_nMusicTempo += tempDiff;\n\t\telse\n\t\t\tm_PlayState.m_nMusicTempo -= tempDiff;\n\n\t\tTEMPO tempoMin = specs.GetTempoMin(), tempoMax = specs.GetTempoMax();\n\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t{\n\t\t\ttempoMax.Set(255);\n\t\t}\n\t\tLimit(m_PlayState.m_nMusicTempo, tempoMin, tempoMax);\n\t}\n}\n\n\nROWINDEX CSoundFile::PatternLoop(ModChannel *pChn, uint32 param)\n{\n\tif (param)\n\t{\n\t\t// Loop Repeat\n\t\tif(pChn->nPatternLoopCount)\n\t\t{\n\t\t\t// There's a loop left\n\t\t\tpChn->nPatternLoopCount--;\n\t\t\tif(!pChn->nPatternLoopCount)\n\t\t\t{\n\t\t\t\t// IT compatibility 10. Pattern loops (+ same fix for S3M files)\n\t\t\t\t// When finishing a pattern loop, the next loop without a dedicated SB0 starts on the first row after the previous loop.\n\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoop = m_PlayState.m_nRow + 1;\n\t\t\t\t}\n\n\t\t\t\treturn ROWINDEX_INVALID;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\t// First time we get into the loop => Set loop count.\n\n\t\t\t// IT compatibility 10. Pattern loops (+ same fix for XM / MOD / S3M files)\n\t\t\tif(!m_playBehaviour[kITFT2PatternLoop] && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_S3M)))\n\t\t\t{\n\t\t\t\tModChannel *p = m_PlayState.Chn;\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, p++) if (p != pChn)\n\t\t\t\t{\n\t\t\t\t\t// Loop on other channel\n\t\t\t\t\tif(p->nPatternLoopCount) return ROWINDEX_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpChn->nPatternLoopCount = static_cast<uint8>(param);\n\t\t}\n\t\tm_PlayState.m_nNextPatStartRow = pChn->nPatternLoop; // Nasty FT2 E60 bug emulation!\n\t\treturn pChn->nPatternLoop;\n\t} else\n\t{\n\t\t// Loop Start\n\t\tpChn->nPatternLoop = m_PlayState.m_nRow;\n\t}\n\treturn ROWINDEX_INVALID;\n}\n\n\nvoid CSoundFile::GlobalVolSlide(ModCommand::PARAM param, uint8 &nOldGlobalVolSlide)\n{\n\tint32 nGlbSlide = 0;\n\tif (param) nOldGlobalVolSlide = param; else param = nOldGlobalVolSlide;\n\n\tif((GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\t// XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nGlbSlide = (param >> 4) * 2;\n\t} else\n\tif (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nGlbSlide = - (int)((param & 0x0F) * 2);\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0xF0)\n\t\t\t{\n\t\t\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM)) || (param & 0x0F) == 0)\n\t\t\t\t\tnGlbSlide = (int)((param & 0xF0) >> 4) * 2;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnGlbSlide = -(int)((param & 0x0F) * 2);\n\t\t\t}\n\t\t}\n\t}\n\tif (nGlbSlide)\n\t{\n\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM))) nGlbSlide *= 2;\n\t\tnGlbSlide += m_PlayState.m_nGlobalVolume;\n\t\tLimit(nGlbSlide, 0, 256);\n\t\tm_PlayState.m_nGlobalVolume = nGlbSlide;\n\t}\n}\n\n\n//////////////////////////////////////////////////////\n// Note/Period/Frequency functions\n\n// Find lowest note which has same or lower period as a given period (i.e. the note has the same or higher frequency)\nuint32 CSoundFile::GetNoteFromPeriod(uint32 period, int32 nFineTune, uint32 nC5Speed) const\n{\n\tif(!period) return 0;\n\tif(m_playBehaviour[kFT2Periods])\n\t{\n\t\t// FT2's \"RelocateTon\" function actually rounds up and down, while GetNoteFromPeriod normally just truncates.\n\t\tnFineTune += 64;\n\t}\n\t// This essentially implements std::lower_bound, with the difference that we don't need an iterable container.\n\tuint32 minNote = NOTE_MIN, maxNote = NOTE_MAX, count = maxNote - minNote + 1;\n\tconst bool periodIsFreq = PeriodsAreFrequencies();\n\twhile(count > 0)\n\t{\n\t\tconst uint32 step = count / 2, midNote = minNote + step;\n\t\tuint32 n = GetPeriodFromNote(midNote, nFineTune, nC5Speed);\n\t\tif((n > period && !periodIsFreq) || (n < period && periodIsFreq) || !n)\n\t\t{\n\t\t\tminNote = midNote + 1;\n\t\t\tcount -= step + 1;\n\t\t} else\n\t\t{\n\t\t\tcount = step;\n\t\t}\n\t}\n\treturn minNote;\n}\n\n\nuint32 CSoundFile::GetPeriodFromNote(uint32 note, int32 nFineTune, uint32 nC5Speed) const\n{\n\tif (note == NOTE_NONE || (note >= NOTE_MIN_SPECIAL)) return 0;\n\tnote -= NOTE_MIN;\n\tif (!UseFinetuneAndTranspose())\n\t{\n\t\tif(GetType() & (MOD_TYPE_MDL | MOD_TYPE_DTM))\n\t\t{\n\t\t\t// MDL uses non-linear slides, but their effectiveness does not depend on the middle-C frequency.\n\t\t\treturn (FreqS3MTable[note % 12u] << 4) >> (note / 12);\n\t\t}\n\t\tif(m_SongFlags[SONG_LINEARSLIDES] || GetType() == MOD_TYPE_669)\n\t\t{\n\t\t\t// In IT linear slide mode, directly use frequency in Hertz rather than periods.\n\t\t\tif(m_playBehaviour[kHertzInLinearMode] || GetType() == MOD_TYPE_669)\n\t\t\t\treturn Util::muldiv_unsigned(nC5Speed, LinearSlideUpTable[(note % 12u) * 16u] << (note / 12u), 65536 << 5);\n\t\t\telse\n\t\t\t\treturn (FreqS3MTable[note % 12u] << 5) >> (note / 12);\n\t\t} else\n\t\t{\n\t\t\tif (!nC5Speed)\n\t\t\t\tnC5Speed = 8363;\n\t\t\tLimitMax(nC5Speed, uint32_max >> (note / 12u));\n\t\t\t//(a*b)/c\n\t\t\treturn Util::muldiv_unsigned(8363, (FreqS3MTable[note % 12u] << 5), nC5Speed << (note / 12u));\n\t\t\t//8363 * freq[note%12] / nC5Speed * 2^(5-note/12)\n\t\t}\n\t} else if (GetType() == MOD_TYPE_XM)\n\t{\n\t\tif (note < 12) note = 12;\n\t\tnote -= 12;\n\n\t\t// FT2 Compatibility: The lower three bits of the finetune are truncated.\n\t\t// Test case: Finetune-Precision.xm\n\t\tif(m_playBehaviour[kFT2FinetunePrecision])\n\t\t{\n\t\t\tnFineTune &= ~7;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tint l = ((NOTE_MAX - note) << 6) - (nFineTune / 2);\n\t\t\tif (l < 1) l = 1;\n\t\t\treturn static_cast<uint32>(l);\n\t\t} else\n\t\t{\n\t\t\tint finetune = nFineTune;\n\t\t\tuint32 rnote = (note % 12) << 3;\n\t\t\tuint32 roct = note / 12;\n\t\t\tint rfine = finetune / 16;\n\t\t\tint i = rnote + rfine + 8;\n\t\t\tLimit(i , 0, 103);\n\t\t\tuint32 per1 = XMPeriodTable[i];\n\t\t\tif(finetune < 0)\n\t\t\t{\n\t\t\t\trfine--;\n\t\t\t\tfinetune = -finetune;\n\t\t\t} else rfine++;\n\t\t\ti = rnote+rfine+8;\n\t\t\tif (i < 0) i = 0;\n\t\t\tif (i >= 104) i = 103;\n\t\t\tuint32 per2 = XMPeriodTable[i];\n\t\t\trfine = finetune & 0x0F;\n\t\t\tper1 *= 16-rfine;\n\t\t\tper2 *= rfine;\n\t\t\treturn ((per1 + per2) << 1) >> roct;\n\t\t}\n\t} else\n\t{\n\t\tnFineTune = XM2MODFineTune(nFineTune);\n\t\tif ((nFineTune) || (note < 36) || (note >= 36 + 6 * 12))\n\t\t\treturn (ProTrackerTunedPeriods[nFineTune * 12u + note % 12u] << 5) >> (note / 12u);\n\t\telse\n\t\t\treturn (ProTrackerPeriodTable[note - 36] << 2);\n\t}\n}\n\n\n// Converts period value to sample frequency. Return value is fixed point, with FREQ_FRACBITS fractional bits.\nuint32 CSoundFile::GetFreqFromPeriod(uint32 period, uint32 c5speed, int32 nPeriodFrac) const\n{\n\tif (!period) return 0;\n\tif (GetType() == MOD_TYPE_XM)\n\t{\n\t\tif(m_playBehaviour[kFT2Periods])\n\t\t{\n\t\t\t// FT2 compatibility: Period is a 16-bit value in FT2, and it overflows happily.\n\t\t\t// Test case: FreqWraparound.xm\n\t\t\tperiod &= 0xFFFF;\n\t\t}\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tuint32 octave;\n\t\t\tif(m_playBehaviour[kFT2Periods])\n\t\t\t{\n\t\t\t\t// Under normal circumstances, this calculation returns the same values as the non-compatible one.\n\t\t\t\t// However, once the 12 octaves are exceeded (through portamento slides), the octave shift goes\n\t\t\t\t// crazy in FT2, meaning that the frequency wraps around randomly...\n\t\t\t\t// The entries in FT2's conversion table are four times as big, hence we have to do an additional shift by two bits.\n\t\t\t\t// Test case: FreqWraparound.xm\n\t\t\t\t// 12 octaves * (12 * 64) LUT entries = 9216, add 767 for rounding\n\t\t\t\tuint32 div = ((9216u + 767u - period) / 768);\n\t\t\t\toctave = ((14 - div) & 0x1F);\n\t\t\t} else\n\t\t\t{\n\t\t\t\toctave = (period / 768) + 2;\n\t\t\t}\n\t\t\treturn (XMLinearTable[period % 768] << (FREQ_FRACBITS + 2)) >> octave;\n\t\t} else\n\t\t{\n\t\t\tif(!period) period = 1;\n\t\t\treturn ((8363 * 1712L) << FREQ_FRACBITS) / period;\n\t\t}\n\t} else if (UseFinetuneAndTranspose())\n\t{\n\t\treturn ((3546895L * 4) << FREQ_FRACBITS) / period;\n\t} else if(GetType() == MOD_TYPE_669)\n\t{\n\t\t// We only really use c5speed for the finetune pattern command. All samples in 669 files have the same middle-C speed (imported as 8363 Hz).\n\t\treturn (period + c5speed - 8363) << FREQ_FRACBITS;\n\t} else if(GetType() & (MOD_TYPE_MDL | MOD_TYPE_DTM))\n\t{\n\t\tLimitMax(period, Util::MaxValueOfType(period) >> 8);\n\t\tif (!c5speed) c5speed = 8363;\n\t\treturn Util::muldiv_unsigned(c5speed, (1712L << 7) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t} else\n\t{\n\t\tLimitMax(period, Util::MaxValueOfType(period) >> 8);\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tif(m_playBehaviour[kHertzInLinearMode])\n\t\t\t{\n\t\t\t\t// IT linear slides already use frequencies instead of periods.\n\t\t\t\tstatic_assert(FREQ_FRACBITS <= 8, \"Check this shift operator\");\n\t\t\t\treturn uint32(((uint64(period) << 8) + nPeriodFrac) >> (8 - FREQ_FRACBITS));\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (!c5speed) c5speed = 8363;\n\t\t\t\treturn Util::muldiv_unsigned(c5speed, (1712L << 8) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\treturn Util::muldiv_unsigned(8363, (1712L << 8) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t\t}\n\t}\n}\n\n\nPLUGINDEX CSoundFile::GetBestPlugin(CHANNELINDEX nChn, PluginPriority priority, PluginMutePriority respectMutes) const\n{\n\tif (nChn >= MAX_CHANNELS)\t\t//Check valid channel number\n\t{\n\t\treturn 0;\n\t}\n\n\t//Define search source order\n\tPLUGINDEX nPlugin = 0;\n\tswitch (priority)\n\t{\n\t\tcase ChannelOnly:\n\t\t\tnPlugin = GetChannelPlugin(nChn, respectMutes);\n\t\t\tbreak;\n\t\tcase InstrumentOnly:\n\t\t\tnPlugin  = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\tbreak;\n\t\tcase PrioritiseInstrument:\n\t\t\tnPlugin  = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\tif ((!nPlugin) || (nPlugin > MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tnPlugin = GetChannelPlugin(nChn, respectMutes);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PrioritiseChannel:\n\t\t\tnPlugin  = GetChannelPlugin(nChn, respectMutes);\n\t\t\tif ((!nPlugin) || (nPlugin > MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tnPlugin = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn nPlugin; // 0 Means no plugin found.\n}\n\n\nPLUGINDEX CSoundFile::GetChannelPlugin(CHANNELINDEX nChn, PluginMutePriority respectMutes) const\n{\n\tconst ModChannel &channel = m_PlayState.Chn[nChn];\n\n\tPLUGINDEX nPlugin;\n\tif((respectMutes == RespectMutes && channel.dwFlags[CHN_MUTE]) || channel.dwFlags[CHN_NOFX])\n\t{\n\t\tnPlugin = 0;\n\t} else\n\t{\n\t\t// If it looks like this is an NNA channel, we need to find the master channel.\n\t\t// This ensures we pick up the right ChnSettings.\n\t\t// NB: nMasterChn == 0 means no master channel, so we need to -1 to get correct index.\n\t\tif (nChn >= m_nChannels && channel.nMasterChn > 0)\n\t\t{\n\t\t\tnChn = channel.nMasterChn - 1;\n\t\t}\n\n\t\tif(nChn < MAX_BASECHANNELS)\n\t\t{\n\t\t\tnPlugin = ChnSettings[nChn].nMixPlugin;\n\t\t} else\n\t\t{\n\t\t\tnPlugin = 0;\n\t\t}\n\t}\n\treturn nPlugin;\n}\n\n\nPLUGINDEX CSoundFile::GetActiveInstrumentPlugin(CHANNELINDEX nChn, PluginMutePriority respectMutes) const\n{\n\t// Unlike channel settings, pModInstrument is copied from the original chan to the NNA chan,\n\t// so we don't need to worry about finding the master chan.\n\n\tPLUGINDEX plug = 0;\n\tif(m_PlayState.Chn[nChn].pModInstrument != nullptr)\n\t{\n\t\tif(respectMutes == RespectMutes && m_PlayState.Chn[nChn].pModSample && m_PlayState.Chn[nChn].pModSample->uFlags[CHN_MUTE])\n\t\t{\n\t\t\tplug = 0;\n\t\t} else\n\t\t{\n\t\t\tplug = m_PlayState.Chn[nChn].pModInstrument->nMixPlug;\n\t\t}\n\t}\n\treturn plug;\n}\n\n\n// Retrieve the plugin that is associated with the channel's current instrument.\n// No plugin is returned if the channel is muted or if the instrument doesn't have a MIDI channel set up,\n// As this is meant to be used with instrument plugins.\nIMixPlugin *CSoundFile::GetChannelInstrumentPlugin(CHANNELINDEX chn) const\n{\n#ifndef NO_PLUGINS\n\tif(m_PlayState.Chn[chn].dwFlags[CHN_MUTE | CHN_SYNCMUTE])\n\t{\n\t\t// Don't process portamento on muted channels. Note that this might have a side-effect\n\t\t// on other channels which trigger notes on the same MIDI channel of the same plugin,\n\t\t// as those won't be pitch-bent anymore.\n\t\treturn nullptr;\n\t}\n\n\tif(m_PlayState.Chn[chn].HasMIDIOutput())\n\t{\n\t\tconst ModInstrument *pIns = m_PlayState.Chn[chn].pModInstrument;\n\t\t// Instrument sends to a MIDI channel\n\t\tif(pIns->nMixPlug != 0 && pIns->nMixPlug <= MAX_MIXPLUGINS)\n\t\t{\n\t\t\treturn m_MixPlugins[pIns->nMixPlug - 1].pMixPlugin;\n\t\t}\n\t}\n#else\n\tMPT_UNREFERENCED_PARAMETER(chn);\n#endif // NO_PLUGINS\n\treturn nullptr;\n}\n\n\n// Get the MIDI channel currently associated with a given tracker channel\nuint8 CSoundFile::GetBestMidiChannel(CHANNELINDEX nChn) const\n{\n\tif(nChn >= MAX_CHANNELS)\n\t{\n\t\treturn 0;\n\t}\n\n\tconst ModInstrument *ins = m_PlayState.Chn[nChn].pModInstrument;\n\tif(ins != nullptr)\n\t{\n\t\tif(ins->nMidiChannel == MidiMappedChannel)\n\t\t{\n\t\t\t// For mapped channels, return their pattern channel, modulo 16 (because there are only 16 MIDI channels)\n\t\t\treturn (m_PlayState.Chn[nChn].nMasterChn ? (m_PlayState.Chn[nChn].nMasterChn - 1) : nChn) % 16;\n\t\t} else if(ins->HasValidMIDIChannel())\n\t\t{\n\t\t\treturn (ins->nMidiChannel - 1) & 0x0F;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n#ifdef MODPLUG_TRACKER\nvoid CSoundFile::HandlePatternTransitionEvents()\n{\n\t// MPT sequence override\n\tif(m_PlayState.m_nSeqOverride != ORDERINDEX_INVALID && m_PlayState.m_nSeqOverride < Order().size())\n\t{\n\t\tif(m_SongFlags[SONG_PATTERNLOOP])\n\t\t{\n\t\t\tm_PlayState.m_nPattern = Order()[m_PlayState.m_nSeqOverride];\n\t\t}\n\t\tm_PlayState.m_nCurrentOrder = m_PlayState.m_nSeqOverride;\n\t\tm_PlayState.m_nSeqOverride = ORDERINDEX_INVALID;\n\t}\n\n\t// Channel mutes\n\tfor (CHANNELINDEX chan = 0; chan < GetNumChannels(); chan++)\n\t{\n\t\tif (m_bChannelMuteTogglePending[chan])\n\t\t{\n\t\t\tif(GetpModDoc())\n\t\t\t{\n\t\t\t\tGetpModDoc()->MuteChannel(chan, !GetpModDoc()->IsChannelMuted(chan));\n\t\t\t}\n\t\t\tm_bChannelMuteTogglePending[chan] = false;\n\t\t}\n\t}\n}\n#endif // MODPLUG_TRACKER\n\n\n// Update time signatures (global or pattern-specific). Don't forget to call this when changing the RPB/RPM settings anywhere!\nvoid CSoundFile::UpdateTimeSignature()\n{\n\tif(!Patterns.IsValidIndex(m_PlayState.m_nPattern) || !Patterns[m_PlayState.m_nPattern].GetOverrideSignature())\n\t{\n\t\tm_PlayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tm_PlayState.m_nCurrentRowsPerMeasure = m_nDefaultRowsPerMeasure;\n\t} else\n\t{\n\t\tm_PlayState.m_nCurrentRowsPerBeat = Patterns[m_PlayState.m_nPattern].GetRowsPerBeat();\n\t\tm_PlayState.m_nCurrentRowsPerMeasure = Patterns[m_PlayState.m_nPattern].GetRowsPerMeasure();\n\t}\n}\n\n\nvoid CSoundFile::PortamentoMPT(ModChannel* pChn, int param)\n{\n\t//Behavior: Modifies portamento by param-steps on every tick.\n\t//Note that step meaning depends on tuning.\n\n\tpChn->m_PortamentoFineSteps += param;\n\tpChn->m_CalculateFreq = true;\n}\n\n\nvoid CSoundFile::PortamentoFineMPT(ModChannel* pChn, int param)\n{\n\t//Behavior: Divides portamento change between ticks/row. For example\n\t//if Ticks/row == 6, and param == +-6, portamento goes up/down by one tuning-dependent\n\t//fine step every tick.\n\n\tif(m_PlayState.m_nTickCount == 0)\n\t\tpChn->nOldFinePortaUpDown = 0;\n\n\tconst int tickParam = static_cast<int>((m_PlayState.m_nTickCount + 1.0) * param / m_PlayState.m_nMusicSpeed);\n\tpChn->m_PortamentoFineSteps += (param >= 0) ? tickParam - pChn->nOldFinePortaUpDown : tickParam + pChn->nOldFinePortaUpDown;\n\tif(m_PlayState.m_nTickCount + 1 == m_PlayState.m_nMusicSpeed)\n\t\tpChn->nOldFinePortaUpDown = static_cast<int8>(mpt::abs(param));\n\telse\n\t\tpChn->nOldFinePortaUpDown = static_cast<int8>(mpt::abs(tickParam));\n\n\tpChn->m_CalculateFreq = true;\n}\n\n\nvoid CSoundFile::PortamentoExtraFineMPT(ModChannel* pChn, int param)\n{\n\t// This kinda behaves like regular fine portamento.\n\t// It changes the pitch by n finetune steps on the first tick.\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->m_PortamentoFineSteps += param;\n\t\tpChn->m_CalculateFreq = true;\n\t}\n}\n\n\nOPENMPT_NAMESPACE_END\n"], "fixing_code": ["/*\n * Snd_fx.cpp\n * -----------\n * Purpose: Processing of pattern commands, song length calculation...\n * Notes  : This needs some heavy refactoring.\n *          I thought of actually adding an effect interface class. Every pattern effect\n *          could then be moved into its own class that inherits from the effect interface.\n *          If effect handling differs severly between module formats, every format would have\n *          its own class for that effect. Then, a call chain of effect classes could be set up\n *          for each format, since effects cannot be processed in the same order in all formats.\n * Authors: Olivier Lapicque\n *          OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n */\n\n\n#include \"stdafx.h\"\n#include \"Sndfile.h\"\n#include \"mod_specifications.h\"\n#ifdef MODPLUG_TRACKER\n#include \"../mptrack/Moddoc.h\"\n#endif // MODPLUG_TRACKER\n#include \"tuning.h\"\n#include \"Tables.h\"\n#include \"modsmp_ctrl.h\"\t// For updating the loop wraparound data with the invert loop effect\n#include \"plugins/PlugInterface.h\"\n\nOPENMPT_NAMESPACE_BEGIN\n\n// Formats which have 7-bit (0...128) instead of 6-bit (0...64) global volume commands, or which are imported to this range (mostly formats which are converted to IT internally)\n#ifdef MODPLUG_TRACKER\n#define GLOBALVOL_7BIT_FORMATS_EXT (MOD_TYPE_MT2)\n#else\n#define GLOBALVOL_7BIT_FORMATS_EXT Enum<MODTYPE>::value_type()\n#endif // MODPLUG_TRACKER\n#define GLOBALVOL_7BIT_FORMATS (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM | MOD_TYPE_PTM | MOD_TYPE_MDL | MOD_TYPE_DTM | GLOBALVOL_7BIT_FORMATS_EXT)\n\n\n// Compensate frequency slide LUTs depending on whether we are handling periods or frequency - \"up\" and \"down\" in function name are seen from frequency perspective.\nstatic uint32 GetLinearSlideDownTable    (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideDownTable[i]     : LinearSlideUpTable[i]; }\nstatic uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }\nstatic uint32 GetFineLinearSlideDownTable(const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(FineLinearSlideDownTable)); return sndFile->m_playBehaviour[kHertzInLinearMode] ? FineLinearSlideDownTable[i] : FineLinearSlideUpTable[i]; }\nstatic uint32 GetFineLinearSlideUpTable  (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(FineLinearSlideDownTable)); return sndFile->m_playBehaviour[kHertzInLinearMode] ? FineLinearSlideUpTable[i]   : FineLinearSlideDownTable[i]; }\n\n\n////////////////////////////////////////////////////////////\n// Length\n\n\n// Memory class for GetLength() code\nclass GetLengthMemory\n{\nprotected:\n\tconst CSoundFile &sndFile;\n\npublic:\n\tstd::unique_ptr<CSoundFile::PlayState> state;\n\tstruct ChnSettings\n\t{\n\t\tdouble patLoop = 0.0;\n\t\tCSoundFile::samplecount_t patLoopSmp = 0;\n\t\tROWINDEX patLoopStart = 0;\n\t\tuint32 ticksToRender = 0;\t// When using sample sync, we still need to render this many ticks\n\t\tbool incChanged = false;\t// When using sample sync, note frequency has changed\n\t\tuint8 vol = 0xFF;\n\t};\n\n#ifndef NO_PLUGINS\n\ttypedef std::map<std::pair<ModCommand::INSTR, uint16>, uint16> PlugParamMap;\n\tPlugParamMap plugParams;\n#endif\n\tstd::vector<ChnSettings> chnSettings;\n\tdouble elapsedTime;\n\tstatic const uint32 IGNORE_CHANNEL = uint32_max;\n\n\tGetLengthMemory(const CSoundFile &sf)\n\t\t: sndFile(sf)\n\t\t, state(mpt::make_unique<CSoundFile::PlayState>(sf.m_PlayState))\n\t{\n\t\tReset();\n\t}\n\n\tvoid Reset()\n\t{\n\t\tplugParams.clear();\n\t\telapsedTime = 0.0;\n\t\tstate->m_lTotalSampleCount = 0;\n\t\tstate->m_nMusicSpeed = sndFile.m_nDefaultSpeed;\n\t\tstate->m_nMusicTempo = sndFile.m_nDefaultTempo;\n\t\tstate->m_nGlobalVolume = sndFile.m_nDefaultGlobalVolume;\n\t\tchnSettings.assign(sndFile.GetNumChannels(), ChnSettings());\n\t\tfor(CHANNELINDEX chn = 0; chn < sndFile.GetNumChannels(); chn++)\n\t\t{\n\t\t\tstate->Chn[chn].Reset(ModChannel::resetTotal, sndFile, chn);\n\t\t\tstate->Chn[chn].nOldGlobalVolSlide = 0;\n\t\t\tstate->Chn[chn].nOldChnVolSlide = 0;\n\t\t\tstate->Chn[chn].nNote = state->Chn[chn].nNewNote = state->Chn[chn].nLastNote = NOTE_NONE;\n\t\t}\n\t}\n\n\t// Increment playback position of sample and envelopes on a channel\n\tvoid RenderChannel(CHANNELINDEX channel, uint32 tickDuration, uint32 portaStart = uint32_max)\n\t{\n\t\tModChannel &chn = state->Chn[channel];\n\t\tuint32 numTicks = chnSettings[channel].ticksToRender;\n\t\tif(numTicks == IGNORE_CHANNEL || numTicks == 0 || (!chn.IsSamplePlaying() && !chnSettings[channel].incChanged) || chn.pModSample == nullptr)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tconst SmpLength sampleEnd = chn.dwFlags[CHN_LOOP] ? chn.nLoopEnd : chn.nLength;\n\t\tconst SmpLength loopLength = chn.nLoopEnd - chn.nLoopStart;\n\t\tconst bool itEnvMode = sndFile.m_playBehaviour[kITEnvelopePositionHandling];\n\t\tconst bool updatePitchEnv = (chn.PitchEnv.flags & (ENV_ENABLED | ENV_FILTER)) == ENV_ENABLED;\n\t\tbool stopNote = false;\n\n\t\tSamplePosition inc = chn.increment * tickDuration;\n\t\tif(chn.dwFlags[CHN_PINGPONGFLAG]) inc.Negate();\n\n\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t{\n\t\t\tbool updateInc = (chn.PitchEnv.flags & (ENV_ENABLED | ENV_FILTER)) == ENV_ENABLED;\n\t\t\tif(i >= portaStart)\n\t\t\t{\n\t\t\t\tchn.isFirstTick = false;\n\t\t\t\tconst ModCommand &p = *sndFile.Patterns[state->m_nPattern].GetpModCommand(state->m_nRow, channel);\n\t\t\t\tif(p.command == CMD_TONEPORTAMENTO) sndFile.TonePortamento(&chn, p.param);\n\t\t\t\telse if(p.command == CMD_TONEPORTAVOL) sndFile.TonePortamento(&chn, 0);\n\t\t\t\tif(p.volcmd == VOLCMD_TONEPORTAMENTO)\n\t\t\t\t{\n\t\t\t\t\tuint32 param = p.vol;\n\t\t\t\t\tif(sndFile.GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DMF | MOD_TYPE_DBM | MOD_TYPE_IMF | MOD_TYPE_PSM | MOD_TYPE_J2B | MOD_TYPE_ULT | MOD_TYPE_OKT | MOD_TYPE_MT2 | MOD_TYPE_MDL))\n\t\t\t\t\t{\n\t\t\t\t\t\tparam = ImpulseTrackerPortaVolCmd[param & 0x0F];\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Close enough. Do not bother with idiosyncratic FT2 behaviour here.\n\t\t\t\t\t\tparam <<= 4;\n\t\t\t\t\t}\n\t\t\t\t\tsndFile.TonePortamento(&chn, param);\n\t\t\t\t}\n\t\t\t\tupdateInc = true;\n\t\t\t}\n\n\t\t\tint period = chn.nPeriod;\n\t\t\tif(itEnvMode) sndFile.IncrementEnvelopePositions(&chn);\n\t\t\tif(updatePitchEnv)\n\t\t\t{\n\t\t\t\tsndFile.ProcessPitchFilterEnvelope(&chn, period);\n\t\t\t\tupdateInc = true;\n\t\t\t}\n\t\t\tif(!itEnvMode) sndFile.IncrementEnvelopePositions(&chn);\n\t\t\tint vol = 0;\n\t\t\tsndFile.ProcessInstrumentFade(&chn, vol);\n\n\t\t\tif(updateInc || chnSettings[channel].incChanged)\n\t\t\t{\n\t\t\t\tchn.increment = sndFile.GetChannelIncrement(&chn, period, 0);\n\t\t\t\tchnSettings[channel].incChanged = false;\n\t\t\t\tinc = chn.increment * tickDuration;\n\t\t\t\tif(chn.dwFlags[CHN_PINGPONGFLAG]) inc.Negate();\n\t\t\t}\n\n\t\t\tchn.position += inc;\n\n\t\t\tif(chn.position.GetUInt() >= sampleEnd)\n\t\t\t{\n\t\t\t\tif(chn.dwFlags[CHN_LOOP])\n\t\t\t\t{\n\t\t\t\t\t// We exceeded the sample loop, go back to loop start.\n\t\t\t\t\tif(chn.dwFlags[CHN_PINGPONGLOOP])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(chn.position < SamplePosition(chn.nLoopStart, 0))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchn.position = SamplePosition(chn.nLoopStart + chn.nLoopStart, 0) - chn.position;\n\t\t\t\t\t\t\tchn.dwFlags.flip(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tinc.Negate();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSmpLength posInt = chn.position.GetUInt() - chn.nLoopStart;\n\t\t\t\t\t\tSmpLength pingpongLength = loopLength * 2;\n\t\t\t\t\t\tif(sndFile.m_playBehaviour[kITPingPongMode]) pingpongLength--;\n\t\t\t\t\t\tposInt %= pingpongLength;\n\t\t\t\t\t\tbool forward = (posInt < loopLength);\n\t\t\t\t\t\tif(forward)\n\t\t\t\t\t\t\tchn.position.SetInt(chn.nLoopStart + posInt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tchn.position.SetInt(chn.nLoopEnd - (posInt - loopLength));\n\t\t\t\t\t\tif(forward == chn.dwFlags[CHN_PINGPONGFLAG])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchn.dwFlags.flip(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tinc.Negate();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength posInt = chn.position.GetUInt();\n\t\t\t\t\t\tif(posInt >= chn.nLoopEnd + loopLength)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst SmpLength overshoot = posInt - chn.nLoopEnd;\n\t\t\t\t\t\t\tposInt -= (overshoot / loopLength) * loopLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(posInt >= chn.nLoopEnd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tposInt -= loopLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchn.position.SetInt(posInt);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// Past sample end.\n\t\t\t\t\tstopNote = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(stopNote)\n\t\t{\n\t\t\tchn.Stop();\n\t\t\tchn.nPortamentoDest = 0;\n\t\t}\n\t\tchnSettings[channel].ticksToRender = 0;\n\t}\n};\n\n\n// Get mod length in various cases. Parameters:\n// [in]  adjustMode: See enmGetLengthResetMode for possible adjust modes.\n// [in]  target: Time or position target which should be reached, or no target to get length of the first sub song. Use GetLengthTarget::StartPos to also specify a position from where the seeking should begin.\n// [out] See definition of type GetLengthType for the returned values.\nstd::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMode, GetLengthTarget target)\n{\n\tstd::vector<GetLengthType> results;\n\tGetLengthType retval;\n\tretval.startOrder = target.startOrder;\n\tretval.startRow = target.startRow;\n\n\t// Are we trying to reach a certain pattern position?\n\tconst bool hasSearchTarget = target.mode != GetLengthTarget::NoTarget;\n\tconst bool adjustSamplePos = (adjustMode & eAdjustSamplePositions) == eAdjustSamplePositions;\n\n\tSEQUENCEINDEX sequence = target.sequence;\n\tif(sequence >= Order.GetNumSequences()) sequence = Order.GetCurrentSequenceIndex();\n\tconst ModSequence &orderList = Order(sequence);\n\n\tGetLengthMemory memory(*this);\n\tCSoundFile::PlayState &playState = *memory.state;\n\t// Temporary visited rows vector (so that GetLength() won't interfere with the player code if the module is playing at the same time)\n\tRowVisitor visitedRows(*this, sequence);\n\n\tplayState.m_nNextRow = playState.m_nRow = target.startRow;\n\tplayState.m_nNextOrder = playState.m_nCurrentOrder = target.startOrder;\n\n\t// Fast LUTs for commands that are too weird / complicated / whatever to emulate in sample position adjust mode.\n\tstd::bitset<MAX_EFFECTS> forbiddenCommands;\n\tstd::bitset<MAX_VOLCMDS> forbiddenVolCommands;\n\n\tif(adjustSamplePos)\n\t{\n\t\tforbiddenCommands.set(CMD_ARPEGGIO);             forbiddenCommands.set(CMD_PORTAMENTOUP);\n\t\tforbiddenCommands.set(CMD_PORTAMENTODOWN);       forbiddenCommands.set(CMD_XFINEPORTAUPDOWN);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEUP);          forbiddenCommands.set(CMD_NOTESLIDEUPRETRIG);\n\t\tforbiddenCommands.set(CMD_NOTESLIDEDOWN);        forbiddenCommands.set(CMD_NOTESLIDEDOWNRETRIG);\n\t\tforbiddenVolCommands.set(VOLCMD_PORTAUP);        forbiddenVolCommands.set(VOLCMD_PORTADOWN);\n\n\t\t// Optimize away channels for which it's pointless to adjust sample positions\n\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t{\n\t\t\tif(ChnSettings[i].dwFlags[CHN_MUTE]) memory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t}\n\t\tif(target.mode == GetLengthTarget::SeekPosition && target.pos.order < orderList.size())\n\t\t{\n\t\t\t// If we know where to seek, we can directly rule out any channels on which a new note would be triggered right at the start.\n\t\t\tconst PATTERNINDEX seekPat = orderList[target.pos.order];\n\t\t\tif(Patterns.IsValidPat(seekPat) && Patterns[seekPat].IsValidRow(target.pos.row))\n\t\t\t{\n\t\t\t\tconst ModCommand *m = Patterns[seekPat].GetRow(target.pos.row);\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, m++)\n\t\t\t\t{\n\t\t\t\t\tif(m->note == NOTE_NOTECUT || m->note == NOTE_KEYOFF || (m->note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t\t|| (m->IsNote() && !m->IsPortamento()))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[i].ticksToRender = GetLengthMemory::IGNORE_CHANNEL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If samples are being synced, force them to resync if tick duration changes\n\tuint32 oldTickDuration = 0;\n\n\tfor (;;)\n\t{\n\t\t// Time target reached.\n\t\tif(target.mode == GetLengthTarget::SeekSeconds && memory.elapsedTime >= target.time)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tuint32 rowDelay = 0, tickDelay = 0;\n\t\tplayState.m_nRow = playState.m_nNextRow;\n\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\n\t\tif(orderList.IsValidPat(playState.m_nCurrentOrder) && playState.m_nRow >= Patterns[orderList[playState.m_nCurrentOrder]].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t\tif(m_playBehaviour[kFT2LoopE60Restart])\n\t\t\t{\n\t\t\t\tplayState.m_nRow = playState.m_nNextPatStartRow;\n\t\t\t\tplayState.m_nNextPatStartRow = 0;\n\t\t\t}\n\t\t\tplayState.m_nCurrentOrder = ++playState.m_nNextOrder;\n\t\t}\n\n\t\t// Check if pattern is valid\n\t\tplayState.m_nPattern = playState.m_nCurrentOrder < orderList.size() ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\tbool positionJumpOnThisRow = false;\n\t\tbool patternBreakOnThisRow = false;\n\t\tbool patternLoopEndedOnThisRow = false, patternLoopStartedOnThisRow = false;\n\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern) && playState.m_nPattern != orderList.GetInvalidPatIndex() && target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order)\n\t\t{\n\t\t\t// Early test: Target is inside +++ or non-existing pattern\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\twhile(playState.m_nPattern >= Patterns.Size())\n\t\t{\n\t\t\t// End of song?\n\t\t\tif((playState.m_nPattern == orderList.GetInvalidPatIndex()) || (playState.m_nCurrentOrder >= orderList.size()))\n\t\t\t{\n\t\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tplayState.m_nCurrentOrder = orderList.GetRestartPos();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tplayState.m_nCurrentOrder++;\n\t\t\t}\n\t\t\tplayState.m_nPattern = (playState.m_nCurrentOrder < orderList.size()) ? orderList[playState.m_nCurrentOrder] : orderList.GetInvalidPatIndex();\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder;\n\t\t\tif((!Patterns.IsValidPat(playState.m_nPattern)) && visitedRows.IsVisited(playState.m_nCurrentOrder, 0, true))\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\n\t\t\t\t\tplayState.m_nCurrentOrder = playState.m_nNextOrder;\n\t\t\t\t\tplayState.m_nPattern = orderList[playState.m_nCurrentOrder];\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(playState.m_nNextOrder == ORDERINDEX_INVALID)\n\t\t{\n\t\t\t// GetFirstUnvisitedRow failed, so there is nothing more to play\n\t\t\tbreak;\n\t\t}\n\n\t\t// Skip non-existing patterns\n\t\tif(!Patterns.IsValidPat(playState.m_nPattern))\n\t\t{\n\t\t\t// If there isn't even a tune, we should probably stop here.\n\t\t\tif(playState.m_nCurrentOrder == orderList.GetRestartPos())\n\t\t\t{\n\t\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t\t{\n\t\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\t\tresults.push_back(retval);\n\t\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\t\tmemory.Reset();\n\t\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// Should never happen\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t\tplayState.m_nRow = 0;\n\n\t\t// Check whether target was reached.\n\t\tif(target.mode == GetLengthTarget::SeekPosition && playState.m_nCurrentOrder == target.pos.order && playState.m_nRow == target.pos.row)\n\t\t{\n\t\t\tretval.targetReached = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(visitedRows.IsVisited(playState.m_nCurrentOrder, playState.m_nRow, true))\n\t\t{\n\t\t\tif(!hasSearchTarget || !visitedRows.GetFirstUnvisitedRow(playState.m_nNextOrder, playState.m_nRow, true))\n\t\t\t{\n\t\t\t\t// We aren't searching for a specific row, or we couldn't find any more unvisited rows.\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// We haven't found the target row yet, but we found some other unplayed row... continue searching from here.\n\t\t\t\tretval.duration = memory.elapsedTime;\n\t\t\t\tresults.push_back(retval);\n\t\t\t\tretval.startRow = playState.m_nRow;\n\t\t\t\tretval.startOrder = playState.m_nNextOrder;\n\t\t\t\tmemory.Reset();\n\t\t\t\tplayState.m_nNextRow = playState.m_nRow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tretval.endOrder = playState.m_nCurrentOrder;\n\t\tretval.endRow = playState.m_nRow;\n\n\t\t// Update next position\n\t\tplayState.m_nNextRow = playState.m_nRow + 1;\n\n\t\t// Jumped to invalid pattern row?\n\t\tif(playState.m_nRow >= Patterns[playState.m_nPattern].GetNumRows())\n\t\t{\n\t\t\tplayState.m_nRow = 0;\n\t\t}\n\t\t// New pattern?\n\t\tif(!playState.m_nRow)\n\t\t{\n\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t{\n\t\t\t\tmemory.chnSettings[chn].patLoop = memory.elapsedTime;\n\t\t\t\tmemory.chnSettings[chn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t}\n\t\t}\n\n\t\tModChannel *pChn = playState.Chn;\n\t\t\n\t\t// For various effects, we need to know first how many ticks there are in this row.\n\t\tconst ModCommand *p = Patterns[playState.m_nPattern].GetpModCommand(playState.m_nRow, 0);\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, p++)\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tif(p->IsPcNote())\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif((adjustMode & eAdjust) && p->instr > 0 && p->instr <= MAX_MIXPLUGINS)\n\t\t\t\t{\n\t\t\t\t\tmemory.plugParams[std::make_pair(p->instr, p->GetValueVolCol())] = p->GetValueEffectCol();\n\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\tpChn[nChn].rowCommand.Clear();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpChn[nChn].rowCommand = *p;\n\t\t\tswitch(p->command)\n\t\t\t{\n\t\t\tcase CMD_SPEED:\n\t\t\t\tSetSpeed(playState, p->param);\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\t\tif(p->param != 0) SetSpeed(playState, p->param);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0x60)\n\t\t\t\t{\n\t\t\t\t\t// Fine Pattern Delay\n\t\t\t\t\ttickDelay += (p->param & 0x0F);\n\t\t\t\t} else if((p->param & 0xF0) == 0xE0 && !rowDelay)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\tif(!(GetType() & MOD_TYPE_S3M) || (p->param & 0x0F) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif((p->param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\trowDelay = 1 + (p->param & 0x0F);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(rowDelay == 0) rowDelay = 1;\n\t\tconst uint32 numTicks = (playState.m_nMusicSpeed + tickDelay) * rowDelay;\n\t\tconst uint32 nonRowTicks = numTicks - rowDelay;\n\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++) if(!pChn->rowCommand.IsEmpty())\n\t\t{\n\t\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\t\tcontinue;\n\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\n\t\t\tif (pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->nNewIns = pChn->rowCommand.instr;\n\t\t\t\tpChn->nLastNote = NOTE_NONE;\n\t\t\t\tmemory.chnSettings[nChn].vol = 0xFF;\n\t\t\t}\n\t\t\tif (pChn->rowCommand.IsNote()) pChn->nLastNote = note;\n\n\t\t\t// Update channel panning\n\t\t\tif(pChn->rowCommand.IsNote() || pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tSAMPLEINDEX smp = 0;\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\tModInstrument *pIns;\n\t\t\t\t\tif(pChn->nNewIns <= GetNumInstruments() && (pIns = Instruments[pChn->nNewIns]) != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(pIns->dwFlags[INS_SETPANNING])\n\t\t\t\t\t\t\tpChn->nPan = pIns->nPan;\n\t\t\t\t\t\tif(ModCommand::IsNote(note))\n\t\t\t\t\t\t\tsmp = pIns->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tsmp = pChn->nNewIns;\n\t\t\t\t}\n\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && Samples[smp].uFlags[CHN_PANNING])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = Samples[smp].nPan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\tif(pChn->rowCommand.vol != 0)\n\t\t\t\t\tpChn->nOldVolParam = pChn->rowCommand.vol;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Position Jump\n\t\t\tcase CMD_POSITIONJUMP:\n\t\t\t\tpositionJumpOnThisRow = true;\n\t\t\t\tplayState.m_nNextOrder = static_cast<ORDERINDEX>(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn));\n\t\t\t\tplayState.m_nNextPatStartRow = 0;  // FT2 E60 bug\n\t\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t\t// Test case: PatternJump.mod\n\t\t\t\tif(!patternBreakOnThisRow || (GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t\t\t\t\tplayState.m_nNextRow = 0;\n\n\t\t\t\tif (adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Pattern Break\n\t\t\tcase CMD_PATTERNBREAK:\n\t\t\t\t{\n\t\t\t\t\tROWINDEX row = PatternBreak(playState, nChn, param);\n\t\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternBreakOnThisRow = true;\n\t\t\t\t\t\tplayState.m_nNextRow = row;\n\n\t\t\t\t\t\tif(!positionJumpOnThisRow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nNextOrder = playState.m_nCurrentOrder + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPatternLoopCount = 0;\n\t\t\t\t\t\t\tpChn->nPatternLoop = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Set Tempo\n\t\t\tcase CMD_TEMPO:\n\t\t\t\tif(!m_playBehaviour[kMODVBlankTiming])\n\t\t\t\t{\n\t\t\t\t\tTEMPO tempo(CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn), 0);\n\t\t\t\t\tif ((adjustMode & eAdjust) && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tempo.GetInt()) pChn->nOldTempo = static_cast<uint8>(tempo.GetInt()); else tempo.Set(pChn->nOldTempo);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tempo.GetInt() >= 0x20) playState.m_nMusicTempo = tempo;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Tempo Slide\n\t\t\t\t\t\tTEMPO tempoDiff((tempo.GetInt() & 0x0F) * nonRowTicks, 0);\n\t\t\t\t\t\tif ((tempo.GetInt() & 0xF0) == 0x10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplayState.m_nMusicTempo += tempoDiff;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tempoDiff < playState.m_nMusicTempo)\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo -= tempoDiff;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tplayState.m_nMusicTempo.Set(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tTEMPO tempoMin = GetModSpecifications().GetTempoMin(), tempoMax = GetModSpecifications().GetTempoMax();\n\t\t\t\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t\t\t\t{\n\t\t\t\t\t\ttempoMax.Set(255);\n\t\t\t\t\t}\n\t\t\t\t\tLimit(playState.m_nMusicTempo, tempoMin, tempoMax);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x90:\n\t\t\t\t\tif(param <= 0x91)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_SURROUND, param == 0x91);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xA0:\n\t\t\t\t\t// High sample offset\n\t\t\t\t\tpChn->nOldHiOffset = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 0xB0:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ST3 has only one global loop memory.\n\t\t\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\t\t\tlastChn = GetNumChannels() - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[c].patLoopStart = playState.m_nRow;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tswitch(param & 0xF0)\n\t\t\t\t{\n\t\t\t\tcase 0x60:\n\t\t\t\t\t// Pattern Loop\n\t\t\t\t\tif (param & 0x0F)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_nNextPatStartRow = memory.chnSettings[nChn].patLoopStart; // FT2 E60 bug\n\t\t\t\t\t\tpatternLoopEndedOnThisRow = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpatternLoopStartedOnThisRow = true;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 0xF0:\n\t\t\t\t\t// Active macro\n\t\t\t\t\tpChn->nActiveMacro = param & 0x0F;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\t\t// ignore high offset in compatible mode\n\t\t\t\tif(((param & 0xF0) == 0xA0) && !m_playBehaviour[kFT2RestrictXCommand]) pChn->nOldHiOffset = param & 0x0F;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// The following calculations are not interesting if we just want to get the song length.\n\t\t\tif (!(adjustMode & eAdjust)) continue;\n\t\t\tswitch(command)\n\t\t\t{\n\t\t\t// Portamento Up/Down\n\t\t\tcase CMD_PORTAMENTOUP:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PORTAMENTODOWN:\n\t\t\t\tif(param)\n\t\t\t\t{\n\t\t\t\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t\t\t\t// Test case: Porta-LinkMem.xm\n\t\t\t\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\t\t\t\tpChn->nOldPortaUp = param;\n\t\t\t\t\tpChn->nOldPortaDown = param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Tone-Portamento\n\t\t\tcase CMD_TONEPORTAMENTO:\n\t\t\t\tif (param) pChn->nPortamentoSlide = param << 2;\n\t\t\t\tbreak;\n\t\t\t// Offset\n\t\t\tcase CMD_OFFSET:\n\t\t\t\tif (param) pChn->oldOffset = param << 8;\n\t\t\t\tbreak;\n\t\t\t// Volume Slide\n\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tbreak;\n\t\t\t// Set Volume\n\t\t\tcase CMD_VOLUME:\n\t\t\t\tmemory.chnSettings[nChn].vol = param;\n\t\t\t\tbreak;\n\t\t\t// Global Volume\n\t\t\tcase CMD_GLOBALVOLUME:\n\t\t\t\tif(!(GetType() & GLOBALVOL_7BIT_FORMATS) && param < 128) param *= 2;\n\t\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values\n\t\t\t\tif(param <= 128)\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = param * 2;\n\t\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t\t{\n\t\t\t\t\tplayState.m_nGlobalVolume = 256;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// Global Volume Slide\n\t\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 16. Global volume slide params are stored per channel (FT2/IT)\n\t\t\t\t\tif (param) pChn->nOldGlobalVolSlide = param; else param = pChn->nOldGlobalVolSlide;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif (param) playState.Chn[0].nOldGlobalVolSlide = param; else param = playState.Chn[0].nOldGlobalVolSlide;\n\t\t\t\t}\n\t\t\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param << 1;\n\t\t\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param;\n\t\t\t\t} else if (param & 0xF0)\n\t\t\t\t{\n\t\t\t\t\tparam >>= 4;\n\t\t\t\t\tparam <<= 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume += param * nonRowTicks;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tparam = (param & 0x0F) << 1;\n\t\t\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param <<= 1;\n\t\t\t\t\tplayState.m_nGlobalVolume -= param * nonRowTicks;\n\t\t\t\t}\n\t\t\t\tLimit(playState.m_nGlobalVolume, 0, 256);\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLUME:\n\t\t\t\tif (param <= 64) pChn->nGlobalVol = param;\n\t\t\t\tbreak;\n\t\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\t\t\t\t\tint32 volume = pChn->nGlobalVol;\n\t\t\t\t\tif((param & 0x0F) == 0x0F && (param & 0xF0))\n\t\t\t\t\t\tvolume += (param >> 4);\t\t// Fine Up\n\t\t\t\t\telse if((param & 0xF0) == 0xF0 && (param & 0x0F))\n\t\t\t\t\t\tvolume -= (param & 0x0F);\t// Fine Down\n\t\t\t\t\telse if(param & 0x0F)\t\t\t// Down\n\t\t\t\t\t\tvolume -= (param & 0x0F) * nonRowTicks;\n\t\t\t\t\telse\t\t\t\t\t\t\t// Up\n\t\t\t\t\t\tvolume += ((param & 0xF0) >> 4) * nonRowTicks;\n\t\t\t\t\tLimit(volume, 0, 64);\n\t\t\t\t\tpChn->nGlobalVol = volume;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANNING8:\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t\tbreak;\n\t\t\tcase CMD_MODCMDEX:\n\t\t\t\tif(param < 0x10)\n\t\t\t\t{\n\t\t\t\t\t// LED filter\n\t\t\t\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\tif((param & 0xF0) == 0x80)\n\t\t\t\t{\n\t\t\t\t\tPanning(pChn, (param & 0x0F), Pan4bit);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif (param) pChn->nOldVolumeSlide = param;\n\t\t\t\tparam = 0;\n\t\t\t\tMPT_FALLTHROUGH;\n\t\t\tcase CMD_VIBRATO:\n\t\t\t\tVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\t\tFineVibrato(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tTremolo(pChn, param);\n\t\t\t\tbreak;\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tPanbrello(pChn, param);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(pChn->rowCommand.volcmd)\n\t\t\t{\n\t\t\tcase VOLCMD_PANNING:\n\t\t\t\tPanning(pChn, pChn->rowCommand.vol, Pan6bit);\n\t\t\t\tbreak;\n\n\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\tpChn->nVibratoSpeed = pChn->rowCommand.vol & 0x0F;\n\t\t\t\telse\n\t\t\t\t\tVibrato(pChn, pChn->rowCommand.vol << 4);\n\t\t\t\tbreak;\n\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\tVibrato(pChn, pChn->rowCommand.vol);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Process vibrato / tremolo / panbrello\n\t\t\tswitch(pChn->rowCommand.command)\n\t\t\t{\n\t\t\tcase CMD_VIBRATO:\n\t\t\tcase CMD_FINEVIBRATO:\n\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 vibTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nVibratoSpeed * vibTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nVibratoPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_TREMOLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\tuint32 tremTicks = ((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS]) ? numTicks : nonRowTicks;\n\t\t\t\t\tuint32 inc = pChn->nTremoloSpeed * tremTicks;\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tinc *= 4;\n\t\t\t\t\tpChn->nTremoloPos += static_cast<uint8>(inc);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CMD_PANBRELLO:\n\t\t\t\tif(adjustMode & eAdjust)\n\t\t\t\t{\n\t\t\t\t\t// Panbrello effect is permanent in compatible mode, so actually apply panbrello for the last tick of this row\n\t\t\t\t\tpChn->nPanbrelloPos += static_cast<uint8>(pChn->nPanbrelloSpeed * (numTicks - 1));\n\t\t\t\t\tProcessPanbrello(pChn);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Interpret F00 effect in XM files as \"stop song\"\n\t\tif(GetType() == MOD_TYPE_XM && playState.m_nMusicSpeed == uint16_max)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tplayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tif(Patterns[playState.m_nPattern].GetOverrideSignature())\n\t\t{\n\t\t\tplayState.m_nCurrentRowsPerBeat = Patterns[playState.m_nPattern].GetRowsPerBeat();\n\t\t}\n\n\t\tconst uint32 tickDuration = GetTickDuration(playState);\n\t\tconst uint32 rowDuration = tickDuration * numTicks;\n\t\tmemory.elapsedTime += static_cast<double>(rowDuration) / static_cast<double>(m_MixerSettings.gdwMixingFreq);\n\t\tplayState.m_lTotalSampleCount += rowDuration;\n\n\t\tif(adjustSamplePos)\n\t\t{\n\t\t\t// Super experimental and dirty sample seeking\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); pChn++, nChn++)\n\t\t\t{\n\t\t\t\tif(memory.chnSettings[nChn].ticksToRender == GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tuint32 startTick = 0;\n\t\t\t\tconst ModCommand &m = pChn->rowCommand;\n\t\t\t\tuint32 paramHi = m.param >> 4, paramLo = m.param & 0x0F;\n\t\t\t\tbool porta = m.command == CMD_TONEPORTAMENTO || m.command == CMD_TONEPORTAVOL || m.volcmd == VOLCMD_TONEPORTAMENTO;\n\t\t\t\tbool stopNote = patternLoopStartedOnThisRow;\t// It's too much trouble to keep those pattern loops in sync...\n\n\t\t\t\tif(m.instr) pChn->proTrackerOffset = 0;\n\t\t\t\tif(m.IsNote())\n\t\t\t\t{\n\t\t\t\t\tif(porta && memory.chnSettings[nChn].incChanged)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a portamento, the current channel increment mustn't be 0 in NoteChange()\n\t\t\t\t\t\tpChn->increment = GetChannelIncrement(pChn, pChn->nPeriod, 0);\n\t\t\t\t\t}\n\t\t\t\t\tint32 setPan = pChn->nPan;\n\t\t\t\t\tpChn->nNewNote = pChn->nLastNote;\n\t\t\t\t\tif(pChn->nNewIns != 0) InstrumentChange(pChn, pChn->nNewIns, porta);\n\t\t\t\t\tNoteChange(pChn, m.note, porta);\n\t\t\t\t\tmemory.chnSettings[nChn].incChanged = true;\n\n\t\t\t\t\tif((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xD0 && paramLo < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramLo;\n\t\t\t\t\t} else if(m.command == CMD_DELAYCUT && paramHi < numTicks)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick = paramHi;\n\t\t\t\t\t}\n\t\t\t\t\tif(rowDelay > 1 && startTick != 0 && (GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t\t\t\t{\n\t\t\t\t\t\tstartTick += (playState.m_nMusicSpeed + tickDelay) * (rowDelay - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!porta) memory.chnSettings[nChn].ticksToRender = 0;\n\n\t\t\t\t\t// Panning commands have to be re-applied after a note change with potential pan change.\n\t\t\t\t\tif(m.command == CMD_PANNING8\n\t\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && paramHi == 0x8)\n\t\t\t\t\t\t|| m.volcmd == VOLCMD_PANNING)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nPan = setPan;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.command == CMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tbool isExtended = false;\n\t\t\t\t\t\tSmpLength offset = CalculateXParam(playState.m_nPattern, playState.m_nRow, nChn, &isExtended);\n\t\t\t\t\t\tif(!isExtended)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toffset <<= 8;\n\t\t\t\t\t\t\tif(offset == 0) offset = pChn->oldOffset;\n\t\t\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t} else if(m.command == CMD_OFFSETPERCENTAGE)\n\t\t\t\t\t{\n\t\t\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, m.param, 255));\n\t\t\t\t\t} else if(m.command == CMD_REVERSEOFFSET && pChn->pModSample != nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\tReverseSampleOffset(*pChn, m.param);\n\t\t\t\t\t\tstartTick = playState.m_nMusicSpeed - 1;\n\t\t\t\t\t} else if(m.volcmd == VOLCMD_OFFSET)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(m.vol <= CountOf(pChn->pModSample->cues) && pChn->pModSample != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\t\tif(m.vol == 0)\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[m.vol - 1];\n\t\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(m.note == NOTE_KEYOFF || m.note == NOTE_NOTECUT || (m.note == NOTE_FADE && GetNumInstruments())\n\t\t\t\t\t|| ((m.command == CMD_MODCMDEX || m.command == CMD_S3MCMDEX) && (m.param & 0xF0) == 0xC0 && paramLo < numTicks)\n\t\t\t\t\t|| (m.command == CMD_DELAYCUT && paramLo != 0 && startTick + paramLo < numTicks))\n\t\t\t\t{\n\t\t\t\t\tstopNote = true;\n\t\t\t\t}\n\n\t\t\t\tif(m.command == CMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.param * 4;\n\t\t\t\t} else if(m.volcmd == VOLCMD_VOLUME)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = m.vol * 4;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(pChn->pModSample && !stopNote)\n\t\t\t\t{\n\t\t\t\t\t// Check if we don't want to emulate some effect and thus stop processing.\n\t\t\t\t\tif(m.command < MAX_EFFECTS)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(forbiddenCommands[m.command])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t} else if(m.command == CMD_MODCMDEX)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Special case: Slides using extended commands\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(m.volcmd < forbiddenVolCommands.size() && forbiddenVolCommands[m.volcmd])\n\t\t\t\t\t{\n\t\t\t\t\t\tstopNote = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(stopNote)\n\t\t\t\t{\n\t\t\t\t\tpChn->Stop();\n\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(oldTickDuration != tickDuration && oldTickDuration != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch(m.command)\n\t\t\t\t\t{\n\t\t\t\t\tcase CMD_TONEPORTAVOL:\n\t\t\t\t\tcase CMD_VOLUMESLIDE:\n\t\t\t\t\tcase CMD_VIBRATOVOL:\n\t\t\t\t\t\tif(m.param || (GetType() != MOD_TYPE_MOD))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, m.param);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_MODCMDEX:\n\t\t\t\t\t\tif((m.param & 0x0F) || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\t\t\tswitch(m.param & 0xF0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 0xA0: FineVolumeUp(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\tcase 0xB0: FineVolumeDown(pChn, m.param & 0x0F, false); break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CMD_S3MCMDEX:\n\t\t\t\t\t\tif(m.param == 0x9E)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Play forward\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t} else if(m.param == 0x9F)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Reverse\n\t\t\t\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\t// Re-sync what we've got so far\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\t\t\t\tif(!pChn->position.GetInt() && pChn->nLength && (m.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((m.param & 0xF0) == 0x70)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// TODO\n\t\t\t\t\t\t\t//ExtendedS3MCommands(nChn, param);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpChn->isFirstTick = true;\n\t\t\t\t\tswitch(m.volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_FINEVOLUP:\t\tFineVolumeUp(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_FINEVOLDOWN:\tFineVolumeDown(pChn, m.vol, m_playBehaviour[kITVolColMemory]); break;\n\t\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\t\tModCommand::VOL vol = m.vol;\n\t\t\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(m.volcmd == VOLCMD_VOLSLIDEUP)\n\t\t\t\t\t\t\t\tvol <<= 4;\n\t\t\t\t\t\t\tfor(uint32 i = 0; i < numTicks; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpChn->isFirstTick = (i == 0);\n\t\t\t\t\t\t\t\tVolumeSlide(pChn, vol);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(porta)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Portamento needs immediate syncing, as the pitch changes on each tick\n\t\t\t\t\t\tuint32 portaTick = memory.chnSettings[nChn].ticksToRender + startTick + 1;\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += numTicks;\n\t\t\t\t\t\tmemory.RenderChannel(nChn, tickDuration, portaTick);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].ticksToRender += (numTicks - startTick);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toldTickDuration = tickDuration;\n\n\t\t// Pattern loop is not executed in FT2 if there are any position jump or pattern break commands on the same row.\n\t\t// Pattern loop is not executed in IT if there are any position jump commands on the same row.\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif(patternLoopEndedOnThisRow\n\t\t\t&& (!m_playBehaviour[kFT2PatternLoopWithJumps] || !(positionJumpOnThisRow || patternBreakOnThisRow))\n\t\t\t&& (!m_playBehaviour[kITPatternLoopWithJumps] || !positionJumpOnThisRow))\n\t\t{\n\t\t\tstd::map<double, int> startTimes;\n\t\t\t// This is really just a simple estimation for nested pattern loops. It should handle cases correctly where all parallel loops start and end on the same row.\n\t\t\t// If one of them starts or ends \"in between\", it will most likely calculate a wrong duration.\n\t\t\t// For S3M files, it's also way off.\n\t\t\tpChn = playState.Chn;\n\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t{\n\t\t\t\tModCommand::COMMAND command = pChn->rowCommand.command;\n\t\t\t\tModCommand::PARAM param = pChn->rowCommand.param;\n\t\t\t\tif((command == CMD_S3MCMDEX && param >= 0xB1 && param <= 0xBF)\n\t\t\t\t\t|| (command == CMD_MODCMDEX && param >= 0x61 && param <= 0x6F))\n\t\t\t\t{\n\t\t\t\t\tconst double start = memory.chnSettings[nChn].patLoop;\n\t\t\t\t\tif(!startTimes[start]) startTimes[start] = 1;\n\t\t\t\t\tstartTimes[start] = mpt::lcm(startTimes[start], 1 + (param & 0x0F));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(const auto &i : startTimes)\n\t\t\t{\n\t\t\t\tmemory.elapsedTime += (memory.elapsedTime - i.first) * (double)(i.second - 1);\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif(memory.chnSettings[nChn].patLoop == i.first)\n\t\t\t\t\t{\n\t\t\t\t\t\tplayState.m_lTotalSampleCount += (playState.m_lTotalSampleCount - memory.chnSettings[nChn].patLoopSmp) * (i.second - 1);\n\t\t\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopStart = playState.m_nRow + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(GetType() == MOD_TYPE_IT)\n\t\t\t{\n\t\t\t\t// IT pattern loop start row update - at the end of a pattern loop, set pattern loop start to next row (for upcoming pattern loops with missing SB0)\n\t\t\t\tpChn = playState.Chn;\n\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t\t\t\t{\n\t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n\t\t\t\t\t{\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoop = memory.elapsedTime;\n\t\t\t\t\t\tmemory.chnSettings[nChn].patLoopSmp = playState.m_lTotalSampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Now advance the sample positions for sample seeking on channels that are still playing\n\tif(adjustSamplePos)\n\t{\n\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n\t\t{\n\t\t\tif(memory.chnSettings[nChn].ticksToRender != GetLengthMemory::IGNORE_CHANNEL)\n\t\t\t{\n\t\t\t\tmemory.RenderChannel(nChn, oldTickDuration);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t{\n\t\tretval.lastOrder = playState.m_nCurrentOrder;\n\t\tretval.lastRow = playState.m_nRow;\n\t}\n\tretval.duration = memory.elapsedTime;\n\tresults.push_back(retval);\n\n\t// Store final variables\n\tif(adjustMode & eAdjust)\n\t{\n\t\tif(retval.targetReached || target.mode == GetLengthTarget::NoTarget)\n\t\t{\n\t\t\t// Target found, or there is no target (i.e. play whole song)...\n\t\t\tm_PlayState = std::move(playState);\n\t\t\tm_PlayState.m_nNextRow = m_PlayState.m_nRow;\n\t\t\tm_PlayState.m_nFrameDelay = m_PlayState.m_nPatternDelay = 0;\n\t\t\tm_PlayState.m_nTickCount = Util::MaxValueOfType(m_PlayState.m_nTickCount) - 1;\n\t\t\tm_PlayState.m_bPositionChanged = true;\n\t\t\tfor(CHANNELINDEX n = 0; n < GetNumChannels(); n++)\n\t\t\t{\n\t\t\t\tif(m_PlayState.Chn[n].nLastNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nNewNote = m_PlayState.Chn[n].nLastNote;\n\t\t\t\t}\n\t\t\t\tif(memory.chnSettings[n].vol != 0xFF && !adjustSamplePos)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[n].nVolume = std::min(memory.chnSettings[n].vol, uint8(64)) * 4;\n\t\t\t\t}\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\t// If there were any PC events, update plugin parameters to their latest value.\n\t\t\tstd::bitset<MAX_MIXPLUGINS> plugSetProgram;\n\t\t\tfor(const auto &param : memory.plugParams)\n\t\t\t{\n\t\t\t\tPLUGINDEX plug = param.first.first - 1;\n\t\t\t\tIMixPlugin *plugin = m_MixPlugins[plug].pMixPlugin;\n\t\t\t\tif(plugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!plugSetProgram[plug])\n\t\t\t\t\t{\n\t\t\t\t\t\t// Used for bridged plugins to avoid sending out individual messages for each parameter.\n\t\t\t\t\t\tplugSetProgram.set(plug);\n\t\t\t\t\t\tplugin->BeginSetProgram();\n\t\t\t\t\t}\n\t\t\t\t\tplugin->SetParameter(param.first.second, param.second / PlugParamValue(ModCommand::maxColumnValue));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(plugSetProgram.any())\n\t\t\t{\n\t\t\t\tfor(PLUGINDEX i = 0; i < MAX_MIXPLUGINS; i++)\n\t\t\t\t{\n\t\t\t\t\tif(plugSetProgram[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tm_MixPlugins[i].pMixPlugin->EndSetProgram();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t} else if(adjustMode != eAdjustOnSuccess)\n\t\t{\n\t\t\t// Target not found (e.g. when jumping to a hidden sub song), reset global variables...\n\t\t\tm_PlayState.m_nMusicSpeed = m_nDefaultSpeed;\n\t\t\tm_PlayState.m_nMusicTempo = m_nDefaultTempo;\n\t\t\tm_PlayState.m_nGlobalVolume = m_nDefaultGlobalVolume;\n\t\t}\n\t\t// When adjusting the playback status, we will also want to update the visited rows vector according to the current position.\n\t\tif(sequence != Order.GetCurrentSequenceIndex())\n\t\t{\n\t\t\tOrder.SetSequence(sequence);\n\t\t}\n\t\tvisitedSongRows.Set(visitedRows);\n\t}\n\n\treturn results;\n\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n// Effects\n\n// Change sample or instrument number.\nvoid CSoundFile::InstrumentChange(ModChannel *pChn, uint32 instr, bool bPorta, bool bUpdVol, bool bResetEnv) const\n{\n\tconst ModInstrument *pIns = instr <= GetNumInstruments() ? Instruments[instr] : nullptr;\n\tconst ModSample *pSmp = &Samples[instr];\n\tModCommand::NOTE note = pChn->nNewNote;\n\n\tif(note == NOTE_NONE && m_playBehaviour[kITInstrWithoutNote]) return;\n\n\tif(pIns != nullptr && ModCommand::IsNote(note))\n\t{\n\t\t// Impulse Tracker ignores empty slots.\n\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\tif(pIns->Keyboard[note - NOTE_MIN] == 0 && m_playBehaviour[kITEmptyNoteMapSlot] && !pIns->HasValidMIDIChannel())\n\t\t{\n\t\t\tpChn->pModInstrument = pIns;\n\t\t\treturn;\n\t\t}\n\n\t\tif(pIns->NoteMap[note - NOTE_MIN] > NOTE_MAX) return;\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tpSmp = ((n) && (n < MAX_SAMPLES)) ? &Samples[n] : nullptr;\n\t} else if(GetNumInstruments())\n\t{\n\t\t// No valid instrument, or not a valid note.\n\t\tif (note >= NOTE_MIN_SPECIAL) return;\n\t\tif(m_playBehaviour[kITEmptyNoteMapSlot] && (pIns == nullptr || !pIns->HasValidMIDIChannel()))\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\tpChn->pModInstrument = nullptr;\n\t\t\tpChn->nNewIns = 0;\n\t\t\treturn;\n\t\t}\n\t\tpSmp = nullptr;\n\t}\n\n\tbool returnAfterVolumeAdjust = false;\n\n\t// instrumentChanged is used for IT carry-on env option\n\tbool instrumentChanged = (pIns != pChn->pModInstrument);\n\tconst bool sampleChanged = (pChn->pModSample != nullptr) && (pSmp != pChn->pModSample);\n\n\tconst bool newTuning = (GetType() == MOD_TYPE_MPT && pIns && pIns->pTuning);\n\t// Playback behavior change for MPT: With portamento don't change sample if it is in\n\t// the same instrument as previous sample.\n\tif(bPorta && newTuning && pIns == pChn->pModInstrument && sampleChanged)\n\t\treturn;\n\n\tif(sampleChanged && bPorta)\n\t{\n\t\t// IT compatibility: No sample change (also within multi-sample instruments) during portamento when using Compatible Gxx.\n\t\t// Test case: PortaInsNumCompat.it, PortaSampleCompat.it, PortaCutCompat.it\n\t\tif(m_playBehaviour[kITPortamentoInstrument] && m_SongFlags[SONG_ITCOMPATGXX] && !pChn->increment.IsZero())\n\t\t{\n\t\t\tpSmp = pChn->pModSample;\n\t\t}\n\n\t\t// Special XM hack (also applies to MOD / S3M, except when playing IT-style S3Ms, such as k_vision.s3m)\n\t\t// Test case: PortaSmpChange.mod, PortaSmpChange.s3m\n\t\tif((!instrumentChanged && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)) && pIns)\n\t\t\t|| (GetType() == MOD_TYPE_PLM)\n\t\t\t|| (GetType() == MOD_TYPE_MOD && pChn->IsSamplePlaying())\n\t\t\t|| m_playBehaviour[kST3PortaSampleChange])\n\t\t{\n\t\t\t// FT2 doesn't change the sample in this case,\n\t\t\t// but still uses the sample info from the old one (bug?)\n\t\t\treturnAfterVolumeAdjust = true;\n\t\t}\n\t}\n\t// IT compatibility: A lone instrument number should only reset sample properties to those of the corresponding sample in instrument mode.\n\t// C#5 01 ... <-- sample 1\n\t// C-5 .. g02 <-- sample 2\n\t// ... 01 ... <-- still sample 1, but with properties of sample 2\n\t// In the above example, no sample change happens on the second row. In the third row, sample 1 keeps playing but with the\n\t// volume and panning properties of sample 2.\n\t// Test case: InstrAfterMultisamplePorta.it\n\tif(m_nInstruments && !instrumentChanged && sampleChanged && pChn->pCurrentSample != nullptr && m_playBehaviour[kITMultiSampleInstrumentNumber] && !pChn->rowCommand.IsNote())\n\t{\n\t\treturnAfterVolumeAdjust = true;\n\t}\n\n\t// IT Compatibility: Envelope pickup after SCx cut (but don't do this when working with plugins, or else envelope carry stops working)\n\t// Test case: cut-carry.it\n\tif(!pChn->IsSamplePlaying() && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && (!pIns || !pIns->HasValidMIDIChannel()))\n\t{\n\t\tinstrumentChanged = true;\n\t}\n\n\t// FT2 compatibility: new instrument + portamento = ignore new instrument number, but reload old instrument settings (the world of XM is upside down...)\n\t// And this does *not* happen if volume column portamento is used together with note delay... (handled in ProcessEffects(), where all the other note delay stuff is.)\n\t// Test case: porta-delay.xm\n\tif(instrumentChanged && bPorta && m_playBehaviour[kFT2PortaIgnoreInstr] && (pChn->pModInstrument != nullptr || pChn->pModSample != nullptr))\n\t{\n\t\tpIns = pChn->pModInstrument;\n\t\tpSmp = pChn->pModSample;\n\t\tinstrumentChanged = false;\n\t} else\n\t{\n\t\tpChn->pModInstrument = pIns;\n\t}\n\n\t// Update Volume\n\tif (bUpdVol && (!(GetType() & (MOD_TYPE_MOD | MOD_TYPE_S3M)) || ((pSmp != nullptr && pSmp->HasSampleData()) || pChn->HasMIDIOutput())))\n\t{\n\t\tif(pSmp)\n\t\t{\n\t\t\tif(!pSmp->uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\tpChn->nVolume = pSmp->nVolume;\n\t\t} else if(pIns && pIns->nMixPlug)\n\t\t{\n\t\t\tpChn->nVolume = pChn->GetVSTVolume();\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolume = 0;\n\t\t}\n\t}\n\n\tif(returnAfterVolumeAdjust && sampleChanged && m_playBehaviour[kMODSampleSwap] && pSmp != nullptr)\n\t{\n\t\t// ProTracker applies new instrument's finetune but keeps the old sample playing.\n\t\t// Test case: PortaSwapPT.mod\n\t\tpChn->nFineTune = pSmp->nFineTune;\n\t}\n\n\tif(returnAfterVolumeAdjust) return;\n\n\n\t// Instrument adjust\n\tpChn->nNewIns = 0;\n\n\t// IT Compatiblity: NNA is reset on every note change, not every instrument change (fixes s7xinsnum.it).\n\tif (pIns && ((!m_playBehaviour[kITNNAReset] && pSmp) || pIns->nMixPlug))\n\t\tpChn->nNNA = pIns->nNNA;\n\n\t// Update volume\n\tpChn->UpdateInstrumentVolume(pSmp, pIns);\n\n\t// Update panning\n\t// FT2 compatibility: Only reset panning on instrument numbers, not notes (bUpdVol condition)\n\t// Test case: PanMemory.xm\n\t// IT compatibility: Sample and instrument panning is only applied on note change, not instrument change\n\t// Test case: PanReset.it\n\tif((bUpdVol || !(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))) && !m_playBehaviour[kITPanningReset])\n\t{\n\t\tApplyInstrumentPanning(pChn, pIns, pSmp);\n\t}\n\n\t// Reset envelopes\n\tif(bResetEnv)\n\t{\n\t\t// Blurb by Storlek (from the SchismTracker code):\n\t\t// Conditions experimentally determined to cause envelope reset in Impulse Tracker:\n\t\t// - no note currently playing (of course)\n\t\t// - note given, no portamento\n\t\t// - instrument number given, portamento, compat gxx enabled\n\t\t// - instrument number given, no portamento, after keyoff, old effects enabled\n\t\t// If someone can enlighten me to what the logic really is here, I'd appreciate it.\n\t\t// Seems like it's just a total mess though, probably to get XMs to play right.\n\n\t\tbool reset, resetAlways;\n\n\t\t// IT Compatibility: Envelope reset\n\t\t// Test case: EnvReset.it\n\t\tif(m_playBehaviour[kITEnvelopeReset])\n\t\t{\n\t\t\tconst bool insNumber = (instr != 0);\n\t\t\treset = (!pChn->nLength\n\t\t\t\t|| (insNumber && bPorta && m_SongFlags[SONG_ITCOMPATGXX])\n\t\t\t\t|| (insNumber && !bPorta && pChn->dwFlags[CHN_NOTEFADE | CHN_KEYOFF] && m_SongFlags[SONG_ITOLDEFFECTS]));\n\t\t\t// NOTE: IT2.14 with SB/GUS/etc. output is different. We are going after IT's WAV writer here.\n\t\t\t// For SB/GUS/etc. emulation, envelope carry should only apply when the NNA isn't set to \"Note Cut\".\n\t\t\t// Test case: CarryNNA.it\n\t\t\tresetAlways = (!pChn->nFadeOutVol || instrumentChanged || pChn->dwFlags[CHN_KEYOFF]);\n\t\t} else\n\t\t{\n\t\t\treset = (!bPorta || !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) || m_SongFlags[SONG_ITCOMPATGXX]\n\t\t\t\t|| !pChn->nLength || (pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol));\n\t\t\tresetAlways = !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) || instrumentChanged || pIns == nullptr || pChn->dwFlags[CHN_KEYOFF | CHN_NOTEFADE];\n\t\t}\n\n\t\tif(reset)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\tif(pIns != nullptr)\n\t\t\t{\n\t\t\t\tif(resetAlways)\n\t\t\t\t{\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(!pIns->VolEnv.dwFlags[ENV_CARRY]) pChn->VolEnv.Reset();\n\t\t\t\t\tif(!pIns->PanEnv.dwFlags[ENV_CARRY]) pChn->PanEnv.Reset();\n\t\t\t\t\tif(!pIns->PitchEnv.dwFlags[ENV_CARRY]) pChn->PitchEnv.Reset();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// IT Compatibility: Autovibrato reset\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t{\n\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t}\n\t\t} else if(pIns != nullptr && !pIns->VolEnv.dwFlags[ENV_ENABLED])\n\t\t{\n\t\t\tif(m_playBehaviour[kITPortamentoInstrument])\n\t\t\t{\n\t\t\t\tpChn->VolEnv.Reset();\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t}\n\t\t}\n\t}\n\t// Invalid sample ?\n\tif(pSmp == nullptr && (pIns == nullptr || !pIns->HasValidMIDIChannel()))\n\t{\n\t\tpChn->pModSample = nullptr;\n\t\tpChn->nInsVol = 0;\n\t\treturn;\n\t}\n\n\t// Tone-Portamento doesn't reset the pingpong direction flag\n\tif(bPorta && pSmp == pChn->pModSample && pSmp != nullptr)\n\t{\n\t\t// If channel length is 0, we cut a previous sample using SCx. In that case, we have to update sample length, loop points, etc...\n\t\tif(GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT) && pChn->nLength != 0) return;\n\t\tpChn->dwFlags.reset(CHN_KEYOFF | CHN_NOTEFADE);\n\t\tpChn->dwFlags = (pChn->dwFlags & (CHN_CHANNELFLAGS | CHN_PINGPONGFLAG));\n\t} else //if(!instrumentChanged || pChn->rowCommand.instr != 0 || !IsCompatibleMode(TRK_FASTTRACKER2))\t// SampleChange.xm?\n\t{\n\t\tpChn->dwFlags.reset(CHN_KEYOFF | CHN_NOTEFADE);\n\n\t\t// IT compatibility tentative fix: Don't change bidi loop direction when\n\t\t// no sample nor instrument is changed.\n\t\tif((m_playBehaviour[kITPingPongNoReset] || !(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) && pSmp == pChn->pModSample && !instrumentChanged)\n\t\t\tpChn->dwFlags = (pChn->dwFlags & (CHN_CHANNELFLAGS | CHN_PINGPONGFLAG));\n\t\telse\n\t\t\tpChn->dwFlags = (pChn->dwFlags & CHN_CHANNELFLAGS);\n\n\t\tif(pIns)\n\t\t{\n\t\t\t// Copy envelope flags (we actually only need the \"enabled\" and \"pitch\" flag)\n\t\t\tpChn->VolEnv.flags = pIns->VolEnv.dwFlags;\n\t\t\tpChn->PanEnv.flags = pIns->PanEnv.dwFlags;\n\t\t\tpChn->PitchEnv.flags = pIns->PitchEnv.dwFlags;\n\n\t\t\t// A cutoff frequency of 0 should not be reset just because the filter envelope is enabled.\n\t\t\t// Test case: FilterEnvReset.it\n\t\t\tif((pIns->PitchEnv.dwFlags & (ENV_ENABLED | ENV_FILTER)) == (ENV_ENABLED | ENV_FILTER) && !m_playBehaviour[kITFilterBehaviour])\n\t\t\t{\n\t\t\t\tif(!pChn->nCutOff) pChn->nCutOff = 0x7F;\n\t\t\t}\n\n\t\t\tif(pIns->IsCutoffEnabled()) pChn->nCutOff = pIns->GetCutoff();\n\t\t\tif(pIns->IsResonanceEnabled()) pChn->nResonance = pIns->GetResonance();\n\t\t}\n\t}\n\n\tif(pSmp == nullptr)\n\t{\n\t\tpChn->pModSample = nullptr;\n\t\tpChn->nLength = 0;\n\t\treturn;\n\t}\n\n\tif(bPorta && pChn->nLength == 0 && (m_playBehaviour[kFT2PortaNoNote] || m_playBehaviour[kITPortaNoNote]))\n\t{\n\t\t// IT/FT2 compatibility: If the note just stopped on the previous tick, prevent it from restarting.\n\t\t// Test cases: PortaJustStoppedNote.xm, PortaJustStoppedNote.it\n\t\tpChn->increment.Set(0);\n\t}\n\n\tpChn->pModSample = pSmp;\n\tpChn->nLength = pSmp->nLength;\n\tpChn->nLoopStart = pSmp->nLoopStart;\n\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t// ProTracker \"oneshot\" loops (if loop start is 0, play the whole sample once and then repeat until loop end)\n\tif(m_playBehaviour[kMODOneShotLoops] && pChn->nLoopStart == 0) pChn->nLoopEnd = pSmp->nLength;\n\tpChn->dwFlags |= (pSmp->uFlags & (CHN_SAMPLEFLAGS | CHN_SURROUND));\n\n\t// IT Compatibility: Autovibrato reset\n\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t{\n\t\tpChn->nAutoVibDepth = 0;\n\t\tpChn->nAutoVibPos = 0;\n\t}\n\n\tif(newTuning)\n\t{\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\t\tpChn->m_CalculateFreq = true;\n\t\tpChn->nFineTune = 0;\n\t} else if(!bPorta || sampleChanged || !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)))\n\t{\n\t\t// Don't reset finetune changed by \"set finetune\" command.\n\t\t// Test case: finetune.xm, finetune.mod\n\t\t// But *do* change the finetune if we switch to a different sample, to fix\n\t\t// Miranda`s axe by Jamson (jam007.xm) - this file doesn't use compatible play mode,\n\t\t// so we may want to use IsCompatibleMode instead if further problems arise.\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\t\tpChn->nFineTune = pSmp->nFineTune;\n\t}\n\n\n\tpChn->nTranspose = pSmp->RelativeTone;\n\n\t// FT2 compatibility: Don't reset portamento target with new instrument numbers.\n\t// Test case: Porta-Pickup.xm\n\t// ProTracker does the same.\n\t// Test case: PortaTarget.mod\n\tif(!m_playBehaviour[kFT2PortaTargetNoReset] && GetType() != MOD_TYPE_MOD)\n\t{\n\t\tpChn->nPortamentoDest = 0;\n\t}\n\tpChn->m_PortamentoFineSteps = 0;\n\n\tif(pChn->dwFlags[CHN_SUSTAINLOOP])\n\t{\n\t\tpChn->nLoopStart = pSmp->nSustainStart;\n\t\tpChn->nLoopEnd = pSmp->nSustainEnd;\n\t\tif(pChn->dwFlags[CHN_PINGPONGSUSTAIN]) pChn->dwFlags.set(CHN_PINGPONGLOOP);\n\t\tpChn->dwFlags.set(CHN_LOOP);\n\t}\n\tif(pChn->dwFlags[CHN_LOOP] && pChn->nLoopEnd < pChn->nLength) pChn->nLength = pChn->nLoopEnd;\n\n\t// Fix sample position on instrument change. This is needed for IT \"on the fly\" sample change.\n\t// XXX is this actually called? In ProcessEffects(), a note-on effect is emulated if there's an on the fly sample change!\n\tif(pChn->position.GetUInt() >= pChn->nLength)\n\t{\n\t\tif((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)))\n\t\t{\n\t\t\tpChn->position.Set(0);\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::NoteChange(ModChannel *pChn, int note, bool bPorta, bool bResetEnv, bool bManual) const\n{\n\tif (note < NOTE_MIN) return;\n\tconst ModSample *pSmp = pChn->pModSample;\n\tconst ModInstrument *pIns = pChn->pModInstrument;\n\n\tconst bool newTuning = (GetType() == MOD_TYPE_MPT && pIns != nullptr && pIns->pTuning);\n\t// save the note that's actually used, as it's necessary to properly calculate PPS and stuff\n\tconst int realnote = note;\n\n\tif((pIns) && (note - NOTE_MIN < (int)CountOf(pIns->Keyboard)))\n\t{\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tif((n) && (n < MAX_SAMPLES))\n\t\t{\n\t\t\tpSmp = &Samples[n];\n\t\t} else if(m_playBehaviour[kITEmptyNoteMapSlot] && !pChn->HasMIDIOutput())\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\treturn;\n\t\t}\n\t\tnote = pIns->NoteMap[note - NOTE_MIN];\n\t}\n\t// Key Off\n\tif(note > NOTE_MAX)\n\t{\n\t\t// Key Off (+ Invalid Note for XM - TODO is this correct?)\n\t\tif(note == NOTE_KEYOFF || !(GetType() & (MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\t{\n\t\t\tKeyOff(pChn);\n\t\t} else // Invalid Note -> Note Fade\n\t\t{\n\t\t\tif(/*note == NOTE_FADE && */ GetNumInstruments())\n\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t}\n\n\t\t// Note Cut\n\t\tif (note == NOTE_NOTECUT)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t// IT compatibility: Stopping sample playback by setting sample increment to 0 rather than volume\n\t\t\t// Test case: NoteOffInstr.it\n\t\t\tif ((!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) || (m_nInstruments != 0 && !m_playBehaviour[kITInstrWithNoteOff])) pChn->nVolume = 0;\n\t\t\tif(m_playBehaviour[kITInstrWithNoteOff]) pChn->increment.Set(0);\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t}\n\n\t\t// IT compatibility tentative fix: Clear channel note memory.\n\t\tif(m_playBehaviour[kITClearOldNoteAfterCut])\n\t\t{\n\t\t\tpChn->nNote = pChn->nNewNote = NOTE_NONE;\n\t\t}\n\t\treturn;\n\t}\n\n\tif(newTuning)\n\t{\n\t\tif(!bPorta || pChn->nNote == NOTE_NONE)\n\t\t\tpChn->nPortamentoDest = 0;\n\t\telse\n\t\t{\n\t\t\tpChn->nPortamentoDest = pIns->pTuning->GetStepDistance(pChn->nNote, pChn->m_PortamentoFineSteps, static_cast<Tuning::NOTEINDEXTYPE>(note), 0);\n\t\t\t//Here pChn->nPortamentoDest means 'steps to slide'.\n\t\t\tpChn->m_PortamentoFineSteps = -pChn->nPortamentoDest;\n\t\t}\n\t}\n\n\tif(!bPorta && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MED | MOD_TYPE_MT2)))\n\t{\n\t\tif(pSmp)\n\t\t{\n\t\t\tpChn->nTranspose = pSmp->RelativeTone;\n\t\t\tpChn->nFineTune = pSmp->nFineTune;\n\t\t}\n\t}\n\t// IT Compatibility: Update multisample instruments frequency even if instrument is not specified (fixes the guitars in spx-shuttledeparture.it)\n\t// Test case: freqreset-noins.it\n\tif(!bPorta && pSmp && m_playBehaviour[kITMultiSampleBehaviour])\n\t\tpChn->nC5Speed = pSmp->nC5Speed;\n\n\tif(bPorta && !pChn->IsSamplePlaying())\n\t{\n\t\tif(m_playBehaviour[kFT2PortaNoNote])\n\t\t{\n\t\t\t// FT2 Compatibility: Ignore notes with portamento if there was no note playing.\n\t\t\t// Test case: 3xx-no-old-samp.xm\n\t\t\tpChn->nPeriod = 0;\n\t\t\treturn;\n\t\t} else if(m_playBehaviour[kITPortaNoNote])\n\t\t{\n\t\t\t// IT Compatibility: Ignore portamento command if no note was playing (e.g. if a previous note has faded out).\n\t\t\t// Test case: Fade-Porta.it\n\t\t\tbPorta = false;\n\t\t}\n\t}\n\n\tif(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2|MOD_TYPE_MED|MOD_TYPE_MOD))\n\t{\n\t\tnote += pChn->nTranspose;\n\t\t// RealNote = PatternNote + RelativeTone; (0..118, 0 = C-0, 118 = A#9)\n\t\tLimit(note, NOTE_MIN + 11, NOTE_MIN + 130);\t// 119 possible notes\n\t} else\n\t{\n\t\tLimit(note, NOTE_MIN, NOTE_MAX);\n\t}\n\tif(m_playBehaviour[kITRealNoteMapping])\n\t{\n\t\t// need to memorize the original note for various effects (e.g. PPS)\n\t\tpChn->nNote = static_cast<ModCommand::NOTE>(Clamp(realnote, NOTE_MIN, NOTE_MAX));\n\t} else\n\t{\n\t\tpChn->nNote = static_cast<ModCommand::NOTE>(note);\n\t}\n\tpChn->m_CalculateFreq = true;\n\n\tif ((!bPorta) || (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\tpChn->nNewIns = 0;\n\n\tuint32 period = GetPeriodFromNote(note, pChn->nFineTune, pChn->nC5Speed);\n\tpChn->nPanbrelloOffset = 0;\n\n\t// IT compatibility: Sample and instrument panning is only applied on note change, not instrument change\n\t// Test case: PanReset.it\n\tif(m_playBehaviour[kITPanningReset]) ApplyInstrumentPanning(pChn, pIns, pSmp);\n\n\tif(bResetEnv && !bPorta)\n\t{\n\t\tpChn->nVolSwing = pChn->nPanSwing = 0;\n\t\tpChn->nResSwing = pChn->nCutSwing = 0;\n\t\tif(pIns)\n\t\t{\n\t\t\t// IT Compatiblity: NNA is reset on every note change, not every instrument change (fixes spx-farspacedance.it).\n\t\t\tif(m_playBehaviour[kITNNAReset]) pChn->nNNA = pIns->nNNA;\n\n\t\t\tif(!pIns->VolEnv.dwFlags[ENV_CARRY]) pChn->VolEnv.Reset();\n\t\t\tif(!pIns->PanEnv.dwFlags[ENV_CARRY]) pChn->PanEnv.Reset();\n\t\t\tif(!pIns->PitchEnv.dwFlags[ENV_CARRY]) pChn->PitchEnv.Reset();\n\n\t\t\t// Volume Swing\n\t\t\tif(pIns->nVolSwing)\n\t\t\t{\n\t\t\t\tpChn->nVolSwing = static_cast<int16>(((mpt::random<int8>(AccessPRNG()) * pIns->nVolSwing) / 64 + 1) * (m_playBehaviour[kITSwingBehaviour] ? pChn->nInsVol : ((pChn->nVolume + 1) / 2)) / 199);\n\t\t\t}\n\t\t\t// Pan Swing\n\t\t\tif(pIns->nPanSwing)\n\t\t\t{\n\t\t\t\tpChn->nPanSwing = static_cast<int16>(((mpt::random<int8>(AccessPRNG()) * pIns->nPanSwing * 4) / 128));\n\t\t\t\tif(!m_playBehaviour[kITSwingBehaviour])\n\t\t\t\t{\n\t\t\t\t\tpChn->nRestorePanOnNewNote = static_cast<int16>(pChn->nPan + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Cutoff Swing\n\t\t\tif(pIns->nCutSwing)\n\t\t\t{\n\t\t\t\tint32 d = ((int32)pIns->nCutSwing * (int32)(static_cast<int32>(mpt::random<int8>(AccessPRNG())) + 1)) / 128;\n\t\t\t\tpChn->nCutSwing = static_cast<int16>((d * pChn->nCutOff + 1) / 128);\n\t\t\t\tpChn->nRestoreCutoffOnNewNote = pChn->nCutOff + 1;\n\t\t\t}\n\t\t\t// Resonance Swing\n\t\t\tif(pIns->nResSwing)\n\t\t\t{\n\t\t\t\tint32 d = ((int32)pIns->nResSwing * (int32)(static_cast<int32>(mpt::random<int8>(AccessPRNG())) + 1)) / 128;\n\t\t\t\tpChn->nResSwing = static_cast<int16>((d * pChn->nResonance + 1) / 128);\n\t\t\t\tpChn->nRestoreResonanceOnNewNote = pChn->nResonance + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!pSmp) return;\n\tif(period)\n\t{\n\t\tif((!bPorta) || (!pChn->nPeriod)) pChn->nPeriod = period;\n\t\tif(!newTuning)\n\t\t{\n\t\t\t// FT2 compatibility: Don't reset portamento target with new notes.\n\t\t\t// Test case: Porta-Pickup.xm\n\t\t\t// ProTracker does the same.\n\t\t\t// Test case: PortaTarget.mod\n\t\t\t// IT compatibility: Portamento target is completely cleared with new notes.\n\t\t\t// Test case: PortaReset.it\n\t\t\tif(bPorta || !(m_playBehaviour[kFT2PortaTargetNoReset] || m_playBehaviour[kITClearPortaTarget] || GetType() == MOD_TYPE_MOD))\n\t\t\t{\n\t\t\t\tpChn->nPortamentoDest = period;\n\t\t\t}\n\t\t}\n\n\t\tif(!bPorta || (!pChn->nLength && !(GetType() & MOD_TYPE_S3M)))\n\t\t{\n\t\t\tpChn->pModSample = pSmp;\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t\tpChn->nLoopEnd = pSmp->nLength;\n\t\t\tpChn->nLoopStart = 0;\n\t\t\tpChn->position.Set(0);\n\t\t\tif(m_SongFlags[SONG_PT_MODE] && !pChn->rowCommand.instr)\n\t\t\t{\n\t\t\t\tpChn->position.SetInt(std::min<SmpLength>(pChn->proTrackerOffset, pChn->nLength - 1));\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->proTrackerOffset = 0;\n\t\t\t}\n\t\t\tpChn->dwFlags = (pChn->dwFlags & CHN_CHANNELFLAGS) | (pSmp->uFlags & (CHN_SAMPLEFLAGS | CHN_SURROUND));\n\t\t\tpChn->dwFlags.reset(CHN_PORTAMENTO);\n\t\t\tif(pChn->dwFlags[CHN_SUSTAINLOOP])\n\t\t\t{\n\t\t\t\tpChn->nLoopStart = pSmp->nSustainStart;\n\t\t\t\tpChn->nLoopEnd = pSmp->nSustainEnd;\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGLOOP, pChn->dwFlags[CHN_PINGPONGSUSTAIN]);\n\t\t\t\tpChn->dwFlags.set(CHN_LOOP);\n\t\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\t} else if(pChn->dwFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tpChn->nLoopStart = pSmp->nLoopStart;\n\t\t\t\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\t}\n\t\t\t// ProTracker \"oneshot\" loops (if loop start is 0, play the whole sample once and then repeat until loop end)\n\t\t\tif(m_playBehaviour[kMODOneShotLoops] && pChn->nLoopStart == 0) pChn->nLoopEnd = pChn->nLength = pSmp->nLength;\n\n\t\t\tif(pChn->dwFlags[CHN_REVERSE])\n\t\t\t{\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\t\t\tpChn->position.SetInt(pChn->nLength - 1);\n\t\t\t}\n\n\t\t\t// Handle \"retrigger\" waveform type\n\t\t\tif(pChn->nVibratoType < 4)\n\t\t\t{\n\t\t\t\t// IT Compatibilty: Slightly different waveform offsets (why does MPT have two different offsets here with IT old effects enabled and disabled?)\n\t\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello] && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && !m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t\tpChn->nVibratoPos = 0x10;\n\t\t\t\telse if(GetType() == MOD_TYPE_MTM)\n\t\t\t\t\tpChn->nVibratoPos = 0x20;\n\t\t\t\telse if(!(GetType() & (MOD_TYPE_DIGI | MOD_TYPE_DBM)))\n\t\t\t\t\tpChn->nVibratoPos = 0;\n\t\t\t}\n\t\t\t// IT Compatibility: No \"retrigger\" waveform here\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello] && pChn->nTremoloType < 4)\n\t\t\t{\n\t\t\t\tpChn->nTremoloPos = 0;\n\t\t\t}\n\t\t}\n\t\tif(pChn->position.GetUInt() >= pChn->nLength) pChn->position.SetInt(pChn->nLoopStart);\n\t} else\n\t{\n\t\tbPorta = false;\n\t}\n\n\tif (!bPorta\n\t\t|| (!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)))\n\t\t|| (pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol)\n\t\t|| (m_SongFlags[SONG_ITCOMPATGXX] && pChn->rowCommand.instr != 0))\n\t{\n\t\tif((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_DBM)) && pChn->dwFlags[CHN_NOTEFADE] && !pChn->nFadeOutVol)\n\t\t{\n\t\t\tpChn->ResetEnvelopes();\n\t\t\t// IT Compatibility: Autovibrato reset\n\t\t\tif(!m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t{\n\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t}\n\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\tpChn->nFadeOutVol = 65536;\n\t\t}\n\t\tif ((!bPorta) || (!m_SongFlags[SONG_ITCOMPATGXX]) || (pChn->rowCommand.instr))\n\t\t{\n\t\t\tif ((!(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) || (pChn->rowCommand.instr))\n\t\t\t{\n\t\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\t\tpChn->nFadeOutVol = 65536;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IT compatibility: Don't reset key-off flag on porta notes unless Compat Gxx is enabled\n\t// Test case: Off-Porta.it, Off-Porta-CompatGxx.it\n\tif(m_playBehaviour[kITDontResetNoteOffOnPorta] && bPorta && (!m_SongFlags[SONG_ITCOMPATGXX] || pChn->rowCommand.instr == 0))\n\t\tpChn->dwFlags.reset(CHN_EXTRALOUD);\n\telse\n\t\tpChn->dwFlags.reset(CHN_EXTRALOUD | CHN_KEYOFF);\n\n\t// Enable Ramping\n\tif(!bPorta)\n\t{\n\t\tpChn->nLeftVU = pChn->nRightVU = 0xFF;\n\t\tpChn->dwFlags.reset(CHN_FILTER);\n\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\n\t\t// IT compatibility 15. Retrigger is reset in RetrigNote (Tremor doesn't store anything here, so we just don't reset this as well)\n\t\tif(!m_playBehaviour[kITRetrigger] && !m_playBehaviour[kITTremor])\n\t\t{\n\t\t\t// FT2 compatibility: Retrigger is reset in RetrigNote, tremor in ProcessEffects\n\t\t\tif(!m_playBehaviour[kFT2Retrigger] && !m_playBehaviour[kFT2Tremor])\n\t\t\t{\n\t\t\t\tpChn->nRetrigCount = 0;\n\t\t\t\tpChn->nTremorCount = 0;\n\t\t\t}\n\t\t}\n\n\t\tif(bResetEnv)\n\t\t{\n\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\tpChn->nAutoVibPos = 0;\n\t\t}\n\t\tpChn->rightVol = pChn->leftVol = 0;\n\t\tbool useFilter = !m_SongFlags[SONG_MPTFILTERMODE];\n\t\t// Setup Initial Filter for this note\n\t\tif(pIns)\n\t\t{\n\t\t\tif(pIns->IsResonanceEnabled())\n\t\t\t{\n\t\t\t\tpChn->nResonance = pIns->GetResonance();\n\t\t\t\tuseFilter = true;\n\t\t\t}\n\t\t\tif(pIns->IsCutoffEnabled())\n\t\t\t{\n\t\t\t\tpChn->nCutOff = pIns->GetCutoff();\n\t\t\t\tuseFilter = true;\n\t\t\t}\n\t\t\tif(useFilter && (pIns->nFilterMode != FLTMODE_UNCHANGED))\n\t\t\t{\n\t\t\t\tpChn->nFilterMode = pIns->nFilterMode;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolSwing = pChn->nPanSwing = 0;\n\t\t\tpChn->nCutSwing = pChn->nResSwing = 0;\n\t\t}\n\t\tif((pChn->nCutOff < 0x7F || m_playBehaviour[kITFilterBehaviour]) && useFilter)\n\t\t{\n\t\t\tSetupChannelFilter(pChn, true);\n\t\t}\n\t}\n\t// Special case for MPT\n\tif (bManual) pChn->dwFlags.reset(CHN_MUTE);\n\tif((pChn->dwFlags[CHN_MUTE] && (m_MixerSettings.MixerFlags & SNDMIX_MUTECHNMODE))\n\t\t|| (pChn->pModSample != nullptr && pChn->pModSample->uFlags[CHN_MUTE] && !bManual)\n\t\t|| (pChn->pModInstrument != nullptr && pChn->pModInstrument->dwFlags[INS_MUTE] && !bManual))\n\t{\n\t\tif (!bManual) pChn->nPeriod = 0;\n\t}\n\n\t// Reset the Amiga resampler for this channel\n\tif(!bPorta)\n\t{\n\t\tpChn->paulaState.Reset();\n\t}\n}\n\n\n// Apply sample or instrumernt panning\nvoid CSoundFile::ApplyInstrumentPanning(ModChannel *pChn, const ModInstrument *instr, const ModSample *smp) const\n{\n\tint32 newPan = int32_min;\n\t// Default instrument panning\n\tif(instr != nullptr && instr->dwFlags[INS_SETPANNING])\n\t\tnewPan = instr->nPan;\n\t// Default sample panning\n\tif(smp != nullptr && smp->uFlags[CHN_PANNING])\n\t\tnewPan = smp->nPan;\n\n\tif(newPan != int32_min)\n\t{\n\t\tpChn->nPan = newPan;\n\t\t// IT compatibility: Sample and instrument panning overrides channel surround status.\n\t\t// Test case: SmpInsPanSurround.it\n\t\tif(m_playBehaviour[kPanOverride] && !m_SongFlags[SONG_SURROUNDPAN])\n\t\t{\n\t\t\tpChn->dwFlags.reset(CHN_SURROUND);\n\t\t}\n\t}\n}\n\n\nCHANNELINDEX CSoundFile::GetNNAChannel(CHANNELINDEX nChn) const\n{\n\tconst ModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\t// Check for empty channel\n\tconst ModChannel *pi = &m_PlayState.Chn[m_nChannels];\n\tfor (CHANNELINDEX i = m_nChannels; i < MAX_CHANNELS; i++, pi++) if (!pi->nLength) return i;\n\tif (!pChn->nFadeOutVol) return 0;\n\n\t// All channels are used: check for lowest volume\n\tCHANNELINDEX result = 0;\n\tuint32 vol = (1u << (14 + 9)) / 4u;\t// 25%\n\tuint32 envpos = uint32_max;\n\tconst ModChannel *pj = &m_PlayState.Chn[m_nChannels];\n\tfor (CHANNELINDEX j = m_nChannels; j < MAX_CHANNELS; j++, pj++)\n\t{\n\t\tif (!pj->nFadeOutVol) return j;\n\t\t// Use a combination of real volume [14 bit] (which includes volume envelopes, but also potentially global volume) and note volume [9 bit].\n\t\t// Rationale: We need volume envelopes in case e.g. all NNA channels are playing at full volume but are looping on a 0-volume envelope node.\n\t\t// But if global volume is not applied to master and the global volume temporarily drops to 0, we would kill arbitrary channels. Hence, add the note volume as well.\n\t\tuint32 v = (pj->nRealVolume << 9) | pj->nVolume;\n\t\tif(pj->dwFlags[CHN_LOOP]) v >>= 1;\n\t\tif ((v < vol) || ((v == vol) && (pj->VolEnv.nEnvPosition > envpos)))\n\t\t{\n\t\t\tenvpos = pj->VolEnv.nEnvPosition;\n\t\t\tvol = v;\n\t\t\tresult = j;\n\t\t}\n\t}\n\treturn result;\n}\n\n\nCHANNELINDEX CSoundFile::CheckNNA(CHANNELINDEX nChn, uint32 instr, int note, bool forceCut)\n{\n\tCHANNELINDEX nnaChn = CHANNELINDEX_INVALID;\n\tModChannel &srcChn = m_PlayState.Chn[nChn];\n\tconst ModInstrument *pIns = nullptr;\n\tif(!ModCommand::IsNote(static_cast<ModCommand::NOTE>(note)))\n\t{\n\t\treturn nnaChn;\n\t}\n\t// Always NNA cut - using\n\tif((!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_MT2)) || !m_nInstruments || forceCut) && !srcChn.HasMIDIOutput())\n\t{\n\t\tif(!srcChn.nLength || srcChn.dwFlags[CHN_MUTE] || !(srcChn.rightVol | srcChn.leftVol))\n\t\t{\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(!nnaChn) return CHANNELINDEX_INVALID;\n\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\t// Copy Channel\n\t\tchn = srcChn;\n\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_MUTE | CHN_PORTAMENTO);\n\t\tchn.nPanbrelloOffset = 0;\n\t\tchn.nMasterChn = nChn + 1;\n\t\tchn.nCommand = CMD_NONE;\n\t\tchn.rowCommand.Clear();\n\t\t// Cut the note\n\t\tchn.nFadeOutVol = 0;\n\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t// Stop this channel\n\t\tsrcChn.nLength = 0;\n\t\tsrcChn.position.Set(0);\n\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\tsrcChn.rightVol = srcChn.leftVol = 0;\n\t\treturn nnaChn;\n\t}\n\tif(instr > GetNumInstruments()) instr = 0;\n\tconst ModSample *pSample = srcChn.pModSample;\n\t// If no instrument is given, assume previous instrument to still be valid.\n\t// Test case: DNA-NoInstr.it\n\tpIns = instr > 0 ? Instruments[instr] : srcChn.pModInstrument;\n\tif(pIns != nullptr)\n\t{\n\t\tuint32 n = pIns->Keyboard[note - NOTE_MIN];\n\t\tnote = pIns->NoteMap[note - NOTE_MIN];\n\t\tif ((n) && (n < MAX_SAMPLES))\n\t\t{\n\t\t\tpSample = &Samples[n];\n\t\t} else if(m_playBehaviour[kITEmptyNoteMapSlot] && !pIns->HasValidMIDIChannel())\n\t\t{\n\t\t\t// Impulse Tracker ignores empty slots.\n\t\t\t// We won't ignore them if a plugin is assigned to this slot, so that VSTis still work as intended.\n\t\t\t// Test case: emptyslot.it, PortaInsNum.it, gxsmp.it, gxsmp2.it\n\t\t\treturn CHANNELINDEX_INVALID;\n\t\t}\n\t}\n\tif (srcChn.dwFlags[CHN_MUTE])\n\t\treturn CHANNELINDEX_INVALID;\n\n\tfor(CHANNELINDEX i = nChn; i < MAX_CHANNELS; i++)\n\tif(i >= m_nChannels || i == nChn)\n\t{\n\t\tModChannel &chn = m_PlayState.Chn[i];\n\t\tbool applyDNAtoPlug = false;\n\t\tif((chn.nMasterChn == nChn + 1 || i == nChn) && chn.pModInstrument != nullptr)\n\t\t{\n\t\t\tbool bOk = false;\n\t\t\t// Duplicate Check Type\n\t\t\tswitch(chn.pModInstrument->nDCT)\n\t\t\t{\n\t\t\t// Note\n\t\t\tcase DCT_NOTE:\n\t\t\t\tif(note && chn.nNote == note && pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\t// Sample\n\t\t\tcase DCT_SAMPLE:\n\t\t\t\tif(pSample != nullptr && pSample == chn.pModSample) bOk = true;\n\t\t\t\tbreak;\n\t\t\t// Instrument\n\t\t\tcase DCT_INSTRUMENT:\n\t\t\t\tif(pIns == chn.pModInstrument) bOk = true;\n\t\t\t\tif(pIns && pIns->nMixPlug) applyDNAtoPlug = true;\n\t\t\t\tbreak;\n\t\t\t// Plugin\n\t\t\tcase DCT_PLUGIN:\n\t\t\t\tif(pIns && (pIns->nMixPlug) && (pIns->nMixPlug == chn.pModInstrument->nMixPlug))\n\t\t\t\t{\n\t\t\t\t\tapplyDNAtoPlug = true;\n\t\t\t\t\tbOk = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\t// Duplicate Note Action\n\t\t\tif (bOk)\n\t\t\t{\n#ifndef NO_PLUGINS\n\t\t\t\tif (applyDNAtoPlug && chn.nNote != NOTE_NONE)\n\t\t\t\t{\n\t\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t\t{\n\t\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\t\t// Switch off duplicated note played on this plugin\n\t\t\t\t\t\tSendMIDINote(i, chn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]) + NOTE_MAX_SPECIAL, 0);\n\t\t\t\t\t\tchn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\t\tswitch(chn.pModInstrument->nDNA)\n\t\t\t\t{\n\t\t\t\t// Cut\n\t\t\t\tcase DNA_NOTECUT:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tchn.nVolume = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t// Note Off\n\t\t\t\tcase DNA_NOTEOFF:\n\t\t\t\t\tKeyOff(&chn);\n\t\t\t\t\tbreak;\n\t\t\t\t// Note Fade\n\t\t\t\tcase DNA_NOTEFADE:\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!chn.nVolume)\n\t\t\t\t{\n\t\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do we need to apply New/Duplicate Note Action to a VSTi?\n\tbool applyNNAtoPlug = false;\n#ifndef NO_PLUGINS\n\tIMixPlugin *pPlugin = nullptr;\n\tif(srcChn.HasMIDIOutput() && ModCommand::IsNote(srcChn.nNote)) // instro sends to a midi chan\n\t{\n\t\tPLUGINDEX nPlugin = GetBestPlugin(nChn, PrioritiseInstrument, RespectMutes);\n\n\t\tif(nPlugin > 0 && nPlugin <= MAX_MIXPLUGINS)\n\t\t{\n\t\t\tpPlugin =  m_MixPlugins[nPlugin-1].pMixPlugin;\n\t\t\tif(pPlugin)\n\t\t\t{\n\t\t\t\t// apply NNA to this plugin iff it is currently playing a note on this tracker channel\n\t\t\t\t// (and if it is playing a note, we know that would be the last note played on this chan).\n\t\t\t\tapplyNNAtoPlug = pPlugin->IsNotePlaying(srcChn.GetPluginNote(m_playBehaviour[kITRealNoteMapping]), GetBestMidiChannel(nChn), nChn);\n\t\t\t}\n\t\t}\n\t}\n#endif // NO_PLUGINS\n\n\t// New Note Action\n\tif((srcChn.nRealVolume > 0 && srcChn.nLength > 0) || applyNNAtoPlug)\n\t{\n\t\tnnaChn = GetNNAChannel(nChn);\n\t\tif(nnaChn != 0)\n\t\t{\n\t\t\tModChannel &chn = m_PlayState.Chn[nnaChn];\n\t\t\t// Copy Channel\n\t\t\tchn = srcChn;\n\t\t\tchn.dwFlags.reset(CHN_VIBRATO | CHN_TREMOLO | CHN_PORTAMENTO);\n\t\t\tchn.nPanbrelloOffset = 0;\n\n\t\t\tchn.nMasterChn = nChn < GetNumChannels() ? nChn + 1 : 0;\n\t\t\tchn.nCommand = CMD_NONE;\n#ifndef NO_PLUGINS\n\t\t\tif(applyNNAtoPlug && pPlugin)\n\t\t\t{\n\t\t\t\t//Move note to the NNA channel (odd, but makes sense with DNA stuff).\n\t\t\t\t//Actually a bad idea since it then become very hard to kill some notes.\n\t\t\t\t//pPlugin->MoveNote(pChn.nNote, pChn.pModInstrument->nMidiChannel, nChn, n);\n\t\t\t\tswitch(srcChn.nNNA)\n\t\t\t\t{\n\t\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tcase NNA_NOTECUT:\n\t\t\t\tcase NNA_NOTEFADE:\n\t\t\t\t\t//switch off note played on this plugin, on this tracker channel and midi channel\n\t\t\t\t\t//pPlugin->MidiCommand(pChn.pModInstrument->nMidiChannel, pChn.pModInstrument->nMidiProgram, pChn.nNote + NOTE_MAX_SPECIAL, 0, n);\n\t\t\t\t\tSendMIDINote(nChn, NOTE_KEYOFF, 0);\n\t\t\t\t\tsrcChn.nArpeggioLastNote = NOTE_NONE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#endif // NO_PLUGINS\n\n\t\t\t// Key Off the note\n\t\t\tswitch(srcChn.nNNA)\n\t\t\t{\n\t\t\tcase NNA_NOTEOFF:\n\t\t\t\tKeyOff(&chn);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTECUT:\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\tcase NNA_NOTEFADE:\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!chn.nVolume)\n\t\t\t{\n\t\t\t\tchn.nFadeOutVol = 0;\n\t\t\t\tchn.dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\t// Stop this channel\n\t\t\tsrcChn.nLength = 0;\n\t\t\tsrcChn.position.Set(0);\n\t\t\tsrcChn.nROfs = srcChn.nLOfs = 0;\n\t\t}\n\t}\n\treturn nnaChn;\n}\n\n\nbool CSoundFile::ProcessEffects()\n{\n\tModChannel *pChn = m_PlayState.Chn;\n\tROWINDEX nBreakRow = ROWINDEX_INVALID;\t\t// Is changed if a break to row command is encountered\n\tROWINDEX nPatLoopRow = ROWINDEX_INVALID;\t// Is changed if a pattern loop jump-back is executed\n\tORDERINDEX nPosJump = ORDERINDEX_INVALID;\n\n\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n\t{\n\t\tconst uint32 tickCount = m_PlayState.m_nTickCount % (m_PlayState.m_nMusicSpeed + m_PlayState.m_nFrameDelay);\n\t\tuint32 instr = pChn->rowCommand.instr;\n\t\tModCommand::VOLCMD volcmd = pChn->rowCommand.volcmd;\n\t\tuint32 vol = pChn->rowCommand.vol;\n\t\tModCommand::COMMAND cmd = pChn->rowCommand.command;\n\t\tuint32 param = pChn->rowCommand.param;\n\t\tbool bPorta = pChn->rowCommand.IsPortamento();\n\n\t\tuint32 nStartTick = 0;\n\t\tpChn->isFirstTick = m_SongFlags[SONG_FIRSTTICK];\n\n\t\t// Process parameter control note.\n\t\tif(pChn->rowCommand.note == NOTE_PC)\n\t\t{\n#ifndef NO_PLUGINS\n\t\t\tconst PLUGINDEX plug = pChn->rowCommand.instr;\n\t\t\tconst PlugParamIndex plugparam = pChn->rowCommand.GetValueVolCol();\n\t\t\tconst PlugParamValue value = pChn->rowCommand.GetValueEffectCol() / PlugParamValue(ModCommand::maxColumnValue);\n\n\t\t\tif(plug > 0 && plug <= MAX_MIXPLUGINS && m_MixPlugins[plug - 1].pMixPlugin)\n\t\t\t\tm_MixPlugins[plug-1].pMixPlugin->SetParameter(plugparam, value);\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// Process continuous parameter control note.\n\t\t// Row data is cleared after first tick so on following\n\t\t// ticks using channels m_nPlugParamValueStep to identify\n\t\t// the need for parameter control. The condition cmd == 0\n\t\t// is to make sure that m_nPlugParamValueStep != 0 because\n\t\t// of NOTE_PCS, not because of macro.\n\t\tif(pChn->rowCommand.note == NOTE_PCS || (cmd == CMD_NONE && pChn->m_plugParamValueStep != 0))\n\t\t{\n#ifndef NO_PLUGINS\n\t\t\tconst bool isFirstTick = m_SongFlags[SONG_FIRSTTICK];\n\t\t\tif(isFirstTick)\n\t\t\t\tpChn->m_RowPlug = pChn->rowCommand.instr;\n\t\t\tconst PLUGINDEX nPlug = pChn->m_RowPlug;\n\t\t\tconst bool hasValidPlug = (nPlug > 0 && nPlug <= MAX_MIXPLUGINS && m_MixPlugins[nPlug-1].pMixPlugin);\n\t\t\tif(hasValidPlug)\n\t\t\t{\n\t\t\t\tif(isFirstTick)\n\t\t\t\t\tpChn->m_RowPlugParam = ModCommand::GetValueVolCol(pChn->rowCommand.volcmd, pChn->rowCommand.vol);\n\t\t\t\tconst PlugParamIndex plugparam = pChn->m_RowPlugParam;\n\t\t\t\tif(isFirstTick)\n\t\t\t\t{\n\t\t\t\t\tPlugParamValue targetvalue = ModCommand::GetValueEffectCol(pChn->rowCommand.command, pChn->rowCommand.param) / PlugParamValue(ModCommand::maxColumnValue);\n\t\t\t\t\tpChn->m_plugParamTargetValue = targetvalue;\n\t\t\t\t\tpChn->m_plugParamValueStep = (targetvalue - m_MixPlugins[nPlug-1].pMixPlugin->GetParameter(plugparam)) / float(GetNumTicksOnCurrentRow());\n\t\t\t\t}\n\t\t\t\tif(m_PlayState.m_nTickCount + 1 == GetNumTicksOnCurrentRow())\n\t\t\t\t{\t// On last tick, set parameter exactly to target value.\n\t\t\t\t\tm_MixPlugins[nPlug-1].pMixPlugin->SetParameter(plugparam, pChn->m_plugParamTargetValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tm_MixPlugins[nPlug-1].pMixPlugin->ModifyParameter(plugparam, pChn->m_plugParamValueStep);\n\t\t\t}\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// Apart from changing parameters, parameter control notes are intended to be 'invisible'.\n\t\t// To achieve this, clearing the note data so that rest of the process sees the row as empty row.\n\t\tif(ModCommand::IsPcNote(pChn->rowCommand.note))\n\t\t{\n\t\t\tpChn->ClearRowCmd();\n\t\t\tinstr = 0;\n\t\t\tvolcmd = VOLCMD_NONE;\n\t\t\tvol = 0;\n\t\t\tcmd = CMD_NONE;\n\t\t\tparam = 0;\n\t\t\tbPorta = false;\n\t\t}\n\n\t\t// Process Invert Loop (MOD Effect, called every row if it's active)\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tInvertLoop(&m_PlayState.Chn[nChn]);\n\t\t} else\n\t\t{\n\t\t\tif(instr) m_PlayState.Chn[nChn].nEFxOffset = 0;\n\t\t}\n\n\t\t// Process special effects (note delay, pattern delay, pattern loop)\n\t\tif (cmd == CMD_DELAYCUT)\n\t\t{\n\t\t\t//:xy --> note delay until tick x, note cut at tick x+y\n\t\t\tnStartTick = (param & 0xF0) >> 4;\n\t\t\tconst uint32 cutAtTick = nStartTick + (param & 0x0F);\n\t\t\tNoteCut(nChn, cutAtTick, m_playBehaviour[kITSCxStopsSample]);\n\t\t} else if ((cmd == CMD_MODCMDEX) || (cmd == CMD_S3MCMDEX))\n\t\t{\n\t\t\tif ((!param) && (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT)))\n\t\t\t\tparam = pChn->nOldCmdEx;\n\t\t\telse\n\t\t\t\tpChn->nOldCmdEx = static_cast<ModCommand::PARAM>(param);\n\n\t\t\t// Note Delay ?\n\t\t\tif ((param & 0xF0) == 0xD0)\n\t\t\t{\n\t\t\t\tnStartTick = param & 0x0F;\n\t\t\t\tif(nStartTick == 0)\n\t\t\t\t{\n\t\t\t\t\t//IT compatibility 22. SD0 == SD1\n\t\t\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))\n\t\t\t\t\t\tnStartTick = 1;\n\t\t\t\t\t//ST3 ignores notes with SD0 completely\n\t\t\t\t\telse if(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else if(nStartTick >= (m_PlayState.m_nMusicSpeed + m_PlayState.m_nFrameDelay) && m_playBehaviour[kITOutOfRangeDelay])\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility 08. Handling of out-of-range delay command.\n\t\t\t\t\t// Additional test case: tickdelay.it\n\t\t\t\t\tif(instr)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\t// Pattern Loop ?\n\t\t\t\tif((((param & 0xF0) == 0x60 && cmd == CMD_MODCMDEX)\n\t\t\t\t\t|| ((param & 0xF0) == 0xB0 && cmd == CMD_S3MCMDEX))\n\t\t\t\t\t&& !(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE]))\t// not even effects are processed on muted S3M channels\n\t\t\t\t{\n\t\t\t\t\tROWINDEX nloop = PatternLoop(pChn, param & 0x0F);\n\t\t\t\t\tif (nloop != ROWINDEX_INVALID)\n\t\t\t\t\t{\n\t\t\t\t\t\t// FT2 compatibility: E6x overwrites jump targets of Dxx effects that are located left of the E6x effect.\n\t\t\t\t\t\t// Test cases: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t\t\t\t\tif(nBreakRow != ROWINDEX_INVALID && m_playBehaviour[kFT2PatternLoopWithJumps])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnBreakRow = nloop;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnPatLoopRow = nloop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ST3 doesn't have per-channel pattern loop memory, so spam all changes to other channels as well.\n\t\t\t\t\t\tfor (CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_PlayState.Chn[i].nPatternLoop = pChn->nPatternLoop;\n\t\t\t\t\t\t\tm_PlayState.Chn[i].nPatternLoopCount = pChn->nPatternLoopCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if ((param & 0xF0) == 0xE0)\n\t\t\t\t{\n\t\t\t\t\t// Pattern Delay\n\t\t\t\t\t// In Scream Tracker 3 / Impulse Tracker, only the first delay command on this row is considered.\n\t\t\t\t\t// Test cases: PatternDelays.it, PatternDelays.s3m, PatternDelays.xm\n\t\t\t\t\t// XXX In Scream Tracker 3, the \"left\" channels are evaluated before the \"right\" channels, which is not emulated here!\n\t\t\t\t\tif(!(GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT)) || !m_PlayState.m_nPatternDelay)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!(GetType() & (MOD_TYPE_S3M)) || (param & 0x0F) != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// While Impulse Tracker *does* count S60 as a valid row delay (and thus ignores any other row delay commands on the right),\n\t\t\t\t\t\t\t// Scream Tracker 3 simply ignores such commands.\n\t\t\t\t\t\t\tm_PlayState.m_nPatternDelay = 1 + (param & 0x0F);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(GetType() == MOD_TYPE_MTM && cmd == CMD_MODCMDEX && (param & 0xF0) == 0xD0)\n\t\t{\n\t\t\t// Apparently, retrigger and note delay have the same behaviour in MultiTracker:\n\t\t\t// They both restart the note at tick x, and if there is a note on the same row,\n\t\t\t// this note is started on the first tick.\n\t\t\tnStartTick = 0;\n\t\t\tparam = 0x90 | (param & 0x0F);\n\t\t}\n\n\t\tif(nStartTick != 0 && pChn->rowCommand.note == NOTE_KEYOFF && pChn->rowCommand.volcmd == VOLCMD_PANNING && m_playBehaviour[kFT2PanWithDelayedNoteOff])\n\t\t{\n\t\t\t// FT2 compatibility: If there's a delayed note off, panning commands are ignored. WTF!\n\t\t\t// Test case: PanOff.xm\n\t\t\tpChn->rowCommand.volcmd = VOLCMD_NONE;\n\t\t}\n\n\t\tbool triggerNote = (m_PlayState.m_nTickCount == nStartTick);\t// Can be delayed by a note delay effect\n\t\tif(m_playBehaviour[kFT2OutOfRangeDelay] && nStartTick >= m_PlayState.m_nMusicSpeed)\n\t\t{\n\t\t\t// FT2 compatibility: Note delays greater than the song speed should be ignored.\n\t\t\t// However, EEx pattern delay is *not* considered at all.\n\t\t\t// Test case: DelayCombination.xm, PortaDelay.xm\n\t\t\ttriggerNote = false;\n\t\t} else if(m_playBehaviour[kRowDelayWithNoteDelay] && nStartTick > 0 && tickCount == nStartTick)\n\t\t{\n\t\t\t// IT compatibility: Delayed notes (using SDx) that are on the same row as a Row Delay effect are retriggered.\n\t\t\t// ProTracker / Scream Tracker 3 / FastTracker 2 do the same.\n\t\t\t// Test case: PatternDelay-NoteDelay.it, PatternDelay-NoteDelay.xm, PatternDelaysRetrig.mod\n\t\t\ttriggerNote = true;\n\t\t}\n\n\t\t// IT compatibility: Tick-0 vs non-tick-0 effect distinction is always based on tick delay.\n\t\t// Test case: SlideDelay.it\n\t\tif(m_playBehaviour[kITFirstTickHandling])\n\t\t{\n\t\t\tpChn->isFirstTick = tickCount == nStartTick;\n\t\t}\n\n\t\t// FT2 compatibility: Note + portamento + note delay = no portamento\n\t\t// Test case: PortaDelay.xm\n\t\tif(m_playBehaviour[kFT2PortaDelay] && nStartTick != 0)\n\t\t{\n\t\t\tbPorta = false;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_PT_MODE] && instr && !m_PlayState.m_nTickCount)\n\t\t{\n\t\t\t// Instrument number resets the stacked ProTracker offset.\n\t\t\t// Test case: ptoffset.mod\n\t\t\tpChn->proTrackerOffset = 0;\n\t\t\t// ProTracker compatibility: Sample properties are always loaded on the first tick, even when there is a note delay.\n\t\t\t// Test case: InstrDelay.mod\n\t\t\tif(!triggerNote && pChn->IsSamplePlaying())\n\t\t\t{\n\t\t\t\tpChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\t\t\t\tif(instr <= GetNumSamples())\n\t\t\t\t{\n\t\t\t\t\tpChn->nVolume = Samples[instr].nVolume;\n\t\t\t\t\tpChn->nFineTune = Samples[instr].nFineTune;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Handles note/instrument/volume changes\n\t\tif(triggerNote)\n\t\t{\n\t\t\tModCommand::NOTE note = pChn->rowCommand.note;\n\t\t\tif(instr) pChn->nNewIns = static_cast<ModCommand::INSTR>(instr);\n\n\t\t\tif(ModCommand::IsNote(note) && m_playBehaviour[kFT2Transpose])\n\t\t\t{\n\t\t\t\t// Notes that exceed FT2's limit are completely ignored.\n\t\t\t\t// Test case: NoteLimit.xm\n\t\t\t\tint transpose = pChn->nTranspose;\n\t\t\t\tif(instr && !bPorta)\n\t\t\t\t{\n\t\t\t\t\t// Refresh transpose\n\t\t\t\t\t// Test case: NoteLimit2.xm\n\t\t\t\t\tSAMPLEINDEX sample = SAMPLEINDEX_INVALID;\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Instrument mode\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && Instruments[instr] != nullptr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsample = Instruments[instr]->Keyboard[note - NOTE_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Sample mode\n\t\t\t\t\t\tsample = static_cast<SAMPLEINDEX>(instr);\n\t\t\t\t\t}\n\t\t\t\t\tif(sample <= GetNumSamples())\n\t\t\t\t\t{\n\t\t\t\t\t\ttranspose = GetSample(sample).RelativeTone;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst int computedNote = note + transpose;\n\t\t\t\tif((computedNote < NOTE_MIN + 11 || computedNote > NOTE_MIN + 130))\n\t\t\t\t{\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t}\n\t\t\t} else if((GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) && GetNumInstruments() != 0 && ModCommand::IsNoteOrEmpty(static_cast<ModCommand::NOTE>(note)))\n\t\t\t{\n\t\t\t\t// IT compatibility: Invalid instrument numbers do nothing, but they are remembered for upcoming notes and do not trigger a note in that case.\n\t\t\t\t// Test case: InstrumentNumberChange.it\n\t\t\t\tINSTRUMENTINDEX instrToCheck = static_cast<INSTRUMENTINDEX>((instr != 0) ? instr : pChn->nOldIns);\n\t\t\t\tif(instrToCheck != 0 && (instrToCheck > GetNumInstruments() || Instruments[instrToCheck] == nullptr))\n\t\t\t\t{\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\tinstr = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XM: FT2 ignores a note next to a K00 effect, and a fade-out seems to be done when no volume envelope is present (not exactly the Kxx behaviour)\n\t\t\tif(cmd == CMD_KEYOFF && param == 0 && m_playBehaviour[kFT2KeyOff])\n\t\t\t{\n\t\t\t\tnote = NOTE_NONE;\n\t\t\t\tinstr = 0;\n\t\t\t}\n\n\t\t\tbool retrigEnv = note == NOTE_NONE && instr != 0;\n\n\t\t\t// Apparently, any note number in a pattern causes instruments to recall their original volume settings - no matter if there's a Note Off next to it or whatever.\n\t\t\t// Test cases: keyoff+instr.xm, delay.xm\n\t\t\tbool reloadSampleSettings = (m_playBehaviour[kFT2ReloadSampleSettings] && instr != 0);\n\t\t\t// ProTracker Compatibility: If a sample was stopped before, lone instrument numbers can retrigger it\n\t\t\t// Test case: PTSwapEmpty.mod\n\t\t\tbool keepInstr = (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (m_playBehaviour[kMODSampleSwap] && !pChn->IsSamplePlaying() && pChn->pModSample != nullptr && !pChn->pModSample->HasSampleData());\n\n\t\t\t// Now it's time for some FT2 crap...\n\t\t\tif (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))\n\t\t\t{\n\n\t\t\t\t// XM: Key-Off + Sample == Note Cut (BUT: Only if no instr number or volume effect is present!)\n\t\t\t\t// Test case: NoteOffVolume.xm\n\t\t\t\tif(note == NOTE_KEYOFF\n\t\t\t\t\t&& ((!instr && volcmd != VOLCMD_VOLUME && cmd != CMD_VOLUME) || !m_playBehaviour[kFT2KeyOff])\n\t\t\t\t\t&& (pChn->pModInstrument == nullptr || !pChn->pModInstrument->VolEnv.dwFlags[ENV_ENABLED]))\n\t\t\t\t{\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->nVolume = 0;\n\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\tinstr = 0;\n\t\t\t\t\tretrigEnv = false;\n\t\t\t\t\t// FT2 Compatbility: Start fading the note for notes with no delay. Only relevant when a volume command is encountered after the note-off.\n\t\t\t\t\t// Test case: NoteOffFadeNoEnv.xm\n\t\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && m_playBehaviour[kFT2NoteOffFlags])\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t} else if(m_playBehaviour[kFT2RetrigWithNoteDelay] && !m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\t// FT2 Compatibility: Some special hacks for rogue note delays... (EDx with x > 0)\n\t\t\t\t\t// Apparently anything that is next to a note delay behaves totally unpredictable in FT2. Swedish tracker logic. :)\n\n\t\t\t\t\tretrigEnv = true;\n\n\t\t\t\t\t// Portamento + Note Delay = No Portamento\n\t\t\t\t\t// Test case: porta-delay.xm\n\t\t\t\t\tbPorta = false;\n\n\t\t\t\t\tif(note == NOTE_NONE)\n\t\t\t\t\t{\n\t\t\t\t\t\t// If there's a note delay but no real note, retrig the last note.\n\t\t\t\t\t\t// Test case: delay2.xm, delay3.xm\n\t\t\t\t\t\tnote = static_cast<ModCommand::NOTE>(pChn->nNote - pChn->nTranspose);\n\t\t\t\t\t} else if(note >= NOTE_MIN_SPECIAL)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Gah! Even Note Off + Note Delay will cause envelopes to *retrigger*! How stupid is that?\n\t\t\t\t\t\t// ... Well, and that is actually all it does if there's an envelope. No fade out, no nothing. *sigh*\n\t\t\t\t\t\t// Test case: OffDelay.xm\n\t\t\t\t\t\tnote = NOTE_NONE;\n\t\t\t\t\t\tkeepInstr = false;\n\t\t\t\t\t\treloadSampleSettings = true;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Normal note\n\t\t\t\t\t\tkeepInstr = true;\n\t\t\t\t\t\treloadSampleSettings = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif((retrigEnv && !m_playBehaviour[kFT2ReloadSampleSettings]) || reloadSampleSettings)\n\t\t\t{\n\t\t\t\tconst ModSample *oldSample = nullptr;\n\t\t\t\t// Reset default volume when retriggering envelopes\n\n\t\t\t\tif(GetNumInstruments())\n\t\t\t\t{\n\t\t\t\t\toldSample = pChn->pModSample;\n\t\t\t\t} else if (instr <= GetNumSamples())\n\t\t\t\t{\n\t\t\t\t\t// Case: Only samples are used; no instruments.\n\t\t\t\t\toldSample = &Samples[instr];\n\t\t\t\t}\n\n\t\t\t\tif(oldSample != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(!oldSample->uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\t\t\tpChn->nVolume = oldSample->nVolume;\n\t\t\t\t\tif(reloadSampleSettings)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Also reload panning\n\t\t\t\t\t\tpChn->nPan = oldSample->nPan;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FT2 compatibility: Instrument number disables tremor effect\n\t\t\t// Test case: TremorInstr.xm, TremoRecover.xm\n\t\t\tif(m_playBehaviour[kFT2Tremor] && instr != 0)\n\t\t\t{\n\t\t\t\tpChn->nTremorCount = 0x20;\n\t\t\t}\n\n\t\t\tif(retrigEnv) //Case: instrument with no note data.\n\t\t\t{\n\t\t\t\t//IT compatibility: Instrument with no note.\n\t\t\t\tif(m_playBehaviour[kITInstrWithoutNote] || GetType() == MOD_TYPE_PLM)\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Completely retrigger note after sample end to also reset portamento.\n\t\t\t\t\t// Test case: PortaResetAfterRetrigger.it\n\t\t\t\t\tbool triggerAfterSmpEnd = m_playBehaviour[kITMultiSampleInstrumentNumber] && !pChn->IsSamplePlaying();\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\t// Instrument mode\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && (pChn->pModInstrument != Instruments[instr] || triggerAfterSmpEnd))\n\t\t\t\t\t\t\tnote = pChn->nNote;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\t// Sample mode\n\t\t\t\t\t\tif(instr < MAX_SAMPLES && (pChn->pModSample != &Samples[instr] || triggerAfterSmpEnd))\n\t\t\t\t\t\t\tnote = pChn->nNote;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (GetNumInstruments() && (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)))\n\t\t\t\t{\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->dwFlags.reset(CHN_NOTEFADE);\n\t\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t\t\tpChn->nFadeOutVol = 65536;\n\t\t\t\t\t// FT2 Compatbility: Reset key-off status with instrument number\n\t\t\t\t\t// Test case: NoteOffInstrChange.xm\n\t\t\t\t\tif(m_playBehaviour[kFT2NoteOffFlags])\n\t\t\t\t\t\tpChn->dwFlags.reset(CHN_KEYOFF);\n\t\t\t\t}\n\t\t\t\tif (!keepInstr) instr = 0;\n\t\t\t}\n\n\t\t\t// Note Cut/Off/Fade => ignore instrument\n\t\t\tif (note >= NOTE_MIN_SPECIAL)\n\t\t\t{\n\t\t\t\t// IT compatibility: Default volume of sample is recalled if instrument number is next to a note-off.\n\t\t\t\t// Test case: NoteOffInstr.it, noteoff2.it\n\t\t\t\tif(m_playBehaviour[kITInstrWithNoteOff] && instr)\n\t\t\t\t{\n\t\t\t\t\tSAMPLEINDEX smp = static_cast<SAMPLEINDEX>(instr);\n\t\t\t\t\tif(GetNumInstruments())\n\t\t\t\t\t{\n\t\t\t\t\t\tsmp = 0;\n\t\t\t\t\t\tif(instr <= GetNumInstruments() && Instruments[instr] != nullptr && ModCommand::IsNote(pChn->nLastNote))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmp = Instruments[instr]->Keyboard[pChn->nLastNote - NOTE_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(smp > 0 && smp <= GetNumSamples() && !Samples[smp].uFlags[SMP_NODEFAULTVOLUME])\n\t\t\t\t\t\tpChn->nVolume = Samples[smp].nVolume;\n\t\t\t\t}\n\t\t\t\tinstr = 0;\n\t\t\t}\n\n\t\t\tif(ModCommand::IsNote(note))\n\t\t\t{\n\t\t\t\tpChn->nNewNote = pChn->nLastNote = note;\n\n\t\t\t\t// New Note Action ?\n\t\t\t\tif(!bPorta)\n\t\t\t\t{\n\t\t\t\t\tCheckNNA(nChn, instr, note, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(note)\n\t\t\t{\n\t\t\t\tif(pChn->nRestorePanOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPan = pChn->nRestorePanOnNewNote - 1;\n\t\t\t\t\tpChn->nRestorePanOnNewNote = 0;\n\t\t\t\t}\n\t\t\t\tif(pChn->nRestoreResonanceOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nResonance = pChn->nRestoreResonanceOnNewNote - 1;\n\t\t\t\t\tpChn->nRestoreResonanceOnNewNote = 0;\n\t\t\t\t}\n\t\t\t\tif(pChn->nRestoreCutoffOnNewNote > 0)\n\t\t\t\t{\n\t\t\t\t\tpChn->nCutOff = pChn->nRestoreCutoffOnNewNote - 1;\n\t\t\t\t\tpChn->nRestoreCutoffOnNewNote = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Instrument Change ?\n\t\t\tif(instr)\n\t\t\t{\n\t\t\t\tconst ModSample *oldSample = pChn->pModSample;\n\t\t\t\t//const ModInstrument *oldInstrument = pChn->pModInstrument;\n\n\t\t\t\tInstrumentChange(pChn, instr, bPorta, true);\n\t\t\t\t// IT compatibility: Keep new instrument number for next instrument-less note even if sample playback is stopped\n\t\t\t\t// Test case: StoppedInstrSwap.it\n\t\t\t\tif(GetType() == MOD_TYPE_MOD)\n\t\t\t\t{\n\t\t\t\t\t// Test case: PortaSwapPT.mod\n\t\t\t\t\tif(!bPorta || !m_playBehaviour[kMODSampleSwap]) pChn->nNewIns = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(!m_playBehaviour[kITInstrWithNoteOff] || ModCommand::IsNote(note)) pChn->nNewIns = 0;\n\t\t\t\t}\n\n\t\t\t\tif(m_playBehaviour[kITPortamentoSwapResetsPos])\n\t\t\t\t{\n\t\t\t\t\t// Test cases: PortaInsNum.it, PortaSample.it\n\t\t\t\t\tif(ModCommand::IsNote(note) && oldSample != pChn->pModSample)\n\t\t\t\t\t{\n\t\t\t\t\t\t//const bool newInstrument = oldInstrument != pChn->pModInstrument && pChn->pModInstrument->Keyboard[pChn->nNewNote - NOTE_MIN] != 0;\n\t\t\t\t\t\tpChn->position.Set(0);\n\t\t\t\t\t}\n\t\t\t\t} else if ((GetType() & (MOD_TYPE_S3M | MOD_TYPE_IT | MOD_TYPE_MPT) && oldSample != pChn->pModSample && ModCommand::IsNote(note)))\n\t\t\t\t{\n\t\t\t\t\t// Special IT case: portamento+note causes sample change -> ignore portamento\n\t\t\t\t\tbPorta = false;\n\t\t\t\t} else if(m_playBehaviour[kMODSampleSwap] && pChn->increment.IsZero())\n\t\t\t\t{\n\t\t\t\t\t// If channel was paused and is resurrected by a lone instrument number, reset the sample position.\n\t\t\t\t\t// Test case: PTSwapEmpty.mod\n\t\t\t\t\tpChn->position.Set(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// New Note ?\n\t\t\tif (note)\n\t\t\t{\n\t\t\t\tif ((!instr) && (pChn->nNewIns) && (note < 0x80))\n\t\t\t\t{\n\t\t\t\t\tInstrumentChange(pChn, pChn->nNewIns, bPorta, pChn->pModSample == nullptr && pChn->pModInstrument == nullptr, !(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)));\n\t\t\t\t\tpChn->nNewIns = 0;\n\t\t\t\t}\n\t\t\t\tNoteChange(pChn, note, bPorta, !(GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)));\n\t\t\t\tif ((bPorta) && (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)) && (instr))\n\t\t\t\t{\n\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\tpChn->ResetEnvelopes();\n\t\t\t\t\tpChn->nAutoVibDepth = 0;\n\t\t\t\t\tpChn->nAutoVibPos = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Tick-0 only volume commands\n\t\t\tif (volcmd == VOLCMD_VOLUME)\n\t\t\t{\n\t\t\t\tif (vol > 64) vol = 64;\n\t\t\t\tpChn->nVolume = vol << 2;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t} else\n\t\t\tif (volcmd == VOLCMD_PANNING)\n\t\t\t{\n\t\t\t\tPanning(pChn, vol, Pan6bit);\n\t\t\t}\n\n#ifndef NO_PLUGINS\n\t\t\tif (m_nInstruments) ProcessMidiOut(nChn);\n#endif // NO_PLUGINS\n\t\t}\n\n\t\tif(m_playBehaviour[kST3NoMutedChannels] && ChnSettings[nChn].dwFlags[CHN_MUTE])\t// not even effects are processed on muted S3M channels\n\t\t\tcontinue;\n\n\t\t// Volume Column Effect (except volume & panning)\n\t\t/*\tA few notes, paraphrased from ITTECH.TXT by Storlek (creator of schismtracker):\n\t\t\tEx/Fx/Gx are shared with Exx/Fxx/Gxx; Ex/Fx are 4x the 'normal' slide value\n\t\t\tGx is linked with Ex/Fx if Compat Gxx is off, just like Gxx is with Exx/Fxx\n\t\t\tGx values: 1, 4, 8, 16, 32, 64, 96, 128, 255\n\t\t\tAx/Bx/Cx/Dx values are used directly (i.e. D9 == D09), and are NOT shared with Dxx\n\t\t\t(value is stored into nOldVolParam and used by A0/B0/C0/D0)\n\t\t\tHx uses the same value as Hxx and Uxx, and affects the *depth*\n\t\t\tso... hxx = (hx | (oldhxx & 0xf0))  ???\n\t\t\tTODO is this done correctly?\n\t\t*/\n\t\tbool doVolumeColumn = m_PlayState.m_nTickCount >= nStartTick;\n\t\t// FT2 compatibility: If there's a note delay, volume column effects are NOT executed\n\t\t// on the first tick and, if there's an instrument number, on the delayed tick.\n\t\t// Test case: VolColDelay.xm, PortaDelay.xm\n\t\tif(m_playBehaviour[kFT2VolColDelay] && nStartTick != 0)\n\t\t{\n\t\t\tdoVolumeColumn = m_PlayState.m_nTickCount != 0 && (m_PlayState.m_nTickCount != nStartTick || (pChn->rowCommand.instr == 0 && volcmd != VOLCMD_TONEPORTAMENTO));\n\t\t}\n\t\tif(volcmd > VOLCMD_PANNING && doVolumeColumn)\n\t\t{\n\t\t\tif (volcmd == VOLCMD_TONEPORTAMENTO)\n\t\t\t{\n\t\t\t\tuint32 porta = 0;\n\t\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DMF | MOD_TYPE_DBM | MOD_TYPE_IMF | MOD_TYPE_PSM | MOD_TYPE_J2B | MOD_TYPE_ULT | MOD_TYPE_OKT | MOD_TYPE_MT2 | MOD_TYPE_MDL))\n\t\t\t\t{\n\t\t\t\t\tporta = ImpulseTrackerPortaVolCmd[vol & 0x0F];\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tif(cmd == CMD_TONEPORTAMENTO && GetType() == MOD_TYPE_XM)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Yes, FT2 is *that* weird. If there is a Mx command in the volume column\n\t\t\t\t\t\t// and a normal 3xx command, the 3xx command is ignored but the Mx command's\n\t\t\t\t\t\t// effectiveness is doubled.\n\t\t\t\t\t\t// Test case: TonePortamentoMemory.xm\n\t\t\t\t\t\tcmd = CMD_NONE;\n\t\t\t\t\t\tvol *= 2;\n\t\t\t\t\t}\n\t\t\t\t\tporta = vol << 4;\n\n\t\t\t\t\t// FT2 compatibility: If there's a portamento and a note delay, execute the portamento, but don't update the parameter\n\t\t\t\t\t// Test case: PortaDelay.xm\n\t\t\t\t\tif(m_playBehaviour[kFT2PortaDelay] && nStartTick != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tporta = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTonePortamento(pChn, porta);\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// FT2 Compatibility: FT2 ignores some volume commands with parameter = 0.\n\t\t\t\tif(m_playBehaviour[kFT2VolColMemory] && vol == 0)\n\t\t\t\t{\n\t\t\t\t\tswitch(volcmd)\n\t\t\t\t\t{\n\t\t\t\t\tcase VOLCMD_VOLUME:\n\t\t\t\t\tcase VOLCMD_PANNING:\n\t\t\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase VOLCMD_PANSLIDELEFT:\n\t\t\t\t\t\t// FT2 Compatibility: Pan slide left with zero parameter causes panning to be set to full left on every non-row tick.\n\t\t\t\t\t\t// Test case: PanSlideZero.xm\n\t\t\t\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->nPan = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMPT_FALLTHROUGH;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// no memory here.\n\t\t\t\t\t\tvolcmd = VOLCMD_NONE;\n\t\t\t\t\t}\n\n\t\t\t\t} else if(!m_playBehaviour[kITVolColMemory])\n\t\t\t\t{\n\t\t\t\t\t// IT Compatibility: Effects in the volume column don't have an unified memory.\n\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\tif(vol) pChn->nOldVolParam = static_cast<ModCommand::PARAM>(vol); else vol = pChn->nOldVolParam;\n\t\t\t\t}\n\n\t\t\t\tswitch(volcmd)\n\t\t\t\t{\n\t\t\t\tcase VOLCMD_VOLSLIDEUP:\n\t\t\t\tcase VOLCMD_VOLSLIDEDOWN:\n\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\tif(vol == 0 && m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\tvol = pChn->nOldVolParam;\n\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nOldVolParam = static_cast<ModCommand::PARAM>(vol);\n\t\t\t\t\t}\n\t\t\t\t\tVolumeSlide(pChn, static_cast<ModCommand::PARAM>(volcmd == VOLCMD_VOLSLIDEUP ? (vol << 4) : vol));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_FINEVOLUP:\n\t\t\t\t\t// IT Compatibility: Fine volume slides in the volume column are only executed on the first tick, not on multiples of the first tick in case of pattern delay\n\t\t\t\t\t// Test case: FineVolColSlide.it\n\t\t\t\t\tif(m_PlayState.m_nTickCount == nStartTick || !m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\tFineVolumeUp(pChn, static_cast<ModCommand::PARAM>(vol), m_playBehaviour[kITVolColMemory]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_FINEVOLDOWN:\n\t\t\t\t\t// IT Compatibility: Fine volume slides in the volume column are only executed on the first tick, not on multiples of the first tick in case of pattern delay\n\t\t\t\t\t// Test case: FineVolColSlide.it\n\t\t\t\t\tif(m_PlayState.m_nTickCount == nStartTick || !m_playBehaviour[kITVolColMemory])\n\t\t\t\t\t{\n\t\t\t\t\t\t// IT Compatibility: Volume column volume slides have their own memory\n\t\t\t\t\t\t// Test case: VolColMemory.it\n\t\t\t\t\t\tFineVolumeDown(pChn, static_cast<ModCommand::PARAM>(vol), m_playBehaviour[kITVolColMemory]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_VIBRATOSPEED:\n\t\t\t\t\t// FT2 does not automatically enable vibrato with the \"set vibrato speed\" command\n\t\t\t\t\tif(m_playBehaviour[kFT2VolColVibrato])\n\t\t\t\t\t\tpChn->nVibratoSpeed = vol & 0x0F;\n\t\t\t\t\telse\n\t\t\t\t\t\tVibrato(pChn, vol << 4);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_VIBRATODEPTH:\n\t\t\t\t\tVibrato(pChn, vol);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PANSLIDELEFT:\n\t\t\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(vol), !m_playBehaviour[kFT2VolColMemory]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PANSLIDERIGHT:\n\t\t\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(vol << 4), !m_playBehaviour[kFT2VolColMemory]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PORTAUP:\n\t\t\t\t\t// IT compatibility (one of the first testcases - link effect memory)\n\t\t\t\t\tPortamentoUp(nChn, static_cast<ModCommand::PARAM>(vol << 2), m_playBehaviour[kITVolColFinePortamento]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_PORTADOWN:\n\t\t\t\t\t// IT compatibility (one of the first testcases - link effect memory)\n\t\t\t\t\tPortamentoDown(nChn, static_cast<ModCommand::PARAM>(vol << 2), m_playBehaviour[kITVolColFinePortamento]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase VOLCMD_OFFSET:\n\t\t\t\t\tif (triggerNote && pChn->pModSample && vol <= CountOf(pChn->pModSample->cues))\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength offset;\n\t\t\t\t\t\tif(vol == 0)\n\t\t\t\t\t\t\toffset = pChn->oldOffset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\toffset = pChn->oldOffset = pChn->pModSample->cues[vol - 1];\n\t\t\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Effects\n\t\tif(cmd != CMD_NONE) switch (cmd)\n\t\t{\n\t\t// Set Volume\n\t\tcase CMD_VOLUME:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tpChn->nVolume = (param < 64) ? param * 4 : 256;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Portamento Up\n\t\tcase CMD_PORTAMENTOUP:\n\t\t\tif ((!param) && (GetType() & MOD_TYPE_MOD)) break;\n\t\t\tPortamentoUp(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Portamento Down\n\t\tcase CMD_PORTAMENTODOWN:\n\t\t\tif ((!param) && (GetType() & MOD_TYPE_MOD)) break;\n\t\t\tPortamentoDown(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Volume Slide\n\t\tcase CMD_VOLUMESLIDE:\n\t\t\tif (param || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Tone-Portamento\n\t\tcase CMD_TONEPORTAMENTO:\n\t\t\tTonePortamento(pChn, param);\n\t\t\tbreak;\n\n\t\t// Tone-Portamento + Volume Slide\n\t\tcase CMD_TONEPORTAVOL:\n\t\t\tif ((param) || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tTonePortamento(pChn, 0);\n\t\t\tbreak;\n\n\t\t// Vibrato\n\t\tcase CMD_VIBRATO:\n\t\t\tVibrato(pChn, param);\n\t\t\tbreak;\n\n\t\t// Vibrato + Volume Slide\n\t\tcase CMD_VIBRATOVOL:\n\t\t\tif ((param) || (GetType() != MOD_TYPE_MOD)) VolumeSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tVibrato(pChn, 0);\n\t\t\tbreak;\n\n\t\t// Set Speed\n\t\tcase CMD_SPEED:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\tSetSpeed(m_PlayState, param);\n\t\t\tbreak;\n\n\t\t// Set Tempo\n\t\tcase CMD_TEMPO:\n\t\t\tif(m_playBehaviour[kMODVBlankTiming])\n\t\t\t{\n\t\t\t\t// ProTracker MODs with VBlank timing: All Fxx parameters set the tick count.\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && param != 0) SetSpeed(m_PlayState, param);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t{\n\t\t\t\tparam = CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn);\n\t\t\t\tif (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))\n\t\t\t\t{\n\t\t\t\t\tif (param) pChn->nOldTempo = static_cast<ModCommand::PARAM>(param); else param = pChn->nOldTempo;\n\t\t\t\t}\n\t\t\t\tTEMPO t(param, 0);\n\t\t\t\tLimitMax(t, GetModSpecifications().GetTempoMax());\n\t\t\t\tSetTempo(t);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Set Offset\n\t\tcase CMD_OFFSET:\n\t\t\tif (triggerNote)\n\t\t\t{\n\t\t\t\t// FT2 compatibility: Portamento + Offset = Ignore offset\n\t\t\t\t// Test case: porta-offset.xm\n\t\t\t\tif(bPorta && GetType() == MOD_TYPE_XM)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbool isExtended = false;\n\t\t\t\tSmpLength offset = CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn, &isExtended);\n\t\t\t\tif(!isExtended)\n\t\t\t\t{\n\t\t\t\t\t// No X-param (normal behaviour)\n\t\t\t\t\toffset <<= 8;\n\t\t\t\t\tif (offset) pChn->oldOffset = offset; else offset = pChn->oldOffset;\n\t\t\t\t\toffset += static_cast<SmpLength>(pChn->nOldHiOffset) << 16;\n\t\t\t\t}\n\t\t\t\tSampleOffset(*pChn, offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Disorder Tracker 2 percentage offset\n\t\tcase CMD_OFFSETPERCENTAGE:\n\t\t\tif(triggerNote)\n\t\t\t{\n\t\t\t\tSampleOffset(*pChn, Util::muldiv_unsigned(pChn->nLength, param, 255));\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Arpeggio\n\t\tcase CMD_ARPEGGIO:\n\t\t\t// IT compatibility 01. Don't ignore Arpeggio if no note is playing (also valid for ST3)\n\t\t\tif(m_PlayState.m_nTickCount) break;\n\t\t\tif((!pChn->nPeriod || !pChn->nNote)\n\t\t\t\t&& (pChn->pModInstrument == nullptr || !pChn->pModInstrument->HasValidMIDIChannel())\t// Plugin arpeggio\n\t\t\t\t&& !m_playBehaviour[kITArpeggio] && (GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))) break;\n\t\t\tif (!param && (GetType() & (MOD_TYPE_XM | MOD_TYPE_MOD))) break;\t// Only important when editing MOD/XM files (000 effects are removed when loading files where this means \"no effect\")\n\t\t\tpChn->nCommand = CMD_ARPEGGIO;\n\t\t\tif (param) pChn->nArpeggio = static_cast<ModCommand::PARAM>(param);\n\t\t\tbreak;\n\n\t\t// Retrig\n\t\tcase CMD_RETRIG:\n\t\t\tif (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))\n\t\t\t{\n\t\t\t\tif (!(param & 0xF0)) param |= pChn->nRetrigParam & 0xF0;\n\t\t\t\tif (!(param & 0x0F)) param |= pChn->nRetrigParam & 0x0F;\n\t\t\t\tparam |= 0x100; // increment retrig count on first row\n\t\t\t}\n\t\t\t// IT compatibility 15. Retrigger\n\t\t\tif(m_playBehaviour[kITRetrigger])\n\t\t\t{\n\t\t\t\tif (param) pChn->nRetrigParam = static_cast<uint8>(param & 0xFF);\n\t\t\t\tRetrigNote(nChn, pChn->nRetrigParam, (volcmd == VOLCMD_OFFSET) ? vol + 1 : 0);\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// XM Retrig\n\t\t\t\tif (param) pChn->nRetrigParam = static_cast<uint8>(param & 0xFF); else param = pChn->nRetrigParam;\n\t\t\t\tRetrigNote(nChn, param, (volcmd == VOLCMD_OFFSET) ? vol + 1 : 0);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Tremor\n\t\tcase CMD_TREMOR:\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// IT compatibility 12. / 13. Tremor (using modified DUMB's Tremor logic here because of old effects - http://dumb.sf.net/)\n\t\t\tif(m_playBehaviour[kITTremor])\n\t\t\t{\n\t\t\t\tif(param && !m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t{\n\t\t\t\t\t// Old effects have different length interpretation (+1 for both on and off)\n\t\t\t\t\tif(param & 0xF0) param -= 0x10;\n\t\t\t\t\tif(param & 0x0F) param -= 0x01;\n\t\t\t\t}\n\t\t\t\tpChn->nTremorCount |= 0x80; // set on/off flag\n\t\t\t} else if(m_playBehaviour[kFT2Tremor])\n\t\t\t{\n\t\t\t\t// XM Tremor. Logic is being processed in sndmix.cpp\n\t\t\t\tpChn->nTremorCount |= 0x80; // set on/off flag\n\t\t\t}\n\n\t\t\tpChn->nCommand = CMD_TREMOR;\n\t\t\tif (param) pChn->nTremorParam = static_cast<ModCommand::PARAM>(param);\n\n\t\t\tbreak;\n\n\t\t// Set Global Volume\n\t\tcase CMD_GLOBALVOLUME:\n\t\t\t// IT compatibility: Only apply global volume on first tick (and multiples)\n\t\t\t// Test case: GlobalVolFirstTick.it\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\tbreak;\n\t\t\t// ST3 applies global volume on tick 1 and does other weird things, but we won't emulate this for now.\n// \t\t\tif(((GetType() & MOD_TYPE_S3M) && m_nTickCount != 1)\n// \t\t\t\t|| (!(GetType() & MOD_TYPE_S3M) && !m_SongFlags[SONG_FIRSTTICK]))\n// \t\t\t{\n// \t\t\t\tbreak;\n// \t\t\t}\n\n\t\t\t// FT2 compatibility: On channels that are \"left\" of the global volume command, the new global volume is not applied\n\t\t\t// until the second tick of the row. Since we apply global volume on the mix buffer rather than note volumes, this\n\t\t\t// cannot be fixed for now.\n\t\t\t// Test case: GlobalVolume.xm\n// \t\t\tif(IsCompatibleMode(TRK_FASTTRACKER2) && m_SongFlags[SONG_FIRSTTICK] && m_nMusicSpeed > 1)\n// \t\t\t{\n// \t\t\t\tbreak;\n// \t\t\t}\n\n\t\t\tif (!(GetType() & GLOBALVOL_7BIT_FORMATS)) param *= 2;\n\n\t\t\t// IT compatibility 16. ST3 and IT ignore out-of-range values.\n\t\t\t// Test case: globalvol-invalid.it\n\t\t\tif(param <= 128)\n\t\t\t{\n\t\t\t\tm_PlayState.m_nGlobalVolume = param * 2;\n\t\t\t} else if(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_S3M)))\n\t\t\t{\n\t\t\t\tm_PlayState.m_nGlobalVolume = 256;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Global Volume Slide\n\t\tcase CMD_GLOBALVOLSLIDE:\n\t\t\t//IT compatibility 16. Saving last global volume slide param per channel (FT2/IT)\n\t\t\tif(m_playBehaviour[kPerChannelGlobalVolSlide])\n\t\t\t\tGlobalVolSlide(static_cast<ModCommand::PARAM>(param), pChn->nOldGlobalVolSlide);\n\t\t\telse\n\t\t\t\tGlobalVolSlide(static_cast<ModCommand::PARAM>(param), m_PlayState.Chn[0].nOldGlobalVolSlide);\n\t\t\tbreak;\n\n\t\t// Set 8-bit Panning\n\t\tcase CMD_PANNING8:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tPanning(pChn, param, Pan8bit);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Panning Slide\n\t\tcase CMD_PANNINGSLIDE:\n\t\t\tPanningSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Tremolo\n\t\tcase CMD_TREMOLO:\n\t\t\tTremolo(pChn, param);\n\t\t\tbreak;\n\n\t\t// Fine Vibrato\n\t\tcase CMD_FINEVIBRATO:\n\t\t\tFineVibrato(pChn, param);\n\t\t\tbreak;\n\n\t\t// MOD/XM Exx Extended Commands\n\t\tcase CMD_MODCMDEX:\n\t\t\tExtendedMODCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// S3M/IT Sxx Extended Commands\n\t\tcase CMD_S3MCMDEX:\n\t\t\tif(m_playBehaviour[kST3EffectMemory] && param == 0)\n\t\t\t{\n\t\t\t\tparam = pChn->nArpeggio;\t// S00 uses the last non-zero effect parameter as memory, like other effects including Arpeggio, so we \"borrow\" our memory there.\n\t\t\t}\n\t\t\tExtendedS3MCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Key Off\n\t\tcase CMD_KEYOFF:\n\t\t\t// This is how Key Off is supposed to sound... (in FT2 at least)\n\t\t\tif(m_playBehaviour[kFT2KeyOff])\n\t\t\t{\n\t\t\t\tif (m_PlayState.m_nTickCount == param)\n\t\t\t\t{\n\t\t\t\t\t// XM: Key-Off + Sample == Note Cut\n\t\t\t\t\tif(pChn->pModInstrument == nullptr || !pChn->pModInstrument->VolEnv.dwFlags[ENV_ENABLED])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(param == 0 && (pChn->rowCommand.instr || pChn->rowCommand.volcmd != VOLCMD_NONE)) // FT2 is weird....\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\t\t\t\tpChn->nVolume = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tKeyOff(pChn);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This is how it's NOT supposed to sound...\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t\tKeyOff(pChn);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Extra-fine porta up/down\n\t\tcase CMD_XFINEPORTAUPDOWN:\n\t\t\tswitch(param & 0xF0)\n\t\t\t{\n\t\t\tcase 0x10: ExtraFinePortamentoUp(pChn, param & 0x0F); break;\n\t\t\tcase 0x20: ExtraFinePortamentoDown(pChn, param & 0x0F); break;\n\t\t\t// ModPlug XM Extensions (ignore in compatible mode)\n\t\t\tcase 0x50:\n\t\t\tcase 0x60:\n\t\t\tcase 0x70:\n\t\t\tcase 0x90:\n\t\t\tcase 0xA0:\n\t\t\t\tif(!m_playBehaviour[kFT2RestrictXCommand]) ExtendedS3MCommands(nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Set Channel Global Volume\n\t\tcase CMD_CHANNELVOLUME:\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\tif (param <= 64)\n\t\t\t{\n\t\t\t\tpChn->nGlobalVol = param;\n\t\t\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Channel volume slide\n\t\tcase CMD_CHANNELVOLSLIDE:\n\t\t\tChannelVolSlide(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n\t\t// Panbrello (IT)\n\t\tcase CMD_PANBRELLO:\n\t\t\tPanbrello(pChn, param);\n\t\t\tbreak;\n\n\t\t// Set Envelope Position\n\t\tcase CMD_SETENVPOSITION:\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tpChn->VolEnv.nEnvPosition = param;\n\n\t\t\t\t// FT2 compatibility: FT2 only sets the position of the panning envelope if the volume envelope's sustain flag is set\n\t\t\t\t// Test case: SetEnvPos.xm\n\t\t\t\tif(!m_playBehaviour[kFT2SetPanEnvPos] || pChn->VolEnv.flags[ENV_SUSTAIN])\n\t\t\t\t{\n\t\t\t\t\tpChn->PanEnv.nEnvPosition = param;\n\t\t\t\t\tpChn->PitchEnv.nEnvPosition = param;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Position Jump\n\t\tcase CMD_POSITIONJUMP:\n\t\t\tm_PlayState.m_nNextPatStartRow = 0; // FT2 E60 bug\n\t\t\tnPosJump = static_cast<ORDERINDEX>(CalculateXParam(m_PlayState.m_nPattern, m_PlayState.m_nRow, nChn));\n\n\t\t\t// see https://forum.openmpt.org/index.php?topic=2769.0 - FastTracker resets Dxx if Bxx is called _after_ Dxx\n\t\t\t// Test case: PatternJump.mod\n\t\t\tif((GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM)) && nBreakRow != ROWINDEX_INVALID)\n\t\t\t{\n\t\t\t\tnBreakRow = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// Pattern Break\n\t\tcase CMD_PATTERNBREAK:\n\t\t\t{\n\t\t\t\tROWINDEX row = PatternBreak(m_PlayState, nChn, static_cast<ModCommand::PARAM>(param));\n\t\t\t\tif(row != ROWINDEX_INVALID)\n\t\t\t\t{\n\t\t\t\t\tnBreakRow = row;\n\t\t\t\t\tif(m_SongFlags[SONG_PATTERNLOOP])\n\t\t\t\t\t{\n\t\t\t\t\t\t//If song is set to loop and a pattern break occurs we should stay on the same pattern.\n\t\t\t\t\t\t//Use nPosJump to force playback to \"jump to this pattern\" rather than move to next, as by default.\n\t\t\t\t\t\t//rewbs.to\n\t\t\t\t\t\tnPosJump = m_PlayState.m_nCurrentOrder;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t// IMF / PTM Note Slides\n\t\tcase CMD_NOTESLIDEUP:\n\t\tcase CMD_NOTESLIDEDOWN:\n\t\tcase CMD_NOTESLIDEUPRETRIG:\n\t\tcase CMD_NOTESLIDEDOWNRETRIG:\n\t\t\t// Note that this command seems to be a bit buggy in Polytracker... Luckily, no tune seems to seriously use this\n\t\t\t// (Vic uses it e.g. in Spaceman or Perfect Reason to slide effect samples, noone will notice the difference :)\n\t\t\tNoteSlide(pChn, param, cmd == CMD_NOTESLIDEUP || cmd == CMD_NOTESLIDEUPRETRIG, cmd == CMD_NOTESLIDEUPRETRIG || cmd == CMD_NOTESLIDEDOWNRETRIG);\n\t\t\tbreak;\n\n\t\t// PTM Reverse sample + offset (executed on every tick)\n\t\tcase CMD_REVERSEOFFSET:\n\t\t\tReverseSampleOffset(*pChn, static_cast<ModCommand::PARAM>(param));\n\t\t\tbreak;\n\n#ifndef NO_PLUGINS\n\t\t// DBM: Toggle DSP Echo\n\t\tcase CMD_DBMECHO:\n\t\t\tif(m_PlayState.m_nTickCount == 0)\n\t\t\t{\n\t\t\t\tuint32 chns = (param >> 4), enable = (param & 0x0F);\n\t\t\t\tif(chns > 1 || enable > 2)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tCHANNELINDEX firstChn = nChn, lastChn = nChn;\n\t\t\t\tif(chns == 1)\n\t\t\t\t{\n\t\t\t\t\tfirstChn = 0;\n\t\t\t\t\tlastChn = m_nChannels - 1;\n\t\t\t\t}\n\t\t\t\tfor(CHANNELINDEX c = firstChn; c <= lastChn; c++)\n\t\t\t\t{\n\t\t\t\t\tChnSettings[c].dwFlags.set(CHN_NOFX, enable == 1);\n\t\t\t\t\tm_PlayState.Chn[c].dwFlags.set(CHN_NOFX, enable == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n#endif // NO_PLUGINS\n\t\t}\n\n\t\tif(m_playBehaviour[kST3EffectMemory] && param != 0)\n\t\t{\n\t\t\tUpdateS3MEffectMemory(pChn, static_cast<ModCommand::PARAM>(param));\n\t\t}\n\n\t\tif(pChn->rowCommand.instr)\n\t\t{\n\t\t\t// Not necessarily consistent with actually playing instrument for IT compatibility\n\t\t\tpChn->nOldIns = pChn->rowCommand.instr;\n\t\t}\n\n\t} // for(...) end\n\n\t// Navigation Effects\n\tif(m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\tconst bool doPatternLoop = (nPatLoopRow != ROWINDEX_INVALID);\n\t\tconst bool doBreakRow = (nBreakRow != ROWINDEX_INVALID);\n\t\tconst bool doPosJump = (nPosJump != ORDERINDEX_INVALID);\n\n\t\t// Pattern Loop\n\t\tif(doPatternLoop)\n\t\t{\n\t\t\tm_PlayState.m_nNextOrder = m_PlayState.m_nCurrentOrder;\n\t\t\tm_PlayState.m_nNextRow = nPatLoopRow;\n\t\t\tif(m_PlayState.m_nPatternDelay)\n\t\t\t{\n\t\t\t\tm_PlayState.m_nNextRow++;\n\t\t\t}\n\n\t\t\t// IT Compatibility: If the restart row is past the end of the current pattern\n\t\t\t// (e.g. when continued from a previous pattern without explicit SB0 effect), continue the next pattern.\n\t\t\t// Test case: LoopStartAfterPatternEnd.it\n\t\t\tif(nPatLoopRow >= Patterns[m_PlayState.m_nPattern].GetNumRows())\n\t\t\t{\n\t\t\t\tm_PlayState.m_nNextOrder++;\n\t\t\t\tm_PlayState.m_nNextRow = 0;\n\t\t\t}\n\n\t\t\t// As long as the pattern loop is running, mark the looped rows as not visited yet\n\t\t\tvisitedSongRows.ResetPatternLoop(m_PlayState.m_nCurrentOrder, nPatLoopRow);\n\t\t}\n\n\t\t// Pattern Break / Position Jump only if no loop running\n\t\t// Exception: FastTracker 2 in all cases, Impulse Tracker in case of position jump\n\t\t// Test case for FT2 exception: PatLoop-Jumps.xm, PatLoop-Various.xm\n\t\t// Test case for IT: exception: LoopBreak.it\n\t\tif((doBreakRow || doPosJump)\n\t\t\t&& (!doPatternLoop || m_playBehaviour[kFT2PatternLoopWithJumps] || (m_playBehaviour[kITPatternLoopWithJumps] && doPosJump)))\n\t\t{\n\t\t\tif(!doPosJump) nPosJump = m_PlayState.m_nCurrentOrder + 1;\n\t\t\tif(!doBreakRow) nBreakRow = 0;\n\t\t\tm_SongFlags.set(SONG_BREAKTOROW);\n\n\t\t\tif(nPosJump >= Order().size())\n\t\t\t{\n\t\t\t\tnPosJump = Order().GetRestartPos();\n\t\t\t}\n\n\t\t\t// IT / FT2 compatibility: don't reset loop count on pattern break.\n\t\t\t// Test case: gm-trippy01.it, PatLoop-Break.xm, PatLoop-Weird.xm, PatLoop-Break.mod\n\t\t\tif(nPosJump != m_PlayState.m_nCurrentOrder\n\t\t\t\t&& !m_playBehaviour[kITPatternLoopBreak] && !m_playBehaviour[kFT2PatternLoopWithJumps] && GetType() != MOD_TYPE_MOD)\n\t\t\t{\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++)\n\t\t\t\t{\n\t\t\t\t\tm_PlayState.Chn[i].nPatternLoopCount = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm_PlayState.m_nNextRow = nBreakRow;\n\t\t\tif(!m_SongFlags[SONG_PATTERNLOOP])\n\t\t\t\tm_PlayState.m_nNextOrder = nPosJump;\n\t\t}\n\n\t}\n\treturn true;\n}\n\n\n////////////////////////////////////////////////////////////\n// Channels effects\n\n\n// Update the effect memory of all S3M effects that use the last non-zero effect parameter as memory (Dxy, Exx, Fxx, Ixy, Jxy, Kxy, Lxy, Qxy, Rxy, Sxy)\n// Test case: ParamMemory.s3m\nvoid CSoundFile::UpdateS3MEffectMemory(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tpChn->nOldVolumeSlide = param;\t// Dxy / Kxy / Lxy\n\tpChn->nOldPortaUp = param;\t\t// Exx / Fxx\n\tpChn->nOldPortaDown = param;\t// Exx / Fxx\n\tpChn->nTremorParam = param;\t\t// Ixy\n\tpChn->nArpeggio = param;\t\t// Jxy\n\tpChn->nRetrigParam = param;\t\t// Qxy\n\tpChn->nTremoloDepth = (param & 0x0F) << 2;\t// Rxy\n\tpChn->nTremoloSpeed = (param >> 4) & 0x0F;\t// Rxy\n\t// Sxy is not handled here.\n}\n\n\n// Calculate full parameter for effects that support parameter extension at the given pattern location.\n// maxCommands sets the maximum number of XParam commands to look at for this effect\n// isExtended returns if the command is actually using any XParam extensions.\nuint32 CSoundFile::CalculateXParam(PATTERNINDEX pat, ROWINDEX row, CHANNELINDEX chn, bool *isExtended) const\n{\n\tif(isExtended != nullptr) *isExtended = false;\n\tROWINDEX maxCommands = 4;\n\tconst ModCommand *m = Patterns[pat].GetpModCommand(row, chn);\n\tuint32 val = m->param;\n\n\tswitch(m->command)\n\t{\n\tcase CMD_OFFSET:\n\t\t// 24 bit command\n\t\tmaxCommands = 2;\n\t\tbreak;\n\tcase CMD_TEMPO:\n\tcase CMD_PATTERNBREAK:\n\tcase CMD_POSITIONJUMP:\n\t\t// 16 bit command\n\t\tmaxCommands = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn val;\n\t}\n\n\tconst bool xmTempoFix = m->command == CMD_TEMPO && GetType() == MOD_TYPE_XM;\n\tROWINDEX numRows = std::min(Patterns[pat].GetNumRows() - row - 1, maxCommands);\n\twhile(numRows > 0)\n\t{\n\t\tm += Patterns[pat].GetNumChannels();\n\t\tif(m->command != CMD_XPARAM)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif(xmTempoFix && val < 256)\n\t\t{\n\t\t\t// With XM, 0x20 is the lowest tempo. Anything below changes ticks per row.\n\t\t\tval -= 0x20;\n\t\t}\n\t\tval = (val << 8) | m->param;\n\t\tnumRows--;\n\t\tif(isExtended != nullptr) *isExtended = true;\n\t}\n\treturn val;\n}\n\n\nROWINDEX CSoundFile::PatternBreak(PlayState &state, CHANNELINDEX chn, uint8 param) const\n{\n\tif(param >= 64 && (GetType() & MOD_TYPE_S3M))\n\t{\n\t\t// ST3 ignores invalid pattern breaks.\n\t\treturn ROWINDEX_INVALID;\n\t}\n\n\tstate.m_nNextPatStartRow = 0; // FT2 E60 bug\n\n\treturn static_cast<ROWINDEX>(CalculateXParam(state.m_nPattern, state.m_nRow, chn));\n}\n\n\nvoid CSoundFile::PortamentoUp(CHANNELINDEX nChn, ModCommand::PARAM param, const bool doFinePortamentoAsRegular)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\tif(param)\n\t{\n\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\tpChn->nOldPortaDown = param;\n\t\tpChn->nOldPortaUp = param;\n\t} else\n\t{\n\t\tparam = pChn->nOldPortaUp;\n\t}\n\n\tconst bool doFineSlides = !doFinePortamentoAsRegular && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_AMF0 | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM));\n\n\t// Process MIDI pitch bend for instrument plugins\n\tMidiPortamento(nChn, param, doFineSlides);\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t// Portamento for instruments with custom tuning\n\t\tif(param >= 0xF0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoFineMPT(pChn, param - 0xF0);\n\t\telse if(param >= 0xE0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoExtraFineMPT(pChn, param - 0xE0);\n\t\telse\n\t\t\tPortamentoMPT(pChn, param);\n\t\treturn;\n\t} else if(GetType() == MOD_TYPE_PLM)\n\t{\n\t\t// A normal portamento up or down makes a follow-up tone portamento go the same direction.\n\t\tpChn->nPortamentoDest = 1;\n\t}\n\n\tif (doFineSlides && param >= 0xE0)\n\t{\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif ((param & 0xF0) == 0xF0)\n\t\t\t{\n\t\t\t\tFinePortamentoUp(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t} else if ((param & 0xF0) == 0xE0 && GetType() != MOD_TYPE_DBM)\n\t\t\t{\n\t\t\t\tExtraFinePortamentoUp(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(GetType() != MOD_TYPE_DBM)\n\t\t{\n\t\t\t// DBM only has fine slides, no extra-fine slides.\n\t\t\treturn;\n\t\t}\n\t}\n\t// Regular Slide\n\tif(!pChn->isFirstTick || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]) || GetType() == MOD_TYPE_669)\n\t{\n\t\tDoFreqSlide(pChn, -int(param) * 4);\n\t}\n}\n\n\nvoid CSoundFile::PortamentoDown(CHANNELINDEX nChn, ModCommand::PARAM param, const bool doFinePortamentoAsRegular)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\n\tif(param)\n\t{\n\t\t// FT2 compatibility: Separate effect memory for all portamento commands\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(!m_playBehaviour[kFT2PortaUpDownMemory])\n\t\t\tpChn->nOldPortaUp = param;\n\t\tpChn->nOldPortaDown = param;\n\t} else\n\t{\n\t\tparam = pChn->nOldPortaDown;\n\t}\n\n\tconst bool doFineSlides = !doFinePortamentoAsRegular && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_AMF0 | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM));\n\n\t// Process MIDI pitch bend for instrument plugins\n\tMidiPortamento(nChn, -static_cast<int>(param), doFineSlides);\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t// Portamento for instruments with custom tuning\n\t\tif(param >= 0xF0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoFineMPT(pChn, -static_cast<int>(param - 0xF0));\n\t\telse if(param >= 0xE0 && !doFinePortamentoAsRegular)\n\t\t\tPortamentoExtraFineMPT(pChn, -static_cast<int>(param - 0xE0));\n\t\telse\n\t\t\tPortamentoMPT(pChn, -static_cast<int>(param));\n\t\treturn;\n\t} else if(GetType() == MOD_TYPE_PLM)\n\t{\n\t\t// A normal portamento up or down makes a follow-up tone portamento go the same direction.\n\t\tpChn->nPortamentoDest = 65535;\n\t}\n\n\tif(doFineSlides && param >= 0xE0)\n\t{\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif ((param & 0xF0) == 0xF0)\n\t\t\t{\n\t\t\t\tFinePortamentoDown(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t} else if ((param & 0xF0) == 0xE0 && GetType() != MOD_TYPE_DBM)\n\t\t\t{\n\t\t\t\tExtraFinePortamentoDown(pChn, param & 0x0F);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(GetType() != MOD_TYPE_DBM)\n\t\t{\n\t\t\t// DBM only has fine slides, no extra-fine slides.\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(!pChn->isFirstTick || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]) || GetType() == MOD_TYPE_669)\n\t{\n\t\tDoFreqSlide(pChn, int(param) * 4);\n\t}\n}\n\n\n// Send portamento commands to plugins\nvoid CSoundFile::MidiPortamento(CHANNELINDEX nChn, int param, bool doFineSlides)\n{\n\tint actualParam = mpt::abs(param);\n\tint pitchBend = 0;\n\n\t// Old MIDI Pitch Bends:\n\t// - Applied on every tick\n\t// - No fine pitch slides (they are interpreted as normal slides)\n\t// New MIDI Pitch Bends:\n\t// - Behaviour identical to sample pitch bends if the instrument's PWD parameter corresponds to the actual VSTi setting.\n\n\tif(doFineSlides && actualParam >= 0xE0 && !m_playBehaviour[kOldMIDIPitchBends])\n\t{\n\t\tif(m_PlayState.Chn[nChn].isFirstTick)\n\t\t{\n\t\t\t// Extra fine slide...\n\t\t\tpitchBend = (actualParam & 0x0F) * sgn(param);\n\t\t\tif(actualParam >= 0xF0)\n\t\t\t{\n\t\t\t\t// ... or just a fine slide!\n\t\t\t\tpitchBend *= 4;\n\t\t\t}\n\t\t}\n\t} else if(!m_PlayState.Chn[nChn].isFirstTick || m_playBehaviour[kOldMIDIPitchBends])\n\t{\n\t\t// Regular slide\n\t\tpitchBend = param * 4;\n\t}\n\n\tif(pitchBend)\n\t{\n#ifndef NO_PLUGINS\n\t\tIMixPlugin *plugin = GetChannelInstrumentPlugin(nChn);\n\t\tif(plugin != nullptr)\n\t\t{\n\t\t\tint8 pwd = 13;\t// Early OpenMPT legacy... Actually it's not *exactly* 13, but close enough...\n\t\t\tif(m_PlayState.Chn[nChn].pModInstrument != nullptr)\n\t\t\t{\n\t\t\t\tpwd = m_PlayState.Chn[nChn].pModInstrument->midiPWD;\n\t\t\t}\n\t\t\tplugin->MidiPitchBend(GetBestMidiChannel(nChn), pitchBend, pwd);\n\t\t}\n#endif // NO_PLUGINS\n\t}\n}\n\n\nvoid CSoundFile::FinePortamentoUp(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldFinePortaUpDown = (pChn->nOldFinePortaUpDown & 0x0F) | (param << 4); else param = (pChn->nOldFinePortaUpDown >> 4);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tconst auto oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetLinearSlideUpTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod)\n\t\t\t\t{\n\t\t\t\t\tif(m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\t\telse if(!m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod > 1)\n\t\t\t\t\t\tpChn->nPeriod--;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod -= (int)(param * 4);\n\t\t\t\tif (pChn->nPeriod < 1)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPeriod = 1;\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nFadeOutVol = 0;\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::FinePortamentoDown(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldFinePortaUpDown = (pChn->nOldFinePortaUpDown & 0xF0) | (param & 0x0F); else param = (pChn->nOldFinePortaUpDown & 0x0F);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif (m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tconst auto oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetLinearSlideDownTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod)\n\t\t\t\t{\n\t\t\t\t\tif(!m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\t\telse if(m_playBehaviour[kHertzInLinearMode] && pChn->nPeriod > 1)\n\t\t\t\t\t\tpChn->nPeriod--;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod += (int)(param * 4);\n\t\t\t\tif (pChn->nPeriod > 0xFFFF) pChn->nPeriod = 0xFFFF;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::ExtraFinePortamentoUp(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldExtraFinePortaUpDown = (pChn->nOldExtraFinePortaUpDown & 0x0F) | (param << 4); else param = (pChn->nOldExtraFinePortaUpDown >> 4);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tint oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetFineLinearSlideUpTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod) pChn->nPeriod++;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod -= (int)(param);\n\t\t\t\tif (pChn->nPeriod < 1)\n\t\t\t\t{\n\t\t\t\t\tpChn->nPeriod = 1;\n\t\t\t\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->nFadeOutVol = 0;\n\t\t\t\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::ExtraFinePortamentoDown(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: E1x / E2x / X1x / X2x memory is not linked\n\t\t// Test case: Porta-LinkMem.xm\n\t\tif(param) pChn->nOldExtraFinePortaUpDown = (pChn->nOldExtraFinePortaUpDown & 0xF0) | (param & 0x0F); else param = (pChn->nOldExtraFinePortaUpDown & 0x0F);\n\t} else if(GetType() == MOD_TYPE_MT2)\n\t{\n\t\tif(param) pChn->nOldFinePortaUpDown = param; else param = pChn->nOldFinePortaUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tif ((pChn->nPeriod) && (param))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tint oldPeriod = pChn->nPeriod;\n\t\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, GetFineLinearSlideDownTable(this, param & 0x0F), 65536);\n\t\t\t\tif(oldPeriod == pChn->nPeriod) pChn->nPeriod--;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tpChn->nPeriod += (int)(param);\n\t\t\t\tif (pChn->nPeriod > 0xFFFF) pChn->nPeriod = 0xFFFF;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Implemented for IMF compatibility, can't actually save this in any formats\n// Slide up / down every x ticks by y semitones\nvoid CSoundFile::NoteSlide(ModChannel *pChn, uint32 param, bool slideUp, bool retrig) const\n{\n\tuint8 x, y;\n\tif(m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\tx = param & 0xF0;\n\t\tif (x)\n\t\t\tpChn->nNoteSlideSpeed = (x >> 4);\n\t\ty = param & 0x0F;\n\t\tif (y)\n\t\t\tpChn->nNoteSlideStep = y;\n\t\tpChn->nNoteSlideCounter = pChn->nNoteSlideSpeed;\n\t} else\n\t{\n\t\tif (--pChn->nNoteSlideCounter == 0)\n\t\t{\n\t\t\tpChn->nNoteSlideCounter = pChn->nNoteSlideSpeed;\n\t\t\t// update it\n\t\t\tpChn->nPeriod = GetPeriodFromNote\n\t\t\t\t((slideUp ? 1 : -1)  * pChn->nNoteSlideStep + GetNoteFromPeriod(pChn->nPeriod), 8363, 0);\n\n\t\t\tif(retrig)\n\t\t\t{\n\t\t\t\tpChn->position.Set(0);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Portamento Slide\nvoid CSoundFile::TonePortamento(ModChannel *pChn, uint32 param) const\n{\n\tpChn->dwFlags.set(CHN_PORTAMENTO);\n\n\t//IT compatibility 03: Share effect memory with portamento up/down\n\tif((!m_SongFlags[SONG_ITCOMPATGXX] && m_playBehaviour[kITPortaMemoryShare]) || GetType() == MOD_TYPE_PLM)\n\t{\n\t\tif(param == 0) param = pChn->nOldPortaUp;\n\t\tpChn->nOldPortaUp = pChn->nOldPortaDown = static_cast<uint8>(param);\n\t}\n\n\tif(GetType() == MOD_TYPE_MPT && pChn->pModInstrument && pChn->pModInstrument->pTuning)\n\t{\n\t\t//Behavior: Param tells number of finesteps(or 'fullsteps'(notes) with glissando)\n\t\t//to slide per row(not per tick).\n\t\tconst int32 old_PortamentoTickSlide = (m_PlayState.m_nTickCount != 0) ? pChn->m_PortamentoTickSlide : 0;\n\n\t\tif(param)\n\t\t\tpChn->nPortamentoSlide = param;\n\t\telse\n\t\t\tif(pChn->nPortamentoSlide == 0)\n\t\t\t\treturn;\n\n\n\t\tif((pChn->nPortamentoDest > 0 && pChn->nPortamentoSlide < 0) ||\n\t\t\t(pChn->nPortamentoDest < 0 && pChn->nPortamentoSlide > 0))\n\t\t\tpChn->nPortamentoSlide = -pChn->nPortamentoSlide;\n\n\t\tpChn->m_PortamentoTickSlide = static_cast<int32>((m_PlayState.m_nTickCount + 1.0) * pChn->nPortamentoSlide / m_PlayState.m_nMusicSpeed);\n\n\t\tif(pChn->dwFlags[CHN_GLISSANDO])\n\t\t{\n\t\t\tpChn->m_PortamentoTickSlide *= pChn->pModInstrument->pTuning->GetFineStepCount() + 1;\n\t\t\t//With glissando interpreting param as notes instead of finesteps.\n\t\t}\n\n\t\tconst int32 slide = pChn->m_PortamentoTickSlide - old_PortamentoTickSlide;\n\n\t\tif(mpt::abs(pChn->nPortamentoDest) <= mpt::abs(slide))\n\t\t{\n\t\t\tif(pChn->nPortamentoDest != 0)\n\t\t\t{\n\t\t\t\tpChn->m_PortamentoFineSteps += pChn->nPortamentoDest;\n\t\t\t\tpChn->nPortamentoDest = 0;\n\t\t\t\tpChn->m_CalculateFreq = true;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->m_PortamentoFineSteps += slide;\n\t\t\tpChn->nPortamentoDest -= slide;\n\t\t\tpChn->m_CalculateFreq = true;\n\t\t}\n\n\t\treturn;\n\t} //End candidate MPT behavior.\n\n\tbool doPorta = !pChn->isFirstTick || (GetType() & (MOD_TYPE_DBM | MOD_TYPE_669)) || (m_PlayState.m_nMusicSpeed == 1 && m_playBehaviour[kSlidesAtSpeed1]);\n\tif(GetType() == MOD_TYPE_PLM && param >= 0xF0)\n\t{\n\t\tparam -= 0xF0;\n\t\tdoPorta = pChn->isFirstTick;\n\t}\n\n\tif(param)\n\t{\n\t\tif(GetType() == MOD_TYPE_669)\n\t\t{\n\t\t\tparam *= 10;\n\t\t}\n\t\tpChn->nPortamentoSlide = param * 4;\n\t}\n\n\tif(pChn->nPeriod && pChn->nPortamentoDest && doPorta)\n\t{\n\t\tif (pChn->nPeriod < pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\t// Return (a*b+c/2)/c - no divide error\n\t\t\t\t// Table is 65536*2(n/192)\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideUpTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta < 1) delta = 1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod > pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t} else\n\t\tif (pChn->nPeriod > pChn->nPortamentoDest)\n\t\t{\n\t\t\tint32 delta = -pChn->nPortamentoSlide;\n\t\t\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t\t\t{\n\t\t\t\tuint32 n = pChn->nPortamentoSlide / 4;\n\t\t\t\tif (n > 255) n = 255;\n\t\t\t\tdelta = Util::muldivr(pChn->nPeriod, LinearSlideDownTable[n], 65536) - pChn->nPeriod;\n\t\t\t\tif (delta > -1) delta = -1;\n\t\t\t}\n\t\t\tpChn->nPeriod += delta;\n\t\t\tif (pChn->nPeriod < pChn->nPortamentoDest) pChn->nPeriod = pChn->nPortamentoDest;\n\t\t}\n\t}\n\n\t// IT compatibility 23. Portamento with no note\n\t// ProTracker also disables portamento once the target is reached.\n\t// Test case: PortaTarget.mod\n\tif(pChn->nPeriod == pChn->nPortamentoDest && (m_playBehaviour[kITPortaTargetReached] || GetType() == MOD_TYPE_MOD))\n\t\tpChn->nPortamentoDest = 0;\n\n}\n\n\nvoid CSoundFile::Vibrato(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nVibratoDepth = (param & 0x0F) * 4;\n\tif (param & 0xF0) p->nVibratoSpeed = (param >> 4) & 0x0F;\n\tp->dwFlags.set(CHN_VIBRATO);\n}\n\n\nvoid CSoundFile::FineVibrato(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nVibratoDepth = param & 0x0F;\n\tif (param & 0xF0) p->nVibratoSpeed = (param >> 4) & 0x0F;\n\tp->dwFlags.set(CHN_VIBRATO);\n\t// ST3 compatibility: Do not distinguish between vibrato types in effect memory\n\t// Test case: VibratoTypeChange.s3m\n\tif(m_playBehaviour[kST3VibratoMemory] && (param & 0x0F))\n\t{\n\t\tp->nVibratoDepth *= 4u;\n\t}\n}\n\n\nvoid CSoundFile::Panbrello(ModChannel *p, uint32 param) const\n{\n\tif (param & 0x0F) p->nPanbrelloDepth = param & 0x0F;\n\tif (param & 0xF0) p->nPanbrelloSpeed = (param >> 4) & 0x0F;\n}\n\n\nvoid CSoundFile::Panning(ModChannel *pChn, uint32 param, PanningType panBits) const\n{\n\t// No panning in ProTracker mode\n\tif(m_playBehaviour[kMODIgnorePanning])\n\t{\n\t\treturn;\n\t}\n\t// IT Compatibility (and other trackers as well): panning disables surround (unless panning in rear channels is enabled, which is not supported by the original trackers anyway)\n\tif (!m_SongFlags[SONG_SURROUNDPAN] && (panBits == Pan8bit || m_playBehaviour[kPanOverride]))\n\t{\n\t\tpChn->dwFlags.reset(CHN_SURROUND);\n\t}\n\tif(panBits == Pan4bit)\n\t{\n\t\t// 0...15 panning\n\t\tpChn->nPan = (param * 256 + 8) / 15;\n\t} else if(panBits == Pan6bit)\n\t{\n\t\t// 0...64 panning\n\t\tif(param > 64) param = 64;\n\t\tpChn->nPan = param * 4;\n\t} else\n\t{\n\t\tif(!(GetType() & (MOD_TYPE_S3M | MOD_TYPE_DSM | MOD_TYPE_AMF | MOD_TYPE_MTM)))\n\t\t{\n\t\t\t// Real 8-bit panning\n\t\t\tpChn->nPan = param;\n\t\t} else\n\t\t{\n\t\t\t// 7-bit panning + surround\n\t\t\tif(param <= 0x80)\n\t\t\t{\n\t\t\t\tpChn->nPan = param << 1;\n\t\t\t} else if(param == 0xA4)\n\t\t\t{\n\t\t\t\tpChn->dwFlags.set(CHN_SURROUND);\n\t\t\t\tpChn->nPan = 0x80;\n\t\t\t}\n\t\t}\n\t}\n\n\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\tpChn->nRestorePanOnNewNote = 0;\n\t//IT compatibility 20. Set pan overrides random pan\n\tif(m_playBehaviour[kPanOverride])\n\t{\n\t\tpChn->nPanSwing = 0;\n\t\tpChn->nPanbrelloOffset = 0;\n\t}\n}\n\n\nvoid CSoundFile::VolumeSlide(ModChannel *pChn, ModCommand::PARAM param)\n{\n\tif (param)\n\t\tpChn->nOldVolumeSlide = param;\n\telse\n\t\tparam = pChn->nOldVolumeSlide;\n\n\tif((GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MED | MOD_TYPE_DIGI | MOD_TYPE_STP | MOD_TYPE_DTM)))\n\t{\n\t\t// MOD / XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tint newvolume = pChn->nVolume;\n\tif(!(GetType() & (MOD_TYPE_MOD | MOD_TYPE_XM | MOD_TYPE_AMF0 | MOD_TYPE_MED | MOD_TYPE_DIGI)))\n\t{\n\t\tif ((param & 0x0F) == 0x0F) //Fine upslide or slide -15\n\t\t{\n\t\t\tif (param & 0xF0) //Fine upslide\n\t\t\t{\n\t\t\t\tFineVolumeUp(pChn, (param >> 4), false);\n\t\t\t\treturn;\n\t\t\t} else //Slide -15\n\t\t\t{\n\t\t\t\tif(pChn->isFirstTick && !m_SongFlags[SONG_FASTVOLSLIDES])\n\t\t\t\t{\n\t\t\t\t\tnewvolume -= 0x0F * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\tif ((param & 0xF0) == 0xF0) //Fine downslide or slide +15\n\t\t{\n\t\t\tif (param & 0x0F) //Fine downslide\n\t\t\t{\n\t\t\t\tFineVolumeDown(pChn, (param & 0x0F), false);\n\t\t\t\treturn;\n\t\t\t} else //Slide +15\n\t\t\t{\n\t\t\t\tif(pChn->isFirstTick && !m_SongFlags[SONG_FASTVOLSLIDES])\n\t\t\t\t{\n\t\t\t\t\tnewvolume += 0x0F * 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(!pChn->isFirstTick || m_SongFlags[SONG_FASTVOLSLIDES] || (m_PlayState.m_nMusicSpeed == 1 && GetType() == MOD_TYPE_DBM))\n\t{\n\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\tif (param & 0x0F)\n\t\t{\n\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (param & 0xF0) == 0)\n\t\t\t\tnewvolume -= (int)((param & 0x0F) * 4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnewvolume += (int)((param & 0xF0) >> 2);\n\t\t}\n\t\tif (GetType() == MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n\tnewvolume = Clamp(newvolume, 0, 256);\n\n\tpChn->nVolume = newvolume;\n}\n\n\nvoid CSoundFile::PanningSlide(ModChannel *pChn, ModCommand::PARAM param, bool memory)\n{\n\tif(memory)\n\t{\n\t\t// FT2 compatibility: Use effect memory (lxx and rxx in XM shouldn't use effect memory).\n\t\t// Test case: PanSlideMem.xm\n\t\tif(param)\n\t\t\tpChn->nOldPanSlide = param;\n\t\telse\n\t\t\tparam = pChn->nOldPanSlide;\n\t}\n\n\tif((GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\t// XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tint32 nPanSlide = 0;\n\n\tif(!(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tparam = (param & 0xF0) / 4u;\n\t\t\t\tnPanSlide = - (int)param;\n\t\t\t}\n\t\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t\t{\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t{\n\t\t\t\tnPanSlide = (param & 0x0F) * 4u;\n\t\t\t}\n\t\t} else if(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0x0F)\n\t\t\t{\n\t\t\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT)) || (param & 0xF0) == 0)\n\t\t\t\t\tnPanSlide = (int)((param & 0x0F) * 4u);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnPanSlide = -(int)((param & 0xF0) / 4u);\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0xF0)\n\t\t\t{\n\t\t\t\tnPanSlide = (int)((param & 0xF0) / 4u);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnPanSlide = -(int)((param & 0x0F) * 4u);\n\t\t\t}\n\t\t\t// FT2 compatibility: FT2's panning slide is like IT's fine panning slide (not as deep)\n\t\t\tif(m_playBehaviour[kFT2PanSlide])\n\t\t\t\tnPanSlide /= 4;\n\t\t}\n\t}\n\tif (nPanSlide)\n\t{\n\t\tnPanSlide += pChn->nPan;\n\t\tnPanSlide = Clamp(nPanSlide, 0, 256);\n\t\tpChn->nPan = nPanSlide;\n\t\tpChn->nRestorePanOnNewNote = 0;\n\t}\n}\n\n\nvoid CSoundFile::FineVolumeUp(ModChannel *pChn, ModCommand::PARAM param, bool volCol) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: EAx / EBx memory is not linked\n\t\t// Test case: FineVol-LinkMem.xm\n\t\tif(param) pChn->nOldFineVolUpDown = (param << 4) | (pChn->nOldFineVolUpDown & 0x0F); else param = (pChn->nOldFineVolUpDown >> 4);\n\t} else if(volCol)\n\t{\n\t\tif(param) pChn->nOldVolParam = param; else param = pChn->nOldVolParam;\n\t} else\n\t{\n\t\tif(param) pChn->nOldFineVolUpDown = param; else param = pChn->nOldFineVolUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->nVolume += param * 4;\n\t\tif(pChn->nVolume > 256) pChn->nVolume = 256;\n\t\tif(GetType() & MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n}\n\n\nvoid CSoundFile::FineVolumeDown(ModChannel *pChn, ModCommand::PARAM param, bool volCol) const\n{\n\tif(GetType() == MOD_TYPE_XM)\n\t{\n\t\t// FT2 compatibility: EAx / EBx memory is not linked\n\t\t// Test case: FineVol-LinkMem.xm\n\t\tif(param) pChn->nOldFineVolUpDown = param | (pChn->nOldFineVolUpDown & 0xF0); else param = (pChn->nOldFineVolUpDown & 0x0F);\n\t} else if(volCol)\n\t{\n\t\tif(param) pChn->nOldVolParam = param; else param = pChn->nOldVolParam;\n\t} else\n\t{\n\t\tif(param) pChn->nOldFineVolUpDown = param; else param = pChn->nOldFineVolUpDown;\n\t}\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->nVolume -= param * 4;\n\t\tif(pChn->nVolume < 0) pChn->nVolume = 0;\n\t\tif(GetType() & MOD_TYPE_MOD) pChn->dwFlags.set(CHN_FASTVOLRAMP);\n\t}\n}\n\n\nvoid CSoundFile::Tremolo(ModChannel *pChn, uint32 param) const\n{\n\tif (param & 0x0F) pChn->nTremoloDepth = (param & 0x0F) << 2;\n\tif (param & 0xF0) pChn->nTremoloSpeed = (param >> 4) & 0x0F;\n\tpChn->dwFlags.set(CHN_TREMOLO);\n}\n\n\nvoid CSoundFile::ChannelVolSlide(ModChannel *pChn, ModCommand::PARAM param) const\n{\n\tint32 nChnSlide = 0;\n\tif (param) pChn->nOldChnVolSlide = param; else param = pChn->nOldChnVolSlide;\n\n\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nChnSlide = param >> 4;\n\t} else if (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nChnSlide = - (int)(param & 0x0F);\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0x0F)\n\t\t\t{\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_J2B | MOD_TYPE_DBM)) || (param & 0xF0) == 0)\n\t\t\t\t\tnChnSlide = -(int)(param & 0x0F);\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnChnSlide = (int)((param & 0xF0) >> 4);\n\t\t\t}\n\t\t}\n\t}\n\tif (nChnSlide)\n\t{\n\t\tnChnSlide += pChn->nGlobalVol;\n\t\tnChnSlide = Clamp(nChnSlide, 0, 64);\n\t\tpChn->nGlobalVol = nChnSlide;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedMODCommands(CHANNELINDEX nChn, ModCommand::PARAM param)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\tuint8 command = param & 0xF0;\n\tparam &= 0x0F;\n\tswitch(command)\n\t{\n\t// E0x: Set Filter\n\tcase 0x00:\n\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t{\n\t\t\tm_PlayState.Chn[chn].dwFlags.set(CHN_AMIGAFILTER, !(param & 1));\n\t\t}\n\t\tbreak;\n\t// E1x: Fine Portamento Up\n\tcase 0x10:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FinePortamentoUp(pChn, param); break;\n\t// E2x: Fine Portamento Down\n\tcase 0x20:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FinePortamentoDown(pChn, param); break;\n\t// E3x: Set Glissando Control\n\tcase 0x30:\tpChn->dwFlags.set(CHN_GLISSANDO, param != 0); break;\n\t// E4x: Set Vibrato WaveForm\n\tcase 0x40:\tpChn->nVibratoType = param & 0x07; break;\n\t// E5x: Set FineTune\n\tcase 0x50:\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(GetType() & (MOD_TYPE_MOD | MOD_TYPE_DIGI | MOD_TYPE_AMF0 | MOD_TYPE_MED))\n\t\t\t\t{\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param);\n\t\t\t\t\tif(pChn->nPeriod && pChn->rowCommand.IsNote()) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t} else if(pChn->rowCommand.IsNote())\n\t\t\t\t{\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param - 8);\n\t\t\t\t\tif(pChn->nPeriod) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// E6x: Pattern Loop\n\t// E7x: Set Tremolo WaveForm\n\tcase 0x70:\tpChn->nTremoloType = param & 0x07; break;\n\t// E8x: Set 4-bit Panning\n\tcase 0x80:\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tPanning(pChn, param, Pan4bit);\n\t\t}\n\t\tbreak;\n\t// E9x: Retrig\n\tcase 0x90:\tRetrigNote(nChn, param); break;\n\t// EAx: Fine Volume Up\n\tcase 0xA0:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FineVolumeUp(pChn, param, false); break;\n\t// EBx: Fine Volume Down\n\tcase 0xB0:\tif ((param) || (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2))) FineVolumeDown(pChn, param, false); break;\n\t// ECx: Note Cut\n\tcase 0xC0:\tNoteCut(nChn, param, false); break;\n\t// EDx: Note Delay\n\t// EEx: Pattern Delay\n\tcase 0xF0:\n\t\tif(GetType() == MOD_TYPE_MOD) // MOD: Invert Loop\n\t\t{\n\t\t\tpChn->nEFxSpeed = param;\n\t\t\tif(m_SongFlags[SONG_FIRSTTICK]) InvertLoop(pChn);\n\t\t} else // XM: Set Active Midi Macro\n\t\t{\n\t\t\tpChn->nActiveMacro = param;\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedS3MCommands(CHANNELINDEX nChn, ModCommand::PARAM param)\n{\n\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\tuint8 command = param & 0xF0;\n\tparam &= 0x0F;\n\tswitch(command)\n\t{\n\t// S0x: Set Filter\n\t// S1x: Set Glissando Control\n\tcase 0x10:\tpChn->dwFlags.set(CHN_GLISSANDO, param != 0); break;\n\t// S2x: Set FineTune\n\tcase 0x20:\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\t\tif(GetType() != MOD_TYPE_669)\n\t\t\t\t{\n\t\t\t\t\tpChn->nC5Speed = S3MFineTuneTable[param];\n\t\t\t\t\tpChn->nFineTune = MOD2XMFineTune(param);\n\t\t\t\t\tif (pChn->nPeriod) pChn->nPeriod = GetPeriodFromNote(pChn->nNote, pChn->nFineTune, pChn->nC5Speed);\n\t\t\t\t} else if(pChn->pModSample != nullptr)\n\t\t\t\t{\n\t\t\t\t\tpChn->nC5Speed = pChn->pModSample->nC5Speed + param * 80;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S3x: Set Vibrato Waveform\n\tcase 0x30:\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t{\n\t\t\t\t\tpChn->nVibratoType = param & 0x03;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tpChn->nVibratoType = (param < 0x04) ? param : 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tpChn->nVibratoType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S4x: Set Tremolo Waveform\n\tcase 0x40:\tif(GetType() == MOD_TYPE_S3M)\n\t\t\t\t{\n\t\t\t\t\tpChn->nTremoloType = param & 0x03;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t\t\tpChn->nTremoloType = (param < 0x04) ? param : 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tpChn->nTremoloType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S5x: Set Panbrello Waveform\n\tcase 0x50:\n\t\t// IT compatibility: Ignore waveform types > 3\n\t\t\t\tif(m_playBehaviour[kITVibratoTremoloPanbrello])\n\t\t\t\t{\n\t\t\t\t\tpChn->nPanbrelloType = (param < 0x04) ? param : 0;\n\t\t\t\t\tpChn->nPanbrelloPos = 0;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tpChn->nPanbrelloType = param & 0x07;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S6x: Pattern Delay for x frames\n\tcase 0x60:\n\t\t\t\tif(m_SongFlags[SONG_FIRSTTICK] && m_PlayState.m_nTickCount == 0)\n\t\t\t\t{\n\t\t\t\t\t// Tick delays are added up.\n\t\t\t\t\t// Scream Tracker 3 does actually not support this command.\n\t\t\t\t\t// We'll use the same behaviour as for Impulse Tracker, as we can assume that\n\t\t\t\t\t// most S3Ms that make use of this command were made with Impulse Tracker.\n\t\t\t\t\t// MPT added this command to the XM format through the X6x effect, so we will use\n\t\t\t\t\t// the same behaviour here as well.\n\t\t\t\t\t// Test cases: PatternDelays.it, PatternDelays.s3m, PatternDelays.xm\n\t\t\t\t\tm_PlayState.m_nFrameDelay += param;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S7x: Envelope Control / Instrument Control\n\tcase 0x70:\tif(!m_SongFlags[SONG_FIRSTTICK]) break;\n\t\t\t\tswitch(param)\n\t\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\t\t{\n\t\t\t\t\t\tModChannel *bkp = &m_PlayState.Chn[m_nChannels];\n\t\t\t\t\t\tfor (CHANNELINDEX i=m_nChannels; i<MAX_CHANNELS; i++, bkp++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (bkp->nMasterChn == nChn+1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (param == 1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tKeyOff(bkp);\n\t\t\t\t\t\t\t\t} else if (param == 2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbkp->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbkp->dwFlags.set(CHN_NOTEFADE);\n\t\t\t\t\t\t\t\t\tbkp->nFadeOutVol = 0;\n\t\t\t\t\t\t\t\t}\n#ifndef NO_PLUGINS\n\t\t\t\t\t\t\t\tconst ModInstrument *pIns = bkp->pModInstrument;\n\t\t\t\t\t\t\t\tIMixPlugin *pPlugin;\n\t\t\t\t\t\t\t\tif(pIns != nullptr && pIns->nMixPlug && (pPlugin = m_MixPlugins[pIns->nMixPlug - 1].pMixPlugin) != nullptr)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpPlugin->MidiCommand(GetBestMidiChannel(nChn), pIns->nMidiProgram, pIns->wMidiBank, bkp->nNote + NOTE_MAX_SPECIAL, 0, nChn);\n\t\t\t\t\t\t\t\t}\n#endif // NO_PLUGINS\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t\tpChn->nNNA = NNA_NOTECUT; break;\n\t\t\t\tcase 4:\t\tpChn->nNNA = NNA_CONTINUE; break;\n\t\t\t\tcase 5:\t\tpChn->nNNA = NNA_NOTEOFF; break;\n\t\t\t\tcase 6:\t\tpChn->nNNA = NNA_NOTEFADE; break;\n\t\t\t\tcase 7:\t\tpChn->VolEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 8:\t\tpChn->VolEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 9:\t\tpChn->PanEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 10:\tpChn->PanEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 11:\tpChn->PitchEnv.flags.reset(ENV_ENABLED); break;\n\t\t\t\tcase 12:\tpChn->PitchEnv.flags.set(ENV_ENABLED); break;\n\t\t\t\tcase 13:\t// S7D: Enable pitch envelope, force to play as pitch envelope\n\t\t\t\tcase 14:\t// S7E: Enable pitch envelope, force to play as filter envelope\n\t\t\t\t\tif(GetType() == MOD_TYPE_MPT)\n\t\t\t\t\t{\n\t\t\t\t\t\tpChn->PitchEnv.flags.set(ENV_ENABLED);\n\t\t\t\t\t\tpChn->PitchEnv.flags.set(ENV_FILTER, param != 13);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// S8x: Set 4-bit Panning\n\tcase 0x80:\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tPanning(pChn, param, Pan4bit);\n\t\t}\n\t\tbreak;\n\t// S9x: Sound Control\n\tcase 0x90:\tExtendedChannelEffect(pChn, param); break;\n\t// SAx: Set 64k Offset\n\tcase 0xA0:\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t\t\t{\n\t\t\t\t\tpChn->nOldHiOffset = static_cast<uint8>(param);\n\t\t\t\t\tif (!m_playBehaviour[kITHighOffsetNoRetrig] && pChn->rowCommand.IsNote())\n\t\t\t\t\t{\n\t\t\t\t\t\tSmpLength pos = param << 16;\n\t\t\t\t\t\tif (pos < pChn->nLength) pChn->position.SetInt(pos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t// SBx: Pattern Loop\n\t// SCx: Note Cut\n\tcase 0xC0:\n\t\tif(param == 0)\n\t\t{\n\t\t\t//IT compatibility 22. SC0 == SC1\n\t\t\tif(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT))\n\t\t\t\tparam = 1;\n\t\t\t// ST3 doesn't cut notes with SC0\n\t\t\telse if(GetType() == MOD_TYPE_S3M)\n\t\t\t\treturn;\n\t\t}\n\t\t// S3M/IT compatibility: Note Cut really cuts notes and does not just mute them (so that following volume commands could restore the sample)\n\t\t// Test case: scx.it\n\t\tNoteCut(nChn, param, m_playBehaviour[kITSCxStopsSample] || GetType() == MOD_TYPE_S3M);\n\t\tbreak;\n\t// SDx: Note Delay\n\t// SEx: Pattern Delay for x rows\n\t// SFx: S3M: Not used, IT: Set Active Midi Macro\n\tcase 0xF0:\n\t\tif(GetType() != MOD_TYPE_S3M)\n\t\t{\n\t\t\tpChn->nActiveMacro = static_cast<uint8>(param);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::ExtendedChannelEffect(ModChannel *pChn, uint32 param)\n{\n\t// S9x and X9x commands (S3M/XM/IT only)\n\tif(!m_SongFlags[SONG_FIRSTTICK]) return;\n\tswitch(param & 0x0F)\n\t{\n\t// S90: Surround Off\n\tcase 0x00:\tpChn->dwFlags.reset(CHN_SURROUND);\tbreak;\n\t// S91: Surround On\n\tcase 0x01:\tpChn->dwFlags.set(CHN_SURROUND); pChn->nPan = 128; break;\n\n\t////////////////////////////////////////////////////////////\n\t// ModPlug Extensions\n\t// S98: Reverb Off\n\tcase 0x08:\n\t\tpChn->dwFlags.reset(CHN_REVERB);\n\t\tpChn->dwFlags.set(CHN_NOREVERB);\n\t\tbreak;\n\t// S99: Reverb On\n\tcase 0x09:\n\t\tpChn->dwFlags.reset(CHN_NOREVERB);\n\t\tpChn->dwFlags.set(CHN_REVERB);\n\t\tbreak;\n\t// S9A: 2-Channels surround mode\n\tcase 0x0A:\n\t\tm_SongFlags.reset(SONG_SURROUNDPAN);\n\t\tbreak;\n\t// S9B: 4-Channels surround mode\n\tcase 0x0B:\n\t\tm_SongFlags.set(SONG_SURROUNDPAN);\n\t\tbreak;\n\t// S9C: IT Filter Mode\n\tcase 0x0C:\n\t\tm_SongFlags.reset(SONG_MPTFILTERMODE);\n\t\tbreak;\n\t// S9D: MPT Filter Mode\n\tcase 0x0D:\n\t\tm_SongFlags.set(SONG_MPTFILTERMODE);\n\t\tbreak;\n\t// S9E: Go forward\n\tcase 0x0E:\n\t\tpChn->dwFlags.reset(CHN_PINGPONGFLAG);\n\t\tbreak;\n\t// S9F: Go backward (and set playback position to the end if sample just started)\n\tcase 0x0F:\n\t\tif(pChn->position.IsZero() && pChn->nLength && (pChn->rowCommand.IsNote() || !pChn->dwFlags[CHN_LOOP]))\n\t\t{\n\t\t\tpChn->position.Set(pChn->nLength - 1, SamplePosition::fractMax);\n\t\t}\n\t\tpChn->dwFlags.set(CHN_PINGPONGFLAG);\n\t\tbreak;\n\t}\n}\n\n\nvoid CSoundFile::InvertLoop(ModChannel *pChn)\n{\n\t// EFx implementation for MOD files (PT 1.1A and up: Invert Loop)\n\t// This effect trashes samples. Thanks to 8bitbubsy for making this work. :)\n\tif(GetType() != MOD_TYPE_MOD || pChn->nEFxSpeed == 0) return;\n\n\t// we obviously also need a sample for this\n\tModSample *pModSample = const_cast<ModSample *>(pChn->pModSample);\n\tif(pModSample == nullptr || !pModSample->HasSampleData() || !pModSample->uFlags[CHN_LOOP] || pModSample->uFlags[CHN_16BIT]) return;\n\n\tpChn->nEFxDelay += ModEFxTable[pChn->nEFxSpeed & 0x0F];\n\tif((pChn->nEFxDelay & 0x80) == 0) return; // only applied if the \"delay\" reaches 128\n\tpChn->nEFxDelay = 0;\n\n\tif (++pChn->nEFxOffset >= pModSample->nLoopEnd - pModSample->nLoopStart)\n\t\tpChn->nEFxOffset = 0;\n\n\t// TRASH IT!!! (Yes, the sample!)\n\tuint8 &sample = mpt::byte_cast<uint8 *>(pModSample->sampleb())[pModSample->nLoopStart + pChn->nEFxOffset];\n\tsample = ~sample;\n\tctrlSmp::PrecomputeLoops(*pModSample, *this, false);\n}\n\n\n// Process a MIDI Macro.\n// Parameters:\n// [in] nChn: Mod channel to apply macro on\n// [in] isSmooth: If true, internal macros are interpolated between two rows\n// [in] macro: Actual MIDI Macro string\n// [in] param: Parameter for parametric macros (Z00 - Z7F)\n// [in] plugin: Plugin to send MIDI message to (if not specified but needed, it is autodetected)\nvoid CSoundFile::ProcessMIDIMacro(CHANNELINDEX nChn, bool isSmooth, const char *macro, uint8 param, PLUGINDEX plugin)\n{\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tconst ModInstrument *pIns = GetNumInstruments() ? chn.pModInstrument : nullptr;\n\n\tuint8 out[MACRO_LENGTH];\n\tuint32 outPos = 0;\t// output buffer position, which also equals the number of complete bytes\n\tconst uint8 lastZxxParam = chn.lastZxxParam;\n\tbool firstNibble = true;\n\n\tfor(uint32 pos = 0; pos < (MACRO_LENGTH - 1) && macro[pos]; pos++)\n\t{\n\t\tbool isNibble = false;\t\t// did we parse a nibble or a byte value?\n\t\tuint8 data = 0;\t\t// data that has just been parsed\n\n\t\t// Parse next macro byte... See Impulse Tracker's MIDI.TXT for detailed information on each possible character.\n\t\tif(macro[pos] >= '0' && macro[pos] <= '9')\n\t\t{\n\t\t\tisNibble = true;\n\t\t\tdata = static_cast<uint8>(macro[pos] - '0');\n\t\t}\n\t\telse if(macro[pos] >= 'A' && macro[pos] <= 'F')\n\t\t{\n\t\t\tisNibble = true;\n\t\t\tdata = static_cast<uint8>(macro[pos] - 'A' + 0x0A);\n\t\t} else if(macro[pos] == 'c')\n\t\t{\n\t\t\t// MIDI channel\n\t\t\tisNibble = true;\n\t\t\tdata = GetBestMidiChannel(nChn);\n\t\t} else if(macro[pos] == 'n')\n\t\t{\n\t\t\t// Last triggered note\n\t\t\tif(ModCommand::IsNote(chn.nLastNote))\n\t\t\t{\n\t\t\t\tdata = chn.nLastNote - NOTE_MIN;\n\t\t\t}\n\t\t} else if(macro[pos] == 'v')\n\t\t{\n\t\t\t// Velocity\n\t\t\t// This is \"almost\" how IT does it - apparently, IT seems to lag one row behind on global volume or channel volume changes.\n\t\t\tconst int swing = (m_playBehaviour[kITSwingBehaviour] || m_playBehaviour[kMPTOldSwingBehaviour]) ? chn.nVolSwing : 0;\n\t\t\tconst int vol = Util::muldiv((chn.nVolume + swing) * m_PlayState.m_nGlobalVolume, chn.nGlobalVol * chn.nInsVol, 1 << 20);\n\t\t\tdata = static_cast<uint8>(Clamp(vol / 2, 1, 127));\n\t\t\t//data = (unsigned char)MIN((chn.nVolume * chn.nGlobalVol * m_nGlobalVolume) >> (1 + 6 + 8), 127);\n\t\t} else if(macro[pos] == 'u')\n\t\t{\n\t\t\t// Calculated volume\n\t\t\t// Same note as with velocity applies here, but apparently also for instrument / sample volumes?\n\t\t\tconst int vol = Util::muldiv(chn.nCalcVolume * m_PlayState.m_nGlobalVolume, chn.nGlobalVol * chn.nInsVol, 1 << 26);\n\t\t\tdata = static_cast<uint8>(Clamp(vol / 2, 1, 127));\n\t\t\t//data = (unsigned char)MIN((chn.nCalcVolume * chn.nGlobalVol * m_nGlobalVolume) >> (7 + 6 + 8), 127);\n\t\t} else if(macro[pos] == 'x')\n\t\t{\n\t\t\t// Pan set\n\t\t\tdata = static_cast<uint8>(std::min(chn.nPan / 2, 127));\n\t\t} else if(macro[pos] == 'y')\n\t\t{\n\t\t\t// Calculated pan\n\t\t\tdata = static_cast<uint8>(std::min(chn.nRealPan / 2, 127));\n\t\t} else if(macro[pos] == 'a')\n\t\t{\n\t\t\t// High byte of bank select\n\t\t\tif(pIns && pIns->wMidiBank)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>(((pIns->wMidiBank - 1) >> 7) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'b')\n\t\t{\n\t\t\t// Low byte of bank select\n\t\t\tif(pIns && pIns->wMidiBank)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>((pIns->wMidiBank - 1) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'o')\n\t\t{\n\t\t\t// Offset (ignoring high offset)\n\t\t\tdata = static_cast<uint8>((chn.oldOffset >> 8) & 0xFF);\n\t\t} else if(macro[pos] == 'h')\n\t\t{\n\t\t\t// Host channel number\n\t\t\tdata = static_cast<uint8>((nChn >= GetNumChannels() ? (chn.nMasterChn - 1) : nChn) & 0x7F);\n\t\t} else if(macro[pos] == 'm')\n\t\t{\n\t\t\t// Loop direction (judging from the character, it was supposed to be loop type, though)\n\t\t\tdata = chn.dwFlags[CHN_PINGPONGFLAG] ? 1 : 0;\n\t\t} else if(macro[pos] == 'p')\n\t\t{\n\t\t\t// Program select\n\t\t\tif(pIns && pIns->nMidiProgram)\n\t\t\t{\n\t\t\t\tdata = static_cast<uint8>((pIns->nMidiProgram - 1) & 0x7F);\n\t\t\t}\n\t\t} else if(macro[pos] == 'z')\n\t\t{\n\t\t\t// Zxx parameter\n\t\t\tdata = param & 0x7F;\n\t\t\tif(isSmooth && chn.lastZxxParam < 0x80\n\t\t\t\t&& (outPos < 3 || out[outPos - 3] != 0xF0 || out[outPos - 2] < 0xF0))\n\t\t\t{\n\t\t\t\t// Interpolation for external MIDI messages - interpolation for internal messages\n\t\t\t\t// is handled separately to allow for more than 7-bit granularity where it's possible\n\t\t\t\tdata = static_cast<uint8>(CalculateSmoothParamChange((float)lastZxxParam, (float)data));\n\t\t\t}\n\t\t\tchn.lastZxxParam = data;\n\t\t} else if(macro[pos] == 's')\n\t\t{\n\t\t\t// SysEx Checksum (not an original Impulse Tracker macro variable, but added for convenience)\n\t\t\tuint32 startPos = outPos;\n\t\t\twhile(startPos > 0 && out[--startPos] != 0xF0);\n\t\t\tif(outPos - startPos < 5 || out[startPos] != 0xF0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(uint32 p = startPos + 5; p != outPos; p++)\n\t\t\t{\n\t\t\t\tdata += out[p];\n\t\t\t}\n\t\t\tdata = (~data + 1) & 0x7F;\n\t\t} else\n\t\t{\n\t\t\t// Unrecognized byte (e.g. space char)\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Append parsed data\n\t\tif(isNibble)\t// parsed a nibble (constant or 'c' variable)\n\t\t{\n\t\t\tif(firstNibble)\n\t\t\t{\n\t\t\t\tout[outPos] = data;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tout[outPos] = (out[outPos] << 4) | data;\n\t\t\t\toutPos++;\n\t\t\t}\n\t\t\tfirstNibble = !firstNibble;\n\t\t} else\t\t\t// parsed a byte (variable)\n\t\t{\n\t\t\tif(!firstNibble)\t// From MIDI.TXT: '9n' is exactly the same as '09 n' or '9 n' -- so finish current byte first\n\t\t\t{\n\t\t\t\toutPos++;\n\t\t\t}\n\t\t\tout[outPos++] = data;\n\t\t\tfirstNibble = true;\n\t\t}\n\t}\n\tif(!firstNibble)\n\t{\n\t\t// Finish current byte\n\t\toutPos++;\n\t}\n\n\t// Macro string has been parsed and translated, now send the message(s)...\n\tuint32 sendPos = 0;\n\tuint8 runningStatus = 0;\n\twhile(sendPos < outPos)\n\t{\n\t\tuint32 sendLen = 0;\n\t\tif(out[sendPos] == 0xF0)\n\t\t{\n\t\t\t// SysEx start\n\t\t\tif((outPos - sendPos >= 4) && (out[sendPos + 1] == 0xF0 || out[sendPos + 1] == 0xF1))\n\t\t\t{\n\t\t\t\t// Internal macro (normal (F0F0) or extended (F0F1)), 4 bytes long\n\t\t\t\tsendLen = 4;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// SysEx message, find end of message\n\t\t\t\tfor(uint32 i = sendPos + 1; i < outPos; i++)\n\t\t\t\t{\n\t\t\t\t\tif(out[i] == 0xF7)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Found end of SysEx message\n\t\t\t\t\t\tsendLen = i - sendPos + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sendLen == 0)\n\t\t\t\t{\n\t\t\t\t\t// Didn't find end, so \"invent\" end of SysEx message\n\t\t\t\t\tout[outPos++] = 0xF7;\n\t\t\t\t\tsendLen = outPos - sendPos;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(!(out[sendPos] & 0x80))\n\t\t{\n\t\t\t// Missing status byte? Try inserting running status\n\t\t\tif(runningStatus != 0)\n\t\t\t{\n\t\t\t\tsendPos--;\n\t\t\t\tout[sendPos] = runningStatus;\n\t\t\t} else\n\t\t\t{\n\t\t\t\t// No running status to re-use; skip this byte\n\t\t\t\tsendPos++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else\n\t\t{\n\t\t\t// Other MIDI messages\n\t\t\tsendLen = std::min<uint32>(MIDIEvents::GetEventLength(out[sendPos]), outPos - sendPos);\n\t\t}\n\n\t\tif(sendLen == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif(out[sendPos] < 0xF0)\n\t\t{\n\t\t\trunningStatus = out[sendPos];\n\t\t}\n\t\tuint32 bytesSent = SendMIDIData(nChn, isSmooth, out + sendPos, sendLen, plugin);\n\t\t// If there's no error in the macro data (e.g. unrecognized internal MIDI macro), we have sendLen == bytesSent.\n\t\tif(bytesSent > 0)\n\t\t{\n\t\t\tsendPos += bytesSent;\n\t\t} else\n\t\t{\n\t\t\tsendPos += sendLen;\n\t\t}\n\t}\n}\n\n\n// Calculate smooth MIDI macro slide parameter for current tick.\nfloat CSoundFile::CalculateSmoothParamChange(float currentValue, float param) const\n{\n\tMPT_ASSERT(GetNumTicksOnCurrentRow() > m_PlayState.m_nTickCount);\n\tconst uint32 ticksLeft = GetNumTicksOnCurrentRow() - m_PlayState.m_nTickCount;\n\tif(ticksLeft > 1)\n\t{\n\t\t// Slide param\n\t\tconst float step = (param - currentValue) / (float)ticksLeft;\n\t\treturn (currentValue + step);\n\t} else\n\t{\n\t\t// On last tick, set exact value.\n\t\treturn param;\n\t}\n}\n\n\n// Process exactly one MIDI message parsed by ProcessMIDIMacro. Returns bytes sent on success, 0 on (parse) failure.\nuint32 CSoundFile::SendMIDIData(CHANNELINDEX nChn, bool isSmooth, const unsigned char *macro, uint32 macroLen, PLUGINDEX plugin)\n{\n\tif(macroLen < 1)\n\t{\n\t\treturn 0;\n\t}\n\n\tif(macro[0] == 0xFA || macro[0] == 0xFC || macro[0] == 0xFF)\n\t{\n\t\t// Start Song, Stop Song, MIDI Reset - both interpreted internally and sent to plugins\n\t\tfor(CHANNELINDEX chn = 0; chn < GetNumChannels(); chn++)\n\t\t{\n\t\t\tm_PlayState.Chn[chn].nCutOff = 0x7F;\n\t\t\tm_PlayState.Chn[chn].nResonance = 0x00;\n\t\t}\n\t}\n\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tif(macro[0] == 0xF0 && (macro[1] == 0xF0 || macro[1] == 0xF1))\n\t{\n\t\t// Internal device.\n\t\tif(macroLen < 4)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tconst bool isExtended = (macro[1] == 0xF1);\n\t\tconst uint8 macroCode = macro[2];\n\t\tconst uint8 param = macro[3];\n\n\t\tif(macroCode == 0x00 && !isExtended && param < 0x80)\n\t\t{\n\t\t\t// F0.F0.00.xx: Set CutOff\n\t\t\tif(!isSmooth)\n\t\t\t{\n\t\t\t\tchn.nCutOff = param;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tchn.nCutOff = Util::Round<uint8>(CalculateSmoothParamChange(chn.nCutOff, param));\n\t\t\t}\n\t\t\tchn.nRestoreCutoffOnNewNote = 0;\n\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\n\t\t\treturn 4;\n\t\t} else if(macroCode == 0x01 && !isExtended && param < 0x80)\n\t\t{\n\t\t\t// F0.F0.01.xx: Set Resonance\n\t\t\tif(!isSmooth)\n\t\t\t{\n\t\t\t\tchn.nResonance = param;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tchn.nResonance = (uint8)CalculateSmoothParamChange((float)chn.nResonance, (float)param);\n\t\t\t}\n\t\t\tchn.nRestoreResonanceOnNewNote = 0;\n\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\n\t\t\treturn 4;\n\t\t} else if(macroCode == 0x02 && !isExtended)\n\t\t{\n\t\t\t// F0.F0.02.xx: Set filter mode (high nibble determines filter mode)\n\t\t\tif(param < 0x20)\n\t\t\t{\n\t\t\t\tchn.nFilterMode = (param >> 4);\n\t\t\t\tSetupChannelFilter(&chn, !chn.dwFlags[CHN_FILTER]);\n\t\t\t}\n\n\t\t\treturn 4;\n#ifndef NO_PLUGINS\n\t\t} else if(macroCode == 0x03 && !isExtended)\n\t\t{\n\t\t\t// F0.F0.03.xx: Set plug dry/wet\n\t\t\tconst PLUGINDEX nPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\tif ((nPlug) && (nPlug <= MAX_MIXPLUGINS) && param < 0x80)\n\t\t\t{\n\t\t\t\tconst float newRatio = (0x7F - (param & 0x7F)) / 127.0f;\n\t\t\t\tif(!isSmooth)\n\t\t\t\t{\n\t\t\t\t\tm_MixPlugins[nPlug - 1].fDryRatio = newRatio;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tm_MixPlugins[nPlug - 1].fDryRatio = CalculateSmoothParamChange(m_MixPlugins[nPlug - 1].fDryRatio, newRatio);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 4;\n\t\t} else if((macroCode & 0x80) || isExtended)\n\t\t{\n\t\t\t// F0.F0.{80|n}.xx / F0.F1.n.xx: Set VST effect parameter n to xx\n\t\t\tconst PLUGINDEX nPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\tconst uint32 plugParam = isExtended ? (0x80 + macroCode) : (macroCode & 0x7F);\n\t\t\tif((nPlug) && (nPlug <= MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tIMixPlugin *pPlugin = m_MixPlugins[nPlug - 1].pMixPlugin;\n\t\t\t\tif(pPlugin && param < 0x80)\n\t\t\t\t{\n\t\t\t\t\tconst float fParam = param / 127.0f;\n\t\t\t\t\tif(!isSmooth)\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->SetParameter(plugParam, fParam);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->SetParameter(plugParam, CalculateSmoothParamChange(pPlugin->GetParameter(plugParam), fParam));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 4;\n#endif // NO_PLUGINS\n\t\t}\n\n\t\t// If we reach this point, the internal macro was invalid.\n\n\t} else\n\t{\n#ifndef NO_PLUGINS\n\t\t// Not an internal device. Pass on to appropriate plugin.\n\t\tconst CHANNELINDEX plugChannel = (nChn < GetNumChannels()) ? nChn + 1 : chn.nMasterChn;\n\t\tif(plugChannel > 0 && plugChannel <= GetNumChannels())\t// XXX do we need this? I guess it might be relevant for previewing notes in the pattern... Or when using this mechanism for volume/panning!\n\t\t{\n\t\t\tPLUGINDEX nPlug = 0;\n\t\t\tif(!chn.dwFlags[CHN_NOFX])\n\t\t\t{\n\t\t\t\tnPlug = (plugin != 0) ? plugin : GetBestPlugin(nChn, PrioritiseChannel, EvenIfMuted);\n\t\t\t}\n\n\t\t\tif(nPlug > 0 && nPlug <= MAX_MIXPLUGINS)\n\t\t\t{\n\t\t\t\tIMixPlugin *pPlugin = m_MixPlugins[nPlug - 1].pMixPlugin;\n\t\t\t\tif (pPlugin != nullptr)\n\t\t\t\t{\n\t\t\t\t\tif(macro[0] == 0xF0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpPlugin->MidiSysexSend(macro, macroLen);\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32 len = std::min<uint32>(MIDIEvents::GetEventLength(macro[0]), macroLen);\n\t\t\t\t\t\tuint32 curData = 0;\n\t\t\t\t\t\tmemcpy(&curData, macro, len);\n\t\t\t\t\t\tpPlugin->MidiSend(curData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tMPT_UNREFERENCED_PARAMETER(plugin);\n#endif // NO_PLUGINS\n\n\t\treturn macroLen;\n\n\t}\n\n\treturn 0;\n\n}\n\n\nvoid CSoundFile::SendMIDINote(CHANNELINDEX chn, uint16 note, uint16 volume)\n{\n#ifndef NO_PLUGINS\n\tauto &channel = m_PlayState.Chn[chn];\n\tconst ModInstrument *pIns = channel.pModInstrument;\n\t// instro sends to a midi chan\n\tif (pIns && pIns->HasValidMIDIChannel())\n\t{\n\t\tPLUGINDEX nPlug = pIns->nMixPlug;\n\t\tif ((nPlug) && (nPlug <= MAX_MIXPLUGINS))\n\t\t{\n\t\t\tIMixPlugin *pPlug = m_MixPlugins[nPlug-1].pMixPlugin;\n\t\t\tif (pPlug != nullptr)\n\t\t\t{\n\t\t\t\tpPlug->MidiCommand(GetBestMidiChannel(chn), pIns->nMidiProgram, pIns->wMidiBank, note, volume, chn);\n\t\t\t\tif(note < NOTE_MIN_SPECIAL)\n\t\t\t\t\tchannel.nLeftVU = channel.nRightVU = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n#endif // NO_PLUGINS\n}\n\n\nvoid CSoundFile::SampleOffset(ModChannel &chn, SmpLength param) const\n{\n\tchn.proTrackerOffset += param;\n\n\tif(param >= chn.nLoopEnd && GetType() == MOD_TYPE_MTM && chn.dwFlags[CHN_LOOP] && chn.nLoopEnd > 0)\n\t{\n\t\t// Offset wrap-around\n\t\tparam = (param - chn.nLoopStart) % (chn.nLoopEnd - chn.nLoopStart) + chn.nLoopStart;\n\t}\n\n\tif(GetType() == MOD_TYPE_MDL && chn.dwFlags[CHN_16BIT])\n\t{\n\t\t// Digitrakker really uses byte offsets, not sample offsets. WTF!\n\t\tparam /= 2u;\n\t}\n\n\tif(chn.rowCommand.IsNote())\n\t{\n\t\t// IT compatibility: If this note is not mapped to a sample, ignore it.\n\t\t// Test case: empty_sample_offset.it\n\t\tif(chn.pModInstrument != nullptr)\n\t\t{\n\t\t\tSAMPLEINDEX smp = chn.pModInstrument->Keyboard[chn.rowCommand.note - NOTE_MIN];\n\t\t\tif(smp == 0 || smp > GetNumSamples())\n\t\t\t\treturn;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_PT_MODE])\n\t\t{\n\t\t\t// ProTracker compatbility: PT1/2-style funky 9xx offset command\n\t\t\t// Test case: ptoffset.mod\n\t\t\tchn.position.Set(chn.proTrackerOffset);\n\t\t\tchn.proTrackerOffset += param;\n\t\t} else\n\t\t{\n\t\t\tchn.position.Set(param);\n\t\t}\n\n\t\tif (chn.position.GetUInt() >= chn.nLength || (chn.dwFlags[CHN_LOOP] && chn.position.GetUInt() >= chn.nLoopEnd))\n\t\t{\n\t\t\t// Offset beyond sample size\n\t\t\tif (!(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MOD | MOD_TYPE_MTM)))\n\t\t\t{\n\t\t\t\t// IT Compatibility: Offset\n\t\t\t\tif(m_playBehaviour[kITOffset])\n\t\t\t\t{\n\t\t\t\t\tif(m_SongFlags[SONG_ITOLDEFFECTS])\n\t\t\t\t\t\tchn.position.Set(chn.nLength); // Old FX: Clip to end of sample\n\t\t\t\t\telse\n\t\t\t\t\t\tchn.position.Set(0); // Reset to beginning of sample\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tchn.position.Set(chn.nLoopStart);\n\t\t\t\t\tif(m_SongFlags[SONG_ITOLDEFFECTS] && chn.nLength > 4)\n\t\t\t\t\t{\n\t\t\t\t\t\tchn.position.Set(chn.nLength - 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(m_playBehaviour[kFT2OffsetOutOfRange] || GetType() == MOD_TYPE_MTM)\n\t\t\t{\n\t\t\t\t// FT2 Compatibility: Don't play note if offset is beyond sample length\n\t\t\t\t// Test case: 3xx-no-old-samp.xm\n\t\t\t\tchn.dwFlags.set(CHN_FASTVOLRAMP);\n\t\t\t\tchn.nPeriod = 0;\n\t\t\t} else if(GetType() == MOD_TYPE_MOD && chn.dwFlags[CHN_LOOP])\n\t\t\t{\n\t\t\t\tchn.position.Set(chn.nLoopStart);\n\t\t\t}\n\t\t}\n\t} else if ((param < chn.nLength) && (GetType() & (MOD_TYPE_MTM | MOD_TYPE_DMF | MOD_TYPE_MDL | MOD_TYPE_PLM)))\n\t{\n\t\t// Some trackers can also call offset effects without notes next to them...\n\t\tchn.position.Set(param);\n\t}\n}\n\n\n// \nvoid CSoundFile::ReverseSampleOffset(ModChannel &chn, ModCommand::PARAM param) const\n{\n\tif(chn.pModSample != nullptr)\n\t{\n\t\tchn.dwFlags.set(CHN_PINGPONGFLAG);\n\t\tchn.dwFlags.reset(CHN_LOOP);\n\t\tchn.nLength = chn.pModSample->nLength;\t// If there was a loop, extend sample to whole length.\n\t\tchn.position.Set((chn.nLength - 1) - std::min<SmpLength>(SmpLength(param) << 8, chn.nLength - 1), 0);\n\t}\n}\n\n\nvoid CSoundFile::RetrigNote(CHANNELINDEX nChn, int param, int offset)\n{\n\t// Retrig: bit 8 is set if it's the new XM retrig\n\tModChannel &chn = m_PlayState.Chn[nChn];\n\tint retrigSpeed = param & 0x0F;\n\tint16 retrigCount = chn.nRetrigCount;\n\tbool doRetrig = false;\n\n\t// IT compatibility 15. Retrigger\n\tif(m_playBehaviour[kITRetrigger])\n\t{\n\t\tif(m_PlayState.m_nTickCount == 0 && chn.rowCommand.note)\n\t\t{\n\t\t\tchn.nRetrigCount = param & 0xf;\n\t\t} else if(!chn.nRetrigCount || !--chn.nRetrigCount)\n\t\t{\n\t\t\tchn.nRetrigCount = param & 0xf;\n\t\t\tdoRetrig = true;\n\t\t}\n\t} else if(m_playBehaviour[kFT2Retrigger] && (param & 0x100))\n\t{\n\t\t// Buggy-like-hell FT2 Rxy retrig!\n\t\t// Test case: retrig.xm\n\t\tif(m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\t// Here are some really stupid things FT2 does on the first tick.\n\t\t\t// Test case: RetrigTick0.xm\n\t\t\tif(chn.rowCommand.instr > 0 && chn.rowCommand.IsNoteOrEmpty()) retrigCount = 1;\n\t\t\tif(chn.rowCommand.volcmd == VOLCMD_VOLUME && chn.rowCommand.vol != 0)\n\t\t\t{\n\t\t\t\t// I guess this condition simply checked if the volume byte was != 0 in FT2.\n\t\t\t\tchn.nRetrigCount = retrigCount;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(retrigCount >= retrigSpeed)\n\t\t{\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK] || !chn.rowCommand.IsNote())\n\t\t\t{\n\t\t\t\tdoRetrig = true;\n\t\t\t\tretrigCount = 0;\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\t// old routines\n\t\tif (GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))\n\t\t{\n\t\t\tif (!retrigSpeed) retrigSpeed = 1;\n\t\t\tif ((retrigCount) && (!(retrigCount % retrigSpeed))) doRetrig = true;\n\t\t\tretrigCount++;\n\t\t} else if(GetType() == MOD_TYPE_MTM)\n\t\t{\n\t\t\t// In MultiTracker, E9x retriggers the last note at exactly the x-th tick of the row\n\t\t\tdoRetrig = m_PlayState.m_nTickCount == static_cast<uint32>(param & 0x0F) && retrigSpeed != 0;\n\t\t} else\n\t\t{\n\t\t\tint realspeed = retrigSpeed;\n\t\t\t// FT2 bug: if a retrig (Rxy) occurs together with a volume command, the first retrig interval is increased by one tick\n\t\t\tif ((param & 0x100) && (chn.rowCommand.volcmd == VOLCMD_VOLUME) && (chn.rowCommand.param & 0xF0)) realspeed++;\n\t\t\tif(!m_SongFlags[SONG_FIRSTTICK] || (param & 0x100))\n\t\t\t{\n\t\t\t\tif (!realspeed) realspeed = 1;\n\t\t\t\tif ((!(param & 0x100)) && (m_PlayState.m_nMusicSpeed) && (!(m_PlayState.m_nTickCount % realspeed))) doRetrig = true;\n\t\t\t\tretrigCount++;\n\t\t\t} else if (GetType() & (MOD_TYPE_XM|MOD_TYPE_MT2)) retrigCount = 0;\n\t\t\tif (retrigCount >= realspeed)\n\t\t\t{\n\t\t\t\tif ((m_PlayState.m_nTickCount) || ((param & 0x100) && (!chn.rowCommand.note))) doRetrig = true;\n\t\t\t}\n\t\t\tif(m_playBehaviour[kFT2Retrigger] && param == 0)\n\t\t\t{\n\t\t\t\t// E90 = Retrig instantly, and only once\n\t\t\t\tdoRetrig = (m_PlayState.m_nTickCount == 0);\n\t\t\t}\n\t\t}\n\t}\n\n\t// IT compatibility: If a sample is shorter than the retrig time (i.e. it stops before the retrig counter hits zero), it is not retriggered.\n\t// Test case: retrig-short.it\n\tif(chn.nLength == 0 && m_playBehaviour[kITShortSampleRetrig] && !chn.HasMIDIOutput())\n\t{\n\t\treturn;\n\t}\n\n\tif(doRetrig)\n\t{\n\t\tuint32 dv = (param >> 4) & 0x0F;\n\t\tint vol = chn.nVolume;\n\t\tif (dv)\n\t\t{\n\n\t\t\t// FT2 compatibility: Retrig + volume will not change volume of retrigged notes\n\t\t\tif(!m_playBehaviour[kFT2Retrigger] || !(chn.rowCommand.volcmd == VOLCMD_VOLUME))\n\t\t\t{\n\t\t\t\tif (retrigTable1[dv])\n\t\t\t\t\tvol = (vol * retrigTable1[dv]) >> 4;\n\t\t\t\telse\n\t\t\t\t\tvol += ((int)retrigTable2[dv]) << 2;\n\t\t\t}\n\t\t\tLimit(vol, 0, 256);\n\n\t\t\tchn.dwFlags.set(CHN_FASTVOLRAMP);\n\t\t}\n\t\tuint32 note = chn.nNewNote;\n\t\tint32 oldPeriod = chn.nPeriod;\n\t\tif (note >= NOTE_MIN && note <= NOTE_MAX && chn.nLength)\n\t\t\tCheckNNA(nChn, 0, note, true);\n\t\tbool resetEnv = false;\n\t\tif(GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2))\n\t\t{\n\t\t\tif((chn.rowCommand.instr) && (param < 0x100))\n\t\t\t{\n\t\t\t\tInstrumentChange(&chn, chn.rowCommand.instr, false, false);\n\t\t\t\tresetEnv = true;\n\t\t\t}\n\t\t\tif (param < 0x100) resetEnv = true;\n\t\t}\n\t\tbool fading = chn.dwFlags[CHN_NOTEFADE];\n\t\t// IT compatibility: Really weird combination of envelopes and retrigger (see Storlek's q.it testcase)\n\t\t// Test case: retrig.it\n\t\tNoteChange(&chn, note, m_playBehaviour[kITRetrigger], resetEnv);\n\t\t// XM compatibility: Prevent NoteChange from resetting the fade flag in case an instrument number + note-off is present.\n\t\t// Test case: RetrigFade.xm\n\t\tif(fading && GetType() == MOD_TYPE_XM)\n\t\t\tchn.dwFlags.set(CHN_NOTEFADE);\n\t\tchn.nVolume = vol;\n\t\tif(m_nInstruments)\n\t\t{\n\t\t\tchn.rowCommand.note = static_cast<ModCommand::NOTE>(note);\t// No retrig without note...\n#ifndef NO_PLUGINS\n\t\t\tProcessMidiOut(nChn);\t//Send retrig to Midi\n#endif // NO_PLUGINS\n\t\t}\n\t\tif ((GetType() & (MOD_TYPE_IT|MOD_TYPE_MPT)) && (!chn.rowCommand.note) && (oldPeriod)) chn.nPeriod = oldPeriod;\n\t\tif (!(GetType() & (MOD_TYPE_S3M|MOD_TYPE_IT|MOD_TYPE_MPT))) retrigCount = 0;\n\t\t// IT compatibility: see previous IT compatibility comment =)\n\t\tif(m_playBehaviour[kITRetrigger]) chn.position.Set(0);\n\n\t\toffset--;\n\t\tif(offset >= 0 && offset <= static_cast<int>(CountOf(chn.pModSample->cues)) && chn.pModSample != nullptr)\n\t\t{\n\t\t\tif(offset == 0) offset = chn.oldOffset;\n\t\t\telse offset = chn.oldOffset = chn.pModSample->cues[offset - 1];\n\t\t\tSampleOffset(chn, offset);\n\t\t}\n\t}\n\n\t// buggy-like-hell FT2 Rxy retrig!\n\tif(m_playBehaviour[kFT2Retrigger] && (param & 0x100)) retrigCount++;\n\n\t// Now we can also store the retrig value for IT...\n\tif(!m_playBehaviour[kITRetrigger])\n\t\tchn.nRetrigCount = retrigCount;\n}\n\n\nvoid CSoundFile::DoFreqSlide(ModChannel *pChn, int32 nFreqSlide) const\n{\n\tif(!pChn->nPeriod) return;\n\tif(GetType() == MOD_TYPE_669)\n\t{\n\t\t// Like other oldskool trackers, Composer 669 doesn't have linear slides...\n\t\t// But the slides are done in Hertz rather than periods, meaning that they\n\t\t// are more effective in the lower notes (rather than the higher notes).\n\t\tnFreqSlide *= -20;\n\t}\n\tif(m_SongFlags[SONG_LINEARSLIDES] && GetType() != MOD_TYPE_XM)\n\t{\n\t\t// IT Linear slides\n\t\tconst auto nOldPeriod = pChn->nPeriod;\n\t\tuint32 n = mpt::abs(nFreqSlide) / 4u;\n\t\tLimitMax(n, 255u);\n\t\tif(n != 0)\n\t\t{\n\t\t\tpChn->nPeriod = Util::muldivr(pChn->nPeriod, nFreqSlide < 0 ? GetLinearSlideUpTable(this, n) : GetLinearSlideDownTable(this, n), 65536);\n\t\t\tif(pChn->nPeriod == nOldPeriod)\n\t\t\t{\n\t\t\t\tconst bool incPeriod = m_playBehaviour[kHertzInLinearMode] == (nFreqSlide < 0);\n\t\t\t\tif(incPeriod && pChn->nPeriod < Util::MaxValueOfType(pChn->nPeriod))\n\t\t\t\t\tpChn->nPeriod++;\n\t\t\t\telse if(!incPeriod && pChn->nPeriod > 1)\n\t\t\t\t\tpChn->nPeriod--;\n\t\t\t}\n\t\t}\n\t} else\n\t{\n\t\tpChn->nPeriod += nFreqSlide;\n\t}\n\tif (pChn->nPeriod < 1)\n\t{\n\t\tpChn->nPeriod = 1;\n\t\tif(GetType() == MOD_TYPE_S3M)\n\t\t{\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE | CHN_FASTVOLRAMP);\n\t\t}\n\t}\n}\n\n\nvoid CSoundFile::NoteCut(CHANNELINDEX nChn, uint32 nTick, bool cutSample)\n{\n\tif (m_PlayState.m_nTickCount == nTick)\n\t{\n\t\tModChannel *pChn = &m_PlayState.Chn[nChn];\n\t\tif(cutSample)\n\t\t{\n\t\t\tpChn->increment.Set(0);\n\t\t\tpChn->nFadeOutVol = 0;\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t} else\n\t\t{\n\t\t\tpChn->nVolume = 0;\n\t\t}\n\t\tpChn->dwFlags.set(CHN_FASTVOLRAMP);\n\n\t\t// instro sends to a midi chan\n\t\tSendMIDINote(nChn, /*pChn->nNote+*/NOTE_MAX_SPECIAL, 0);\n\t}\n}\n\n\nvoid CSoundFile::KeyOff(ModChannel *pChn) const\n{\n\tconst bool bKeyOn = !pChn->dwFlags[CHN_KEYOFF];\n\tpChn->dwFlags.set(CHN_KEYOFF);\n\tif(pChn->pModInstrument != nullptr && !pChn->VolEnv.flags[ENV_ENABLED])\n\t{\n\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t}\n\tif (!pChn->nLength) return;\n\tif (pChn->dwFlags[CHN_SUSTAINLOOP] && pChn->pModSample && bKeyOn)\n\t{\n\t\tconst ModSample *pSmp = pChn->pModSample;\n\t\tif(pSmp->uFlags[CHN_LOOP])\n\t\t{\n\t\t\tif (pSmp->uFlags[CHN_PINGPONGLOOP])\n\t\t\t\tpChn->dwFlags.set(CHN_PINGPONGLOOP);\n\t\t\telse\n\t\t\t\tpChn->dwFlags.reset(CHN_PINGPONGLOOP | CHN_PINGPONGFLAG);\n\t\t\tpChn->dwFlags.set(CHN_LOOP);\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t\tpChn->nLoopStart = pSmp->nLoopStart;\n\t\t\tpChn->nLoopEnd = pSmp->nLoopEnd;\n\t\t\tif (pChn->nLength > pChn->nLoopEnd) pChn->nLength = pChn->nLoopEnd;\n\t\t\tif(pChn->position.GetUInt() > pChn->nLength)\n\t\t\t{\n\t\t\t\t// Test case: SusAfterLoop.it\n\t\t\t\tpChn->position.Set(pChn->position.GetInt() - pChn->nLength + pChn->nLoopStart);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tpChn->dwFlags.reset(CHN_LOOP | CHN_PINGPONGLOOP | CHN_PINGPONGFLAG);\n\t\t\tpChn->nLength = pSmp->nLength;\n\t\t}\n\t}\n\n\tif (pChn->pModInstrument)\n\t{\n\t\tconst ModInstrument *pIns = pChn->pModInstrument;\n\t\tif((pIns->VolEnv.dwFlags[ENV_LOOP] || (GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2 | MOD_TYPE_MDL))) && pIns->nFadeOut != 0)\n\t\t{\n\t\t\tpChn->dwFlags.set(CHN_NOTEFADE);\n\t\t}\n\n\t\tif (pIns->VolEnv.nReleaseNode != ENV_RELEASE_NODE_UNSET && pChn->VolEnv.nEnvValueAtReleaseJump == NOT_YET_RELEASED)\n\t\t{\n\t\t\tpChn->VolEnv.nEnvValueAtReleaseJump = pIns->VolEnv.GetValueFromPosition(pChn->VolEnv.nEnvPosition, 256);\n\t\t\tpChn->VolEnv.nEnvPosition = pIns->VolEnv[pIns->VolEnv.nReleaseNode].tick;\n\t\t}\n\t}\n}\n\n\n//////////////////////////////////////////////////////////\n// CSoundFile: Global Effects\n\n\nvoid CSoundFile::SetSpeed(PlayState &playState, uint32 param) const\n{\n#ifdef MODPLUG_TRACKER\n\t// FT2 appears to be decrementing the tick count before checking for zero,\n\t// so it effectively counts down 65536 ticks with speed = 0 (song speed is a 16-bit variable in FT2)\n\tif(GetType() == MOD_TYPE_XM && !param)\n\t{\n\t\tplayState.m_nMusicSpeed = uint16_max;\n\t}\n#endif\t// MODPLUG_TRACKER\n\tif(param > 0) playState.m_nMusicSpeed = param;\n\tif(GetType() == MOD_TYPE_STM && param > 0)\n\t{\n\t\tplayState.m_nMusicSpeed = std::max<uint32>(param >> 4u, 1);\n\t\tplayState.m_nMusicTempo = ConvertST2Tempo(static_cast<uint8>(param));\n\t}\n}\n\n\n// Convert a ST2 tempo byte to classic tempo and speed combination\nTEMPO CSoundFile::ConvertST2Tempo(uint8 tempo)\n{\n\tstatic const uint8 ST2TempoFactor[] = { 140, 50, 25, 15, 10, 7, 6, 4, 3, 3, 2, 2, 2, 2, 1, 1 };\n\tstatic const uint32 st2MixingRate = 23863; // Highest possible setting in ST2\n\n\t// This underflows at tempo 06...0F, and the resulting tick lengths depend on the mixing rate.\n\tint32 samplesPerTick = st2MixingRate / (49 - ((ST2TempoFactor[tempo >> 4u] * (tempo & 0x0F)) >> 4u));\n\tif(samplesPerTick <= 0)\n\t\tsamplesPerTick += 65536;\n\treturn TEMPO().SetRaw(Util::muldivrfloor(st2MixingRate, 5 * TEMPO::fractFact, samplesPerTick * 2));\n}\n\n\nvoid CSoundFile::SetTempo(TEMPO param, bool setFromUI)\n{\n\tconst CModSpecifications &specs = GetModSpecifications();\n\n\t// Anything lower than the minimum tempo is considered to be a tempo slide\n\tconst TEMPO minTempo = (GetType() == MOD_TYPE_MDL) ? TEMPO(1, 0) : TEMPO(32, 0);\n\n\tif(setFromUI)\n\t{\n\t\t// Set tempo from UI - ignore slide commands and such.\n\t\tm_PlayState.m_nMusicTempo = Clamp(param, specs.GetTempoMin(), specs.GetTempoMax());\n\t} else if(param >= minTempo && m_SongFlags[SONG_FIRSTTICK] == !m_playBehaviour[kMODTempoOnSecondTick])\n\t{\n\t\t// ProTracker sets the tempo after the first tick.\n\t\t// Note: The case of one tick per row is handled in ProcessRow() instead.\n\t\t// Test case: TempoChange.mod\n\t\tm_PlayState.m_nMusicTempo = std::min(param, specs.GetTempoMax());\n\t} else if(param < minTempo && !m_SongFlags[SONG_FIRSTTICK])\n\t{\n\t\t// Tempo Slide\n\t\tTEMPO tempDiff(param.GetInt() & 0x0F, 0);\n\t\tif((param.GetInt() & 0xF0) == 0x10)\n\t\t\tm_PlayState.m_nMusicTempo += tempDiff;\n\t\telse\n\t\t\tm_PlayState.m_nMusicTempo -= tempDiff;\n\n\t\tTEMPO tempoMin = specs.GetTempoMin(), tempoMax = specs.GetTempoMax();\n\t\tif(m_playBehaviour[kTempoClamp])\t// clamp tempo correctly in compatible mode\n\t\t{\n\t\t\ttempoMax.Set(255);\n\t\t}\n\t\tLimit(m_PlayState.m_nMusicTempo, tempoMin, tempoMax);\n\t}\n}\n\n\nROWINDEX CSoundFile::PatternLoop(ModChannel *pChn, uint32 param)\n{\n\tif (param)\n\t{\n\t\t// Loop Repeat\n\t\tif(pChn->nPatternLoopCount)\n\t\t{\n\t\t\t// There's a loop left\n\t\t\tpChn->nPatternLoopCount--;\n\t\t\tif(!pChn->nPatternLoopCount)\n\t\t\t{\n\t\t\t\t// IT compatibility 10. Pattern loops (+ same fix for S3M files)\n\t\t\t\t// When finishing a pattern loop, the next loop without a dedicated SB0 starts on the first row after the previous loop.\n\t\t\t\tif(m_playBehaviour[kITPatternLoopTargetReset] || (GetType() == MOD_TYPE_S3M))\n\t\t\t\t{\n\t\t\t\t\tpChn->nPatternLoop = m_PlayState.m_nRow + 1;\n\t\t\t\t}\n\n\t\t\t\treturn ROWINDEX_INVALID;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\t// First time we get into the loop => Set loop count.\n\n\t\t\t// IT compatibility 10. Pattern loops (+ same fix for XM / MOD / S3M files)\n\t\t\tif(!m_playBehaviour[kITFT2PatternLoop] && !(GetType() & (MOD_TYPE_MOD | MOD_TYPE_S3M)))\n\t\t\t{\n\t\t\t\tModChannel *p = m_PlayState.Chn;\n\t\t\t\tfor(CHANNELINDEX i = 0; i < GetNumChannels(); i++, p++) if (p != pChn)\n\t\t\t\t{\n\t\t\t\t\t// Loop on other channel\n\t\t\t\t\tif(p->nPatternLoopCount) return ROWINDEX_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpChn->nPatternLoopCount = static_cast<uint8>(param);\n\t\t}\n\t\tm_PlayState.m_nNextPatStartRow = pChn->nPatternLoop; // Nasty FT2 E60 bug emulation!\n\t\treturn pChn->nPatternLoop;\n\t} else\n\t{\n\t\t// Loop Start\n\t\tpChn->nPatternLoop = m_PlayState.m_nRow;\n\t}\n\treturn ROWINDEX_INVALID;\n}\n\n\nvoid CSoundFile::GlobalVolSlide(ModCommand::PARAM param, uint8 &nOldGlobalVolSlide)\n{\n\tint32 nGlbSlide = 0;\n\tif (param) nOldGlobalVolSlide = param; else param = nOldGlobalVolSlide;\n\n\tif((GetType() & (MOD_TYPE_XM | MOD_TYPE_MT2)))\n\t{\n\t\t// XM nibble priority\n\t\tif((param & 0xF0) != 0)\n\t\t{\n\t\t\tparam &= 0xF0;\n\t\t} else\n\t\t{\n\t\t\tparam &= 0x0F;\n\t\t}\n\t}\n\n\tif (((param & 0x0F) == 0x0F) && (param & 0xF0))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nGlbSlide = (param >> 4) * 2;\n\t} else\n\tif (((param & 0xF0) == 0xF0) && (param & 0x0F))\n\t{\n\t\tif(m_SongFlags[SONG_FIRSTTICK]) nGlbSlide = - (int)((param & 0x0F) * 2);\n\t} else\n\t{\n\t\tif(!m_SongFlags[SONG_FIRSTTICK])\n\t\t{\n\t\t\tif (param & 0xF0)\n\t\t\t{\n\t\t\t\t// IT compatibility: Ignore slide commands with both nibbles set.\n\t\t\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM)) || (param & 0x0F) == 0)\n\t\t\t\t\tnGlbSlide = (int)((param & 0xF0) >> 4) * 2;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tnGlbSlide = -(int)((param & 0x0F) * 2);\n\t\t\t}\n\t\t}\n\t}\n\tif (nGlbSlide)\n\t{\n\t\tif(!(GetType() & (MOD_TYPE_IT | MOD_TYPE_MPT | MOD_TYPE_IMF | MOD_TYPE_J2B | MOD_TYPE_MID | MOD_TYPE_AMS | MOD_TYPE_AMS2 | MOD_TYPE_DBM))) nGlbSlide *= 2;\n\t\tnGlbSlide += m_PlayState.m_nGlobalVolume;\n\t\tLimit(nGlbSlide, 0, 256);\n\t\tm_PlayState.m_nGlobalVolume = nGlbSlide;\n\t}\n}\n\n\n//////////////////////////////////////////////////////\n// Note/Period/Frequency functions\n\n// Find lowest note which has same or lower period as a given period (i.e. the note has the same or higher frequency)\nuint32 CSoundFile::GetNoteFromPeriod(uint32 period, int32 nFineTune, uint32 nC5Speed) const\n{\n\tif(!period) return 0;\n\tif(m_playBehaviour[kFT2Periods])\n\t{\n\t\t// FT2's \"RelocateTon\" function actually rounds up and down, while GetNoteFromPeriod normally just truncates.\n\t\tnFineTune += 64;\n\t}\n\t// This essentially implements std::lower_bound, with the difference that we don't need an iterable container.\n\tuint32 minNote = NOTE_MIN, maxNote = NOTE_MAX, count = maxNote - minNote + 1;\n\tconst bool periodIsFreq = PeriodsAreFrequencies();\n\twhile(count > 0)\n\t{\n\t\tconst uint32 step = count / 2, midNote = minNote + step;\n\t\tuint32 n = GetPeriodFromNote(midNote, nFineTune, nC5Speed);\n\t\tif((n > period && !periodIsFreq) || (n < period && periodIsFreq) || !n)\n\t\t{\n\t\t\tminNote = midNote + 1;\n\t\t\tcount -= step + 1;\n\t\t} else\n\t\t{\n\t\t\tcount = step;\n\t\t}\n\t}\n\treturn minNote;\n}\n\n\nuint32 CSoundFile::GetPeriodFromNote(uint32 note, int32 nFineTune, uint32 nC5Speed) const\n{\n\tif (note == NOTE_NONE || (note >= NOTE_MIN_SPECIAL)) return 0;\n\tnote -= NOTE_MIN;\n\tif (!UseFinetuneAndTranspose())\n\t{\n\t\tif(GetType() & (MOD_TYPE_MDL | MOD_TYPE_DTM))\n\t\t{\n\t\t\t// MDL uses non-linear slides, but their effectiveness does not depend on the middle-C frequency.\n\t\t\treturn (FreqS3MTable[note % 12u] << 4) >> (note / 12);\n\t\t}\n\t\tif(m_SongFlags[SONG_LINEARSLIDES] || GetType() == MOD_TYPE_669)\n\t\t{\n\t\t\t// In IT linear slide mode, directly use frequency in Hertz rather than periods.\n\t\t\tif(m_playBehaviour[kHertzInLinearMode] || GetType() == MOD_TYPE_669)\n\t\t\t\treturn Util::muldiv_unsigned(nC5Speed, LinearSlideUpTable[(note % 12u) * 16u] << (note / 12u), 65536 << 5);\n\t\t\telse\n\t\t\t\treturn (FreqS3MTable[note % 12u] << 5) >> (note / 12);\n\t\t} else\n\t\t{\n\t\t\tif (!nC5Speed)\n\t\t\t\tnC5Speed = 8363;\n\t\t\tLimitMax(nC5Speed, uint32_max >> (note / 12u));\n\t\t\t//(a*b)/c\n\t\t\treturn Util::muldiv_unsigned(8363, (FreqS3MTable[note % 12u] << 5), nC5Speed << (note / 12u));\n\t\t\t//8363 * freq[note%12] / nC5Speed * 2^(5-note/12)\n\t\t}\n\t} else if (GetType() == MOD_TYPE_XM)\n\t{\n\t\tif (note < 12) note = 12;\n\t\tnote -= 12;\n\n\t\t// FT2 Compatibility: The lower three bits of the finetune are truncated.\n\t\t// Test case: Finetune-Precision.xm\n\t\tif(m_playBehaviour[kFT2FinetunePrecision])\n\t\t{\n\t\t\tnFineTune &= ~7;\n\t\t}\n\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tint l = ((NOTE_MAX - note) << 6) - (nFineTune / 2);\n\t\t\tif (l < 1) l = 1;\n\t\t\treturn static_cast<uint32>(l);\n\t\t} else\n\t\t{\n\t\t\tint finetune = nFineTune;\n\t\t\tuint32 rnote = (note % 12) << 3;\n\t\t\tuint32 roct = note / 12;\n\t\t\tint rfine = finetune / 16;\n\t\t\tint i = rnote + rfine + 8;\n\t\t\tLimit(i , 0, 103);\n\t\t\tuint32 per1 = XMPeriodTable[i];\n\t\t\tif(finetune < 0)\n\t\t\t{\n\t\t\t\trfine--;\n\t\t\t\tfinetune = -finetune;\n\t\t\t} else rfine++;\n\t\t\ti = rnote+rfine+8;\n\t\t\tif (i < 0) i = 0;\n\t\t\tif (i >= 104) i = 103;\n\t\t\tuint32 per2 = XMPeriodTable[i];\n\t\t\trfine = finetune & 0x0F;\n\t\t\tper1 *= 16-rfine;\n\t\t\tper2 *= rfine;\n\t\t\treturn ((per1 + per2) << 1) >> roct;\n\t\t}\n\t} else\n\t{\n\t\tnFineTune = XM2MODFineTune(nFineTune);\n\t\tif ((nFineTune) || (note < 36) || (note >= 36 + 6 * 12))\n\t\t\treturn (ProTrackerTunedPeriods[nFineTune * 12u + note % 12u] << 5) >> (note / 12u);\n\t\telse\n\t\t\treturn (ProTrackerPeriodTable[note - 36] << 2);\n\t}\n}\n\n\n// Converts period value to sample frequency. Return value is fixed point, with FREQ_FRACBITS fractional bits.\nuint32 CSoundFile::GetFreqFromPeriod(uint32 period, uint32 c5speed, int32 nPeriodFrac) const\n{\n\tif (!period) return 0;\n\tif (GetType() == MOD_TYPE_XM)\n\t{\n\t\tif(m_playBehaviour[kFT2Periods])\n\t\t{\n\t\t\t// FT2 compatibility: Period is a 16-bit value in FT2, and it overflows happily.\n\t\t\t// Test case: FreqWraparound.xm\n\t\t\tperiod &= 0xFFFF;\n\t\t}\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tuint32 octave;\n\t\t\tif(m_playBehaviour[kFT2Periods])\n\t\t\t{\n\t\t\t\t// Under normal circumstances, this calculation returns the same values as the non-compatible one.\n\t\t\t\t// However, once the 12 octaves are exceeded (through portamento slides), the octave shift goes\n\t\t\t\t// crazy in FT2, meaning that the frequency wraps around randomly...\n\t\t\t\t// The entries in FT2's conversion table are four times as big, hence we have to do an additional shift by two bits.\n\t\t\t\t// Test case: FreqWraparound.xm\n\t\t\t\t// 12 octaves * (12 * 64) LUT entries = 9216, add 767 for rounding\n\t\t\t\tuint32 div = ((9216u + 767u - period) / 768);\n\t\t\t\toctave = ((14 - div) & 0x1F);\n\t\t\t} else\n\t\t\t{\n\t\t\t\toctave = (period / 768) + 2;\n\t\t\t}\n\t\t\treturn (XMLinearTable[period % 768] << (FREQ_FRACBITS + 2)) >> octave;\n\t\t} else\n\t\t{\n\t\t\tif(!period) period = 1;\n\t\t\treturn ((8363 * 1712L) << FREQ_FRACBITS) / period;\n\t\t}\n\t} else if (UseFinetuneAndTranspose())\n\t{\n\t\treturn ((3546895L * 4) << FREQ_FRACBITS) / period;\n\t} else if(GetType() == MOD_TYPE_669)\n\t{\n\t\t// We only really use c5speed for the finetune pattern command. All samples in 669 files have the same middle-C speed (imported as 8363 Hz).\n\t\treturn (period + c5speed - 8363) << FREQ_FRACBITS;\n\t} else if(GetType() & (MOD_TYPE_MDL | MOD_TYPE_DTM))\n\t{\n\t\tLimitMax(period, Util::MaxValueOfType(period) >> 8);\n\t\tif (!c5speed) c5speed = 8363;\n\t\treturn Util::muldiv_unsigned(c5speed, (1712L << 7) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t} else\n\t{\n\t\tLimitMax(period, Util::MaxValueOfType(period) >> 8);\n\t\tif(m_SongFlags[SONG_LINEARSLIDES])\n\t\t{\n\t\t\tif(m_playBehaviour[kHertzInLinearMode])\n\t\t\t{\n\t\t\t\t// IT linear slides already use frequencies instead of periods.\n\t\t\t\tstatic_assert(FREQ_FRACBITS <= 8, \"Check this shift operator\");\n\t\t\t\treturn uint32(((uint64(period) << 8) + nPeriodFrac) >> (8 - FREQ_FRACBITS));\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (!c5speed) c5speed = 8363;\n\t\t\t\treturn Util::muldiv_unsigned(c5speed, (1712L << 8) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\treturn Util::muldiv_unsigned(8363, (1712L << 8) << FREQ_FRACBITS, (period << 8) + nPeriodFrac);\n\t\t}\n\t}\n}\n\n\nPLUGINDEX CSoundFile::GetBestPlugin(CHANNELINDEX nChn, PluginPriority priority, PluginMutePriority respectMutes) const\n{\n\tif (nChn >= MAX_CHANNELS)\t\t//Check valid channel number\n\t{\n\t\treturn 0;\n\t}\n\n\t//Define search source order\n\tPLUGINDEX nPlugin = 0;\n\tswitch (priority)\n\t{\n\t\tcase ChannelOnly:\n\t\t\tnPlugin = GetChannelPlugin(nChn, respectMutes);\n\t\t\tbreak;\n\t\tcase InstrumentOnly:\n\t\t\tnPlugin  = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\tbreak;\n\t\tcase PrioritiseInstrument:\n\t\t\tnPlugin  = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\tif ((!nPlugin) || (nPlugin > MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tnPlugin = GetChannelPlugin(nChn, respectMutes);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PrioritiseChannel:\n\t\t\tnPlugin  = GetChannelPlugin(nChn, respectMutes);\n\t\t\tif ((!nPlugin) || (nPlugin > MAX_MIXPLUGINS))\n\t\t\t{\n\t\t\t\tnPlugin = GetActiveInstrumentPlugin(nChn, respectMutes);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn nPlugin; // 0 Means no plugin found.\n}\n\n\nPLUGINDEX CSoundFile::GetChannelPlugin(CHANNELINDEX nChn, PluginMutePriority respectMutes) const\n{\n\tconst ModChannel &channel = m_PlayState.Chn[nChn];\n\n\tPLUGINDEX nPlugin;\n\tif((respectMutes == RespectMutes && channel.dwFlags[CHN_MUTE]) || channel.dwFlags[CHN_NOFX])\n\t{\n\t\tnPlugin = 0;\n\t} else\n\t{\n\t\t// If it looks like this is an NNA channel, we need to find the master channel.\n\t\t// This ensures we pick up the right ChnSettings.\n\t\t// NB: nMasterChn == 0 means no master channel, so we need to -1 to get correct index.\n\t\tif (nChn >= m_nChannels && channel.nMasterChn > 0)\n\t\t{\n\t\t\tnChn = channel.nMasterChn - 1;\n\t\t}\n\n\t\tif(nChn < MAX_BASECHANNELS)\n\t\t{\n\t\t\tnPlugin = ChnSettings[nChn].nMixPlugin;\n\t\t} else\n\t\t{\n\t\t\tnPlugin = 0;\n\t\t}\n\t}\n\treturn nPlugin;\n}\n\n\nPLUGINDEX CSoundFile::GetActiveInstrumentPlugin(CHANNELINDEX nChn, PluginMutePriority respectMutes) const\n{\n\t// Unlike channel settings, pModInstrument is copied from the original chan to the NNA chan,\n\t// so we don't need to worry about finding the master chan.\n\n\tPLUGINDEX plug = 0;\n\tif(m_PlayState.Chn[nChn].pModInstrument != nullptr)\n\t{\n\t\tif(respectMutes == RespectMutes && m_PlayState.Chn[nChn].pModSample && m_PlayState.Chn[nChn].pModSample->uFlags[CHN_MUTE])\n\t\t{\n\t\t\tplug = 0;\n\t\t} else\n\t\t{\n\t\t\tplug = m_PlayState.Chn[nChn].pModInstrument->nMixPlug;\n\t\t}\n\t}\n\treturn plug;\n}\n\n\n// Retrieve the plugin that is associated with the channel's current instrument.\n// No plugin is returned if the channel is muted or if the instrument doesn't have a MIDI channel set up,\n// As this is meant to be used with instrument plugins.\nIMixPlugin *CSoundFile::GetChannelInstrumentPlugin(CHANNELINDEX chn) const\n{\n#ifndef NO_PLUGINS\n\tif(m_PlayState.Chn[chn].dwFlags[CHN_MUTE | CHN_SYNCMUTE])\n\t{\n\t\t// Don't process portamento on muted channels. Note that this might have a side-effect\n\t\t// on other channels which trigger notes on the same MIDI channel of the same plugin,\n\t\t// as those won't be pitch-bent anymore.\n\t\treturn nullptr;\n\t}\n\n\tif(m_PlayState.Chn[chn].HasMIDIOutput())\n\t{\n\t\tconst ModInstrument *pIns = m_PlayState.Chn[chn].pModInstrument;\n\t\t// Instrument sends to a MIDI channel\n\t\tif(pIns->nMixPlug != 0 && pIns->nMixPlug <= MAX_MIXPLUGINS)\n\t\t{\n\t\t\treturn m_MixPlugins[pIns->nMixPlug - 1].pMixPlugin;\n\t\t}\n\t}\n#else\n\tMPT_UNREFERENCED_PARAMETER(chn);\n#endif // NO_PLUGINS\n\treturn nullptr;\n}\n\n\n// Get the MIDI channel currently associated with a given tracker channel\nuint8 CSoundFile::GetBestMidiChannel(CHANNELINDEX nChn) const\n{\n\tif(nChn >= MAX_CHANNELS)\n\t{\n\t\treturn 0;\n\t}\n\n\tconst ModInstrument *ins = m_PlayState.Chn[nChn].pModInstrument;\n\tif(ins != nullptr)\n\t{\n\t\tif(ins->nMidiChannel == MidiMappedChannel)\n\t\t{\n\t\t\t// For mapped channels, return their pattern channel, modulo 16 (because there are only 16 MIDI channels)\n\t\t\treturn (m_PlayState.Chn[nChn].nMasterChn ? (m_PlayState.Chn[nChn].nMasterChn - 1) : nChn) % 16;\n\t\t} else if(ins->HasValidMIDIChannel())\n\t\t{\n\t\t\treturn (ins->nMidiChannel - 1) & 0x0F;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n#ifdef MODPLUG_TRACKER\nvoid CSoundFile::HandlePatternTransitionEvents()\n{\n\t// MPT sequence override\n\tif(m_PlayState.m_nSeqOverride != ORDERINDEX_INVALID && m_PlayState.m_nSeqOverride < Order().size())\n\t{\n\t\tif(m_SongFlags[SONG_PATTERNLOOP])\n\t\t{\n\t\t\tm_PlayState.m_nPattern = Order()[m_PlayState.m_nSeqOverride];\n\t\t}\n\t\tm_PlayState.m_nCurrentOrder = m_PlayState.m_nSeqOverride;\n\t\tm_PlayState.m_nSeqOverride = ORDERINDEX_INVALID;\n\t}\n\n\t// Channel mutes\n\tfor (CHANNELINDEX chan = 0; chan < GetNumChannels(); chan++)\n\t{\n\t\tif (m_bChannelMuteTogglePending[chan])\n\t\t{\n\t\t\tif(GetpModDoc())\n\t\t\t{\n\t\t\t\tGetpModDoc()->MuteChannel(chan, !GetpModDoc()->IsChannelMuted(chan));\n\t\t\t}\n\t\t\tm_bChannelMuteTogglePending[chan] = false;\n\t\t}\n\t}\n}\n#endif // MODPLUG_TRACKER\n\n\n// Update time signatures (global or pattern-specific). Don't forget to call this when changing the RPB/RPM settings anywhere!\nvoid CSoundFile::UpdateTimeSignature()\n{\n\tif(!Patterns.IsValidIndex(m_PlayState.m_nPattern) || !Patterns[m_PlayState.m_nPattern].GetOverrideSignature())\n\t{\n\t\tm_PlayState.m_nCurrentRowsPerBeat = m_nDefaultRowsPerBeat;\n\t\tm_PlayState.m_nCurrentRowsPerMeasure = m_nDefaultRowsPerMeasure;\n\t} else\n\t{\n\t\tm_PlayState.m_nCurrentRowsPerBeat = Patterns[m_PlayState.m_nPattern].GetRowsPerBeat();\n\t\tm_PlayState.m_nCurrentRowsPerMeasure = Patterns[m_PlayState.m_nPattern].GetRowsPerMeasure();\n\t}\n}\n\n\nvoid CSoundFile::PortamentoMPT(ModChannel* pChn, int param)\n{\n\t//Behavior: Modifies portamento by param-steps on every tick.\n\t//Note that step meaning depends on tuning.\n\n\tpChn->m_PortamentoFineSteps += param;\n\tpChn->m_CalculateFreq = true;\n}\n\n\nvoid CSoundFile::PortamentoFineMPT(ModChannel* pChn, int param)\n{\n\t//Behavior: Divides portamento change between ticks/row. For example\n\t//if Ticks/row == 6, and param == +-6, portamento goes up/down by one tuning-dependent\n\t//fine step every tick.\n\n\tif(m_PlayState.m_nTickCount == 0)\n\t\tpChn->nOldFinePortaUpDown = 0;\n\n\tconst int tickParam = static_cast<int>((m_PlayState.m_nTickCount + 1.0) * param / m_PlayState.m_nMusicSpeed);\n\tpChn->m_PortamentoFineSteps += (param >= 0) ? tickParam - pChn->nOldFinePortaUpDown : tickParam + pChn->nOldFinePortaUpDown;\n\tif(m_PlayState.m_nTickCount + 1 == m_PlayState.m_nMusicSpeed)\n\t\tpChn->nOldFinePortaUpDown = static_cast<int8>(mpt::abs(param));\n\telse\n\t\tpChn->nOldFinePortaUpDown = static_cast<int8>(mpt::abs(tickParam));\n\n\tpChn->m_CalculateFreq = true;\n}\n\n\nvoid CSoundFile::PortamentoExtraFineMPT(ModChannel* pChn, int param)\n{\n\t// This kinda behaves like regular fine portamento.\n\t// It changes the pitch by n finetune steps on the first tick.\n\n\tif(pChn->isFirstTick)\n\t{\n\t\tpChn->m_PortamentoFineSteps += param;\n\t\tpChn->m_CalculateFreq = true;\n\t}\n}\n\n\nOPENMPT_NAMESPACE_END\n"], "filenames": ["soundlib/Snd_fx.cpp"], "buggy_code_start_loc": [1207], "buggy_code_end_loc": [1208], "fixing_code_start_loc": [1207], "fixing_code_end_loc": [1209], "type": "CWE-125", "message": "soundlib/Snd_fx.cpp in OpenMPT before 1.27.07.00 and libopenmpt before 0.3.8 allows remote attackers to cause a denial of service (out-of-bounds read) via an IT or MO3 file with many nested pattern loops.", "other": {"cve": {"id": "CVE-2018-10017", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-11T05:29:00.327", "lastModified": "2020-10-15T13:32:56.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "soundlib/Snd_fx.cpp in OpenMPT before 1.27.07.00 and libopenmpt before 0.3.8 allows remote attackers to cause a denial of service (out-of-bounds read) via an IT or MO3 file with many nested pattern loops."}, {"lang": "es", "value": "soundlib/Snd_fx.cpp en OpenMPT, en versiones anteriores a la 1.27.07.00 y libopenmpt en versiones anteriores a la 0.3.8, permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) mediante un archivo IT o MO3 con muchos bucles de patr\u00f3n anidados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:libopenmpt:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.8", "matchCriteriaId": "162030BF-A6C5-4D0A-802F-AB88C3D05614"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:openmpt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.27.07.00", "matchCriteriaId": "155A3AAC-6967-4DC2-98F3-A06D8C66E1F9"}]}]}], "references": [{"url": "https://github.com/OpenMPT/openmpt/commit/7ebf02af2e90f03e0dbd0e18b8b3164f372fb97c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lib.openmpt.org/libopenmpt/2018/04/08/security-updates-0.3.8-0.2-beta31-0.2.7561-beta20.5-p8-0.2.7386-beta20.3-p11/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://openmpt.org/openmpt-1-27-07-00-released", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenMPT/openmpt/commit/7ebf02af2e90f03e0dbd0e18b8b3164f372fb97c"}}