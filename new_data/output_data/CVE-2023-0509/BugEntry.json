{"buggy_code": ["version: 2\n\ngeneral - \"General\":\n    en; language : \"Language\" = en\n    folder storage_folder : \"Download folder\" = ~/Downloads/pyLoad\n    bool debug_mode : \"Debug mode\" = True\n    debug;trace;stack debug_level : \"Debug level\" = trace\n    int min_free_space : \"Minimum free space in MiB\" = 1024\n    bool folder_per_package : \"Create folder for each package\" = True\npermission - \"Permissions\":\n    bool change_user : \"Change user of running process\" = False\n    str user : \"Username for ownership\" = user\n    str folder : \"Permission mode for created folders\" = 0755\n    bool change_file : \"Change permissions of downloads\" = False\n    str file : \"Permission mode for downloaded files\" = 0644\n    bool change_group : \"Change group of running process\" = False\n    str group : \"Groupname for ownership\" = users\n    bool change_dl : \"Change ownership of downloads\" = False\ndownload - \"Download\":\n    int chunks : \"Maximum connections for one download\" = 3\n    int max_downloads : \"Maximum parallel downloads\" = 3\n    int max_speed : \"Maximum download speed in KiB/s\" = -1\n    bool limit_speed : \"Limit download speed\" = False\n    ip interface : \"Download interface to bind (IP Address)\" =\n    bool ipv6 : \"Allow IPv6\" = False\n    bool skip_existing : \"Skip already existing files\" = False\n    time start_time : \"Start time\" = 0:00\n    time end_time : \"End time\" = 0:00\nreconnect - \"Reconnection\":\n    bool enabled : \"Activated\" = False\n    str script : \"Script\" =\n    time start_time : \"Start time\" = 0:00\n    time end_time : \"End time\" = 0:00\nwebui - \"Web Interface\":\n    bool enabled : \"Activated\" = True\n    bool use_ssl : \"Use HTTPS\" = False\n    bool develop : \"Development mode\" = False\n    file ssl_certfile : \"SSL Certificate\" = ssl.crt\n    file ssl_keyfile : \"SSL Key\" = ssl.key\n    file ssl_certchain : \"CA's intermediate certificate bundle (optional)\" =\n    ip host : \"IP address\" = localhost\n    int port : \"Port\" = 8000\n    Default;modern;pyplex theme : \"Theme\" = modern\n    bool autologin : \"Skip login if single user\" = False\n    str prefix: \"Path prefix\" =\n    int session_lifetime : \"Session lifetime (minutes)\" = 44640\nproxy - \"Proxy\":\n    bool enabled : \"Activated\" = False\n    ip host : \"IP address\" = localhost\n    int port : \"Port\" = 7070\n    http;https,socks4;socks5 type : \"Protocol\" = http\n    str username : \"Username\" =\n    password password : \"Password\" =\nlog - \"Log\":\n    bool console : \"Print log to console\" = True\n    bool console_color : \"Colorize console\" = False\n    bool syslog : \"Sent log to syslog\" = False\n    local;remote syslog_location : \"Syslog location\" = local\n    folder syslog_folder : \"Syslog local folder\" =\n    ip syslog_host : \"Syslog remote IP address\" = localhost\n    int syslog_port : \"Syslog remote port\" = 514\n    bool filelog : \"Save log to file\" = True\n    int filelog_size : \"Maximum file size (in KiB)\" = 5120\n    folder filelog_folder : \"Log file folder\" =\n    int filelog_entries : \"Maximum log files\" = 10\n    bool filelog_rotate : \"Log rotate\" = True\n", "# -*- coding: utf-8 -*-\n\nimport codecs\nimport io\nimport mimetypes\nimport os\nfrom itertools import chain\nfrom logging import getLogger\nfrom urllib.parse import quote, urlencode\n\nimport pycurl\nfrom pyload import APPID\n\nfrom ...utils.convert import to_bytes, to_str\nfrom ..exceptions import Abort\nfrom .exceptions import BadHeader\n\n\nif not hasattr(pycurl, 'PROXYTYPE_HTTPS'):\n    pycurl.PROXYTYPE_HTTPS = 2\n\ndef myquote(url):\n    try:\n        url = url.encode()\n    except AttributeError:\n        pass\n    return quote(url, safe=\"%/:=&?~#+!$,;'@()*[]\")\n\n\ndef myurlencode(data):\n    data = dict(data)\n    return urlencode(\n        {\n            x.encode()\n            if hasattr(x, \"encode\")\n            else x: y.encode()\n            if hasattr(y, \"encode\")\n            else y\n            for x, y in data.items()\n        }\n    )\n\n\nBAD_STATUS_CODES = tuple(\n    chain(range(400, 404), range(405, 418), range(500, 506))\n)\n\n\nclass FormFile:\n    def __init__(self, filename, data=None, mimetype=None):\n        self.filename = os.path.abspath(filename)\n        self.data = data\n        self.mimetype = mimetype or mimetypes.guess_type(filename)[0] if not data and os.path.exists(\n            filename) else None or 'application/octet-stream'\n\n    def __repr__(self):\n        return f\"FormFile <'{os.path.basename(self.filename)}'>\"\n\n\nclass HTTPRequest:\n    def __init__(self, cookies=None, options=None, limit=2_000_000):\n        self.exception = None\n        self.limit = limit\n\n        self.c = pycurl.Curl()\n        self.rep = None\n\n        self.cj = cookies  #: cookiejar\n\n        self.last_url = None\n        self.last_effective_url = None\n        self.code = 0  #: last http code\n\n        self.response_header = b\"\"\n\n        self.request_headers = []  #: temporary request header\n\n        self.abort = False\n        self.decode = False\n\n        self.init_handle()\n        self.set_interface(options)\n\n        self.c.setopt(pycurl.WRITEFUNCTION, self.write_body)\n        self.c.setopt(pycurl.HEADERFUNCTION, self.write_header)\n\n        self.log = getLogger(APPID)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def init_handle(self):\n        \"\"\"\n        sets common options to curl handle.\n        \"\"\"\n        self.c.setopt(pycurl.FOLLOWLOCATION, 1)\n        self.c.setopt(pycurl.MAXREDIRS, 10)\n        self.c.setopt(pycurl.CONNECTTIMEOUT, 30)\n        self.c.setopt(pycurl.NOSIGNAL, 1)\n        self.c.setopt(pycurl.NOPROGRESS, 1)\n        if hasattr(pycurl, \"AUTOREFERER\"):\n            self.c.setopt(pycurl.AUTOREFERER, 1)\n        self.c.setopt(pycurl.SSL_VERIFYPEER, 0)\n        self.c.setopt(pycurl.LOW_SPEED_TIME, 60)\n        self.c.setopt(pycurl.LOW_SPEED_LIMIT, 5)\n        if hasattr(pycurl, \"USE_SSL\"):\n            self.c.setopt(pycurl.USE_SSL, pycurl.USESSL_TRY)\n\n        # self.c.setopt(pycurl.VERBOSE, 1)\n        # self.c.setopt(pycurl.HTTP_VERSION, pycurl.CURL_HTTP_VERSION_1_1)\n\n        self.c.setopt(\n            pycurl.USERAGENT,\n            b\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\",\n        )\n        if pycurl.version_info()[7]:\n            self.c.setopt(pycurl.ENCODING, b\"gzip, deflate\")\n        self.c.setopt(\n            pycurl.HTTPHEADER,\n            [\n                b\"Accept: */*\",\n                b\"Accept-Language: en-US,en\",\n                b\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\",\n                b\"Connection: keep-alive\",\n                b\"Keep-Alive: 300\",\n                b\"Expect:\",\n            ],\n        )\n\n    def set_interface(self, options):\n        options = {\n            k: v.encode() if hasattr(v, \"encode\") else v for k, v in options.items()\n        }\n\n        interface, proxy, ipv6 = (\n            options[\"interface\"],\n            options[\"proxies\"],\n            options[\"ipv6\"],\n        )\n\n        if interface and interface.lower() != \"none\":\n            self.c.setopt(pycurl.INTERFACE, interface)\n\n        if proxy:\n            if proxy[\"type\"] == \"http\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_HTTP)\n            elif proxy[\"type\"] == \"https\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_HTTPS)\n                self.c.setopt(pycurl.PROXY_SSL_VERIFYPEER, 0)\n            elif proxy[\"type\"] == \"socks4\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_SOCKS4)\n            elif proxy[\"type\"] == \"socks5\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_SOCKS5)\n\n            self.c.setopt(pycurl.PROXY, proxy[\"host\"])\n            self.c.setopt(pycurl.PROXYPORT, int(proxy[\"port\"]))\n\n            if proxy[\"username\"]:\n                user = proxy[\"username\"]\n                pw = proxy[\"password\"]\n                self.c.setopt(pycurl.PROXYUSERPWD, f\"{user}:{pw}\".encode())\n\n        if ipv6:\n            self.c.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_WHATEVER)\n        else:\n            self.c.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_V4)\n\n        if \"auth\" in options:\n            self.c.setopt(pycurl.USERPWD, options[\"auth\"])\n\n        if \"timeout\" in options:\n            self.c.setopt(pycurl.LOW_SPEED_TIME, int(options[\"timeout\"]))\n\n    def add_cookies(self):\n        \"\"\"\n        put cookies from curl handle to cj.\n        \"\"\"\n        if self.cj:\n            self.cj.add_cookies(self.c.getinfo(pycurl.INFO_COOKIELIST))\n\n    def get_cookies(self):\n        \"\"\"\n        add cookies from cj to curl handle.\n        \"\"\"\n        if self.cj:\n            for c in self.cj.get_cookies():\n                self.c.setopt(pycurl.COOKIELIST, c)\n        return\n\n    def clear_cookies(self):\n        self.c.setopt(pycurl.COOKIELIST, \"\")\n\n    def set_request_context(self, url, get, post, referer, cookies, multipart=False, decode=True):\n        \"\"\"\n        sets everything needed for the request.\n        \"\"\"\n        self.rep = io.BytesIO()\n\n        self.exception = None\n\n        self.decode = decode\n\n        url = myquote(url)\n\n        if get:\n            get = urlencode(get)\n            url = f\"{url}?{get}\"\n\n        self.c.setopt(pycurl.URL, url)\n        self.c.last_url = url\n\n        if post:\n            self.c.setopt(pycurl.POST, 1)\n            if not multipart:\n                if post is True:\n                    pass\n                elif isinstance(post, str):\n                    post = post.encode()\n                    self.c.setopt(pycurl.POSTFIELDS, post)\n                else:  # TODO: check if mapping\n                    post = myurlencode(post)\n                    self.c.setopt(pycurl.POSTFIELDS, post)\n\n            else:\n                multipart_post = []\n                for k, v in post.items():\n                    if isinstance(v, (str, bool, int)):\n                        multipart_post.append((k, to_str(v)))\n\n                    elif isinstance(v, FormFile):\n                        filename = os.path.basename(v.filename).encode('utf8')\n                        data = v.data\n                        if data is None:\n                            if not os.path.exists(v.filename):\n                                continue\n                            else:\n                                with open(v.filename, \"rb\") as f:\n                                    data = f.read()\n\n                        else:\n                            data = to_bytes(data)\n\n                        multipart_post.append((k, (pycurl.FORM_BUFFER, filename,\n                                                   pycurl.FORM_BUFFERPTR, data,\n                                                   pycurl.FORM_CONTENTTYPE, v.mimetype)))\n\n                self.c.setopt(pycurl.HTTPPOST, multipart_post)\n\n        else:\n            self.c.setopt(pycurl.POST, 0)\n            self.c.setopt(pycurl.HTTPGET, 1)\n\n        if referer and self.last_url:\n            self.c.setopt(pycurl.REFERER, to_bytes(self.last_url))\n\n        if cookies:\n            self.c.setopt(pycurl.COOKIEFILE, b\"\")\n            self.c.setopt(pycurl.COOKIEJAR, b\"\")\n            self.get_cookies()\n\n    def load(\n        self,\n        url,\n        get={},\n        post={},\n        referer=True,\n        cookies=True,\n        just_header=False,\n        multipart=False,\n        decode=True,\n        follow_location=True,\n        save_cookies=True,\n    ):\n        \"\"\"\n        load and returns a given page.\n        \"\"\"\n        self.set_request_context(url, get, post, referer, cookies, multipart, decode)\n\n        self.response_header = b\"\"\n\n        self.c.setopt(pycurl.HTTPHEADER, self.request_headers)\n\n        if not follow_location:\n            self.c.setopt(pycurl.FOLLOWLOCATION, 0)\n\n        if just_header:\n            self.c.setopt(pycurl.NOBODY, 1)\n\n        try:\n            self.c.perform()\n        except pycurl.error as exc:\n            if exc.args[0] == pycurl.E_WRITE_ERROR and self.exception:\n                raise self.exception from None\n            else:\n                raise\n\n        if not follow_location:\n            self.c.setopt(pycurl.FOLLOWLOCATION, 1)\n\n        if just_header:\n            self.c.setopt(pycurl.NOBODY, 0)\n\n        self.c.setopt(pycurl.POSTFIELDS, b\"\")\n        self.last_effective_url = self.c.getinfo(pycurl.EFFECTIVE_URL)\n\n        if save_cookies:\n            self.add_cookies()\n\n        self.code = self.verify_header()\n\n        ret = self.response_header if just_header else self.get_response()\n\n        if decode:\n            ret = to_str(ret, encoding=\"iso-8859-1\") if just_header else self.decode_response(ret)\n\n        self.rep.close()\n        self.rep = None\n\n        return ret\n\n    def verify_header(self):\n        \"\"\"\n        raise an exceptions on bad headers.\n        \"\"\"\n        code = int(self.c.getinfo(pycurl.RESPONSE_CODE))\n        if code in BAD_STATUS_CODES:\n            response = self.decode_response(self.get_response()) if self.decode else self.get_response()\n            header = to_str(self.response_header, encoding=\"iso-8859-1\") if self.decode else self.response_header\n            self.rep.close()\n            self.rep = None\n\n            # 404 will NOT raise an exception\n            raise BadHeader(\n                code,\n                header,\n                response\n            )\n\n        return code\n\n    def check_header(self):\n        \"\"\"\n        check if header indicates failure.\n        \"\"\"\n        return int(self.c.getinfo(pycurl.RESPONSE_CODE)) not in BAD_STATUS_CODES\n\n    def get_response(self):\n        \"\"\"\n        retrieve response from bytes io.\n        \"\"\"\n        if self.rep is None:\n            return b\"\"\n        else:\n            return self.rep.getvalue()\n\n    def decode_response(self, response):\n        \"\"\"\n        decode with correct encoding, relies on header.\n        \"\"\"\n        header = self.response_header.splitlines()\n        encoding = \"utf-8\"  #: default encoding\n\n        for line in header:\n            line = line.lower().replace(b\" \", b\"\")\n            if not line.startswith(b\"content-type:\") or (b\"text\" not in line and b\"application\" not in line):\n                continue\n\n            none, delimiter, charset = line.rpartition(b\"charset=\")\n            if delimiter:\n                charset = charset.split(b\";\")\n                if charset:\n                    encoding = to_str(charset[0])\n\n        try:\n            # self.log.debug(f\"Decoded {encoding}\")\n            if codecs.lookup(encoding).name == \"utf-8\" and response.startswith(\n                codecs.BOM_UTF8\n            ):\n                encoding = \"utf-8-sig\"\n\n            decoder = codecs.getincrementaldecoder(encoding)(\"replace\")\n            response = decoder.decode(response, True)\n\n            # TODO: html_unescape as default\n\n        except LookupError:\n            self.log.debug(f\"No Decoder found for {encoding}\")\n\n        except Exception:\n            self.log.debug(f\"Error when decoding string from {encoding}\", exc_info=True)\n\n        return response\n\n    def write_body(self, buf):\n        \"\"\"\n        writes response.\n        \"\"\"\n        if self.abort:\n            self.exception = Abort()\n            return pycurl.E_WRITE_ERROR\n\n        elif self.limit and self.rep.tell() > self.limit:\n            rep = self.get_response()\n            with open(\"response.dump\", mode=\"wb\") as fp:\n                fp.write(rep)\n\n            self.exception = Exception(f\"Loaded URL exceeded limit ({self.limit})\")\n            return pycurl.E_WRITE_ERROR\n\n        self.rep.write(buf)\n        return None  #: Everything is OK, please continue\n\n    def write_header(self, buf):\n        \"\"\"\n        writes header.\n        \"\"\"\n        self.response_header += buf\n\n    def put_header(self, name, value):\n        self.request_headers.append(f\"{name}: {value}\")\n\n    def clear_headers(self):\n        self.request_headers = []\n\n    def close(self):\n        \"\"\"\n        cleanup, unusable after this.\n        \"\"\"\n        if self.rep:\n            self.rep.close()\n            del self.rep\n\n        if hasattr(self, \"cj\"):\n            del self.cj\n\n        if hasattr(self, \"c\"):\n            self.c.close()\n            del self.c\n", "# -*- coding: utf-8 -*-\n\nfrom threading import Lock\n\nfrom ..utils.struct.lock import lock\nfrom .browser import Browser\nfrom .bucket import Bucket\nfrom .cookie_jar import CookieJar\nfrom .http.http_request import HTTPRequest\nfrom .xdcc.request import XDCCRequest\n\nDEFAULT_REQUEST = None\n\n\nclass RequestFactory:\n    def __init__(self, core):\n        self.lock = Lock()\n        self.pyload = core\n        self._ = core._\n        self.bucket = Bucket()\n        self.update_bucket()\n        self.cookiejars = {}\n\n        # TODO: Rewrite...\n        global DEFAULT_REQUEST\n        if not DEFAULT_REQUEST:\n            DEFAULT_REQUEST = self\n\n    def iface(self):\n        return self.pyload.config.get(\"download\", \"interface\")\n\n    @lock\n    def get_request(self, plugin_name, account=None, type=\"HTTP\", **kwargs):\n        options = self.get_options()\n        options.update(kwargs)  #: submit kwargs as additional options\n\n        if type == \"XDCC\":\n            req = XDCCRequest(self.bucket, options)\n\n        else:\n            req = Browser(self.bucket, options)\n\n            if account:\n                cj = self.get_cookie_jar(plugin_name, account)\n            else:\n                cj = CookieJar(plugin_name)\n\n            req.set_cookie_jar(cj)\n\n        return req\n\n    def get_http_request(self, **kwargs):\n        \"\"\"\n        returns a http request, dont forget to close it !\n        \"\"\"\n        options = self.get_options()\n        options.update(kwargs)  #: submit kwargs as additional options\n        return HTTPRequest(CookieJar(None), options)\n\n    def get_url(self, *args, **kwargs):\n        \"\"\"\n        see HTTPRequest for argument list.\n        \"\"\"\n        with HTTPRequest(None, self.get_options()) as h:\n            rep = h.load(*args, **kwargs)\n        return rep\n\n    def get_cookie_jar(self, plugin_name, account=None):\n        if (plugin_name, account) in self.cookiejars:\n            return self.cookiejars[(plugin_name, account)]\n\n        cj = CookieJar(plugin_name, account)\n        self.cookiejars[(plugin_name, account)] = cj\n        return cj\n\n    def get_proxies(self):\n        \"\"\"\n        returns a proxy list for the request classes.\n        \"\"\"\n        if not self.pyload.config.get(\"proxy\", \"enabled\"):\n            return {}\n        else:\n            proxy_type = self.pyload.config.get(\"proxy\", \"type\").lower()\n\n            username = None\n            if (\n                self.pyload.config.get(\"proxy\", \"username\")\n                and self.pyload.config.get(\"proxy\", \"username\").lower() != \"none\"\n            ):\n                username = self.pyload.config.get(\"proxy\", \"username\")\n\n            pw = None\n            if (\n                self.pyload.config.get(\"proxy\", \"password\")\n                and self.pyload.config.get(\"proxy\", \"password\").lower() != \"none\"\n            ):\n                pw = self.pyload.config.get(\"proxy\", \"password\")\n\n            return {\n                \"type\": proxy_type,\n                \"host\": self.pyload.config.get(\"proxy\", \"host\"),\n                \"port\": self.pyload.config.get(\"proxy\", \"port\"),\n                \"username\": username,\n                \"password\": pw,\n            }\n\n    def get_options(self):\n        \"\"\"\n        returns options needed for pycurl.\n        \"\"\"\n        return {\n            \"interface\": self.iface(),\n            \"proxies\": self.get_proxies(),\n            \"ipv6\": self.pyload.config.get(\"download\", \"ipv6\"),\n        }\n\n    def update_bucket(self):\n        \"\"\"\n        set values in the bucket according to settings.\n        \"\"\"\n        if not self.pyload.config.get(\"download\", \"limit_speed\"):\n            self.bucket.set_rate(-1)\n        else:\n            self.bucket.set_rate(self.pyload.config.get(\"download\", \"max_speed\") << 10)\n\n\ndef get_url(*args, **kwargs):\n    return DEFAULT_REQUEST.get_url(*args, **kwargs)\n\n\ndef get_request(*args, **kwargs):\n    return DEFAULT_REQUEST.get_http_request()\n"], "fixing_code": ["version: 2\n\ngeneral - \"General\":\n    en; language : \"Language\" = en\n    folder storage_folder : \"Download folder\" = ~/Downloads/pyLoad\n    bool debug_mode : \"Debug mode\" = True\n    debug;trace;stack debug_level : \"Debug level\" = trace\n    int min_free_space : \"Minimum free space in MiB\" = 1024\n    bool folder_per_package : \"Create folder for each package\" = True\n    bool ssl_verify : \"Peer's SSL certificate verification\" = True\npermission - \"Permissions\":\n    bool change_user : \"Change user of running process\" = False\n    str user : \"Username for ownership\" = user\n    str folder : \"Permission mode for created folders\" = 0755\n    bool change_file : \"Change permissions of downloads\" = False\n    str file : \"Permission mode for downloaded files\" = 0644\n    bool change_group : \"Change group of running process\" = False\n    str group : \"Groupname for ownership\" = users\n    bool change_dl : \"Change ownership of downloads\" = False\ndownload - \"Download\":\n    int chunks : \"Maximum connections for one download\" = 3\n    int max_downloads : \"Maximum parallel downloads\" = 3\n    int max_speed : \"Maximum download speed in KiB/s\" = -1\n    bool limit_speed : \"Limit download speed\" = False\n    ip interface : \"Download interface to bind (IP Address)\" =\n    bool ipv6 : \"Allow IPv6\" = False\n    bool skip_existing : \"Skip already existing files\" = False\n    time start_time : \"Start time\" = 0:00\n    time end_time : \"End time\" = 0:00\nreconnect - \"Reconnection\":\n    bool enabled : \"Activated\" = False\n    str script : \"Script\" =\n    time start_time : \"Start time\" = 0:00\n    time end_time : \"End time\" = 0:00\nwebui - \"Web Interface\":\n    bool enabled : \"Activated\" = True\n    bool use_ssl : \"Use HTTPS\" = False\n    bool develop : \"Development mode\" = False\n    file ssl_certfile : \"SSL Certificate\" = ssl.crt\n    file ssl_keyfile : \"SSL Key\" = ssl.key\n    file ssl_certchain : \"CA's intermediate certificate bundle (optional)\" =\n    ip host : \"IP address\" = localhost\n    int port : \"Port\" = 8000\n    Default;modern;pyplex theme : \"Theme\" = modern\n    bool autologin : \"Skip login if single user\" = False\n    str prefix: \"Path prefix\" =\n    int session_lifetime : \"Session lifetime (minutes)\" = 44640\nproxy - \"Proxy\":\n    bool enabled : \"Activated\" = False\n    ip host : \"IP address\" = localhost\n    int port : \"Port\" = 7070\n    http;https,socks4;socks5 type : \"Protocol\" = http\n    str username : \"Username\" =\n    password password : \"Password\" =\nlog - \"Log\":\n    bool console : \"Print log to console\" = True\n    bool console_color : \"Colorize console\" = False\n    bool syslog : \"Sent log to syslog\" = False\n    local;remote syslog_location : \"Syslog location\" = local\n    folder syslog_folder : \"Syslog local folder\" =\n    ip syslog_host : \"Syslog remote IP address\" = localhost\n    int syslog_port : \"Syslog remote port\" = 514\n    bool filelog : \"Save log to file\" = True\n    int filelog_size : \"Maximum file size (in KiB)\" = 5120\n    folder filelog_folder : \"Log file folder\" =\n    int filelog_entries : \"Maximum log files\" = 10\n    bool filelog_rotate : \"Log rotate\" = True\n", "# -*- coding: utf-8 -*-\n\nimport codecs\nimport io\nimport mimetypes\nimport os\nfrom itertools import chain\nfrom logging import getLogger\nfrom urllib.parse import quote, urlencode\n\nimport pycurl\nfrom pyload import APPID\n\nfrom ...utils.convert import to_bytes, to_str\nfrom ..exceptions import Abort\nfrom .exceptions import BadHeader\n\n\nif not hasattr(pycurl, 'PROXYTYPE_HTTPS'):\n    pycurl.PROXYTYPE_HTTPS = 2\n\ndef myquote(url):\n    try:\n        url = url.encode()\n    except AttributeError:\n        pass\n    return quote(url, safe=\"%/:=&?~#+!$,;'@()*[]\")\n\n\ndef myurlencode(data):\n    data = dict(data)\n    return urlencode(\n        {\n            x.encode()\n            if hasattr(x, \"encode\")\n            else x: y.encode()\n            if hasattr(y, \"encode\")\n            else y\n            for x, y in data.items()\n        }\n    )\n\n\nBAD_STATUS_CODES = tuple(\n    chain(range(400, 404), range(405, 418), range(500, 506))\n)\n\n\nclass FormFile:\n    def __init__(self, filename, data=None, mimetype=None):\n        self.filename = os.path.abspath(filename)\n        self.data = data\n        self.mimetype = mimetype or mimetypes.guess_type(filename)[0] if not data and os.path.exists(\n            filename) else None or 'application/octet-stream'\n\n    def __repr__(self):\n        return f\"FormFile <'{os.path.basename(self.filename)}'>\"\n\n\nclass HTTPRequest:\n    def __init__(self, cookies=None, options=None, limit=2_000_000):\n        self.exception = None\n        self.limit = limit\n\n        self.c = pycurl.Curl()\n        self.rep = None\n\n        self.cj = cookies  #: cookiejar\n\n        self.last_url = None\n        self.last_effective_url = None\n        self.code = 0  #: last http code\n\n        self.response_header = b\"\"\n\n        self.request_headers = []  #: temporary request header\n\n        self.abort = False\n        self.decode = False\n\n        self.init_handle()\n        self.set_interface(options)\n\n        self.c.setopt(pycurl.WRITEFUNCTION, self.write_body)\n        self.c.setopt(pycurl.HEADERFUNCTION, self.write_header)\n\n        self.log = getLogger(APPID)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n\n    def init_handle(self):\n        \"\"\"\n        sets common options to curl handle.\n        \"\"\"\n        self.c.setopt(pycurl.FOLLOWLOCATION, 1)\n        self.c.setopt(pycurl.MAXREDIRS, 10)\n        self.c.setopt(pycurl.CONNECTTIMEOUT, 30)\n        self.c.setopt(pycurl.NOSIGNAL, 1)\n        self.c.setopt(pycurl.NOPROGRESS, 1)\n        if hasattr(pycurl, \"AUTOREFERER\"):\n            self.c.setopt(pycurl.AUTOREFERER, 1)\n        self.c.setopt(pycurl.SSL_VERIFYPEER, 1)\n        self.c.setopt(pycurl.LOW_SPEED_TIME, 60)\n        self.c.setopt(pycurl.LOW_SPEED_LIMIT, 5)\n        if hasattr(pycurl, \"USE_SSL\"):\n            self.c.setopt(pycurl.USE_SSL, pycurl.USESSL_TRY)\n\n        # self.c.setopt(pycurl.VERBOSE, 1)\n        # self.c.setopt(pycurl.HTTP_VERSION, pycurl.CURL_HTTP_VERSION_1_1)\n\n        self.c.setopt(\n            pycurl.USERAGENT,\n            b\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0\",\n        )\n        if pycurl.version_info()[7]:\n            self.c.setopt(pycurl.ENCODING, b\"gzip, deflate\")\n        self.c.setopt(\n            pycurl.HTTPHEADER,\n            [\n                b\"Accept: */*\",\n                b\"Accept-Language: en-US,en\",\n                b\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\",\n                b\"Connection: keep-alive\",\n                b\"Keep-Alive: 300\",\n                b\"Expect:\",\n            ],\n        )\n\n    def set_interface(self, options):\n        options = {\n            k: v.encode() if hasattr(v, \"encode\") else v for k, v in options.items()\n        }\n\n        interface, proxy, ipv6 = (\n            options[\"interface\"],\n            options[\"proxies\"],\n            options[\"ipv6\"],\n        )\n\n        if interface and interface.lower() != \"none\":\n            self.c.setopt(pycurl.INTERFACE, interface)\n\n        if proxy:\n            if proxy[\"type\"] == \"http\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_HTTP)\n            elif proxy[\"type\"] == \"https\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_HTTPS)\n                self.c.setopt(pycurl.PROXY_SSL_VERIFYPEER, 0)\n            elif proxy[\"type\"] == \"socks4\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_SOCKS4)\n            elif proxy[\"type\"] == \"socks5\":\n                self.c.setopt(pycurl.PROXYTYPE, pycurl.PROXYTYPE_SOCKS5)\n\n            self.c.setopt(pycurl.PROXY, proxy[\"host\"])\n            self.c.setopt(pycurl.PROXYPORT, int(proxy[\"port\"]))\n\n            if proxy[\"username\"]:\n                user = proxy[\"username\"]\n                pw = proxy[\"password\"]\n                self.c.setopt(pycurl.PROXYUSERPWD, f\"{user}:{pw}\".encode())\n\n        if ipv6:\n            self.c.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_WHATEVER)\n        else:\n            self.c.setopt(pycurl.IPRESOLVE, pycurl.IPRESOLVE_V4)\n\n        if \"auth\" in options:\n            self.c.setopt(pycurl.USERPWD, options[\"auth\"])\n\n        if \"timeout\" in options:\n            self.c.setopt(pycurl.LOW_SPEED_TIME, int(options[\"timeout\"]))\n\n        if \"ssl_verify\" in options:\n            self.c.setopt(pycurl.SSL_VERIFYPEER, 1 if options[\"ssl_verify\"] else 0)\n\n    def add_cookies(self):\n        \"\"\"\n        put cookies from curl handle to cj.\n        \"\"\"\n        if self.cj:\n            self.cj.add_cookies(self.c.getinfo(pycurl.INFO_COOKIELIST))\n\n    def get_cookies(self):\n        \"\"\"\n        add cookies from cj to curl handle.\n        \"\"\"\n        if self.cj:\n            for c in self.cj.get_cookies():\n                self.c.setopt(pycurl.COOKIELIST, c)\n        return\n\n    def clear_cookies(self):\n        self.c.setopt(pycurl.COOKIELIST, \"\")\n\n    def set_request_context(self, url, get, post, referer, cookies, multipart=False, decode=True):\n        \"\"\"\n        sets everything needed for the request.\n        \"\"\"\n        self.rep = io.BytesIO()\n\n        self.exception = None\n\n        self.decode = decode\n\n        url = myquote(url)\n\n        if get:\n            get = urlencode(get)\n            url = f\"{url}?{get}\"\n\n        self.c.setopt(pycurl.URL, url)\n        self.c.last_url = url\n\n        if post:\n            self.c.setopt(pycurl.POST, 1)\n            if not multipart:\n                if post is True:\n                    pass\n                elif isinstance(post, str):\n                    post = post.encode()\n                    self.c.setopt(pycurl.POSTFIELDS, post)\n                else:  # TODO: check if mapping\n                    post = myurlencode(post)\n                    self.c.setopt(pycurl.POSTFIELDS, post)\n\n            else:\n                multipart_post = []\n                for k, v in post.items():\n                    if isinstance(v, (str, bool, int)):\n                        multipart_post.append((k, to_str(v)))\n\n                    elif isinstance(v, FormFile):\n                        filename = os.path.basename(v.filename).encode('utf8')\n                        data = v.data\n                        if data is None:\n                            if not os.path.exists(v.filename):\n                                continue\n                            else:\n                                with open(v.filename, \"rb\") as f:\n                                    data = f.read()\n\n                        else:\n                            data = to_bytes(data)\n\n                        multipart_post.append((k, (pycurl.FORM_BUFFER, filename,\n                                                   pycurl.FORM_BUFFERPTR, data,\n                                                   pycurl.FORM_CONTENTTYPE, v.mimetype)))\n\n                self.c.setopt(pycurl.HTTPPOST, multipart_post)\n\n        else:\n            self.c.setopt(pycurl.POST, 0)\n            self.c.setopt(pycurl.HTTPGET, 1)\n\n        if referer and self.last_url:\n            self.c.setopt(pycurl.REFERER, to_bytes(self.last_url))\n\n        if cookies:\n            self.c.setopt(pycurl.COOKIEFILE, b\"\")\n            self.c.setopt(pycurl.COOKIEJAR, b\"\")\n            self.get_cookies()\n\n    def load(\n        self,\n        url,\n        get={},\n        post={},\n        referer=True,\n        cookies=True,\n        just_header=False,\n        multipart=False,\n        decode=True,\n        follow_location=True,\n        save_cookies=True,\n    ):\n        \"\"\"\n        load and returns a given page.\n        \"\"\"\n        self.set_request_context(url, get, post, referer, cookies, multipart, decode)\n\n        self.response_header = b\"\"\n\n        self.c.setopt(pycurl.HTTPHEADER, self.request_headers)\n\n        if not follow_location:\n            self.c.setopt(pycurl.FOLLOWLOCATION, 0)\n\n        if just_header:\n            self.c.setopt(pycurl.NOBODY, 1)\n\n        try:\n            self.c.perform()\n        except pycurl.error as exc:\n            if exc.args[0] == pycurl.E_WRITE_ERROR and self.exception:\n                raise self.exception from None\n            else:\n                raise\n\n        if not follow_location:\n            self.c.setopt(pycurl.FOLLOWLOCATION, 1)\n\n        if just_header:\n            self.c.setopt(pycurl.NOBODY, 0)\n\n        self.c.setopt(pycurl.POSTFIELDS, b\"\")\n        self.last_effective_url = self.c.getinfo(pycurl.EFFECTIVE_URL)\n\n        if save_cookies:\n            self.add_cookies()\n\n        self.code = self.verify_header()\n\n        ret = self.response_header if just_header else self.get_response()\n\n        if decode:\n            ret = to_str(ret, encoding=\"iso-8859-1\") if just_header else self.decode_response(ret)\n\n        self.rep.close()\n        self.rep = None\n\n        return ret\n\n    def verify_header(self):\n        \"\"\"\n        raise an exceptions on bad headers.\n        \"\"\"\n        code = int(self.c.getinfo(pycurl.RESPONSE_CODE))\n        if code in BAD_STATUS_CODES:\n            response = self.decode_response(self.get_response()) if self.decode else self.get_response()\n            header = to_str(self.response_header, encoding=\"iso-8859-1\") if self.decode else self.response_header\n            self.rep.close()\n            self.rep = None\n\n            # 404 will NOT raise an exception\n            raise BadHeader(\n                code,\n                header,\n                response\n            )\n\n        return code\n\n    def check_header(self):\n        \"\"\"\n        check if header indicates failure.\n        \"\"\"\n        return int(self.c.getinfo(pycurl.RESPONSE_CODE)) not in BAD_STATUS_CODES\n\n    def get_response(self):\n        \"\"\"\n        retrieve response from bytes io.\n        \"\"\"\n        if self.rep is None:\n            return b\"\"\n        else:\n            return self.rep.getvalue()\n\n    def decode_response(self, response):\n        \"\"\"\n        decode with correct encoding, relies on header.\n        \"\"\"\n        header = self.response_header.splitlines()\n        encoding = \"utf-8\"  #: default encoding\n\n        for line in header:\n            line = line.lower().replace(b\" \", b\"\")\n            if not line.startswith(b\"content-type:\") or (b\"text\" not in line and b\"application\" not in line):\n                continue\n\n            none, delimiter, charset = line.rpartition(b\"charset=\")\n            if delimiter:\n                charset = charset.split(b\";\")\n                if charset:\n                    encoding = to_str(charset[0])\n\n        try:\n            # self.log.debug(f\"Decoded {encoding}\")\n            if codecs.lookup(encoding).name == \"utf-8\" and response.startswith(\n                codecs.BOM_UTF8\n            ):\n                encoding = \"utf-8-sig\"\n\n            decoder = codecs.getincrementaldecoder(encoding)(\"replace\")\n            response = decoder.decode(response, True)\n\n            # TODO: html_unescape as default\n\n        except LookupError:\n            self.log.debug(f\"No Decoder found for {encoding}\")\n\n        except Exception:\n            self.log.debug(f\"Error when decoding string from {encoding}\", exc_info=True)\n\n        return response\n\n    def write_body(self, buf):\n        \"\"\"\n        writes response.\n        \"\"\"\n        if self.abort:\n            self.exception = Abort()\n            return pycurl.E_WRITE_ERROR\n\n        elif self.limit and self.rep.tell() > self.limit:\n            rep = self.get_response()\n            with open(\"response.dump\", mode=\"wb\") as fp:\n                fp.write(rep)\n\n            self.exception = Exception(f\"Loaded URL exceeded limit ({self.limit})\")\n            return pycurl.E_WRITE_ERROR\n\n        self.rep.write(buf)\n        return None  #: Everything is OK, please continue\n\n    def write_header(self, buf):\n        \"\"\"\n        writes header.\n        \"\"\"\n        self.response_header += buf\n\n    def put_header(self, name, value):\n        self.request_headers.append(f\"{name}: {value}\")\n\n    def clear_headers(self):\n        self.request_headers = []\n\n    def close(self):\n        \"\"\"\n        cleanup, unusable after this.\n        \"\"\"\n        if self.rep:\n            self.rep.close()\n            del self.rep\n\n        if hasattr(self, \"cj\"):\n            del self.cj\n\n        if hasattr(self, \"c\"):\n            self.c.close()\n            del self.c\n", "# -*- coding: utf-8 -*-\n\nfrom threading import Lock\n\nfrom ..utils.struct.lock import lock\nfrom .browser import Browser\nfrom .bucket import Bucket\nfrom .cookie_jar import CookieJar\nfrom .http.http_request import HTTPRequest\nfrom .xdcc.request import XDCCRequest\n\nDEFAULT_REQUEST = None\n\n\nclass RequestFactory:\n    def __init__(self, core):\n        self.lock = Lock()\n        self.pyload = core\n        self._ = core._\n        self.bucket = Bucket()\n        self.update_bucket()\n        self.cookiejars = {}\n\n        # TODO: Rewrite...\n        global DEFAULT_REQUEST\n        if not DEFAULT_REQUEST:\n            DEFAULT_REQUEST = self\n\n    def iface(self):\n        return self.pyload.config.get(\"download\", \"interface\")\n\n    @lock\n    def get_request(self, plugin_name, account=None, type=\"HTTP\", **kwargs):\n        options = self.get_options()\n        options.update(kwargs)  #: submit kwargs as additional options\n\n        if type == \"XDCC\":\n            req = XDCCRequest(self.bucket, options)\n\n        else:\n            req = Browser(self.bucket, options)\n\n            if account:\n                cj = self.get_cookie_jar(plugin_name, account)\n            else:\n                cj = CookieJar(plugin_name)\n\n            req.set_cookie_jar(cj)\n\n        return req\n\n    def get_http_request(self, **kwargs):\n        \"\"\"\n        returns a http request, dont forget to close it !\n        \"\"\"\n        options = self.get_options()\n        options.update(kwargs)  #: submit kwargs as additional options\n        return HTTPRequest(CookieJar(None), options)\n\n    def get_url(self, *args, **kwargs):\n        \"\"\"\n        see HTTPRequest for argument list.\n        \"\"\"\n        with HTTPRequest(None, self.get_options()) as h:\n            rep = h.load(*args, **kwargs)\n        return rep\n\n    def get_cookie_jar(self, plugin_name, account=None):\n        if (plugin_name, account) in self.cookiejars:\n            return self.cookiejars[(plugin_name, account)]\n\n        cj = CookieJar(plugin_name, account)\n        self.cookiejars[(plugin_name, account)] = cj\n        return cj\n\n    def get_proxies(self):\n        \"\"\"\n        returns a proxy list for the request classes.\n        \"\"\"\n        if not self.pyload.config.get(\"proxy\", \"enabled\"):\n            return {}\n        else:\n            proxy_type = self.pyload.config.get(\"proxy\", \"type\").lower()\n\n            username = None\n            if (\n                self.pyload.config.get(\"proxy\", \"username\")\n                and self.pyload.config.get(\"proxy\", \"username\").lower() != \"none\"\n            ):\n                username = self.pyload.config.get(\"proxy\", \"username\")\n\n            pw = None\n            if (\n                self.pyload.config.get(\"proxy\", \"password\")\n                and self.pyload.config.get(\"proxy\", \"password\").lower() != \"none\"\n            ):\n                pw = self.pyload.config.get(\"proxy\", \"password\")\n\n            return {\n                \"type\": proxy_type,\n                \"host\": self.pyload.config.get(\"proxy\", \"host\"),\n                \"port\": self.pyload.config.get(\"proxy\", \"port\"),\n                \"username\": username,\n                \"password\": pw,\n            }\n\n    def get_options(self):\n        \"\"\"\n        returns options needed for pycurl.\n        \"\"\"\n        return {\n            \"interface\": self.iface(),\n            \"proxies\": self.get_proxies(),\n            \"ipv6\": self.pyload.config.get(\"download\", \"ipv6\"),\n            \"ssl_verify\": self.pyload.config.get(\"general\", \"ssl_verify\"),\n        }\n\n    def update_bucket(self):\n        \"\"\"\n        set values in the bucket according to settings.\n        \"\"\"\n        if not self.pyload.config.get(\"download\", \"limit_speed\"):\n            self.bucket.set_rate(-1)\n        else:\n            self.bucket.set_rate(self.pyload.config.get(\"download\", \"max_speed\") << 10)\n\n\ndef get_url(*args, **kwargs):\n    return DEFAULT_REQUEST.get_url(*args, **kwargs)\n\n\ndef get_request(*args, **kwargs):\n    return DEFAULT_REQUEST.get_http_request()\n"], "filenames": ["src/pyload/core/config/default.cfg", "src/pyload/core/network/http/http_request.py", "src/pyload/core/network/request_factory.py"], "buggy_code_start_loc": [9, 106, 114], "buggy_code_end_loc": [9, 176, 114], "fixing_code_start_loc": [10, 106, 115], "fixing_code_end_loc": [11, 180, 116], "type": "CWE-295", "message": "Improper Certificate Validation in GitHub repository pyload/pyload prior to 0.5.0b3.dev44.", "other": {"cve": {"id": "CVE-2023-0509", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-26T22:15:26.993", "lastModified": "2023-02-07T17:14:22.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Certificate Validation in GitHub repository pyload/pyload prior to 0.5.0b3.dev44."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-01-25", "matchCriteriaId": "98C08F13-A3B4-424F-AB95-9CAEDC37D57F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pyload-ng_project:pyload-ng:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.5.0b3.dev44", "matchCriteriaId": "41241786-7E3F-4DAF-A391-913FAD3C3C45"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/a9098bdf7406e6faf9df3da6ff2d584e90c13bbb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/a370e0c2-a41c-4871-ad91-bc6f31a8e839", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/a9098bdf7406e6faf9df3da6ff2d584e90c13bbb"}}