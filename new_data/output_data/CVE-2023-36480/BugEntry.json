{"buggy_code": ["/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.luaj.vm2.LuaBoolean;\nimport org.luaj.vm2.LuaDouble;\nimport org.luaj.vm2.LuaInteger;\nimport org.luaj.vm2.LuaNil;\nimport org.luaj.vm2.LuaString;\nimport org.luaj.vm2.LuaValue;\n\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\nimport com.aerospike.client.lua.LuaBytes;\nimport com.aerospike.client.lua.LuaInstance;\nimport com.aerospike.client.util.Packer;\n\n/**\n * Polymorphic value classes used to efficiently serialize objects into the wire protocol.\n */\npublic abstract class Value {\n\t/**\n\t * Null value.\n\t */\n\tpublic static final Value NULL = NullValue.INSTANCE;\n\n\t/**\n\t * Infinity value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value INFINITY = new InfinityValue();\n\n\t/**\n\t * Wildcard value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value WILDCARD = new WildcardValue();\n\n\t/**\n\t * Get string or null value instance.\n\t */\n\tpublic static Value get(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new StringValue(value);\n\t}\n\n\t/**\n\t * Get byte array or null value instance.\n\t */\n\tpublic static Value get(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value);\n\t}\n\n\t/**\n\t * Get byte array with type or null value instance.\n\t */\n\tpublic static Value get(byte[] value, int type) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value, type);\n\t}\n\n\t/**\n\t * Get byte segment or null value instance.\n\t */\n\tpublic static Value get(byte[] value, int offset, int length) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ByteSegmentValue(value, offset, length);\n\t}\n\n\t/**\n\t * Get byte segment or null value instance.\n\t */\n\tpublic static Value get(ByteBuffer bb) {\n\t\treturn (bb == null)? NullValue.INSTANCE : new BytesValue(bb.array());\n\t}\n\n\t/**\n\t * Get byte value instance.\n\t */\n\tpublic static Value get(byte value) {\n\t\treturn new ByteValue(value);\n\t}\n\n\t/**\n\t * Get integer value instance.\n\t */\n\tpublic static Value get(int value) {\n\t\treturn new IntegerValue(value);\n\t}\n\n\t/**\n\t * Get long value instance.\n\t */\n\tpublic static Value get(long value) {\n\t\treturn new LongValue(value);\n\t}\n\n\t/**\n\t * Get double value instance.\n\t */\n\tpublic static Value get(double value) {\n\t\treturn new DoubleValue(value);\n\t}\n\n\t/**\n\t * Get float value instance.\n\t */\n\tpublic static Value get(float value) {\n\t\treturn new FloatValue(value);\n\t}\n\n\t/**\n\t * Get boolean value instance.\n\t */\n\tpublic static Value get(boolean value) {\n\t\treturn new BooleanValue(value);\n\t}\n\n\t/**\n\t * Get list or null value instance.\n\t */\n\tpublic static Value get(List<?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ListValue(value);\n\t}\n\n\t/**\n\t * Get map or null value instance.\n\t */\n\tpublic static Value get(Map<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get blob or null value instance.\n\t */\n\tpublic static Value getAsBlob(Object value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {\n        \treturn new BytesValue((byte[])value);\n\t\t}\n\n\t\tif (value instanceof String) {\n        \treturn new StringValue((String)value);\n\t\t}\n\n\t\tif (value instanceof Integer) {\n        \treturn new IntegerValue((Integer)value);\n\t\t}\n\n\t\tif (value instanceof Long) {\n        \treturn new LongValue((Long)value);\n\t\t}\n\n\t\tif (value instanceof Double) {\n        \treturn new DoubleValue((Double)value);\n\t\t}\n\n\t\tif (value instanceof Float) {\n        \treturn new FloatValue((Float)value);\n\t\t}\n\n\t\tif (value instanceof Boolean) {\n        \treturn new BooleanValue((Boolean)value);\n\t\t}\n\n\t\tif (value instanceof Byte) {\n        \treturn new ByteValue((byte)value);\n\t\t}\n\n\t\tif (value instanceof List<?>) {\n        \treturn new ListValue((List<?>)value);\n\t\t}\n\n\t\tif (value instanceof Map<?,?>) {\n        \treturn new MapValue((Map<?,?>)value);\n\t\t}\n\n\t\tif (value instanceof ByteBuffer) {\n\t\t\tByteBuffer bb = (ByteBuffer)value;\n        \treturn new BytesValue(bb.array());\n\t\t}\n\n\t\treturn new BlobValue(value);\n\t}\n\n\t/**\n\t * Get value from Record object. Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value getFromRecordObject(Object value) {\n\t\treturn Value.get(value);\n\t}\n\n\t/**\n\t * Calculate number of bytes necessary to serialize the value in the wire protocol.\n\t */\n\tpublic abstract int estimateSize() throws AerospikeException;\n\n\t/**\n\t * Serialize the value in the wire protocol.\n\t */\n\tpublic abstract int write(byte[] buffer, int offset) throws AerospikeException;\n\n\t/**\n\t * Serialize the value using MessagePack.\n\t */\n\tpublic abstract void pack(Packer packer);\n\n\t/**\n\t * Validate if value type can be used as a key.\n\t * @throws AerospikeException\tif type can't be used as a key.\n\t */\n\tpublic void validateKeyType() throws AerospikeException {\n\t}\n\n\t/**\n\t * Get wire protocol value type.\n\t */\n\tpublic abstract int getType();\n\n\t/**\n\t * Return original value as an Object.\n\t */\n\tpublic abstract Object getObject();\n\n\t/**\n\t * Return value as an Object.\n\t */\n\tpublic abstract LuaValue getLuaValue(LuaInstance instance);\n\n\t/**\n\t * Return value as an integer.\n\t */\n\tpublic int toInteger() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Return value as a long.\n\t */\n\tpublic long toLong() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Empty value.\n\t */\n\tpublic static final class NullValue extends Value {\n\t\tpublic static final NullValue INSTANCE = new NullValue();\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packNil();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: null\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.NULL;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaNil.NIL;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.getClass().equals(other.getClass());\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Byte array value.\n\t */\n\tpublic static final class BytesValue extends Value {\n\t\tprivate final byte[] bytes;\n\t\tprivate final int type;\n\n\t\tpublic BytesValue(byte[] bytes) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.type = ParticleType.BLOB;\n\t\t}\n\n\t\tpublic BytesValue(byte[] bytes, int type) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.type = type;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes, type);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn new LuaBytes(instance, bytes, type);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.bytes, ((BytesValue)other).bytes));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * Byte segment value.\n\t */\n\tpublic static final class ByteSegmentValue extends Value {\n\t\tprivate final byte[] bytes;\n\t\tprivate final int offset;\n\t\tprivate final int length;\n\n\t\tpublic ByteSegmentValue(byte[] bytes, int offset, int length) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.offset = offset;\n\t\t\tthis.length = length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn length;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int targetOffset) {\n\t\t\tSystem.arraycopy(bytes, offset, buffer, targetOffset, length);\n\t\t\treturn length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.BLOB;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (! this.getClass().equals(obj.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tByteSegmentValue other = (ByteSegmentValue)obj;\n\n\t\t\tif (this.length != other.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tif (this.bytes[this.offset + i] != other.bytes[other.offset + i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        int result = 1;\n\t        for (int i = 0; i < length; i++) {\n\t            result = 31 * result + bytes[offset+i];\n\t        }\n\t        return result;\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\tpublic int getOffset() {\n\t\t\treturn offset;\n\t\t}\n\n\t\tpublic int getLength() {\n\t\t\treturn length;\n\t\t}\n\t}\n\n\t/**\n\t * Byte value.\n\t */\n\tpublic static final class ByteValue extends Value {\n\t\tprivate final byte value;\n\n\t\tpublic ByteValue(byte value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packByte(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\t// The server does not natively handle one byte, so store as long (8 byte integer).\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Byte.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((ByteValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * String value.\n\t */\n\tpublic static final class StringValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic StringValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn Buffer.stringToUtf8(value, buffer, offset);\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.STRING;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value.equals(((StringValue)other).value));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Integer value.\n\t */\n\tpublic static final class IntegerValue extends Value {\n\t\tprivate final int value;\n\n\t\tpublic IntegerValue(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packInt(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Integer.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((IntegerValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Long value.\n\t */\n\tpublic static final class LongValue extends Value {\n\t\tprivate final long value;\n\n\t\tpublic LongValue(long value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packLong(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Long.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((LongValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return (int)(value ^ (value >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Double value.\n\t */\n\tpublic static final class DoubleValue extends Value {\n\t\tprivate final double value;\n\n\t\tpublic DoubleValue(double value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.doubleToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packDouble(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.DOUBLE;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaDouble.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Double.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((DoubleValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        long bits = Double.doubleToLongBits(value);\n\t        return (int)(bits ^ (bits >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn (long)value;\n\t\t}\n\t}\n\n\t/**\n\t * Float value.\n\t */\n\tpublic static final class FloatValue extends Value {\n\t\tprivate final float value;\n\n\t\tpublic FloatValue(float value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.doubleToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packFloat(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.DOUBLE;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaDouble.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Float.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((FloatValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return Float.floatToIntBits(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn (long)value;\n\t\t}\n\t}\n\n\t/**\n\t * Boolean value.\n\t */\n\tpublic static final class BooleanValue extends Value {\n\t\tprivate final boolean value;\n\n\t\tpublic BooleanValue(boolean value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value? 1L : 0L, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBoolean(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\t// The server does not natively handle boolean, so store as long (8 byte integer).\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaBoolean.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Boolean.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((BooleanValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value ? 1231 : 1237;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value? 1 : 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value? 1L : 0L;\n\t\t}\n\t}\n\n\t/**\n\t * Blob value.\n\t */\n\tpublic static final class BlobValue extends Value {\n\t\tprivate final Object object;\n\t\tprivate byte[] bytes;\n\n\t\tpublic BlobValue(Object object) {\n\t\t\tthis.object = object;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n\t\t\ttry {\n\t\t\t\tByteArrayOutputStream bstream = new ByteArrayOutputStream();\n\t\t\t\tObjectOutputStream ostream = new ObjectOutputStream(bstream);\n\t\t\t\tostream.writeObject(object);\n\t\t\t\tostream.close();\n\t\t\t\tbytes = bstream.toByteArray();\n\t\t\t\treturn bytes.length;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBlob(object);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.JBLOB;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn object;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.object.equals(((BlobValue)other).object));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return object.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * GeoJSON value.\n\t */\n\tpublic static final class GeoJSONValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic GeoJSONValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\t// flags + ncells + jsonstr\n\t\t\treturn 1 + 2 + Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tbuffer[offset] = 0; // flags\n\t\t\tBuffer.shortToBytes(0, buffer, offset + 1); // ncells\n\t\t\treturn 1 + 2 + Buffer.stringToUtf8(value, buffer, offset + 3); // jsonstr\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packGeoJSON(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: GeoJson\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.GEOJSON;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value.equals(((GeoJSONValue)other).value));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * HyperLogLog value.\n\t */\n\tpublic static final class HLLValue extends Value {\n\t\tprivate final byte[] bytes;\n\n\t\tpublic HLLValue(byte[] bytes) {\n\t\t\tthis.bytes = bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: HLL\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.HLL;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn new LuaBytes(instance, bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.bytes, ((HLLValue)other).bytes));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * Value array.\n\t */\n\tpublic static final class ValueArray extends Value {\n\t\tprivate final Value[] array;\n\t\tprivate byte[] bytes;\n\n\t\tpublic ValueArray(Value[] array) {\n\t\t\tthis.array = array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(array);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packValueArray(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: value[]\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.LIST;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.array, ((ValueArray)other).array));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\t}\n\n\t/**\n\t * List value.\n\t */\n\tpublic static final class ListValue extends Value {\n\t\tprivate final List<?> list;\n\t\tprivate byte[] bytes;\n\n\t\tpublic ListValue(List<?> list) {\n\t\t\tthis.list = list;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(list);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: list\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.LIST;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn list.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.list.equals(((ListValue)other).list));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return list.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Map value.\n\t */\n\tpublic static final class MapValue extends Value {\n\t\tprivate final Map<?,?> map;\n\t\tprivate byte[] bytes;\n\n\t\tpublic MapValue(Map<?,?> map)  {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(map);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packMap(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: map\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.MAP;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn map;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaMap(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn map.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.map.equals(((MapValue)other).map));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return map.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Sorted map value.\n\t */\n\tpublic static final class SortedMapValue extends Value {\n\t\tprivate final List<? extends Entry<?,?>> list;\n\t\tprivate byte[] bytes;\n\t\tprivate final MapOrder order;\n\n\t\tpublic SortedMapValue(List<? extends Entry<?,?>> list, MapOrder order)  {\n\t\t\tthis.list = list;\n\t\t\tthis.order = order;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(list, order);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packMap(list, order);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: map\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.MAP;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn list.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other == null || ! this.getClass().equals(other.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSortedMapValue o = (SortedMapValue)other;\n\t\t\treturn this.order == o.order && this.list.equals(o.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return list.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Infinity value.\n\t */\n\tpublic static final class InfinityValue extends Value {\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packInfinity();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid particle type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid lua type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"INF\";\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\t\tthis.getClass().equals(other.getClass()));\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Wildcard value.\n\t */\n\tpublic static final class WildcardValue extends Value {\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packWildcard();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid particle type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid lua type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"*\";\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\t\tthis.getClass().equals(other.getClass()));\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.command;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.util.Unpacker;\n\npublic final class Buffer {\n\n\tpublic static Value bytesToKeyValue(int type, byte[] buf, int offset, int len)\n\t\tthrows AerospikeException {\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\treturn Value.get(Buffer.utf8ToString(buf, offset, len));\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn bytesToLongValue(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn new Value.DoubleValue(Buffer.bytesToDouble(buf, offset));\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Value.get(Arrays.copyOfRange(buf, offset, offset+len));\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static Object bytesToParticle(int type, byte[] buf, int offset, int len)\n\t\tthrows AerospikeException {\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.JBLOB:\n\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*\n\tprivate static Object parseList(byte[] buf, int offset, int len) throws AerospikeException {\n\t\tint limit = offset + len;\n\t\tint itemCount = Buffer.bytesToInt(buf, offset);\n\t\toffset += 4;\n\t\tArrayList<Object> list = new ArrayList<Object>(itemCount);\n\n\t\twhile (offset < limit) {\n\t\t\tint sz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\tint type = buf[offset];\n\t\t\toffset++;\n\t\t\tlist.add(bytesToParticle(type, buf, offset, sz));\n\t\t\toffset += sz;\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate static Object parseMap(byte[] buf, int offset, int len) throws AerospikeException {\n\t\tObject key;\n\t\tObject value;\n\n\t\tint limit = offset + len;\n\t\tint n_items = Buffer.bytesToInt(buf, offset);\n\t\toffset += 4;\n\t\tHashMap<Object, Object> map = new HashMap<Object, Object>(n_items);\n\n\t\twhile (offset < limit) {\n\t\t\t// read out the key\n\t\t\tint sz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\tint type = buf[offset];\n\t\t\toffset++;\n\n\t\t\tkey = bytesToParticle(type, buf, offset, len);\n\t\t\toffset += sz;\n\n\t\t\t// read out the value\n\t\t\tsz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\ttype = buf[offset];\n\t\t\toffset++;\n\n\t\t\tvalue = bytesToParticle(type, buf, offset, len);\n\t\t\toffset += sz;\n\n\t\t\tmap.put(key, value);\n\t\t}\n\t\treturn map;\n\t}\n\t*/\n\n\t/**\n\t * Estimate size of Utf8 encoded bytes without performing the actual encoding.\n\t */\n\tpublic static int estimateSizeUtf8(String value) {\n\t\tif (value == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint max = value.length();\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < max; i++) {\n\t\t\tchar ch = value.charAt(i);\n\n\t\t\tif (ch < 0x80) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if (ch < 0x800) {\n\t\t\t    count += 2;\n\t\t\t}\n\t\t\telse if (Character.isHighSurrogate(ch)) {\n\t\t\t\tcount += 4;\n\t\t\t\t++i;\n\t\t\t} else {\n\t\t\t\tcount += 3;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n    public static byte[] stringToUtf8(String s) {\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn new byte[0];\n\t\t}\n\t\tint size = estimateSizeUtf8(s);\n\t\tbyte[] bytes = new byte[size];\n\t\tstringToUtf8(s, bytes, 0);\n\t\treturn bytes;\n    }\n\n\t/**\n\t * Convert input string to UTF-8, copies into buffer (at given offset).\n\t * Returns number of bytes in the string.\n\t *\n     * Java's internal UTF8 conversion is very, very slow.\n     * This is, rather amazingly, 8x faster than the to-string method.\n\t * Returns the number of bytes this translated into.\n     */\n    public static int stringToUtf8(String s, byte[] buf, int offset) {\n        if (s == null) {\n        \treturn 0;\n        }\n    \tint length = s.length();\n        int startOffset = offset;\n\n        for (int i = 0; i < length; i++) {\n            int c = s.charAt(i);\n            if (c < 0x80) {\n                buf[offset++] = (byte) c;\n            }\n            else if (c < 0x800) {\n            \tbuf[offset++] = (byte)(0xc0 | ((c >> 6)));\n            \tbuf[offset++] = (byte)(0x80 | (c & 0x3f));\n            }\n            else {\n\t\t    \t// Encountered a different encoding other than 2-byte UTF8. Let java handle it.\n            \ttry {\n\t\t    \t\tbyte[] value = s.getBytes(\"UTF8\");\n\t\t\t\t\tSystem.arraycopy(value, 0, buf, startOffset, value.length);\n\t\t\t\t\treturn value.length;\n            \t}\n            \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 encoding is not supported.\");\n            \t}\n            }\n        }\n        return offset - startOffset;\n    }\n\n    public static String utf8ToString(byte[] buf, int offset, int length) {\n    \t// A Thread local implementation does not help here, so\n    \t// allocate character buffer each time.\n    \tif (length == 0) {\n    \t\treturn \"\";\n    \t}\n\n\t\tchar[] charBuffer = new char[length];\n    \tint charCount = 0;\n        int limit = offset + length;\n    \tint origoffset = offset;\n\n        while (offset < limit ) {\n        \tint b1 = buf[offset];\n\n        \tif (b1 >= 0) {\n                charBuffer[charCount++] = (char)b1;\n                offset++;\n        \t}\n        \telse if ((b1 >> 5) == -2) {\n        \t\tint b2 = buf[offset + 1];\n        \t\tcharBuffer[charCount++] = (char) (((b1 << 6) ^ b2) ^ 0x0f80);\n                offset += 2;\n        \t}\n\t\t    else {\n\t\t    \t// Encountered an UTF encoding which uses more than 2 bytes.\n\t\t    \t// Use a native function to do the conversion.\n\t\t    \ttry {\n\t\t    \t\treturn new String(buf, origoffset, length, \"UTF8\");\n\t\t    \t}\n\t\t    \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 decoding is not supported.\");\n\t\t    \t}\n\t\t    }\n        }\n        return new String(charBuffer, 0, charCount);\n    }\n\n    public static String utf8ToString(byte[] buf, int offset, int length, StringBuilder sb) {\n    \tif (length == 0) {\n    \t\treturn \"\";\n    \t}\n\n    \t// This method is designed to accommodate multiple string conversions on the same\n    \t// thread, but without the ThreadLocal overhead.  The StringBuilder instance is\n    \t// created on the stack and passed in each method invocation.\n    \tsb.setLength(0);\n        int limit = offset + length;\n    \tint origoffset = offset;\n\n        while (offset < limit ) {\n            if ((buf[offset] & 0x80) == 0) { // 1 byte\n                char c = (char) buf[offset];\n                sb.append(c);\n                offset++;\n            }\n            else if ((buf[offset] & 0xE0) == 0xC0) { // 2 bytes\n                char c =  (char) (((buf[offset] & 0x1f) << 6) | (buf[offset+1] & 0x3f));\n                sb.append(c);\n                offset += 2;\n            }\n\t\t    else {\n\t\t    \t// Encountered an UTF encoding which uses more than 2 bytes.\n\t\t    \t// Use a native function to do the conversion.\n\t\t    \ttry {\n\t\t    \t\treturn new String(buf, origoffset, length, \"UTF8\");\n\t\t    \t}\n\t\t    \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 decoding is not supported.\");\n\t\t    \t}\n\t\t    }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convert UTF8 numeric digits to an integer.  Negative integers are not supported.\n     *\n     * Input format: 1234\n     */\n    public static int utf8DigitsToInt(byte[] buf, int begin, int end) {\n    \tint val = 0;\n    \tint mult = 1;\n\n    \tfor (int i = end - 1; i >= begin; i--) {\n    \t\tval += ((int)buf[i] - 48) * mult;\n    \t\tmult *= 10;\n    \t}\n    \treturn val;\n    }\n\n    public static String bytesToHexString(byte[] buf) {\n    \tif (buf == null || buf.length == 0) {\n    \t\treturn \"\";\n    \t}\n\t\tStringBuilder sb = new StringBuilder(buf.length * 2);\n\n\t\tfor (int i = 0; i < buf.length; i++) {\n    \t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n    }\n\n    public static String bytesToHexString(byte[] buf, int offset, int length) {\n\t\tStringBuilder sb = new StringBuilder(length * 2);\n\n\t\tfor (int i = offset; i < length; i++) {\n    \t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n    }\n\n    public static Object bytesToObject(byte[] buf, int offset, int length)\n\t\tthrows AerospikeException.Serialize {\n\n    \tif (length <= 0) {\n    \t\treturn null;\n    \t}\n\n\t\ttry {\n\t\t\tByteArrayInputStream bastream = new ByteArrayInputStream(buf, offset, length);\n\t\t\tObjectInputStream oistream = new ObjectInputStream(bastream);\n\t\t\treturn oistream.readObject();\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\n\t\treturn new Value.LongValue(val);\n\t}\n\n\tpublic static Object bytesToGeoJSON(byte[] buf, int offset, int len) {\n\t\t// Ignore the flags for now\n\t\tint ncells = bytesToShort(buf, offset + 1);\n\t\tint hdrsz = 1 + 2 + (ncells * 8);\n\t\treturn Value.getAsGeoJSON(Buffer.utf8ToString(buf, offset + hdrsz, len - hdrsz));\n\t}\n\n\tpublic static Object bytesToHLL(byte[] buf, int offset, int len) {\n\t\tbyte[] bytes = Arrays.copyOfRange(buf, offset, offset+len);\n\t\treturn Value.getAsHLL(bytes);\n\t}\n\n\tpublic static Object bytesToNumber(byte[] buf, int offset, int len) {\n\t\t// Server always returns 8 for integer length.\n\t\tif (len == 8) {\n\t\t\treturn bytesToLong(buf, offset);\n\t\t}\n\n\t\t// Handle other lengths just in case server changes.\n\t\tif (len == 0) {\n\t\t\treturn new Long(0);\n\t\t}\n\n\t\tif (len == 4) {\n\t\t\treturn new Long(bytesToInt(buf, offset));\n\t\t}\n\n\t\tif (len > 8) {\n\t\t\treturn bytesToBigInteger(buf, offset, len);\n\t\t}\n\n\t\t// Handle variable length integer.\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\t\treturn new Long(val);\n\t}\n\n\tpublic static Object bytesToBigInteger(byte[] buf, int offset, int len) {\n\t\tboolean negative = false;\n\n\t\tif ((buf[offset] & 0x80) != 0) {\n\t\t\tnegative = true;\n\t\t\tbuf[offset] &= 0x7f;\n\t\t}\n\t\tbyte[] bytes = new byte[len];\n\t\tSystem.arraycopy(buf, offset, bytes, 0, len);\n\n\t\tBigInteger big = new BigInteger(bytes);\n\n\t\tif (negative) {\n\t\t\tbig = big.negate();\n\t\t}\n\t\treturn big;\n\t}\n\n\t//-------------------------------------------------------\n\t// 64 bit double conversions.\n\t//-------------------------------------------------------\n\n\tpublic static double bytesToDouble(byte[] buf, int offset) {\n\t\treturn Double.longBitsToDouble(bytesToLong(buf, offset));\n\t}\n\n\tpublic static void doubleToBytes(double v, byte[] buf, int offset) {\n\t\tBuffer.longToBytes(Double.doubleToLongBits(v), buf, offset);\n\t}\n\n\t//-------------------------------------------------------\n\t// 64 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert long to big endian signed or unsigned 64 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void longToBytes(long v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 56);\n\t\tbuf[offset++] = (byte)(v >>> 48);\n\t\tbuf[offset++] = (byte)(v >>> 40);\n\t\tbuf[offset++] = (byte)(v >>> 32);\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>>  8);\n\t\tbuf[offset]   = (byte)(v >>>  0);\n\t}\n\n    /**\n     * Convert long to little endian signed or unsigned 64 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void longToLittleBytes(long v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 0);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 32);\n\t\tbuf[offset++] = (byte)(v >>> 40);\n\t\tbuf[offset++] = (byte)(v >>> 48);\n\t\tbuf[offset]   = (byte)(v >>> 56);\n\t}\n\n    /**\n     * Convert big endian signed 64 bits to long.\n     */\n\tpublic static long bytesToLong(byte[] buf, int offset) {\n       return (\n    \t\t((long)(buf[offset]   & 0xFF) << 56) |\n   \t\t\t((long)(buf[offset+1] & 0xFF) << 48) |\n   \t\t\t((long)(buf[offset+2] & 0xFF) << 40) |\n   \t\t\t((long)(buf[offset+3] & 0xFF) << 32) |\n   \t\t\t((long)(buf[offset+4] & 0xFF) << 24) |\n   \t\t\t((long)(buf[offset+5] & 0xFF) << 16) |\n   \t\t\t((long)(buf[offset+6] & 0xFF) << 8) |\n   \t\t\t((long)(buf[offset+7] & 0xFF) << 0)\n   \t\t\t);\n    }\n\n    /**\n     * Convert little endian signed 64 bits to long.\n     */\n    public static long littleBytesToLong(byte[] buf, int offset) {\n        return (\n\t\t\t((long)(buf[offset]   & 0xFF) << 0) |\n\t\t\t((long)(buf[offset+1] & 0xFF) << 8) |\n\t\t\t((long)(buf[offset+2] & 0xFF) << 16) |\n\t\t\t((long)(buf[offset+3] & 0xFF) << 24) |\n\t\t\t((long)(buf[offset+4] & 0xFF) << 32) |\n\t\t\t((long)(buf[offset+5] & 0xFF) << 40) |\n\t\t\t((long)(buf[offset+6] & 0xFF) << 48) |\n\t\t\t((long)(buf[offset+7] & 0xFF) << 56)\n\t\t\t);\n    }\n\n\t//-------------------------------------------------------\n\t// 32 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert int to big endian signed or unsigned 32 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void intToBytes(int v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset]   = (byte)(v >>> 0);\n\t}\n\n    /**\n     * Convert int to little endian signed or unsigned 32 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void intToLittleBytes(int v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 0);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset]   = (byte)(v >>> 24);\n\t}\n\n    /**\n     * Convert big endian signed 32 bits to int.\n     */\n\tpublic static int bytesToInt(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((buf[offset]   & 0xFF) << 24) |\n\t\t\t((buf[offset+1] & 0xFF) << 16) |\n\t\t\t((buf[offset+2] & 0xFF) << 8) |\n\t\t\t((buf[offset+3] & 0xFF) << 0)\n\t\t\t);\n\t}\n\n    /**\n     * Convert little endian signed 32 bits to int.\n     */\n\tpublic static int littleBytesToInt(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((buf[offset]   & 0xFF) << 0) |\n\t\t\t((buf[offset+1] & 0xFF) << 8) |\n\t\t\t((buf[offset+2] & 0xFF) << 16) |\n\t\t\t((buf[offset+3] & 0xFF) << 24)\n\t\t\t);\n\t}\n\n    /**\n     * Convert big endian unsigned 32 bits to long.\n     */\n\tpublic static long bigUnsigned32ToLong(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((long)(buf[offset]   & 0xFF) << 24) |\n\t\t\t((long)(buf[offset+1] & 0xFF) << 16) |\n\t\t\t((long)(buf[offset+2] & 0xFF) << 8) |\n\t\t\t((long)(buf[offset+3] & 0xFF) << 0)\n\t\t\t);\n\t}\n\n\t//-------------------------------------------------------\n\t// 16 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert int to big endian signed or unsigned 16 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n    public static void shortToBytes(int v, byte[] buf, int offset) {\n        buf[offset++] = (byte)(v >>> 8);\n        buf[offset]   = (byte)(v >>> 0);\n    }\n\n    /**\n     * Convert int to little endian signed or unsigned 16 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n    public static void shortToLittleBytes(int v, byte[] buf, int offset) {\n        buf[offset++] = (byte)(v >>> 0);\n        buf[offset]   = (byte)(v >>> 8);\n    }\n\n    /**\n     * Convert big endian unsigned 16 bits to int.\n     */\n    public static int bytesToShort(byte[] buf, int offset) {\n        return (\n\t\t\t((buf[offset]   & 0xFF) << 8) |\n\t\t\t((buf[offset+1] & 0xFF) << 0)\n        \t);\n    }\n\n    /**\n     * Convert little endian unsigned 16 bits to int.\n     */\n    public static int littleBytesToShort(byte[] buf, int offset) {\n        return (\n\t\t\t((buf[offset]   & 0xFF) << 0) |\n\t\t\t((buf[offset+1] & 0xFF) << 8)\n\t\t\t);\n    }\n\n    /**\n     * Convert big endian signed 16 bits to short.\n     */\n    public static short bigSigned16ToShort(byte[] buf, int offset) {\n        return (short)(\n\t\t\t((buf[offset]   & 0xFF) << 8) |\n\t\t\t((buf[offset+1] & 0xFF) << 0)\n        \t);\n    }\n\n    //-------------------------------------------------------\n\t// Variable byte number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     *\tEncode an integer in variable 7-bit format.\n     *\tThe high bit indicates if more bytes are used.\n     *  Return byte size of integer.\n     */\n    public static int intToVarBytes(int v, byte[] buf, int offset) {\n    \tint i = offset;\n\n    \twhile (i < buf.length && v >= 0x80) {\n    \t\tbuf[i++] = (byte)(v | 0x80);\n    \t\tv >>>= 7;\n    \t}\n\n    \tif (i < buf.length) {\n    \t\tbuf[i++] = (byte)v;\n    \t\treturn i - offset;\n    \t}\n    \treturn 0;\n    }\n\n    /**\n     *\tDecode an integer in variable 7-bit format.\n     *\tThe high bit indicates if more bytes are used.\n     *  Return value and byte size in array.\n     */\n    public static int[] varBytesToInt(byte[] buf, int offset) {\n\t\tint i = offset;\n\t\tint val = 0;\n\t\tint shift = 0;\n\t\tbyte b;\n\n\t\tdo {\n\t\t\tb = buf[i++];\n\t\t\tval |= (b & 0x7F) << shift;\n\t\t\tshift += 7;\n\t\t} while ((b & 0x80) != 0);\n\n\t\treturn new int[] {val, i - offset};\n    }\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * Serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic final class Packer {\n\n\tpublic static byte[] pack(Value[] val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packValueArray(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(List<?> val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packList(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(Map<?,?> val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packMap(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(List<? extends Entry<?,?>> val, MapOrder order) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packMap(val, order);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate byte[] buffer;\n\tprivate int offset;\n\tprivate ArrayList<BufferItem> bufferList;\n\n\tpublic Packer() {\n\t\tthis.buffer = ThreadLocalData.getBuffer();\n\t}\n\n\tpublic void packValueArray(Value[] values) {\n\t\tpackArrayBegin(values.length);\n\t\tfor (Value value : values) {\n\t\t\tvalue.pack(this);\n\t\t}\n\t}\n\n\tpublic void packValueList(List<Value> list) {\n\t\tpackArrayBegin(list.size());\n\t\tfor (Value value : list) {\n\t\t\tvalue.pack(this);\n\t\t}\n\t}\n\n\tpublic void packList(List<?> list) {\n\t\tpackArrayBegin(list.size());\n\t\tfor (Object obj : list) {\n\t\t\tpackObject(obj);\n\t\t}\n\t}\n\n\tpublic void packArrayBegin(int size) {\n        if (size < 16) {\n        \tpackByte(0x90 | size);\n        }\n        else if (size < 65536) {\n        \tpackShort(0xdc, size);\n        }\n        else {\n        \tpackInt(0xdd, size);\n        }\n    }\n\n\tpublic void packValueMap(Map<Value,Value> map) {\n\t\tpackMapBegin(map.size());\n\t\tfor (Entry<Value,Value> entry : map.entrySet()) {\n\t\t\tentry.getKey().pack(this);\n\t\t\tentry.getValue().pack(this);\n\t\t}\n\t}\n\n\tpublic void packMap(Map<?,?> map) {\n\t\tpackMapBegin(map.size());\n\t\tfor (Entry<?,?> entry : map.entrySet()) {\n\t\t\tpackObject(entry.getKey());\n\t\t\tpackObject(entry.getValue());\n\t\t}\n\t}\n\n\tpublic void packMap(List<? extends Entry<?,?>> list, MapOrder order) {\n\t\tint attr = order.attributes;\n\n\t\tif (attr > 0) {\n\t\t\t// Map is sorted.\n\t\t\tpackMapBegin(list.size() + 1);\n\t\t\tpackByte(0xc7);\n\t\t\tpackByte(0);\n\t\t\tpackByte(attr);\n\t\t\tpackByte(0xc0);\n\t\t}\n\t\telse {\n\t\t\tpackMapBegin(list.size());\n\t\t}\n\n\t\tfor (Entry<?,?> entry : list) {\n\t\t\tpackObject(entry.getKey());\n\t\t\tpackObject(entry.getValue());\n\t\t}\n\t}\n\n\tpublic void packMapBegin(int size) {\n        if (size < 16) {\n        \tpackByte(0x80 | size);\n        }\n        else if (size < 65536) {\n        \tpackShort(0xde, size);\n        }\n        else {\n        \tpackInt(0xdf, size);\n        }\n    }\n\n\tpublic void packBytes(byte[] b) {\n    \tpackByteArrayBegin(b.length + 1);\n    \tpackByte(ParticleType.BLOB);\n    \tpackByteArray(b, 0, b.length);\n    }\n\n\tpublic void packBytes(byte[] b, int type) {\n    \tpackByteArrayBegin(b.length + 1);\n    \tpackByte(type);\n    \tpackByteArray(b, 0, b.length);\n    }\n\n\tpublic void packBytes(byte[] b, int offset, int length) {\n    \tpackByteArrayBegin(length + 1);\n    \tpackByte(ParticleType.BLOB);\n    \tpackByteArray(b, offset, length);\n\t}\n\n\tpublic void packBlob(Object val) throws AerospikeException {\n\t\tByteArrayOutputStream bstream = new ByteArrayOutputStream();\n\n\t\ttry {\n\t\t\tObjectOutputStream ostream = new ObjectOutputStream(bstream);\n\t\t\tostream.writeObject(val);\n\t\t\tostream.close();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new AerospikeException.Serialize(ioe);\n\t\t}\n\n\t\tbyte[] bytes = bstream.toByteArray();\n        packByteArrayBegin(bytes.length + 1);\n    \tpackByte(ParticleType.JBLOB);\n    \tpackByteArray(bytes, 0, bytes.length);\n\t}\n\n\tpublic void packGeoJSON(String val) {\n\t\tbyte[] buffer = Buffer.stringToUtf8(val);\n\t\tpackByteArrayBegin(buffer.length + 1);\n\t\tpackByte(ParticleType.GEOJSON);\n\t\tpackByteArray(buffer, 0, buffer.length);\n\t}\n\n\tprivate void packByteArrayBegin(int size) {\n\t\t// Continue to pack byte arrays as strings until all servers/clients\n\t\t// have been upgraded to handle new message pack binary type.\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xda, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdb, size);\n\t\t}\n\n\t\t// TODO: Replace with this code after all servers/clients\n\t\t// have been upgraded to handle new message pack binary type.\n\t\t/*\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\telse if (size < 256) {\n\t\t\tpackByte(0xc4, size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xc5, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xc6, size);\n\t\t}*/\n\t}\n\n\tpublic void packObject(Object obj) {\n\t\tif (obj == null) {\n\t\t\tpackNil();\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Value) {\n\t\t\tValue value = (Value) obj;\n\t\t\tvalue.pack(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof byte[]) {\n\t\t\tpackBytes((byte[]) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof String) {\n\t\t\tpackString((String) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Integer) {\n\t\t\tpackInt((Integer) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Long) {\n\t\t\tpackLong((Long) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Double) {\n\t\t\tpackDouble((Double) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Float) {\n\t\t\tpackFloat((Float) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Boolean) {\n\t\t\tpackBoolean((Boolean)obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof List<?>) {\n\t\t\tpackList((List<?>) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Map<?,?>) {\n\t\t\tpackMap((Map<?,?>) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof ByteBuffer) {\n\t\t\tpackByteBuffer((ByteBuffer) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tpackBlob(obj);\n\t}\n\n\tpublic void packByteBuffer(ByteBuffer bb) {\n\t\tbyte[] b = bb.array();\n\t\tpackBytes(b);\n\t}\n\n\tpublic void packLong(long val) {\n    \tif (val >= 0L) {\n        \tif (val < 128L) {\n        \t\tpackByte((int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 256L) {\n        \t\tpackByte(0xcc, (int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 65536L) {\n        \t\tpackShort(0xcd, (int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 4294967296L) {\n        \t\tpackInt(0xce, (int)val);\n        \t\treturn;\n        \t}\n        \tpackLong(0xcf, val);\n    \t}\n    \telse {\n        \tif (val >= -32) {\n        \t\tpackByte(0xe0 | ((int)val + 32));\n        \t\treturn;\n        \t}\n\n        \tif (val >= Byte.MIN_VALUE) {\n                packByte(0xd0, (int)val);\n                return;\n        \t}\n\n        \tif (val >= Short.MIN_VALUE) {\n                packShort(0xd1, (int)val);\n                return;\n        \t}\n\n        \tif (val >= Integer.MIN_VALUE) {\n        \t\tpackInt(0xd2, (int)val);\n                return;\n        \t}\n        \tpackLong(0xd3, val);\n    \t}\n    }\n\n    public void packInt(int val) {\n    \tif (val >= 0) {\n        \tif (val < 128) {\n        \t\tpackByte(val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 256) {\n        \t\tpackByte(0xcc, val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 65536) {\n        \t\tpackShort(0xcd, val);\n        \t\treturn;\n        \t}\n        \tpackInt(0xce, val);\n    \t}\n    \telse {\n        \tif (val >= -32) {\n        \t\tpackByte(0xe0 | (val + 32));\n        \t\treturn;\n        \t}\n\n        \tif (val >= Byte.MIN_VALUE) {\n                packByte(0xd0, val);\n                return;\n        \t}\n\n        \tif (val >= Short.MIN_VALUE) {\n                packShort(0xd1, val);\n                return;\n        \t}\n        \tpackInt(0xd2, val);\n    \t}\n    }\n\n\tpublic void packString(String val) {\n\t\tint size = Buffer.estimateSizeUtf8(val) + 1;\n\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\t// TODO: Enable this code after all servers/clients\n\t\t// have been upgraded to handle 8 bit string length format.\n\t\t/*\n\t\telse if (size < 256) {\n\t\t\tpackByte(0xd9, size);\n\t\t}\n\t\t*/\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xda, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdb, size);\n\t\t}\n\n\t\tif (offset + size > buffer.length) {\n\t\t\tresize(size);\n\t\t}\n\t\tbuffer[offset++] = (byte)ParticleType.STRING;\n\t\toffset += Buffer.stringToUtf8(val, buffer, offset);\n\t}\n\n\tprivate void packByteArray(byte[] src, int srcOffset, int srcLength) {\n       \tif (offset + srcLength > buffer.length) {\n    \t\tresize(srcLength);\n    \t}\n \t\tSystem.arraycopy(src, srcOffset, buffer, offset, srcLength);\n\t\toffset += srcLength;\n    }\n\n    public void packDouble(double val) {\n    \tif (offset + 9 > buffer.length) {\n    \t\tresize(9);\n    \t}\n    \tbuffer[offset++] = (byte)0xcb;\n    \tBuffer.longToBytes(Double.doubleToLongBits(val), buffer, offset);\n    \toffset += 8;\n    }\n\n    public void packFloat(float val) {\n    \tif (offset + 5 > buffer.length) {\n    \t\tresize(5);\n    \t}\n    \tbuffer[offset++] = (byte)0xca;\n    \tBuffer.intToBytes(Float.floatToIntBits(val), buffer, offset);\n    \toffset += 4;\n    }\n\n    private void packLong(int type, long val) {\n    \tif (offset + 9 > buffer.length) {\n    \t\tresize(9);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.longToBytes(val, buffer, offset);\n    \toffset += 8;\n    }\n\n    private void packInt(int type, int val) {\n    \tif (offset + 5 > buffer.length) {\n    \t\tresize(5);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.intToBytes(val, buffer, offset);\n    \toffset += 4;\n    }\n\n    private void packShort(int type, int val) {\n    \tif (offset + 3 > buffer.length) {\n    \t\tresize(3);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.shortToBytes(val, buffer, offset);\n    \toffset += 2;\n    }\n\n    public void packRawShort(int val) {\n    \t// WARNING. This method is not compatible with message pack standard.\n    \tif (offset + 2 > buffer.length) {\n    \t\tresize(2);\n    \t}\n    \tBuffer.shortToBytes(val, buffer, offset);\n    \toffset += 2;\n    }\n\n    private void packByte(int type, int val) {\n    \tif (offset + 2 > buffer.length) {\n    \t\tresize(2);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tbuffer[offset++] = (byte)val;\n    }\n\n    public void packBoolean(boolean val) {\n    \tif (offset + 1 > buffer.length) {\n    \t\tresize(1);\n    \t}\n\n    \tif (val) {\n    \t\tbuffer[offset++] = (byte)0xc3;\n    \t}\n    \telse {\n    \t\tbuffer[offset++] = (byte)0xc2;\n    \t}\n    }\n\n    public void packNil() {\n    \tif (offset >= buffer.length) {\n    \t\tresize(1);\n    \t}\n    \tbuffer[offset++] = (byte)0xc0;\n    }\n\n\tpublic void packInfinity() {\n\t\tif (offset + 3 > buffer.length) {\n\t\t\tresize(3);\n\t\t}\n\t\tbuffer[offset++] = (byte)0xd4;\n\t\tbuffer[offset++] = (byte)0xff;\n\t\tbuffer[offset++] = (byte)0x01;\n\t}\n\n\tpublic void packWildcard() {\n\t\tif (offset + 3 > buffer.length) {\n\t\t\tresize(3);\n\t\t}\n\t\tbuffer[offset++] = (byte)0xd4;\n\t\tbuffer[offset++] = (byte)0xff;\n\t\tbuffer[offset++] = (byte)0x00;\n\t}\n\n\tpublic void packByte(int val) {\n    \tif (offset >= buffer.length) {\n    \t\tresize(1);\n    \t}\n    \tbuffer[offset++] = (byte)val;\n    }\n\n    private void resize(int size) {\n    \tif (bufferList == null) {\n    \t\tbufferList = new ArrayList<BufferItem>();\n    \t}\n    \tbufferList.add(new BufferItem(buffer, offset));\n\n    \tif (size < buffer.length) {\n    \t\tsize = buffer.length;\n    \t}\n    \tbuffer = new byte[size];\n    \toffset = 0;\n    }\n\n    public byte[] toByteArray() {\n    \tif (bufferList != null) {\n        \tint size = offset;\n    \t\tfor (BufferItem item : bufferList) {\n    \t\t\tsize += item.length;\n    \t\t}\n\n    \t\tbyte[] target = new byte[size];\n    \t\tsize = 0;\n    \t\tfor (BufferItem item : bufferList) {\n            \tSystem.arraycopy(item.buffer, 0, target, size, item.length);\n    \t\t\tsize += item.length;\n    \t\t}\n\n    \t\tSystem.arraycopy(buffer, 0, target, size, offset);\n        \treturn target;\n    \t}\n    \telse {\n        \tbyte[] target = new byte[offset];\n        \tSystem.arraycopy(buffer, 0, target, 0, offset);\n        \treturn target;\n    \t}\n\t}\n\n    private static final class BufferItem {\n    \tprivate byte[] buffer;\n    \tprivate int length;\n\n    \tprivate BufferItem(byte[] buffer, int length) {\n    \t\tthis.buffer = buffer;\n    \t\tthis.length = length;\n    \t}\n    }\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.nio.ByteBuffer;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * De-serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic abstract class Unpacker<T> {\n\n\tprivate final byte[] buffer;\n\tprivate int offset;\n\tprivate final int length;\n\n\tpublic Unpacker(byte[] buffer, int offset, int length) {\n\t\tthis.buffer = buffer;\n\t\tthis.offset = offset;\n\t\tthis.length = length;\n\t}\n\n\tpublic final T unpackList() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}\n\n\t\ttry {\n\t\t\tint type = buffer[offset++] & 0xff;\n\t\t\tint count;\n\n\t\t\tif ((type & 0xf0) == 0x90) {\n\t\t\t\tcount = type & 0x0f;\n\t\t\t}\n\t\t\telse if (type == 0xdc) {\n\t\t\t\tcount = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse if (type == 0xdd) {\n\t\t\t\tcount = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn getList(new ArrayList<T>(0));\n\t\t\t}\n\t\t\treturn unpackList(count);\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate T unpackList(int count) throws IOException, ClassNotFoundException {\n\t\tif (count <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}\n\n\t\t// Extract first object.\n\t\tint mark = offset;\n\t\tint size = count;\n\t\tT val = unpackObject();\n\n\t\tif (val == null) {\n\t\t\t// Determine if null value is because of an extension type.\n\t\t\tint type = buffer[mark] & 0xff;\n\n\t\t\tif (type != 0xc0) {  // not nil type\n\t\t\t\t// Ignore extension type.\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\n\t\tArrayList<T> out = new ArrayList<T>(size);\n\n\t\tif (size == count) {\n\t\t\tout.add(val);\n\t\t}\n\n\t\tfor (int i = 1; i < count; i++) {\n\t\t\tout.add(unpackObject());\n\t\t}\n\t\treturn getList(out);\n\t}\n\n\tpublic final T unpackMap() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t}\n\n\t\ttry {\n\t\t\tint type = buffer[offset++] & 0xff;\n\t\t\tint count;\n\n\t\t\tif ((type & 0xf0) == 0x80) {\n\t\t\t\tcount = type & 0x0f;\n\t\t\t}\n\t\t\telse if (type == 0xde) {\n\t\t\t\tcount = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse if (type == 0xdf) {\n\t\t\t\tcount = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t\t}\n\t\t\treturn unpackMap(count);\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate T unpackMap(int count) throws IOException, ClassNotFoundException {\n\t\tif (count <= 0) {\n\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t}\n\n\t\t// Peek at buffer to determine map type, but do not advance.\n\t\tint type = buffer[offset] & 0xff;\n\n\t\t// Check for extension that the server uses.\n\t\tif (type == 0xc7) {\n\t\t\tint extensionType = buffer[offset + 1] & 0xff;\n\n\t\t\tif (extensionType == 0) {\n\t\t\t\tint mapBits = buffer[offset + 2] & 0xff;\n\n\t\t\t\t// Extension is a map type.  Determine which one.\n\t\t\t\tif ((mapBits & (0x04 | 0x08)) != 0) {\n\t\t\t\t\t// Index/rank range result where order needs to be preserved.\n\t\t\t\t\treturn unpackMapAsList(count);\n\t\t\t\t}\n\t\t\t\telse if ((mapBits & 0x01) != 0) {\n\t\t\t\t\t// Sorted map\n\t\t\t\t\treturn unpackTreeMap(count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn unpackHashMap(count);\n\t}\n\n\tprivate T unpackHashMap(int count) throws IOException, ClassNotFoundException {\n\t\tHashMap<T,T> map = new HashMap<T,T>(count);\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tmap.put(key, val);\n\t\t\t}\n\t\t}\n\t\treturn getMap(map);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T unpackTreeMap(int count) throws IOException, ClassNotFoundException {\n\t\tTreeMap<T,T> map = new TreeMap<T,T>();\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tif (key instanceof byte[]) {\n\t\t\t\t\t// TreeMap does not support byte[] keys,\n\t\t\t\t\t// so wrap byte[] in a ByteBuffer.\n\t\t\t\t\tkey = (T)ByteBuffer.wrap((byte[])key);\n\t\t\t\t}\n\t\t\t\tmap.put(key, val);\n\t\t\t}\n\t\t}\n\t\treturn getMap(map);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T unpackMapAsList(int count) throws IOException, ClassNotFoundException {\n\t\t// Index/rank range result where order needs to be preserved.\n\t\t// Store in List<Entry<?,?> to preserve order.\n\t\t// The first entry is going to be null (ignored), so use \"count - 1\" size.\n\t\tList<Entry<T,T>> list = new ArrayList<Entry<T,T>>(count - 1);\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tlist.add(new AbstractMap.SimpleEntry<T,T>(key, val));\n\t\t\t}\n\t\t}\n\t\treturn getList((List<T>)list);\n\t}\n\n\tprivate T unpackBlob(int count) throws IOException, ClassNotFoundException {\n\t\tint type = buffer[offset++] & 0xff;\n\t\tcount--;\n\t\tT val;\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tcase ParticleType.JBLOB:\n\t\t\tByteArrayInputStream bastream = new ByteArrayInputStream(buffer, offset, count);\n\t\t\tObjectInputStream oistream = new ObjectInputStream(bastream);\n\t\t\tval = getJavaBlob(oistream.readObject());\n\t\t\tbreak;\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval = getBlob(Arrays.copyOfRange(buffer, offset, offset + count));\n\t\t\tbreak;\n\t\t}\n\t\toffset += count;\n\t\treturn val;\n\t}\n\n\tpublic T unpackObject() throws IOException, ClassNotFoundException {\n\t\tint type = buffer[offset++] & 0xff;\n\n\t\tswitch (type) {\n\t\t\tcase 0xc0: { // nil\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc3: { // boolean true\n\t\t\t\treturn getBoolean(true);\n\t\t\t}\n\n\t\t\tcase 0xc2: { // boolean false\n\t\t\t\treturn getBoolean(false);\n\t\t\t}\n\n\t\t\tcase 0xca: { // float\n\t\t\t\tfloat val = Float.intBitsToFloat(Buffer.bytesToInt(buffer, offset));\n\t\t\t\toffset += 4;\n\t\t\t\treturn getDouble(val);\n\t\t\t}\n\n\t\t\tcase 0xcb: { // double\n\t\t\t\tdouble val = Double.longBitsToDouble(Buffer.bytesToLong(buffer, offset));\n\t\t\t\toffset += 8;\n\t\t\t\treturn getDouble(val);\n\t\t\t}\n\n\t\t\tcase 0xd0: { // signed 8 bit integer\n\t\t\t\treturn getLong(buffer[offset++]);\n\t\t\t}\n\n\t\t\tcase 0xcc: { // unsigned 8 bit integer\n\t\t\t\treturn getLong(buffer[offset++] & 0xff);\n\t\t\t}\n\n\t\t\tcase 0xd1: { // signed 16 bit integer\n\t\t\t\tshort val = Buffer.bigSigned16ToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xcd: { // unsigned 16 bit integer\n\t\t\t\tint val = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xd2: { // signed 32 bit integer\n\t\t\t\tint val = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xce: { // unsigned 32 bit integer\n\t\t\t\tlong val = Buffer.bigUnsigned32ToLong(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xd3: { // signed 64 bit integer\n\t\t\t\tlong val = Buffer.bytesToLong(buffer, offset);\n\t\t\t\toffset += 8;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xcf: { // unsigned 64 bit integer\n\t\t\t\t// Java is constrained to signed longs, so that is the best we can do here.\n\t\t\t\tlong val = Buffer.bytesToLong(buffer, offset);\n\t\t\t\toffset += 8;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xc4:\n\t\t\tcase 0xd9: { // string/raw bytes with 8 bit header\n\t\t\t\tint count = buffer[offset++] & 0xff;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xc5:\n\t\t\tcase 0xda: { // string/raw bytes with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xc6:\n\t\t\tcase 0xdb: { // string/raw bytes with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xdc: { // list with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn unpackList(count);\n\t\t\t}\n\n\t\t\tcase 0xdd: { // list with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn unpackList(count);\n\t\t\t}\n\n\t\t\tcase 0xde: { // map with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn unpackMap(count);\n\t\t\t}\n\n\t\t\tcase 0xdf: { // map with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn unpackMap(count);\n\t\t\t}\n\n\t\t\tcase 0xd4: { // Skip over type extension with 1 byte\n\t\t\t\toffset += 1 + 1;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd5: { // Skip over type extension with 2 bytes\n\t\t\t\toffset += 1 + 2;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd6: { // Skip over type extension with 4 bytes\n\t\t\t\toffset += 1 + 4;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd7: { // Skip over type extension with 8 bytes\n\t\t\t\toffset += 1 + 8;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd8: { // Skip over type extension with 16 bytes\n\t\t\t\toffset += 1 + 16;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc7: { // Skip over type extension with 8 bit header and bytes\n\t\t\t\tint count = buffer[offset] & 0xff;\n\t\t\t\toffset += count + 1 + 1;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc8: { // Skip over type extension with 16 bit header and bytes\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += count + 1 + 2;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc9: { // Skip over type extension with 32 bit header and bytes\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += count + 1 + 4;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif ((type & 0xe0) == 0xa0) { // raw bytes with 8 bit combined header\n\t\t\t\t\treturn unpackBlob(type & 0x1f);\n\t\t\t\t}\n\n\t\t\t\tif ((type & 0xf0) == 0x80) { // map with 8 bit combined header\n\t\t\t\t\treturn unpackMap(type & 0x0f);\n\t\t\t\t}\n\n\t\t\t\tif ((type & 0xf0) == 0x90) { // list with 8 bit combined header\n\t\t\t\t\treturn unpackList(type & 0x0f);\n\t\t\t\t}\n\n\t\t\t\tif (type < 0x80) { // 8 bit combined unsigned integer\n\t\t        \treturn getLong(type);\n\t\t\t\t}\n\n\t\t\t\tif (type >= 0xe0) { // 8 bit combined signed integer\n\t\t        \treturn getLong(type - 0xe0 - 32);\n\t\t\t\t}\n\t\t\t\tthrow new IOException(\"Unknown unpack type: \" + type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected abstract T getMap(Map<T,T> value);\n\tprotected abstract T getList(List<T> value);\n\tprotected abstract T getJavaBlob(Object value);\n\tprotected abstract T getBlob(byte[] value);\n\tprotected abstract T getString(String value);\n\tprotected abstract T getLong(long value);\n\tprotected abstract T getDouble(double value);\n\tprotected abstract T getBoolean(boolean value);\n\tprotected abstract T getGeoJSON(String value);\n\n\tpublic static Object unpackObjectList(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\treturn unpacker.unpackList();\n\t}\n\n\tpublic static Object unpackObjectMap(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\treturn unpacker.unpackMap();\n\t}\n\n\tpublic static Object unpackObject(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\ttry {\n\t\t\tif (length <= 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\t\treturn unpacker.unpackObject();\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static final class ObjectUnpacker extends Unpacker<Object> {\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getJavaBlob(Object value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}\n}\n"], "fixing_code": ["/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client;\n\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.luaj.vm2.LuaBoolean;\nimport org.luaj.vm2.LuaDouble;\nimport org.luaj.vm2.LuaInteger;\nimport org.luaj.vm2.LuaNil;\nimport org.luaj.vm2.LuaString;\nimport org.luaj.vm2.LuaValue;\n\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\nimport com.aerospike.client.lua.LuaBytes;\nimport com.aerospike.client.lua.LuaInstance;\nimport com.aerospike.client.util.Packer;\n\n/**\n * Polymorphic value classes used to efficiently serialize objects into the wire protocol.\n */\npublic abstract class Value {\n\t/**\n\t * Null value.\n\t */\n\tpublic static final Value NULL = NullValue.INSTANCE;\n\n\t/**\n\t * Infinity value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value INFINITY = new InfinityValue();\n\n\t/**\n\t * Wildcard value to be used in CDT range comparisons only.\n\t */\n\tpublic static final Value WILDCARD = new WildcardValue();\n\n\t/**\n\t * Get string or null value instance.\n\t */\n\tpublic static Value get(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new StringValue(value);\n\t}\n\n\t/**\n\t * Get byte array or null value instance.\n\t */\n\tpublic static Value get(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value);\n\t}\n\n\t/**\n\t * Get byte array with type or null value instance.\n\t */\n\tpublic static Value get(byte[] value, int type) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BytesValue(value, type);\n\t}\n\n\t/**\n\t * Get byte segment or null value instance.\n\t */\n\tpublic static Value get(byte[] value, int offset, int length) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ByteSegmentValue(value, offset, length);\n\t}\n\n\t/**\n\t * Get byte segment or null value instance.\n\t */\n\tpublic static Value get(ByteBuffer bb) {\n\t\treturn (bb == null)? NullValue.INSTANCE : new BytesValue(bb.array());\n\t}\n\n\t/**\n\t * Get byte value instance.\n\t */\n\tpublic static Value get(byte value) {\n\t\treturn new ByteValue(value);\n\t}\n\n\t/**\n\t * Get integer value instance.\n\t */\n\tpublic static Value get(int value) {\n\t\treturn new IntegerValue(value);\n\t}\n\n\t/**\n\t * Get long value instance.\n\t */\n\tpublic static Value get(long value) {\n\t\treturn new LongValue(value);\n\t}\n\n\t/**\n\t * Get double value instance.\n\t */\n\tpublic static Value get(double value) {\n\t\treturn new DoubleValue(value);\n\t}\n\n\t/**\n\t * Get float value instance.\n\t */\n\tpublic static Value get(float value) {\n\t\treturn new FloatValue(value);\n\t}\n\n\t/**\n\t * Get boolean value instance.\n\t */\n\tpublic static Value get(boolean value) {\n\t\treturn new BooleanValue(value);\n\t}\n\n\t/**\n\t * Get list or null value instance.\n\t */\n\tpublic static Value get(List<?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ListValue(value);\n\t}\n\n\t/**\n\t * Get map or null value instance.\n\t */\n\tpublic static Value get(Map<?,?> value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new MapValue(value);\n\t}\n\n\t/**\n\t * Get sorted map or null value instance.\n\t */\n\tpublic static Value get(List<? extends Entry<?,?>> value, MapOrder mapOrder) {\n\t\treturn (value == null)? NullValue.INSTANCE : new SortedMapValue(value, mapOrder);\n\t}\n\n\t/**\n\t * Get value array instance.\n\t */\n\tpublic static Value get(Value[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new ValueArray(value);\n\t}\n\n\t/**\n\t * Get blob or null value instance.\n\t */\n\tpublic static Value getAsBlob(Object value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new BlobValue(value);\n\t}\n\n\t/**\n\t * Get GeoJSON or null value instance.\n\t */\n\tpublic static Value getAsGeoJSON(String value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new GeoJSONValue(value);\n\t}\n\n\t/**\n\t * Get HyperLogLog or null value instance.\n\t */\n\tpublic static Value getAsHLL(byte[] value) {\n\t\treturn (value == null)? NullValue.INSTANCE : new HLLValue(value);\n\t}\n\n\t/**\n\t * Get null value instance.\n\t */\n\tpublic static Value getAsNull() {\n\t\treturn NullValue.INSTANCE;\n\t}\n\n\t/**\n\t * Determine value given generic object.\n\t * This is the slowest of the Value get() methods.\n\t * Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value get(Object value) {\n\t\tif (value == null) {\n\t\t\treturn NullValue.INSTANCE;\n\t\t}\n\n\t\tif (value instanceof Value) {\n\t\t\treturn (Value)value;\n\t\t}\n\n\t\tif (value instanceof byte[]) {\n        \treturn new BytesValue((byte[])value);\n\t\t}\n\n\t\tif (value instanceof String) {\n        \treturn new StringValue((String)value);\n\t\t}\n\n\t\tif (value instanceof Integer) {\n        \treturn new IntegerValue((Integer)value);\n\t\t}\n\n\t\tif (value instanceof Long) {\n        \treturn new LongValue((Long)value);\n\t\t}\n\n\t\tif (value instanceof Double) {\n        \treturn new DoubleValue((Double)value);\n\t\t}\n\n\t\tif (value instanceof Float) {\n        \treturn new FloatValue((Float)value);\n\t\t}\n\n\t\tif (value instanceof Boolean) {\n        \treturn new BooleanValue((Boolean)value);\n\t\t}\n\n\t\tif (value instanceof Byte) {\n        \treturn new ByteValue((byte)value);\n\t\t}\n\n\t\tif (value instanceof List<?>) {\n        \treturn new ListValue((List<?>)value);\n\t\t}\n\n\t\tif (value instanceof Map<?,?>) {\n        \treturn new MapValue((Map<?,?>)value);\n\t\t}\n\n\t\tif (value instanceof ByteBuffer) {\n\t\t\tByteBuffer bb = (ByteBuffer)value;\n        \treturn new BytesValue(bb.array());\n\t\t}\n\n\t\treturn new BlobValue(value);\n\t}\n\n\t/**\n\t * Get value from Record object. Useful when copying records from one cluster to another.\n\t */\n\tpublic static Value getFromRecordObject(Object value) {\n\t\treturn Value.get(value);\n\t}\n\n\t/**\n\t * Calculate number of bytes necessary to serialize the value in the wire protocol.\n\t */\n\tpublic abstract int estimateSize() throws AerospikeException;\n\n\t/**\n\t * Serialize the value in the wire protocol.\n\t */\n\tpublic abstract int write(byte[] buffer, int offset) throws AerospikeException;\n\n\t/**\n\t * Serialize the value using MessagePack.\n\t */\n\tpublic abstract void pack(Packer packer);\n\n\t/**\n\t * Validate if value type can be used as a key.\n\t * @throws AerospikeException\tif type can't be used as a key.\n\t */\n\tpublic void validateKeyType() throws AerospikeException {\n\t}\n\n\t/**\n\t * Get wire protocol value type.\n\t */\n\tpublic abstract int getType();\n\n\t/**\n\t * Return original value as an Object.\n\t */\n\tpublic abstract Object getObject();\n\n\t/**\n\t * Return value as an Object.\n\t */\n\tpublic abstract LuaValue getLuaValue(LuaInstance instance);\n\n\t/**\n\t * Return value as an integer.\n\t */\n\tpublic int toInteger() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Return value as a long.\n\t */\n\tpublic long toLong() {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Empty value.\n\t */\n\tpublic static final class NullValue extends Value {\n\t\tpublic static final NullValue INSTANCE = new NullValue();\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packNil();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: null\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.NULL;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaNil.NIL;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other == null) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.getClass().equals(other.getClass());\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Byte array value.\n\t */\n\tpublic static final class BytesValue extends Value {\n\t\tprivate final byte[] bytes;\n\t\tprivate final int type;\n\n\t\tpublic BytesValue(byte[] bytes) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.type = ParticleType.BLOB;\n\t\t}\n\n\t\tpublic BytesValue(byte[] bytes, int type) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.type = type;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes, type);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn new LuaBytes(instance, bytes, type);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.bytes, ((BytesValue)other).bytes));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * Byte segment value.\n\t */\n\tpublic static final class ByteSegmentValue extends Value {\n\t\tprivate final byte[] bytes;\n\t\tprivate final int offset;\n\t\tprivate final int length;\n\n\t\tpublic ByteSegmentValue(byte[] bytes, int offset, int length) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.offset = offset;\n\t\t\tthis.length = length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn length;\n\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int targetOffset) {\n\t\t\tSystem.arraycopy(bytes, offset, buffer, targetOffset, length);\n\t\t\treturn length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.BLOB;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (! this.getClass().equals(obj.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tByteSegmentValue other = (ByteSegmentValue)obj;\n\n\t\t\tif (this.length != other.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tif (this.bytes[this.offset + i] != other.bytes[other.offset + i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        int result = 1;\n\t        for (int i = 0; i < length; i++) {\n\t            result = 31 * result + bytes[offset+i];\n\t        }\n\t        return result;\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\tpublic int getOffset() {\n\t\t\treturn offset;\n\t\t}\n\n\t\tpublic int getLength() {\n\t\t\treturn length;\n\t\t}\n\t}\n\n\t/**\n\t * Byte value.\n\t */\n\tpublic static final class ByteValue extends Value {\n\t\tprivate final byte value;\n\n\t\tpublic ByteValue(byte value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packByte(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\t// The server does not natively handle one byte, so store as long (8 byte integer).\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Byte.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((ByteValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * String value.\n\t */\n\tpublic static final class StringValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic StringValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn Buffer.stringToUtf8(value, buffer, offset);\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.STRING;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value.equals(((StringValue)other).value));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Integer value.\n\t */\n\tpublic static final class IntegerValue extends Value {\n\t\tprivate final int value;\n\n\t\tpublic IntegerValue(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packInt(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Integer.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((IntegerValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Long value.\n\t */\n\tpublic static final class LongValue extends Value {\n\t\tprivate final long value;\n\n\t\tpublic LongValue(long value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packLong(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaInteger.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Long.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((LongValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return (int)(value ^ (value >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Double value.\n\t */\n\tpublic static final class DoubleValue extends Value {\n\t\tprivate final double value;\n\n\t\tpublic DoubleValue(double value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.doubleToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packDouble(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.DOUBLE;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaDouble.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Double.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((DoubleValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        long bits = Double.doubleToLongBits(value);\n\t        return (int)(bits ^ (bits >>> 32));\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn (long)value;\n\t\t}\n\t}\n\n\t/**\n\t * Float value.\n\t */\n\tpublic static final class FloatValue extends Value {\n\t\tprivate final float value;\n\n\t\tpublic FloatValue(float value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.doubleToBytes(value, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packFloat(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.DOUBLE;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaDouble.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Float.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((FloatValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return Float.floatToIntBits(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn (int)value;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn (long)value;\n\t\t}\n\t}\n\n\t/**\n\t * Boolean value.\n\t */\n\tpublic static final class BooleanValue extends Value {\n\t\tprivate final boolean value;\n\n\t\tpublic BooleanValue(boolean value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tBuffer.longToBytes(value? 1L : 0L, buffer, offset);\n\t\t\treturn 8;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBoolean(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\t// The server does not natively handle boolean, so store as long (8 byte integer).\n\t\t\treturn ParticleType.INTEGER;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaBoolean.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Boolean.toString(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value == ((BooleanValue)other).value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value ? 1231 : 1237;\n\t\t}\n\n\t\t@Override\n\t\tpublic int toInteger() {\n\t\t\treturn value? 1 : 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic long toLong() {\n\t\t\treturn value? 1L : 0L;\n\t\t}\n\t}\n\n\t/**\n\t * Blob value.\n\t */\n\tpublic static final class BlobValue extends Value {\n\t\tprivate final Object object;\n\t\tprivate byte[] bytes;\n\n\t\tpublic BlobValue(Object object) {\n\t\t\tthis.object = object;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException.Serialize {\n\t\t\tthrow new AerospikeException(ResultCode.SERIALIZE_ERROR, \"Object serializer has been disabled\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBlob(object);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: jblob\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.JBLOB;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn object;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.object.equals(((BlobValue)other).object));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return object.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * GeoJSON value.\n\t */\n\tpublic static final class GeoJSONValue extends Value {\n\t\tprivate final String value;\n\n\t\tpublic GeoJSONValue(String value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\t// flags + ncells + jsonstr\n\t\t\treturn 1 + 2 + Buffer.estimateSizeUtf8(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tbuffer[offset] = 0; // flags\n\t\t\tBuffer.shortToBytes(0, buffer, offset + 1); // ncells\n\t\t\treturn 1 + 2 + Buffer.stringToUtf8(value, buffer, offset + 3); // jsonstr\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packGeoJSON(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: GeoJson\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.GEOJSON;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn LuaString.valueOf(value);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.value.equals(((GeoJSONValue)other).value));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return value.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * HyperLogLog value.\n\t */\n\tpublic static final class HLLValue extends Value {\n\t\tprivate final byte[] bytes;\n\n\t\tpublic HLLValue(byte[] bytes) {\n\t\t\tthis.bytes = bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packBytes(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: HLL\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.HLL;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\treturn bytes;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn new LuaBytes(instance, bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Buffer.bytesToHexString(bytes);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.bytes, ((HLLValue)other).bytes));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(bytes);\n\t\t}\n\t}\n\n\t/**\n\t * Value array.\n\t */\n\tpublic static final class ValueArray extends Value {\n\t\tprivate final Value[] array;\n\t\tprivate byte[] bytes;\n\n\t\tpublic ValueArray(Value[] array) {\n\t\t\tthis.array = array;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(array);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packValueArray(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: value[]\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.LIST;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn array;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(array);\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tArrays.equals(this.array, ((ValueArray)other).array));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(array);\n\t\t}\n\t}\n\n\t/**\n\t * List value.\n\t */\n\tpublic static final class ListValue extends Value {\n\t\tprivate final List<?> list;\n\t\tprivate byte[] bytes;\n\n\t\tpublic ListValue(List<?> list) {\n\t\t\tthis.list = list;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(list);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: list\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.LIST;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn list.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.list.equals(((ListValue)other).list));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return list.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Map value.\n\t */\n\tpublic static final class MapValue extends Value {\n\t\tprivate final Map<?,?> map;\n\t\tprivate byte[] bytes;\n\n\t\tpublic MapValue(Map<?,?> map)  {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(map);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packMap(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: map\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.MAP;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn map;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaMap(map);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn map.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\tthis.getClass().equals(other.getClass()) &&\n\t\t\t\tthis.map.equals(((MapValue)other).map));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return map.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Sorted map value.\n\t */\n\tpublic static final class SortedMapValue extends Value {\n\t\tprivate final List<? extends Entry<?,?>> list;\n\t\tprivate byte[] bytes;\n\t\tprivate final MapOrder order;\n\n\t\tpublic SortedMapValue(List<? extends Entry<?,?>> list, MapOrder order)  {\n\t\t\tthis.list = list;\n\t\t\tthis.order = order;\n\t\t}\n\n\t\t@Override\n\t\tpublic int estimateSize() throws AerospikeException {\n\t\t\tbytes = Packer.pack(list, order);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\tSystem.arraycopy(bytes, 0, buffer, offset, bytes.length);\n\t\t\treturn bytes.length;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packMap(list, order);\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: map\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\treturn ParticleType.MAP;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn list;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\treturn instance.getLuaList(list);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn list.toString();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (other == null || ! this.getClass().equals(other.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSortedMapValue o = (SortedMapValue)other;\n\t\t\treturn this.order == o.order && this.list.equals(o.list);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t        return list.hashCode();\n\t\t}\n\t}\n\n\t/**\n\t * Infinity value.\n\t */\n\tpublic static final class InfinityValue extends Value {\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packInfinity();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid particle type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid lua type: INF\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"INF\";\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\t\tthis.getClass().equals(other.getClass()));\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Wildcard value.\n\t */\n\tpublic static final class WildcardValue extends Value {\n\t\t@Override\n\t\tpublic int estimateSize() {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int write(byte[] buffer, int offset) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic void pack(Packer packer) {\n\t\t\tpacker.packWildcard();\n\t\t}\n\n\t\t@Override\n\t\tpublic void validateKeyType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid key type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic int getType() {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid particle type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getObject() {\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic LuaValue getLuaValue(LuaInstance instance) {\n\t\t\tthrow new AerospikeException(ResultCode.PARAMETER_ERROR, \"Invalid lua type: wildcard\");\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"*\";\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\treturn (other != null &&\n\t\t\t\t\tthis.getClass().equals(other.getClass()));\n\t\t}\n\n\t\t@Override\n\t\tpublic final int hashCode() {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.command;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.ResultCode;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.util.Unpacker;\n\npublic final class Buffer {\n\n\tpublic static Value bytesToKeyValue(int type, byte[] buf, int offset, int len)\n\t\tthrows AerospikeException {\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\treturn Value.get(Buffer.utf8ToString(buf, offset, len));\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn bytesToLongValue(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn new Value.DoubleValue(Buffer.bytesToDouble(buf, offset));\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Value.get(Arrays.copyOfRange(buf, offset, offset+len));\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic static Object bytesToParticle(int type, byte[] buf, int offset, int len)\n\t\tthrows AerospikeException {\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\treturn Buffer.utf8ToString(buf, offset, len);\n\n\t\tcase ParticleType.INTEGER:\n\t\t\treturn Buffer.bytesToNumber(buf, offset, len);\n\n\t\tcase ParticleType.DOUBLE:\n\t\t\treturn Buffer.bytesToDouble(buf, offset);\n\n\t\tcase ParticleType.BLOB:\n\t\t\treturn Arrays.copyOfRange(buf, offset, offset+len);\n\n\t\tcase ParticleType.JBLOB:\n\t\t\treturn Buffer.bytesToObject(buf, offset, len);\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\treturn Buffer.bytesToGeoJSON(buf, offset, len);\n\n\t\tcase ParticleType.HLL:\n\t\t\treturn Buffer.bytesToHLL(buf, offset, len);\n\n\t\tcase ParticleType.LIST:\n\t\t\treturn Unpacker.unpackObjectList(buf, offset, len);\n\n\t\tcase ParticleType.MAP:\n\t\t\treturn Unpacker.unpackObjectMap(buf, offset, len);\n\n\t\tdefault:\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*\n\tprivate static Object parseList(byte[] buf, int offset, int len) throws AerospikeException {\n\t\tint limit = offset + len;\n\t\tint itemCount = Buffer.bytesToInt(buf, offset);\n\t\toffset += 4;\n\t\tArrayList<Object> list = new ArrayList<Object>(itemCount);\n\n\t\twhile (offset < limit) {\n\t\t\tint sz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\tint type = buf[offset];\n\t\t\toffset++;\n\t\t\tlist.add(bytesToParticle(type, buf, offset, sz));\n\t\t\toffset += sz;\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate static Object parseMap(byte[] buf, int offset, int len) throws AerospikeException {\n\t\tObject key;\n\t\tObject value;\n\n\t\tint limit = offset + len;\n\t\tint n_items = Buffer.bytesToInt(buf, offset);\n\t\toffset += 4;\n\t\tHashMap<Object, Object> map = new HashMap<Object, Object>(n_items);\n\n\t\twhile (offset < limit) {\n\t\t\t// read out the key\n\t\t\tint sz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\tint type = buf[offset];\n\t\t\toffset++;\n\n\t\t\tkey = bytesToParticle(type, buf, offset, len);\n\t\t\toffset += sz;\n\n\t\t\t// read out the value\n\t\t\tsz = Buffer.bytesToInt(buf, offset);\n\t\t\toffset += 4;\n\t\t\ttype = buf[offset];\n\t\t\toffset++;\n\n\t\t\tvalue = bytesToParticle(type, buf, offset, len);\n\t\t\toffset += sz;\n\n\t\t\tmap.put(key, value);\n\t\t}\n\t\treturn map;\n\t}\n\t*/\n\n\t/**\n\t * Estimate size of Utf8 encoded bytes without performing the actual encoding.\n\t */\n\tpublic static int estimateSizeUtf8(String value) {\n\t\tif (value == null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tint max = value.length();\n\t\tint count = 0;\n\n\t\tfor (int i = 0; i < max; i++) {\n\t\t\tchar ch = value.charAt(i);\n\n\t\t\tif (ch < 0x80) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse if (ch < 0x800) {\n\t\t\t    count += 2;\n\t\t\t}\n\t\t\telse if (Character.isHighSurrogate(ch)) {\n\t\t\t\tcount += 4;\n\t\t\t\t++i;\n\t\t\t} else {\n\t\t\t\tcount += 3;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n    public static byte[] stringToUtf8(String s) {\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn new byte[0];\n\t\t}\n\t\tint size = estimateSizeUtf8(s);\n\t\tbyte[] bytes = new byte[size];\n\t\tstringToUtf8(s, bytes, 0);\n\t\treturn bytes;\n    }\n\n\t/**\n\t * Convert input string to UTF-8, copies into buffer (at given offset).\n\t * Returns number of bytes in the string.\n\t *\n     * Java's internal UTF8 conversion is very, very slow.\n     * This is, rather amazingly, 8x faster than the to-string method.\n\t * Returns the number of bytes this translated into.\n     */\n    public static int stringToUtf8(String s, byte[] buf, int offset) {\n        if (s == null) {\n        \treturn 0;\n        }\n    \tint length = s.length();\n        int startOffset = offset;\n\n        for (int i = 0; i < length; i++) {\n            int c = s.charAt(i);\n            if (c < 0x80) {\n                buf[offset++] = (byte) c;\n            }\n            else if (c < 0x800) {\n            \tbuf[offset++] = (byte)(0xc0 | ((c >> 6)));\n            \tbuf[offset++] = (byte)(0x80 | (c & 0x3f));\n            }\n            else {\n\t\t    \t// Encountered a different encoding other than 2-byte UTF8. Let java handle it.\n            \ttry {\n\t\t    \t\tbyte[] value = s.getBytes(\"UTF8\");\n\t\t\t\t\tSystem.arraycopy(value, 0, buf, startOffset, value.length);\n\t\t\t\t\treturn value.length;\n            \t}\n            \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 encoding is not supported.\");\n            \t}\n            }\n        }\n        return offset - startOffset;\n    }\n\n    public static String utf8ToString(byte[] buf, int offset, int length) {\n    \t// A Thread local implementation does not help here, so\n    \t// allocate character buffer each time.\n    \tif (length == 0) {\n    \t\treturn \"\";\n    \t}\n\n\t\tchar[] charBuffer = new char[length];\n    \tint charCount = 0;\n        int limit = offset + length;\n    \tint origoffset = offset;\n\n        while (offset < limit ) {\n        \tint b1 = buf[offset];\n\n        \tif (b1 >= 0) {\n                charBuffer[charCount++] = (char)b1;\n                offset++;\n        \t}\n        \telse if ((b1 >> 5) == -2) {\n        \t\tint b2 = buf[offset + 1];\n        \t\tcharBuffer[charCount++] = (char) (((b1 << 6) ^ b2) ^ 0x0f80);\n                offset += 2;\n        \t}\n\t\t    else {\n\t\t    \t// Encountered an UTF encoding which uses more than 2 bytes.\n\t\t    \t// Use a native function to do the conversion.\n\t\t    \ttry {\n\t\t    \t\treturn new String(buf, origoffset, length, \"UTF8\");\n\t\t    \t}\n\t\t    \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 decoding is not supported.\");\n\t\t    \t}\n\t\t    }\n        }\n        return new String(charBuffer, 0, charCount);\n    }\n\n    public static String utf8ToString(byte[] buf, int offset, int length, StringBuilder sb) {\n    \tif (length == 0) {\n    \t\treturn \"\";\n    \t}\n\n    \t// This method is designed to accommodate multiple string conversions on the same\n    \t// thread, but without the ThreadLocal overhead.  The StringBuilder instance is\n    \t// created on the stack and passed in each method invocation.\n    \tsb.setLength(0);\n        int limit = offset + length;\n    \tint origoffset = offset;\n\n        while (offset < limit ) {\n            if ((buf[offset] & 0x80) == 0) { // 1 byte\n                char c = (char) buf[offset];\n                sb.append(c);\n                offset++;\n            }\n            else if ((buf[offset] & 0xE0) == 0xC0) { // 2 bytes\n                char c =  (char) (((buf[offset] & 0x1f) << 6) | (buf[offset+1] & 0x3f));\n                sb.append(c);\n                offset += 2;\n            }\n\t\t    else {\n\t\t    \t// Encountered an UTF encoding which uses more than 2 bytes.\n\t\t    \t// Use a native function to do the conversion.\n\t\t    \ttry {\n\t\t    \t\treturn new String(buf, origoffset, length, \"UTF8\");\n\t\t    \t}\n\t\t    \tcatch (UnsupportedEncodingException uee) {\n            \t\tthrow new RuntimeException(\"UTF8 decoding is not supported.\");\n\t\t    \t}\n\t\t    }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Convert UTF8 numeric digits to an integer.  Negative integers are not supported.\n     *\n     * Input format: 1234\n     */\n    public static int utf8DigitsToInt(byte[] buf, int begin, int end) {\n    \tint val = 0;\n    \tint mult = 1;\n\n    \tfor (int i = end - 1; i >= begin; i--) {\n    \t\tval += ((int)buf[i] - 48) * mult;\n    \t\tmult *= 10;\n    \t}\n    \treturn val;\n    }\n\n    public static String bytesToHexString(byte[] buf) {\n    \tif (buf == null || buf.length == 0) {\n    \t\treturn \"\";\n    \t}\n\t\tStringBuilder sb = new StringBuilder(buf.length * 2);\n\n\t\tfor (int i = 0; i < buf.length; i++) {\n    \t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n    }\n\n    public static String bytesToHexString(byte[] buf, int offset, int length) {\n\t\tStringBuilder sb = new StringBuilder(length * 2);\n\n\t\tfor (int i = offset; i < length; i++) {\n    \t\tsb.append(String.format(\"%02x\", buf[i]));\n\t\t}\n\t\treturn sb.toString();\n    }\n\n    public static Object bytesToObject(byte[] buf, int offset, int length)\n\t\tthrows AerospikeException.Serialize {\n\n    \tif (length <= 0) {\n    \t\treturn null;\n    \t}\n\n\t\tthrow new AerospikeException(ResultCode.SERIALIZE_ERROR, \"Object deserializer has been disabled\");\n\t}\n\n\tpublic static Value bytesToLongValue(byte[] buf, int offset, int len) {\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\n\t\treturn new Value.LongValue(val);\n\t}\n\n\tpublic static Object bytesToGeoJSON(byte[] buf, int offset, int len) {\n\t\t// Ignore the flags for now\n\t\tint ncells = bytesToShort(buf, offset + 1);\n\t\tint hdrsz = 1 + 2 + (ncells * 8);\n\t\treturn Value.getAsGeoJSON(Buffer.utf8ToString(buf, offset + hdrsz, len - hdrsz));\n\t}\n\n\tpublic static Object bytesToHLL(byte[] buf, int offset, int len) {\n\t\tbyte[] bytes = Arrays.copyOfRange(buf, offset, offset+len);\n\t\treturn Value.getAsHLL(bytes);\n\t}\n\n\tpublic static Object bytesToNumber(byte[] buf, int offset, int len) {\n\t\t// Server always returns 8 for integer length.\n\t\tif (len == 8) {\n\t\t\treturn bytesToLong(buf, offset);\n\t\t}\n\n\t\t// Handle other lengths just in case server changes.\n\t\tif (len == 0) {\n\t\t\treturn new Long(0);\n\t\t}\n\n\t\tif (len == 4) {\n\t\t\treturn new Long(bytesToInt(buf, offset));\n\t\t}\n\n\t\tif (len > 8) {\n\t\t\treturn bytesToBigInteger(buf, offset, len);\n\t\t}\n\n\t\t// Handle variable length integer.\n\t\tlong val = 0;\n\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tval <<= 8;\n\t\t\tval |= buf[offset+i] & 0xFF;\n\t\t}\n\t\treturn new Long(val);\n\t}\n\n\tpublic static Object bytesToBigInteger(byte[] buf, int offset, int len) {\n\t\tboolean negative = false;\n\n\t\tif ((buf[offset] & 0x80) != 0) {\n\t\t\tnegative = true;\n\t\t\tbuf[offset] &= 0x7f;\n\t\t}\n\t\tbyte[] bytes = new byte[len];\n\t\tSystem.arraycopy(buf, offset, bytes, 0, len);\n\n\t\tBigInteger big = new BigInteger(bytes);\n\n\t\tif (negative) {\n\t\t\tbig = big.negate();\n\t\t}\n\t\treturn big;\n\t}\n\n\t//-------------------------------------------------------\n\t// 64 bit double conversions.\n\t//-------------------------------------------------------\n\n\tpublic static double bytesToDouble(byte[] buf, int offset) {\n\t\treturn Double.longBitsToDouble(bytesToLong(buf, offset));\n\t}\n\n\tpublic static void doubleToBytes(double v, byte[] buf, int offset) {\n\t\tBuffer.longToBytes(Double.doubleToLongBits(v), buf, offset);\n\t}\n\n\t//-------------------------------------------------------\n\t// 64 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert long to big endian signed or unsigned 64 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void longToBytes(long v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 56);\n\t\tbuf[offset++] = (byte)(v >>> 48);\n\t\tbuf[offset++] = (byte)(v >>> 40);\n\t\tbuf[offset++] = (byte)(v >>> 32);\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>>  8);\n\t\tbuf[offset]   = (byte)(v >>>  0);\n\t}\n\n    /**\n     * Convert long to little endian signed or unsigned 64 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void longToLittleBytes(long v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 0);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 32);\n\t\tbuf[offset++] = (byte)(v >>> 40);\n\t\tbuf[offset++] = (byte)(v >>> 48);\n\t\tbuf[offset]   = (byte)(v >>> 56);\n\t}\n\n    /**\n     * Convert big endian signed 64 bits to long.\n     */\n\tpublic static long bytesToLong(byte[] buf, int offset) {\n       return (\n    \t\t((long)(buf[offset]   & 0xFF) << 56) |\n   \t\t\t((long)(buf[offset+1] & 0xFF) << 48) |\n   \t\t\t((long)(buf[offset+2] & 0xFF) << 40) |\n   \t\t\t((long)(buf[offset+3] & 0xFF) << 32) |\n   \t\t\t((long)(buf[offset+4] & 0xFF) << 24) |\n   \t\t\t((long)(buf[offset+5] & 0xFF) << 16) |\n   \t\t\t((long)(buf[offset+6] & 0xFF) << 8) |\n   \t\t\t((long)(buf[offset+7] & 0xFF) << 0)\n   \t\t\t);\n    }\n\n    /**\n     * Convert little endian signed 64 bits to long.\n     */\n    public static long littleBytesToLong(byte[] buf, int offset) {\n        return (\n\t\t\t((long)(buf[offset]   & 0xFF) << 0) |\n\t\t\t((long)(buf[offset+1] & 0xFF) << 8) |\n\t\t\t((long)(buf[offset+2] & 0xFF) << 16) |\n\t\t\t((long)(buf[offset+3] & 0xFF) << 24) |\n\t\t\t((long)(buf[offset+4] & 0xFF) << 32) |\n\t\t\t((long)(buf[offset+5] & 0xFF) << 40) |\n\t\t\t((long)(buf[offset+6] & 0xFF) << 48) |\n\t\t\t((long)(buf[offset+7] & 0xFF) << 56)\n\t\t\t);\n    }\n\n\t//-------------------------------------------------------\n\t// 32 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert int to big endian signed or unsigned 32 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void intToBytes(int v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 24);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset]   = (byte)(v >>> 0);\n\t}\n\n    /**\n     * Convert int to little endian signed or unsigned 32 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n\tpublic static void intToLittleBytes(int v, byte[] buf, int offset) {\n\t\tbuf[offset++] = (byte)(v >>> 0);\n\t\tbuf[offset++] = (byte)(v >>> 8);\n\t\tbuf[offset++] = (byte)(v >>> 16);\n\t\tbuf[offset]   = (byte)(v >>> 24);\n\t}\n\n    /**\n     * Convert big endian signed 32 bits to int.\n     */\n\tpublic static int bytesToInt(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((buf[offset]   & 0xFF) << 24) |\n\t\t\t((buf[offset+1] & 0xFF) << 16) |\n\t\t\t((buf[offset+2] & 0xFF) << 8) |\n\t\t\t((buf[offset+3] & 0xFF) << 0)\n\t\t\t);\n\t}\n\n    /**\n     * Convert little endian signed 32 bits to int.\n     */\n\tpublic static int littleBytesToInt(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((buf[offset]   & 0xFF) << 0) |\n\t\t\t((buf[offset+1] & 0xFF) << 8) |\n\t\t\t((buf[offset+2] & 0xFF) << 16) |\n\t\t\t((buf[offset+3] & 0xFF) << 24)\n\t\t\t);\n\t}\n\n    /**\n     * Convert big endian unsigned 32 bits to long.\n     */\n\tpublic static long bigUnsigned32ToLong(byte[] buf, int offset) {\n\t\treturn (\n\t\t\t((long)(buf[offset]   & 0xFF) << 24) |\n\t\t\t((long)(buf[offset+1] & 0xFF) << 16) |\n\t\t\t((long)(buf[offset+2] & 0xFF) << 8) |\n\t\t\t((long)(buf[offset+3] & 0xFF) << 0)\n\t\t\t);\n\t}\n\n\t//-------------------------------------------------------\n\t// 16 bit number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     * Convert int to big endian signed or unsigned 16 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n    public static void shortToBytes(int v, byte[] buf, int offset) {\n        buf[offset++] = (byte)(v >>> 8);\n        buf[offset]   = (byte)(v >>> 0);\n    }\n\n    /**\n     * Convert int to little endian signed or unsigned 16 bits.\n     * The bit pattern will be the same regardless of sign.\n     */\n    public static void shortToLittleBytes(int v, byte[] buf, int offset) {\n        buf[offset++] = (byte)(v >>> 0);\n        buf[offset]   = (byte)(v >>> 8);\n    }\n\n    /**\n     * Convert big endian unsigned 16 bits to int.\n     */\n    public static int bytesToShort(byte[] buf, int offset) {\n        return (\n\t\t\t((buf[offset]   & 0xFF) << 8) |\n\t\t\t((buf[offset+1] & 0xFF) << 0)\n        \t);\n    }\n\n    /**\n     * Convert little endian unsigned 16 bits to int.\n     */\n    public static int littleBytesToShort(byte[] buf, int offset) {\n        return (\n\t\t\t((buf[offset]   & 0xFF) << 0) |\n\t\t\t((buf[offset+1] & 0xFF) << 8)\n\t\t\t);\n    }\n\n    /**\n     * Convert big endian signed 16 bits to short.\n     */\n    public static short bigSigned16ToShort(byte[] buf, int offset) {\n        return (short)(\n\t\t\t((buf[offset]   & 0xFF) << 8) |\n\t\t\t((buf[offset+1] & 0xFF) << 0)\n        \t);\n    }\n\n    //-------------------------------------------------------\n\t// Variable byte number conversions.\n\t//-------------------------------------------------------\n\n    /**\n     *\tEncode an integer in variable 7-bit format.\n     *\tThe high bit indicates if more bytes are used.\n     *  Return byte size of integer.\n     */\n    public static int intToVarBytes(int v, byte[] buf, int offset) {\n    \tint i = offset;\n\n    \twhile (i < buf.length && v >= 0x80) {\n    \t\tbuf[i++] = (byte)(v | 0x80);\n    \t\tv >>>= 7;\n    \t}\n\n    \tif (i < buf.length) {\n    \t\tbuf[i++] = (byte)v;\n    \t\treturn i - offset;\n    \t}\n    \treturn 0;\n    }\n\n    /**\n     *\tDecode an integer in variable 7-bit format.\n     *\tThe high bit indicates if more bytes are used.\n     *  Return value and byte size in array.\n     */\n    public static int[] varBytesToInt(byte[] buf, int offset) {\n\t\tint i = offset;\n\t\tint val = 0;\n\t\tint shift = 0;\n\t\tbyte b;\n\n\t\tdo {\n\t\t\tb = buf[i++];\n\t\t\tval |= (b & 0x7F) << shift;\n\t\t\tshift += 7;\n\t\t} while ((b & 0x80) != 0);\n\n\t\treturn new int[] {val, i - offset};\n    }\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.ResultCode;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.cdt.MapOrder;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * Serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic final class Packer {\n\n\tpublic static byte[] pack(Value[] val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packValueArray(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(List<?> val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packList(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(Map<?,?> val) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packMap(val);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static byte[] pack(List<? extends Entry<?,?>> val, MapOrder order) throws AerospikeException {\n\t\ttry {\n\t\t\tPacker packer = new Packer();\n\t\t\tpacker.packMap(val, order);\n\t\t\treturn packer.toByteArray();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate byte[] buffer;\n\tprivate int offset;\n\tprivate ArrayList<BufferItem> bufferList;\n\n\tpublic Packer() {\n\t\tthis.buffer = ThreadLocalData.getBuffer();\n\t}\n\n\tpublic void packValueArray(Value[] values) {\n\t\tpackArrayBegin(values.length);\n\t\tfor (Value value : values) {\n\t\t\tvalue.pack(this);\n\t\t}\n\t}\n\n\tpublic void packValueList(List<Value> list) {\n\t\tpackArrayBegin(list.size());\n\t\tfor (Value value : list) {\n\t\t\tvalue.pack(this);\n\t\t}\n\t}\n\n\tpublic void packList(List<?> list) {\n\t\tpackArrayBegin(list.size());\n\t\tfor (Object obj : list) {\n\t\t\tpackObject(obj);\n\t\t}\n\t}\n\n\tpublic void packArrayBegin(int size) {\n        if (size < 16) {\n        \tpackByte(0x90 | size);\n        }\n        else if (size < 65536) {\n        \tpackShort(0xdc, size);\n        }\n        else {\n        \tpackInt(0xdd, size);\n        }\n    }\n\n\tpublic void packValueMap(Map<Value,Value> map) {\n\t\tpackMapBegin(map.size());\n\t\tfor (Entry<Value,Value> entry : map.entrySet()) {\n\t\t\tentry.getKey().pack(this);\n\t\t\tentry.getValue().pack(this);\n\t\t}\n\t}\n\n\tpublic void packMap(Map<?,?> map) {\n\t\tpackMapBegin(map.size());\n\t\tfor (Entry<?,?> entry : map.entrySet()) {\n\t\t\tpackObject(entry.getKey());\n\t\t\tpackObject(entry.getValue());\n\t\t}\n\t}\n\n\tpublic void packMap(List<? extends Entry<?,?>> list, MapOrder order) {\n\t\tint attr = order.attributes;\n\n\t\tif (attr > 0) {\n\t\t\t// Map is sorted.\n\t\t\tpackMapBegin(list.size() + 1);\n\t\t\tpackByte(0xc7);\n\t\t\tpackByte(0);\n\t\t\tpackByte(attr);\n\t\t\tpackByte(0xc0);\n\t\t}\n\t\telse {\n\t\t\tpackMapBegin(list.size());\n\t\t}\n\n\t\tfor (Entry<?,?> entry : list) {\n\t\t\tpackObject(entry.getKey());\n\t\t\tpackObject(entry.getValue());\n\t\t}\n\t}\n\n\tpublic void packMapBegin(int size) {\n        if (size < 16) {\n        \tpackByte(0x80 | size);\n        }\n        else if (size < 65536) {\n        \tpackShort(0xde, size);\n        }\n        else {\n        \tpackInt(0xdf, size);\n        }\n    }\n\n\tpublic void packBytes(byte[] b) {\n    \tpackByteArrayBegin(b.length + 1);\n    \tpackByte(ParticleType.BLOB);\n    \tpackByteArray(b, 0, b.length);\n    }\n\n\tpublic void packBytes(byte[] b, int type) {\n    \tpackByteArrayBegin(b.length + 1);\n    \tpackByte(type);\n    \tpackByteArray(b, 0, b.length);\n    }\n\n\tpublic void packBytes(byte[] b, int offset, int length) {\n    \tpackByteArrayBegin(length + 1);\n    \tpackByte(ParticleType.BLOB);\n    \tpackByteArray(b, offset, length);\n\t}\n\n\tpublic void packBlob(Object val) throws AerospikeException {\n\t\tthrow new AerospikeException(ResultCode.SERIALIZE_ERROR, \"Object serializer has been disabled\");\n\t}\n\n\tpublic void packGeoJSON(String val) {\n\t\tbyte[] buffer = Buffer.stringToUtf8(val);\n\t\tpackByteArrayBegin(buffer.length + 1);\n\t\tpackByte(ParticleType.GEOJSON);\n\t\tpackByteArray(buffer, 0, buffer.length);\n\t}\n\n\tprivate void packByteArrayBegin(int size) {\n\t\t// Continue to pack byte arrays as strings until all servers/clients\n\t\t// have been upgraded to handle new message pack binary type.\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xda, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdb, size);\n\t\t}\n\n\t\t// TODO: Replace with this code after all servers/clients\n\t\t// have been upgraded to handle new message pack binary type.\n\t\t/*\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\telse if (size < 256) {\n\t\t\tpackByte(0xc4, size);\n\t\t}\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xc5, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xc6, size);\n\t\t}*/\n\t}\n\n\tpublic void packObject(Object obj) {\n\t\tif (obj == null) {\n\t\t\tpackNil();\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Value) {\n\t\t\tValue value = (Value) obj;\n\t\t\tvalue.pack(this);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof byte[]) {\n\t\t\tpackBytes((byte[]) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof String) {\n\t\t\tpackString((String) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Integer) {\n\t\t\tpackInt((Integer) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Long) {\n\t\t\tpackLong((Long) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Double) {\n\t\t\tpackDouble((Double) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Float) {\n\t\t\tpackFloat((Float) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Boolean) {\n\t\t\tpackBoolean((Boolean)obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof List<?>) {\n\t\t\tpackList((List<?>) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof Map<?,?>) {\n\t\t\tpackMap((Map<?,?>) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tif (obj instanceof ByteBuffer) {\n\t\t\tpackByteBuffer((ByteBuffer) obj);\n\t\t\treturn;\n\t\t}\n\n\t\tpackBlob(obj);\n\t}\n\n\tpublic void packByteBuffer(ByteBuffer bb) {\n\t\tbyte[] b = bb.array();\n\t\tpackBytes(b);\n\t}\n\n\tpublic void packLong(long val) {\n    \tif (val >= 0L) {\n        \tif (val < 128L) {\n        \t\tpackByte((int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 256L) {\n        \t\tpackByte(0xcc, (int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 65536L) {\n        \t\tpackShort(0xcd, (int)val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 4294967296L) {\n        \t\tpackInt(0xce, (int)val);\n        \t\treturn;\n        \t}\n        \tpackLong(0xcf, val);\n    \t}\n    \telse {\n        \tif (val >= -32) {\n        \t\tpackByte(0xe0 | ((int)val + 32));\n        \t\treturn;\n        \t}\n\n        \tif (val >= Byte.MIN_VALUE) {\n                packByte(0xd0, (int)val);\n                return;\n        \t}\n\n        \tif (val >= Short.MIN_VALUE) {\n                packShort(0xd1, (int)val);\n                return;\n        \t}\n\n        \tif (val >= Integer.MIN_VALUE) {\n        \t\tpackInt(0xd2, (int)val);\n                return;\n        \t}\n        \tpackLong(0xd3, val);\n    \t}\n    }\n\n    public void packInt(int val) {\n    \tif (val >= 0) {\n        \tif (val < 128) {\n        \t\tpackByte(val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 256) {\n        \t\tpackByte(0xcc, val);\n        \t\treturn;\n        \t}\n\n        \tif (val < 65536) {\n        \t\tpackShort(0xcd, val);\n        \t\treturn;\n        \t}\n        \tpackInt(0xce, val);\n    \t}\n    \telse {\n        \tif (val >= -32) {\n        \t\tpackByte(0xe0 | (val + 32));\n        \t\treturn;\n        \t}\n\n        \tif (val >= Byte.MIN_VALUE) {\n                packByte(0xd0, val);\n                return;\n        \t}\n\n        \tif (val >= Short.MIN_VALUE) {\n                packShort(0xd1, val);\n                return;\n        \t}\n        \tpackInt(0xd2, val);\n    \t}\n    }\n\n\tpublic void packString(String val) {\n\t\tint size = Buffer.estimateSizeUtf8(val) + 1;\n\n\t\tif (size < 32) {\n\t\t\tpackByte(0xa0 | size);\n\t\t}\n\t\t// TODO: Enable this code after all servers/clients\n\t\t// have been upgraded to handle 8 bit string length format.\n\t\t/*\n\t\telse if (size < 256) {\n\t\t\tpackByte(0xd9, size);\n\t\t}\n\t\t*/\n\t\telse if (size < 65536) {\n\t\t\tpackShort(0xda, size);\n\t\t}\n\t\telse {\n\t\t\tpackInt(0xdb, size);\n\t\t}\n\n\t\tif (offset + size > buffer.length) {\n\t\t\tresize(size);\n\t\t}\n\t\tbuffer[offset++] = (byte)ParticleType.STRING;\n\t\toffset += Buffer.stringToUtf8(val, buffer, offset);\n\t}\n\n\tprivate void packByteArray(byte[] src, int srcOffset, int srcLength) {\n       \tif (offset + srcLength > buffer.length) {\n    \t\tresize(srcLength);\n    \t}\n \t\tSystem.arraycopy(src, srcOffset, buffer, offset, srcLength);\n\t\toffset += srcLength;\n    }\n\n    public void packDouble(double val) {\n    \tif (offset + 9 > buffer.length) {\n    \t\tresize(9);\n    \t}\n    \tbuffer[offset++] = (byte)0xcb;\n    \tBuffer.longToBytes(Double.doubleToLongBits(val), buffer, offset);\n    \toffset += 8;\n    }\n\n    public void packFloat(float val) {\n    \tif (offset + 5 > buffer.length) {\n    \t\tresize(5);\n    \t}\n    \tbuffer[offset++] = (byte)0xca;\n    \tBuffer.intToBytes(Float.floatToIntBits(val), buffer, offset);\n    \toffset += 4;\n    }\n\n    private void packLong(int type, long val) {\n    \tif (offset + 9 > buffer.length) {\n    \t\tresize(9);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.longToBytes(val, buffer, offset);\n    \toffset += 8;\n    }\n\n    private void packInt(int type, int val) {\n    \tif (offset + 5 > buffer.length) {\n    \t\tresize(5);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.intToBytes(val, buffer, offset);\n    \toffset += 4;\n    }\n\n    private void packShort(int type, int val) {\n    \tif (offset + 3 > buffer.length) {\n    \t\tresize(3);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tBuffer.shortToBytes(val, buffer, offset);\n    \toffset += 2;\n    }\n\n    public void packRawShort(int val) {\n    \t// WARNING. This method is not compatible with message pack standard.\n    \tif (offset + 2 > buffer.length) {\n    \t\tresize(2);\n    \t}\n    \tBuffer.shortToBytes(val, buffer, offset);\n    \toffset += 2;\n    }\n\n    private void packByte(int type, int val) {\n    \tif (offset + 2 > buffer.length) {\n    \t\tresize(2);\n    \t}\n    \tbuffer[offset++] = (byte)type;\n    \tbuffer[offset++] = (byte)val;\n    }\n\n    public void packBoolean(boolean val) {\n    \tif (offset + 1 > buffer.length) {\n    \t\tresize(1);\n    \t}\n\n    \tif (val) {\n    \t\tbuffer[offset++] = (byte)0xc3;\n    \t}\n    \telse {\n    \t\tbuffer[offset++] = (byte)0xc2;\n    \t}\n    }\n\n    public void packNil() {\n    \tif (offset >= buffer.length) {\n    \t\tresize(1);\n    \t}\n    \tbuffer[offset++] = (byte)0xc0;\n    }\n\n\tpublic void packInfinity() {\n\t\tif (offset + 3 > buffer.length) {\n\t\t\tresize(3);\n\t\t}\n\t\tbuffer[offset++] = (byte)0xd4;\n\t\tbuffer[offset++] = (byte)0xff;\n\t\tbuffer[offset++] = (byte)0x01;\n\t}\n\n\tpublic void packWildcard() {\n\t\tif (offset + 3 > buffer.length) {\n\t\t\tresize(3);\n\t\t}\n\t\tbuffer[offset++] = (byte)0xd4;\n\t\tbuffer[offset++] = (byte)0xff;\n\t\tbuffer[offset++] = (byte)0x00;\n\t}\n\n\tpublic void packByte(int val) {\n    \tif (offset >= buffer.length) {\n    \t\tresize(1);\n    \t}\n    \tbuffer[offset++] = (byte)val;\n    }\n\n    private void resize(int size) {\n    \tif (bufferList == null) {\n    \t\tbufferList = new ArrayList<BufferItem>();\n    \t}\n    \tbufferList.add(new BufferItem(buffer, offset));\n\n    \tif (size < buffer.length) {\n    \t\tsize = buffer.length;\n    \t}\n    \tbuffer = new byte[size];\n    \toffset = 0;\n    }\n\n    public byte[] toByteArray() {\n    \tif (bufferList != null) {\n        \tint size = offset;\n    \t\tfor (BufferItem item : bufferList) {\n    \t\t\tsize += item.length;\n    \t\t}\n\n    \t\tbyte[] target = new byte[size];\n    \t\tsize = 0;\n    \t\tfor (BufferItem item : bufferList) {\n            \tSystem.arraycopy(item.buffer, 0, target, size, item.length);\n    \t\t\tsize += item.length;\n    \t\t}\n\n    \t\tSystem.arraycopy(buffer, 0, target, size, offset);\n        \treturn target;\n    \t}\n    \telse {\n        \tbyte[] target = new byte[offset];\n        \tSystem.arraycopy(buffer, 0, target, 0, offset);\n        \treturn target;\n    \t}\n\t}\n\n    private static final class BufferItem {\n    \tprivate byte[] buffer;\n    \tprivate int length;\n\n    \tprivate BufferItem(byte[] buffer, int length) {\n    \t\tthis.buffer = buffer;\n    \t\tthis.length = length;\n    \t}\n    }\n}\n", "/*\n * Copyright 2012-2020 Aerospike, Inc.\n *\n * Portions may be licensed to Aerospike, Inc. under one or more contributor\n * license agreements WHICH ARE COMPATIBLE WITH THE APACHE LICENSE, VERSION 2.0.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.aerospike.client.util;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport com.aerospike.client.AerospikeException;\nimport com.aerospike.client.ResultCode;\nimport com.aerospike.client.Value;\nimport com.aerospike.client.command.Buffer;\nimport com.aerospike.client.command.ParticleType;\n\n/**\n * De-serialize collection objects using MessagePack format specification:\n *\n * https://github.com/msgpack/msgpack/blob/master/spec.md\n */\npublic abstract class Unpacker<T> {\n\n\tprivate final byte[] buffer;\n\tprivate int offset;\n\tprivate final int length;\n\n\tpublic Unpacker(byte[] buffer, int offset, int length) {\n\t\tthis.buffer = buffer;\n\t\tthis.offset = offset;\n\t\tthis.length = length;\n\t}\n\n\tpublic final T unpackList() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}\n\n\t\ttry {\n\t\t\tint type = buffer[offset++] & 0xff;\n\t\t\tint count;\n\n\t\t\tif ((type & 0xf0) == 0x90) {\n\t\t\t\tcount = type & 0x0f;\n\t\t\t}\n\t\t\telse if (type == 0xdc) {\n\t\t\t\tcount = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse if (type == 0xdd) {\n\t\t\t\tcount = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn getList(new ArrayList<T>(0));\n\t\t\t}\n\t\t\treturn unpackList(count);\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate T unpackList(int count) throws IOException, ClassNotFoundException {\n\t\tif (count <= 0) {\n\t\t\treturn getList(new ArrayList<T>(0));\n\t\t}\n\n\t\t// Extract first object.\n\t\tint mark = offset;\n\t\tint size = count;\n\t\tT val = unpackObject();\n\n\t\tif (val == null) {\n\t\t\t// Determine if null value is because of an extension type.\n\t\t\tint type = buffer[mark] & 0xff;\n\n\t\t\tif (type != 0xc0) {  // not nil type\n\t\t\t\t// Ignore extension type.\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\n\t\tArrayList<T> out = new ArrayList<T>(size);\n\n\t\tif (size == count) {\n\t\t\tout.add(val);\n\t\t}\n\n\t\tfor (int i = 1; i < count; i++) {\n\t\t\tout.add(unpackObject());\n\t\t}\n\t\treturn getList(out);\n\t}\n\n\tpublic final T unpackMap() throws AerospikeException {\n\t\tif (length <= 0) {\n\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t}\n\n\t\ttry {\n\t\t\tint type = buffer[offset++] & 0xff;\n\t\t\tint count;\n\n\t\t\tif ((type & 0xf0) == 0x80) {\n\t\t\t\tcount = type & 0x0f;\n\t\t\t}\n\t\t\telse if (type == 0xde) {\n\t\t\t\tcount = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t}\n\t\t\telse if (type == 0xdf) {\n\t\t\t\tcount = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t\t}\n\t\t\treturn unpackMap(count);\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tprivate T unpackMap(int count) throws IOException, ClassNotFoundException {\n\t\tif (count <= 0) {\n\t\t\treturn getMap(new HashMap<T,T>(0));\n\t\t}\n\n\t\t// Peek at buffer to determine map type, but do not advance.\n\t\tint type = buffer[offset] & 0xff;\n\n\t\t// Check for extension that the server uses.\n\t\tif (type == 0xc7) {\n\t\t\tint extensionType = buffer[offset + 1] & 0xff;\n\n\t\t\tif (extensionType == 0) {\n\t\t\t\tint mapBits = buffer[offset + 2] & 0xff;\n\n\t\t\t\t// Extension is a map type.  Determine which one.\n\t\t\t\tif ((mapBits & (0x04 | 0x08)) != 0) {\n\t\t\t\t\t// Index/rank range result where order needs to be preserved.\n\t\t\t\t\treturn unpackMapAsList(count);\n\t\t\t\t}\n\t\t\t\telse if ((mapBits & 0x01) != 0) {\n\t\t\t\t\t// Sorted map\n\t\t\t\t\treturn unpackTreeMap(count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn unpackHashMap(count);\n\t}\n\n\tprivate T unpackHashMap(int count) throws IOException, ClassNotFoundException {\n\t\tHashMap<T,T> map = new HashMap<T,T>(count);\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tmap.put(key, val);\n\t\t\t}\n\t\t}\n\t\treturn getMap(map);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T unpackTreeMap(int count) throws IOException, ClassNotFoundException {\n\t\tTreeMap<T,T> map = new TreeMap<T,T>();\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tif (key instanceof byte[]) {\n\t\t\t\t\t// TreeMap does not support byte[] keys,\n\t\t\t\t\t// so wrap byte[] in a ByteBuffer.\n\t\t\t\t\tkey = (T)ByteBuffer.wrap((byte[])key);\n\t\t\t\t}\n\t\t\t\tmap.put(key, val);\n\t\t\t}\n\t\t}\n\t\treturn getMap(map);\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate T unpackMapAsList(int count) throws IOException, ClassNotFoundException {\n\t\t// Index/rank range result where order needs to be preserved.\n\t\t// Store in List<Entry<?,?> to preserve order.\n\t\t// The first entry is going to be null (ignored), so use \"count - 1\" size.\n\t\tList<Entry<T,T>> list = new ArrayList<Entry<T,T>>(count - 1);\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tT key = unpackObject();\n\t\t\tT val = unpackObject();\n\n\t\t\tif (key != null) {\n\t\t\t\tlist.add(new AbstractMap.SimpleEntry<T,T>(key, val));\n\t\t\t}\n\t\t}\n\t\treturn getList((List<T>)list);\n\t}\n\n\tprivate T unpackBlob(int count) throws IOException, ClassNotFoundException {\n\t\tint type = buffer[offset++] & 0xff;\n\t\tcount--;\n\t\tT val;\n\n\t\tswitch (type) {\n\t\tcase ParticleType.STRING:\n\t\t\tval = getString(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tcase ParticleType.JBLOB:\n\t\t\tthrow new AerospikeException(ResultCode.SERIALIZE_ERROR, \"Object deserializer has been disabled\");\n\n\t\tcase ParticleType.GEOJSON:\n\t\t\tval = getGeoJSON(Buffer.utf8ToString(buffer, offset, count));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval = getBlob(Arrays.copyOfRange(buffer, offset, offset + count));\n\t\t\tbreak;\n\t\t}\n\t\toffset += count;\n\t\treturn val;\n\t}\n\n\tpublic T unpackObject() throws IOException, ClassNotFoundException {\n\t\tint type = buffer[offset++] & 0xff;\n\n\t\tswitch (type) {\n\t\t\tcase 0xc0: { // nil\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc3: { // boolean true\n\t\t\t\treturn getBoolean(true);\n\t\t\t}\n\n\t\t\tcase 0xc2: { // boolean false\n\t\t\t\treturn getBoolean(false);\n\t\t\t}\n\n\t\t\tcase 0xca: { // float\n\t\t\t\tfloat val = Float.intBitsToFloat(Buffer.bytesToInt(buffer, offset));\n\t\t\t\toffset += 4;\n\t\t\t\treturn getDouble(val);\n\t\t\t}\n\n\t\t\tcase 0xcb: { // double\n\t\t\t\tdouble val = Double.longBitsToDouble(Buffer.bytesToLong(buffer, offset));\n\t\t\t\toffset += 8;\n\t\t\t\treturn getDouble(val);\n\t\t\t}\n\n\t\t\tcase 0xd0: { // signed 8 bit integer\n\t\t\t\treturn getLong(buffer[offset++]);\n\t\t\t}\n\n\t\t\tcase 0xcc: { // unsigned 8 bit integer\n\t\t\t\treturn getLong(buffer[offset++] & 0xff);\n\t\t\t}\n\n\t\t\tcase 0xd1: { // signed 16 bit integer\n\t\t\t\tshort val = Buffer.bigSigned16ToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xcd: { // unsigned 16 bit integer\n\t\t\t\tint val = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xd2: { // signed 32 bit integer\n\t\t\t\tint val = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xce: { // unsigned 32 bit integer\n\t\t\t\tlong val = Buffer.bigUnsigned32ToLong(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xd3: { // signed 64 bit integer\n\t\t\t\tlong val = Buffer.bytesToLong(buffer, offset);\n\t\t\t\toffset += 8;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xcf: { // unsigned 64 bit integer\n\t\t\t\t// Java is constrained to signed longs, so that is the best we can do here.\n\t\t\t\tlong val = Buffer.bytesToLong(buffer, offset);\n\t\t\t\toffset += 8;\n\t\t\t\treturn getLong(val);\n\t\t\t}\n\n\t\t\tcase 0xc4:\n\t\t\tcase 0xd9: { // string/raw bytes with 8 bit header\n\t\t\t\tint count = buffer[offset++] & 0xff;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xc5:\n\t\t\tcase 0xda: { // string/raw bytes with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xc6:\n\t\t\tcase 0xdb: { // string/raw bytes with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn (T)unpackBlob(count);\n\t\t\t}\n\n\t\t\tcase 0xdc: { // list with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn unpackList(count);\n\t\t\t}\n\n\t\t\tcase 0xdd: { // list with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn unpackList(count);\n\t\t\t}\n\n\t\t\tcase 0xde: { // map with 16 bit header\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn unpackMap(count);\n\t\t\t}\n\n\t\t\tcase 0xdf: { // map with 32 bit header\n\t\t\t\t// Java array length is restricted to positive int values (0 - Integer.MAX_VALUE).\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn unpackMap(count);\n\t\t\t}\n\n\t\t\tcase 0xd4: { // Skip over type extension with 1 byte\n\t\t\t\toffset += 1 + 1;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd5: { // Skip over type extension with 2 bytes\n\t\t\t\toffset += 1 + 2;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd6: { // Skip over type extension with 4 bytes\n\t\t\t\toffset += 1 + 4;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd7: { // Skip over type extension with 8 bytes\n\t\t\t\toffset += 1 + 8;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xd8: { // Skip over type extension with 16 bytes\n\t\t\t\toffset += 1 + 16;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc7: { // Skip over type extension with 8 bit header and bytes\n\t\t\t\tint count = buffer[offset] & 0xff;\n\t\t\t\toffset += count + 1 + 1;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc8: { // Skip over type extension with 16 bit header and bytes\n\t\t\t\tint count = Buffer.bytesToShort(buffer, offset);\n\t\t\t\toffset += count + 1 + 2;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tcase 0xc9: { // Skip over type extension with 32 bit header and bytes\n\t\t\t\tint count = Buffer.bytesToInt(buffer, offset);\n\t\t\t\toffset += count + 1 + 4;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tif ((type & 0xe0) == 0xa0) { // raw bytes with 8 bit combined header\n\t\t\t\t\treturn unpackBlob(type & 0x1f);\n\t\t\t\t}\n\n\t\t\t\tif ((type & 0xf0) == 0x80) { // map with 8 bit combined header\n\t\t\t\t\treturn unpackMap(type & 0x0f);\n\t\t\t\t}\n\n\t\t\t\tif ((type & 0xf0) == 0x90) { // list with 8 bit combined header\n\t\t\t\t\treturn unpackList(type & 0x0f);\n\t\t\t\t}\n\n\t\t\t\tif (type < 0x80) { // 8 bit combined unsigned integer\n\t\t        \treturn getLong(type);\n\t\t\t\t}\n\n\t\t\t\tif (type >= 0xe0) { // 8 bit combined signed integer\n\t\t        \treturn getLong(type - 0xe0 - 32);\n\t\t\t\t}\n\t\t\t\tthrow new IOException(\"Unknown unpack type: \" + type);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected abstract T getMap(Map<T,T> value);\n\tprotected abstract T getList(List<T> value);\n\tprotected abstract T getJavaBlob(Object value);\n\tprotected abstract T getBlob(byte[] value);\n\tprotected abstract T getString(String value);\n\tprotected abstract T getLong(long value);\n\tprotected abstract T getDouble(double value);\n\tprotected abstract T getBoolean(boolean value);\n\tprotected abstract T getGeoJSON(String value);\n\n\tpublic static Object unpackObjectList(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\treturn unpacker.unpackList();\n\t}\n\n\tpublic static Object unpackObjectMap(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\treturn unpacker.unpackMap();\n\t}\n\n\tpublic static Object unpackObject(byte[] buffer, int offset, int length) throws AerospikeException {\n\t\ttry {\n\t\t\tif (length <= 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tObjectUnpacker unpacker = new ObjectUnpacker(buffer, offset, length);\n\t\t\treturn unpacker.unpackObject();\n\t\t}\n\t\tcatch (Exception e) {\n    \t\tthrow new AerospikeException.Serialize(e);\n\t\t}\n\t}\n\n\tpublic static final class ObjectUnpacker extends Unpacker<Object> {\n\n\t\tpublic ObjectUnpacker(byte[] buffer, int offset, int length) {\n\t\t\tsuper(buffer, offset, length);\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getMap(Map<Object,Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getList(List<Object> value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getJavaBlob(Object value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBlob(byte[] value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getString(String value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getLong(long value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getDouble(double value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getBoolean(boolean value) {\n\t\t\treturn value;\n\t\t}\n\n\t\t@Override\n\t\tprotected Object getGeoJSON(String value) {\n\t\t\treturn Value.getAsGeoJSON(value);\n\t\t}\n\t}\n}\n"], "filenames": ["client/src/com/aerospike/client/Value.java", "client/src/com/aerospike/client/command/Buffer.java", "client/src/com/aerospike/client/util/Packer.java", "client/src/com/aerospike/client/util/Unpacker.java"], "buggy_code_start_loc": [19, 19, 19, 19], "buggy_code_end_loc": [1034, 346, 209, 242], "fixing_code_start_loc": [18, 18, 18, 18], "fixing_code_end_loc": [1022, 338, 193, 238], "type": "CWE-502", "message": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2023-36480", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T15:15:10.210", "lastModified": "2023-08-09T17:36:23.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Aerospike Java client is a Java application that implements a network protocol to communicate with an Aerospike server. Prior to versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 some of the messages received from the server contain Java objects that the client deserializes when it encounters them without further validation. Attackers that manage to trick clients into communicating with a malicious server can include especially crafted objects in its responses that, once deserialized by the client, force it to execute arbitrary code. This can be abused to take control of the machine the client is running on. Versions 7.0.0, 6.2.0, 5.2.0, and 4.5.0 contain a patch for this issue."}, {"lang": "es", "value": "El cliente Java de Aerospike es una aplicaci\u00f3n Java que implementa un protocolo de red para comunicarse con un servidor Aerospike. Antes de las versiones 7.0.0, 6.2.0, 5.2.0 y 4.5.0, algunos de los mensajes recibidos del servidor conten\u00edan objetos Java que el cliente deserializaba cuando los encontraba sin validaci\u00f3n adicional. Los atacantes que consiguen enga\u00f1ar a los clientes para que se comuniquen con un servidor malicioso pueden incluir objetos especialmente dise\u00f1ados en sus respuestas que, una vez deserializados por el cliente, le obligan a ejecutar c\u00f3digo arbitrario. Esto se puede aprovechar para tomar el control de la m\u00e1quina en la que se ejecuta el cliente. Las versiones 7.0.0, 6.2.0, 5.2.0 y 4.5.0 contienen un parche para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aerospike:aerospike_java_client:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "8AF2204F-28DD-49CC-8468-CDB842A26AD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aerospike:aerospike_java_client:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.2.0", "matchCriteriaId": "8DC4192F-9ADB-4642-8CA0-B2DE4FCCC38D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:aerospike:aerospike_java_client:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2.0", "matchCriteriaId": "C73DE084-C94F-4498-88B2-9D860736FFEC"}]}]}], "references": [{"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/async/AsyncRead.java#L68", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/async/NettyCommand.java#L1157", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/async/NettyCommand.java#L489", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/async/NettyCommand.java#L596", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/command/Buffer.java#L53", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/command/Command.java#L2083", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/blob/e40a49b3db0d2b3d45068910e1cb9d917c795315/client/src/com/aerospike/client/util/Unpacker.java#L227", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/aerospike/aerospike-client-java/commit/02bf28e62fb186f004c82c87b219db2fc5b8262a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aerospike/aerospike-client-java/commit/51c65e32837da29435161a2d9c09bbdc2071ecae", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aerospike/aerospike-client-java/commit/66aafb4cd743cf53baffaeaf69b035f51d2e2e36", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aerospike/aerospike-client-java/commit/80c508cc5ecb0173ce92d7fab8cfab5e77bd9900", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aerospike/aerospike-client-java/security/advisories/GHSA-jj95-55cr-9597", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://support.aerospike.com/s/article/CVE-2023-36480-Aerospike-Java-Client-vulnerable-to-unsafe-deserialization-of-server-responses", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/aerospike/aerospike-client-java/commit/02bf28e62fb186f004c82c87b219db2fc5b8262a"}}