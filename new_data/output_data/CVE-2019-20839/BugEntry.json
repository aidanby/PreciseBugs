{"buggy_code": ["/*\n *  Copyright (C) 2011-2012 Christian Beier <dontmind@freeshell.org>\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * sockets.c - functions to deal with sockets.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#ifdef __linux__\n/* Setting this on other systems hides definitions such as INADDR_LOOPBACK.\n * The check should be for __GLIBC__ in fact. */\n# define _POSIX_SOURCE\n#endif\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <rfb/rfbclient.h>\n#ifdef WIN32\n#undef SOCKET\n#include <winsock2.h>\n#ifdef EWOULDBLOCK\n#undef EWOULDBLOCK\n#endif\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#define close closesocket\n#define read(sock,buf,len) recv(sock,buf,len,0)\n#define write(sock,buf,len) send(sock,buf,len,0)\n#define socklen_t int\n#ifdef LIBVNCSERVER_HAVE_WS2TCPIP_H\n#undef socklen_t\n#include <ws2tcpip.h>\n#endif\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#endif\n#include \"tls.h\"\n#include \"sasl.h\"\n\n#ifdef _MSC_VER\n#  define snprintf _snprintf\n#endif\n\nvoid PrintInHex(char *buf, int len);\n\nrfbBool errorMessageOnReadFailure = TRUE;\n\n/*\n * ReadFromRFBServer is called whenever we want to read some data from the RFB\n * server.  It is non-trivial for two reasons:\n *\n * 1. For efficiency it performs some intelligent buffering, avoiding invoking\n *    the read() system call too often.  For small chunks of data, it simply\n *    copies the data out of an internal buffer.  For large amounts of data it\n *    reads directly into the buffer provided by the caller.\n *\n * 2. Whenever read() would block, it invokes the Xt event dispatching\n *    mechanism to process X events.  In fact, this is the only place these\n *    events are processed, as there is no XtAppMainLoop in the program.\n */\n\nrfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tint nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}\n\n\n/*\n * Write an exact number of bytes, and don't return until you've sent them.\n */\n\nrfbBool\nWriteToRFBServer(rfbClient* client, char *buf, int n)\n{\n  fd_set fds;\n  int i = 0;\n  int j;\n  const char *obuf = buf;\n#ifdef LIBVNCSERVER_HAVE_SASL\n  const char *output;\n  unsigned int outputlen;\n  int err;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  if (client->serverPort==-1)\n    return TRUE; /* vncrec playing */\n\n  if (client->tlsSession) {\n    /* WriteToTLS() will guarantee either everything is written, or error/eof returns */\n    i = WriteToTLS(client, buf, n);\n    if (i <= 0) return FALSE;\n\n    return TRUE;\n  }\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslconn) {\n    err = sasl_encode(client->saslconn,\n                      buf, n,\n                      &output, &outputlen);\n    if (err != SASL_OK) {\n      rfbClientLog(\"Failed to encode SASL data %s\",\n                   sasl_errstring(err, NULL, NULL));\n      return FALSE;\n    }\n    obuf = output;\n    n = outputlen;\n  }\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  while (i < n) {\n    j = write(client->sock, obuf + i, (n - i));\n    if (j <= 0) {\n      if (j < 0) {\n#ifdef WIN32\n\t errno=WSAGetLastError();\n#endif\n\tif (errno == EWOULDBLOCK ||\n#ifdef LIBVNCSERVER_ENOENT_WORKAROUND\n\t\terrno == ENOENT ||\n#endif\n\t\terrno == EAGAIN) {\n\t  FD_ZERO(&fds);\n\t  FD_SET(client->sock,&fds);\n\n\t  if (select(client->sock+1, NULL, &fds, NULL, NULL) <= 0) {\n\t    rfbClientErr(\"select\\n\");\n\t    return FALSE;\n\t  }\n\t  j = 0;\n\t} else {\n\t  rfbClientErr(\"write\\n\");\n\t  return FALSE;\n\t}\n      } else {\n\trfbClientLog(\"write failed\\n\");\n\treturn FALSE;\n      }\n    }\n    i += j;\n  }\n  return TRUE;\n}\n\nstatic int initSockets() {\n#ifdef WIN32\n  WSADATA trash;\n  static rfbBool WSAinitted=FALSE;\n  if(!WSAinitted) {\n    int i=WSAStartup(MAKEWORD(2,0),&trash);\n    if(i!=0) {\n      rfbClientErr(\"Couldn't init Windows Sockets\\n\");\n      return 0;\n    }\n    WSAinitted=TRUE;\n  }\n#endif\n  return 1;\n}\n\n/*\n * ConnectToTcpAddr connects to the given TCP port.\n */\n\nint\nConnectClientToTcpAddr(unsigned int host, int port)\n{\n  int sock;\n  struct sockaddr_in addr;\n  int one = 1;\n\n  if (!initSockets())\n\t  return -1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = host;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientErr(\"ConnectToTcpAddr: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: connect\\n\");\n    close(sock);\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\nint\nConnectClientToTcpAddr6(const char *hostname, int port)\n{\n#ifdef LIBVNCSERVER_IPv6\n  int sock;\n  int n;\n  struct addrinfo hints, *res, *ressave;\n  char port_s[10];\n  int one = 1;\n\n  if (!initSockets())\n\t  return -1;\n\n  snprintf(port_s, 10, \"%d\", port);\n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((n = getaddrinfo(hostname, port_s, &hints, &res)))\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: getaddrinfo (%s)\\n\", gai_strerror(n));\n    return -1;\n  }\n\n  ressave = res;\n  sock = -1;\n  while (res)\n  {\n    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sock >= 0)\n    {\n      if (connect(sock, res->ai_addr, res->ai_addrlen) == 0)\n        break;\n      close(sock);\n      sock = -1;\n    }\n    res = res->ai_next;\n  }\n  freeaddrinfo(ressave);\n\n  if (sock == -1)\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: connect\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n\n#else\n\n  rfbClientErr(\"ConnectClientToTcpAddr6: IPv6 disabled\\n\");\n  return -1;\n\n#endif\n}\n\nint\nConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n#endif\n}\n\n\n\n/*\n * FindFreeTcpPort tries to find unused TCP port in the range\n * (TUNNEL_PORT_OFFSET, TUNNEL_PORT_OFFSET + 99]. Returns 0 on failure.\n */\n\nint\nFindFreeTcpPort(void)\n{\n  int sock, port;\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n  if (!initSockets())\n    return -1;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\": FindFreeTcpPort: socket\\n\");\n    return 0;\n  }\n\n  for (port = TUNNEL_PORT_OFFSET + 99; port > TUNNEL_PORT_OFFSET; port--) {\n    addr.sin_port = htons((unsigned short)port);\n    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0) {\n      close(sock);\n      return port;\n    }\n  }\n\n  close(sock);\n  return 0;\n}\n\n\n/*\n * ListenAtTcpPort starts listening at the given TCP port.\n */\n\nint\nListenAtTcpPort(int port)\n{\n  return ListenAtTcpPortAndAddress(port, NULL);\n}\n\n\n\n/*\n * ListenAtTcpPortAndAddress starts listening at the given TCP port on\n * the given IP address\n */\n\nint\nListenAtTcpPortAndAddress(int port, const char *address)\n{\n  int sock;\n  int one = 1;\n#ifndef LIBVNCSERVER_IPv6\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  if (address) {\n    addr.sin_addr.s_addr = inet_addr(address);\n  } else {\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  }\n\n  if (!initSockets())\n    return -1;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ListenAtTcpPort: socket\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t (const char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: bind\\n\");\n    close(sock);\n    return -1;\n  }\n\n#else\n  int rv;\n  struct addrinfo hints, *servinfo, *p;\n  char port_str[8];\n\n  snprintf(port_str, 8, \"%d\", port);\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE; /* fill in wildcard address if address == NULL */\n\n  if (!initSockets())\n    return -1;\n\n  if ((rv = getaddrinfo(address, port_str, &hints, &servinfo)) != 0) {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in getaddrinfo: %s\\n\", gai_strerror(rv));\n    return -1;\n  }\n\n  /* loop through all the results and bind to the first we can */\n  for(p = servinfo; p != NULL; p = p->ai_next) {\n    if ((sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) {\n      continue;\n    }\n\n#ifdef IPV6_V6ONLY\n    /* we have separate IPv4 and IPv6 sockets since some OS's do not support dual binding */\n    if (p->ai_family == AF_INET6 && setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt IPV6_V6ONLY: %s\\n\", strerror(errno));\n      close(sock);\n      freeaddrinfo(servinfo);\n      return -1;\n    }\n#endif\n\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt SO_REUSEADDR: %s\\n\", strerror(errno));\n      close(sock);\n      freeaddrinfo(servinfo);\n      return -1;\n    }\n\n    if (bind(sock, p->ai_addr, p->ai_addrlen) < 0) {\n      close(sock);\n      continue;\n    }\n\n    break;\n  }\n\n  if (p == NULL)  {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in bind: %s\\n\", strerror(errno));\n    return -1;\n  }\n\n  /* all done with this structure now */\n  freeaddrinfo(servinfo);\n#endif\n\n  if (listen(sock, 5) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: listen\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\n\n/*\n * AcceptTcpConnection accepts a TCP connection.\n */\n\nint\nAcceptTcpConnection(int listenSock)\n{\n  int sock;\n  struct sockaddr_in addr;\n  socklen_t addrlen = sizeof(addr);\n  int one = 1;\n\n  sock = accept(listenSock, (struct sockaddr *) &addr, &addrlen);\n  if (sock < 0) {\n    rfbClientErr(\"AcceptTcpConnection: accept\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"AcceptTcpConnection: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\n\n/*\n * SetNonBlocking sets a socket into non-blocking mode.\n */\n\nrfbBool\nSetNonBlocking(int sock)\n{\n#ifdef WIN32\n  unsigned long block=1;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to non-blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\n\n/*\n * SetDSCP sets a socket's IP QoS parameters aka Differentiated Services Code Point field\n */\n\nrfbBool\nSetDSCP(int sock, int dscp)\n{\n#ifdef WIN32\n  rfbClientErr(\"Setting of QoS IP DSCP not implemented for Windows\\n\");\n  return TRUE;\n#else\n  int level, cmd;\n  struct sockaddr addr;\n  socklen_t addrlen = sizeof(addr);\n\n  if(getsockname(sock, &addr, &addrlen) != 0) {\n    rfbClientErr(\"Setting socket QoS failed while getting socket address: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n\n  switch(addr.sa_family)\n    {\n#if defined LIBVNCSERVER_IPv6 && defined IPV6_TCLASS\n    case AF_INET6:\n      level = IPPROTO_IPV6;\n      cmd = IPV6_TCLASS;\n      break;\n#endif\n    case AF_INET:\n      level = IPPROTO_IP;\n      cmd = IP_TOS;\n      break;\n    default:\n      rfbClientErr(\"Setting socket QoS failed: Not bound to IP address\");\n      return FALSE;\n    }\n\n  if(setsockopt(sock, level, cmd, (void*)&dscp, sizeof(dscp)) != 0) {\n    rfbClientErr(\"Setting socket QoS failed: %s\\n\", strerror(errno));\n    return FALSE;\n  }\n\n  return TRUE;\n#endif\n}\n\n\n\n/*\n * StringToIPAddr - convert a host string to an IP address.\n */\n\nrfbBool\nStringToIPAddr(const char *str, unsigned int *addr)\n{\n  struct hostent *hp;\n\n  if (strcmp(str,\"\") == 0) {\n    *addr = htonl(INADDR_LOOPBACK); /* local */\n    return TRUE;\n  }\n\n  *addr = inet_addr(str);\n\n  if (*addr != -1)\n    return TRUE;\n\n  if (!initSockets())\n\t  return -1;\n\n  hp = gethostbyname(str);\n\n  if (hp) {\n    *addr = *(unsigned int *)hp->h_addr;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * Test if the other end of a socket is on the same machine.\n */\n\nrfbBool\nSameMachine(int sock)\n{\n  struct sockaddr_in peeraddr, myaddr;\n  socklen_t addrlen = sizeof(struct sockaddr_in);\n\n  getpeername(sock, (struct sockaddr *)&peeraddr, &addrlen);\n  getsockname(sock, (struct sockaddr *)&myaddr, &addrlen);\n\n  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);\n}\n\n\n/*\n * Print out the contents of a packet for debugging.\n */\n\nvoid\nPrintInHex(char *buf, int len)\n{\n  int i, j;\n  char c, str[17];\n\n  str[16] = 0;\n\n  rfbClientLog(\"ReadExact: \");\n\n  for (i = 0; i < len; i++)\n    {\n      if ((i % 16 == 0) && (i != 0)) {\n\trfbClientLog(\"           \");\n      }\n      c = buf[i];\n      str[i % 16] = (((c > 31) && (c < 127)) ? c : '.');\n      rfbClientLog(\"%02x \",(unsigned char)c);\n      if ((i % 4) == 3)\n\trfbClientLog(\" \");\n      if ((i % 16) == 15)\n\t{\n\t  rfbClientLog(\"%s\\n\",str);\n\t}\n    }\n  if ((i % 16) != 0)\n    {\n      for (j = i % 16; j < 16; j++)\n\t{\n\t  rfbClientLog(\"   \");\n\t  if ((j % 4) == 3) rfbClientLog(\" \");\n\t}\n      str[i % 16] = 0;\n      rfbClientLog(\"%s\\n\",str);\n    }\n\n  fflush(stderr);\n}\n\nint WaitForMessage(rfbClient* client,unsigned int usecs)\n{\n  fd_set fds;\n  struct timeval timeout;\n  int num;\n\n  if (client->serverPort==-1)\n    /* playing back vncrec file */\n    return 1;\n  \n  timeout.tv_sec=(usecs/1000000);\n  timeout.tv_usec=(usecs%1000000);\n\n  FD_ZERO(&fds);\n  FD_SET(client->sock,&fds);\n\n  num=select(client->sock+1, &fds, NULL, NULL, &timeout);\n  if(num<0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientLog(\"Waiting for message failed: %d (%s)\\n\",errno,strerror(errno));\n  }\n\n  return num;\n}\n\n\n"], "fixing_code": ["/*\n *  Copyright (C) 2011-2012 Christian Beier <dontmind@freeshell.org>\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * sockets.c - functions to deal with sockets.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#ifdef __linux__\n/* Setting this on other systems hides definitions such as INADDR_LOOPBACK.\n * The check should be for __GLIBC__ in fact. */\n# define _POSIX_SOURCE\n#endif\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <rfb/rfbclient.h>\n#ifdef WIN32\n#undef SOCKET\n#include <winsock2.h>\n#ifdef EWOULDBLOCK\n#undef EWOULDBLOCK\n#endif\n#define EWOULDBLOCK WSAEWOULDBLOCK\n#define close closesocket\n#define read(sock,buf,len) recv(sock,buf,len,0)\n#define write(sock,buf,len) send(sock,buf,len,0)\n#define socklen_t int\n#ifdef LIBVNCSERVER_HAVE_WS2TCPIP_H\n#undef socklen_t\n#include <ws2tcpip.h>\n#endif\n#else\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#endif\n#include \"tls.h\"\n#include \"sasl.h\"\n\n#ifdef _MSC_VER\n#  define snprintf _snprintf\n#endif\n\nvoid PrintInHex(char *buf, int len);\n\nrfbBool errorMessageOnReadFailure = TRUE;\n\n/*\n * ReadFromRFBServer is called whenever we want to read some data from the RFB\n * server.  It is non-trivial for two reasons:\n *\n * 1. For efficiency it performs some intelligent buffering, avoiding invoking\n *    the read() system call too often.  For small chunks of data, it simply\n *    copies the data out of an internal buffer.  For large amounts of data it\n *    reads directly into the buffer provided by the caller.\n *\n * 2. Whenever read() would block, it invokes the Xt event dispatching\n *    mechanism to process X events.  In fact, this is the only place these\n *    events are processed, as there is no XtAppMainLoop in the program.\n */\n\nrfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tint nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}\n\n\n/*\n * Write an exact number of bytes, and don't return until you've sent them.\n */\n\nrfbBool\nWriteToRFBServer(rfbClient* client, char *buf, int n)\n{\n  fd_set fds;\n  int i = 0;\n  int j;\n  const char *obuf = buf;\n#ifdef LIBVNCSERVER_HAVE_SASL\n  const char *output;\n  unsigned int outputlen;\n  int err;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  if (client->serverPort==-1)\n    return TRUE; /* vncrec playing */\n\n  if (client->tlsSession) {\n    /* WriteToTLS() will guarantee either everything is written, or error/eof returns */\n    i = WriteToTLS(client, buf, n);\n    if (i <= 0) return FALSE;\n\n    return TRUE;\n  }\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslconn) {\n    err = sasl_encode(client->saslconn,\n                      buf, n,\n                      &output, &outputlen);\n    if (err != SASL_OK) {\n      rfbClientLog(\"Failed to encode SASL data %s\",\n                   sasl_errstring(err, NULL, NULL));\n      return FALSE;\n    }\n    obuf = output;\n    n = outputlen;\n  }\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  while (i < n) {\n    j = write(client->sock, obuf + i, (n - i));\n    if (j <= 0) {\n      if (j < 0) {\n#ifdef WIN32\n\t errno=WSAGetLastError();\n#endif\n\tif (errno == EWOULDBLOCK ||\n#ifdef LIBVNCSERVER_ENOENT_WORKAROUND\n\t\terrno == ENOENT ||\n#endif\n\t\terrno == EAGAIN) {\n\t  FD_ZERO(&fds);\n\t  FD_SET(client->sock,&fds);\n\n\t  if (select(client->sock+1, NULL, &fds, NULL, NULL) <= 0) {\n\t    rfbClientErr(\"select\\n\");\n\t    return FALSE;\n\t  }\n\t  j = 0;\n\t} else {\n\t  rfbClientErr(\"write\\n\");\n\t  return FALSE;\n\t}\n      } else {\n\trfbClientLog(\"write failed\\n\");\n\treturn FALSE;\n      }\n    }\n    i += j;\n  }\n  return TRUE;\n}\n\nstatic int initSockets() {\n#ifdef WIN32\n  WSADATA trash;\n  static rfbBool WSAinitted=FALSE;\n  if(!WSAinitted) {\n    int i=WSAStartup(MAKEWORD(2,0),&trash);\n    if(i!=0) {\n      rfbClientErr(\"Couldn't init Windows Sockets\\n\");\n      return 0;\n    }\n    WSAinitted=TRUE;\n  }\n#endif\n  return 1;\n}\n\n/*\n * ConnectToTcpAddr connects to the given TCP port.\n */\n\nint\nConnectClientToTcpAddr(unsigned int host, int port)\n{\n  int sock;\n  struct sockaddr_in addr;\n  int one = 1;\n\n  if (!initSockets())\n\t  return -1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = host;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientErr(\"ConnectToTcpAddr: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: connect\\n\");\n    close(sock);\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\nint\nConnectClientToTcpAddr6(const char *hostname, int port)\n{\n#ifdef LIBVNCSERVER_IPv6\n  int sock;\n  int n;\n  struct addrinfo hints, *res, *ressave;\n  char port_s[10];\n  int one = 1;\n\n  if (!initSockets())\n\t  return -1;\n\n  snprintf(port_s, 10, \"%d\", port);\n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((n = getaddrinfo(hostname, port_s, &hints, &res)))\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: getaddrinfo (%s)\\n\", gai_strerror(n));\n    return -1;\n  }\n\n  ressave = res;\n  sock = -1;\n  while (res)\n  {\n    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sock >= 0)\n    {\n      if (connect(sock, res->ai_addr, res->ai_addrlen) == 0)\n        break;\n      close(sock);\n      sock = -1;\n    }\n    res = res->ai_next;\n  }\n  freeaddrinfo(ressave);\n\n  if (sock == -1)\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: connect\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n\n#else\n\n  rfbClientErr(\"ConnectClientToTcpAddr6: IPv6 disabled\\n\");\n  return -1;\n\n#endif\n}\n\nint\nConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n#endif\n}\n\n\n\n/*\n * FindFreeTcpPort tries to find unused TCP port in the range\n * (TUNNEL_PORT_OFFSET, TUNNEL_PORT_OFFSET + 99]. Returns 0 on failure.\n */\n\nint\nFindFreeTcpPort(void)\n{\n  int sock, port;\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n  if (!initSockets())\n    return -1;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\": FindFreeTcpPort: socket\\n\");\n    return 0;\n  }\n\n  for (port = TUNNEL_PORT_OFFSET + 99; port > TUNNEL_PORT_OFFSET; port--) {\n    addr.sin_port = htons((unsigned short)port);\n    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0) {\n      close(sock);\n      return port;\n    }\n  }\n\n  close(sock);\n  return 0;\n}\n\n\n/*\n * ListenAtTcpPort starts listening at the given TCP port.\n */\n\nint\nListenAtTcpPort(int port)\n{\n  return ListenAtTcpPortAndAddress(port, NULL);\n}\n\n\n\n/*\n * ListenAtTcpPortAndAddress starts listening at the given TCP port on\n * the given IP address\n */\n\nint\nListenAtTcpPortAndAddress(int port, const char *address)\n{\n  int sock;\n  int one = 1;\n#ifndef LIBVNCSERVER_IPv6\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  if (address) {\n    addr.sin_addr.s_addr = inet_addr(address);\n  } else {\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  }\n\n  if (!initSockets())\n    return -1;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ListenAtTcpPort: socket\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t (const char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: bind\\n\");\n    close(sock);\n    return -1;\n  }\n\n#else\n  int rv;\n  struct addrinfo hints, *servinfo, *p;\n  char port_str[8];\n\n  snprintf(port_str, 8, \"%d\", port);\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE; /* fill in wildcard address if address == NULL */\n\n  if (!initSockets())\n    return -1;\n\n  if ((rv = getaddrinfo(address, port_str, &hints, &servinfo)) != 0) {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in getaddrinfo: %s\\n\", gai_strerror(rv));\n    return -1;\n  }\n\n  /* loop through all the results and bind to the first we can */\n  for(p = servinfo; p != NULL; p = p->ai_next) {\n    if ((sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0) {\n      continue;\n    }\n\n#ifdef IPV6_V6ONLY\n    /* we have separate IPv4 and IPv6 sockets since some OS's do not support dual binding */\n    if (p->ai_family == AF_INET6 && setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt IPV6_V6ONLY: %s\\n\", strerror(errno));\n      close(sock);\n      freeaddrinfo(servinfo);\n      return -1;\n    }\n#endif\n\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt SO_REUSEADDR: %s\\n\", strerror(errno));\n      close(sock);\n      freeaddrinfo(servinfo);\n      return -1;\n    }\n\n    if (bind(sock, p->ai_addr, p->ai_addrlen) < 0) {\n      close(sock);\n      continue;\n    }\n\n    break;\n  }\n\n  if (p == NULL)  {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in bind: %s\\n\", strerror(errno));\n    return -1;\n  }\n\n  /* all done with this structure now */\n  freeaddrinfo(servinfo);\n#endif\n\n  if (listen(sock, 5) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: listen\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\n\n/*\n * AcceptTcpConnection accepts a TCP connection.\n */\n\nint\nAcceptTcpConnection(int listenSock)\n{\n  int sock;\n  struct sockaddr_in addr;\n  socklen_t addrlen = sizeof(addr);\n  int one = 1;\n\n  sock = accept(listenSock, (struct sockaddr *) &addr, &addrlen);\n  if (sock < 0) {\n    rfbClientErr(\"AcceptTcpConnection: accept\\n\");\n    return -1;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"AcceptTcpConnection: setsockopt\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n}\n\n\n/*\n * SetNonBlocking sets a socket into non-blocking mode.\n */\n\nrfbBool\nSetNonBlocking(int sock)\n{\n#ifdef WIN32\n  unsigned long block=1;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to non-blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\n\n/*\n * SetDSCP sets a socket's IP QoS parameters aka Differentiated Services Code Point field\n */\n\nrfbBool\nSetDSCP(int sock, int dscp)\n{\n#ifdef WIN32\n  rfbClientErr(\"Setting of QoS IP DSCP not implemented for Windows\\n\");\n  return TRUE;\n#else\n  int level, cmd;\n  struct sockaddr addr;\n  socklen_t addrlen = sizeof(addr);\n\n  if(getsockname(sock, &addr, &addrlen) != 0) {\n    rfbClientErr(\"Setting socket QoS failed while getting socket address: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n\n  switch(addr.sa_family)\n    {\n#if defined LIBVNCSERVER_IPv6 && defined IPV6_TCLASS\n    case AF_INET6:\n      level = IPPROTO_IPV6;\n      cmd = IPV6_TCLASS;\n      break;\n#endif\n    case AF_INET:\n      level = IPPROTO_IP;\n      cmd = IP_TOS;\n      break;\n    default:\n      rfbClientErr(\"Setting socket QoS failed: Not bound to IP address\");\n      return FALSE;\n    }\n\n  if(setsockopt(sock, level, cmd, (void*)&dscp, sizeof(dscp)) != 0) {\n    rfbClientErr(\"Setting socket QoS failed: %s\\n\", strerror(errno));\n    return FALSE;\n  }\n\n  return TRUE;\n#endif\n}\n\n\n\n/*\n * StringToIPAddr - convert a host string to an IP address.\n */\n\nrfbBool\nStringToIPAddr(const char *str, unsigned int *addr)\n{\n  struct hostent *hp;\n\n  if (strcmp(str,\"\") == 0) {\n    *addr = htonl(INADDR_LOOPBACK); /* local */\n    return TRUE;\n  }\n\n  *addr = inet_addr(str);\n\n  if (*addr != -1)\n    return TRUE;\n\n  if (!initSockets())\n\t  return -1;\n\n  hp = gethostbyname(str);\n\n  if (hp) {\n    *addr = *(unsigned int *)hp->h_addr;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * Test if the other end of a socket is on the same machine.\n */\n\nrfbBool\nSameMachine(int sock)\n{\n  struct sockaddr_in peeraddr, myaddr;\n  socklen_t addrlen = sizeof(struct sockaddr_in);\n\n  getpeername(sock, (struct sockaddr *)&peeraddr, &addrlen);\n  getsockname(sock, (struct sockaddr *)&myaddr, &addrlen);\n\n  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);\n}\n\n\n/*\n * Print out the contents of a packet for debugging.\n */\n\nvoid\nPrintInHex(char *buf, int len)\n{\n  int i, j;\n  char c, str[17];\n\n  str[16] = 0;\n\n  rfbClientLog(\"ReadExact: \");\n\n  for (i = 0; i < len; i++)\n    {\n      if ((i % 16 == 0) && (i != 0)) {\n\trfbClientLog(\"           \");\n      }\n      c = buf[i];\n      str[i % 16] = (((c > 31) && (c < 127)) ? c : '.');\n      rfbClientLog(\"%02x \",(unsigned char)c);\n      if ((i % 4) == 3)\n\trfbClientLog(\" \");\n      if ((i % 16) == 15)\n\t{\n\t  rfbClientLog(\"%s\\n\",str);\n\t}\n    }\n  if ((i % 16) != 0)\n    {\n      for (j = i % 16; j < 16; j++)\n\t{\n\t  rfbClientLog(\"   \");\n\t  if ((j % 4) == 3) rfbClientLog(\" \");\n\t}\n      str[i % 16] = 0;\n      rfbClientLog(\"%s\\n\",str);\n    }\n\n  fflush(stderr);\n}\n\nint WaitForMessage(rfbClient* client,unsigned int usecs)\n{\n  fd_set fds;\n  struct timeval timeout;\n  int num;\n\n  if (client->serverPort==-1)\n    /* playing back vncrec file */\n    return 1;\n  \n  timeout.tv_sec=(usecs/1000000);\n  timeout.tv_usec=(usecs%1000000);\n\n  FD_ZERO(&fds);\n  FD_SET(client->sock,&fds);\n\n  num=select(client->sock+1, &fds, NULL, NULL, &timeout);\n  if(num<0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientLog(\"Waiting for message failed: %d (%s)\\n\",errno,strerror(errno));\n  }\n\n  return num;\n}\n\n\n"], "filenames": ["libvncclient/sockets.c"], "buggy_code_start_loc": [463], "buggy_code_end_loc": [463], "fixing_code_start_loc": [464], "fixing_code_end_loc": [468], "type": "CWE-120", "message": "libvncclient/sockets.c in LibVNCServer before 0.9.13 has a buffer overflow via a long socket filename.", "other": {"cve": {"id": "CVE-2019-20839", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.463", "lastModified": "2022-03-10T15:23:52.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libvncclient/sockets.c in LibVNCServer before 0.9.13 has a buffer overflow via a long socket filename."}, {"lang": "es", "value": "La biblioteca libvncclient/sockets.c en LibVNCServer versiones anteriores a 0.9.13, presenta un desbordamiento de b\u00fafer por medio de un nombre de archivo socket largo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.12", "matchCriteriaId": "A03A7282-D445-4E26-98A0-6A1597838D35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/3fd03977c9b35800d73a865f167338cb4d05b0c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4F6FUH4EFK4NAP6GT4TQRTBKWIRCZLIY/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NVP7TJVYJDXDFRHVQ3ENEN3H354QPXEZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/3fd03977c9b35800d73a865f167338cb4d05b0c1"}}