{"buggy_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport org.jctools.queues.MpscArrayQueue;\nimport org.jctools.queues.MpscChunkedArrayQueue;\nimport org.jctools.queues.MpscUnboundedArrayQueue;\nimport org.jctools.queues.SpscLinkedQueue;\nimport org.jctools.queues.atomic.MpscAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscChunkedAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;\nimport org.jctools.queues.atomic.SpscLinkedAtomicQueue;\nimport org.jctools.util.Pow2;\nimport org.jctools.util.UnsafeAccess;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.file.Files;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_ASCII_SEED;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C1;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C2;\nimport static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitize;\nimport static io.netty.util.internal.PlatformDependent0.unalignedAccess;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Utility that detects various properties specific to the current runtime\n * environment, such as Java version and the availability of the\n * {@code sun.misc.Unsafe} object.\n * <p>\n * You can disable the use of {@code sun.misc.Unsafe} if you specify\n * the system property <strong>io.netty.noUnsafe</strong>.\n */\npublic final class PlatformDependent {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent.class);\n\n    private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern.compile(\n            \"\\\\s*-XX:MaxDirectMemorySize\\\\s*=\\\\s*([0-9]+)\\\\s*([kKmMgG]?)\\\\s*$\");\n\n    private static final boolean MAYBE_SUPER_USER;\n\n    private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();\n\n    private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();\n    private static final boolean DIRECT_BUFFER_PREFERRED;\n    private static final long MAX_DIRECT_MEMORY = estimateMaxDirectMemory();\n\n    private static final int MPSC_CHUNK_SIZE =  1024;\n    private static final int MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2;\n    private static final int MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2;\n\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n\n    private static final File TMPDIR = tmpdir0();\n\n    private static final int BIT_MODE = bitMode0();\n    private static final String NORMALIZED_ARCH = normalizeArch(SystemPropertyUtil.get(\"os.arch\", \"\"));\n    private static final String NORMALIZED_OS = normalizeOs(SystemPropertyUtil.get(\"os.name\", \"\"));\n\n    // keep in sync with maven's pom.xml via os.detection.classifierWithLikes!\n    private static final String[] ALLOWED_LINUX_OS_CLASSIFIERS = {\"fedora\", \"suse\", \"arch\"};\n    private static final Set<String> LINUX_OS_CLASSIFIERS;\n\n    private static final boolean IS_WINDOWS = isWindows0();\n    private static final boolean IS_OSX = isOsx0();\n    private static final boolean IS_J9_JVM = isJ9Jvm0();\n    private static final boolean IS_IVKVM_DOT_NET = isIkvmDotNet0();\n\n    private static final int ADDRESS_SIZE = addressSize0();\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    private static final Cleaner CLEANER;\n    private static final int UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD;\n    // For specifications, see https://www.freedesktop.org/software/systemd/man/os-release.html\n    private static final String[] OS_RELEASE_FILES = {\"/etc/os-release\", \"/usr/lib/os-release\"};\n    private static final String LINUX_ID_PREFIX = \"ID=\";\n    private static final String LINUX_ID_LIKE_PREFIX = \"ID_LIKE=\";\n    public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n\n    private static final Cleaner NOOP = new Cleaner() {\n        @Override\n        public void freeDirectBuffer(ByteBuffer buffer) {\n            // NOOP\n        }\n    };\n\n    static {\n        if (javaVersion() >= 7) {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n                public Random current() {\n                    return java.util.concurrent.ThreadLocalRandom.current();\n                }\n            };\n        } else {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                public Random current() {\n                    return ThreadLocalRandom.current();\n                }\n            };\n        }\n\n        // Here is how the system property is used:\n        //\n        // * <  0  - Don't use cleaner, and inherit max direct memory from java. In this case the\n        //           \"practical max direct memory\" would be 2 * max memory as defined by the JDK.\n        // * == 0  - Use cleaner, Netty will not enforce max memory, and instead will defer to JDK.\n        // * >  0  - Don't use cleaner. This will limit Netty's total direct memory\n        //           (note: that JDK's direct memory limit is independent of this).\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = MAX_DIRECT_MEMORY;\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        logger.debug(\"-Dio.netty.maxDirectMemory: {} bytes\", maxDirectMemory);\n        DIRECT_MEMORY_LIMIT = maxDirectMemory >= 1 ? maxDirectMemory : MAX_DIRECT_MEMORY;\n\n        int tryAllocateUninitializedArray =\n                SystemPropertyUtil.getInt(\"io.netty.uninitializedArrayAllocationThreshold\", 1024);\n        UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD = javaVersion() >= 9 && PlatformDependent0.hasAllocateArrayMethod() ?\n                tryAllocateUninitializedArray : -1;\n        logger.debug(\"-Dio.netty.uninitializedArrayAllocationThreshold: {}\", UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD);\n\n        MAYBE_SUPER_USER = maybeSuperUser0();\n\n        if (!isAndroid()) {\n            // only direct to method if we are not running on android.\n            // See https://github.com/netty/netty/issues/2604\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n\n        // We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\n        DIRECT_BUFFER_PREFERRED = CLEANER != NOOP\n                                  && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n        }\n\n        /*\n         * We do not want to log this message if unsafe is explicitly disabled. Do not remove the explicit no unsafe\n         * guard.\n         */\n        if (CLEANER == NOOP && !PlatformDependent0.isExplicitNoUnsafe()) {\n            logger.info(\n                    \"Your platform does not provide complete low-level API for accessing direct buffers reliably. \" +\n                    \"Unless explicitly requested, heap buffer will always be preferred to avoid potential system \" +\n                    \"instability.\");\n        }\n\n        final Set<String> allowedClassifiers = Collections.unmodifiableSet(\n                new HashSet<String>(Arrays.asList(ALLOWED_LINUX_OS_CLASSIFIERS)));\n        final Set<String> availableClassifiers = new LinkedHashSet<String>();\n        for (final String osReleaseFileName : OS_RELEASE_FILES) {\n            final File file = new File(osReleaseFileName);\n            boolean found = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                @Override\n                public Boolean run() {\n                    try {\n                        if (file.exists()) {\n                            BufferedReader reader = null;\n                            try {\n                                reader = new BufferedReader(\n                                        new InputStreamReader(\n                                                new FileInputStream(file), CharsetUtil.UTF_8));\n\n                                String line;\n                                while ((line = reader.readLine()) != null) {\n                                    if (line.startsWith(LINUX_ID_PREFIX)) {\n                                        String id = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, id);\n                                    } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n                                        line = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_LIKE_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, line.split(\"[ ]+\"));\n                                    }\n                                }\n                            } catch (SecurityException e) {\n                                logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n                            } catch (IOException e) {\n                                logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                            } finally {\n                                if (reader != null) {\n                                    try {\n                                        reader.close();\n                                    } catch (IOException ignored) {\n                                        // Ignore\n                                    }\n                                }\n                            }\n                            // specification states we should only fall back if /etc/os-release does not exist\n                            return true;\n                        }\n                    } catch (SecurityException e) {\n                        logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n                    }\n                    return false;\n                }\n            });\n\n            if (found) {\n                break;\n            }\n        }\n        LINUX_OS_CLASSIFIERS = Collections.unmodifiableSet(availableClassifiers);\n    }\n\n    public static long byteArrayBaseOffset() {\n        return BYTE_ARRAY_BASE_OFFSET;\n    }\n\n    public static boolean hasDirectBufferNoCleanerConstructor() {\n        return PlatformDependent0.hasDirectBufferNoCleanerConstructor();\n    }\n\n    public static byte[] allocateUninitializedArray(int size) {\n        return UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD < 0 || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD > size ?\n                new byte[size] : PlatformDependent0.allocateUninitializedArray(size);\n    }\n\n    /**\n     * Returns {@code true} if and only if the current platform is Android\n     */\n    public static boolean isAndroid() {\n        return PlatformDependent0.isAndroid();\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on Windows\n     */\n    public static boolean isWindows() {\n        return IS_WINDOWS;\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on OSX / MacOS\n     */\n    public static boolean isOsx() {\n        return IS_OSX;\n    }\n\n    /**\n     * Return {@code true} if the current user may be a super-user. Be aware that this is just an hint and so it may\n     * return false-positives.\n     */\n    public static boolean maybeSuperUser() {\n        return MAYBE_SUPER_USER;\n    }\n\n    /**\n     * Return the version of Java under which this library is used.\n     */\n    public static int javaVersion() {\n        return PlatformDependent0.javaVersion();\n    }\n\n    /**\n     * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default.\n     */\n    public static boolean canEnableTcpNoDelayByDefault() {\n        return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;\n    }\n\n    /**\n     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for accelerated\n     * direct memory access.\n     */\n    public static boolean hasUnsafe() {\n        return UNSAFE_UNAVAILABILITY_CAUSE == null;\n    }\n\n    /**\n     * Return the reason (if any) why {@code sun.misc.Unsafe} was not available.\n     */\n    public static Throwable getUnsafeUnavailabilityCause() {\n        return UNSAFE_UNAVAILABILITY_CAUSE;\n    }\n\n    /**\n     * {@code true} if and only if the platform supports unaligned access.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Segmentation_fault#Bus_error\">Wikipedia on segfault</a>\n     */\n    public static boolean isUnaligned() {\n        return PlatformDependent0.isUnaligned();\n    }\n\n    /**\n     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user has not specified\n     * {@code -Dio.netty.noPreferDirect} option.\n     */\n    public static boolean directBufferPreferred() {\n        return DIRECT_BUFFER_PREFERRED;\n    }\n\n    /**\n     * Returns the maximum memory reserved for direct buffer allocation.\n     */\n    public static long maxDirectMemory() {\n        return DIRECT_MEMORY_LIMIT;\n    }\n\n    /**\n     * Returns the current memory reserved for direct buffer allocation.\n     * This method returns -1 in case that a value is not available.\n     *\n     * @see #maxDirectMemory()\n     */\n    public static long usedDirectMemory() {\n        return DIRECT_MEMORY_COUNTER != null ? DIRECT_MEMORY_COUNTER.get() : -1;\n    }\n\n    /**\n     * Returns the temporary directory.\n     */\n    public static File tmpdir() {\n        return TMPDIR;\n    }\n\n    /**\n     * Returns the bit mode of the current VM (usually 32 or 64.)\n     */\n    public static int bitMode() {\n        return BIT_MODE;\n    }\n\n    /**\n     * Return the address size of the OS.\n     * 4 (for 32 bits systems ) and 8 (for 64 bits systems).\n     */\n    public static int addressSize() {\n        return ADDRESS_SIZE;\n    }\n\n    public static long allocateMemory(long size) {\n        return PlatformDependent0.allocateMemory(size);\n    }\n\n    public static void freeMemory(long address) {\n        PlatformDependent0.freeMemory(address);\n    }\n\n    public static long reallocateMemory(long address, long newSize) {\n        return PlatformDependent0.reallocateMemory(address, newSize);\n    }\n\n    /**\n     * Raises an exception bypassing compiler checks for checked exceptions.\n     */\n    public static void throwException(Throwable t) {\n        if (hasUnsafe()) {\n            PlatformDependent0.throwException(t);\n        } else {\n            PlatformDependent.<RuntimeException>throwException0(t);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <E extends Throwable> void throwException0(Throwable t) throws E {\n        throw (E) t;\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<K, V>();\n    }\n\n    /**\n     * Creates a new fastest {@link LongCounter} implementation for the current platform.\n     */\n    public static LongCounter newLongCounter() {\n        if (javaVersion() >= 8) {\n            return new LongAdderCounter();\n        } else {\n            return new AtomicLongCounter();\n        }\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity) {\n        return new ConcurrentHashMap<K, V>(initialCapacity);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity, float loadFactor) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(\n            int initialCapacity, float loadFactor, int concurrencyLevel) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor, concurrencyLevel);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(Map<? extends K, ? extends V> map) {\n        return new ConcurrentHashMap<K, V>(map);\n    }\n\n    /**\n     * Try to deallocate the specified direct {@link ByteBuffer}. Please note this method does nothing if\n     * the current platform does not support this operation or the specified buffer is not a direct buffer.\n     */\n    public static void freeDirectBuffer(ByteBuffer buffer) {\n        CLEANER.freeDirectBuffer(buffer);\n    }\n\n    public static long directBufferAddress(ByteBuffer buffer) {\n        return PlatformDependent0.directBufferAddress(buffer);\n    }\n\n    public static ByteBuffer directBuffer(long memoryAddress, int size) {\n        if (PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            return PlatformDependent0.newDirectBuffer(memoryAddress, size);\n        }\n        throw new UnsupportedOperationException(\n                \"sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not available\");\n    }\n\n    public static Object getObject(Object object, long fieldOffset) {\n        return PlatformDependent0.getObject(object, fieldOffset);\n    }\n\n    public static int getInt(Object object, long fieldOffset) {\n        return PlatformDependent0.getInt(object, fieldOffset);\n    }\n\n    static void safeConstructPutInt(Object object, long fieldOffset, int value) {\n        PlatformDependent0.safeConstructPutInt(object, fieldOffset, value);\n    }\n\n    public static int getIntVolatile(long address) {\n        return PlatformDependent0.getIntVolatile(address);\n    }\n\n    public static void putIntOrdered(long adddress, int newValue) {\n        PlatformDependent0.putIntOrdered(adddress, newValue);\n    }\n\n    public static byte getByte(long address) {\n        return PlatformDependent0.getByte(address);\n    }\n\n    public static short getShort(long address) {\n        return PlatformDependent0.getShort(address);\n    }\n\n    public static int getInt(long address) {\n        return PlatformDependent0.getInt(address);\n    }\n\n    public static long getLong(long address) {\n        return PlatformDependent0.getLong(address);\n    }\n\n    public static byte getByte(byte[] data, int index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static byte getByte(byte[] data, long index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static short getShort(byte[] data, int index) {\n        return PlatformDependent0.getShort(data, index);\n    }\n\n    public static int getInt(byte[] data, int index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static int getInt(int[] data, long index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static long getLong(byte[] data, int index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    public static long getLong(long[] data, long index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    private static long getLongSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (long) bytes[offset] << 56 |\n                    ((long) bytes[offset + 1] & 0xff) << 48 |\n                    ((long) bytes[offset + 2] & 0xff) << 40 |\n                    ((long) bytes[offset + 3] & 0xff) << 32 |\n                    ((long) bytes[offset + 4] & 0xff) << 24 |\n                    ((long) bytes[offset + 5] & 0xff) << 16 |\n                    ((long) bytes[offset + 6] & 0xff) <<  8 |\n                    (long) bytes[offset + 7] & 0xff;\n        }\n        return (long) bytes[offset] & 0xff |\n                ((long) bytes[offset + 1] & 0xff) << 8 |\n                ((long) bytes[offset + 2] & 0xff) << 16 |\n                ((long) bytes[offset + 3] & 0xff) << 24 |\n                ((long) bytes[offset + 4] & 0xff) << 32 |\n                ((long) bytes[offset + 5] & 0xff) << 40 |\n                ((long) bytes[offset + 6] & 0xff) << 48 |\n                (long) bytes[offset + 7] << 56;\n    }\n\n    private static int getIntSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return bytes[offset] << 24 |\n                    (bytes[offset + 1] & 0xff) << 16 |\n                    (bytes[offset + 2] & 0xff) << 8 |\n                    bytes[offset + 3] & 0xff;\n        }\n        return bytes[offset] & 0xff |\n                (bytes[offset + 1] & 0xff) << 8 |\n                (bytes[offset + 2] & 0xff) << 16 |\n                bytes[offset + 3] << 24;\n    }\n\n    private static short getShortSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (short) (bytes[offset] << 8 | (bytes[offset + 1] & 0xff));\n        }\n        return (short) (bytes[offset] & 0xff | (bytes[offset + 1] << 8));\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiCompute(long, int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiCompute(CharSequence value, int offset, int hash) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return hash * HASH_CODE_C1 +\n                    // Low order int\n                    hashCodeAsciiSanitizeInt(value, offset + 4) * HASH_CODE_C2 +\n                    // High order int\n                    hashCodeAsciiSanitizeInt(value, offset);\n        }\n        return hash * HASH_CODE_C1 +\n                // Low order int\n                hashCodeAsciiSanitizeInt(value, offset) * HASH_CODE_C2 +\n                // High order int\n                hashCodeAsciiSanitizeInt(value, offset + 4);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeInt(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getInt call on a big endian machine\n            return (value.charAt(offset + 3) & 0x1f) |\n                   (value.charAt(offset + 2) & 0x1f) << 8 |\n                   (value.charAt(offset + 1) & 0x1f) << 16 |\n                   (value.charAt(offset) & 0x1f) << 24;\n        }\n        return (value.charAt(offset + 3) & 0x1f) << 24 |\n               (value.charAt(offset + 2) & 0x1f) << 16 |\n               (value.charAt(offset + 1) & 0x1f) << 8 |\n               (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(short)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeShort(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getShort call on a big endian machine\n            return (value.charAt(offset + 1) & 0x1f) |\n                    (value.charAt(offset) & 0x1f) << 8;\n        }\n        return (value.charAt(offset + 1) & 0x1f) << 8 |\n                (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(byte)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeByte(char value) {\n        return value & 0x1f;\n    }\n\n    public static void putByte(long address, byte value) {\n        PlatformDependent0.putByte(address, value);\n    }\n\n    public static void putShort(long address, short value) {\n        PlatformDependent0.putShort(address, value);\n    }\n\n    public static void putInt(long address, int value) {\n        PlatformDependent0.putInt(address, value);\n    }\n\n    public static void putLong(long address, long value) {\n        PlatformDependent0.putLong(address, value);\n    }\n\n    public static void putByte(byte[] data, int index, byte value) {\n        PlatformDependent0.putByte(data, index, value);\n    }\n\n    public static void putByte(Object data, long offset, byte value) {\n        PlatformDependent0.putByte(data, offset, value);\n    }\n\n    public static void putShort(byte[] data, int index, short value) {\n        PlatformDependent0.putShort(data, index, value);\n    }\n\n    public static void putInt(byte[] data, int index, int value) {\n        PlatformDependent0.putInt(data, index, value);\n    }\n\n    public static void putLong(byte[] data, int index, long value) {\n        PlatformDependent0.putLong(data, index, value);\n    }\n\n    public static void putObject(Object o, long offset, Object x) {\n        PlatformDependent0.putObject(o, offset, x);\n    }\n\n    public static long objectFieldOffset(Field field) {\n        return PlatformDependent0.objectFieldOffset(field);\n    }\n\n    public static void copyMemory(long srcAddr, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(srcAddr, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex, null, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex,\n                                      dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void copyMemory(long srcAddr, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(null, srcAddr, dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void setMemory(byte[] dst, int dstIndex, long bytes, byte value) {\n        PlatformDependent0.setMemory(dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, bytes, value);\n    }\n\n    public static void setMemory(long address, long bytes, byte value) {\n        PlatformDependent0.setMemory(address, bytes, value);\n    }\n\n    /**\n     * Allocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s allocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        incrementMemoryCounter(capacity);\n        try {\n            return PlatformDependent0.allocateDirectNoCleaner(capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(capacity);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * Reallocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s reallocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer reallocateDirectNoCleaner(ByteBuffer buffer, int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int len = capacity - buffer.capacity();\n        incrementMemoryCounter(len);\n        try {\n            return PlatformDependent0.reallocateDirectNoCleaner(buffer, capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(len);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * This method <strong>MUST</strong> only be called for {@link ByteBuffer}s that were allocated via\n     * {@link #allocateDirectNoCleaner(int)}.\n     */\n    public static void freeDirectNoCleaner(ByteBuffer buffer) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int capacity = buffer.capacity();\n        PlatformDependent0.freeMemory(PlatformDependent0.directBufferAddress(buffer));\n        decrementMemoryCounter(capacity);\n    }\n\n    public static boolean hasAlignDirectByteBuffer() {\n        return hasUnsafe() || PlatformDependent0.hasAlignSliceMethod();\n    }\n\n    public static ByteBuffer alignDirectBuffer(ByteBuffer buffer, int alignment) {\n        if (!buffer.isDirect()) {\n            throw new IllegalArgumentException(\"Cannot get aligned slice of non-direct byte buffer.\");\n        }\n        if (PlatformDependent0.hasAlignSliceMethod()) {\n            return PlatformDependent0.alignSlice(buffer, alignment);\n        }\n        if (hasUnsafe()) {\n            long address = directBufferAddress(buffer);\n            long aligned = align(address, alignment);\n            buffer.position((int) (aligned - address));\n            return buffer.slice();\n        }\n        // We don't have enough information to be able to align any buffers.\n        throw new UnsupportedOperationException(\"Cannot align direct buffer. \" +\n                \"Needs either Unsafe or ByteBuffer.alignSlice method available.\");\n    }\n\n    public static long align(long value, int alignment) {\n        return Pow2.align(value, alignment);\n    }\n\n    private static void incrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long newUsedMemory = DIRECT_MEMORY_COUNTER.addAndGet(capacity);\n            if (newUsedMemory > DIRECT_MEMORY_LIMIT) {\n                DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n                throw new OutOfDirectMemoryError(\"failed to allocate \" + capacity\n                        + \" byte(s) of direct memory (used: \" + (newUsedMemory - capacity)\n                        + \", max: \" + DIRECT_MEMORY_LIMIT + ')');\n            }\n        }\n    }\n\n    private static void decrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long usedMemory = DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n            assert usedMemory >= 0;\n        }\n    }\n\n    public static boolean useDirectBufferNoCleaner() {\n        return USE_DIRECT_BUFFER_NO_CLEANER;\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the\n     * parameters is performed.\n     *\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     */\n    public static boolean equals(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  equalsSafe(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equals(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Determine if a subsection of an array is zero.\n     * @param bytes The byte array.\n     * @param startPos The starting index (inclusive) in {@code bytes}.\n     * @param length The amount of bytes to check for zero.\n     * @return {@code false} if {@code bytes[startPos:startsPos+length)} contains a value other than zero.\n     */\n    public static boolean isZero(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                isZeroSafe(bytes, startPos, length) :\n                PlatformDependent0.isZero(bytes, startPos, length);\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality without leaking timing information.\n     * For performance reasons no bounds checking on the parameters is performed.\n     * <p>\n     * The {@code int} return type is intentional and is designed to allow cascading of constant time operations:\n     * <pre>\n     *     byte[] s1 = new {1, 2, 3};\n     *     byte[] s2 = new {1, 2, 3};\n     *     byte[] s3 = new {1, 2, 3};\n     *     byte[] s4 = new {4, 5, 6};\n     *     boolean equals = (equalsConstantTime(s1, 0, s2, 0, s1.length) &\n     *                       equalsConstantTime(s3, 0, s4, 0, s3.length)) != 0;\n     * </pre>\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     * @return {@code 0} if not equal. {@code 1} if equal.\n     */\n    public static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  ConstantTimeUtils.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * @param bytes The array which contains the data to hash.\n     * @param startPos What index to start generating a hash code in {@code bytes}\n     * @param length The amount of bytes that should be accounted for in the computation.\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                hashCodeAsciiSafe(bytes, startPos, length) :\n                PlatformDependent0.hashCodeAscii(bytes, startPos, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * <p>\n     * This method assumes that {@code bytes} is equivalent to a {@code byte[]} but just using {@link CharSequence}\n     * for storage. The upper most byte of each {@code char} from {@code bytes} is ignored.\n     * @param bytes The array which contains the data to hash (assumed to be equivalent to a {@code byte[]}).\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(CharSequence bytes) {\n        final int length = bytes.length();\n        final int remainingBytes = length & 7;\n        int hash = HASH_CODE_ASCII_SEED;\n        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large\n        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because\n        // of this we take special provisions to unroll the looping for these conditions.\n        if (length >= 32) {\n            for (int i = length - 8; i >= remainingBytes; i -= 8) {\n                hash = hashCodeAsciiCompute(bytes, i, hash);\n            }\n        } else if (length >= 8) {\n            hash = hashCodeAsciiCompute(bytes, length - 8, hash);\n            if (length >= 16) {\n                hash = hashCodeAsciiCompute(bytes, length - 16, hash);\n                if (length >= 24) {\n                    hash = hashCodeAsciiCompute(bytes, length - 24, hash);\n                }\n            }\n        }\n        if (remainingBytes == 0) {\n            return hash;\n        }\n        int offset = 0;\n        if (remainingBytes != 2 & remainingBytes != 4 & remainingBytes != 6) { // 1, 3, 5, 7\n            hash = hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));\n            offset = 1;\n        }\n        if (remainingBytes != 1 & remainingBytes != 4 & remainingBytes != 5) { // 2, 3, 6, 7\n            hash = hash * (offset == 0 ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitize(hashCodeAsciiSanitizeShort(bytes, offset));\n            offset += 2;\n        }\n        if (remainingBytes >= 4) { // 4, 5, 6, 7\n            return hash * ((offset == 0 | offset == 3) ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitizeInt(bytes, offset);\n        }\n        return hash;\n    }\n\n    private static final class Mpsc {\n        private static final boolean USE_MPSC_CHUNKED_ARRAY_QUEUE;\n\n        private Mpsc() {\n        }\n\n        static {\n            Object unsafe = null;\n            if (hasUnsafe()) {\n                // jctools goes through its own process of initializing unsafe; of\n                // course, this requires permissions which might not be granted to calling code, so we\n                // must mark this block as privileged too\n                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        // force JCTools to initialize unsafe\n                        return UnsafeAccess.UNSAFE;\n                    }\n                });\n            }\n\n            if (unsafe == null) {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: unavailable\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = false;\n            } else {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: available\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = true;\n            }\n        }\n\n        static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n            // Calculate the max capacity which can not be bigger than MAX_ALLOWED_MPSC_CAPACITY.\n            // This is forced by the MpscChunkedArrayQueue implementation as will try to round it\n            // up to the next power of two and so will overflow otherwise.\n            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);\n            return newChunkedMpscQueue(MPSC_CHUNK_SIZE, capacity);\n        }\n\n        static <T> Queue<T> newChunkedMpscQueue(final int chunkSize, final int capacity) {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(chunkSize, capacity)\n                    : new MpscChunkedAtomicArrayQueue<T>(chunkSize, capacity);\n        }\n\n        static <T> Queue<T> newMpscQueue() {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE)\n                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);\n        }\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * @return A MPSC queue which may be unbounded.\n     */\n    public static <T> Queue<T> newMpscQueue() {\n        return Mpsc.newMpscQueue();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n        return Mpsc.newMpscQueue(maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * The queue will grow and shrink its capacity in units of the given chunk size.\n     */\n    public static <T> Queue<T> newMpscQueue(final int chunkSize, final int maxCapacity) {\n        return Mpsc.newChunkedMpscQueue(chunkSize, maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for single producer (one thread!) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newSpscQueue() {\n        return hasUnsafe() ? new SpscLinkedQueue<T>() : new SpscLinkedAtomicQueue<T>();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!) with the given fixes {@code capacity}.\n     */\n    public static <T> Queue<T> newFixedMpscQueue(int capacity) {\n        return hasUnsafe() ? new MpscArrayQueue<T>(capacity) : new MpscAtomicArrayQueue<T>(capacity);\n    }\n\n    /**\n     * Return the {@link ClassLoader} for the given {@link Class}.\n     */\n    public static ClassLoader getClassLoader(final Class<?> clazz) {\n        return PlatformDependent0.getClassLoader(clazz);\n    }\n\n    /**\n     * Return the context {@link ClassLoader} for the current {@link Thread}.\n     */\n    public static ClassLoader getContextClassLoader() {\n        return PlatformDependent0.getContextClassLoader();\n    }\n\n    /**\n     * Return the system {@link ClassLoader}.\n     */\n    public static ClassLoader getSystemClassLoader() {\n        return PlatformDependent0.getSystemClassLoader();\n    }\n\n    /**\n     * Returns a new concurrent {@link Deque}.\n     */\n    @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n    public static <C> Deque<C> newConcurrentDeque() {\n        if (javaVersion() < 7) {\n            return new LinkedBlockingDeque<C>();\n        } else {\n            return new ConcurrentLinkedDeque<C>();\n        }\n    }\n\n    /**\n     * Return a {@link Random} which is not-threadsafe and so can only be used from the same thread.\n     */\n    public static Random threadLocalRandom() {\n        return RANDOM_PROVIDER.current();\n    }\n\n    private static boolean isWindows0() {\n        boolean windows = \"windows\".equals(NORMALIZED_OS);\n        if (windows) {\n            logger.debug(\"Platform: Windows\");\n        }\n        return windows;\n    }\n\n    private static boolean isOsx0() {\n        boolean osx = \"osx\".equals(NORMALIZED_OS);\n        if (osx) {\n            logger.debug(\"Platform: MacOS\");\n        }\n        return osx;\n    }\n\n    private static boolean maybeSuperUser0() {\n        String username = SystemPropertyUtil.get(\"user.name\");\n        if (isWindows()) {\n            return \"Administrator\".equals(username);\n        }\n        // Check for root and toor as some BSDs have a toor user that is basically the same as root.\n        return \"root\".equals(username) || \"toor\".equals(username);\n    }\n\n    private static Throwable unsafeUnavailabilityCause0() {\n        if (isAndroid()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (Android)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (Android)\");\n        }\n\n        if (isIkvmDotNet()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n        }\n\n        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();\n        if (cause != null) {\n            return cause;\n        }\n\n        try {\n            boolean hasUnsafe = PlatformDependent0.hasUnsafe();\n            logger.debug(\"sun.misc.Unsafe: {}\", hasUnsafe ? \"available\" : \"unavailable\");\n            return hasUnsafe ? null : PlatformDependent0.getUnsafeUnavailabilityCause();\n        } catch (Throwable t) {\n            logger.trace(\"Could not determine if Unsafe is available\", t);\n            // Probably failed to initialize PlatformDependent0.\n            return new UnsupportedOperationException(\"Could not determine if Unsafe is available\", t);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is either <a href=\"https://developer.ibm.com/javasdk/\">IBM J9</a> or\n     * <a href=\"https://www.eclipse.org/openj9/\">Eclipse OpenJ9</a>, {@code false} otherwise.\n     */\n    public static boolean isJ9Jvm() {\n        return IS_J9_JVM;\n    }\n\n    private static boolean isJ9Jvm0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n        return vmName.startsWith(\"ibm j9\") || vmName.startsWith(\"eclipse openj9\");\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is <a href=\"https://www.ikvm.net\">IKVM.NET</a>, {@code false} otherwise.\n     */\n    public static boolean isIkvmDotNet() {\n        return IS_IVKVM_DOT_NET;\n    }\n\n    private static boolean isIkvmDotNet0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toUpperCase(Locale.US);\n        return vmName.equals(\"IKVM.NET\");\n    }\n\n    /**\n     * Compute an estimate of the maximum amount of direct memory available to this JVM.\n     * <p>\n     * The computation is not cached, so you probably want to use {@link #maxDirectMemory()} instead.\n     * <p>\n     * This will produce debug log output when called.\n     *\n     * @return The estimated max direct memory, in bytes.\n     */\n    public static long estimateMaxDirectMemory() {\n        long maxDirectMemory = 0;\n\n        ClassLoader systemClassLoader = null;\n        try {\n            systemClassLoader = getSystemClassLoader();\n\n            // When using IBM J9 / Eclipse OpenJ9 we should not use VM.maxDirectMemory() as it not reflects the\n            // correct value.\n            // See:\n            //  - https://github.com/netty/netty/issues/7654\n            String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n            if (!vmName.startsWith(\"ibm j9\") &&\n                    // https://github.com/eclipse/openj9/blob/openj9-0.8.0/runtime/include/vendor_version.h#L53\n                    !vmName.startsWith(\"eclipse openj9\")) {\n                // Try to get from sun.misc.VM.maxDirectMemory() which should be most accurate.\n                Class<?> vmClass = Class.forName(\"sun.misc.VM\", true, systemClassLoader);\n                Method m = vmClass.getDeclaredMethod(\"maxDirectMemory\");\n                maxDirectMemory = ((Number) m.invoke(null)).longValue();\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory > 0) {\n            return maxDirectMemory;\n        }\n\n        try {\n            // Now try to get the JVM option (-XX:MaxDirectMemorySize) and parse it.\n            // Note that we are using reflection because Android doesn't have these classes.\n            Class<?> mgmtFactoryClass = Class.forName(\n                    \"java.lang.management.ManagementFactory\", true, systemClassLoader);\n            Class<?> runtimeClass = Class.forName(\n                    \"java.lang.management.RuntimeMXBean\", true, systemClassLoader);\n\n            Object runtime = mgmtFactoryClass.getDeclaredMethod(\"getRuntimeMXBean\").invoke(null);\n\n            @SuppressWarnings(\"unchecked\")\n            List<String> vmArgs = (List<String>) runtimeClass.getDeclaredMethod(\"getInputArguments\").invoke(runtime);\n            for (int i = vmArgs.size() - 1; i >= 0; i --) {\n                Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN.matcher(vmArgs.get(i));\n                if (!m.matches()) {\n                    continue;\n                }\n\n                maxDirectMemory = Long.parseLong(m.group(1));\n                switch (m.group(2).charAt(0)) {\n                    case 'k': case 'K':\n                        maxDirectMemory *= 1024;\n                        break;\n                    case 'm': case 'M':\n                        maxDirectMemory *= 1024 * 1024;\n                        break;\n                    case 'g': case 'G':\n                        maxDirectMemory *= 1024 * 1024 * 1024;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory <= 0) {\n            maxDirectMemory = Runtime.getRuntime().maxMemory();\n            logger.debug(\"maxDirectMemory: {} bytes (maybe)\", maxDirectMemory);\n        } else {\n            logger.debug(\"maxDirectMemory: {} bytes\", maxDirectMemory);\n        }\n\n        return maxDirectMemory;\n    }\n\n    private static File tmpdir0() {\n        File f;\n        try {\n            f = toDirectory(SystemPropertyUtil.get(\"io.netty.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {}\", f);\n                return f;\n            }\n\n            f = toDirectory(SystemPropertyUtil.get(\"java.io.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {} (java.io.tmpdir)\", f);\n                return f;\n            }\n\n            // This shouldn't happen, but just in case ..\n            if (isWindows()) {\n                f = toDirectory(System.getenv(\"TEMP\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} (%TEMP%)\", f);\n                    return f;\n                }\n\n                String userprofile = System.getenv(\"USERPROFILE\");\n                if (userprofile != null) {\n                    f = toDirectory(userprofile + \"\\\\AppData\\\\Local\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\AppData\\\\Local\\\\Temp)\", f);\n                        return f;\n                    }\n\n                    f = toDirectory(userprofile + \"\\\\Local Settings\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\Local Settings\\\\Temp)\", f);\n                        return f;\n                    }\n                }\n            } else {\n                f = toDirectory(System.getenv(\"TMPDIR\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} ($TMPDIR)\", f);\n                    return f;\n                }\n            }\n        } catch (Throwable ignored) {\n            // Environment variable inaccessible\n        }\n\n        // Last resort.\n        if (isWindows()) {\n            f = new File(\"C:\\\\Windows\\\\Temp\");\n        } else {\n            f = new File(\"/tmp\");\n        }\n\n        logger.warn(\"Failed to get the temporary directory; falling back to: {}\", f);\n        return f;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static File toDirectory(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        File f = new File(path);\n        f.mkdirs();\n\n        if (!f.isDirectory()) {\n            return null;\n        }\n\n        try {\n            return f.getAbsoluteFile();\n        } catch (Exception ignored) {\n            return f;\n        }\n    }\n\n    private static int bitMode0() {\n        // Check user-specified bit mode first.\n        int bitMode = SystemPropertyUtil.getInt(\"io.netty.bitMode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {}\", bitMode);\n            return bitMode;\n        }\n\n        // And then the vendor specific ones which is probably most reliable.\n        bitMode = SystemPropertyUtil.getInt(\"sun.arch.data.model\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (sun.arch.data.model)\", bitMode);\n            return bitMode;\n        }\n        bitMode = SystemPropertyUtil.getInt(\"com.ibm.vm.bitmode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (com.ibm.vm.bitmode)\", bitMode);\n            return bitMode;\n        }\n\n        // os.arch also gives us a good hint.\n        String arch = SystemPropertyUtil.get(\"os.arch\", \"\").toLowerCase(Locale.US).trim();\n        if (\"amd64\".equals(arch) || \"x86_64\".equals(arch)) {\n            bitMode = 64;\n        } else if (\"i386\".equals(arch) || \"i486\".equals(arch) || \"i586\".equals(arch) || \"i686\".equals(arch)) {\n            bitMode = 32;\n        }\n\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (os.arch: {})\", bitMode, arch);\n        }\n\n        // Last resort: guess from VM name and then fall back to most common 64-bit mode.\n        String vm = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase(Locale.US);\n        Pattern bitPattern = Pattern.compile(\"([1-9][0-9]+)-?bit\");\n        Matcher m = bitPattern.matcher(vm);\n        if (m.find()) {\n            return Integer.parseInt(m.group(1));\n        } else {\n            return 64;\n        }\n    }\n\n    private static int addressSize0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.addressSize();\n    }\n\n    private static long byteArrayBaseOffset0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.byteArrayBaseOffset();\n    }\n\n    private static boolean equalsSafe(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        final int end = startPos1 + length;\n        for (; startPos1 < end; ++startPos1, ++startPos2) {\n            if (bytes1[startPos1] != bytes2[startPos2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isZeroSafe(byte[] bytes, int startPos, int length) {\n        final int end = startPos + length;\n        for (; startPos < end; ++startPos) {\n            if (bytes[startPos] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Package private for testing purposes only!\n     */\n    static int hashCodeAsciiSafe(byte[] bytes, int startPos, int length) {\n        int hash = HASH_CODE_ASCII_SEED;\n        final int remainingBytes = length & 7;\n        final int end = startPos + remainingBytes;\n        for (int i = startPos - 8 + length; i >= end; i -= 8) {\n            hash = PlatformDependent0.hashCodeAsciiCompute(getLongSafe(bytes, i), hash);\n        }\n        switch(remainingBytes) {\n        case 7:\n            return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                          * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1)))\n                          * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 3));\n        case 6:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos)))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 2));\n        case 5:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 1));\n        case 4:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos));\n        case 3:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1));\n        case 2:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos));\n        case 1:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]);\n        default:\n            return hash;\n        }\n    }\n\n    public static String normalizedArch() {\n        return NORMALIZED_ARCH;\n    }\n\n    public static String normalizedOs() {\n        return NORMALIZED_OS;\n    }\n\n    public static Set<String> normalizedLinuxClassifiers() {\n        return LINUX_OS_CLASSIFIERS;\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        if (directory == null) {\n            return File.createTempFile(prefix, suffix);\n        }\n        File file = File.createTempFile(prefix, suffix, directory);\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        file.setReadable(false, false);\n        file.setReadable(true, true);\n        return file;\n    }\n\n    /**\n     * Adds only those classifier strings to <tt>dest</tt> which are present in <tt>allowed</tt>.\n     *\n     * @param allowed          allowed classifiers\n     * @param dest             destination set\n     * @param maybeClassifiers potential classifiers to add\n     */\n    private static void addClassifier(Set<String> allowed, Set<String> dest, String... maybeClassifiers) {\n        for (String id : maybeClassifiers) {\n            if (allowed.contains(id)) {\n                dest.add(id);\n            }\n        }\n    }\n\n    private static String normalizeOsReleaseVariableValue(String value) {\n        // Variable assignment values may be enclosed in double or single quotes.\n        return value.trim().replaceAll(\"[\\\"']\", \"\");\n    }\n\n    private static String normalize(String value) {\n        return value.toLowerCase(Locale.US).replaceAll(\"[^a-z0-9]+\", \"\");\n    }\n\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static String normalizeOs(String value) {\n        value = normalize(value);\n        if (value.startsWith(\"aix\")) {\n            return \"aix\";\n        }\n        if (value.startsWith(\"hpux\")) {\n            return \"hpux\";\n        }\n        if (value.startsWith(\"os400\")) {\n            // Avoid the names such as os4000\n            if (value.length() <= 5 || !Character.isDigit(value.charAt(5))) {\n                return \"os400\";\n            }\n        }\n        if (value.startsWith(\"linux\")) {\n            return \"linux\";\n        }\n        if (value.startsWith(\"macosx\") || value.startsWith(\"osx\") || value.startsWith(\"darwin\")) {\n            return \"osx\";\n        }\n        if (value.startsWith(\"freebsd\")) {\n            return \"freebsd\";\n        }\n        if (value.startsWith(\"openbsd\")) {\n            return \"openbsd\";\n        }\n        if (value.startsWith(\"netbsd\")) {\n            return \"netbsd\";\n        }\n        if (value.startsWith(\"solaris\") || value.startsWith(\"sunos\")) {\n            return \"sunos\";\n        }\n        if (value.startsWith(\"windows\")) {\n            return \"windows\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static final class AtomicLongCounter extends AtomicLong implements LongCounter {\n        private static final long serialVersionUID = 4074772784610639305L;\n\n        @Override\n        public void add(long delta) {\n            addAndGet(delta);\n        }\n\n        @Override\n        public void increment() {\n            incrementAndGet();\n        }\n\n        @Override\n        public void decrement() {\n            decrementAndGet();\n        }\n\n        @Override\n        public long value() {\n            return get();\n        }\n    }\n\n    private interface ThreadLocalRandomProvider {\n        Random current();\n    }\n\n    private PlatformDependent() {\n        // only static method supported\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.util.internal;\n\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport org.jctools.queues.MpscArrayQueue;\nimport org.jctools.queues.MpscChunkedArrayQueue;\nimport org.jctools.queues.MpscUnboundedArrayQueue;\nimport org.jctools.queues.SpscLinkedQueue;\nimport org.jctools.queues.atomic.MpscAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscChunkedAtomicArrayQueue;\nimport org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;\nimport org.jctools.queues.atomic.SpscLinkedAtomicQueue;\nimport org.jctools.util.Pow2;\nimport org.jctools.util.UnsafeAccess;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.file.Files;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_ASCII_SEED;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C1;\nimport static io.netty.util.internal.PlatformDependent0.HASH_CODE_C2;\nimport static io.netty.util.internal.PlatformDependent0.hashCodeAsciiSanitize;\nimport static io.netty.util.internal.PlatformDependent0.unalignedAccess;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n/**\n * Utility that detects various properties specific to the current runtime\n * environment, such as Java version and the availability of the\n * {@code sun.misc.Unsafe} object.\n * <p>\n * You can disable the use of {@code sun.misc.Unsafe} if you specify\n * the system property <strong>io.netty.noUnsafe</strong>.\n */\npublic final class PlatformDependent {\n\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent.class);\n\n    private static final Pattern MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN = Pattern.compile(\n            \"\\\\s*-XX:MaxDirectMemorySize\\\\s*=\\\\s*([0-9]+)\\\\s*([kKmMgG]?)\\\\s*$\");\n\n    private static final boolean MAYBE_SUPER_USER;\n\n    private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();\n\n    private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();\n    private static final boolean DIRECT_BUFFER_PREFERRED;\n    private static final long MAX_DIRECT_MEMORY = estimateMaxDirectMemory();\n\n    private static final int MPSC_CHUNK_SIZE =  1024;\n    private static final int MIN_MAX_MPSC_CAPACITY =  MPSC_CHUNK_SIZE * 2;\n    private static final int MAX_ALLOWED_MPSC_CAPACITY = Pow2.MAX_POW2;\n\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n\n    private static final File TMPDIR = tmpdir0();\n\n    private static final int BIT_MODE = bitMode0();\n    private static final String NORMALIZED_ARCH = normalizeArch(SystemPropertyUtil.get(\"os.arch\", \"\"));\n    private static final String NORMALIZED_OS = normalizeOs(SystemPropertyUtil.get(\"os.name\", \"\"));\n\n    // keep in sync with maven's pom.xml via os.detection.classifierWithLikes!\n    private static final String[] ALLOWED_LINUX_OS_CLASSIFIERS = {\"fedora\", \"suse\", \"arch\"};\n    private static final Set<String> LINUX_OS_CLASSIFIERS;\n\n    private static final boolean IS_WINDOWS = isWindows0();\n    private static final boolean IS_OSX = isOsx0();\n    private static final boolean IS_J9_JVM = isJ9Jvm0();\n    private static final boolean IS_IVKVM_DOT_NET = isIkvmDotNet0();\n\n    private static final int ADDRESS_SIZE = addressSize0();\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    private static final Cleaner CLEANER;\n    private static final int UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD;\n    // For specifications, see https://www.freedesktop.org/software/systemd/man/os-release.html\n    private static final String[] OS_RELEASE_FILES = {\"/etc/os-release\", \"/usr/lib/os-release\"};\n    private static final String LINUX_ID_PREFIX = \"ID=\";\n    private static final String LINUX_ID_LIKE_PREFIX = \"ID_LIKE=\";\n    public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n\n    private static final Cleaner NOOP = new Cleaner() {\n        @Override\n        public void freeDirectBuffer(ByteBuffer buffer) {\n            // NOOP\n        }\n    };\n\n    static {\n        if (javaVersion() >= 7) {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n                public Random current() {\n                    return java.util.concurrent.ThreadLocalRandom.current();\n                }\n            };\n        } else {\n            RANDOM_PROVIDER = new ThreadLocalRandomProvider() {\n                @Override\n                public Random current() {\n                    return ThreadLocalRandom.current();\n                }\n            };\n        }\n\n        // Here is how the system property is used:\n        //\n        // * <  0  - Don't use cleaner, and inherit max direct memory from java. In this case the\n        //           \"practical max direct memory\" would be 2 * max memory as defined by the JDK.\n        // * == 0  - Use cleaner, Netty will not enforce max memory, and instead will defer to JDK.\n        // * >  0  - Don't use cleaner. This will limit Netty's total direct memory\n        //           (note: that JDK's direct memory limit is independent of this).\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = MAX_DIRECT_MEMORY;\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        logger.debug(\"-Dio.netty.maxDirectMemory: {} bytes\", maxDirectMemory);\n        DIRECT_MEMORY_LIMIT = maxDirectMemory >= 1 ? maxDirectMemory : MAX_DIRECT_MEMORY;\n\n        int tryAllocateUninitializedArray =\n                SystemPropertyUtil.getInt(\"io.netty.uninitializedArrayAllocationThreshold\", 1024);\n        UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD = javaVersion() >= 9 && PlatformDependent0.hasAllocateArrayMethod() ?\n                tryAllocateUninitializedArray : -1;\n        logger.debug(\"-Dio.netty.uninitializedArrayAllocationThreshold: {}\", UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD);\n\n        MAYBE_SUPER_USER = maybeSuperUser0();\n\n        if (!isAndroid()) {\n            // only direct to method if we are not running on android.\n            // See https://github.com/netty/netty/issues/2604\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n\n        // We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.\n        DIRECT_BUFFER_PREFERRED = CLEANER != NOOP\n                                  && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"-Dio.netty.noPreferDirect: {}\", !DIRECT_BUFFER_PREFERRED);\n        }\n\n        /*\n         * We do not want to log this message if unsafe is explicitly disabled. Do not remove the explicit no unsafe\n         * guard.\n         */\n        if (CLEANER == NOOP && !PlatformDependent0.isExplicitNoUnsafe()) {\n            logger.info(\n                    \"Your platform does not provide complete low-level API for accessing direct buffers reliably. \" +\n                    \"Unless explicitly requested, heap buffer will always be preferred to avoid potential system \" +\n                    \"instability.\");\n        }\n\n        final Set<String> allowedClassifiers = Collections.unmodifiableSet(\n                new HashSet<String>(Arrays.asList(ALLOWED_LINUX_OS_CLASSIFIERS)));\n        final Set<String> availableClassifiers = new LinkedHashSet<String>();\n        for (final String osReleaseFileName : OS_RELEASE_FILES) {\n            final File file = new File(osReleaseFileName);\n            boolean found = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n                @Override\n                public Boolean run() {\n                    try {\n                        if (file.exists()) {\n                            BufferedReader reader = null;\n                            try {\n                                reader = new BufferedReader(\n                                        new InputStreamReader(\n                                                new FileInputStream(file), CharsetUtil.UTF_8));\n\n                                String line;\n                                while ((line = reader.readLine()) != null) {\n                                    if (line.startsWith(LINUX_ID_PREFIX)) {\n                                        String id = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, id);\n                                    } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n                                        line = normalizeOsReleaseVariableValue(\n                                                line.substring(LINUX_ID_LIKE_PREFIX.length()));\n                                        addClassifier(allowedClassifiers, availableClassifiers, line.split(\"[ ]+\"));\n                                    }\n                                }\n                            } catch (SecurityException e) {\n                                logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n                            } catch (IOException e) {\n                                logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                            } finally {\n                                if (reader != null) {\n                                    try {\n                                        reader.close();\n                                    } catch (IOException ignored) {\n                                        // Ignore\n                                    }\n                                }\n                            }\n                            // specification states we should only fall back if /etc/os-release does not exist\n                            return true;\n                        }\n                    } catch (SecurityException e) {\n                        logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n                    }\n                    return false;\n                }\n            });\n\n            if (found) {\n                break;\n            }\n        }\n        LINUX_OS_CLASSIFIERS = Collections.unmodifiableSet(availableClassifiers);\n    }\n\n    public static long byteArrayBaseOffset() {\n        return BYTE_ARRAY_BASE_OFFSET;\n    }\n\n    public static boolean hasDirectBufferNoCleanerConstructor() {\n        return PlatformDependent0.hasDirectBufferNoCleanerConstructor();\n    }\n\n    public static byte[] allocateUninitializedArray(int size) {\n        return UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD < 0 || UNINITIALIZED_ARRAY_ALLOCATION_THRESHOLD > size ?\n                new byte[size] : PlatformDependent0.allocateUninitializedArray(size);\n    }\n\n    /**\n     * Returns {@code true} if and only if the current platform is Android\n     */\n    public static boolean isAndroid() {\n        return PlatformDependent0.isAndroid();\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on Windows\n     */\n    public static boolean isWindows() {\n        return IS_WINDOWS;\n    }\n\n    /**\n     * Return {@code true} if the JVM is running on OSX / MacOS\n     */\n    public static boolean isOsx() {\n        return IS_OSX;\n    }\n\n    /**\n     * Return {@code true} if the current user may be a super-user. Be aware that this is just an hint and so it may\n     * return false-positives.\n     */\n    public static boolean maybeSuperUser() {\n        return MAYBE_SUPER_USER;\n    }\n\n    /**\n     * Return the version of Java under which this library is used.\n     */\n    public static int javaVersion() {\n        return PlatformDependent0.javaVersion();\n    }\n\n    /**\n     * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default.\n     */\n    public static boolean canEnableTcpNoDelayByDefault() {\n        return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;\n    }\n\n    /**\n     * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for accelerated\n     * direct memory access.\n     */\n    public static boolean hasUnsafe() {\n        return UNSAFE_UNAVAILABILITY_CAUSE == null;\n    }\n\n    /**\n     * Return the reason (if any) why {@code sun.misc.Unsafe} was not available.\n     */\n    public static Throwable getUnsafeUnavailabilityCause() {\n        return UNSAFE_UNAVAILABILITY_CAUSE;\n    }\n\n    /**\n     * {@code true} if and only if the platform supports unaligned access.\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Segmentation_fault#Bus_error\">Wikipedia on segfault</a>\n     */\n    public static boolean isUnaligned() {\n        return PlatformDependent0.isUnaligned();\n    }\n\n    /**\n     * Returns {@code true} if the platform has reliable low-level direct buffer access API and a user has not specified\n     * {@code -Dio.netty.noPreferDirect} option.\n     */\n    public static boolean directBufferPreferred() {\n        return DIRECT_BUFFER_PREFERRED;\n    }\n\n    /**\n     * Returns the maximum memory reserved for direct buffer allocation.\n     */\n    public static long maxDirectMemory() {\n        return DIRECT_MEMORY_LIMIT;\n    }\n\n    /**\n     * Returns the current memory reserved for direct buffer allocation.\n     * This method returns -1 in case that a value is not available.\n     *\n     * @see #maxDirectMemory()\n     */\n    public static long usedDirectMemory() {\n        return DIRECT_MEMORY_COUNTER != null ? DIRECT_MEMORY_COUNTER.get() : -1;\n    }\n\n    /**\n     * Returns the temporary directory.\n     */\n    public static File tmpdir() {\n        return TMPDIR;\n    }\n\n    /**\n     * Returns the bit mode of the current VM (usually 32 or 64.)\n     */\n    public static int bitMode() {\n        return BIT_MODE;\n    }\n\n    /**\n     * Return the address size of the OS.\n     * 4 (for 32 bits systems ) and 8 (for 64 bits systems).\n     */\n    public static int addressSize() {\n        return ADDRESS_SIZE;\n    }\n\n    public static long allocateMemory(long size) {\n        return PlatformDependent0.allocateMemory(size);\n    }\n\n    public static void freeMemory(long address) {\n        PlatformDependent0.freeMemory(address);\n    }\n\n    public static long reallocateMemory(long address, long newSize) {\n        return PlatformDependent0.reallocateMemory(address, newSize);\n    }\n\n    /**\n     * Raises an exception bypassing compiler checks for checked exceptions.\n     */\n    public static void throwException(Throwable t) {\n        if (hasUnsafe()) {\n            PlatformDependent0.throwException(t);\n        } else {\n            PlatformDependent.<RuntimeException>throwException0(t);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <E extends Throwable> void throwException0(Throwable t) throws E {\n        throw (E) t;\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap() {\n        return new ConcurrentHashMap<K, V>();\n    }\n\n    /**\n     * Creates a new fastest {@link LongCounter} implementation for the current platform.\n     */\n    public static LongCounter newLongCounter() {\n        if (javaVersion() >= 8) {\n            return new LongAdderCounter();\n        } else {\n            return new AtomicLongCounter();\n        }\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity) {\n        return new ConcurrentHashMap<K, V>(initialCapacity);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(int initialCapacity, float loadFactor) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(\n            int initialCapacity, float loadFactor, int concurrencyLevel) {\n        return new ConcurrentHashMap<K, V>(initialCapacity, loadFactor, concurrencyLevel);\n    }\n\n    /**\n     * Creates a new fastest {@link ConcurrentMap} implementation for the current platform.\n     */\n    public static <K, V> ConcurrentMap<K, V> newConcurrentHashMap(Map<? extends K, ? extends V> map) {\n        return new ConcurrentHashMap<K, V>(map);\n    }\n\n    /**\n     * Try to deallocate the specified direct {@link ByteBuffer}. Please note this method does nothing if\n     * the current platform does not support this operation or the specified buffer is not a direct buffer.\n     */\n    public static void freeDirectBuffer(ByteBuffer buffer) {\n        CLEANER.freeDirectBuffer(buffer);\n    }\n\n    public static long directBufferAddress(ByteBuffer buffer) {\n        return PlatformDependent0.directBufferAddress(buffer);\n    }\n\n    public static ByteBuffer directBuffer(long memoryAddress, int size) {\n        if (PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            return PlatformDependent0.newDirectBuffer(memoryAddress, size);\n        }\n        throw new UnsupportedOperationException(\n                \"sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not available\");\n    }\n\n    public static Object getObject(Object object, long fieldOffset) {\n        return PlatformDependent0.getObject(object, fieldOffset);\n    }\n\n    public static int getInt(Object object, long fieldOffset) {\n        return PlatformDependent0.getInt(object, fieldOffset);\n    }\n\n    static void safeConstructPutInt(Object object, long fieldOffset, int value) {\n        PlatformDependent0.safeConstructPutInt(object, fieldOffset, value);\n    }\n\n    public static int getIntVolatile(long address) {\n        return PlatformDependent0.getIntVolatile(address);\n    }\n\n    public static void putIntOrdered(long adddress, int newValue) {\n        PlatformDependent0.putIntOrdered(adddress, newValue);\n    }\n\n    public static byte getByte(long address) {\n        return PlatformDependent0.getByte(address);\n    }\n\n    public static short getShort(long address) {\n        return PlatformDependent0.getShort(address);\n    }\n\n    public static int getInt(long address) {\n        return PlatformDependent0.getInt(address);\n    }\n\n    public static long getLong(long address) {\n        return PlatformDependent0.getLong(address);\n    }\n\n    public static byte getByte(byte[] data, int index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static byte getByte(byte[] data, long index) {\n        return PlatformDependent0.getByte(data, index);\n    }\n\n    public static short getShort(byte[] data, int index) {\n        return PlatformDependent0.getShort(data, index);\n    }\n\n    public static int getInt(byte[] data, int index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static int getInt(int[] data, long index) {\n        return PlatformDependent0.getInt(data, index);\n    }\n\n    public static long getLong(byte[] data, int index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    public static long getLong(long[] data, long index) {\n        return PlatformDependent0.getLong(data, index);\n    }\n\n    private static long getLongSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (long) bytes[offset] << 56 |\n                    ((long) bytes[offset + 1] & 0xff) << 48 |\n                    ((long) bytes[offset + 2] & 0xff) << 40 |\n                    ((long) bytes[offset + 3] & 0xff) << 32 |\n                    ((long) bytes[offset + 4] & 0xff) << 24 |\n                    ((long) bytes[offset + 5] & 0xff) << 16 |\n                    ((long) bytes[offset + 6] & 0xff) <<  8 |\n                    (long) bytes[offset + 7] & 0xff;\n        }\n        return (long) bytes[offset] & 0xff |\n                ((long) bytes[offset + 1] & 0xff) << 8 |\n                ((long) bytes[offset + 2] & 0xff) << 16 |\n                ((long) bytes[offset + 3] & 0xff) << 24 |\n                ((long) bytes[offset + 4] & 0xff) << 32 |\n                ((long) bytes[offset + 5] & 0xff) << 40 |\n                ((long) bytes[offset + 6] & 0xff) << 48 |\n                (long) bytes[offset + 7] << 56;\n    }\n\n    private static int getIntSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return bytes[offset] << 24 |\n                    (bytes[offset + 1] & 0xff) << 16 |\n                    (bytes[offset + 2] & 0xff) << 8 |\n                    bytes[offset + 3] & 0xff;\n        }\n        return bytes[offset] & 0xff |\n                (bytes[offset + 1] & 0xff) << 8 |\n                (bytes[offset + 2] & 0xff) << 16 |\n                bytes[offset + 3] << 24;\n    }\n\n    private static short getShortSafe(byte[] bytes, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return (short) (bytes[offset] << 8 | (bytes[offset + 1] & 0xff));\n        }\n        return (short) (bytes[offset] & 0xff | (bytes[offset + 1] << 8));\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiCompute(long, int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiCompute(CharSequence value, int offset, int hash) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            return hash * HASH_CODE_C1 +\n                    // Low order int\n                    hashCodeAsciiSanitizeInt(value, offset + 4) * HASH_CODE_C2 +\n                    // High order int\n                    hashCodeAsciiSanitizeInt(value, offset);\n        }\n        return hash * HASH_CODE_C1 +\n                // Low order int\n                hashCodeAsciiSanitizeInt(value, offset) * HASH_CODE_C2 +\n                // High order int\n                hashCodeAsciiSanitizeInt(value, offset + 4);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(int)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeInt(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getInt call on a big endian machine\n            return (value.charAt(offset + 3) & 0x1f) |\n                   (value.charAt(offset + 2) & 0x1f) << 8 |\n                   (value.charAt(offset + 1) & 0x1f) << 16 |\n                   (value.charAt(offset) & 0x1f) << 24;\n        }\n        return (value.charAt(offset + 3) & 0x1f) << 24 |\n               (value.charAt(offset + 2) & 0x1f) << 16 |\n               (value.charAt(offset + 1) & 0x1f) << 8 |\n               (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(short)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeShort(CharSequence value, int offset) {\n        if (BIG_ENDIAN_NATIVE_ORDER) {\n            // mimic a unsafe.getShort call on a big endian machine\n            return (value.charAt(offset + 1) & 0x1f) |\n                    (value.charAt(offset) & 0x1f) << 8;\n        }\n        return (value.charAt(offset + 1) & 0x1f) << 8 |\n                (value.charAt(offset) & 0x1f);\n    }\n\n    /**\n     * Identical to {@link PlatformDependent0#hashCodeAsciiSanitize(byte)} but for {@link CharSequence}.\n     */\n    private static int hashCodeAsciiSanitizeByte(char value) {\n        return value & 0x1f;\n    }\n\n    public static void putByte(long address, byte value) {\n        PlatformDependent0.putByte(address, value);\n    }\n\n    public static void putShort(long address, short value) {\n        PlatformDependent0.putShort(address, value);\n    }\n\n    public static void putInt(long address, int value) {\n        PlatformDependent0.putInt(address, value);\n    }\n\n    public static void putLong(long address, long value) {\n        PlatformDependent0.putLong(address, value);\n    }\n\n    public static void putByte(byte[] data, int index, byte value) {\n        PlatformDependent0.putByte(data, index, value);\n    }\n\n    public static void putByte(Object data, long offset, byte value) {\n        PlatformDependent0.putByte(data, offset, value);\n    }\n\n    public static void putShort(byte[] data, int index, short value) {\n        PlatformDependent0.putShort(data, index, value);\n    }\n\n    public static void putInt(byte[] data, int index, int value) {\n        PlatformDependent0.putInt(data, index, value);\n    }\n\n    public static void putLong(byte[] data, int index, long value) {\n        PlatformDependent0.putLong(data, index, value);\n    }\n\n    public static void putObject(Object o, long offset, Object x) {\n        PlatformDependent0.putObject(o, offset, x);\n    }\n\n    public static long objectFieldOffset(Field field) {\n        return PlatformDependent0.objectFieldOffset(field);\n    }\n\n    public static void copyMemory(long srcAddr, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(srcAddr, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, long dstAddr, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex, null, dstAddr, length);\n    }\n\n    public static void copyMemory(byte[] src, int srcIndex, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(src, BYTE_ARRAY_BASE_OFFSET + srcIndex,\n                                      dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void copyMemory(long srcAddr, byte[] dst, int dstIndex, long length) {\n        PlatformDependent0.copyMemory(null, srcAddr, dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, length);\n    }\n\n    public static void setMemory(byte[] dst, int dstIndex, long bytes, byte value) {\n        PlatformDependent0.setMemory(dst, BYTE_ARRAY_BASE_OFFSET + dstIndex, bytes, value);\n    }\n\n    public static void setMemory(long address, long bytes, byte value) {\n        PlatformDependent0.setMemory(address, bytes, value);\n    }\n\n    /**\n     * Allocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s allocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        incrementMemoryCounter(capacity);\n        try {\n            return PlatformDependent0.allocateDirectNoCleaner(capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(capacity);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * Reallocate a new {@link ByteBuffer} with the given {@code capacity}. {@link ByteBuffer}s reallocated with\n     * this method <strong>MUST</strong> be deallocated via {@link #freeDirectNoCleaner(ByteBuffer)}.\n     */\n    public static ByteBuffer reallocateDirectNoCleaner(ByteBuffer buffer, int capacity) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int len = capacity - buffer.capacity();\n        incrementMemoryCounter(len);\n        try {\n            return PlatformDependent0.reallocateDirectNoCleaner(buffer, capacity);\n        } catch (Throwable e) {\n            decrementMemoryCounter(len);\n            throwException(e);\n            return null;\n        }\n    }\n\n    /**\n     * This method <strong>MUST</strong> only be called for {@link ByteBuffer}s that were allocated via\n     * {@link #allocateDirectNoCleaner(int)}.\n     */\n    public static void freeDirectNoCleaner(ByteBuffer buffer) {\n        assert USE_DIRECT_BUFFER_NO_CLEANER;\n\n        int capacity = buffer.capacity();\n        PlatformDependent0.freeMemory(PlatformDependent0.directBufferAddress(buffer));\n        decrementMemoryCounter(capacity);\n    }\n\n    public static boolean hasAlignDirectByteBuffer() {\n        return hasUnsafe() || PlatformDependent0.hasAlignSliceMethod();\n    }\n\n    public static ByteBuffer alignDirectBuffer(ByteBuffer buffer, int alignment) {\n        if (!buffer.isDirect()) {\n            throw new IllegalArgumentException(\"Cannot get aligned slice of non-direct byte buffer.\");\n        }\n        if (PlatformDependent0.hasAlignSliceMethod()) {\n            return PlatformDependent0.alignSlice(buffer, alignment);\n        }\n        if (hasUnsafe()) {\n            long address = directBufferAddress(buffer);\n            long aligned = align(address, alignment);\n            buffer.position((int) (aligned - address));\n            return buffer.slice();\n        }\n        // We don't have enough information to be able to align any buffers.\n        throw new UnsupportedOperationException(\"Cannot align direct buffer. \" +\n                \"Needs either Unsafe or ByteBuffer.alignSlice method available.\");\n    }\n\n    public static long align(long value, int alignment) {\n        return Pow2.align(value, alignment);\n    }\n\n    private static void incrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long newUsedMemory = DIRECT_MEMORY_COUNTER.addAndGet(capacity);\n            if (newUsedMemory > DIRECT_MEMORY_LIMIT) {\n                DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n                throw new OutOfDirectMemoryError(\"failed to allocate \" + capacity\n                        + \" byte(s) of direct memory (used: \" + (newUsedMemory - capacity)\n                        + \", max: \" + DIRECT_MEMORY_LIMIT + ')');\n            }\n        }\n    }\n\n    private static void decrementMemoryCounter(int capacity) {\n        if (DIRECT_MEMORY_COUNTER != null) {\n            long usedMemory = DIRECT_MEMORY_COUNTER.addAndGet(-capacity);\n            assert usedMemory >= 0;\n        }\n    }\n\n    public static boolean useDirectBufferNoCleaner() {\n        return USE_DIRECT_BUFFER_NO_CLEANER;\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the\n     * parameters is performed.\n     *\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     */\n    public static boolean equals(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  equalsSafe(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equals(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Determine if a subsection of an array is zero.\n     * @param bytes The byte array.\n     * @param startPos The starting index (inclusive) in {@code bytes}.\n     * @param length The amount of bytes to check for zero.\n     * @return {@code false} if {@code bytes[startPos:startsPos+length)} contains a value other than zero.\n     */\n    public static boolean isZero(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                isZeroSafe(bytes, startPos, length) :\n                PlatformDependent0.isZero(bytes, startPos, length);\n    }\n\n    /**\n     * Compare two {@code byte} arrays for equality without leaking timing information.\n     * For performance reasons no bounds checking on the parameters is performed.\n     * <p>\n     * The {@code int} return type is intentional and is designed to allow cascading of constant time operations:\n     * <pre>\n     *     byte[] s1 = new {1, 2, 3};\n     *     byte[] s2 = new {1, 2, 3};\n     *     byte[] s3 = new {1, 2, 3};\n     *     byte[] s4 = new {4, 5, 6};\n     *     boolean equals = (equalsConstantTime(s1, 0, s2, 0, s1.length) &\n     *                       equalsConstantTime(s3, 0, s4, 0, s3.length)) != 0;\n     * </pre>\n     * @param bytes1 the first byte array.\n     * @param startPos1 the position (inclusive) to start comparing in {@code bytes1}.\n     * @param bytes2 the second byte array.\n     * @param startPos2 the position (inclusive) to start comparing in {@code bytes2}.\n     * @param length the amount of bytes to compare. This is assumed to be validated as not going out of bounds\n     * by the caller.\n     * @return {@code 0} if not equal. {@code 1} if equal.\n     */\n    public static int equalsConstantTime(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                  ConstantTimeUtils.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length) :\n                  PlatformDependent0.equalsConstantTime(bytes1, startPos1, bytes2, startPos2, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * @param bytes The array which contains the data to hash.\n     * @param startPos What index to start generating a hash code in {@code bytes}\n     * @param length The amount of bytes that should be accounted for in the computation.\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(byte[] bytes, int startPos, int length) {\n        return !hasUnsafe() || !unalignedAccess() ?\n                hashCodeAsciiSafe(bytes, startPos, length) :\n                PlatformDependent0.hashCodeAscii(bytes, startPos, length);\n    }\n\n    /**\n     * Calculate a hash code of a byte array assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     * <p>\n     * This method assumes that {@code bytes} is equivalent to a {@code byte[]} but just using {@link CharSequence}\n     * for storage. The upper most byte of each {@code char} from {@code bytes} is ignored.\n     * @param bytes The array which contains the data to hash (assumed to be equivalent to a {@code byte[]}).\n     * @return The hash code of {@code bytes} assuming ASCII character encoding.\n     * The resulting hash code will be case insensitive.\n     */\n    public static int hashCodeAscii(CharSequence bytes) {\n        final int length = bytes.length();\n        final int remainingBytes = length & 7;\n        int hash = HASH_CODE_ASCII_SEED;\n        // Benchmarking shows that by just naively looping for inputs 8~31 bytes long we incur a relatively large\n        // performance penalty (only achieve about 60% performance of loop which iterates over each char). So because\n        // of this we take special provisions to unroll the looping for these conditions.\n        if (length >= 32) {\n            for (int i = length - 8; i >= remainingBytes; i -= 8) {\n                hash = hashCodeAsciiCompute(bytes, i, hash);\n            }\n        } else if (length >= 8) {\n            hash = hashCodeAsciiCompute(bytes, length - 8, hash);\n            if (length >= 16) {\n                hash = hashCodeAsciiCompute(bytes, length - 16, hash);\n                if (length >= 24) {\n                    hash = hashCodeAsciiCompute(bytes, length - 24, hash);\n                }\n            }\n        }\n        if (remainingBytes == 0) {\n            return hash;\n        }\n        int offset = 0;\n        if (remainingBytes != 2 & remainingBytes != 4 & remainingBytes != 6) { // 1, 3, 5, 7\n            hash = hash * HASH_CODE_C1 + hashCodeAsciiSanitizeByte(bytes.charAt(0));\n            offset = 1;\n        }\n        if (remainingBytes != 1 & remainingBytes != 4 & remainingBytes != 5) { // 2, 3, 6, 7\n            hash = hash * (offset == 0 ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitize(hashCodeAsciiSanitizeShort(bytes, offset));\n            offset += 2;\n        }\n        if (remainingBytes >= 4) { // 4, 5, 6, 7\n            return hash * ((offset == 0 | offset == 3) ? HASH_CODE_C1 : HASH_CODE_C2)\n                    + hashCodeAsciiSanitizeInt(bytes, offset);\n        }\n        return hash;\n    }\n\n    private static final class Mpsc {\n        private static final boolean USE_MPSC_CHUNKED_ARRAY_QUEUE;\n\n        private Mpsc() {\n        }\n\n        static {\n            Object unsafe = null;\n            if (hasUnsafe()) {\n                // jctools goes through its own process of initializing unsafe; of\n                // course, this requires permissions which might not be granted to calling code, so we\n                // must mark this block as privileged too\n                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        // force JCTools to initialize unsafe\n                        return UnsafeAccess.UNSAFE;\n                    }\n                });\n            }\n\n            if (unsafe == null) {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: unavailable\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = false;\n            } else {\n                logger.debug(\"org.jctools-core.MpscChunkedArrayQueue: available\");\n                USE_MPSC_CHUNKED_ARRAY_QUEUE = true;\n            }\n        }\n\n        static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n            // Calculate the max capacity which can not be bigger than MAX_ALLOWED_MPSC_CAPACITY.\n            // This is forced by the MpscChunkedArrayQueue implementation as will try to round it\n            // up to the next power of two and so will overflow otherwise.\n            final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);\n            return newChunkedMpscQueue(MPSC_CHUNK_SIZE, capacity);\n        }\n\n        static <T> Queue<T> newChunkedMpscQueue(final int chunkSize, final int capacity) {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(chunkSize, capacity)\n                    : new MpscChunkedAtomicArrayQueue<T>(chunkSize, capacity);\n        }\n\n        static <T> Queue<T> newMpscQueue() {\n            return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE)\n                                                : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);\n        }\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * @return A MPSC queue which may be unbounded.\n     */\n    public static <T> Queue<T> newMpscQueue() {\n        return Mpsc.newMpscQueue();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newMpscQueue(final int maxCapacity) {\n        return Mpsc.newMpscQueue(maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!).\n     * The queue will grow and shrink its capacity in units of the given chunk size.\n     */\n    public static <T> Queue<T> newMpscQueue(final int chunkSize, final int maxCapacity) {\n        return Mpsc.newChunkedMpscQueue(chunkSize, maxCapacity);\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for single producer (one thread!) and a single\n     * consumer (one thread!).\n     */\n    public static <T> Queue<T> newSpscQueue() {\n        return hasUnsafe() ? new SpscLinkedQueue<T>() : new SpscLinkedAtomicQueue<T>();\n    }\n\n    /**\n     * Create a new {@link Queue} which is safe to use for multiple producers (different threads) and a single\n     * consumer (one thread!) with the given fixes {@code capacity}.\n     */\n    public static <T> Queue<T> newFixedMpscQueue(int capacity) {\n        return hasUnsafe() ? new MpscArrayQueue<T>(capacity) : new MpscAtomicArrayQueue<T>(capacity);\n    }\n\n    /**\n     * Return the {@link ClassLoader} for the given {@link Class}.\n     */\n    public static ClassLoader getClassLoader(final Class<?> clazz) {\n        return PlatformDependent0.getClassLoader(clazz);\n    }\n\n    /**\n     * Return the context {@link ClassLoader} for the current {@link Thread}.\n     */\n    public static ClassLoader getContextClassLoader() {\n        return PlatformDependent0.getContextClassLoader();\n    }\n\n    /**\n     * Return the system {@link ClassLoader}.\n     */\n    public static ClassLoader getSystemClassLoader() {\n        return PlatformDependent0.getSystemClassLoader();\n    }\n\n    /**\n     * Returns a new concurrent {@link Deque}.\n     */\n    @SuppressJava6Requirement(reason = \"Usage guarded by java version check\")\n    public static <C> Deque<C> newConcurrentDeque() {\n        if (javaVersion() < 7) {\n            return new LinkedBlockingDeque<C>();\n        } else {\n            return new ConcurrentLinkedDeque<C>();\n        }\n    }\n\n    /**\n     * Return a {@link Random} which is not-threadsafe and so can only be used from the same thread.\n     */\n    public static Random threadLocalRandom() {\n        return RANDOM_PROVIDER.current();\n    }\n\n    private static boolean isWindows0() {\n        boolean windows = \"windows\".equals(NORMALIZED_OS);\n        if (windows) {\n            logger.debug(\"Platform: Windows\");\n        }\n        return windows;\n    }\n\n    private static boolean isOsx0() {\n        boolean osx = \"osx\".equals(NORMALIZED_OS);\n        if (osx) {\n            logger.debug(\"Platform: MacOS\");\n        }\n        return osx;\n    }\n\n    private static boolean maybeSuperUser0() {\n        String username = SystemPropertyUtil.get(\"user.name\");\n        if (isWindows()) {\n            return \"Administrator\".equals(username);\n        }\n        // Check for root and toor as some BSDs have a toor user that is basically the same as root.\n        return \"root\".equals(username) || \"toor\".equals(username);\n    }\n\n    private static Throwable unsafeUnavailabilityCause0() {\n        if (isAndroid()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (Android)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (Android)\");\n        }\n\n        if (isIkvmDotNet()) {\n            logger.debug(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n            return new UnsupportedOperationException(\"sun.misc.Unsafe: unavailable (IKVM.NET)\");\n        }\n\n        Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();\n        if (cause != null) {\n            return cause;\n        }\n\n        try {\n            boolean hasUnsafe = PlatformDependent0.hasUnsafe();\n            logger.debug(\"sun.misc.Unsafe: {}\", hasUnsafe ? \"available\" : \"unavailable\");\n            return hasUnsafe ? null : PlatformDependent0.getUnsafeUnavailabilityCause();\n        } catch (Throwable t) {\n            logger.trace(\"Could not determine if Unsafe is available\", t);\n            // Probably failed to initialize PlatformDependent0.\n            return new UnsupportedOperationException(\"Could not determine if Unsafe is available\", t);\n        }\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is either <a href=\"https://developer.ibm.com/javasdk/\">IBM J9</a> or\n     * <a href=\"https://www.eclipse.org/openj9/\">Eclipse OpenJ9</a>, {@code false} otherwise.\n     */\n    public static boolean isJ9Jvm() {\n        return IS_J9_JVM;\n    }\n\n    private static boolean isJ9Jvm0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n        return vmName.startsWith(\"ibm j9\") || vmName.startsWith(\"eclipse openj9\");\n    }\n\n    /**\n     * Returns {@code true} if the running JVM is <a href=\"https://www.ikvm.net\">IKVM.NET</a>, {@code false} otherwise.\n     */\n    public static boolean isIkvmDotNet() {\n        return IS_IVKVM_DOT_NET;\n    }\n\n    private static boolean isIkvmDotNet0() {\n        String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toUpperCase(Locale.US);\n        return vmName.equals(\"IKVM.NET\");\n    }\n\n    /**\n     * Compute an estimate of the maximum amount of direct memory available to this JVM.\n     * <p>\n     * The computation is not cached, so you probably want to use {@link #maxDirectMemory()} instead.\n     * <p>\n     * This will produce debug log output when called.\n     *\n     * @return The estimated max direct memory, in bytes.\n     */\n    public static long estimateMaxDirectMemory() {\n        long maxDirectMemory = 0;\n\n        ClassLoader systemClassLoader = null;\n        try {\n            systemClassLoader = getSystemClassLoader();\n\n            // When using IBM J9 / Eclipse OpenJ9 we should not use VM.maxDirectMemory() as it not reflects the\n            // correct value.\n            // See:\n            //  - https://github.com/netty/netty/issues/7654\n            String vmName = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase();\n            if (!vmName.startsWith(\"ibm j9\") &&\n                    // https://github.com/eclipse/openj9/blob/openj9-0.8.0/runtime/include/vendor_version.h#L53\n                    !vmName.startsWith(\"eclipse openj9\")) {\n                // Try to get from sun.misc.VM.maxDirectMemory() which should be most accurate.\n                Class<?> vmClass = Class.forName(\"sun.misc.VM\", true, systemClassLoader);\n                Method m = vmClass.getDeclaredMethod(\"maxDirectMemory\");\n                maxDirectMemory = ((Number) m.invoke(null)).longValue();\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory > 0) {\n            return maxDirectMemory;\n        }\n\n        try {\n            // Now try to get the JVM option (-XX:MaxDirectMemorySize) and parse it.\n            // Note that we are using reflection because Android doesn't have these classes.\n            Class<?> mgmtFactoryClass = Class.forName(\n                    \"java.lang.management.ManagementFactory\", true, systemClassLoader);\n            Class<?> runtimeClass = Class.forName(\n                    \"java.lang.management.RuntimeMXBean\", true, systemClassLoader);\n\n            Object runtime = mgmtFactoryClass.getDeclaredMethod(\"getRuntimeMXBean\").invoke(null);\n\n            @SuppressWarnings(\"unchecked\")\n            List<String> vmArgs = (List<String>) runtimeClass.getDeclaredMethod(\"getInputArguments\").invoke(runtime);\n            for (int i = vmArgs.size() - 1; i >= 0; i --) {\n                Matcher m = MAX_DIRECT_MEMORY_SIZE_ARG_PATTERN.matcher(vmArgs.get(i));\n                if (!m.matches()) {\n                    continue;\n                }\n\n                maxDirectMemory = Long.parseLong(m.group(1));\n                switch (m.group(2).charAt(0)) {\n                    case 'k': case 'K':\n                        maxDirectMemory *= 1024;\n                        break;\n                    case 'm': case 'M':\n                        maxDirectMemory *= 1024 * 1024;\n                        break;\n                    case 'g': case 'G':\n                        maxDirectMemory *= 1024 * 1024 * 1024;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            }\n        } catch (Throwable ignored) {\n            // Ignore\n        }\n\n        if (maxDirectMemory <= 0) {\n            maxDirectMemory = Runtime.getRuntime().maxMemory();\n            logger.debug(\"maxDirectMemory: {} bytes (maybe)\", maxDirectMemory);\n        } else {\n            logger.debug(\"maxDirectMemory: {} bytes\", maxDirectMemory);\n        }\n\n        return maxDirectMemory;\n    }\n\n    private static File tmpdir0() {\n        File f;\n        try {\n            f = toDirectory(SystemPropertyUtil.get(\"io.netty.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {}\", f);\n                return f;\n            }\n\n            f = toDirectory(SystemPropertyUtil.get(\"java.io.tmpdir\"));\n            if (f != null) {\n                logger.debug(\"-Dio.netty.tmpdir: {} (java.io.tmpdir)\", f);\n                return f;\n            }\n\n            // This shouldn't happen, but just in case ..\n            if (isWindows()) {\n                f = toDirectory(System.getenv(\"TEMP\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} (%TEMP%)\", f);\n                    return f;\n                }\n\n                String userprofile = System.getenv(\"USERPROFILE\");\n                if (userprofile != null) {\n                    f = toDirectory(userprofile + \"\\\\AppData\\\\Local\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\AppData\\\\Local\\\\Temp)\", f);\n                        return f;\n                    }\n\n                    f = toDirectory(userprofile + \"\\\\Local Settings\\\\Temp\");\n                    if (f != null) {\n                        logger.debug(\"-Dio.netty.tmpdir: {} (%USERPROFILE%\\\\Local Settings\\\\Temp)\", f);\n                        return f;\n                    }\n                }\n            } else {\n                f = toDirectory(System.getenv(\"TMPDIR\"));\n                if (f != null) {\n                    logger.debug(\"-Dio.netty.tmpdir: {} ($TMPDIR)\", f);\n                    return f;\n                }\n            }\n        } catch (Throwable ignored) {\n            // Environment variable inaccessible\n        }\n\n        // Last resort.\n        if (isWindows()) {\n            f = new File(\"C:\\\\Windows\\\\Temp\");\n        } else {\n            f = new File(\"/tmp\");\n        }\n\n        logger.warn(\"Failed to get the temporary directory; falling back to: {}\", f);\n        return f;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static File toDirectory(String path) {\n        if (path == null) {\n            return null;\n        }\n\n        File f = new File(path);\n        f.mkdirs();\n\n        if (!f.isDirectory()) {\n            return null;\n        }\n\n        try {\n            return f.getAbsoluteFile();\n        } catch (Exception ignored) {\n            return f;\n        }\n    }\n\n    private static int bitMode0() {\n        // Check user-specified bit mode first.\n        int bitMode = SystemPropertyUtil.getInt(\"io.netty.bitMode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {}\", bitMode);\n            return bitMode;\n        }\n\n        // And then the vendor specific ones which is probably most reliable.\n        bitMode = SystemPropertyUtil.getInt(\"sun.arch.data.model\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (sun.arch.data.model)\", bitMode);\n            return bitMode;\n        }\n        bitMode = SystemPropertyUtil.getInt(\"com.ibm.vm.bitmode\", 0);\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (com.ibm.vm.bitmode)\", bitMode);\n            return bitMode;\n        }\n\n        // os.arch also gives us a good hint.\n        String arch = SystemPropertyUtil.get(\"os.arch\", \"\").toLowerCase(Locale.US).trim();\n        if (\"amd64\".equals(arch) || \"x86_64\".equals(arch)) {\n            bitMode = 64;\n        } else if (\"i386\".equals(arch) || \"i486\".equals(arch) || \"i586\".equals(arch) || \"i686\".equals(arch)) {\n            bitMode = 32;\n        }\n\n        if (bitMode > 0) {\n            logger.debug(\"-Dio.netty.bitMode: {} (os.arch: {})\", bitMode, arch);\n        }\n\n        // Last resort: guess from VM name and then fall back to most common 64-bit mode.\n        String vm = SystemPropertyUtil.get(\"java.vm.name\", \"\").toLowerCase(Locale.US);\n        Pattern bitPattern = Pattern.compile(\"([1-9][0-9]+)-?bit\");\n        Matcher m = bitPattern.matcher(vm);\n        if (m.find()) {\n            return Integer.parseInt(m.group(1));\n        } else {\n            return 64;\n        }\n    }\n\n    private static int addressSize0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.addressSize();\n    }\n\n    private static long byteArrayBaseOffset0() {\n        if (!hasUnsafe()) {\n            return -1;\n        }\n        return PlatformDependent0.byteArrayBaseOffset();\n    }\n\n    private static boolean equalsSafe(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {\n        final int end = startPos1 + length;\n        for (; startPos1 < end; ++startPos1, ++startPos2) {\n            if (bytes1[startPos1] != bytes2[startPos2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isZeroSafe(byte[] bytes, int startPos, int length) {\n        final int end = startPos + length;\n        for (; startPos < end; ++startPos) {\n            if (bytes[startPos] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Package private for testing purposes only!\n     */\n    static int hashCodeAsciiSafe(byte[] bytes, int startPos, int length) {\n        int hash = HASH_CODE_ASCII_SEED;\n        final int remainingBytes = length & 7;\n        final int end = startPos + remainingBytes;\n        for (int i = startPos - 8 + length; i >= end; i -= 8) {\n            hash = PlatformDependent0.hashCodeAsciiCompute(getLongSafe(bytes, i), hash);\n        }\n        switch(remainingBytes) {\n        case 7:\n            return ((hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                          * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1)))\n                          * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 3));\n        case 6:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos)))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 2));\n        case 5:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos + 1));\n        case 4:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getIntSafe(bytes, startPos));\n        case 3:\n            return (hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]))\n                         * HASH_CODE_C2 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos + 1));\n        case 2:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(getShortSafe(bytes, startPos));\n        case 1:\n            return hash * HASH_CODE_C1 + hashCodeAsciiSanitize(bytes[startPos]);\n        default:\n            return hash;\n        }\n    }\n\n    public static String normalizedArch() {\n        return NORMALIZED_ARCH;\n    }\n\n    public static String normalizedOs() {\n        return NORMALIZED_OS;\n    }\n\n    public static Set<String> normalizedLinuxClassifiers() {\n        return LINUX_OS_CLASSIFIERS;\n    }\n\n    @SuppressJava6Requirement(reason = \"Guarded by version check\")\n    public static File createTempFile(String prefix, String suffix, File directory) throws IOException {\n        if (javaVersion() >= 7) {\n            if (directory == null) {\n                return Files.createTempFile(prefix, suffix).toFile();\n            }\n            return Files.createTempFile(directory.toPath(), prefix, suffix).toFile();\n        }\n        final File file;\n        if (directory == null) {\n            file = File.createTempFile(prefix, suffix);\n        } else {\n            file = File.createTempFile(prefix, suffix, directory);\n        }\n\n        // Try to adjust the perms, if this fails there is not much else we can do...\n        if (!file.setReadable(false, false)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n        if (!file.setReadable(true, true)) {\n            throw new IOException(\"Failed to set permissions on temporary file \" + file);\n        }\n        return file;\n    }\n\n    /**\n     * Adds only those classifier strings to <tt>dest</tt> which are present in <tt>allowed</tt>.\n     *\n     * @param allowed          allowed classifiers\n     * @param dest             destination set\n     * @param maybeClassifiers potential classifiers to add\n     */\n    private static void addClassifier(Set<String> allowed, Set<String> dest, String... maybeClassifiers) {\n        for (String id : maybeClassifiers) {\n            if (allowed.contains(id)) {\n                dest.add(id);\n            }\n        }\n    }\n\n    private static String normalizeOsReleaseVariableValue(String value) {\n        // Variable assignment values may be enclosed in double or single quotes.\n        return value.trim().replaceAll(\"[\\\"']\", \"\");\n    }\n\n    private static String normalize(String value) {\n        return value.toLowerCase(Locale.US).replaceAll(\"[^a-z0-9]+\", \"\");\n    }\n\n    private static String normalizeArch(String value) {\n        value = normalize(value);\n        if (value.matches(\"^(x8664|amd64|ia32e|em64t|x64)$\")) {\n            return \"x86_64\";\n        }\n        if (value.matches(\"^(x8632|x86|i[3-6]86|ia32|x32)$\")) {\n            return \"x86_32\";\n        }\n        if (value.matches(\"^(ia64|itanium64)$\")) {\n            return \"itanium_64\";\n        }\n        if (value.matches(\"^(sparc|sparc32)$\")) {\n            return \"sparc_32\";\n        }\n        if (value.matches(\"^(sparcv9|sparc64)$\")) {\n            return \"sparc_64\";\n        }\n        if (value.matches(\"^(arm|arm32)$\")) {\n            return \"arm_32\";\n        }\n        if (\"aarch64\".equals(value)) {\n            return \"aarch_64\";\n        }\n        if (value.matches(\"^(ppc|ppc32)$\")) {\n            return \"ppc_32\";\n        }\n        if (\"ppc64\".equals(value)) {\n            return \"ppc_64\";\n        }\n        if (\"ppc64le\".equals(value)) {\n            return \"ppcle_64\";\n        }\n        if (\"s390\".equals(value)) {\n            return \"s390_32\";\n        }\n        if (\"s390x\".equals(value)) {\n            return \"s390_64\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static String normalizeOs(String value) {\n        value = normalize(value);\n        if (value.startsWith(\"aix\")) {\n            return \"aix\";\n        }\n        if (value.startsWith(\"hpux\")) {\n            return \"hpux\";\n        }\n        if (value.startsWith(\"os400\")) {\n            // Avoid the names such as os4000\n            if (value.length() <= 5 || !Character.isDigit(value.charAt(5))) {\n                return \"os400\";\n            }\n        }\n        if (value.startsWith(\"linux\")) {\n            return \"linux\";\n        }\n        if (value.startsWith(\"macosx\") || value.startsWith(\"osx\") || value.startsWith(\"darwin\")) {\n            return \"osx\";\n        }\n        if (value.startsWith(\"freebsd\")) {\n            return \"freebsd\";\n        }\n        if (value.startsWith(\"openbsd\")) {\n            return \"openbsd\";\n        }\n        if (value.startsWith(\"netbsd\")) {\n            return \"netbsd\";\n        }\n        if (value.startsWith(\"solaris\") || value.startsWith(\"sunos\")) {\n            return \"sunos\";\n        }\n        if (value.startsWith(\"windows\")) {\n            return \"windows\";\n        }\n\n        return \"unknown\";\n    }\n\n    private static final class AtomicLongCounter extends AtomicLong implements LongCounter {\n        private static final long serialVersionUID = 4074772784610639305L;\n\n        @Override\n        public void add(long delta) {\n            addAndGet(delta);\n        }\n\n        @Override\n        public void increment() {\n            incrementAndGet();\n        }\n\n        @Override\n        public void decrement() {\n            decrementAndGet();\n        }\n\n        @Override\n        public long value() {\n            return get();\n        }\n    }\n\n    private interface ThreadLocalRandomProvider {\n        Random current();\n    }\n\n    private PlatformDependent() {\n        // only static method supported\n    }\n}\n"], "filenames": ["common/src/main/java/io/netty/util/internal/PlatformDependent.java"], "buggy_code_start_loc": [1449], "buggy_code_end_loc": [1457], "fixing_code_start_loc": [1450], "fixing_code_end_loc": [1464], "type": "CWE-378", "message": "Netty is an open-source, asynchronous event-driven network application framework. The package `io.netty:netty-codec-http` prior to version 4.1.77.Final contains an insufficient fix for CVE-2021-21290. When Netty's multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. This only impacts applications running on Java version 6 and lower. Additionally, this vulnerability impacts code running on Unix-like systems, and very old versions of Mac OSX and Windows as they all share the system temporary directory between all users. Version 4.1.77.Final contains a patch for this vulnerability. As a workaround, specify one's own `java.io.tmpdir` when starting the JVM or use DefaultHttpDataFactory.setBaseDir(...) to set the directory to something that is only readable by the current user.", "other": {"cve": {"id": "CVE-2022-24823", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-06T12:15:08.163", "lastModified": "2022-12-03T14:25:37.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty is an open-source, asynchronous event-driven network application framework. The package `io.netty:netty-codec-http` prior to version 4.1.77.Final contains an insufficient fix for CVE-2021-21290. When Netty's multipart decoders are used local information disclosure can occur via the local system temporary directory if temporary storing uploads on the disk is enabled. This only impacts applications running on Java version 6 and lower. Additionally, this vulnerability impacts code running on Unix-like systems, and very old versions of Mac OSX and Windows as they all share the system temporary directory between all users. Version 4.1.77.Final contains a patch for this vulnerability. As a workaround, specify one's own `java.io.tmpdir` when starting the JVM or use DefaultHttpDataFactory.setBaseDir(...) to set the directory to something that is only readable by the current user."}, {"lang": "es", "value": "Netty es un framework de aplicaciones de red as\u00edncronas de c\u00f3digo abierto. El paquete \"io.netty:netty-codec-http\" versiones anteriores a 4.1.77.Final contiene una correcci\u00f3n insuficiente para CVE-2021-21290. Cuando son usados los descodificadores multiparte de Netty, puede producirse una divulgaci\u00f3n de informaci\u00f3n local por medio del directorio temporal del sistema local si es habilitado el almacenamiento temporal de cargas en el disco. Esto s\u00f3lo afecta a las aplicaciones que son ejecutadas en la versi\u00f3n 6 de Java e inferior. Adem\u00e1s, esta vulnerabilidad afecta al c\u00f3digo que es ejecutado en sistemas tipo Unix, y a versiones muy antiguas de Mac OSX y Windows, ya que todos ellos comparten el directorio temporal del sistema entre todos los usuarios. La versi\u00f3n 4.1.77.Final contiene un parche para esta vulnerabilidad. Como mitigaci\u00f3n, especifique su propio \"java.io.tmpdir\" cuando inicie la JVM o use DefaultHttpDataFactory.setBaseDir(...) para establecer el directorio en algo que s\u00f3lo pueda leer el usuario actual"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-378"}, {"lang": "en", "value": "CWE-379"}, {"lang": "en", "value": "CWE-668"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.77", "matchCriteriaId": "C18E3C55-A603-42B2-AA47-9DC973753630"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_crime_and_compliance_management_studio:8.0.8.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "55F091C7-0869-4FD6-AC73-DA697D990304"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_crime_and_compliance_management_studio:8.0.8.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "4D134C60-F9E2-46C2-8466-DB90AD98439E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:linux:*:*", "matchCriteriaId": "F3E0B672-3E06-4422-B2A4-0BD073AEC2A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:windows:*:*", "matchCriteriaId": "B55E8D50-99B4-47EC-86F9-699B67D473CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}]}]}], "references": [{"url": "https://github.com/netty/netty/commit/185f8b2756a36aaa4f973f1a2a025e7d981823f1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-269q-hmxg-m83q", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-5mcr-gq6c-3hq2", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220616-0004/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/185f8b2756a36aaa4f973f1a2a025e7d981823f1"}}