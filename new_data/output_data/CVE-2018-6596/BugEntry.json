{"buggy_code": ["import re\nimport warnings\n\nimport six\nfrom django.http import HttpResponse\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.generic import View\n\nfrom ..exceptions import AnymailInsecureWebhookWarning, AnymailWebhookValidationFailure\nfrom ..utils import get_anymail_setting, collect_all_methods, get_request_basic_auth\n\n\nclass AnymailBasicAuthMixin(object):\n    \"\"\"Implements webhook basic auth as mixin to AnymailBaseWebhookView.\"\"\"\n\n    # Whether to warn if basic auth is not configured.\n    # For most ESPs, basic auth is the only webhook security,\n    # so the default is True. Subclasses can set False if\n    # they enforce other security (like signed webhooks).\n    warn_if_no_basic_auth = True\n\n    # List of allowable HTTP basic-auth 'user:pass' strings.\n    basic_auth = None  # (Declaring class attr allows override by kwargs in View.as_view.)\n\n    def __init__(self, **kwargs):\n        self.basic_auth = get_anymail_setting('webhook_authorization', default=[],\n                                              kwargs=kwargs)  # no esp_name -- auth is shared between ESPs\n        # Allow a single string:\n        if isinstance(self.basic_auth, six.string_types):\n            self.basic_auth = [self.basic_auth]\n        if self.warn_if_no_basic_auth and len(self.basic_auth) < 1:\n            warnings.warn(\n                \"Your Anymail webhooks are insecure and open to anyone on the web. \"\n                \"You should set WEBHOOK_AUTHORIZATION in your ANYMAIL settings. \"\n                \"See 'Securing webhooks' in the Anymail docs.\",\n                AnymailInsecureWebhookWarning)\n        # noinspection PyArgumentList\n        super(AnymailBasicAuthMixin, self).__init__(**kwargs)\n\n    def validate_request(self, request):\n        \"\"\"If configured for webhook basic auth, validate request has correct auth.\"\"\"\n        if self.basic_auth:\n            basic_auth = get_request_basic_auth(request)\n            if basic_auth is None or basic_auth not in self.basic_auth:\n                # noinspection PyUnresolvedReferences\n                raise AnymailWebhookValidationFailure(\n                    \"Missing or invalid basic auth in Anymail %s webhook\" % self.esp_name)\n\n\n# Mixin note: Django's View.__init__ doesn't cooperate with chaining,\n# so all mixins that need __init__ must appear before View in MRO.\nclass AnymailBaseWebhookView(AnymailBasicAuthMixin, View):\n    \"\"\"Base view for processing ESP event webhooks\n\n    ESP-specific implementations should subclass\n    and implement parse_events. They may also\n    want to implement validate_request\n    if additional security is available.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super(AnymailBaseWebhookView, self).__init__(**kwargs)\n        self.validators = collect_all_methods(self.__class__, 'validate_request')\n\n    # Subclass implementation:\n\n    # Where to send events: either ..signals.inbound or ..signals.tracking\n    signal = None\n\n    def validate_request(self, request):\n        \"\"\"Check validity of webhook post, or raise AnymailWebhookValidationFailure.\n\n        AnymailBaseWebhookView includes basic auth validation.\n        Subclasses can implement (or provide via mixins) if the ESP supports\n        additional validation (such as signature checking).\n\n        *All* definitions of this method in the class chain (including mixins)\n        will be called. There is no need to chain to the superclass.\n        (See self.run_validators and collect_all_methods.)\n        \"\"\"\n        # if request.POST['signature'] != expected_signature:\n        #     raise AnymailWebhookValidationFailure(\"...message...\")\n        # (else just do nothing)\n        pass\n\n    def parse_events(self, request):\n        \"\"\"Return a list of normalized AnymailWebhookEvent extracted from ESP post data.\n\n        Subclasses must implement.\n        \"\"\"\n        raise NotImplementedError()\n\n    # HTTP handlers (subclasses shouldn't need to override):\n\n    http_method_names = [\"post\", \"head\", \"options\"]\n\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        return super(AnymailBaseWebhookView, self).dispatch(request, *args, **kwargs)\n\n    def head(self, request, *args, **kwargs):\n        # Some ESPs verify the webhook with a HEAD request at configuration time\n        return HttpResponse()\n\n    def post(self, request, *args, **kwargs):\n        # Normal Django exception handling will do the right thing:\n        # - AnymailWebhookValidationFailure will turn into an HTTP 400 response\n        #   (via Django SuspiciousOperation handling)\n        # - Any other errors (e.g., in signal dispatch) will turn into HTTP 500\n        #   responses (via normal Django error handling). ESPs generally\n        #   treat that as \"try again later\".\n        self.run_validators(request)\n        events = self.parse_events(request)\n        esp_name = self.esp_name\n        for event in events:\n            self.signal.send(sender=self.__class__, event=event, esp_name=esp_name)\n        return HttpResponse()\n\n    # Request validation (subclasses shouldn't need to override):\n\n    def run_validators(self, request):\n        for validator in self.validators:\n            validator(self, request)\n\n    @property\n    def esp_name(self):\n        \"\"\"\n        Read-only name of the ESP for this webhook view.\n\n        (E.g., MailgunTrackingWebhookView will return \"Mailgun\")\n        \"\"\"\n        return re.sub(r'(Tracking|Inbox)WebhookView$', \"\", self.__class__.__name__)\n"], "fixing_code": ["import re\nimport warnings\n\nimport six\nfrom django.http import HttpResponse\nfrom django.utils.crypto import constant_time_compare\nfrom django.utils.decorators import method_decorator\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.views.generic import View\n\nfrom ..exceptions import AnymailInsecureWebhookWarning, AnymailWebhookValidationFailure\nfrom ..utils import get_anymail_setting, collect_all_methods, get_request_basic_auth\n\n\nclass AnymailBasicAuthMixin(object):\n    \"\"\"Implements webhook basic auth as mixin to AnymailBaseWebhookView.\"\"\"\n\n    # Whether to warn if basic auth is not configured.\n    # For most ESPs, basic auth is the only webhook security,\n    # so the default is True. Subclasses can set False if\n    # they enforce other security (like signed webhooks).\n    warn_if_no_basic_auth = True\n\n    # List of allowable HTTP basic-auth 'user:pass' strings.\n    basic_auth = None  # (Declaring class attr allows override by kwargs in View.as_view.)\n\n    def __init__(self, **kwargs):\n        self.basic_auth = get_anymail_setting('webhook_authorization', default=[],\n                                              kwargs=kwargs)  # no esp_name -- auth is shared between ESPs\n        # Allow a single string:\n        if isinstance(self.basic_auth, six.string_types):\n            self.basic_auth = [self.basic_auth]\n        if self.warn_if_no_basic_auth and len(self.basic_auth) < 1:\n            warnings.warn(\n                \"Your Anymail webhooks are insecure and open to anyone on the web. \"\n                \"You should set WEBHOOK_AUTHORIZATION in your ANYMAIL settings. \"\n                \"See 'Securing webhooks' in the Anymail docs.\",\n                AnymailInsecureWebhookWarning)\n        # noinspection PyArgumentList\n        super(AnymailBasicAuthMixin, self).__init__(**kwargs)\n\n    def validate_request(self, request):\n        \"\"\"If configured for webhook basic auth, validate request has correct auth.\"\"\"\n        if self.basic_auth:\n            request_auth = get_request_basic_auth(request)\n            # Use constant_time_compare to avoid timing attack on basic auth. (It's OK that any()\n            # can terminate early: we're not trying to protect how many auth strings are allowed,\n            # just the contents of each individual auth string.)\n            auth_ok = any(constant_time_compare(request_auth, allowed_auth)\n                          for allowed_auth in self.basic_auth)\n            if not auth_ok:\n                # noinspection PyUnresolvedReferences\n                raise AnymailWebhookValidationFailure(\n                    \"Missing or invalid basic auth in Anymail %s webhook\" % self.esp_name)\n\n\n# Mixin note: Django's View.__init__ doesn't cooperate with chaining,\n# so all mixins that need __init__ must appear before View in MRO.\nclass AnymailBaseWebhookView(AnymailBasicAuthMixin, View):\n    \"\"\"Base view for processing ESP event webhooks\n\n    ESP-specific implementations should subclass\n    and implement parse_events. They may also\n    want to implement validate_request\n    if additional security is available.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super(AnymailBaseWebhookView, self).__init__(**kwargs)\n        self.validators = collect_all_methods(self.__class__, 'validate_request')\n\n    # Subclass implementation:\n\n    # Where to send events: either ..signals.inbound or ..signals.tracking\n    signal = None\n\n    def validate_request(self, request):\n        \"\"\"Check validity of webhook post, or raise AnymailWebhookValidationFailure.\n\n        AnymailBaseWebhookView includes basic auth validation.\n        Subclasses can implement (or provide via mixins) if the ESP supports\n        additional validation (such as signature checking).\n\n        *All* definitions of this method in the class chain (including mixins)\n        will be called. There is no need to chain to the superclass.\n        (See self.run_validators and collect_all_methods.)\n\n        Security note: use django.utils.crypto.constant_time_compare for string\n        comparisons, to avoid exposing your validation to a timing attack.\n        \"\"\"\n        # if not constant_time_compare(request.POST['signature'], expected_signature):\n        #     raise AnymailWebhookValidationFailure(\"...message...\")\n        # (else just do nothing)\n        pass\n\n    def parse_events(self, request):\n        \"\"\"Return a list of normalized AnymailWebhookEvent extracted from ESP post data.\n\n        Subclasses must implement.\n        \"\"\"\n        raise NotImplementedError()\n\n    # HTTP handlers (subclasses shouldn't need to override):\n\n    http_method_names = [\"post\", \"head\", \"options\"]\n\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        return super(AnymailBaseWebhookView, self).dispatch(request, *args, **kwargs)\n\n    def head(self, request, *args, **kwargs):\n        # Some ESPs verify the webhook with a HEAD request at configuration time\n        return HttpResponse()\n\n    def post(self, request, *args, **kwargs):\n        # Normal Django exception handling will do the right thing:\n        # - AnymailWebhookValidationFailure will turn into an HTTP 400 response\n        #   (via Django SuspiciousOperation handling)\n        # - Any other errors (e.g., in signal dispatch) will turn into HTTP 500\n        #   responses (via normal Django error handling). ESPs generally\n        #   treat that as \"try again later\".\n        self.run_validators(request)\n        events = self.parse_events(request)\n        esp_name = self.esp_name\n        for event in events:\n            self.signal.send(sender=self.__class__, event=event, esp_name=esp_name)\n        return HttpResponse()\n\n    # Request validation (subclasses shouldn't need to override):\n\n    def run_validators(self, request):\n        for validator in self.validators:\n            validator(self, request)\n\n    @property\n    def esp_name(self):\n        \"\"\"\n        Read-only name of the ESP for this webhook view.\n\n        (E.g., MailgunTrackingWebhookView will return \"Mailgun\")\n        \"\"\"\n        return re.sub(r'(Tracking|Inbox)WebhookView$', \"\", self.__class__.__name__)\n"], "filenames": ["anymail/webhooks/base.py"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [83], "fixing_code_start_loc": [6], "fixing_code_end_loc": [92], "type": "CWE-200", "message": "webhooks/base.py in Anymail (aka django-anymail) before 1.2.1 is prone to a timing attack vulnerability on the WEBHOOK_AUTHORIZATION secret, which allows remote attackers to post arbitrary e-mail tracking events.", "other": {"cve": {"id": "CVE-2018-6596", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-03T21:29:00.210", "lastModified": "2018-03-02T13:56:38.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "webhooks/base.py in Anymail (aka django-anymail) before 1.2.1 is prone to a timing attack vulnerability on the WEBHOOK_AUTHORIZATION secret, which allows remote attackers to post arbitrary e-mail tracking events."}, {"lang": "es", "value": "webhooks/base.py en Anymail (tambi\u00e9n conocido como django-anymail), en versiones anteriores a la 1.2.1, es propenso a una vulnerabilidad de ataque de sincronizaci\u00f3n en el secreto WEBHOOK_AUTHORIZATION, que permite que los atacantes remotos publiquen eventos de seguimiento de email."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:django-anymail_project:django-anymail:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "8F3C5222-0242-49B1-9EF0-052C5890FC35"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugs.debian.org/889450", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/anymail/django-anymail/commit/c07998304b4a31df4c61deddcb03d3607a04691b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/anymail/django-anymail/commit/db586ede1fbb41dce21310ea28ae15a1cf1286c5", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/anymail/django-anymail/releases/tag/v1.2.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/anymail/django-anymail/releases/tag/v1.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.debian.org/security/2018/dsa-4107", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/anymail/django-anymail/commit/c07998304b4a31df4c61deddcb03d3607a04691b"}}