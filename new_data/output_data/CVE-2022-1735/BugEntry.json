{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * change.c: functions related to changing text\n */\n\n#include \"vim.h\"\n\n/*\n * If the file is readonly, give a warning message with the first change.\n * Don't do this for autocommands.\n * Doesn't use emsg(), because it flushes the macro buffer.\n * If we have undone all changes b_changed will be FALSE, but \"b_did_warn\"\n * will be TRUE.\n * \"col\" is the column for the message; non-zero when in insert mode and\n * 'showmode' is on.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchange_warning(int col)\n{\n    static char *w_readonly = N_(\"W10: Warning: Changing a readonly file\");\n\n    if (curbuf->b_did_warn == FALSE\n\t    && curbufIsChanged() == 0\n\t    && !autocmd_busy\n\t    && curbuf->b_p_ro)\n    {\n\t++curbuf_lock;\n\tapply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, FALSE, curbuf);\n\t--curbuf_lock;\n\tif (!curbuf->b_p_ro)\n\t    return;\n\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tif (msg_row == Rows - 1)\n\t    msg_col = col;\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts_attr(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);\n#ifdef FEAT_EVAL\n\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);\n#endif\n\tmsg_clr_eos();\n\t(void)msg_end();\n\tif (msg_silent == 0 && !silent_mode\n#ifdef FEAT_EVAL\n\t\t&& time_for_testing != 1\n#endif\n\t\t)\n\t{\n\t    out_flush();\n\t    ui_delay(1002L, TRUE); // give the user time to think about it\n\t}\n\tcurbuf->b_did_warn = TRUE;\n\tredraw_cmdline = FALSE;\t// don't redraw and erase the message\n\tif (msg_row < Rows - 1)\n\t    showmode();\n    }\n}\n\n/*\n * Call this function when something in the current buffer is changed.\n *\n * Most often called through changed_bytes() and changed_lines(), which also\n * mark the area of the display to be redrawn.\n *\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged(void)\n{\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n    {\n\t// The text of the preediting area is inserted, but this doesn't\n\t// mean a change of the buffer yet.  That is delayed until the\n\t// text is committed. (this means preedit becomes empty)\n\tif (im_is_preediting() && !xim_changed_while_preediting)\n\t    return;\n\txim_changed_while_preediting = FALSE;\n    }\n#endif\n\n    if (!curbuf->b_changed)\n    {\n\tint\tsave_msg_scroll = msg_scroll;\n\n\t// Give a warning about changing a read-only file.  This may also\n\t// check-out the file, thus change \"curbuf\"!\n\tchange_warning(0);\n\n\t// Create a swap file if that is wanted.\n\t// Don't do this for \"nofile\" and \"nowrite\" buffer types.\n\tif (curbuf->b_may_swap\n#ifdef FEAT_QUICKFIX\n\t\t&& !bt_dontwrite(curbuf)\n#endif\n\t\t)\n\t{\n\t    int save_need_wait_return = need_wait_return;\n\n\t    need_wait_return = FALSE;\n\t    ml_open_file(curbuf);\n\n\t    // The ml_open_file() can cause an ATTENTION message.\n\t    // Wait two seconds, to make sure the user reads this unexpected\n\t    // message.  Since we could be anywhere, call wait_return() now,\n\t    // and don't let the emsg() set msg_scroll.\n\t    if (need_wait_return && emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(2002L, TRUE);\n\t\twait_return(TRUE);\n\t\tmsg_scroll = save_msg_scroll;\n\t    }\n\t    else\n\t\tneed_wait_return = save_need_wait_return;\n\t}\n\tchanged_internal();\n    }\n    ++CHANGEDTICK(curbuf);\n\n#ifdef FEAT_SEARCH_EXTRA\n    // If a pattern is highlighted, the position may now be invalid.\n    highlight_match = FALSE;\n#endif\n}\n\n/*\n * Internal part of changed(), no user interaction.\n * Also used for recovery.\n */\n    void\nchanged_internal(void)\n{\n    curbuf->b_changed = TRUE;\n    ml_setflags(curbuf);\n    check_status(curbuf);\n    redraw_tabline = TRUE;\n    need_maketitle = TRUE;\t    // set window title later\n}\n\n#ifdef FEAT_EVAL\nstatic long next_listener_id = 0;\n\n/*\n * Check if the change at \"lnum\" is above or overlaps with an existing\n * change. If above then flush changes and invoke listeners.\n */\n    static void\ncheck_recorded_changes(\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnum,\n\tlinenr_T\tlnume,\n\tlong\t\txtra)\n{\n    if (buf->b_recorded_changes != NULL && xtra != 0)\n    {\n\tlistitem_T *li;\n\tlinenr_T    prev_lnum;\n\tlinenr_T    prev_lnume;\n\n\tFOR_ALL_LIST_ITEMS(buf->b_recorded_changes, li)\n\t{\n\t    prev_lnum = (linenr_T)dict_get_number(\n\t\t\t\t      li->li_tv.vval.v_dict, (char_u *)\"lnum\");\n\t    prev_lnume = (linenr_T)dict_get_number(\n\t\t\t\t       li->li_tv.vval.v_dict, (char_u *)\"end\");\n\t    if (prev_lnum >= lnum || prev_lnum > lnume || prev_lnume >= lnum)\n\t    {\n\t\t// the current change is going to make the line number in\n\t\t// the older change invalid, flush now\n\t\tinvoke_listeners(curbuf);\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\n/*\n * Record a change for listeners added with listener_add().\n * Always for the current buffer.\n */\n    static void\nmay_record_change(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    dict_T\t*dict;\n\n    if (curbuf->b_listener == NULL)\n\treturn;\n\n    // If the new change is going to change the line numbers in already listed\n    // changes, then flush.\n    check_recorded_changes(curbuf, lnum, lnume, xtra);\n\n    if (curbuf->b_recorded_changes == NULL)\n    {\n\tcurbuf->b_recorded_changes = list_alloc();\n\tif (curbuf->b_recorded_changes == NULL)  // out of memory\n\t    return;\n\t++curbuf->b_recorded_changes->lv_refcount;\n\tcurbuf->b_recorded_changes->lv_lock = VAR_FIXED;\n    }\n\n    dict = dict_alloc();\n    if (dict == NULL)\n\treturn;\n    dict_add_number(dict, \"lnum\", (varnumber_T)lnum);\n    dict_add_number(dict, \"end\", (varnumber_T)lnume);\n    dict_add_number(dict, \"added\", (varnumber_T)xtra);\n    dict_add_number(dict, \"col\", (varnumber_T)col + 1);\n\n    list_append_dict(curbuf->b_recorded_changes, dict);\n}\n\n/*\n * listener_add() function\n */\n    void\nf_listener_add(typval_T *argvars, typval_T *rettv)\n{\n    callback_T\tcallback;\n    listener_T\t*lnr;\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 1) == FAIL)\n\treturn;\n\n    callback = get_callback(&argvars[0]);\n    if (callback.cb_name == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[1]);\n\tif (buf == NULL)\n\t{\n\t    free_callback(&callback);\n\t    return;\n\t}\n    }\n\n    lnr = ALLOC_CLEAR_ONE(listener_T);\n    if (lnr == NULL)\n    {\n\tfree_callback(&callback);\n\treturn;\n    }\n    lnr->lr_next = buf->b_listener;\n    buf->b_listener = lnr;\n\n    set_callback(&lnr->lr_callback, &callback);\n\n    lnr->lr_id = ++next_listener_id;\n    rettv->vval.v_number = lnr->lr_id;\n}\n\n/*\n * listener_flush() function\n */\n    void\nf_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[0]);\n\tif (buf == NULL)\n\t    return;\n    }\n    invoke_listeners(buf);\n}\n\n\n    static void\nremove_listener(buf_T *buf, listener_T *lnr, listener_T *prev)\n{\n    if (prev != NULL)\n\tprev->lr_next = lnr->lr_next;\n    else\n\tbuf->b_listener = lnr->lr_next;\n    free_callback(&lnr->lr_callback);\n    vim_free(lnr);\n}\n\n/*\n * listener_remove() function\n */\n    void\nf_listener_remove(typval_T *argvars, typval_T *rettv)\n{\n    listener_T\t*lnr;\n    listener_T\t*next;\n    listener_T\t*prev;\n    int\t\tid;\n    buf_T\t*buf;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    id = tv_get_number(argvars);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tprev = NULL;\n\tfor (lnr = buf->b_listener; lnr != NULL; lnr = next)\n\t{\n\t    next = lnr->lr_next;\n\t    if (lnr->lr_id == id)\n\t    {\n\t\tif (textwinlock > 0)\n\t\t{\n\t\t    // in invoke_listeners(), clear ID and delete later\n\t\t    lnr->lr_id = 0;\n\t\t    return;\n\t\t}\n\t\tremove_listener(buf, lnr, prev);\n\t\trettv->vval.v_number = 1;\n\t\treturn;\n\t    }\n\t    prev = lnr;\n\t}\n    }\n}\n\n/*\n * Called before inserting a line above \"lnum\"/\"lnum3\" or deleting line \"lnum\"\n * to \"lnume\".\n */\n    void\nmay_invoke_listeners(buf_T *buf, linenr_T lnum, linenr_T lnume, int added)\n{\n    check_recorded_changes(buf, lnum, lnume, added);\n}\n\n/*\n * Called when a sequence of changes is done: invoke listeners added with\n * listener_add().\n */\n    void\ninvoke_listeners(buf_T *buf)\n{\n    listener_T\t*lnr;\n    typval_T\trettv;\n    typval_T\targv[6];\n    listitem_T\t*li;\n    linenr_T\tstart = MAXLNUM;\n    linenr_T\tend = 0;\n    linenr_T\tadded = 0;\n    int\t\tsave_updating_screen = updating_screen;\n    static int\trecursive = FALSE;\n    listener_T\t*next;\n\n    if (buf->b_recorded_changes == NULL  // nothing changed\n\t    || buf->b_listener == NULL   // no listeners\n\t    || recursive)\t\t // already busy\n\treturn;\n    recursive = TRUE;\n\n    // Block messages on channels from being handled, so that they don't make\n    // text changes here.\n    ++updating_screen;\n\n    argv[0].v_type = VAR_NUMBER;\n    argv[0].vval.v_number = buf->b_fnum; // a:bufnr\n\n    FOR_ALL_LIST_ITEMS(buf->b_recorded_changes, li)\n    {\n\tvarnumber_T lnum;\n\n\tlnum = dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"lnum\");\n\tif (start > lnum)\n\t    start = lnum;\n\tlnum = dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"end\");\n\tif (end < lnum)\n\t    end = lnum;\n\tadded += dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"added\");\n    }\n    argv[1].v_type = VAR_NUMBER;\n    argv[1].vval.v_number = start;\n    argv[2].v_type = VAR_NUMBER;\n    argv[2].vval.v_number = end;\n    argv[3].v_type = VAR_NUMBER;\n    argv[3].vval.v_number = added;\n\n    argv[4].v_type = VAR_LIST;\n    argv[4].vval.v_list = buf->b_recorded_changes;\n    ++textwinlock;\n\n    for (lnr = buf->b_listener; lnr != NULL; lnr = lnr->lr_next)\n    {\n\tcall_callback(&lnr->lr_callback, -1, &rettv, 5, argv);\n\tclear_tv(&rettv);\n    }\n\n    // If f_listener_remove() was called may have to remove a listener now.\n    for (lnr = buf->b_listener; lnr != NULL; lnr = next)\n    {\n\tlistener_T\t*prev = NULL;\n\n\tnext = lnr->lr_next;\n\tif (lnr->lr_id == 0)\n\t    remove_listener(buf, lnr, prev);\n\telse\n\t    prev = lnr;\n    }\n\n    --textwinlock;\n    list_unref(buf->b_recorded_changes);\n    buf->b_recorded_changes = NULL;\n\n    if (save_updating_screen)\n\tupdating_screen = TRUE;\n    else\n\tafter_updating_screen(TRUE);\n    recursive = FALSE;\n}\n\n/*\n * Remove all listeners associated with \"buf\".\n */\n    void\nremove_listeners(buf_T *buf)\n{\n    listener_T\t*lnr;\n    listener_T\t*next;\n\n    for (lnr = buf->b_listener; lnr != NULL; lnr = next)\n    {\n\tnext = lnr->lr_next;\n\tfree_callback(&lnr->lr_callback);\n\tvim_free(lnr);\n    }\n    buf->b_listener = NULL;\n}\n#endif\n\n/*\n * Common code for when a change was made.\n * See changed_lines() for the arguments.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    static void\nchanged_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}\n\n    static void\nchangedOneline(buf_T *buf, linenr_T lnum)\n{\n    if (buf->b_mod_set)\n    {\n\t// find the maximum area that must be redisplayed\n\tif (lnum < buf->b_mod_top)\n\t    buf->b_mod_top = lnum;\n\telse if (lnum >= buf->b_mod_bot)\n\t    buf->b_mod_bot = lnum + 1;\n    }\n    else\n    {\n\t// set the area that must be redisplayed to one line\n\tbuf->b_mod_set = TRUE;\n\tbuf->b_mod_top = lnum;\n\tbuf->b_mod_bot = lnum + 1;\n\tbuf->b_mod_xlines = 0;\n    }\n}\n\n/*\n * Changed bytes within a single line for the current buffer.\n * - marks the windows on this buffer to be redisplayed\n * - marks the buffer changed by calling changed()\n * - invalidates cached values\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged_bytes(linenr_T lnum, colnr_T col)\n{\n    changedOneline(curbuf, lnum);\n    changed_common(lnum, col, lnum + 1, 0L);\n\n#ifdef FEAT_DIFF\n    // Diff highlighting in other diff windows may need to be updated too.\n    if (curwin->w_p_diff)\n    {\n\twin_T\t    *wp;\n\tlinenr_T    wlnum;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_diff && wp != curwin)\n\t    {\n\t\tredraw_win_later(wp, VALID);\n\t\twlnum = diff_lnum_win(lnum, wp);\n\t\tif (wlnum > 0)\n\t\t    changedOneline(wp->w_buffer, wlnum);\n\t    }\n    }\n#endif\n}\n\n/*\n * Like changed_bytes() but also adjust text properties for \"added\" bytes.\n * When \"added\" is negative text was deleted.\n */\n    void\ninserted_bytes(linenr_T lnum, colnr_T col, int added UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    if (curbuf->b_has_textprop && added != 0)\n\tadjust_prop_columns(lnum, col, added, 0);\n#endif\n\n    changed_bytes(lnum, col);\n}\n\n/*\n * Appended \"count\" lines below line \"lnum\" in the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * Takes care of marking the buffer to be redrawn and sets the changed flag.\n */\n    void\nappended_lines(linenr_T lnum, long count)\n{\n    changed_lines(lnum + 1, 0, lnum + 1, count);\n}\n\n/*\n * Like appended_lines(), but adjust marks first.\n */\n    void\nappended_lines_mark(linenr_T lnum, long count)\n{\n    // Skip mark_adjust when adding a line after the last one, there can't\n    // be marks there. But it's still needed in diff mode.\n    if (lnum + count < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    || curwin->w_p_diff\n#endif\n\t)\n\tmark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);\n    changed_lines(lnum + 1, 0, lnum + 1, count);\n}\n\n/*\n * Deleted \"count\" lines at line \"lnum\" in the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * Takes care of marking the buffer to be redrawn and sets the changed flag.\n */\n    void\ndeleted_lines(linenr_T lnum, long count)\n{\n    changed_lines(lnum, 0, lnum + count, -count);\n}\n\n/*\n * Like deleted_lines(), but adjust marks first.\n * Make sure the cursor is on a valid line before calling, a GUI callback may\n * be triggered to display the cursor.\n */\n    void\ndeleted_lines_mark(linenr_T lnum, long count)\n{\n    mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);\n    changed_lines(lnum, 0, lnum + count, -count);\n}\n\n/*\n * Marks the area to be redrawn after a change.\n */\n    void\nchanged_lines_buf(\n    buf_T\t*buf,\n    linenr_T\tlnum,\t    // first line with change\n    linenr_T\tlnume,\t    // line below last changed line\n    long\txtra)\t    // number of extra lines (negative when deleting)\n{\n    if (buf->b_mod_set)\n    {\n\t// find the maximum area that must be redisplayed\n\tif (lnum < buf->b_mod_top)\n\t    buf->b_mod_top = lnum;\n\tif (lnum < buf->b_mod_bot)\n\t{\n\t    // adjust old bot position for xtra lines\n\t    buf->b_mod_bot += xtra;\n\t    if (buf->b_mod_bot < lnum)\n\t\tbuf->b_mod_bot = lnum;\n\t}\n\tif (lnume + xtra > buf->b_mod_bot)\n\t    buf->b_mod_bot = lnume + xtra;\n\tbuf->b_mod_xlines += xtra;\n    }\n    else\n    {\n\t// set the area that must be redisplayed\n\tbuf->b_mod_set = TRUE;\n\tbuf->b_mod_top = lnum;\n\tbuf->b_mod_bot = lnume + xtra;\n\tbuf->b_mod_xlines = xtra;\n    }\n}\n\n/*\n * Changed lines for the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * - mark the buffer changed by calling changed()\n * - mark the windows on this buffer to be redisplayed\n * - invalidate cached values\n * \"lnum\" is the first line that needs displaying, \"lnume\" the first line\n * below the changed lines (BEFORE the change).\n * When only inserting lines, \"lnum\" and \"lnume\" are equal.\n * Takes care of calling changed() and updating b_mod_*.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged_lines(\n    linenr_T\tlnum,\t    // first line with change\n    colnr_T\tcol,\t    // column in first line with change\n    linenr_T\tlnume,\t    // line below last changed line\n    long\txtra)\t    // number of extra lines (negative when deleting)\n{\n    changed_lines_buf(curbuf, lnum, lnume, xtra);\n\n#ifdef FEAT_DIFF\n    if (xtra == 0 && curwin->w_p_diff && !diff_internal())\n    {\n\t// When the number of lines doesn't change then mark_adjust() isn't\n\t// called and other diff buffers still need to be marked for\n\t// displaying.\n\twin_T\t    *wp;\n\tlinenr_T    wlnum;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_diff && wp != curwin)\n\t    {\n\t\tredraw_win_later(wp, VALID);\n\t\twlnum = diff_lnum_win(lnum, wp);\n\t\tif (wlnum > 0)\n\t\t    changed_lines_buf(wp->w_buffer, wlnum,\n\t\t\t\t\t\t    lnume - lnum + wlnum, 0L);\n\t    }\n    }\n#endif\n\n    changed_common(lnum, col, lnume, xtra);\n}\n\n/*\n * Called when the changed flag must be reset for buffer \"buf\".\n * When \"ff\" is TRUE also reset 'fileformat'.\n * When \"always_inc_changedtick\" is TRUE b:changedtick is incremented also when\n * the changed flag was off.\n */\n    void\nunchanged(buf_T *buf, int ff, int always_inc_changedtick)\n{\n    if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))\n    {\n\tbuf->b_changed = 0;\n\tml_setflags(buf);\n\tif (ff)\n\t    save_file_ff(buf);\n\tcheck_status(buf);\n\tredraw_tabline = TRUE;\n\tneed_maketitle = TRUE;\t    // set window title later\n\t++CHANGEDTICK(buf);\n    }\n    else if (always_inc_changedtick)\n\t++CHANGEDTICK(buf);\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_unmodified(buf);\n#endif\n}\n\n/*\n * Save the current values of 'fileformat' and 'fileencoding', so that we know\n * the file must be considered changed when the value is different.\n */\n    void\nsave_file_ff(buf_T *buf)\n{\n    buf->b_start_ffc = *buf->b_p_ff;\n    buf->b_start_eol = buf->b_p_eol;\n    buf->b_start_bomb = buf->b_p_bomb;\n\n    // Only use free/alloc when necessary, they take time.\n    if (buf->b_start_fenc == NULL\n\t\t\t     || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0)\n    {\n\tvim_free(buf->b_start_fenc);\n\tbuf->b_start_fenc = vim_strsave(buf->b_p_fenc);\n    }\n}\n\n/*\n * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value\n * from when editing started (save_file_ff() called).\n * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was\n * changed and 'binary' is not set.\n * Also when 'endofline' was changed and 'fixeol' is not set.\n * When \"ignore_empty\" is true don't consider a new, empty buffer to be\n * changed.\n */\n    int\nfile_ff_differs(buf_T *buf, int ignore_empty)\n{\n    // In a buffer that was never loaded the options are not valid.\n    if (buf->b_flags & BF_NEVERLOADED)\n\treturn FALSE;\n    if (ignore_empty\n\t    && (buf->b_flags & BF_NEW)\n\t    && buf->b_ml.ml_line_count == 1\n\t    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)\n\treturn FALSE;\n    if (buf->b_start_ffc != *buf->b_p_ff)\n\treturn TRUE;\n    if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol)\n\treturn TRUE;\n    if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)\n\treturn TRUE;\n    if (buf->b_start_fenc == NULL)\n\treturn (*buf->b_p_fenc != NUL);\n    return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);\n}\n\n/*\n * Insert string \"p\" at the cursor position.  Stops at a NUL byte.\n * Handles Replace mode and multi-byte characters.\n */\n    void\nins_bytes(char_u *p)\n{\n    ins_bytes_len(p, (int)STRLEN(p));\n}\n\n/*\n * Insert string \"p\" with length \"len\" at the cursor position.\n * Handles Replace mode and multi-byte characters.\n */\n    void\nins_bytes_len(char_u *p, int len)\n{\n    int\t\ti;\n    int\t\tn;\n\n    if (has_mbyte)\n\tfor (i = 0; i < len; i += n)\n\t{\n\t    if (enc_utf8)\n\t\t// avoid reading past p[len]\n\t\tn = utfc_ptr2len_len(p + i, len - i);\n\t    else\n\t\tn = (*mb_ptr2len)(p + i);\n\t    ins_char_bytes(p + i, n);\n\t}\n    else\n\tfor (i = 0; i < len; ++i)\n\t    ins_char(p[i]);\n}\n\n/*\n * Insert or replace a single character at the cursor position.\n * When in MODE_REPLACE or MODE_VREPLACE state, replace any existing character.\n * Caller must have prepared for undo.\n * For multi-byte characters we get the whole character, the caller must\n * convert bytes to a character.\n */\n    void\nins_char(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tn = (*mb_char2bytes)(c, buf);\n\n    // When \"c\" is 0x100, 0x200, etc. we don't want to insert a NUL byte.\n    // Happens for CTRL-Vu9900.\n    if (buf[0] == 0)\n\tbuf[0] = '\\n';\n\n    ins_char_bytes(buf, n);\n}\n\n    void\nins_char_bytes(char_u *buf, int charlen)\n{\n    int\t\tc = buf[0];\n    int\t\tnewlen;\t\t// nr of bytes inserted\n    int\t\toldlen;\t\t// nr of bytes deleted (0 when not replacing)\n    char_u\t*p;\n    char_u\t*newp;\n    char_u\t*oldp;\n    int\t\tlinelen;\t// length of old line including NUL\n    colnr_T\tcol;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\ti;\n\n    // Break tabs if needed.\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance_force(getviscol());\n\n    col = curwin->w_cursor.col;\n    oldp = ml_get(lnum);\n    linelen = (int)STRLEN(oldp) + 1;\n\n    // The lengths default to the values for when not replacing.\n    oldlen = 0;\n    newlen = charlen;\n\n    if (State & REPLACE_FLAG)\n    {\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    colnr_T\tnew_vcol = 0;   // init for GCC\n\t    colnr_T\tvcol;\n\t    int\t\told_list;\n\n\t    // Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.\n\t    // Returns the old value of list, so when finished,\n\t    // curwin->w_p_list should be set back to this.\n\t    old_list = curwin->w_p_list;\n\t    if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t\tcurwin->w_p_list = FALSE;\n\n\t    // In virtual replace mode each character may replace one or more\n\t    // characters (zero if it's a TAB).  Count the number of bytes to\n\t    // be deleted to make room for the new character, counting screen\n\t    // cells.  May result in adding spaces to fill a gap.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);\n\t    new_vcol = vcol + chartabsize(buf, vcol);\n\t    while (oldp[col + oldlen] != NUL && vcol < new_vcol)\n\t    {\n\t\tvcol += chartabsize(oldp + col + oldlen, vcol);\n\t\t// Don't need to remove a TAB that takes us to the right\n\t\t// position.\n\t\tif (vcol > new_vcol && oldp[col + oldlen] == TAB)\n\t\t    break;\n\t\toldlen += (*mb_ptr2len)(oldp + col + oldlen);\n\t\t// Deleted a bit too much, insert spaces.\n\t\tif (vcol > new_vcol)\n\t\t    newlen += vcol - new_vcol;\n\t    }\n\t    curwin->w_p_list = old_list;\n\t}\n\telse if (oldp[col] != NUL)\n\t{\n\t    // normal replace\n\t    oldlen = (*mb_ptr2len)(oldp + col);\n\t}\n\n\n\t// Push the replaced bytes onto the replace stack, so that they can be\n\t// put back when BS is used.  The bytes of a multi-byte character are\n\t// done the other way around, so that the first byte is popped off\n\t// first (it tells the byte length of the character).\n\treplace_push(NUL);\n\tfor (i = 0; i < oldlen; ++i)\n\t{\n\t    if (has_mbyte)\n\t\ti += replace_push_mb(oldp + col + i) - 1;\n\t    else\n\t\treplace_push(oldp[col + i]);\n\t}\n    }\n\n    newp = alloc(linelen + newlen - oldlen);\n    if (newp == NULL)\n\treturn;\n\n    // Copy bytes before the cursor.\n    if (col > 0)\n\tmch_memmove(newp, oldp, (size_t)col);\n\n    // Copy bytes after the changed character(s).\n    p = newp + col;\n    if (linelen > col + oldlen)\n\tmch_memmove(p + newlen, oldp + col + oldlen,\n\t\t\t\t\t    (size_t)(linelen - col - oldlen));\n\n    // Insert or overwrite the new character.\n    mch_memmove(p, buf, charlen);\n    i = charlen;\n\n    // Fill with spaces when necessary.\n    while (i < newlen)\n\tp[i++] = ' ';\n\n    // Replace the line in the buffer.\n    ml_replace(lnum, newp, FALSE);\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, col, newlen - oldlen);\n\n    // If we're in Insert or Replace mode and 'showmatch' is set, then briefly\n    // show the match for right parens and braces.\n    if (p_sm && (State & MODE_INSERT)\n\t    && msg_silent == 0\n\t    && !ins_compl_active())\n    {\n\tif (has_mbyte)\n\t    showmatch(mb_ptr2char(buf));\n\telse\n\t    showmatch(c);\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (!p_ri || (State & REPLACE_FLAG))\n#endif\n    {\n\t// Normal insert: move cursor right\n\tcurwin->w_cursor.col += charlen;\n    }\n\n    // TODO: should try to update w_row here, to avoid recomputing it later.\n}\n\n/*\n * Insert a string at the cursor position.\n * Note: Does NOT handle Replace mode.\n * Caller must have prepared for undo.\n */\n    void\nins_str(char_u *s)\n{\n    char_u\t*oldp, *newp;\n    int\t\tnewlen = (int)STRLEN(s);\n    int\t\toldlen;\n    colnr_T\tcol;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance_force(getviscol());\n\n    col = curwin->w_cursor.col;\n    oldp = ml_get(lnum);\n    oldlen = (int)STRLEN(oldp);\n\n    newp = alloc(oldlen + newlen + 1);\n    if (newp == NULL)\n\treturn;\n    if (col > 0)\n\tmch_memmove(newp, oldp, (size_t)col);\n    mch_memmove(newp + col, s, (size_t)newlen);\n    mch_memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));\n    ml_replace(lnum, newp, FALSE);\n    inserted_bytes(lnum, col, newlen);\n    curwin->w_cursor.col += newlen;\n}\n\n/*\n * Delete one character under the cursor.\n * If \"fixpos\" is TRUE, don't leave the cursor on the NUL after the line.\n * Caller must have prepared for undo.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndel_char(int fixpos)\n{\n    if (has_mbyte)\n    {\n\t// Make sure the cursor is at the start of a character.\n\tmb_adjust_cursor();\n\tif (*ml_get_cursor() == NUL)\n\t    return FAIL;\n\treturn del_chars(1L, fixpos);\n    }\n    return del_bytes(1L, fixpos, TRUE);\n}\n\n/*\n * Like del_bytes(), but delete characters instead of bytes.\n */\n    int\ndel_chars(long count, int fixpos)\n{\n    long\tbytes = 0;\n    long\ti;\n    char_u\t*p;\n    int\t\tl;\n\n    p = ml_get_cursor();\n    for (i = 0; i < count && *p != NUL; ++i)\n    {\n\tl = (*mb_ptr2len)(p);\n\tbytes += l;\n\tp += l;\n    }\n    return del_bytes(bytes, fixpos, TRUE);\n}\n\n/*\n * Delete \"count\" bytes under the cursor.\n * If \"fixpos\" is TRUE, don't leave the cursor on the NUL after the line.\n * Caller must have prepared for undo.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndel_bytes(\n    long\tcount,\n    int\t\tfixpos_arg,\n    int\t\tuse_delcombine UNUSED)\t    // 'delcombine' option applies\n{\n    char_u\t*oldp, *newp;\n    colnr_T\toldlen;\n    colnr_T\tnewlen;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    int\t\talloc_newp;\n    long\tmovelen;\n    int\t\tfixpos = fixpos_arg;\n\n    oldp = ml_get(lnum);\n    oldlen = (int)STRLEN(oldp);\n\n    // Can't do anything when the cursor is on the NUL after the line.\n    if (col >= oldlen)\n\treturn FAIL;\n\n    // If \"count\" is zero there is nothing to do.\n    if (count == 0)\n\treturn OK;\n\n    // If \"count\" is negative the caller must be doing something wrong.\n    if (count < 1)\n    {\n\tsiemsg(e_invalid_count_for_del_bytes_nr, count);\n\treturn FAIL;\n    }\n\n    // If 'delcombine' is set and deleting (less than) one character, only\n    // delete the last combining character.\n    if (p_deco && use_delcombine && enc_utf8\n\t\t\t\t\t && utfc_ptr2len(oldp + col) >= count)\n    {\n\tint\tcc[MAX_MCO];\n\tint\tn;\n\n\t(void)utfc_ptr2char(oldp + col, cc);\n\tif (cc[0] != NUL)\n\t{\n\t    // Find the last composing char, there can be several.\n\t    n = col;\n\t    do\n\t    {\n\t\tcol = n;\n\t\tcount = utf_ptr2len(oldp + n);\n\t\tn += count;\n\t    } while (UTF_COMPOSINGLIKE(oldp + col, oldp + n));\n\t    fixpos = 0;\n\t}\n    }\n\n    // When count is too big, reduce it.\n    movelen = (long)oldlen - (long)col - count + 1; // includes trailing NUL\n    if (movelen <= 1)\n    {\n\t// If we just took off the last character of a non-blank line, and\n\t// fixpos is TRUE, we don't want to end up positioned at the NUL,\n\t// unless \"restart_edit\" is set or 'virtualedit' contains \"onemore\".\n\tif (col > 0 && fixpos && restart_edit == 0\n\t\t\t\t\t      && (get_ve_flags() & VE_ONEMORE) == 0)\n\t{\n\t    --curwin->w_cursor.col;\n\t    curwin->w_cursor.coladd = 0;\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col -=\n\t\t\t    (*mb_head_off)(oldp, oldp + curwin->w_cursor.col);\n\t}\n\tcount = oldlen - col;\n\tmovelen = 1;\n    }\n    newlen = oldlen - count;\n\n    // If the old line has been allocated the deletion can be done in the\n    // existing line. Otherwise a new line has to be allocated\n    // Can't do this when using Netbeans, because we would need to invoke\n    // netbeans_removed(), which deallocates the line.  Let ml_replace() take\n    // care of notifying Netbeans.\n#ifdef FEAT_NETBEANS_INTG\n    if (netbeans_active())\n\talloc_newp = TRUE;\n    else\n#endif\n\talloc_newp = !ml_line_alloced();    // check if oldp was allocated\n    if (!alloc_newp)\n\tnewp = oldp;\t\t\t    // use same allocated memory\n    else\n    {\t\t\t\t\t    // need to allocate a new line\n\tnewp = alloc(newlen + 1);\n\tif (newp == NULL)\n\t    return FAIL;\n\tmch_memmove(newp, oldp, (size_t)col);\n    }\n    mch_memmove(newp + col, oldp + col + count, (size_t)movelen);\n    if (alloc_newp)\n\tml_replace(lnum, newp, FALSE);\n#ifdef FEAT_PROP_POPUP\n    else\n    {\n\t// Also move any following text properties.\n\tif (oldlen + 1 < curbuf->b_ml.ml_line_len)\n\t    mch_memmove(newp + newlen + 1, oldp + oldlen + 1,\n\t\t\t       (size_t)curbuf->b_ml.ml_line_len - oldlen - 1);\n\tcurbuf->b_ml.ml_line_len -= count;\n    }\n#endif\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, col, -count);\n\n    return OK;\n}\n\n/*\n * open_line: Add a new line below or above the current line.\n *\n * For MODE_VREPLACE state, we only add a new line when we get to the end of\n * the file, otherwise we just start replacing the next line.\n *\n * Caller must take care of undo.  Since MODE_VREPLACE may affect any number of\n * lines however, it may call u_save_cursor() again when starting to change a\n * new line.\n * \"flags\": OPENLINE_DELSPACES\tdelete spaces after cursor\n *\t    OPENLINE_DO_COM\tformat comments\n *\t    OPENLINE_KEEPTRAIL\tkeep trailing spaces\n *\t    OPENLINE_MARKFIX\tadjust mark positions after the line break\n *\t    OPENLINE_COM_LIST\tformat comments with list or 2nd line indent\n *\n * \"second_line_indent\": indent for after ^^D in Insert mode or if flag\n *\t\t\t  OPENLINE_COM_LIST\n * \"did_do_comment\" is set to TRUE when intentionally putting the comment\n * leader in fromt of the new line.\n *\n * Return OK for success, FAIL for failure\n */\n    int\nopen_line(\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tflags,\n    int\t\tsecond_line_indent,\n    int\t\t*did_do_comment UNUSED)\n{\n    char_u\t*saved_line;\t\t// copy of the original line\n    char_u\t*next_line = NULL;\t// copy of the next line\n    char_u\t*p_extra = NULL;\t// what goes to next line\n    int\t\tless_cols = 0;\t\t// less columns for mark in new line\n    int\t\tless_cols_off = 0;\t// columns to skip for mark and\n\t\t\t\t\t// textprop adjustment\n    pos_T\told_cursor;\t\t// old cursor position\n    int\t\tnewcol = 0;\t\t// new cursor column\n    int\t\tnewindent = 0;\t\t// auto-indent of the new line\n    int\t\tn;\n    int\t\ttrunc_line = FALSE;\t// truncate current line afterwards\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\textra_len = 0;\t\t// length of p_extra string\n    int\t\tlead_len;\t\t// length of comment leader\n    int\t\tcomment_start = 0;\t// start index of the comment leader\n    char_u\t*lead_flags;\t// position in 'comments' for comment leader\n    char_u\t*leader = NULL;\t\t// copy of comment leader\n    char_u\t*allocated = NULL;\t// allocated memory\n    char_u\t*p;\n    int\t\tsaved_char = NUL;\t// init for GCC\n    pos_T\t*pos;\n#ifdef FEAT_CINDENT\n    int\t\tdo_cindent;\n#endif\n#ifdef FEAT_SMARTINDENT\n    int\t\tdo_si = may_do_si();\n    int\t\tno_si = FALSE;\t\t// reset did_si afterwards\n    int\t\tfirst_char = NUL;\t// init for GCC\n#endif\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    int\t\tvreplace_mode;\n#endif\n    int\t\tdid_append;\t\t// appended a new line\n    int\t\tsaved_pi = curbuf->b_p_pi; // copy of preserveindent setting\n\n    // make a copy of the current line so we can mess with it\n    saved_line = vim_strsave(ml_get_curline());\n    if (saved_line == NULL)\t    // out of memory!\n\treturn FALSE;\n\n    if (State & VREPLACE_FLAG)\n    {\n\t// With MODE_VREPLACE we make a copy of the next line, which we will be\n\t// starting to replace.  First make the new line empty and let vim play\n\t// with the indenting and comment leader to its heart's content.  Then\n\t// we grab what it ended up putting on the new line, put back the\n\t// original line, and call ins_char() to put each new character onto\n\t// the line, replacing what was there before and pushing the right\n\t// stuff onto the replace stack.  -- webb.\n\tif (curwin->w_cursor.lnum < orig_line_count)\n\t    next_line = vim_strsave(ml_get(curwin->w_cursor.lnum + 1));\n\telse\n\t    next_line = vim_strsave((char_u *)\"\");\n\tif (next_line == NULL)\t    // out of memory!\n\t    goto theend;\n\n\t// In MODE_VREPLACE state, a NL replaces the rest of the line, and\n\t// starts replacing the next line, so push all of the characters left\n\t// on the line onto the replace stack.  We'll push any other characters\n\t// that might be replaced at the start of the next line (due to\n\t// autoindent etc) a bit later.\n\treplace_push(NUL);  // Call twice because BS over NL expects it\n\treplace_push(NUL);\n\tp = saved_line + curwin->w_cursor.col;\n\twhile (*p != NUL)\n\t{\n\t    if (has_mbyte)\n\t\tp += replace_push_mb(p);\n\t    else\n\t\treplace_push(*p++);\n\t}\n\tsaved_line[curwin->w_cursor.col] = NUL;\n    }\n\n    if ((State & MODE_INSERT) && (State & VREPLACE_FLAG) == 0)\n    {\n\tp_extra = saved_line + curwin->w_cursor.col;\n#ifdef FEAT_SMARTINDENT\n\tif (do_si)\t\t// need first char after new line break\n\t{\n\t    p = skipwhite(p_extra);\n\t    first_char = *p;\n\t}\n#endif\n\textra_len = (int)STRLEN(p_extra);\n\tsaved_char = *p_extra;\n\t*p_extra = NUL;\n    }\n\n    u_clearline();\t\t// cannot do \"U\" command when adding lines\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n#endif\n    ai_col = 0;\n\n    // If we just did an auto-indent, then we didn't type anything on\n    // the prior line, and it should be truncated.  Do this even if 'ai' is not\n    // set because automatically inserting a comment leader also sets did_ai.\n    if (dir == FORWARD && did_ai)\n\ttrunc_line = TRUE;\n\n    // If 'autoindent' and/or 'smartindent' is set, try to figure out what\n    // indent to use for the new line.\n    if (curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t|| do_si\n#endif\n\t\t\t\t\t    )\n    {\n\t// count white space on current line\n#ifdef FEAT_VARTABS\n\tnewindent = get_indent_str_vtab(saved_line, curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n\tnewindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);\n#endif\n\tif (newindent == 0 && !(flags & OPENLINE_COM_LIST))\n\t    newindent = second_line_indent; // for ^^D command in insert mode\n\n#ifdef FEAT_SMARTINDENT\n\t// Do smart indenting.\n\t// In insert/replace mode (only when dir == FORWARD)\n\t// we may move some text to the next line. If it starts with '{'\n\t// don't add an indent. Fixes inserting a NL before '{' in line\n\t//\t\"if (condition) {\"\n\tif (!trunc_line && do_si && *saved_line != NUL\n\t\t\t\t    && (p_extra == NULL || first_char != '{'))\n\t{\n\t    char_u  *ptr;\n\t    char_u  last_char;\n\n\t    old_cursor = curwin->w_cursor;\n\t    ptr = saved_line;\n\t    if (flags & OPENLINE_DO_COM)\n\t\tlead_len = get_leader_len(ptr, NULL, FALSE, TRUE);\n\t    else\n\t\tlead_len = 0;\n\t    if (dir == FORWARD)\n\t    {\n\t\t// Skip preprocessor directives, unless they are\n\t\t// recognised as comments.\n\t\tif ( lead_len == 0 && ptr[0] == '#')\n\t\t{\n\t\t    while (ptr[0] == '#' && curwin->w_cursor.lnum > 1)\n\t\t\tptr = ml_get(--curwin->w_cursor.lnum);\n\t\t    newindent = get_indent();\n\t\t}\n\t\tif (flags & OPENLINE_DO_COM)\n\t\t    lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);\n\t\telse\n\t\t    lead_len = 0;\n\t\tif (lead_len > 0)\n\t\t{\n\t\t    // This case gets the following right:\n\t\t    //\t    /*\n\t\t    //\t     * A comment (read '\\' as '/').\n\t\t    //\t     */\n\t\t    // #define IN_THE_WAY\n\t\t    //\t    This should line up here;\n\t\t    p = skipwhite(ptr);\n\t\t    if (p[0] == '/' && p[1] == '*')\n\t\t\tp++;\n\t\t    if (p[0] == '*')\n\t\t    {\n\t\t\tfor (p++; *p; p++)\n\t\t\t{\n\t\t\t    if (p[0] == '/' && p[-1] == '*')\n\t\t\t    {\n\t\t\t\t// End of C comment, indent should line up\n\t\t\t\t// with the line containing the start of\n\t\t\t\t// the comment\n\t\t\t\tcurwin->w_cursor.col = (colnr_T)(p - ptr);\n\t\t\t\tif ((pos = findmatch(NULL, NUL)) != NULL)\n\t\t\t\t{\n\t\t\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t\t\t    newindent = get_indent();\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\t// Not a comment line\n\t\t{\n\t\t    // Find last non-blank in line\n\t\t    p = ptr + STRLEN(ptr) - 1;\n\t\t    while (p > ptr && VIM_ISWHITE(*p))\n\t\t\t--p;\n\t\t    last_char = *p;\n\n\t\t    // find the character just before the '{' or ';'\n\t\t    if (last_char == '{' || last_char == ';')\n\t\t    {\n\t\t\tif (p > ptr)\n\t\t\t    --p;\n\t\t\twhile (p > ptr && VIM_ISWHITE(*p))\n\t\t\t    --p;\n\t\t    }\n\t\t    // Try to catch lines that are split over multiple\n\t\t    // lines.  eg:\n\t\t    //\t    if (condition &&\n\t\t    //\t\t\tcondition) {\n\t\t    //\t\tShould line up here!\n\t\t    //\t    }\n\t\t    if (*p == ')')\n\t\t    {\n\t\t\tcurwin->w_cursor.col = (colnr_T)(p - ptr);\n\t\t\tif ((pos = findmatch(NULL, '(')) != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t\t    newindent = get_indent();\n\t\t\t    ptr = ml_get_curline();\n\t\t\t}\n\t\t    }\n\t\t    // If last character is '{' do indent, without\n\t\t    // checking for \"if\" and the like.\n\t\t    if (last_char == '{')\n\t\t    {\n\t\t\tdid_si = TRUE;\t// do indent\n\t\t\tno_si = TRUE;\t// don't delete it when '{' typed\n\t\t    }\n\t\t    // Look for \"if\" and the like, use 'cinwords'.\n\t\t    // Don't do this if the previous line ended in ';' or\n\t\t    // '}'.\n\t\t    else if (last_char != ';' && last_char != '}'\n\t\t\t\t\t\t       && cin_is_cinword(ptr))\n\t\t\tdid_si = TRUE;\n\t\t}\n\t    }\n\t    else // dir == BACKWARD\n\t    {\n\t\t// Skip preprocessor directives, unless they are\n\t\t// recognised as comments.\n\t\tif (lead_len == 0 && ptr[0] == '#')\n\t\t{\n\t\t    int was_backslashed = FALSE;\n\n\t\t    while ((ptr[0] == '#' || was_backslashed) &&\n\t\t\t curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\tif (*ptr && ptr[STRLEN(ptr) - 1] == '\\\\')\n\t\t\t    was_backslashed = TRUE;\n\t\t\telse\n\t\t\t    was_backslashed = FALSE;\n\t\t\tptr = ml_get(++curwin->w_cursor.lnum);\n\t\t    }\n\t\t    if (was_backslashed)\n\t\t\tnewindent = 0;\t    // Got to end of file\n\t\t    else\n\t\t\tnewindent = get_indent();\n\t\t}\n\t\tp = skipwhite(ptr);\n\t\tif (*p == '}')\t    // if line starts with '}': do indent\n\t\t    did_si = TRUE;\n\t\telse\t\t    // can delete indent when '{' typed\n\t\t    can_si_back = TRUE;\n\t    }\n\t    curwin->w_cursor = old_cursor;\n\t}\n\tif (do_si)\n\t    can_si = TRUE;\n#endif // FEAT_SMARTINDENT\n\n\tdid_ai = TRUE;\n    }\n\n#ifdef FEAT_CINDENT\n    // May do indenting after opening a new line.\n    do_cindent = !p_paste && (curbuf->b_p_cin\n# ifdef FEAT_EVAL\n\t\t    || *curbuf->b_p_inde != NUL\n# endif\n\t\t)\n\t    && in_cinkeys(dir == FORWARD\n\t\t? KEY_OPEN_FORW\n\t\t: KEY_OPEN_BACK, ' ', linewhite(curwin->w_cursor.lnum));\n#endif\n\n    // Find out if the current line starts with a comment leader.\n    // This may then be inserted in front of the new line.\n    end_comment_pending = NUL;\n    if (flags & OPENLINE_DO_COM)\n    {\n\tlead_len = get_leader_len(saved_line, &lead_flags,\n\t\t\t\t\t\t\tdir == BACKWARD, TRUE);\n#ifdef FEAT_CINDENT\n\tif (lead_len == 0 && curbuf->b_p_cin && do_cindent && dir == FORWARD\n\t\t\t\t\t&& !has_format_option(FO_NO_OPEN_COMS))\n\t{\n\t    // Check for a line comment after code.\n\t    comment_start = check_linecomment(saved_line);\n\t    if (comment_start != MAXCOL)\n\t    {\n\t\tlead_len = get_leader_len(saved_line + comment_start,\n\t\t\t\t\t\t     &lead_flags, FALSE, TRUE);\n\t\tif (lead_len != 0)\n\t\t{\n\t\t    lead_len += comment_start;\n\t\t    if (did_do_comment != NULL)\n\t\t\t*did_do_comment = TRUE;\n\t\t}\n\t    }\n\t}\n#endif\n    }\n    else\n\tlead_len = 0;\n    if (lead_len > 0)\n    {\n\tchar_u\t*lead_repl = NULL;\t    // replaces comment leader\n\tint\tlead_repl_len = 0;\t    // length of *lead_repl\n\tchar_u\tlead_middle[COM_MAX_LEN];   // middle-comment string\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tchar_u\t*comment_end = NULL;\t    // where lead_end has been found\n\tint\textra_space = FALSE;\t    // append extra space\n\tint\tcurrent_flag;\n\tint\trequire_blank = FALSE;\t    // requires blank after middle\n\tchar_u\t*p2;\n\n\t// If the comment leader has the start, middle or end flag, it may not\n\t// be used or may be replaced with the middle leader.\n\tfor (p = lead_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_BLANK)\n\t    {\n\t\trequire_blank = TRUE;\n\t\tcontinue;\n\t    }\n\t    if (*p == COM_START || *p == COM_MIDDLE)\n\t    {\n\t\tcurrent_flag = *p;\n\t\tif (*p == COM_START)\n\t\t{\n\t\t    // Doing \"O\" on a start of comment does not insert leader.\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\tlead_len = 0;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // find start of middle part\n\t\t    (void)copy_option_part(&p, lead_middle, COM_MAX_LEN, \",\");\n\t\t    require_blank = FALSE;\n\t\t}\n\n\t\t// Isolate the strings of the middle and end leader.\n\t\twhile (*p && p[-1] != ':')\t// find end of middle flags\n\t\t{\n\t\t    if (*p == COM_BLANK)\n\t\t\trequire_blank = TRUE;\n\t\t    ++p;\n\t\t}\n\t\t(void)copy_option_part(&p, lead_middle, COM_MAX_LEN, \",\");\n\n\t\twhile (*p && p[-1] != ':')\t// find end of end flags\n\t\t{\n\t\t    // Check whether we allow automatic ending of comments\n\t\t    if (*p == COM_AUTO_END)\n\t\t\tend_comment_pending = -1; // means we want to set it\n\t\t    ++p;\n\t\t}\n\t\tn = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t\tif (end_comment_pending == -1)\t// we can set it now\n\t\t    end_comment_pending = lead_end[n - 1];\n\n\t\t// If the end of the comment is in the same line, don't use\n\t\t// the comment leader.\n\t\tif (dir == FORWARD)\n\t\t{\n\t\t    for (p = saved_line + lead_len; *p; ++p)\n\t\t\tif (STRNCMP(p, lead_end, n) == 0)\n\t\t\t{\n\t\t\t    comment_end = p;\n\t\t\t    lead_len = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\n\t\t// Doing \"o\" on a start of comment inserts the middle leader.\n\t\tif (lead_len > 0)\n\t\t{\n\t\t    if (current_flag == COM_START)\n\t\t    {\n\t\t\tlead_repl = lead_middle;\n\t\t\tlead_repl_len = (int)STRLEN(lead_middle);\n\t\t    }\n\n\t\t    // If we have hit RETURN immediately after the start\n\t\t    // comment leader, then put a space after the middle\n\t\t    // comment leader on the next line.\n\t\t    if (!VIM_ISWHITE(saved_line[lead_len - 1])\n\t\t\t    && ((p_extra != NULL\n\t\t\t\t    && (int)curwin->w_cursor.col == lead_len)\n\t\t\t\t|| (p_extra == NULL\n\t\t\t\t    && saved_line[lead_len] == NUL)\n\t\t\t\t|| require_blank))\n\t\t\textra_space = TRUE;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (*p == COM_END)\n\t    {\n\t\t// Doing \"o\" on the end of a comment does not insert leader.\n\t\t// Remember where the end is, might want to use it to find the\n\t\t// start (for C-comments).\n\t\tif (dir == FORWARD)\n\t\t{\n\t\t    comment_end = skipwhite(saved_line);\n\t\t    lead_len = 0;\n\t\t    break;\n\t\t}\n\n\t\t// Doing \"O\" on the end of a comment inserts the middle leader.\n\t\t// Find the string for the middle leader, searching backwards.\n\t\twhile (p > curbuf->b_p_com && *p != ',')\n\t\t    --p;\n\t\tfor (lead_repl = p; lead_repl > curbuf->b_p_com\n\t\t\t\t\t && lead_repl[-1] != ':'; --lead_repl)\n\t\t    ;\n\t\tlead_repl_len = (int)(p - lead_repl);\n\n\t\t// We can probably always add an extra space when doing \"O\" on\n\t\t// the comment-end\n\t\textra_space = TRUE;\n\n\t\t// Check whether we allow automatic ending of comments\n\t\tfor (p2 = p; *p2 && *p2 != ':'; p2++)\n\t\t{\n\t\t    if (*p2 == COM_AUTO_END)\n\t\t\tend_comment_pending = -1; // means we want to set it\n\t\t}\n\t\tif (end_comment_pending == -1)\n\t\t{\n\t\t    // Find last character in end-comment string\n\t\t    while (*p2 && *p2 != ',')\n\t\t\tp2++;\n\t\t    end_comment_pending = p2[-1];\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (*p == COM_FIRST)\n\t    {\n\t\t// Comment leader for first line only:\tDon't repeat leader\n\t\t// when using \"O\", blank out leader when using \"o\".\n\t\tif (dir == BACKWARD)\n\t\t    lead_len = 0;\n\t\telse\n\t\t{\n\t\t    lead_repl = (char_u *)\"\";\n\t\t    lead_repl_len = 0;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (lead_len)\n\t{\n\t    // allocate buffer (may concatenate p_extra later)\n\t    leader = alloc(lead_len + lead_repl_len + extra_space + extra_len\n\t\t     + (second_line_indent > 0 ? second_line_indent : 0) + 1);\n\t    allocated = leader;\t\t    // remember to free it later\n\n\t    if (leader == NULL)\n\t\tlead_len = 0;\n\t    else\n\t    {\n\t\tint li;\n\n\t\tvim_strncpy(leader, saved_line, lead_len);\n\n\t\t// TODO: handle multi-byte and double width chars\n\t\tfor (li = 0; li < comment_start; ++li)\n\t\t    if (!VIM_ISWHITE(leader[li]))\n\t\t\tleader[li] = ' ';\n\n\t\t// Replace leader with lead_repl, right or left adjusted\n\t\tif (lead_repl != NULL)\n\t\t{\n\t\t    int\t\tc = 0;\n\t\t    int\t\toff = 0;\n\n\t\t    for (p = lead_flags; *p != NUL && *p != ':'; )\n\t\t    {\n\t\t\tif (*p == COM_RIGHT || *p == COM_LEFT)\n\t\t\t    c = *p++;\n\t\t\telse if (VIM_ISDIGIT(*p) || *p == '-')\n\t\t\t    off = getdigits(&p);\n\t\t\telse\n\t\t\t    ++p;\n\t\t    }\n\t\t    if (c == COM_RIGHT)    // right adjusted leader\n\t\t    {\n\t\t\t// find last non-white in the leader to line up with\n\t\t\tfor (p = leader + lead_len - 1; p > leader\n\t\t\t\t\t\t      && VIM_ISWHITE(*p); --p)\n\t\t\t    ;\n\t\t\t++p;\n\n\t\t\t// Compute the length of the replaced characters in\n\t\t\t// screen characters, not bytes.\n\t\t\t{\n\t\t\t    int\t    repl_size = vim_strnsize(lead_repl,\n\t\t\t\t\t\t\t       lead_repl_len);\n\t\t\t    int\t    old_size = 0;\n\t\t\t    char_u  *endp = p;\n\t\t\t    int\t    l;\n\n\t\t\t    while (old_size < repl_size && p > leader)\n\t\t\t    {\n\t\t\t\tMB_PTR_BACK(leader, p);\n\t\t\t\told_size += ptr2cells(p);\n\t\t\t    }\n\t\t\t    l = lead_repl_len - (int)(endp - p);\n\t\t\t    if (l != 0)\n\t\t\t\tmch_memmove(endp + l, endp,\n\t\t\t\t\t(size_t)((leader + lead_len) - endp));\n\t\t\t    lead_len += l;\n\t\t\t}\n\t\t\tmch_memmove(p, lead_repl, (size_t)lead_repl_len);\n\t\t\tif (p + lead_repl_len > leader + lead_len)\n\t\t\t    p[lead_repl_len] = NUL;\n\n\t\t\t// blank-out any other chars from the old leader.\n\t\t\twhile (--p >= leader)\n\t\t\t{\n\t\t\t    int l = mb_head_off(leader, p);\n\n\t\t\t    if (l > 1)\n\t\t\t    {\n\t\t\t\tp -= l;\n\t\t\t\tif (ptr2cells(p) > 1)\n\t\t\t\t{\n\t\t\t\t    p[1] = ' ';\n\t\t\t\t    --l;\n\t\t\t\t}\n\t\t\t\tmch_memmove(p + 1, p + l + 1,\n\t\t\t\t   (size_t)((leader + lead_len) - (p + l + 1)));\n\t\t\t\tlead_len -= l;\n\t\t\t\t*p = ' ';\n\t\t\t    }\n\t\t\t    else if (!VIM_ISWHITE(*p))\n\t\t\t\t*p = ' ';\n\t\t\t}\n\t\t    }\n\t\t    else\t// left adjusted leader\n\t\t    {\n\t\t\tp = skipwhite(leader);\n\n\t\t\t// Compute the length of the replaced characters in\n\t\t\t// screen characters, not bytes. Move the part that is\n\t\t\t// not to be overwritten.\n\t\t\t{\n\t\t\t    int\t    repl_size = vim_strnsize(lead_repl,\n\t\t\t\t\t\t\t       lead_repl_len);\n\t\t\t    int\t    i;\n\t\t\t    int\t    l;\n\n\t\t\t    for (i = 0; i < lead_len && p[i] != NUL; i += l)\n\t\t\t    {\n\t\t\t\tl = (*mb_ptr2len)(p + i);\n\t\t\t\tif (vim_strnsize(p, i + l) > repl_size)\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (i != lead_repl_len)\n\t\t\t    {\n\t\t\t\tmch_memmove(p + lead_repl_len, p + i,\n\t\t\t\t       (size_t)(lead_len - i - (p - leader)));\n\t\t\t\tlead_len += lead_repl_len - i;\n\t\t\t    }\n\t\t\t}\n\t\t\tmch_memmove(p, lead_repl, (size_t)lead_repl_len);\n\n\t\t\t// Replace any remaining non-white chars in the old\n\t\t\t// leader by spaces.  Keep Tabs, the indent must\n\t\t\t// remain the same.\n\t\t\tfor (p += lead_repl_len; p < leader + lead_len; ++p)\n\t\t\t    if (!VIM_ISWHITE(*p))\n\t\t\t    {\n\t\t\t\t// Don't put a space before a TAB.\n\t\t\t\tif (p + 1 < leader + lead_len && p[1] == TAB)\n\t\t\t\t{\n\t\t\t\t    --lead_len;\n\t\t\t\t    mch_memmove(p, p + 1,\n\t\t\t\t\t\t     (leader + lead_len) - p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    int\t    l = (*mb_ptr2len)(p);\n\n\t\t\t\t    if (l > 1)\n\t\t\t\t    {\n\t\t\t\t\tif (ptr2cells(p) > 1)\n\t\t\t\t\t{\n\t\t\t\t\t    // Replace a double-wide char with\n\t\t\t\t\t    // two spaces\n\t\t\t\t\t    --l;\n\t\t\t\t\t    *p++ = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tmch_memmove(p + 1, p + l,\n\t\t\t\t\t\t     (leader + lead_len) - p);\n\t\t\t\t\tlead_len -= l - 1;\n\t\t\t\t    }\n\t\t\t\t    *p = ' ';\n\t\t\t\t}\n\t\t\t    }\n\t\t\t*p = NUL;\n\t\t    }\n\n\t\t    // Recompute the indent, it may have changed.\n\t\t    if (curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t\t|| do_si\n#endif\n\t\t\t\t\t\t\t   )\n#ifdef FEAT_VARTABS\n\t\t\tnewindent = get_indent_str_vtab(leader, curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n\t\t\tnewindent = get_indent_str(leader,\n\t\t\t\t\t\t   (int)curbuf->b_p_ts, FALSE);\n#endif\n\n\t\t    // Add the indent offset\n\t\t    if (newindent + off < 0)\n\t\t    {\n\t\t\toff = -newindent;\n\t\t\tnewindent = 0;\n\t\t    }\n\t\t    else\n\t\t\tnewindent += off;\n\n\t\t    // Correct trailing spaces for the shift, so that\n\t\t    // alignment remains equal.\n\t\t    while (off > 0 && lead_len > 0\n\t\t\t\t\t       && leader[lead_len - 1] == ' ')\n\t\t    {\n\t\t\t// Don't do it when there is a tab before the space\n\t\t\tif (vim_strchr(skipwhite(leader), '\\t') != NULL)\n\t\t\t    break;\n\t\t\t--lead_len;\n\t\t\t--off;\n\t\t    }\n\n\t\t    // If the leader ends in white space, don't add an\n\t\t    // extra space\n\t\t    if (lead_len > 0 && VIM_ISWHITE(leader[lead_len - 1]))\n\t\t\textra_space = FALSE;\n\t\t    leader[lead_len] = NUL;\n\t\t}\n\n\t\tif (extra_space)\n\t\t{\n\t\t    leader[lead_len++] = ' ';\n\t\t    leader[lead_len] = NUL;\n\t\t}\n\n\t\tnewcol = lead_len;\n\n\t\t// if a new indent will be set below, remove the indent that\n\t\t// is in the comment leader\n\t\tif (newindent\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t|| did_si\n#endif\n\t\t\t\t\t   )\n\t\t{\n\t\t    while (lead_len && VIM_ISWHITE(*leader))\n\t\t    {\n\t\t\t--lead_len;\n\t\t\t--newcol;\n\t\t\t++leader;\n\t\t    }\n\t\t}\n\n\t    }\n#ifdef FEAT_SMARTINDENT\n\t    did_si = can_si = FALSE;\n#endif\n\t}\n\telse if (comment_end != NULL)\n\t{\n\t    // We have finished a comment, so we don't use the leader.\n\t    // If this was a C-comment and 'ai' or 'si' is set do a normal\n\t    // indent to align with the line containing the start of the\n\t    // comment.\n\t    if (comment_end[0] == '*' && comment_end[1] == '/' &&\n\t\t\t(curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t\t|| do_si\n#endif\n\t\t\t\t\t\t\t   ))\n\t    {\n\t\told_cursor = curwin->w_cursor;\n\t\tcurwin->w_cursor.col = (colnr_T)(comment_end - saved_line);\n\t\tif ((pos = findmatch(NULL, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t    newindent = get_indent();\n\t\t}\n\t\tcurwin->w_cursor = old_cursor;\n\t    }\n\t}\n    }\n\n    // (State == MODE_INSERT || State == MODE_REPLACE), only when dir == FORWARD\n    if (p_extra != NULL)\n    {\n\t*p_extra = saved_char;\t\t// restore char that NUL replaced\n\n\t// When 'ai' set or \"flags\" has OPENLINE_DELSPACES, skip to the first\n\t// non-blank.\n\t//\n\t// When in MODE_REPLACE state, put the deleted blanks on the replace\n\t// stack, preceded by a NUL, so they can be put back when a BS is\n\t// entered.\n\tif (REPLACE_NORMAL(State))\n\t    replace_push(NUL);\t    // end of extra blanks\n\tif (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))\n\t{\n\t    while ((*p_extra == ' ' || *p_extra == '\\t')\n\t\t    && (!enc_utf8\n\t\t\t       || !utf_iscomposing(utf_ptr2char(p_extra + 1))))\n\t    {\n\t\tif (REPLACE_NORMAL(State))\n\t\t    replace_push(*p_extra);\n\t\t++p_extra;\n\t\t++less_cols_off;\n\t    }\n\t}\n\n\t// columns for marks adjusted for removed columns\n\tless_cols = (int)(p_extra - saved_line);\n    }\n\n    if (p_extra == NULL)\n\tp_extra = (char_u *)\"\";\t\t    // append empty line\n\n    // concatenate leader and p_extra, if there is a leader\n    if (lead_len)\n    {\n\tif (flags & OPENLINE_COM_LIST && second_line_indent > 0)\n\t{\n\t    int i;\n\t    int padding = second_line_indent\n\t\t\t\t\t  - (newindent + (int)STRLEN(leader));\n\n\t    // Here whitespace is inserted after the comment char.\n\t    // Below, set_indent(newindent, SIN_INSERT) will insert the\n\t    // whitespace needed before the comment char.\n\t    for (i = 0; i < padding; i++)\n\t    {\n\t\tSTRCAT(leader, \" \");\n\t\tless_cols--;\n\t\tnewcol++;\n\t    }\n\t}\n\tSTRCAT(leader, p_extra);\n\tp_extra = leader;\n\tdid_ai = TRUE;\t    // So truncating blanks works with comments\n\tless_cols -= lead_len;\n    }\n    else\n\tend_comment_pending = NUL;  // turns out there was no leader\n\n    old_cursor = curwin->w_cursor;\n    if (dir == BACKWARD)\n\t--curwin->w_cursor.lnum;\n    if (!(State & VREPLACE_FLAG) || old_cursor.lnum >= orig_line_count)\n    {\n\tif (ml_append(curwin->w_cursor.lnum, p_extra, (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    goto theend;\n\t// Postpone calling changed_lines(), because it would mess up folding\n\t// with markers.\n\t// Skip mark_adjust when adding a line after the last one, there can't\n\t// be marks there. But still needed in diff mode.\n\tif (curwin->w_cursor.lnum + 1 < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_p_diff\n#endif\n\t    )\n\t    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\tdid_append = TRUE;\n#ifdef FEAT_PROP_POPUP\n\tif ((State & MODE_INSERT) && (State & VREPLACE_FLAG) == 0)\n\t    // Properties after the split move to the next line.\n\t    adjust_props_for_split(curwin->w_cursor.lnum, curwin->w_cursor.lnum,\n\t\t    curwin->w_cursor.col + 1, 0);\n#endif\n    }\n    else\n    {\n\t// In MODE_VREPLACE state we are starting to replace the next line.\n\tcurwin->w_cursor.lnum++;\n\tif (curwin->w_cursor.lnum >= Insstart.lnum + vr_lines_changed)\n\t{\n\t    // In case we NL to a new line, BS to the previous one, and NL\n\t    // again, we don't want to save the new line for undo twice.\n\t    (void)u_save_cursor();\t\t    // errors are ignored!\n\t    vr_lines_changed++;\n\t}\n\tml_replace(curwin->w_cursor.lnum, p_extra, TRUE);\n\tchanged_bytes(curwin->w_cursor.lnum, 0);\n\tcurwin->w_cursor.lnum--;\n\tdid_append = FALSE;\n    }\n\n    if (newindent\n#ifdef FEAT_SMARTINDENT\n\t\t    || did_si\n#endif\n\t\t\t\t)\n    {\n\t++curwin->w_cursor.lnum;\n#ifdef FEAT_SMARTINDENT\n\tif (did_si)\n\t{\n\t    int sw = (int)get_sw_value(curbuf);\n\n\t    if (p_sr)\n\t\tnewindent -= newindent % sw;\n\t    newindent += sw;\n\t}\n#endif\n\t// Copy the indent\n\tif (curbuf->b_p_ci)\n\t{\n\t    (void)copy_indent(newindent, saved_line);\n\n\t    // Set the 'preserveindent' option so that any further screwing\n\t    // with the line doesn't entirely destroy our efforts to preserve\n\t    // it.  It gets restored at the function end.\n\t    curbuf->b_p_pi = TRUE;\n\t}\n\telse\n\t    (void)set_indent(newindent, SIN_INSERT);\n\tless_cols -= curwin->w_cursor.col;\n\n\tai_col = curwin->w_cursor.col;\n\n\t// In MODE_REPLACE state, for each character in the new indent, there\n\t// must be a NUL on the replace stack, for when it is deleted with BS\n\tif (REPLACE_NORMAL(State))\n\t    for (n = 0; n < (int)curwin->w_cursor.col; ++n)\n\t\treplace_push(NUL);\n\tnewcol += curwin->w_cursor.col;\n#ifdef FEAT_SMARTINDENT\n\tif (no_si)\n\t    did_si = FALSE;\n#endif\n    }\n\n    // In MODE_REPLACE state, for each character in the extra leader, there\n    // must be a NUL on the replace stack, for when it is deleted with BS.\n    if (REPLACE_NORMAL(State))\n\twhile (lead_len-- > 0)\n\t    replace_push(NUL);\n\n    curwin->w_cursor = old_cursor;\n\n    if (dir == FORWARD)\n    {\n\tif (trunc_line || (State & MODE_INSERT))\n\t{\n\t    // truncate current line at cursor\n\t    saved_line[curwin->w_cursor.col] = NUL;\n\t    // Remove trailing white space, unless OPENLINE_KEEPTRAIL used.\n\t    if (trunc_line && !(flags & OPENLINE_KEEPTRAIL))\n\t\ttruncate_spaces(saved_line);\n\t    ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);\n\t    saved_line = NULL;\n\t    if (did_append)\n\t    {\n\t\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 1L);\n\t\tdid_append = FALSE;\n\n\t\t// Move marks after the line break to the new line.\n\t\tif (flags & OPENLINE_MARKFIX)\n\t\t    mark_col_adjust(curwin->w_cursor.lnum,\n\t\t\t\t\t curwin->w_cursor.col + less_cols_off,\n\t\t\t\t\t\t      1L, (long)-less_cols, 0);\n#ifdef FEAT_PROP_POPUP\n\t\t// Keep into account the deleted blanks on the new line.\n\t\tif (curbuf->b_has_textprop && less_cols_off != 0)\n\t\t    adjust_prop_columns(curwin->w_cursor.lnum + 1, 0,\n\t\t\t\t\t\t\t    -less_cols_off, 0);\n#endif\n\t    }\n\t    else\n\t\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t}\n\n\t// Put the cursor on the new line.  Careful: the scrollup() above may\n\t// have moved w_cursor, we must use old_cursor.\n\tcurwin->w_cursor.lnum = old_cursor.lnum + 1;\n    }\n    if (did_append)\n\tchanged_lines(curwin->w_cursor.lnum, 0, curwin->w_cursor.lnum, 1L);\n\n    curwin->w_cursor.col = newcol;\n    curwin->w_cursor.coladd = 0;\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    // In MODE_VREPLACE state, we are handling the replace stack ourselves, so\n    // stop fixthisline() from doing it (via change_indent()) by telling it\n    // we're in normal MODE_INSERT state.\n    if (State & VREPLACE_FLAG)\n    {\n\tvreplace_mode = State;\t// So we know to put things right later\n\tState = MODE_INSERT;\n    }\n    else\n\tvreplace_mode = 0;\n#endif\n#ifdef FEAT_LISP\n    // May do lisp indenting.\n    if (!p_paste\n\t    && leader == NULL\n\t    && curbuf->b_p_lisp\n\t    && curbuf->b_p_ai)\n    {\n\tfixthisline(get_lisp_indent);\n\tai_col = (colnr_T)getwhitecols_curline();\n    }\n#endif\n#ifdef FEAT_CINDENT\n    // May do indenting after opening a new line.\n    if (do_cindent)\n    {\n\tdo_c_expr_indent();\n\tai_col = (colnr_T)getwhitecols_curline();\n    }\n#endif\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (vreplace_mode != 0)\n\tState = vreplace_mode;\n#endif\n\n    // Finally, MODE_VREPLACE gets the stuff on the new line, then puts back\n    // the original line, and inserts the new stuff char by char, pushing old\n    // stuff onto the replace stack (via ins_char()).\n    if (State & VREPLACE_FLAG)\n    {\n\t// Put new line in p_extra\n\tp_extra = vim_strsave(ml_get_curline());\n\tif (p_extra == NULL)\n\t    goto theend;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, next_line, FALSE);\n\n\t// Insert new stuff into line again\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\tins_bytes(p_extra);\t// will call changed_bytes()\n\tvim_free(p_extra);\n\tnext_line = NULL;\n    }\n\n    retval = OK;\t\t// success!\ntheend:\n    curbuf->b_p_pi = saved_pi;\n    vim_free(saved_line);\n    vim_free(next_line);\n    vim_free(allocated);\n    return retval;\n}\n\n/*\n * Delete from cursor to end of line.\n * Caller must have prepared for undo.\n * If \"fixpos\" is TRUE fix the cursor position when done.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ntruncate_line(int fixpos)\n{\n    char_u\t*newp;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    char_u\t*old_line;\n    int\t\tdeleted;\n\n    old_line = ml_get(lnum);\n    if (col == 0)\n\tnewp = vim_strsave((char_u *)\"\");\n    else\n\tnewp = vim_strnsave(old_line, col);\n    deleted = (int)STRLEN(old_line) - col;\n\n    if (newp == NULL)\n\treturn FAIL;\n\n    ml_replace(lnum, newp, FALSE);\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, curwin->w_cursor.col, -deleted);\n\n    // If \"fixpos\" is TRUE we don't want to end up positioned at the NUL.\n    if (fixpos && curwin->w_cursor.col > 0)\n\t--curwin->w_cursor.col;\n\n    return OK;\n}\n\n/*\n * Delete \"nlines\" lines at the cursor.\n * Saves the lines for undo first if \"undo\" is TRUE.\n */\n    void\ndel_lines(long nlines,\tint undo)\n{\n    long\tn;\n    linenr_T\tfirst = curwin->w_cursor.lnum;\n\n    if (nlines <= 0)\n\treturn;\n\n    // save the deleted lines for undo\n    if (undo && u_savedel(first, nlines) == FAIL)\n\treturn;\n\n    for (n = 0; n < nlines; )\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\n\tml_delete_flags(first, ML_DEL_MESSAGE);\n\t++n;\n\n\t// If we delete the last line in the file, stop\n\tif (first > curbuf->b_ml.ml_line_count)\n\t    break;\n    }\n\n    // Correct the cursor position before calling deleted_lines_mark(), it may\n    // trigger a callback to display the cursor.\n    curwin->w_cursor.col = 0;\n    check_cursor_lnum();\n\n    // adjust marks, mark the buffer as changed and prepare for displaying\n    deleted_lines_mark(first, n);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * edit.c: functions for Insert mode\n */\n\n#include \"vim.h\"\n\n#define BACKSPACE_CHAR\t\t    1\n#define BACKSPACE_WORD\t\t    2\n#define BACKSPACE_WORD_NOT_SPACE    3\n#define BACKSPACE_LINE\t\t    4\n\n// Set when doing something for completion that may call edit() recursively,\n// which is not allowed.\nstatic int\tcompl_busy = FALSE;\n\n\nstatic void ins_ctrl_v(void);\nstatic void insert_special(int, int, int);\nstatic void redo_literal(int c);\nstatic void start_arrow_common(pos_T *end_insert_pos, int change);\n#ifdef FEAT_SPELL\nstatic void check_spell_redraw(void);\n#endif\nstatic void stop_insert(pos_T *end_insert_pos, int esc, int nomove);\nstatic int  echeck_abbr(int);\nstatic void mb_replace_pop_ins(int cc);\nstatic void replace_flush(void);\nstatic void replace_do_bs(int limit_col);\nstatic int del_char_after_col(int limit_col);\nstatic void ins_reg(void);\nstatic void ins_ctrl_g(void);\nstatic void ins_ctrl_hat(void);\nstatic int  ins_esc(long *count, int cmdchar, int nomove);\n#ifdef FEAT_RIGHTLEFT\nstatic void ins_ctrl_(void);\n#endif\nstatic int ins_start_select(int c);\nstatic void ins_insert(int replaceState);\nstatic void ins_ctrl_o(void);\nstatic void ins_shift(int c, int lastc);\nstatic void ins_del(void);\nstatic int  ins_bs(int c, int mode, int *inserted_space_p);\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\nstatic void ins_tabline(int c);\n#endif\nstatic void ins_left(void);\nstatic void ins_home(int c);\nstatic void ins_end(int c);\nstatic void ins_s_left(void);\nstatic void ins_right(void);\nstatic void ins_s_right(void);\nstatic void ins_up(int startcol);\nstatic void ins_pageup(void);\nstatic void ins_down(int startcol);\nstatic void ins_pagedown(void);\n#ifdef FEAT_DND\nstatic void ins_drop(void);\n#endif\nstatic int  ins_tab(void);\n#ifdef FEAT_DIGRAPHS\nstatic int  ins_digraph(void);\n#endif\nstatic int  ins_ctrl_ey(int tc);\n#if defined(FEAT_EVAL)\nstatic char_u *do_insert_char_pre(int c);\n#endif\n\nstatic colnr_T\tInsstart_textlen;\t// length of line when insert started\nstatic colnr_T\tInsstart_blank_vcol;\t// vcol for first inserted blank\nstatic int\tupdate_Insstart_orig = TRUE; // set Insstart_orig to Insstart\n\nstatic char_u\t*last_insert = NULL;\t// the text of the previous insert,\n\t\t\t\t\t// K_SPECIAL and CSI are escaped\nstatic int\tlast_insert_skip; // nr of chars in front of previous insert\nstatic int\tnew_insert_skip;  // nr of chars in front of current insert\nstatic int\tdid_restart_edit;\t// \"restart_edit\" when calling edit()\n\n#ifdef FEAT_CINDENT\nstatic int\tcan_cindent;\t\t// may do cindenting on this line\n#endif\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\trevins_on;\t\t// reverse insert mode on\nstatic int\trevins_chars;\t\t// how much to skip after edit\nstatic int\trevins_legal;\t\t// was the last char 'legal'?\nstatic int\trevins_scol;\t\t// start column of revins session\n#endif\n\nstatic int\tins_need_undo;\t\t// call u_save() before inserting a\n\t\t\t\t\t// char.  Set when edit() is called.\n\t\t\t\t\t// after that arrow_used is used.\n\nstatic int\tdont_sync_undo = FALSE;\t// CTRL-G U prevents syncing undo for\n\t\t\t\t\t// the next left/right cursor key\n\n/*\n * edit(): Start inserting text.\n *\n * \"cmdchar\" can be:\n * 'i'\tnormal insert command\n * 'a'\tnormal append command\n * K_PS bracketed paste\n * 'R'\treplace command\n * 'r'\t\"r<CR>\" command: insert one <CR>.  Note: count can be > 1, for redo,\n *\tbut still only one <CR> is inserted.  The <Esc> is not used for redo.\n * 'g'\t\"gI\" command.\n * 'V'\t\"gR\" command for Virtual Replace mode.\n * 'v'\t\"gr\" command for single character Virtual Replace mode.\n *\n * This function is not called recursively.  For CTRL-O commands, it returns\n * and lets the caller handle the Normal-mode command.\n *\n * Return TRUE if a CTRL-O command caused the return (insert mode pending).\n */\n    int\nedit(\n    int\t\tcmdchar,\n    int\t\tstartln,\t// if set, insert at start of line\n    long\tcount)\n{\n    int\t\tc = 0;\n    char_u\t*ptr;\n    int\t\tlastc = 0;\n    int\t\tmincol;\n    static linenr_T o_lnum = 0;\n    int\t\ti;\n    int\t\tdid_backspace = TRUE;\t    // previous char was backspace\n#ifdef FEAT_CINDENT\n    int\t\tline_is_white = FALSE;\t    // line is empty before insert\n#endif\n    linenr_T\told_topline = 0;\t    // topline before insertion\n#ifdef FEAT_DIFF\n    int\t\told_topfill = -1;\n#endif\n    int\t\tinserted_space = FALSE;     // just inserted a space\n    int\t\treplaceState = MODE_REPLACE;\n    int\t\tnomove = FALSE;\t\t    // don't move cursor on return\n#ifdef FEAT_JOB_CHANNEL\n    int\t\tcmdchar_todo = cmdchar;\n#endif\n#ifdef FEAT_CONCEAL\n    int\t\tcursor_line_was_concealed;\n#endif\n\n    // Remember whether editing was restarted after CTRL-O.\n    did_restart_edit = restart_edit;\n\n    // sleep before redrawing, needed for \"CTRL-O :\" that results in an\n    // error message\n    check_for_delay(TRUE);\n\n    // set Insstart_orig to Insstart\n    update_Insstart_orig = TRUE;\n\n#ifdef HAVE_SANDBOX\n    // Don't allow inserting in the sandbox.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    // Don't allow recursive insert mode when busy with completion.\n    if (textwinlock != 0 || textlock != 0\n\t\t\t  || ins_compl_active() || compl_busy || pum_visible())\n    {\n\temsg(_(e_not_allowed_to_change_text_or_change_window));\n\treturn FALSE;\n    }\n    ins_compl_clear();\t    // clear stuff for CTRL-X mode\n\n    /*\n     * Trigger InsertEnter autocommands.  Do not do this for \"r<CR>\" or \"grx\".\n     */\n    if (cmdchar != 'r' && cmdchar != 'v')\n    {\n\tpos_T   save_cursor = curwin->w_cursor;\n\n#ifdef FEAT_EVAL\n\tif (cmdchar == 'R')\n\t    ptr = (char_u *)\"r\";\n\telse if (cmdchar == 'V')\n\t    ptr = (char_u *)\"v\";\n\telse\n\t    ptr = (char_u *)\"i\";\n\tset_vim_var_string(VV_INSERTMODE, ptr, 1);\n\tset_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n#endif\n\tins_apply_autocmds(EVENT_INSERTENTER);\n\n\t// Check for changed highlighting, e.g. for ModeMsg.\n\tif (need_highlight_changed)\n\t    highlight_changed();\n\n\t// Make sure the cursor didn't move.  Do call check_cursor_col() in\n\t// case the text was modified.  Since Insert mode was not started yet\n\t// a call to check_cursor_col() may move the cursor, especially with\n\t// the \"A\" command, thus set State to avoid that. Also check that the\n\t// line number is still valid (lines may have been deleted).\n\t// Do not restore if v:char was set to a non-empty string.\n\tif (!EQUAL_POS(curwin->w_cursor, save_cursor)\n#ifdef FEAT_EVAL\n\t\t&& *get_vim_var_str(VV_CHAR) == NUL\n#endif\n\t\t&& save_cursor.lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    int save_state = State;\n\n\t    curwin->w_cursor = save_cursor;\n\t    State = MODE_INSERT;\n\t    check_cursor_col();\n\t    State = save_state;\n\t}\n    }\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line was concealed before changing State.\n    cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    /*\n     * When doing a paste with the middle mouse button, Insstart is set to\n     * where the paste started.\n     */\n    if (where_paste_started.lnum != 0)\n\tInsstart = where_paste_started;\n    else\n    {\n\tInsstart = curwin->w_cursor;\n\tif (startln)\n\t    Insstart.col = 0;\n    }\n    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n    Insstart_blank_vcol = MAXCOL;\n    if (!did_ai)\n\tai_col = 0;\n\n    if (cmdchar != NUL && restart_edit == 0)\n    {\n\tResetRedobuff();\n\tAppendNumberToRedobuff(count);\n\tif (cmdchar == 'V' || cmdchar == 'v')\n\t{\n\t    // \"gR\" or \"gr\" command\n\t    AppendCharToRedobuff('g');\n\t    AppendCharToRedobuff((cmdchar == 'v') ? 'r' : 'R');\n\t}\n\telse\n\t{\n\t    if (cmdchar == K_PS)\n\t\tAppendCharToRedobuff('a');\n\t    else\n\t\tAppendCharToRedobuff(cmdchar);\n\t    if (cmdchar == 'g')\t\t    // \"gI\" command\n\t\tAppendCharToRedobuff('I');\n\t    else if (cmdchar == 'r')\t    // \"r<CR>\" command\n\t\tcount = 1;\t\t    // insert only one <CR>\n\t}\n    }\n\n    if (cmdchar == 'R')\n    {\n\tState = MODE_REPLACE;\n    }\n    else if (cmdchar == 'V' || cmdchar == 'v')\n    {\n\tState = MODE_VREPLACE;\n\treplaceState = MODE_VREPLACE;\n\torig_line_count = curbuf->b_ml.ml_line_count;\n\tvr_lines_changed = 1;\n    }\n    else\n\tState = MODE_INSERT;\n\n    may_trigger_modechanged();\n    stop_insert_mode = FALSE;\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"n\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    /*\n     * Enable langmap or IME, indicated by 'iminsert'.\n     * Note that IME may enabled/disabled without us noticing here, thus the\n     * 'iminsert' value may not reflect what is actually used.  It is updated\n     * when hitting <Esc>.\n     */\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n#endif\n\n    setmouse();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // there is no reverse replace mode\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n\tundisplay_dollar();\n    revins_chars = 0;\n    revins_legal = 0;\n    revins_scol = -1;\n#endif\n    if (!p_ek)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tch_log_output = TRUE;\n#endif\n\t// Disable bracketed paste mode, we won't recognize the escape\n\t// sequences.\n\tout_str(T_BD);\n\n\t// Disable modifyOtherKeys, keys with modifiers would cause exiting\n\t// Insert mode.\n\tout_str(T_CTE);\n    }\n\n    /*\n     * Handle restarting Insert mode.\n     * Don't do this for \"CTRL-O .\" (repeat an insert): In that case we get\n     * here with something in the stuff buffer.\n     */\n    if (restart_edit != 0 && stuff_empty())\n    {\n\t/*\n\t * After a paste we consider text typed to be part of the insert for\n\t * the pasted text. You can backspace over the pasted text too.\n\t */\n\tif (where_paste_started.lnum)\n\t    arrow_used = FALSE;\n\telse\n\t    arrow_used = TRUE;\n\trestart_edit = 0;\n\n\t/*\n\t * If the cursor was after the end-of-line before the CTRL-O and it is\n\t * now at the end-of-line, put it after the end-of-line (this is not\n\t * correct in very rare cases).\n\t * Also do this if curswant is greater than the current virtual\n\t * column.  Eg after \"^O$\" or \"^O80|\".\n\t */\n\tvalidate_virtcol();\n\tupdate_curswant();\n\tif (((ins_at_eol && curwin->w_cursor.lnum == o_lnum)\n\t\t    || curwin->w_curswant > curwin->w_virtcol)\n\t\t&& *(ptr = ml_get_curline() + curwin->w_cursor.col) != NUL)\n\t{\n\t    if (ptr[1] == NUL)\n\t\t++curwin->w_cursor.col;\n\t    else if (has_mbyte)\n\t    {\n\t\ti = (*mb_ptr2len)(ptr);\n\t\tif (ptr[i] == NUL)\n\t\t    curwin->w_cursor.col += i;\n\t    }\n\t}\n\tins_at_eol = FALSE;\n    }\n    else\n\tarrow_used = FALSE;\n\n    // we are in insert mode now, don't need to start it anymore\n    need_start_insertmode = FALSE;\n\n    // Need to save the line for undo before inserting the first char.\n    ins_need_undo = TRUE;\n\n    where_paste_started.lnum = 0;\n#ifdef FEAT_CINDENT\n    can_cindent = TRUE;\n#endif\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold, unless 'insertmode' is set or\n    // restarting.\n    if (!p_im && did_restart_edit == 0)\n\tfoldOpenCursor();\n#endif\n\n    /*\n     * If 'showmode' is set, show the current (insert/replace/..) mode.\n     * A warning message for changing a readonly file is given here, before\n     * actually changing anything.  It's put after the mode, if any.\n     */\n    i = 0;\n    if (p_smd && msg_silent == 0)\n\ti = showmode();\n\n    if (!p_im && did_restart_edit == 0)\n\tchange_warning(i == 0 ? 0 : i + 1);\n\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// clear digraphs\n#endif\n\n    /*\n     * Get the current length of the redo buffer, those characters have to be\n     * skipped if we want to get to the inserted characters.\n     */\n    ptr = get_inserted();\n    if (ptr == NULL)\n\tnew_insert_skip = 0;\n    else\n    {\n\tnew_insert_skip = (int)STRLEN(ptr);\n\tvim_free(ptr);\n    }\n\n    old_indent = 0;\n\n    /*\n     * Main loop in Insert mode: repeat until Insert mode is left.\n     */\n    for (;;)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (!revins_legal)\n\t    revins_scol = -1;\t    // reset on illegal motions\n\telse\n\t    revins_legal = 0;\n#endif\n\tif (arrow_used)\t    // don't repeat insert when arrow key used\n\t    count = 0;\n\n\tif (update_Insstart_orig)\n\t    Insstart_orig = Insstart;\n\n\tif (stop_insert_mode && !ins_compl_active())\n\t{\n\t    // \":stopinsert\" used or 'insertmode' reset\n\t    count = 0;\n\t    goto doESCkey;\n\t}\n\n\t// set curwin->w_curswant for next K_DOWN or K_UP\n\tif (!arrow_used)\n\t    curwin->w_set_curswant = TRUE;\n\n\t// If there is no typeahead may check for timestamps (e.g., for when a\n\t// menu invoked a shell command).\n\tif (stuff_empty())\n\t{\n\t    did_check_timestamps = FALSE;\n\t    if (need_check_timestamps)\n\t\tcheck_timestamps(FALSE);\n\t}\n\n\t/*\n\t * When emsg() was called msg_scroll will have been set.\n\t */\n\tmsg_scroll = FALSE;\n\n#ifdef FEAT_GUI\n\t// When 'mousefocus' is set a mouse movement may have taken us to\n\t// another window.  \"need_mouse_correct\" may then be set because of an\n\t// autocommand.\n\tif (need_mouse_correct)\n\t    gui_mouse_correct();\n#endif\n\n#ifdef FEAT_FOLDING\n\t// Open fold at the cursor line, according to 'foldopen'.\n\tif (fdo_flags & FDO_INSERT)\n\t    foldOpenCursor();\n\t// Close folds where the cursor isn't, according to 'foldclose'\n\tif (!char_avail())\n\t    foldCheckClose();\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    init_prompt(cmdchar_todo);\n\t    cmdchar_todo = NUL;\n\t}\n#endif\n\n\t/*\n\t * If we inserted a character at the last position of the last line in\n\t * the window, scroll the window one line up. This avoids an extra\n\t * redraw.\n\t * This is detected when the cursor column is smaller after inserting\n\t * something.\n\t * Don't do this when the topline changed already, it has\n\t * already been adjusted (by insertchar() calling open_line())).\n\t */\n\tif (curbuf->b_mod_set\n\t\t&& curwin->w_p_wrap\n\t\t&& !did_backspace\n\t\t&& curwin->w_topline == old_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == old_topfill\n#endif\n\t\t)\n\t{\n\t    mincol = curwin->w_wcol;\n\t    validate_cursor_col();\n\n\t    if (\n#ifdef FEAT_VARTABS\n\t\tcurwin->w_wcol < mincol - tabstop_at(\n\t\t\t\t\t  get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t\t curbuf->b_p_vts_array)\n#else\n\t\t(int)curwin->w_wcol < mincol - curbuf->b_p_ts\n#endif\n\t\t    && curwin->w_wrow == W_WINROW(curwin)\n\t\t\t\t + curwin->w_height - 1 - get_scrolloff_value()\n\t\t    && (curwin->w_cursor.lnum != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill > 0\n#endif\n\t\t    ))\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &old_topline))\n\t\t    set_topline(curwin, old_topline + 1);\n\t\telse\n#endif\n\t\t    set_topline(curwin, curwin->w_topline + 1);\n\t    }\n\t}\n\n\t// May need to adjust w_topline to show the cursor.\n\tupdate_topline();\n\n\tdid_backspace = FALSE;\n\n\tvalidate_cursor();\t\t// may set must_redraw\n\n\t/*\n\t * Redraw the display when no characters are waiting.\n\t * Also shows mode, ruler and positions cursor.\n\t */\n\tins_redraw(TRUE);\n\n\tif (curwin->w_p_scb)\n\t    do_check_scrollbind(TRUE);\n\n\tif (curwin->w_p_crb)\n\t    do_check_cursorbind();\n\tupdate_curswant();\n\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n\told_topfill = curwin->w_topfill;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n\t/*\n\t * Get a character for Insert mode.  Ignore K_IGNORE and K_NOP.\n\t */\n\tif (c != K_CURSORHOLD)\n\t    lastc = c;\t\t// remember the previous char for CTRL-D\n\n\t// After using CTRL-G U the next cursor key will not break undo.\n\tif (dont_sync_undo == MAYBE)\n\t    dont_sync_undo = TRUE;\n\telse\n\t    dont_sync_undo = FALSE;\n\tif (cmdchar == K_PS)\n\t    // Got here from normal mode when bracketed paste started.\n\t    c = K_PS;\n\telse\n\t    do\n\t    {\n\t\tc = safe_vgetc();\n\n\t\tif (stop_insert_mode\n#ifdef FEAT_TERMINAL\n\t\t\t|| (c == K_IGNORE && term_use_loop())\n#endif\n\t\t   )\n\t\t{\n\t\t    // Insert mode ended, possibly from a callback, or a timer\n\t\t    // must have opened a terminal window.\n\t\t    if (c != K_IGNORE && c != K_NOP)\n\t\t\tvungetc(c);\n\t\t    count = 0;\n\t\t    nomove = TRUE;\n\t\t    ins_compl_prep(ESC);\n\t\t    goto doESCkey;\n\t\t}\n\t    } while (c == K_IGNORE || c == K_NOP);\n\n\t// Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.\n\tdid_cursorhold = TRUE;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (p_hkmap && KeyTyped)\n\t    c = hkmap(c);\t\t// Hebrew mode mapping\n#endif\n\n\t// If the window was made so small that nothing shows, make it at least\n\t// one line and one column when typing.\n\tif (KeyTyped && !KeyStuffed)\n\t    win_ensure_size();\n\n\t/*\n\t * Special handling of keys while the popup menu is visible or wanted\n\t * and the cursor is still in the completed word.  Only when there is\n\t * a match, skip this when no matches were found.\n\t */\n\tif (ins_compl_active()\n\t\t&& pum_wanted()\n\t\t&& curwin->w_cursor.col >= ins_compl_col()\n\t\t&& ins_compl_has_shown_match())\n\t{\n\t    // BS: Delete one character from \"compl_leader\".\n\t    if ((c == K_BS || c == Ctrl_H)\n\t\t\t&& curwin->w_cursor.col > ins_compl_col()\n\t\t\t&& (c = ins_compl_bs()) == NUL)\n\t\tcontinue;\n\n\t    // When no match was selected or it was edited.\n\t    if (!ins_compl_used_match())\n\t    {\n\t\t// CTRL-L: Add one character from the current match to\n\t\t// \"compl_leader\".  Except when at the original match and\n\t\t// there is nothing to add, CTRL-L works like CTRL-P then.\n\t\tif (c == Ctrl_L\n\t\t\t&& (!ctrl_x_mode_line_or_eval()\n\t\t\t    || ins_compl_long_shown_match()))\n\t\t{\n\t\t    ins_compl_addfrommatch();\n\t\t    continue;\n\t\t}\n\n\t\t// A non-white character that fits in with the current\n\t\t// completion: Add to \"compl_leader\".\n\t\tif (ins_compl_accept_char(c))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    // Trigger InsertCharPre.\n\t\t    char_u *str = do_insert_char_pre(c);\n\t\t    char_u *p;\n\n\t\t    if (str != NULL)\n\t\t    {\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t    ins_compl_addleader(PTR2CHAR(p));\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    else\n#endif\n\t\t\tins_compl_addleader(c);\n\t\t    continue;\n\t\t}\n\n\t\t// Pressing CTRL-Y selects the current match.  When\n\t\t// ins_compl_enter_selects() is set the Enter key does the\n\t\t// same.\n\t\tif ((c == Ctrl_Y || (ins_compl_enter_selects()\n\t\t\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t\t\t&& stop_arrow() == OK)\n\t\t{\n\t\t    ins_compl_delete();\n\t\t    ins_compl_insert(FALSE);\n\t\t}\n\t    }\n\t}\n\n\t// Prepare for or stop CTRL-X mode.  This doesn't do completion, but\n\t// it does fix up the text when finishing completion.\n\tins_compl_init_get_longest();\n\tif (ins_compl_prep(c))\n\t    continue;\n\n\t// CTRL-\\ CTRL-N goes to Normal mode,\n\t// CTRL-\\ CTRL-G goes to mode selected with 'insertmode',\n\t// CTRL-\\ CTRL-O is like CTRL-O but without moving the cursor.\n\tif (c == Ctrl_BSL)\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    c = plain_vgetc();\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)\n\t    {\n\t\t// it's something else\n\t\tvungetc(c);\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == Ctrl_G && p_im)\n\t\tcontinue;\n\t    else\n\t    {\n\t\tif (c == Ctrl_O)\n\t\t{\n\t\t    ins_ctrl_o();\n\t\t    ins_at_eol = FALSE;\t// cursor keeps its column\n\t\t    nomove = TRUE;\n\t\t}\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tc = do_digraph(c);\n#endif\n\n\tif ((c == Ctrl_V || c == Ctrl_Q) && ctrl_x_mode_cmdline())\n\t    goto docomplete;\n\tif (c == Ctrl_V || c == Ctrl_Q)\n\t{\n\t    ins_ctrl_v();\n\t    c = Ctrl_V;\t// pretend CTRL-V is last typed character\n\t    continue;\n\t}\n\n#ifdef FEAT_CINDENT\n\tif (cindent_on() && ctrl_x_mode_none())\n\t{\n\t    // A key name preceded by a bang means this key is not to be\n\t    // inserted.  Skip ahead to the re-indenting below.\n\t    // A key name preceded by a star means that indenting has to be\n\t    // done before inserting the key.\n\t    line_is_white = inindent(0);\n\t    if (in_cinkeys(c, '!', line_is_white))\n\t\tgoto force_cindent;\n\t    if (can_cindent && in_cinkeys(c, '*', line_is_white)\n\t\t\t\t\t\t\t&& stop_arrow() == OK)\n\t\tdo_c_expr_indent();\n\t}\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t    switch (c)\n\t    {\n\t\tcase K_LEFT:\tc = K_RIGHT; break;\n\t\tcase K_S_LEFT:\tc = K_S_RIGHT; break;\n\t\tcase K_C_LEFT:\tc = K_C_RIGHT; break;\n\t\tcase K_RIGHT:\tc = K_LEFT; break;\n\t\tcase K_S_RIGHT: c = K_S_LEFT; break;\n\t\tcase K_C_RIGHT: c = K_C_LEFT; break;\n\t    }\n#endif\n\n\t/*\n\t * If 'keymodel' contains \"startsel\", may start selection.  If it\n\t * does, a CTRL-O and c will be stuffed, we need to get these\n\t * characters.\n\t */\n\tif (ins_start_select(c))\n\t    continue;\n\n\t/*\n\t * The big switch to handle a character in insert mode.\n\t */\n\tswitch (c)\n\t{\n\tcase ESC:\t// End input mode\n\t    if (echeck_abbr(ESC + ABBR_OFF))\n\t\tbreak;\n\t    // FALLTHROUGH\n\n\tcase Ctrl_C:\t// End input mode\n#ifdef FEAT_CMDWIN\n\t    if (c == Ctrl_C && cmdwin_type != 0)\n\t    {\n\t\t// Close the cmdline window.\n\t\tcmdwin_result = K_IGNORE;\n\t\tgot_int = FALSE; // don't stop executing autocommands et al.\n\t\tnomove = TRUE;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (c == Ctrl_C && bt_prompt(curbuf))\n\t    {\n\t\tif (invoke_prompt_interrupt())\n\t\t{\n\t\t    if (!bt_prompt(curbuf))\n\t\t\t// buffer changed to a non-prompt buffer, get out of\n\t\t\t// Insert mode\n\t\t\tgoto doESCkey;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\n#ifdef UNIX\ndo_intr:\n#endif\n\t    // when 'insertmode' set, and not halfway a mapping, don't leave\n\t    // Insert mode\n\t    if (goto_im())\n\t    {\n\t\tif (got_int)\n\t\t{\n\t\t    (void)vgetc();\t\t// flush all buffers\n\t\t    got_int = FALSE;\n\t\t}\n\t\telse\n\t\t    vim_beep(BO_IM);\n\t\tbreak;\n\t    }\ndoESCkey:\n\t    /*\n\t     * This is the ONLY return from edit()!\n\t     */\n\t    // Always update o_lnum, so that a \"CTRL-O .\" that adds a line\n\t    // still puts the cursor back after the inserted text.\n\t    if (ins_at_eol && gchar_cursor() == NUL)\n\t\to_lnum = curwin->w_cursor.lnum;\n\n\t    if (ins_esc(&count, cmdchar, nomove))\n\t    {\n\t\t// When CTRL-C was typed got_int will be set, with the result\n\t\t// that the autocommands won't be executed. When mapped got_int\n\t\t// is not set, but let's keep the behavior the same.\n\t\tif (cmdchar != 'r' && cmdchar != 'v' && c != Ctrl_C)\n\t\t    ins_apply_autocmds(EVENT_INSERTLEAVE);\n\t\tdid_cursorhold = FALSE;\n\t\treturn (c == Ctrl_O);\n\t    }\n\t    continue;\n\n\tcase Ctrl_Z:\t// suspend when 'insertmode' set\n\t    if (!p_im)\n\t\tgoto normalchar;\t// insert CTRL-Z as normal char\n\t    do_cmdline_cmd((char_u *)\"stop\");\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t\t// may need to update cursor shape\n#endif\n\t    continue;\n\n\tcase Ctrl_O:\t// execute one command\n#ifdef FEAT_COMPL_FUNC\n\t    if (ctrl_x_mode_omni())\n\t\tgoto docomplete;\n#endif\n\t    if (echeck_abbr(Ctrl_O + ABBR_OFF))\n\t\tbreak;\n\t    ins_ctrl_o();\n\n\t    // don't move the cursor left when 'virtualedit' has \"onemore\".\n\t    if (get_ve_flags() & VE_ONEMORE)\n\t    {\n\t\tins_at_eol = FALSE;\n\t\tnomove = TRUE;\n\t    }\n\t    count = 0;\n\t    goto doESCkey;\n\n\tcase K_INS:\t// toggle insert/replace mode\n\tcase K_KINS:\n\t    ins_insert(replaceState);\n\t    break;\n\n\tcase K_SELECT:\t// end of Select mode mapping - ignore\n\t    break;\n\n\tcase K_HELP:\t// Help key works like <ESC> <Help>\n\tcase K_F1:\n\tcase K_XF1:\n\t    stuffcharReadbuff(K_HELP);\n\t    if (p_im)\n\t\tneed_start_insertmode = TRUE;\n\t    goto doESCkey;\n\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t// NetBeans command\n\t    ++no_mapping;\t\t// don't map the next key hits\n\t    i = plain_vgetc();\n\t    --no_mapping;\n\t    netbeans_keycommand(i);\n\t    break;\n#endif\n\n\tcase K_ZERO:\t// Insert the previously inserted text.\n\tcase NUL:\n\tcase Ctrl_A:\n\t    // For ^@ the trailing ESC will end the insert, unless there is an\n\t    // error.\n\t    if (stuff_inserted(NUL, 1L, (c == Ctrl_A)) == FAIL\n\t\t\t\t\t\t   && c != Ctrl_A && !p_im)\n\t\tgoto doESCkey;\t\t// quit insert mode\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_R:\t// insert the contents of a register\n\t    ins_reg();\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_G:\t// commands starting with CTRL-G\n\t    ins_ctrl_g();\n\t    break;\n\n\tcase Ctrl_HAT:\t// switch input mode and/or langmap\n\t    ins_ctrl_hat();\n\t    break;\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t// switch between languages\n\t    if (!p_ari)\n\t\tgoto normalchar;\n\t    ins_ctrl_();\n\t    break;\n#endif\n\n\tcase Ctrl_D:\t// Make indent one shiftwidth smaller.\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_defines())\n\t\tgoto docomplete;\n#endif\n\t    // FALLTHROUGH\n\n\tcase Ctrl_T:\t// Make indent one shiftwidth greater.\n\t    if (c == Ctrl_T && ctrl_x_mode_thesaurus())\n\t    {\n\t\tif (has_compl_option(FALSE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n\n\t    ins_shift(c, lastc);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_DEL:\t// delete character under the cursor\n\tcase K_KDEL:\n\t    ins_del();\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_BS:\t// delete character before the cursor\n\tcase K_S_BS:\n\tcase Ctrl_H:\n\t    did_backspace = ins_bs(c, BACKSPACE_CHAR, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_W:\t// delete word before the cursor\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf) && (mod_mask & MOD_MASK_SHIFT) == 0)\n\t    {\n\t\t// In a prompt window CTRL-W is used for window commands.\n\t\t// Use Shift-CTRL-W to delete a word.\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\trestart_edit = 'A';\n\t\tnomove = TRUE;\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n#endif\n\t    did_backspace = ins_bs(c, BACKSPACE_WORD, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_U:\t// delete all inserted text in current line\n# ifdef FEAT_COMPL_FUNC\n\t    // CTRL-X CTRL-U completes with 'completefunc'.\n\t    if (ctrl_x_mode_function())\n\t\tgoto docomplete;\n# endif\n\t    did_backspace = ins_bs(c, BACKSPACE_LINE, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_LEFTMOUSE:   // mouse keys\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\t    ins_mouse(c);\n\t    break;\n\n\tcase K_MOUSEDOWN: // Default action for scroll wheel up: scroll up\n\t    ins_mousescroll(MSCR_DOWN);\n\t    break;\n\n\tcase K_MOUSEUP:\t// Default action for scroll wheel down: scroll down\n\t    ins_mousescroll(MSCR_UP);\n\t    break;\n\n\tcase K_MOUSELEFT: // Scroll wheel left\n\t    ins_mousescroll(MSCR_LEFT);\n\t    break;\n\n\tcase K_MOUSERIGHT: // Scroll wheel right\n\t    ins_mousescroll(MSCR_RIGHT);\n\t    break;\n\n\tcase K_PS:\n\t    bracketed_paste(PASTE_INSERT, FALSE, NULL);\n\t    if (cmdchar == K_PS)\n\t\t// invoked from normal mode, bail out\n\t\tgoto doESCkey;\n\t    break;\n\tcase K_PE:\n\t    // Got K_PE without K_PS, ignore.\n\t    break;\n\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t    ins_tabline(c);\n\t    break;\n#endif\n\n\tcase K_IGNORE:\t// Something mapped to nothing\n\t    break;\n\n\tcase K_COMMAND:\t\t    // <Cmd>command<CR>\n\tcase K_SCRIPT_COMMAND:\t    // <ScriptCmd>command<CR>\n\t    do_cmdkey_command(c, 0);\n#ifdef FEAT_TERMINAL\n\t    if (term_use_loop())\n\t\t// Started a terminal that gets the input, exit Insert mode.\n\t\tgoto doESCkey;\n#endif\n\t    break;\n\n\tcase K_CURSORHOLD:\t// Didn't type something for a while.\n\t    ins_apply_autocmds(EVENT_CURSORHOLDI);\n\t    did_cursorhold = TRUE;\n\t    // If CTRL-G U was used apply it to the next typed key.\n\t    if (dont_sync_undo == TRUE)\n\t\tdont_sync_undo = MAYBE;\n\t    break;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask != MOD_MASK_ALT)\n\t\tgoto normalchar;\n\t    break;\n#endif\n\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\n\t    ins_scroll();\n\t    break;\n\n\tcase K_HOR_SCROLLBAR:\n\t    ins_horscroll();\n\t    break;\n#endif\n\n\tcase K_HOME:\t// <Home>\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t    ins_home(c);\n\t    break;\n\n\tcase K_END:\t// <End>\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t    ins_end(c);\n\t    break;\n\n\tcase K_LEFT:\t// <Left>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_left();\n\t    else\n\t\tins_left();\n\t    break;\n\n\tcase K_S_LEFT:\t// <S-Left>\n\tcase K_C_LEFT:\n\t    ins_s_left();\n\t    break;\n\n\tcase K_RIGHT:\t// <Right>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_right();\n\t    else\n\t\tins_right();\n\t    break;\n\n\tcase K_S_RIGHT:\t// <S-Right>\n\tcase K_C_RIGHT:\n\t    ins_s_right();\n\t    break;\n\n\tcase K_UP:\t// <Up>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pageup();\n\t    else\n\t\tins_up(FALSE);\n\t    break;\n\n\tcase K_S_UP:\t// <S-Up>\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pageup();\n\t    break;\n\n\tcase K_DOWN:\t// <Down>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pagedown();\n\t    else\n\t\tins_down(FALSE);\n\t    break;\n\n\tcase K_S_DOWN:\t// <S-Down>\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pagedown();\n\t    break;\n\n#ifdef FEAT_DND\n\tcase K_DROP:\t// drag-n-drop event\n\t    ins_drop();\n\t    break;\n#endif\n\n\tcase K_S_TAB:\t// When not mapped, use like a normal TAB\n\t    c = TAB;\n\t    // FALLTHROUGH\n\n\tcase TAB:\t// TAB or Complete patterns along path\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_patterns())\n\t\tgoto docomplete;\n#endif\n\t    inserted_space = FALSE;\n\t    if (ins_tab())\n\t\tgoto normalchar;\t// insert TAB as a normal char\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_KENTER:\t// <Enter>\n\t    c = CAR;\n\t    // FALLTHROUGH\n\tcase CAR:\n\tcase NL:\n#if defined(FEAT_QUICKFIX)\n\t    // In a quickfix window a <CR> jumps to the error under the\n\t    // cursor.\n\t    if (bt_quickfix(curbuf) && c == CAR)\n\t    {\n\t\tif (curwin->w_llist_ref == NULL)    // quickfix window\n\t\t    do_cmdline_cmd((char_u *)\".cc\");\n\t\telse\t\t\t\t    // location list window\n\t\t    do_cmdline_cmd((char_u *)\".ll\");\n\t\tbreak;\n\t    }\n#endif\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0)\n\t    {\n\t\t// Execute the command in the cmdline window.\n\t\tcmdwin_result = CAR;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t    {\n\t\tinvoke_prompt_callback();\n\t\tif (!bt_prompt(curbuf))\n\t\t    // buffer changed to a non-prompt buffer, get out of\n\t\t    // Insert mode\n\t\t    goto doESCkey;\n\t\tbreak;\n\t    }\n#endif\n\t    if (ins_eol(c) == FAIL && !p_im)\n\t\tgoto doESCkey;\t    // out of memory\n\t    auto_format(FALSE, FALSE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_K:\t    // digraph or keyword completion\n\t    if (ctrl_x_mode_dictionary())\n\t    {\n\t\tif (has_compl_option(TRUE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n#ifdef FEAT_DIGRAPHS\n\t    c = ins_digraph();\n\t    if (c == NUL)\n\t\tbreak;\n#endif\n\t    goto normalchar;\n\n\tcase Ctrl_X:\t// Enter CTRL-X mode\n\t    ins_ctrl_x();\n\t    break;\n\n\tcase Ctrl_RSB:\t// Tag name completion after ^X\n\t    if (!ctrl_x_mode_tags())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_F:\t// File name completion after ^X\n\t    if (!ctrl_x_mode_files())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase 's':\t// Spelling completion after ^X\n\tcase Ctrl_S:\n\t    if (!ctrl_x_mode_spell())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_L:\t// Whole line completion after ^X\n\t    if (!ctrl_x_mode_whole_line())\n\t    {\n\t\t// CTRL-L with 'insertmode' set: Leave Insert mode\n\t\tif (p_im)\n\t\t{\n\t\t    if (echeck_abbr(Ctrl_L + ABBR_OFF))\n\t\t\tbreak;\n\t\t    goto doESCkey;\n\t\t}\n\t\tgoto normalchar;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase Ctrl_P:\t// Do previous/next pattern completion\n\tcase Ctrl_N:\n\t    // if 'complete' is empty then plain ^P is no longer special,\n\t    // but it is under other ^X modes\n\t    if (*curbuf->b_p_cpt == NUL\n\t\t    && (ctrl_x_mode_normal() || ctrl_x_mode_whole_line())\n\t\t    && !compl_status_local())\n\t\tgoto normalchar;\n\ndocomplete:\n\t    compl_busy = TRUE;\n#ifdef FEAT_FOLDING\n\t    disable_fold_update++;  // don't redraw folds here\n#endif\n\t    if (ins_complete(c, TRUE) == FAIL)\n\t\tcompl_status_clear();\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    compl_busy = FALSE;\n#ifdef FEAT_SMARTINDENT\n\t    can_si = may_do_si(); // allow smartindenting\n#endif\n\t    break;\n\n\tcase Ctrl_Y:\t// copy from previous line or scroll down\n\tcase Ctrl_E:\t// copy from next line\t   or scroll up\n\t    c = ins_ctrl_ey(c);\n\t    break;\n\n\t  default:\n#ifdef UNIX\n\t    if (c == intr_char)\t\t// special interrupt char\n\t\tgoto do_intr;\n#endif\n\nnormalchar:\n\t    /*\n\t     * Insert a normal character.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (!p_paste)\n\t    {\n\t\t// Trigger InsertCharPre.\n\t\tchar_u *str = do_insert_char_pre(c);\n\t\tchar_u *p;\n\n\t\tif (str != NULL)\n\t\t{\n\t\t    if (*str != NUL && stop_arrow() != FAIL)\n\t\t    {\n\t\t\t// Insert the new value of v:char literally.\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t{\n\t\t\t    c = PTR2CHAR(p);\n\t\t\t    if (c == CAR || c == K_KENTER || c == NL)\n\t\t\t\tins_eol(c);\n\t\t\t    else\n\t\t\t\tins_char(c);\n\t\t\t}\n\t\t\tAppendToRedobuffLit(str, -1);\n\t\t    }\n\t\t    vim_free(str);\n\t\t    c = NUL;\n\t\t}\n\n\t\t// If the new value is already inserted or an empty string\n\t\t// then don't insert any character.\n\t\tif (c == NUL)\n\t\t    break;\n\t    }\n#endif\n#ifdef FEAT_SMARTINDENT\n\t    // Try to perform smart-indenting.\n\t    ins_try_si(c);\n#endif\n\n\t    if (c == ' ')\n\t    {\n\t\tinserted_space = TRUE;\n#ifdef FEAT_CINDENT\n\t\tif (inindent(0))\n\t\t    can_cindent = FALSE;\n#endif\n\t\tif (Insstart_blank_vcol == MAXCOL\n\t\t\t&& curwin->w_cursor.lnum == Insstart.lnum)\n\t\t    Insstart_blank_vcol = get_nolist_virtcol();\n\t    }\n\n\t    // Insert a normal character and check for abbreviations on a\n\t    // special character.  Let CTRL-] expand abbreviations without\n\t    // inserting it.\n\t    if (vim_iswordc(c) || (!echeck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t\t&& c != Ctrl_RSB))\n\t    {\n\t\tinsert_special(c, FALSE, FALSE);\n#ifdef FEAT_RIGHTLEFT\n\t\trevins_legal++;\n\t\trevins_chars++;\n#endif\n\t    }\n\n\t    auto_format(FALSE, TRUE);\n\n#ifdef FEAT_FOLDING\n\t    // When inserting a character the cursor line must never be in a\n\t    // closed fold.\n\t    foldOpenCursor();\n#endif\n\t    break;\n\t}   // end of switch (c)\n\n\t// If typed something may trigger CursorHoldI again.\n\tif (c != K_CURSORHOLD\n#ifdef FEAT_COMPL_FUNC\n\t\t// but not in CTRL-X mode, a script can't restore the state\n\t\t&& ctrl_x_mode_normal()\n#endif\n\t       )\n\t    did_cursorhold = FALSE;\n\n\t// If the cursor was moved we didn't just insert a space\n\tif (arrow_used)\n\t    inserted_space = FALSE;\n\n#ifdef FEAT_CINDENT\n\tif (can_cindent && cindent_on() && ctrl_x_mode_normal())\n\t{\nforce_cindent:\n\t    /*\n\t     * Indent now if a key was typed that is in 'cinkeys'.\n\t     */\n\t    if (in_cinkeys(c, ' ', line_is_white))\n\t    {\n\t\tif (stop_arrow() == OK)\n\t\t    // re-indent the current line\n\t\t    do_c_expr_indent();\n\t    }\n\t}\n#endif // FEAT_CINDENT\n\n    }\t// for (;;)\n    // NOTREACHED\n}\n\n    int\nins_need_undo_get(void)\n{\n    return ins_need_undo;\n}\n\n/*\n * Redraw for Insert mode.\n * This is postponed until getting the next character to make '$' in the 'cpo'\n * option work correctly.\n * Only redraw when there are no characters available.  This speeds up\n * inserting sequences of characters (e.g., for CTRL-R).\n */\n    void\nins_redraw(int ready)\t    // not busy with something\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\tconceal_old_cursor_line = 0;\n    linenr_T\tconceal_new_cursor_line = 0;\n    int\t\tconceal_update_lines = FALSE;\n#endif\n\n    if (char_avail())\n\treturn;\n\n    // Trigger CursorMoved if the cursor moved.  Not when the popup menu is\n    // visible, the command might delete it.\n    if (ready && (has_cursormovedI()\n# ifdef FEAT_PROP_POPUP\n\t\t|| popup_visible\n# endif\n# if defined(FEAT_CONCEAL)\n\t\t|| curwin->w_p_cole > 0\n# endif\n\t\t)\n\t    && !EQUAL_POS(last_cursormoved, curwin->w_cursor)\n\t    && !pum_visible())\n    {\n# ifdef FEAT_SYN_HL\n\t// Need to update the screen first, to make sure syntax\n\t// highlighting is correct after making a change (e.g., inserting\n\t// a \"(\".  The autocommand may also require a redraw, so it's done\n\t// again below, unfortunately.\n\tif (syntax_present(curwin) && must_redraw)\n\t    update_screen(0);\n# endif\n\tif (has_cursormovedI())\n\t{\n\t    // Make sure curswant is correct, an autocommand may call\n\t    // getcurpos().\n\t    update_curswant();\n\t    ins_apply_autocmds(EVENT_CURSORMOVEDI);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (popup_visible)\n\t    popup_check_cursor_pos();\n#endif\n# ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0)\n\t{\n\t    conceal_old_cursor_line = last_cursormoved.lnum;\n\t    conceal_new_cursor_line = curwin->w_cursor.lnum;\n\t    conceal_update_lines = TRUE;\n\t}\n# endif\n\tlast_cursormoved = curwin->w_cursor;\n    }\n\n    // Trigger TextChangedI if b_changedtick_i differs.\n    if (ready && has_textchangedI()\n\t    && curbuf->b_last_changedtick_i != CHANGEDTICK(curbuf)\n\t    && !pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    // Trigger TextChangedP if b_changedtick_pum differs. When the popupmenu\n    // closes TextChangedI will need to trigger for backwards compatibility,\n    // thus use different b_last_changedtick* variables.\n    if (ready && has_textchangedP()\n\t    && curbuf->b_last_changedtick_pum != CHANGEDTICK(curbuf)\n\t    && pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDP, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    if (ready)\n\tmay_trigger_winscrolled();\n\n    // Trigger SafeState if nothing is pending.\n    may_trigger_safestate(ready\n\t    && !ins_compl_active()\n\t    && !pum_visible());\n\n#if defined(FEAT_CONCEAL)\n    if ((conceal_update_lines\n\t    && (conceal_old_cursor_line != conceal_new_cursor_line\n\t\t|| conceal_cursor_line(curwin)))\n\t    || need_cursor_line_redraw)\n    {\n\tif (conceal_old_cursor_line != conceal_new_cursor_line)\n\t    redrawWinline(curwin, conceal_old_cursor_line);\n\tredrawWinline(curwin, conceal_new_cursor_line == 0\n\t\t\t    ? curwin->w_cursor.lnum : conceal_new_cursor_line);\n\tcurwin->w_valid &= ~VALID_CROW;\n\tneed_cursor_line_redraw = FALSE;\n    }\n#endif\n    if (must_redraw)\n\tupdate_screen(0);\n    else if (clear_cmdline || redraw_cmdline)\n\tshowmode();\t\t// clear cmdline and show mode\n    showruler(FALSE);\n    setcursor();\n    emsg_on_display = FALSE;\t// may remove error message now\n}\n\n/*\n * Handle a CTRL-V or CTRL-Q typed in Insert mode.\n */\n    static void\nins_ctrl_v(void)\n{\n    int\t\tc;\n    int\t\tdid_putchar = FALSE;\n\n    // may need to redraw when no more chars available now\n    ins_redraw(FALSE);\n\n    if (redrawing() && !char_avail())\n    {\n\tedit_putchar('^', TRUE);\n\tdid_putchar = TRUE;\n    }\n    AppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\n#ifdef FEAT_CMDL_INFO\n    add_to_showcmd_c(Ctrl_V);\n#endif\n\n    // Do not change any modifyOtherKeys ESC sequence to a normal key for\n    // CTRL-SHIFT-V.\n    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n    if (did_putchar)\n\t// when the line fits in 'columns' the '^' is at the start of the next\n\t// line and will not removed by the redraw\n\tedit_unputchar();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    insert_special(c, FALSE, TRUE);\n#ifdef FEAT_RIGHTLEFT\n    revins_chars++;\n    revins_legal++;\n#endif\n}\n\n/*\n * After getting an ESC or CSI for a literal key: If the typeahead buffer\n * contains a modifyOtherKeys sequence then decode it and return the result.\n * Otherwise return \"c\".\n * Note that this doesn't wait for characters, they must be in the typeahead\n * buffer already.\n */\n    static int\ndecodeModifyOtherKeys(int c)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    idx;\n    int\t    form = 0;\n    int\t    argidx = 0;\n    int\t    arg[2] = {0, 0};\n\n    // Recognize:\n    // form 0: {lead}{key};{modifier}u\n    // form 1: {lead}27;{modifier};{key}~\n    if (typebuf.tb_len >= 4 && (c == CSI || (c == ESC && *p == '[')))\n    {\n\tidx = (*p == '[');\n\tif (p[idx] == '2' && p[idx + 1] == '7' && p[idx + 2] == ';')\n\t{\n\t    form = 1;\n\t    idx += 3;\n\t}\n\twhile (idx < typebuf.tb_len && argidx < 2)\n\t{\n\t    if (p[idx] == ';')\n\t\t++argidx;\n\t    else if (VIM_ISDIGIT(p[idx]))\n\t\targ[argidx] = arg[argidx] * 10 + (p[idx] - '0');\n\t    else\n\t\tbreak;\n\t    ++idx;\n\t}\n\tif (idx < typebuf.tb_len\n\t\t&& p[idx] == (form == 1 ? '~' : 'u')\n\t\t&& argidx == 1)\n\t{\n\t    // Match, consume the code.\n\t    typebuf.tb_off += idx + 1;\n\t    typebuf.tb_len -= idx + 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    if (typebuf.tb_len == 0)\n\t\ttypebuf_was_filled = FALSE;\n#endif\n\n\t    mod_mask = decode_modifiers(arg[!form]);\n\t    c = merge_modifyOtherKeys(arg[form], &mod_mask);\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Put a character directly onto the screen.  It's not stored in a buffer.\n * Used while handling CTRL-K, CTRL-V, etc. in Insert mode.\n */\nstatic int  pc_status;\n#define PC_STATUS_UNSET\t0\t// pc_bytes was not set\n#define PC_STATUS_RIGHT\t1\t// right half of double-wide char\n#define PC_STATUS_LEFT\t2\t// left half of double-wide char\n#define PC_STATUS_SET\t3\t// pc_bytes was filled\nstatic char_u pc_bytes[MB_MAXBYTES + 1]; // saved bytes\nstatic int  pc_attr;\nstatic int  pc_row;\nstatic int  pc_col;\n\n    void\nedit_putchar(int c, int highlight)\n{\n    int\t    attr;\n\n    if (ScreenLines != NULL)\n    {\n\tupdate_topline();\t// just in case w_topline isn't valid\n\tvalidate_cursor();\n\tif (highlight)\n\t    attr = HL_ATTR(HLF_8);\n\telse\n\t    attr = 0;\n\tpc_row = W_WINROW(curwin) + curwin->w_wrow;\n\tpc_col = curwin->w_wincol;\n\tpc_status = PC_STATUS_UNSET;\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t{\n\t    pc_col += curwin->w_width - 1 - curwin->w_wcol;\n\t    if (has_mbyte)\n\t    {\n\t\tint fix_col = mb_fix_col(pc_col, pc_row);\n\n\t\tif (fix_col != pc_col)\n\t\t{\n\t\t    screen_putchar(' ', pc_row, fix_col, attr);\n\t\t    --curwin->w_wcol;\n\t\t    pc_status = PC_STATUS_RIGHT;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    pc_col += curwin->w_wcol;\n\t    if (mb_lefthalve(pc_row, pc_col))\n\t\tpc_status = PC_STATUS_LEFT;\n\t}\n\n\t// save the character to be able to put it back\n\tif (pc_status == PC_STATUS_UNSET)\n\t{\n\t    screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);\n\t    pc_status = PC_STATUS_SET;\n\t}\n\tscreen_putchar(c, pc_row, pc_col, attr);\n    }\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Set the insert start position for when using a prompt buffer.\n */\n    void\nset_insstart(linenr_T lnum, int col)\n{\n    Insstart.lnum = lnum;\n    Insstart.col = col;\n    Insstart_orig = Insstart;\n    Insstart_textlen = Insstart.col;\n    Insstart_blank_vcol = MAXCOL;\n    arrow_used = FALSE;\n}\n#endif\n\n/*\n * Undo the previous edit_putchar().\n */\n    void\nedit_unputchar(void)\n{\n    if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)\n    {\n\tif (pc_status == PC_STATUS_RIGHT)\n\t    ++curwin->w_wcol;\n\tif (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT)\n\t    redrawWinline(curwin, curwin->w_cursor.lnum);\n\telse\n\t    screen_puts(pc_bytes, pc_row - msg_scrolled, pc_col, pc_attr);\n    }\n}\n\n/*\n * Called when p_dollar is set: display a '$' at the end of the changed text\n * Only works when cursor is in the line that changes.\n */\n    void\ndisplay_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}\n\n/*\n * Call this function before moving the cursor from the normal insert position\n * in insert mode.\n */\n    void\nundisplay_dollar(void)\n{\n    if (dollar_vcol >= 0)\n    {\n\tdollar_vcol = -1;\n\tredrawWinline(curwin, curwin->w_cursor.lnum);\n    }\n}\n\n/*\n * Truncate the space at the end of a line.  This is to be used only in an\n * insert mode.  It handles fixing the replace stack for MODE_REPLACE and\n * MODE_VREPLACE modes.\n */\n    void\ntruncate_spaces(char_u *line)\n{\n    int\t    i;\n\n    // find start of trailing white space\n    for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)\n    {\n\tif (State & REPLACE_FLAG)\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n    }\n    line[i + 1] = NUL;\n}\n\n/*\n * Backspace the cursor until the given column.  Handles MODE_REPLACE and\n * MODE_VREPLACE modes correctly.  May also be used when not in insert mode at\n * all.  Will attempt not to go before \"col\" even when there is a composing\n * character.\n */\n    void\nbackspace_until_column(int col)\n{\n    while ((int)curwin->w_cursor.col > col)\n    {\n\tcurwin->w_cursor.col--;\n\tif (State & REPLACE_FLAG)\n\t    replace_do_bs(col);\n\telse if (!del_char_after_col(col))\n\t    break;\n    }\n}\n\n/*\n * Like del_char(), but make sure not to go before column \"limit_col\".\n * Only matters when there are composing characters.\n * Return TRUE when something was deleted.\n */\n   static int\ndel_char_after_col(int limit_col UNUSED)\n{\n    if (enc_utf8 && limit_col >= 0)\n    {\n\tcolnr_T ecol = curwin->w_cursor.col + 1;\n\n\t// Make sure the cursor is at the start of a character, but\n\t// skip forward again when going too far back because of a\n\t// composing character.\n\tmb_adjust_cursor();\n\twhile (curwin->w_cursor.col < (colnr_T)limit_col)\n\t{\n\t    int l = utf_ptr2len(ml_get_cursor());\n\n\t    if (l == 0)  // end of line\n\t\tbreak;\n\t    curwin->w_cursor.col += l;\n\t}\n\tif (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)\n\t    return FALSE;\n\tdel_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);\n    }\n    else\n\t(void)del_char(FALSE);\n    return TRUE;\n}\n\n/*\n * Next character is interpreted literally.\n * A one, two or three digit decimal number is interpreted as its byte value.\n * If one or two digits are entered, the next character is given to vungetc().\n * For Unicode a character > 255 may be returned.\n * If \"noReduceKeys\" is TRUE do not change any modifyOtherKeys ESC sequence\n * into a normal key, return ESC.\n */\n    int\nget_literal(int noReduceKeys)\n{\n    int\t\tcc;\n    int\t\tnc;\n    int\t\ti;\n    int\t\thex = FALSE;\n    int\t\toctal = FALSE;\n    int\t\tunicode = 0;\n\n    if (got_int)\n\treturn Ctrl_C;\n\n#ifdef FEAT_GUI\n    /*\n     * In GUI there is no point inserting the internal code for a special key.\n     * It is more useful to insert the string \"<KEY>\" instead.\tThis would\n     * probably be useful in a text window too, but it would not be\n     * vi-compatible (maybe there should be an option for it?) -- webb\n     */\n    if (gui.in_use)\n    {\n\t++allow_keys;\n\tif (noReduceKeys)\n\t    ++no_reduce_keys;\n    }\n#endif\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\t\t// don't map the next key hits\n    cc = 0;\n    i = 0;\n    for (;;)\n    {\n\tnc = plain_vgetc();\n\tif ((nc == ESC || nc == CSI) && !noReduceKeys)\n\t    nc = decodeModifyOtherKeys(nc);\n\n\tif ((mod_mask & ~MOD_MASK_SHIFT) != 0)\n\t    // A character with non-Shift modifiers should not be a valid\n\t    // character for i_CTRL-V_digit.\n\t    break;\n\n#ifdef FEAT_CMDL_INFO\n\tif ((State & MODE_CMDLINE) == 0 && MB_BYTE2LEN_CHECK(nc) == 1)\n\t    add_to_showcmd(nc);\n#endif\n\tif (nc == 'x' || nc == 'X')\n\t    hex = TRUE;\n\telse if (nc == 'o' || nc == 'O')\n\t    octal = TRUE;\n\telse if (nc == 'u' || nc == 'U')\n\t    unicode = nc;\n\telse\n\t{\n\t    if (hex || unicode != 0)\n\t    {\n\t\tif (!vim_isxdigit(nc))\n\t\t    break;\n\t\tcc = cc * 16 + hex2nr(nc);\n\t    }\n\t    else if (octal)\n\t    {\n\t\tif (nc < '0' || nc > '7')\n\t\t    break;\n\t\tcc = cc * 8 + nc - '0';\n\t    }\n\t    else\n\t    {\n\t\tif (!VIM_ISDIGIT(nc))\n\t\t    break;\n\t\tcc = cc * 10 + nc - '0';\n\t    }\n\n\t    ++i;\n\t}\n\n\tif (cc > 255 && unicode == 0)\n\t    cc = 255;\t\t// limit range to 0-255\n\tnc = 0;\n\n\tif (hex)\t\t// hex: up to two chars\n\t{\n\t    if (i >= 2)\n\t\tbreak;\n\t}\n\telse if (unicode)\t// Unicode: up to four or eight chars\n\t{\n\t    if ((unicode == 'u' && i >= 4) || (unicode == 'U' && i >= 8))\n\t\tbreak;\n\t}\n\telse if (i >= 3)\t// decimal or octal: up to three chars\n\t    break;\n    }\n    if (i == 0)\t    // no number entered\n    {\n\tif (nc == K_ZERO)   // NUL is stored as NL\n\t{\n\t    cc = '\\n';\n\t    nc = 0;\n\t}\n\telse\n\t{\n\t    cc = nc;\n\t    nc = 0;\n\t}\n    }\n\n    if (cc == 0)\t// NUL is stored as NL\n\tcc = '\\n';\n    if (enc_dbcs && (cc & 0xff) == 0)\n\tcc = '?';\t// don't accept an illegal DBCS char, the NUL in the\n\t\t\t// second byte will cause trouble!\n\n    --no_mapping;\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\t--allow_keys;\n\tif (noReduceKeys)\n\t    --no_reduce_keys;\n    }\n#endif\n    if (nc)\n    {\n\tvungetc(nc);\n\t// A character typed with i_CTRL-V_digit cannot have modifiers.\n\tmod_mask = 0;\n    }\n    got_int = FALSE;\t    // CTRL-C typed after CTRL-V is not an interrupt\n    return cc;\n}\n\n/*\n * Insert character, taking care of special keys and mod_mask\n */\n    static void\ninsert_special(\n    int\t    c,\n    int\t    allow_modmask,\n    int\t    ctrlv)\t    // c was typed after CTRL-V\n{\n    char_u  *p;\n    int\t    len;\n\n    /*\n     * Special function key, translate into \"<Key>\". Up to the last '>' is\n     * inserted with ins_str(), so as not to replace characters in replace\n     * mode.\n     * Only use mod_mask for special keys, to avoid things like <S-Space>,\n     * unless 'allow_modmask' is TRUE.\n     */\n#ifdef MACOS_X\n    // Command-key never produces a normal key\n    if (mod_mask & MOD_MASK_CMD)\n\tallow_modmask = TRUE;\n#endif\n    if (IS_SPECIAL(c) || (mod_mask && allow_modmask))\n    {\n\tp = get_special_key_name(c, mod_mask);\n\tlen = (int)STRLEN(p);\n\tc = p[len - 1];\n\tif (len > 2)\n\t{\n\t    if (stop_arrow() == FAIL)\n\t\treturn;\n\t    p[len - 1] = NUL;\n\t    ins_str(p);\n\t    AppendToRedobuffLit(p, -1);\n\t    ctrlv = FALSE;\n\t}\n    }\n    if (stop_arrow() == OK)\n\tinsertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);\n}\n\n/*\n * Special characters in this context are those that need processing other\n * than the simple insertion that can be performed here. This includes ESC\n * which terminates the insert, and CR/NL which need special processing to\n * open up a new line. This routine tries to optimize insertions performed by\n * the \"redo\", \"undo\" or \"put\" commands, so it needs to know when it should\n * stop and defer processing to the \"normal\" mechanism.\n * '0' and '^' are special, because they can be followed by CTRL-D.\n */\n#define ISSPECIAL(c)\t((c) < ' ' || (c) >= DEL || (c) == '0' || (c) == '^')\n\n/*\n * \"flags\": INSCHAR_FORMAT - force formatting\n *\t    INSCHAR_CTRLV  - char typed just after CTRL-V\n *\t    INSCHAR_NO_FEX - don't use 'formatexpr'\n *\n *   NOTE: passes the flags value straight through to internal_format() which,\n *\t   beside INSCHAR_FORMAT (above), is also looking for these:\n *\t    INSCHAR_DO_COM   - format comments\n *\t    INSCHAR_COM_LIST - format comments with num list or 2nd line indent\n */\n    void\ninsertchar(\n    int\t\tc,\t\t\t// character to insert or NUL\n    int\t\tflags,\t\t\t// INSCHAR_FORMAT, etc.\n    int\t\tsecond_indent)\t\t// indent for second line if >= 0\n{\n    int\t\ttextwidth;\n    char_u\t*p;\n    int\t\tfo_ins_blank;\n    int\t\tforce_format = flags & INSCHAR_FORMAT;\n\n    textwidth = comp_textwidth(force_format);\n    fo_ins_blank = has_format_option(FO_INS_BLANK);\n\n    /*\n     * Try to break the line in two or more pieces when:\n     * - Always do this if we have been called to do formatting only.\n     * - Always do this when 'formatoptions' has the 'a' flag and the line\n     *   ends in white space.\n     * - Otherwise:\n     *\t - Don't do this if inserting a blank\n     *\t - Don't do this if an existing character is being replaced, unless\n     *\t   we're in MODE_VREPLACE state.\n     *\t - Do this if the cursor is not on the line where insert started\n     *\t or - 'formatoptions' doesn't have 'l' or the line was not too long\n     *\t       before the insert.\n     *\t    - 'formatoptions' doesn't have 'b' or a blank was inserted at or\n     *\t      before 'textwidth'\n     */\n    if (textwidth > 0\n\t    && (force_format\n\t\t|| (!VIM_ISWHITE(c)\n\t\t    && !((State & REPLACE_FLAG)\n\t\t\t&& !(State & VREPLACE_FLAG)\n\t\t\t&& *ml_get_cursor() != NUL)\n\t\t    && (curwin->w_cursor.lnum != Insstart.lnum\n\t\t\t|| ((!has_format_option(FO_INS_LONG)\n\t\t\t\t|| Insstart_textlen <= (colnr_T)textwidth)\n\t\t\t    && (!fo_ins_blank\n\t\t\t\t|| Insstart_blank_vcol <= (colnr_T)textwidth\n\t\t\t    ))))))\n    {\n\t// Format with 'formatexpr' when it's set.  Use internal formatting\n\t// when 'formatexpr' isn't set or it returns non-zero.\n#if defined(FEAT_EVAL)\n\tint     do_internal = TRUE;\n\tcolnr_T virtcol = get_nolist_virtcol()\n\t\t\t\t  + char2cells(c != NUL ? c : gchar_cursor());\n\n\tif (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0\n\t\t&& (force_format || virtcol > (colnr_T)textwidth))\n\t{\n\t    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);\n\t    // It may be required to save for undo again, e.g. when setline()\n\t    // was called.\n\t    ins_need_undo = TRUE;\n\t}\n\tif (do_internal)\n#endif\n\t    internal_format(textwidth, second_indent, flags, c == NUL, c);\n    }\n\n    if (c == NUL)\t    // only formatting was wanted\n\treturn;\n\n    // Check whether this character should end a comment.\n    if (did_ai && c == end_comment_pending)\n    {\n\tchar_u  *line;\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tint\tmiddle_len, end_len;\n\tint\ti;\n\n\t/*\n\t * Need to remove existing (middle) comment leader and insert end\n\t * comment leader.  First, check what comment leader we can find.\n\t */\n\ti = get_leader_len(line = ml_get_curline(), &p, FALSE, TRUE);\n\tif (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL)\t// Just checking\n\t{\n\t    // Skip middle-comment string\n\t    while (*p && p[-1] != ':')\t// find end of middle flags\n\t\t++p;\n\t    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    // Don't count trailing white space for middle_len\n\t    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))\n\t\t--middle_len;\n\n\t    // Find the end-comment string\n\t    while (*p && p[-1] != ':')\t// find end of end flags\n\t\t++p;\n\t    end_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t    // Skip white space before the cursor\n\t    i = curwin->w_cursor.col;\n\t    while (--i >= 0 && VIM_ISWHITE(line[i]))\n\t\t;\n\t    i++;\n\n\t    // Skip to before the middle leader\n\t    i -= middle_len;\n\n\t    // Check some expected things before we go on\n\t    if (i >= 0 && lead_end[end_len - 1] == end_comment_pending)\n\t    {\n\t\t// Backspace over all the stuff we want to replace\n\t\tbackspace_until_column(i);\n\n\t\t// Insert the end-comment string, except for the last\n\t\t// character, which will get inserted as normal later.\n\t\tins_bytes_len(lead_end, end_len - 1);\n\t    }\n\t}\n    }\n    end_comment_pending = NUL;\n\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    /*\n     * If there's any pending input, grab up to INPUT_BUFLEN at once.\n     * This speeds up normal text input considerably.\n     * Don't do this when 'cindent' or 'indentexpr' is set, because we might\n     * need to re-indent at a ':', or any other character (but not what\n     * 'paste' is set)..\n     * Don't do this when there an InsertCharPre autocommand is defined,\n     * because we need to fire the event for every character.\n     * Do the check for InsertCharPre before the call to vpeekc() because the\n     * InsertCharPre autocommand could change the input buffer.\n     */\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n    if (       !ISSPECIAL(c)\n\t    && (!has_mbyte || (*mb_char2len)(c) == 1)\n\t    && !has_insertcharpre()\n\t    && vpeekc() != NUL\n\t    && !(State & REPLACE_FLAG)\n#ifdef FEAT_CINDENT\n\t    && !cindent_on()\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    && !p_ri\n#endif\n\t   )\n    {\n#define INPUT_BUFLEN 100\n\tchar_u\t\tbuf[INPUT_BUFLEN + 1];\n\tint\t\ti;\n\tcolnr_T\t\tvirtcol = 0;\n\n\tbuf[0] = c;\n\ti = 1;\n\tif (textwidth > 0)\n\t    virtcol = get_nolist_virtcol();\n\t/*\n\t * Stop the string when:\n\t * - no more chars available\n\t * - finding a special character (command key)\n\t * - buffer is full\n\t * - running into the 'textwidth' boundary\n\t * - need to check for abbreviation: A non-word char after a word-char\n\t */\n\twhile (\t   (c = vpeekc()) != NUL\n\t\t&& !ISSPECIAL(c)\n\t\t&& (!has_mbyte || MB_BYTE2LEN_CHECK(c) == 1)\n\t\t&& i < INPUT_BUFLEN\n\t\t&& (textwidth == 0\n\t\t    || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)\n\t\t&& !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1])))\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    c = vgetc();\n\t    if (p_hkmap && KeyTyped)\n\t\tc = hkmap(c);\t\t    // Hebrew mode mapping\n\t    buf[i++] = c;\n#else\n\t    buf[i++] = vgetc();\n#endif\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tdo_digraph(-1);\t\t\t// clear digraphs\n\tdo_digraph(buf[i-1]);\t\t// may be the start of a digraph\n#endif\n\tbuf[i] = NUL;\n\tins_str(buf);\n\tif (flags & INSCHAR_CTRLV)\n\t{\n\t    redo_literal(*buf);\n\t    i = 1;\n\t}\n\telse\n\t    i = 0;\n\tif (buf[i] != NUL)\n\t    AppendToRedobuffLit(buf + i, -1);\n    }\n    else\n    {\n\tint\t\tcc;\n\n\tif (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n\t{\n\t    char_u\tbuf[MB_MAXBYTES + 1];\n\n\t    (*mb_char2bytes)(c, buf);\n\t    buf[cc] = NUL;\n\t    ins_char_bytes(buf, cc);\n\t    AppendCharToRedobuff(c);\n\t}\n\telse\n\t{\n\t    ins_char(c);\n\t    if (flags & INSCHAR_CTRLV)\n\t\tredo_literal(c);\n\t    else\n\t\tAppendCharToRedobuff(c);\n\t}\n    }\n}\n\n/*\n * Put a character in the redo buffer, for when just after a CTRL-V.\n */\n    static void\nredo_literal(int c)\n{\n    char_u\tbuf[10];\n\n    // Only digits need special treatment.  Translate them into a string of\n    // three digits.\n    if (VIM_ISDIGIT(c))\n    {\n\tvim_snprintf((char *)buf, sizeof(buf), \"%03d\", c);\n\tAppendToRedobuff(buf);\n    }\n    else\n\tAppendCharToRedobuff(c);\n}\n\n/*\n * start_arrow() is called when an arrow key is used in insert mode.\n * For undo/redo it resembles hitting the <ESC> key.\n */\n    void\nstart_arrow(\n    pos_T    *end_insert_pos)\t\t// can be NULL\n{\n    start_arrow_common(end_insert_pos, TRUE);\n}\n\n/*\n * Like start_arrow() but with end_change argument.\n * Will prepare for redo of CTRL-G U if \"end_change\" is FALSE.\n */\n    static void\nstart_arrow_with_change(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    start_arrow_common(end_insert_pos, end_change);\n    if (!end_change)\n    {\n\tAppendCharToRedobuff(Ctrl_G);\n\tAppendCharToRedobuff('U');\n    }\n}\n\n    static void\nstart_arrow_common(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    if (!arrow_used && end_change)\t// something has been inserted\n    {\n\tAppendToRedobuff(ESC_STR);\n\tstop_insert(end_insert_pos, FALSE, FALSE);\n\tarrow_used = TRUE;\t// this means we stopped the current insert\n    }\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n}\n\n#ifdef FEAT_SPELL\n/*\n * If we skipped highlighting word at cursor, do it now.\n * It may be skipped again, thus reset spell_redraw_lnum first.\n */\n    static void\ncheck_spell_redraw(void)\n{\n    if (spell_redraw_lnum != 0)\n    {\n\tlinenr_T\tlnum = spell_redraw_lnum;\n\n\tspell_redraw_lnum = 0;\n\tredrawWinline(curwin, lnum);\n    }\n}\n\n#endif\n\n/*\n * stop_arrow() is called before a change is made in insert mode.\n * If an arrow key has been used, start a new insertion.\n * Returns FAIL if undo is impossible, shouldn't insert then.\n */\n    int\nstop_arrow(void)\n{\n    if (arrow_used)\n    {\n\tInsstart = curwin->w_cursor;\t// new insertion starts here\n\tif (Insstart.col > Insstart_orig.col && !ins_need_undo)\n\t    // Don't update the original insert position when moved to the\n\t    // right, except when nothing was inserted yet.\n\t    update_Insstart_orig = FALSE;\n\tInsstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n\n\tif (u_save_cursor() == OK)\n\t{\n\t    arrow_used = FALSE;\n\t    ins_need_undo = FALSE;\n\t}\n\n\tai_col = 0;\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    orig_line_count = curbuf->b_ml.ml_line_count;\n\t    vr_lines_changed = 1;\n\t}\n\tResetRedobuff();\n\tAppendToRedobuff((char_u *)\"1i\");   // pretend we start an insertion\n\tnew_insert_skip = 2;\n    }\n    else if (ins_need_undo)\n    {\n\tif (u_save_cursor() == OK)\n\t    ins_need_undo = FALSE;\n    }\n\n#ifdef FEAT_FOLDING\n    // Always open fold at the cursor line when inserting something.\n    foldOpenCursor();\n#endif\n\n    return (arrow_used || ins_need_undo ? FAIL : OK);\n}\n\n/*\n * Do a few things to stop inserting.\n * \"end_insert_pos\" is where insert ended.  It is NULL when we already jumped\n * to another window/buffer.\n */\n    static void\nstop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active && VIsual.lnum == curwin->w_cursor.lnum)\n\t    {\n\t\tint len = (int)STRLEN(ml_get_curline());\n\n\t\tif (VIsual.col > len)\n\t\t{\n\t\t    VIsual.col = len;\n\t\t    VIsual.coladd = 0;\n\t\t}\n\t    }\n\t}\n    }\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}\n\n/*\n * Set the last inserted text to a single character.\n * Used for the replace command.\n */\n    void\nset_last_insert(int c)\n{\n    char_u\t*s;\n\n    vim_free(last_insert);\n    last_insert = alloc(MB_MAXBYTES * 3 + 5);\n    if (last_insert != NULL)\n    {\n\ts = last_insert;\n\t// Use the CTRL-V only when entering a special char\n\tif (c < ' ' || c == DEL)\n\t    *s++ = Ctrl_V;\n\ts = add_char2buf(c, s);\n\t*s++ = ESC;\n\t*s++ = NUL;\n\tlast_insert_skip = 0;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_last_insert(void)\n{\n    VIM_CLEAR(last_insert);\n}\n#endif\n\n/*\n * Add character \"c\" to buffer \"s\".  Escape the special meaning of K_SPECIAL\n * and CSI.  Handle multi-byte characters.\n * Returns a pointer to after the added bytes.\n */\n    char_u *\nadd_char2buf(int c, char_u *s)\n{\n    char_u\ttemp[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tlen;\n\n    len = (*mb_char2bytes)(c, temp);\n    for (i = 0; i < len; ++i)\n    {\n\tc = temp[i];\n\t// Need to escape K_SPECIAL and CSI like in the typeahead buffer.\n\tif (c == K_SPECIAL)\n\t{\n\t    *s++ = K_SPECIAL;\n\t    *s++ = KS_SPECIAL;\n\t    *s++ = KE_FILLER;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    *s++ = CSI;\n\t    *s++ = KS_EXTRA;\n\t    *s++ = (int)KE_CSI;\n\t}\n#endif\n\telse\n\t    *s++ = c;\n    }\n    return s;\n}\n\n/*\n * move cursor to start of line\n * if flags & BL_WHITE\tmove to first non-white\n * if flags & BL_SOL\tmove to first non-white if startofline is set,\n *\t\t\t    otherwise keep \"curswant\" column\n * if flags & BL_FIX\tdon't leave the cursor on a NUL.\n */\n    void\nbeginline(int flags)\n{\n    if ((flags & BL_SOL) && !p_sol)\n\tcoladvance(curwin->w_curswant);\n    else\n    {\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\n\tif (flags & (BL_WHITE | BL_SOL))\n\t{\n\t    char_u  *ptr;\n\n\t    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)\n\t\t\t       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)\n\t\t++curwin->w_cursor.col;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * oneright oneleft cursor_down cursor_up\n *\n * Move one char {right,left,down,up}.\n * Doesn't move onto the NUL past the end of the line, unless it is allowed.\n * Return OK when successful, FAIL when we hit a line of file boundary.\n */\n\n    int\noneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\n\t// Adjust for multi-wide char (excluding TAB)\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\t// Return OK if the cursor moved, FAIL otherwise (at window edge).\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    // already at the very end\n\n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n\n    // move \"l\" bytes right, but don't end up on the NUL, unless 'virtualedit'\n    // contains \"onemore\".\n    if (ptr[l] == NUL && (get_ve_flags() & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}\n\n    int\noneleft(void)\n{\n    if (virtual_active())\n    {\n#ifdef FEAT_LINEBREAK\n\tint width;\n#endif\n\tint v = getviscol();\n\n\tif (v == 0)\n\t    return FAIL;\n\n#ifdef FEAT_LINEBREAK\n\t// We might get stuck on 'showbreak', skip over it.\n\twidth = 1;\n\tfor (;;)\n\t{\n\t    coladvance(v - width);\n\t    // getviscol() is slow, skip it when 'showbreak' is empty,\n\t    // 'breakindent' is not set and there are no multi-byte\n\t    // characters\n\t    if ((*get_showbreak_value(curwin) == NUL && !curwin->w_p_bri\n\t\t\t\t\t     && !has_mbyte) || getviscol() < v)\n\t\tbreak;\n\t    ++width;\n\t}\n#else\n\tcoladvance(v - 1);\n#endif\n\n\tif (curwin->w_cursor.coladd == 1)\n\t{\n\t    char_u *ptr;\n\n\t    // Adjust for multi-wide char (not a TAB)\n\t    ptr = ml_get_cursor();\n\t    if (*ptr != TAB && vim_isprintc((*mb_ptr2char)(ptr))\n\t\t\t\t\t\t\t && ptr2cells(ptr) > 1)\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\n\tcurwin->w_set_curswant = TRUE;\n\treturn OK;\n    }\n\n    if (curwin->w_cursor.col == 0)\n\treturn FAIL;\n\n    curwin->w_set_curswant = TRUE;\n    --curwin->w_cursor.col;\n\n    // if the character on the left of the current cursor is a multi-byte\n    // character, move to its first byte\n    if (has_mbyte)\n\tmb_adjust_cursor();\n    return OK;\n}\n\n    int\ncursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\t// This fails if the cursor is already in the first line or the count\n\t// is larger than the line number and '-' is in 'cpoptions'\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    /*\n\t     * Count each sequence of folded lines as one logical line.\n\t     */\n\t    // go to the start of the current fold\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\n\t    while (n--)\n\t    {\n\t\t// move up one line\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\t// If we entered a fold, move to the beginning, unless in\n\t\t// Insert mode or when 'foldopen' contains \"all\": it will open\n\t\t// in a moment.\n\t\tif (n > 0 || !((State & MODE_INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Cursor down a number of logical lines.\n */\n    int\ncursor_down(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Move to last line of fold, will fail if it's the end-of-file.\n\t(void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t// This fails if the cursor is already in the last line or would move\n\t// beyond the last line and '-' is in 'cpoptions'\n\tif (lnum >= curbuf->b_ml.ml_line_count\n\t\t|| (lnum + n > curbuf->b_ml.ml_line_count\n\t\t    && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (lnum + n >= curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count;\n\telse\n#ifdef FEAT_FOLDING\n\tif (hasAnyFolding(curwin))\n\t{\n\t    linenr_T\tlast;\n\n\t    // count each sequence of folded lines as one logical line\n\t    while (n--)\n\t    {\n\t\tif (hasFolding(lnum, NULL, &last))\n\t\t    lnum = last + 1;\n\t\telse\n\t\t    ++lnum;\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t    }\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t}\n\telse\n#endif\n\t    lnum += n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Stuff the last inserted text in the read buffer.\n * Last_insert actually is a copy of the redo buffer, so we\n * first have to remove the command.\n */\n    int\nstuff_inserted(\n    int\t    c,\t\t// Command character to be inserted\n    long    count,\t// Repeat this many times\n    int\t    no_esc)\t// Don't add an ESC at the end\n{\n    char_u\t*esc_ptr;\n    char_u\t*ptr;\n    char_u\t*last_ptr;\n    char_u\tlast = NUL;\n\n    ptr = get_last_insert();\n    if (ptr == NULL)\n    {\n\temsg(_(e_no_inserted_text_yet));\n\treturn FAIL;\n    }\n\n    // may want to stuff the command character, to start Insert mode\n    if (c != NUL)\n\tstuffcharReadbuff(c);\n    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)\n\t*esc_ptr = NUL;\t    // remove the ESC\n\n    // when the last char is either \"0\" or \"^\" it will be quoted if no ESC\n    // comes after it OR if it will inserted more than once and \"ptr\"\n    // starts with ^D.\t-- Acevedo\n    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;\n    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')\n\t    && (no_esc || (*ptr == Ctrl_D && count > 1)))\n    {\n\tlast = *last_ptr;\n\t*last_ptr = NUL;\n    }\n\n    do\n    {\n\tstuffReadbuff(ptr);\n\t// a trailing \"0\" is inserted as \"<C-V>048\", \"^\" as \"<C-V>^\"\n\tif (last)\n\t    stuffReadbuff(\n\t\t       (char_u *)(last == '0' ? \"\\026\\060\\064\\070\" : \"\\026^\"));\n    }\n    while (--count > 0);\n\n    if (last)\n\t*last_ptr = last;\n\n    if (esc_ptr != NULL)\n\t*esc_ptr = ESC;\t    // put the ESC back\n\n    // may want to stuff a trailing ESC, to get out of Insert mode\n    if (!no_esc)\n\tstuffcharReadbuff(ESC);\n\n    return OK;\n}\n\n    char_u *\nget_last_insert(void)\n{\n    if (last_insert == NULL)\n\treturn NULL;\n    return last_insert + last_insert_skip;\n}\n\n/*\n * Get last inserted string, and remove trailing <Esc>.\n * Returns pointer to allocated memory (must be freed) or NULL.\n */\n    char_u *\nget_last_insert_save(void)\n{\n    char_u\t*s;\n    int\t\tlen;\n\n    if (last_insert == NULL)\n\treturn NULL;\n    s = vim_strsave(last_insert + last_insert_skip);\n    if (s != NULL)\n    {\n\tlen = (int)STRLEN(s);\n\tif (len > 0 && s[len - 1] == ESC)\t// remove trailing ESC\n\t    s[len - 1] = NUL;\n    }\n    return s;\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text and\n * the replacement string is inserted in typebuf.tb_buf[], followed by \"c\".\n */\n    static int\necheck_abbr(int c)\n{\n    // Don't check for abbreviation in paste mode, when disabled and just\n    // after moving around with cursor keys.\n    if (p_paste || no_abbr || arrow_used)\n\treturn FALSE;\n\n    return check_abbr(c, ml_get_curline(), curwin->w_cursor.col,\n\t\tcurwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);\n}\n\n/*\n * replace-stack functions\n *\n * When replacing characters, the replaced characters are remembered for each\n * new character.  This is used to re-insert the old text when backspacing.\n *\n * There is a NUL headed list of characters for each character that is\n * currently in the file after the insertion point.  When BS is used, one NUL\n * headed list is put back for the deleted character.\n *\n * For a newline, there are two NUL headed lists.  One contains the characters\n * that the NL replaced.  The extra one stores the characters after the cursor\n * that were deleted (always white space).\n *\n * Replace_offset is normally 0, in which case replace_push will add a new\n * character at the end of the stack.  If replace_offset is not 0, that many\n * characters will be left on the stack above the newly inserted character.\n */\n\nstatic char_u\t*replace_stack = NULL;\nstatic long\treplace_stack_nr = 0;\t    // next entry in replace stack\nstatic long\treplace_stack_len = 0;\t    // max. number of entries\n\n    void\nreplace_push(\n    int\t    c)\t    // character that is replaced (NUL is none)\n{\n    char_u  *p;\n\n    if (replace_stack_nr < replace_offset)\t// nothing to do\n\treturn;\n    if (replace_stack_len <= replace_stack_nr)\n    {\n\treplace_stack_len += 50;\n\tp = ALLOC_MULT(char_u, replace_stack_len);\n\tif (p == NULL)\t    // out of memory\n\t{\n\t    replace_stack_len -= 50;\n\t    return;\n\t}\n\tif (replace_stack != NULL)\n\t{\n\t    mch_memmove(p, replace_stack,\n\t\t\t\t (size_t)(replace_stack_nr * sizeof(char_u)));\n\t    vim_free(replace_stack);\n\t}\n\treplace_stack = p;\n    }\n    p = replace_stack + replace_stack_nr - replace_offset;\n    if (replace_offset)\n\tmch_memmove(p + 1, p, (size_t)(replace_offset * sizeof(char_u)));\n    *p = c;\n    ++replace_stack_nr;\n}\n\n/*\n * Push a character onto the replace stack.  Handles a multi-byte character in\n * reverse byte order, so that the first byte is popped off first.\n * Return the number of bytes done (includes composing characters).\n */\n    int\nreplace_push_mb(char_u *p)\n{\n    int l = (*mb_ptr2len)(p);\n    int j;\n\n    for (j = l - 1; j >= 0; --j)\n\treplace_push(p[j]);\n    return l;\n}\n\n/*\n * Pop one item from the replace stack.\n * return -1 if stack empty\n * return replaced character or NUL otherwise\n */\n    static int\nreplace_pop(void)\n{\n    if (replace_stack_nr == 0)\n\treturn -1;\n    return (int)replace_stack[--replace_stack_nr];\n}\n\n/*\n * Join the top two items on the replace stack.  This removes to \"off\"'th NUL\n * encountered.\n */\n    void\nreplace_join(\n    int\t    off)\t// offset for which NUL to remove\n{\n    int\t    i;\n\n    for (i = replace_stack_nr; --i >= 0; )\n\tif (replace_stack[i] == NUL && off-- <= 0)\n\t{\n\t    --replace_stack_nr;\n\t    mch_memmove(replace_stack + i, replace_stack + i + 1,\n\t\t\t\t\t      (size_t)(replace_stack_nr - i));\n\t    return;\n\t}\n}\n\n/*\n * Pop bytes from the replace stack until a NUL is found, and insert them\n * before the cursor.  Can only be used in MODE_REPLACE or MODE_VREPLACE state.\n */\n    static void\nreplace_pop_ins(void)\n{\n    int\t    cc;\n    int\t    oldState = State;\n\n    State = MODE_NORMAL;\t\t\t// don't want MODE_REPLACE here\n    while ((cc = replace_pop()) > 0)\n    {\n\tmb_replace_pop_ins(cc);\n\tdec_cursor();\n    }\n    State = oldState;\n}\n\n/*\n * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it\n * indicates a multi-byte char, pop the other bytes too.\n */\n    static void\nmb_replace_pop_ins(int cc)\n{\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tc;\n\n    if (has_mbyte && (n = MB_BYTE2LEN(cc)) > 1)\n    {\n\tbuf[0] = cc;\n\tfor (i = 1; i < n; ++i)\n\t    buf[i] = replace_pop();\n\tins_bytes_len(buf, n);\n    }\n    else\n\tins_char(cc);\n\n    if (enc_utf8)\n\t// Handle composing chars.\n\tfor (;;)\n\t{\n\t    c = replace_pop();\n\t    if (c == -1)\t    // stack empty\n\t\tbreak;\n\t    if ((n = MB_BYTE2LEN(c)) == 1)\n\t    {\n\t\t// Not a multi-byte char, put it back.\n\t\treplace_push(c);\n\t\tbreak;\n\t    }\n\n\t    buf[0] = c;\n\t    for (i = 1; i < n; ++i)\n\t\tbuf[i] = replace_pop();\n\t    if (utf_iscomposing(utf_ptr2char(buf)))\n\t\tins_bytes_len(buf, n);\n\t    else\n\t    {\n\t\t// Not a composing char, put it back.\n\t\tfor (i = n - 1; i >= 0; --i)\n\t\t    replace_push(buf[i]);\n\t\tbreak;\n\t    }\n\n\t}\n}\n\n/*\n * make the replace stack empty\n * (called when exiting replace mode)\n */\n    static void\nreplace_flush(void)\n{\n    VIM_CLEAR(replace_stack);\n    replace_stack_len = 0;\n    replace_stack_nr = 0;\n}\n\n/*\n * Handle doing a BS for one character.\n * cc < 0: replace stack empty, just move cursor\n * cc == 0: character was inserted, delete it\n * cc > 0: character was replaced, put cc (first byte of original char) back\n * and check for more characters to be put back\n * When \"limit_col\" is >= 0, don't delete before this column.  Matters when\n * using composing characters, use del_char_after_col() instead of del_char().\n */\n    static void\nreplace_do_bs(int limit_col)\n{\n    int\t\tcc;\n    int\t\torig_len = 0;\n    int\t\tins_len;\n    int\t\torig_vcols = 0;\n    colnr_T\tstart_vcol;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tvcol;\n\n    cc = replace_pop();\n    if (cc > 0)\n    {\n#ifdef FEAT_PROP_POPUP\n\tsize_t\tlen_before = 0;  // init to shut up GCC\n\n\tif (curbuf->b_has_textprop)\n\t{\n\t    // Do not adjust text properties for individual delete and insert\n\t    // operations, do it afterwards on the resulting text.\n\t    len_before = STRLEN(ml_get_curline());\n\t    ++text_prop_frozen;\n\t}\n#endif\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the character we are\n\t    // going to delete.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &start_vcol, NULL);\n\t    orig_vcols = chartabsize(ml_get_cursor(), start_vcol);\n\t}\n\tif (has_mbyte)\n\t{\n\t    (void)del_char_after_col(limit_col);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor());\n\t    replace_push(cc);\n\t}\n\telse\n\t{\n\t    pchar_cursor(cc);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor()) - 1;\n\t}\n\treplace_pop_ins();\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the inserted characters\n\t    p = ml_get_cursor();\n\t    ins_len = (int)STRLEN(p) - orig_len;\n\t    vcol = start_vcol;\n\t    for (i = 0; i < ins_len; ++i)\n\t    {\n\t\tvcol += chartabsize(p + i, vcol);\n\t\ti += (*mb_ptr2len)(p) - 1;\n\t    }\n\t    vcol -= start_vcol;\n\n\t    // Delete spaces that were inserted after the cursor to keep the\n\t    // text aligned.\n\t    curwin->w_cursor.col += ins_len;\n\t    while (vcol > orig_vcols && gchar_cursor() == ' ')\n\t    {\n\t\tdel_char(FALSE);\n\t\t++orig_vcols;\n\t    }\n\t    curwin->w_cursor.col -= ins_len;\n\t}\n\n\t// mark the buffer as changed and prepare for displaying\n\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n#ifdef FEAT_PROP_POPUP\n\tif (curbuf->b_has_textprop)\n\t{\n\t    size_t len_now = STRLEN(ml_get_curline());\n\n\t    --text_prop_frozen;\n\t    adjust_prop_columns(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t   (int)(len_now - len_before), 0);\n\t}\n#endif\n    }\n    else if (cc == 0)\n\t(void)del_char_after_col(limit_col);\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Map Hebrew keyboard when in hkmap mode.\n */\n    int\nhkmap(int c)\n{\n    if (p_hkmapp)   // phonetic mapping, by Ilya Dogolazky\n    {\n\tenum {hALEF=0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,\n\t    KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,\n\t    PEIsofit, PEI, ZADIsofit, ZADI, KOF, RESH, hSHIN, TAV};\n\tstatic char_u map[26] =\n\t    {(char_u)hALEF/*a*/, (char_u)BET  /*b*/, (char_u)hKAF    /*c*/,\n\t     (char_u)DALET/*d*/, (char_u)-1   /*e*/, (char_u)PEIsofit/*f*/,\n\t     (char_u)GIMEL/*g*/, (char_u)HEI  /*h*/, (char_u)IUD     /*i*/,\n\t     (char_u)HET  /*j*/, (char_u)KOF  /*k*/, (char_u)LAMED   /*l*/,\n\t     (char_u)MEM  /*m*/, (char_u)NUN  /*n*/, (char_u)SAMEH   /*o*/,\n\t     (char_u)PEI  /*p*/, (char_u)-1   /*q*/, (char_u)RESH    /*r*/,\n\t     (char_u)ZAIN /*s*/, (char_u)TAV  /*t*/, (char_u)TET     /*u*/,\n\t     (char_u)VAV  /*v*/, (char_u)hSHIN/*w*/, (char_u)-1      /*x*/,\n\t     (char_u)AIN  /*y*/, (char_u)ZADI /*z*/};\n\n\tif (c == 'N' || c == 'M' || c == 'P' || c == 'C' || c == 'Z')\n\t    return (int)(map[CharOrd(c)] - 1 + p_aleph);\n\t\t\t\t\t\t\t    // '-1'='sofit'\n\telse if (c == 'x')\n\t    return 'X';\n\telse if (c == 'q')\n\t    return '\\''; // {geresh}={'}\n\telse if (c == 246)\n\t    return ' ';  // \\\"o --> ' ' for a german keyboard\n\telse if (c == 228)\n\t    return ' ';  // \\\"a --> ' '      -- / --\n\telse if (c == 252)\n\t    return ' ';  // \\\"u --> ' '      -- / --\n\t// NOTE: islower() does not do the right thing for us on Linux so we\n\t// do this the same was as 5.7 and previous, so it works correctly on\n\t// all systems.  Specifically, the e.g. Delete and Arrow keys are\n\t// munged and won't work if e.g. searching for Hebrew text.\n\telse if (c >= 'a' && c <= 'z')\n\t    return (int)(map[CharOrdLow(c)] + p_aleph);\n\telse\n\t    return c;\n    }\n    else\n    {\n\tswitch (c)\n\t{\n\t    case '`':\treturn ';';\n\t    case '/':\treturn '.';\n\t    case '\\'':\treturn ',';\n\t    case 'q':\treturn '/';\n\t    case 'w':\treturn '\\'';\n\n\t\t\t// Hebrew letters - set offset from 'a'\n\t    case ',':\tc = '{'; break;\n\t    case '.':\tc = 'v'; break;\n\t    case ';':\tc = 't'; break;\n\t    default: {\n\t\t\t static char str[] = \"zqbcxlsjphmkwonu ydafe rig\";\n\n\t\t\t if (c < 'a' || c > 'z')\n\t\t\t     return c;\n\t\t\t c = str[CharOrdLow(c)];\n\t\t\t break;\n\t\t     }\n\t}\n\n\treturn (int)(CharOrdLow(c) + p_aleph);\n    }\n}\n#endif\n\n    static void\nins_reg(void)\n{\n    int\t\tneed_redraw = FALSE;\n    int\t\tregname;\n    int\t\tliterally = 0;\n    int\t\tvis_active = VIsual_active;\n\n    /*\n     * If we are going to wait for a character, show a '\"'.\n     */\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('\"', TRUE);\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_R);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    /*\n     * Don't map the register name. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    regname = plain_vgetc();\n    LANGMAP_ADJUST(regname, TRUE);\n    if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)\n    {\n\t// Get a third key for literal register insertion\n\tliterally = regname;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(literally);\n#endif\n\tregname = plain_vgetc();\n\tLANGMAP_ADJUST(regname, TRUE);\n    }\n    --no_mapping;\n    --allow_keys;\n\n#ifdef FEAT_EVAL\n    // Don't call u_sync() while typing the expression or giving an error\n    // message for it. Only call it explicitly.\n    ++no_u_sync;\n    if (regname == '=')\n    {\n\tpos_T\tcurpos = curwin->w_cursor;\n# ifdef HAVE_INPUT_METHOD\n\tint\tim_on = im_get_status();\n# endif\n\t// Sync undo when evaluating the expression calls setline() or\n\t// append(), so that it can be undone separately.\n\tu_sync_once = 2;\n\n\tregname = get_expr_register();\n\n\t// Cursor may be moved back a column.\n\tcurwin->w_cursor = curpos;\n\tcheck_cursor();\n# ifdef HAVE_INPUT_METHOD\n\t// Restore the Input Method.\n\tif (im_on)\n\t    im_set_active(TRUE);\n# endif\n    }\n    if (regname == NUL || !valid_yank_reg(regname, FALSE))\n    {\n\tvim_beep(BO_REG);\n\tneed_redraw = TRUE;\t// remove the '\"'\n    }\n    else\n    {\n#endif\n\tif (literally == Ctrl_O || literally == Ctrl_P)\n\t{\n\t    // Append the command to the redo buffer.\n\t    AppendCharToRedobuff(Ctrl_R);\n\t    AppendCharToRedobuff(literally);\n\t    AppendCharToRedobuff(regname);\n\n\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n\t}\n\telse if (insert_reg(regname, literally) == FAIL)\n\t{\n\t    vim_beep(BO_REG);\n\t    need_redraw = TRUE;\t// remove the '\"'\n\t}\n\telse if (stop_insert_mode)\n\t    // When the '=' register was used and a function was invoked that\n\t    // did \":stopinsert\" then stuff_empty() returns FALSE but we won't\n\t    // insert anything, need to remove the '\"'\n\t    need_redraw = TRUE;\n\n#ifdef FEAT_EVAL\n    }\n    --no_u_sync;\n    if (u_sync_once == 1)\n\tins_need_undo = TRUE;\n    u_sync_once = 0;\n#endif\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    // If the inserted register is empty, we need to remove the '\"'\n    if (need_redraw || stuff_empty())\n\tedit_unputchar();\n\n    // Disallow starting Visual mode here, would get a weird mode.\n    if (!vis_active && VIsual_active)\n\tend_visual_mode();\n}\n\n/*\n * CTRL-G commands in Insert mode.\n */\n    static void\nins_ctrl_g(void)\n{\n    int\t\tc;\n\n    // Right after CTRL-X the cursor will be after the ruler.\n    setcursor();\n\n    /*\n     * Don't map the second key. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    switch (c)\n    {\n\t// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col\n\tcase K_UP:\n\tcase Ctrl_K:\n\tcase 'k': ins_up(TRUE);\n\t\t  break;\n\n\t// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col\n\tcase K_DOWN:\n\tcase Ctrl_J:\n\tcase 'j': ins_down(TRUE);\n\t\t  break;\n\n\t// CTRL-G u: start new undoable edit\n\tcase 'u': u_sync(TRUE);\n\t\t  ins_need_undo = TRUE;\n\n\t\t  // Need to reset Insstart, esp. because a BS that joins\n\t\t  // a line to the previous one must save for undo.\n\t\t  update_Insstart_orig = FALSE;\n\t\t  Insstart = curwin->w_cursor;\n\t\t  break;\n\n\t// CTRL-G U: do not break undo with the next char\n\tcase 'U':\n\t\t  // Allow one left/right cursor movement with the next char,\n\t\t  // without breaking undo.\n\t\t  dont_sync_undo = MAYBE;\n\t\t  break;\n\n\t// Unknown CTRL-G command, reserved for future expansion.\n\tdefault:  vim_beep(BO_CTRLG);\n    }\n}\n\n/*\n * CTRL-^ in Insert mode.\n */\n    static void\nins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, Toggle use of \":lmap\" mappings.\n\tif (State & MODE_LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~MODE_LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~MODE_LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    // may show different cursor shape or color\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle ESC in insert mode.\n * Returns TRUE when leaving insert mode, FALSE when going to repeat the\n * insert.\n */\n    static int\nins_esc(\n    long\t*count,\n    int\t\tcmdchar,\n    int\t\tnomove)\t    // don't move cursor\n{\n    int\t\ttemp;\n    static int\tdisabled_redraw = FALSE;\n#ifdef FEAT_CONCEAL\n    // Remember if the cursor line was concealed before changing State.\n    int\t\tcursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n\n    temp = curwin->w_cursor.col;\n    if (disabled_redraw)\n    {\n\t--RedrawingDisabled;\n\tdisabled_redraw = FALSE;\n    }\n    if (!arrow_used)\n    {\n\t/*\n\t * Don't append the ESC for \"r<CR>\" and \"grx\".\n\t * When 'insertmode' is set only CTRL-L stops Insert mode.  Needed for\n\t * when \"count\" is non-zero.\n\t */\n\tif (cmdchar != 'r' && cmdchar != 'v')\n\t    AppendToRedobuff(p_im ? (char_u *)\"\\014\" : ESC_STR);\n\n\t/*\n\t * Repeating insert may take a long time.  Check for\n\t * interrupt now and then.\n\t */\n\tif (*count > 0)\n\t{\n\t    line_breakcheck();\n\t    if (got_int)\n\t\t*count = 0;\n\t}\n\n\tif (--*count > 0)\t// repeat what was typed\n\t{\n\t    // Vi repeats the insert without replacing characters.\n\t    if (vim_strchr(p_cpo, CPO_REPLCNT) != NULL)\n\t\tState &= ~REPLACE_FLAG;\n\n\t    (void)start_redo_ins();\n\t    if (cmdchar == 'r' || cmdchar == 'v')\n\t\tstuffRedoReadbuff(ESC_STR);\t// no ESC in redo buffer\n\t    ++RedrawingDisabled;\n\t    disabled_redraw = TRUE;\n\t    return FALSE;\t// repeat the insert\n\t}\n\tstop_insert(&curwin->w_cursor, TRUE, nomove);\n\tundisplay_dollar();\n    }\n\n    if (cmdchar != 'r' && cmdchar != 'v')\n\tins_apply_autocmds(EVENT_INSERTLEAVEPRE);\n\n    // When an autoindent was removed, curswant stays after the\n    // indent\n    if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col)\n\tcurwin->w_set_curswant = TRUE;\n\n    // Remember the last Insert position in the '^ mark.\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n\tcurbuf->b_last_insert = curwin->w_cursor;\n\n    /*\n     * The cursor should end up on the last inserted character.\n     * Don't do it for CTRL-O, unless past the end of the line.\n     */\n    if (!nomove\n\t    && (curwin->w_cursor.col != 0\n\t\t|| curwin->w_cursor.coladd > 0)\n\t    && (restart_edit == NUL\n\t\t   || (gchar_cursor() == NUL && !VIsual_active))\n#ifdef FEAT_RIGHTLEFT\n\t    && !revins_on\n#endif\n\t\t\t\t      )\n    {\n\tif (curwin->w_cursor.coladd > 0 || get_ve_flags() == VE_ALL)\n\t{\n\t    oneleft();\n\t    if (restart_edit != NUL)\n\t\t++curwin->w_cursor.coladd;\n\t}\n\telse\n\t{\n\t    --curwin->w_cursor.col;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t}\n    }\n\n#ifdef HAVE_INPUT_METHOD\n    // Disable IM to allow typing English directly for Normal mode commands.\n    // When \":lmap\" is enabled don't change 'iminsert' (IM can be enabled as\n    // well).\n    if (!(State & MODE_LANGMAP))\n\tim_save_status(&curbuf->b_p_iminsert);\n    im_set_active(FALSE);\n#endif\n\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    if (!p_ek)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tch_log_output = TRUE;\n#endif\n\t// Re-enable bracketed paste mode.\n\tout_str(T_BE);\n\n\t// Re-enable modifyOtherKeys.\n\tout_str(T_CTI);\n    }\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"i\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // When recording or for CTRL-O, need to display the new mode.\n    // Otherwise remove the mode message.\n    if (reg_recording != 0 || restart_edit != NUL)\n\tshowmode();\n    else if (p_smd && (got_int || !skip_showmode()))\n\tmsg(\"\");\n\n    return TRUE;\t    // exit Insert mode\n}\n\n#ifdef FEAT_RIGHTLEFT\n/*\n * Toggle language: hkmap and revins_on.\n * Move to end of reverse inserted text.\n */\n    static void\nins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    // be consistent!\n    showmode();\n}\n#endif\n\n/*\n * If 'keymodel' contains \"startsel\", may start selection.\n * Returns TRUE when a CTRL-O and other keys stuffed.\n */\n    static int\nins_start_select(int c)\n{\n    if (km_startsel)\n\tswitch (c)\n\t{\n\t    case K_KHOME:\n\t    case K_KEND:\n\t    case K_PAGEUP:\n\t    case K_KPAGEUP:\n\t    case K_PAGEDOWN:\n\t    case K_KPAGEDOWN:\n# ifdef MACOS_X\n\t    case K_LEFT:\n\t    case K_RIGHT:\n\t    case K_UP:\n\t    case K_DOWN:\n\t    case K_END:\n\t    case K_HOME:\n# endif\n\t\tif (!(mod_mask & MOD_MASK_SHIFT))\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case K_S_LEFT:\n\t    case K_S_RIGHT:\n\t    case K_S_UP:\n\t    case K_S_DOWN:\n\t    case K_S_END:\n\t    case K_S_HOME:\n\t\t// Start selection right away, the cursor can move with\n\t\t// CTRL-O when beyond the end of the line.\n\t\tstart_selection();\n\n\t\t// Execute the key in (insert) Select mode.\n\t\tstuffcharReadbuff(Ctrl_O);\n\t\tif (mod_mask)\n\t\t{\n\t\t    char_u\t    buf[4];\n\n\t\t    buf[0] = K_SPECIAL;\n\t\t    buf[1] = KS_MODIFIER;\n\t\t    buf[2] = mod_mask;\n\t\t    buf[3] = NUL;\n\t\t    stuffReadbuff(buf);\n\t\t}\n\t\tstuffcharReadbuff(c);\n\t\treturn TRUE;\n\t}\n    return FALSE;\n}\n\n/*\n * <Insert> key in Insert mode: toggle insert/replace mode.\n */\n    static void\nins_insert(int replaceState)\n{\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_INSERTMODE,\n\t\t   (char_u *)((State & REPLACE_FLAG) ? \"i\"\n\t\t\t    : replaceState == MODE_VREPLACE ? \"v\" : \"r\"), 1);\n#endif\n    ins_apply_autocmds(EVENT_INSERTCHANGE);\n    if (State & REPLACE_FLAG)\n\tState = MODE_INSERT | (State & MODE_LANGMAP);\n    else\n\tState = replaceState | (State & MODE_LANGMAP);\n    may_trigger_modechanged();\n    AppendCharToRedobuff(K_INS);\n    showmode();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Pressed CTRL-O in Insert mode.\n */\n    static void\nins_ctrl_o(void)\n{\n    if (State & VREPLACE_FLAG)\n\trestart_edit = 'V';\n    else if (State & REPLACE_FLAG)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'I';\n    if (virtual_active())\n\tins_at_eol = FALSE;\t// cursor always keeps its column\n    else\n\tins_at_eol = (gchar_cursor() == NUL);\n}\n\n/*\n * If the cursor is on an indent, ^T/^D insert/delete one\n * shiftwidth.\tOtherwise ^T/^D behave like a \"<<\" or \">>\".\n * Always round the indent to 'shiftwidth', this is compatible\n * with vi.  But vi only supports ^T and ^D after an\n * autoindent, we support it everywhere.\n */\n    static void\nins_shift(int c, int lastc)\n{\n    if (stop_arrow() == FAIL)\n\treturn;\n    AppendCharToRedobuff(c);\n\n    /*\n     * 0^D and ^^D: remove all indent.\n     */\n    if (c == Ctrl_D && (lastc == '0' || lastc == '^')\n\t\t\t\t\t\t  && curwin->w_cursor.col > 0)\n    {\n\t--curwin->w_cursor.col;\n\t(void)del_char(FALSE);\t\t// delete the '^' or '0'\n\t// In Replace mode, restore the characters that '^' or '0' replaced.\n\tif (State & REPLACE_FLAG)\n\t    replace_pop_ins();\n\tif (lastc == '^')\n\t    old_indent = get_indent();\t// remember curr. indent\n\tchange_indent(INDENT_SET, 0, TRUE, 0, TRUE);\n    }\n    else\n\tchange_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);\n\n    if (did_ai && *skipwhite(ml_get_curline()) != NUL)\n\tdid_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n#ifdef FEAT_CINDENT\n    can_cindent = FALSE;\t// no cindenting after ^D or ^T\n#endif\n}\n\n    static void\nins_del(void)\n{\n    int\t    temp;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (gchar_cursor() == NUL)\t\t// delete newline\n    {\n\ttemp = curwin->w_cursor.col;\n\tif (!can_bs(BS_EOL)\t\t// only if \"eol\" included\n\t\t|| do_join(2, FALSE, TRUE, FALSE, FALSE) == FAIL)\n\t    vim_beep(BO_BS);\n\telse\n\t{\n\t    curwin->w_cursor.col = temp;\n\t    // Adjust orig_line_count in case more lines have been deleted than\n\t    // have been added. That makes sure, that open_line() later\n\t    // can access all buffer lines correctly\n\t    if (State & VREPLACE_FLAG &&\n\t\t    orig_line_count > curbuf->b_ml.ml_line_count)\n\t\torig_line_count = curbuf->b_ml.ml_line_count;\n\t}\n    }\n    else if (del_char(FALSE) == FAIL)  // delete char under cursor\n\tvim_beep(BO_BS);\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    AppendCharToRedobuff(K_DEL);\n}\n\n/*\n * Delete one character for ins_bs().\n */\n    static void\nins_bs_one(colnr_T *vcolp)\n{\n    dec_cursor();\n    getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);\n    if (State & REPLACE_FLAG)\n    {\n\t// Don't delete characters before the insert point when in\n\t// Replace mode\n\tif (curwin->w_cursor.lnum != Insstart.lnum\n\t\t|| curwin->w_cursor.col >= Insstart.col)\n\t    replace_do_bs(-1);\n    }\n    else\n\t(void)del_char(FALSE);\n}\n\n/*\n * Handle Backspace, delete-word and delete-line in Insert mode.\n * Return TRUE when backspace was actually used.\n */\n    static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    int\t\tcall_fix_indent = FALSE;\n#endif\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n#ifdef FEAT_CINDENT\n    if (in_indent)\n\tcan_cindent = FALSE;\n#endif\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai\n#ifdef FEAT_CINDENT\n\t\t    || cindent_on()\n#endif\n\t\t   )\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n#endif\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (call_fix_indent)\n\tfix_indent();\n#endif\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}\n\n/*\n * Handle receiving P_PS: start paste mode.  Inserts the following text up to\n * P_PE literally.\n * When \"drop\" is TRUE then consume the text and drop it.\n */\n    int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value_give_err((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value_give_err((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n    static void\nins_tabline(int c)\n{\n    // We will be leaving the current window, unless closing another tab.\n    if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE\n\t\t|| (current_tab != 0 && current_tab != tabpage_index(curtab)))\n    {\n\tundisplay_dollar();\n\tstart_arrow(&curwin->w_cursor);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n\n    if (c == K_TABLINE)\n\tgoto_tabpage(current_tab);\n    else\n    {\n\thandle_tabmenu();\n\tredraw_statuslines();\t// will redraw the tabline when needed\n    }\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    void\nins_scroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_scroll())\n    {\n\tstart_arrow(&tpos);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n}\n\n    void\nins_horscroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_horiz_scroll(scrollbar_value, FALSE))\n    {\n\tstart_arrow(&tpos);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n}\n#endif\n\n    static void\nins_left(void)\n{\n    pos_T\ttpos;\n    int\t\tend_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (oneleft() == OK)\n    {\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t// Only call start_arrow() when not busy with preediting, it will\n\t// break undo.  K_LEFT is inserted in im_correct_cursor().\n\tif (p_imst == IM_OVER_THE_SPOT || !im_is_preediting())\n#endif\n\t{\n\t    start_arrow_with_change(&tpos, end_change);\n\t    if (!end_change)\n\t\tAppendCharToRedobuff(K_LEFT);\n\t}\n#ifdef FEAT_RIGHTLEFT\n\t// If exit reversed string, position is fixed\n\tif (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol)\n\t    revins_legal++;\n\trevins_chars++;\n#endif\n    }\n\n    /*\n     * if 'whichwrap' set for cursor in insert mode may go to\n     * previous line\n     */\n    else if (vim_strchr(p_ww, '[') != NULL && curwin->w_cursor.lnum > 1)\n    {\n\t// always break undo when moving upwards/downwards, else undo may break\n\tstart_arrow(&tpos);\n\t--(curwin->w_cursor.lnum);\n\tcoladvance((colnr_T)MAXCOL);\n\tcurwin->w_set_curswant = TRUE;\t// so we stay at the end\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_home(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_HOME)\n\tcurwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    start_arrow(&tpos);\n}\n\n    static void\nins_end(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_END)\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance((colnr_T)MAXCOL);\n    curwin->w_curswant = MAXCOL;\n\n    start_arrow(&tpos);\n}\n\n    static void\nins_s_left()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum > 1 || curwin->w_cursor.col > 0)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_LEFT);\n\t(void)bck_word(1L, FALSE, FALSE);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_right(void)\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (gchar_cursor() != NUL || virtual_active())\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_RIGHT);\n\tcurwin->w_set_curswant = TRUE;\n\tif (virtual_active())\n\t    oneright();\n\telse\n\t{\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t\t++curwin->w_cursor.col;\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\trevins_legal++;\n\tif (revins_chars)\n\t    revins_chars--;\n#endif\n    }\n    // if 'whichwrap' set for cursor in insert mode, may move the\n    // cursor to the next line\n    else if (vim_strchr(p_ww, ']') != NULL\n\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n    {\n\tstart_arrow(&curwin->w_cursor);\n\tcurwin->w_set_curswant = TRUE;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_s_right()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count\n\t    || gchar_cursor() != NUL)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_RIGHT);\n\t(void)fwd_word(1L, FALSE, 0);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_up(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_up(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pageup(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(-1);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(BACKWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_down(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_down(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pagedown(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageDown>: tab page forward\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(0);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(FORWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n#ifdef FEAT_DND\n    static void\nins_drop(void)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Handle TAB in Insert or Replace mode.\n * Return TRUE when the TAB needs to be inserted like a normal character.\n */\n    static int\nins_tab(void)\n{\n    int\t\tind;\n    int\t\ti;\n    int\t\ttemp;\n\n    if (Insstart_blank_vcol == MAXCOL && curwin->w_cursor.lnum == Insstart.lnum)\n\tInsstart_blank_vcol = get_nolist_virtcol();\n    if (echeck_abbr(TAB + ABBR_OFF))\n\treturn FALSE;\n\n    ind = inindent(0);\n#ifdef FEAT_CINDENT\n    if (ind)\n\tcan_cindent = FALSE;\n#endif\n\n    /*\n     * When nothing special, insert TAB like a normal character.\n     */\n    if (!curbuf->b_p_et\n#ifdef FEAT_VARTABS\n\t    && !(p_sta && ind\n\t\t// These five lines mean 'tabstop' != 'shiftwidth'\n\t\t&& ((tabstop_count(curbuf->b_p_vts_array) > 1)\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 1\n\t\t\t&& tabstop_first(curbuf->b_p_vts_array)\n\t\t\t\t\t\t       != get_sw_value(curbuf))\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 0\n\t\t\t&& curbuf->b_p_ts != get_sw_value(curbuf))))\n\t    && tabstop_count(curbuf->b_p_vsts_array) == 0\n#else\n\t    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))\n#endif\n\t    && get_sts_value() == 0)\n\treturn TRUE;\n\n    if (stop_arrow() == FAIL)\n\treturn TRUE;\n\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    AppendToRedobuff((char_u *)\"\\t\");\n\n#ifdef FEAT_VARTABS\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n    {\n\ttemp = (int)get_sw_value(curbuf);\n\ttemp -= get_nolist_virtcol() % temp;\n    }\n    else if (tabstop_count(curbuf->b_p_vsts_array) > 0 || curbuf->b_p_sts != 0)\n\t\t\t\t// use 'softtabstop' when set\n\ttemp = tabstop_padding(get_nolist_virtcol(), get_sts_value(),\n\t\t\t\t\t\t     curbuf->b_p_vsts_array);\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = tabstop_padding(get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t     curbuf->b_p_vts_array);\n#else\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n\ttemp = (int)get_sw_value(curbuf);\n    else if (curbuf->b_p_sts != 0) // use 'softtabstop' when set\n\ttemp = (int)get_sts_value();\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = (int)curbuf->b_p_ts;\n    temp -= get_nolist_virtcol() % temp;\n#endif\n\n    /*\n     * Insert the first space with ins_char().\tIt will delete one char in\n     * replace mode.  Insert the rest with ins_str(); it will not delete any\n     * chars.  For MODE_VREPLACE state, we use ins_char() for all characters.\n     */\n    ins_char(' ');\n    while (--temp > 0)\n    {\n\tif (State & VREPLACE_FLAG)\n\t    ins_char(' ');\n\telse\n\t{\n\t    ins_str((char_u *)\" \");\n\t    if (State & REPLACE_FLAG)\t    // no char replaced\n\t\treplace_push(NUL);\n\t}\n    }\n\n    /*\n     * When 'expandtab' not set: Replace spaces by TABs where possible.\n     */\n#ifdef FEAT_VARTABS\n    if (!curbuf->b_p_et && (tabstop_count(curbuf->b_p_vsts_array) > 0\n\t\t\t    || get_sts_value() > 0\n\t\t\t    || (p_sta && ind)))\n#else\n    if (!curbuf->b_p_et && (get_sts_value() || (p_sta && ind)))\n#endif\n    {\n\tchar_u\t\t*ptr;\n\tchar_u\t\t*saved_line = NULL;\t// init for GCC\n\tpos_T\t\tpos;\n\tpos_T\t\tfpos;\n\tpos_T\t\t*cursor;\n\tcolnr_T\t\twant_vcol, vcol;\n\tint\t\tchange_col = -1;\n\tint\t\tsave_list = curwin->w_p_list;\n\n\t/*\n\t * Get the current line.  For MODE_VREPLACE state, don't make real\n\t * changes yet, just work on a copy of the line.\n\t */\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    pos = curwin->w_cursor;\n\t    cursor = &pos;\n\t    saved_line = vim_strsave(ml_get_curline());\n\t    if (saved_line == NULL)\n\t\treturn FALSE;\n\t    ptr = saved_line + pos.col;\n\t}\n\telse\n\t{\n\t    ptr = ml_get_cursor();\n\t    cursor = &curwin->w_cursor;\n\t}\n\n\t// When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.\n\tif (vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t    curwin->w_p_list = FALSE;\n\n\t// Find first white before the cursor\n\tfpos = curwin->w_cursor;\n\twhile (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))\n\t{\n\t    --fpos.col;\n\t    --ptr;\n\t}\n\n\t// In Replace mode, don't change characters before the insert point.\n\tif ((State & REPLACE_FLAG)\n\t\t&& fpos.lnum == Insstart.lnum\n\t\t&& fpos.col < Insstart.col)\n\t{\n\t    ptr += Insstart.col - fpos.col;\n\t    fpos.col = Insstart.col;\n\t}\n\n\t// compute virtual column numbers of first white and cursor\n\tgetvcol(curwin, &fpos, &vcol, NULL, NULL);\n\tgetvcol(curwin, cursor, &want_vcol, NULL, NULL);\n\n\t// Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'\n\t// and 'linebreak' adding extra virtual columns.\n\twhile (VIM_ISWHITE(*ptr))\n\t{\n\t    i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);\n\t    if (vcol + i > want_vcol)\n\t\tbreak;\n\t    if (*ptr != TAB)\n\t    {\n\t\t*ptr = TAB;\n\t\tif (change_col < 0)\n\t\t{\n\t\t    change_col = fpos.col;  // Column of first change\n\t\t    // May have to adjust Insstart\n\t\t    if (fpos.lnum == Insstart.lnum && fpos.col < Insstart.col)\n\t\t\tInsstart.col = fpos.col;\n\t\t}\n\t    }\n\t    ++fpos.col;\n\t    ++ptr;\n\t    vcol += i;\n\t}\n\n\tif (change_col >= 0)\n\t{\n\t    int repl_off = 0;\n\t    char_u *line = ptr;\n\n\t    // Skip over the spaces we need.\n\t    while (vcol < want_vcol && *ptr == ' ')\n\t    {\n\t\tvcol += lbr_chartabsize(line, ptr, vcol);\n\t\t++ptr;\n\t\t++repl_off;\n\t    }\n\t    if (vcol > want_vcol)\n\t    {\n\t\t// Must have a char with 'showbreak' just before it.\n\t\t--ptr;\n\t\t--repl_off;\n\t    }\n\t    fpos.col += repl_off;\n\n\t    // Delete following spaces.\n\t    i = cursor->col - fpos.col;\n\t    if (i > 0)\n\t    {\n#ifdef FEAT_PROP_POPUP\n\t\tif (!(State & VREPLACE_FLAG))\n\t\t{\n\t\t    char_u  *newp;\n\t\t    int\t    col;\n\n\t\t    newp = alloc(curbuf->b_ml.ml_line_len - i);\n\t\t    if (newp == NULL)\n\t\t\treturn FALSE;\n\n\t\t    col = ptr - curbuf->b_ml.ml_line_ptr;\n\t\t    if (col > 0)\n\t\t\tmch_memmove(newp, ptr - col, col);\n\t\t    mch_memmove(newp + col, ptr + i,\n\t\t\t\t\t   curbuf->b_ml.ml_line_len - col - i);\n\n\t\t    if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)\n\t\t\tvim_free(curbuf->b_ml.ml_line_ptr);\n\t\t    curbuf->b_ml.ml_line_ptr = newp;\n\t\t    curbuf->b_ml.ml_line_len -= i;\n\t\t    curbuf->b_ml.ml_flags =\n\t\t\t   (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;\n\t\t}\n\t\telse\n#endif\n\t\t    STRMOVE(ptr, ptr + i);\n\t\t// correct replace stack.\n\t\tif ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\t\t    for (temp = i; --temp >= 0; )\n\t\t\treplace_join(repl_off);\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tnetbeans_removed(curbuf, fpos.lnum, cursor->col, (long)(i + 1));\n\t\tnetbeans_inserted(curbuf, fpos.lnum, cursor->col,\n\t\t\t\t\t\t\t   (char_u *)\"\\t\", 1);\n\t    }\n#endif\n\t    cursor->col -= i;\n\n\t    /*\n\t     * In MODE_VREPLACE state, we haven't changed anything yet.  Do it\n\t     * now by backspacing over the changed spacing and then inserting\n\t     * the new spacing.\n\t     */\n\t    if (State & VREPLACE_FLAG)\n\t    {\n\t\t// Backspace from real cursor to change_col\n\t\tbackspace_until_column(change_col);\n\n\t\t// Insert each char in saved_line from changed_col to\n\t\t// ptr-cursor\n\t\tins_bytes_len(saved_line + change_col,\n\t\t\t\t\t\t    cursor->col - change_col);\n\t    }\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t    vim_free(saved_line);\n\tcurwin->w_p_list = save_list;\n    }\n\n    return FALSE;\n}\n\n/*\n * Handle CR or NL in insert mode.\n * Return FAIL when out of memory or can't undo.\n */\n    int\nins_eol(int c)\n{\n    int\t    i;\n\n    if (echeck_abbr(c + ABBR_OFF))\n\treturn OK;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n    undisplay_dollar();\n\n    /*\n     * Strange Vi behaviour: In Replace mode, typing a NL will not delete the\n     * character under the cursor.  Only push a NUL on the replace stack,\n     * nothing to put back when the NL is deleted.\n     */\n    if ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\treplace_push(NUL);\n\n    /*\n     * In MODE_VREPLACE state, a NL replaces the rest of the line, and starts\n     * replacing the next line, so we push all of the characters left on the\n     * line onto the replace stack.  This is not done here though, it is done\n     * in open_line().\n     */\n\n    // Put cursor on NUL if on the last char and coladd is 1 (happens after\n    // CTRL-O).\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance(getviscol());\n\n#ifdef FEAT_RIGHTLEFT\n    // NL in reverse insert will always start in the end of\n    // current line.\n    if (revins_on)\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n#endif\n\n    AppendToRedobuff(NL_STR);\n    i = open_line(FORWARD,\n\t    has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0, old_indent,\n\t    NULL);\n    old_indent = 0;\n#ifdef FEAT_CINDENT\n    can_cindent = TRUE;\n#endif\n#ifdef FEAT_FOLDING\n    // When inserting a line the cursor line must never be in a closed fold.\n    foldOpenCursor();\n#endif\n\n    return i;\n}\n\n#ifdef FEAT_DIGRAPHS\n/*\n * Handle digraph in insert mode.\n * Returns character still to be inserted, or NUL when nothing remaining to be\n * done.\n */\n    static int\nins_digraph(void)\n{\n    int\t    c;\n    int\t    cc;\n    int\t    did_putchar = FALSE;\n\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('?', TRUE);\n\tdid_putchar = TRUE;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_K);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // don't map the digraph chars. This also prevents the\n    // mode message to be deleted when ESC is hit\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    if (did_putchar)\n\t// when the line fits in 'columns' the '?' is at the start of the next\n\t// line and will not be removed by the redraw\n\tedit_unputchar();\n\n    if (IS_SPECIAL(c) || mod_mask)\t    // special key\n    {\n#ifdef FEAT_CMDL_INFO\n\tclear_showcmd();\n#endif\n\tinsert_special(c, TRUE, FALSE);\n\treturn NUL;\n    }\n    if (c != ESC)\n    {\n\tdid_putchar = FALSE;\n\tif (redrawing() && !char_avail())\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\n\t    if (char2cells(c) == 1)\n\t    {\n\t\tins_redraw(FALSE);\n\t\tedit_putchar(c, TRUE);\n\t\tdid_putchar = TRUE;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    add_to_showcmd_c(c);\n#endif\n\t}\n\t++no_mapping;\n\t++allow_keys;\n\tcc = plain_vgetc();\n\t--no_mapping;\n\t--allow_keys;\n\tif (did_putchar)\n\t    // when the line fits in 'columns' the '?' is at the start of the\n\t    // next line and will not be removed by a redraw\n\t    edit_unputchar();\n\tif (cc != ESC)\n\t{\n\t    AppendToRedobuff((char_u *)CTRL_V_STR);\n\t    c = digraph_get(c, cc, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    return c;\n\t}\n    }\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    return NUL;\n}\n#endif\n\n/*\n * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.\n * Returns the char to be inserted, or NUL if none found.\n */\n    int\nins_copychar(linenr_T lnum)\n{\n    int\t    c;\n    int\t    temp;\n    char_u  *ptr, *prev_ptr;\n    char_u  *line;\n\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)\n    {\n\tvim_beep(BO_COPY);\n\treturn NUL;\n    }\n\n    // try to advance to the cursor column\n    temp = 0;\n    line = ptr = ml_get(lnum);\n    prev_ptr = ptr;\n    validate_virtcol();\n    while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)\n    {\n\tprev_ptr = ptr;\n\ttemp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);\n    }\n    if ((colnr_T)temp > curwin->w_virtcol)\n\tptr = prev_ptr;\n\n    c = (*mb_ptr2char)(ptr);\n    if (c == NUL)\n\tvim_beep(BO_COPY);\n    return c;\n}\n\n/*\n * CTRL-Y or CTRL-E typed in Insert mode.\n */\n    static int\nins_ctrl_ey(int tc)\n{\n    int\t    c = tc;\n\n    if (ctrl_x_mode_scroll())\n    {\n\tif (c == Ctrl_Y)\n\t    scrolldown_clamp();\n\telse\n\t    scrollup_clamp();\n\tredraw_later(VALID);\n    }\n    else\n    {\n\tc = ins_copychar(curwin->w_cursor.lnum + (c == Ctrl_Y ? -1 : 1));\n\tif (c != NUL)\n\t{\n\t    long\ttw_save;\n\n\t    // The character must be taken literally, insert like it\n\t    // was typed after a CTRL-V, and pretend 'textwidth'\n\t    // wasn't set.  Digits, 'o' and 'x' are special after a\n\t    // CTRL-V, don't use it for these.\n\t    if (c < 256 && !isalnum(c))\n\t\tAppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\t    tw_save = curbuf->b_p_tw;\n\t    curbuf->b_p_tw = -1;\n\t    insert_special(c, TRUE, FALSE);\n\t    curbuf->b_p_tw = tw_save;\n#ifdef FEAT_RIGHTLEFT\n\t    revins_chars++;\n\t    revins_legal++;\n#endif\n\t    c = Ctrl_V;\t// pretend CTRL-V is last character\n\t    auto_format(FALSE, TRUE);\n\t}\n    }\n    return c;\n}\n\n/*\n * Get the value that w_virtcol would have when 'list' is off.\n * Unless 'cpo' contains the 'L' flag.\n */\n    colnr_T\nget_nolist_virtcol(void)\n{\n    // check validity of cursor in current buffer\n    if (curwin->w_buffer == NULL\n\t|| curwin->w_buffer->b_ml.ml_mfp == NULL\n\t|| curwin->w_cursor.lnum > curwin->w_buffer->b_ml.ml_line_count)\n\treturn 0;\n    if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\treturn getvcol_nolist(&curwin->w_cursor);\n    validate_virtcol();\n    return curwin->w_virtcol;\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Handle the InsertCharPre autocommand.\n * \"c\" is the character that was typed.\n * Return a pointer to allocated memory with the replacement string.\n * Return NULL to continue inserting \"c\".\n */\n    static char_u *\ndo_insert_char_pre(int c)\n{\n    char_u\t*res;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tsave_State = State;\n\n    // Return quickly when there is nothing to do.\n    if (!has_insertcharpre())\n\treturn NULL;\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n\n    // Lock the text to avoid weird things from happening.\n    ++textwinlock;\n    set_vim_var_string(VV_CHAR, buf, -1);  // set v:char\n\n    res = NULL;\n    if (ins_apply_autocmds(EVENT_INSERTCHARPRE))\n    {\n\t// Get the value of v:char.  It may be empty or more than one\n\t// character.  Only use it when changed, otherwise continue with the\n\t// original character to avoid breaking autoindent.\n\tif (STRCMP(buf, get_vim_var_str(VV_CHAR)) != 0)\n\t    res = vim_strsave(get_vim_var_str(VV_CHAR));\n    }\n\n    set_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n    --textwinlock;\n\n    // Restore the State, it may have been changed.\n    State = save_State;\n\n    return res;\n}\n#endif\n\n#if defined(FEAT_CINDENT) || defined(PROTO)\n    int\nget_can_cindent(void)\n{\n    return can_cindent;\n}\n\n    void\nset_can_cindent(int val)\n{\n    can_cindent = val;\n}\n#endif\n\n/*\n * Trigger \"event\" and take care of fixing undo.\n */\n    int\nins_apply_autocmds(event_T event)\n{\n    varnumber_T\ttick = CHANGEDTICK(curbuf);\n    int r;\n\n    r = apply_autocmds(event, NULL, NULL, FALSE, curbuf);\n\n    // If u_savesub() was called then we are not prepared to start\n    // a new line.  Call u_save() with no contents to fix that.\n    // Except when leaving Insert mode.\n    if (event != EVENT_INSERTLEAVE && tick != CHANGEDTICK(curbuf))\n\tu_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n\n    return r;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * misc2.c: Various functions.\n */\n#include \"vim.h\"\n\nstatic char_u\t*username = NULL; // cached result of mch_get_user_name()\n\nstatic int coladvance2(pos_T *pos, int addspaces, int finetune, colnr_T wcol);\n\n/*\n * Return TRUE if in the current mode we need to use virtual.\n */\n    int\nvirtual_active(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    // While an operator is being executed we return \"virtual_op\", because\n    // VIsual_active has already been reset, thus we can't check for \"block\"\n    // being used.\n    if (virtual_op != MAYBE)\n\treturn virtual_op;\n    return (cur_ve_flags == VE_ALL\n\t    || ((cur_ve_flags & VE_BLOCK) && VIsual_active\n\t\t\t\t\t\t      && VIsual_mode == Ctrl_V)\n\t    || ((cur_ve_flags & VE_INSERT) && (State & MODE_INSERT)));\n}\n\n/*\n * Get the screen position of the cursor.\n */\n    int\ngetviscol(void)\n{\n    colnr_T\tx;\n\n    getvvcol(curwin, &curwin->w_cursor, &x, NULL, NULL);\n    return (int)x;\n}\n\n/*\n * Go to column \"wcol\", and add/insert white space as necessary to get the\n * cursor in that column.\n * The caller must have saved the cursor line for undo!\n */\n    int\ncoladvance_force(colnr_T wcol)\n{\n    int rc = coladvance2(&curwin->w_cursor, TRUE, FALSE, wcol);\n\n    if (wcol == MAXCOL)\n\tcurwin->w_valid &= ~VALID_VIRTCOL;\n    else\n    {\n\t// Virtcol is valid\n\tcurwin->w_valid |= VALID_VIRTCOL;\n\tcurwin->w_virtcol = wcol;\n    }\n    return rc;\n}\n\n/*\n * Get the screen position of character col with a coladd in the cursor line.\n */\n    int\ngetviscol2(colnr_T col, colnr_T coladd UNUSED)\n{\n    colnr_T\tx;\n    pos_T\tpos;\n\n    pos.lnum = curwin->w_cursor.lnum;\n    pos.col = col;\n    pos.coladd = coladd;\n    getvvcol(curwin, &pos, &x, NULL, NULL);\n    return (int)x;\n}\n\n/*\n * Try to advance the Cursor to the specified screen column.\n * If virtual editing: fine tune the cursor position.\n * Note that all virtual positions off the end of a line should share\n * a curwin->w_cursor.col value (n.b. this is equal to STRLEN(line)),\n * beginning at coladd 0.\n *\n * return OK if desired column is reached, FAIL if not\n */\n    int\ncoladvance(colnr_T wcol)\n{\n    int rc = getvpos(&curwin->w_cursor, wcol);\n\n    if (wcol == MAXCOL || rc == FAIL)\n\tcurwin->w_valid &= ~VALID_VIRTCOL;\n    else if (*ml_get_cursor() != TAB)\n    {\n\t// Virtcol is valid when not on a TAB\n\tcurwin->w_valid |= VALID_VIRTCOL;\n\tcurwin->w_virtcol = wcol;\n    }\n    return rc;\n}\n\n/*\n * Return in \"pos\" the position of the cursor advanced to screen column \"wcol\".\n * return OK if desired column is reached, FAIL if not\n */\n    int\ngetvpos(pos_T *pos, colnr_T wcol)\n{\n    return coladvance2(pos, FALSE, virtual_active(), wcol);\n}\n\n    static int\ncoladvance2(\n    pos_T\t*pos,\n    int\t\taddspaces,\t// change the text to achieve our goal?\n    int\t\tfinetune,\t// change char offset for the exact column\n    colnr_T\twcol_arg)\t// column to move to (can be negative)\n{\n    colnr_T\twcol = wcol_arg;\n    int\t\tidx;\n    char_u\t*ptr;\n    char_u\t*line;\n    colnr_T\tcol = 0;\n    int\t\tcsize = 0;\n    int\t\tone_more;\n#ifdef FEAT_LINEBREAK\n    int\t\thead = 0;\n#endif\n\n    one_more = (State & MODE_INSERT)\n\t\t    || restart_edit != NUL\n\t\t    || (VIsual_active && *p_sel != 'o')\n\t\t    || ((get_ve_flags() & VE_ONEMORE) && wcol < MAXCOL);\n    line = ml_get_buf(curbuf, pos->lnum, FALSE);\n\n    if (wcol >= MAXCOL)\n    {\n\t    idx = (int)STRLEN(line) - 1 + one_more;\n\t    col = wcol;\n\n\t    if ((addspaces || finetune) && !VIsual_active)\n\t    {\n\t\tcurwin->w_curswant = linetabsize(line) + one_more;\n\t\tif (curwin->w_curswant > 0)\n\t\t    --curwin->w_curswant;\n\t    }\n    }\n    else\n    {\n\tint width = curwin->w_width - win_col_off(curwin);\n\n\tif (finetune\n\t\t&& curwin->w_p_wrap\n\t\t&& curwin->w_width != 0\n\t\t&& wcol >= (colnr_T)width\n\t\t&& width > 0)\n\t{\n\t    csize = linetabsize(line);\n\t    if (csize > 0)\n\t\tcsize--;\n\n\t    if (wcol / width > (colnr_T)csize / width\n\t\t    && ((State & MODE_INSERT) == 0 || (int)wcol > csize + 1))\n\t    {\n\t\t// In case of line wrapping don't move the cursor beyond the\n\t\t// right screen edge.  In Insert mode allow going just beyond\n\t\t// the last character (like what happens when typing and\n\t\t// reaching the right window edge).\n\t\twcol = (csize / width + 1) * width - 1;\n\t    }\n\t}\n\n\tptr = line;\n\twhile (col <= wcol && *ptr != NUL)\n\t{\n\t    // Count a tab for what it's worth (if list mode not on)\n#ifdef FEAT_LINEBREAK\n\t    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);\n\t    MB_PTR_ADV(ptr);\n#else\n\t    csize = lbr_chartabsize_adv(line, &ptr, col);\n#endif\n\t    col += csize;\n\t}\n\tidx = (int)(ptr - line);\n\t/*\n\t * Handle all the special cases.  The virtual_active() check\n\t * is needed to ensure that a virtual position off the end of\n\t * a line has the correct indexing.  The one_more comparison\n\t * replaces an explicit add of one_more later on.\n\t */\n\tif (col > wcol || (!virtual_active() && one_more == 0))\n\t{\n\t    idx -= 1;\n# ifdef FEAT_LINEBREAK\n\t    // Don't count the chars from 'showbreak'.\n\t    csize -= head;\n# endif\n\t    col -= csize;\n\t}\n\n\tif (virtual_active()\n\t\t&& addspaces\n\t\t&& wcol >= 0\n\t\t&& ((col != wcol && col != wcol + 1) || csize > 1))\n\t{\n\t    // 'virtualedit' is set: The difference between wcol and col is\n\t    // filled with spaces.\n\n\t    if (line[idx] == NUL)\n\t    {\n\t\t// Append spaces\n\t\tint\tcorrect = wcol - col;\n\t\tchar_u\t*newline = alloc(idx + correct + 1);\n\t\tint\tt;\n\n\t\tif (newline == NULL)\n\t\t    return FAIL;\n\n\t\tfor (t = 0; t < idx; ++t)\n\t\t    newline[t] = line[t];\n\n\t\tfor (t = 0; t < correct; ++t)\n\t\t    newline[t + idx] = ' ';\n\n\t\tnewline[idx + correct] = NUL;\n\n\t\tml_replace(pos->lnum, newline, FALSE);\n\t\tchanged_bytes(pos->lnum, (colnr_T)idx);\n\t\tidx += correct;\n\t\tcol = wcol;\n\t    }\n\t    else\n\t    {\n\t\t// Break a tab\n\t\tint\tlinelen = (int)STRLEN(line);\n\t\tint\tcorrect = wcol - col - csize + 1; // negative!!\n\t\tchar_u\t*newline;\n\t\tint\tt, s = 0;\n\t\tint\tv;\n\n\t\tif (-correct > csize)\n\t\t    return FAIL;\n\n\t\tnewline = alloc(linelen + csize);\n\t\tif (newline == NULL)\n\t\t    return FAIL;\n\n\t\tfor (t = 0; t < linelen; t++)\n\t\t{\n\t\t    if (t != idx)\n\t\t\tnewline[s++] = line[t];\n\t\t    else\n\t\t\tfor (v = 0; v < csize; v++)\n\t\t\t    newline[s++] = ' ';\n\t\t}\n\n\t\tnewline[linelen + csize - 1] = NUL;\n\n\t\tml_replace(pos->lnum, newline, FALSE);\n\t\tchanged_bytes(pos->lnum, idx);\n\t\tidx += (csize - 1 + correct);\n\t\tcol += correct;\n\t    }\n\t}\n    }\n\n    if (idx < 0)\n\tpos->col = 0;\n    else\n\tpos->col = idx;\n\n    pos->coladd = 0;\n\n    if (finetune)\n    {\n\tif (wcol == MAXCOL)\n\t{\n\t    // The width of the last character is used to set coladd.\n\t    if (!one_more)\n\t    {\n\t\tcolnr_T\t    scol, ecol;\n\n\t\tgetvcol(curwin, pos, &scol, NULL, &ecol);\n\t\tpos->coladd = ecol - scol;\n\t    }\n\t}\n\telse\n\t{\n\t    int b = (int)wcol - (int)col;\n\n\t    // The difference between wcol and col is used to set coladd.\n\t    if (b > 0 && b < (MAXCOL - 2 * curwin->w_width))\n\t\tpos->coladd = b;\n\n\t    col += b;\n\t}\n    }\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curbuf, pos);\n\n    if (wcol < 0 || col < wcol)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Increment the cursor position.  See inc() for return values.\n */\n    int\ninc_cursor(void)\n{\n    return inc(&curwin->w_cursor);\n}\n\n/*\n * Increment the line pointer \"lp\" crossing line boundaries as necessary.\n * Return 1 when going to the next line.\n * Return 2 when moving forward onto a NUL at the end of the line).\n * Return -1 when at the end of file.\n * Return 0 otherwise.\n */\n    int\ninc(pos_T *lp)\n{\n    char_u  *p;\n\n    // when searching position may be set to end of a line\n    if (lp->col != MAXCOL)\n    {\n\tp = ml_get_pos(lp);\n\tif (*p != NUL)\t// still within line, move to next char (may be NUL)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tint l = (*mb_ptr2len)(p);\n\n\t\tlp->col += l;\n\t\treturn ((p[l] != NUL) ? 0 : 2);\n\t    }\n\t    lp->col++;\n\t    lp->coladd = 0;\n\t    return ((p[1] != NUL) ? 0 : 2);\n\t}\n    }\n    if (lp->lnum != curbuf->b_ml.ml_line_count)     // there is a next line\n    {\n\tlp->col = 0;\n\tlp->lnum++;\n\tlp->coladd = 0;\n\treturn 1;\n    }\n    return -1;\n}\n\n/*\n * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines\n */\n    int\nincl(pos_T *lp)\n{\n    int\t    r;\n\n    if ((r = inc(lp)) >= 1 && lp->col)\n\tr = inc(lp);\n    return r;\n}\n\n/*\n * dec(p)\n *\n * Decrement the line pointer 'p' crossing line boundaries as necessary.\n * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.\n */\n    int\ndec_cursor(void)\n{\n    return dec(&curwin->w_cursor);\n}\n\n    int\ndec(pos_T *lp)\n{\n    char_u\t*p;\n\n    lp->coladd = 0;\n    if (lp->col == MAXCOL)\n    {\n\t// past end of line\n\tp = ml_get(lp->lnum);\n\tlp->col = (colnr_T)STRLEN(p);\n\tif (has_mbyte)\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\treturn 0;\n    }\n\n    if (lp->col > 0)\n    {\n\t// still within line\n\tlp->col--;\n\tif (has_mbyte)\n\t{\n\t    p = ml_get(lp->lnum);\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t}\n\treturn 0;\n    }\n\n    if (lp->lnum > 1)\n    {\n\t// there is a prior line\n\tlp->lnum--;\n\tp = ml_get(lp->lnum);\n\tlp->col = (colnr_T)STRLEN(p);\n\tif (has_mbyte)\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\treturn 1;\n    }\n\n    // at start of file\n    return -1;\n}\n\n/*\n * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines\n */\n    int\ndecl(pos_T *lp)\n{\n    int\t    r;\n\n    if ((r = dec(lp)) == 1 && lp->col)\n\tr = dec(lp);\n    return r;\n}\n\n/*\n * Get the line number relative to the current cursor position, i.e. the\n * difference between line number and cursor position. Only look for lines that\n * can be visible, folded lines don't count.\n */\n    linenr_T\nget_cursor_rel_lnum(\n    win_T\t*wp,\n    linenr_T\tlnum)\t\t    // line number to get the result for\n{\n    linenr_T\tcursor = wp->w_cursor.lnum;\n    linenr_T\tretval = 0;\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(wp))\n    {\n\tif (lnum > cursor)\n\t{\n\t    while (lnum > cursor)\n\t    {\n\t\t(void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\t// if lnum and cursor are in the same fold,\n\t\t// now lnum <= cursor\n\t\tif (lnum > cursor)\n\t\t    retval++;\n\t\tlnum--;\n\t    }\n\t}\n\telse if (lnum < cursor)\n\t{\n\t    while (lnum < cursor)\n\t    {\n\t\t(void)hasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n\t\t// if lnum and cursor are in the same fold,\n\t\t// now lnum >= cursor\n\t\tif (lnum < cursor)\n\t\t    retval--;\n\t\tlnum++;\n\t    }\n\t}\n\t// else if (lnum == cursor)\n\t//     retval = 0;\n    }\n    else\n#endif\n\tretval = lnum - cursor;\n\n    return retval;\n}\n\n/*\n * Make sure \"pos.lnum\" and \"pos.col\" are valid in \"buf\".\n * This allows for the col to be on the NUL byte.\n */\n    void\ncheck_pos(buf_T *buf, pos_T *pos)\n{\n    char_u *line;\n    colnr_T len;\n\n    if (pos->lnum > buf->b_ml.ml_line_count)\n\tpos->lnum = buf->b_ml.ml_line_count;\n\n    if (pos->col > 0)\n    {\n\tline = ml_get_buf(buf, pos->lnum, FALSE);\n\tlen = (colnr_T)STRLEN(line);\n\tif (pos->col > len)\n\t    pos->col = len;\n    }\n}\n\n/*\n * Make sure curwin->w_cursor.lnum is valid.\n */\n    void\ncheck_cursor_lnum(void)\n{\n    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n    {\n#ifdef FEAT_FOLDING\n\t// If there is a closed fold at the end of the file, put the cursor in\n\t// its first line.  Otherwise in the last line.\n\tif (!hasFolding(curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL))\n#endif\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n    if (curwin->w_cursor.lnum <= 0)\n\tcurwin->w_cursor.lnum = 1;\n}\n\n/*\n * Make sure curwin->w_cursor.col is valid.\n */\n    void\ncheck_cursor_col(void)\n{\n    check_cursor_col_win(curwin);\n}\n\n/*\n * Make sure win->w_cursor.col is valid.\n */\n    void\ncheck_cursor_col_win(win_T *win)\n{\n    colnr_T      len;\n    colnr_T      oldcol = win->w_cursor.col;\n    colnr_T      oldcoladd = win->w_cursor.col + win->w_cursor.coladd;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    len = (colnr_T)STRLEN(ml_get_buf(win->w_buffer, win->w_cursor.lnum, FALSE));\n    if (len == 0)\n\twin->w_cursor.col = 0;\n    else if (win->w_cursor.col >= len)\n    {\n\t// Allow cursor past end-of-line when:\n\t// - in Insert mode or restarting Insert mode\n\t// - in Visual mode and 'selection' isn't \"old\"\n\t// - 'virtualedit' is set\n\tif ((State & MODE_INSERT) || restart_edit\n\t\t|| (VIsual_active && *p_sel != 'o')\n\t\t|| (cur_ve_flags & VE_ONEMORE)\n\t\t|| virtual_active())\n\t    win->w_cursor.col = len;\n\telse\n\t{\n\t    win->w_cursor.col = len - 1;\n\t    // Move the cursor to the head byte.\n\t    if (has_mbyte)\n\t\tmb_adjustpos(win->w_buffer, &win->w_cursor);\n\t}\n    }\n    else if (win->w_cursor.col < 0)\n\twin->w_cursor.col = 0;\n\n    // If virtual editing is on, we can leave the cursor on the old position,\n    // only we must set it to virtual.  But don't do it when at the end of the\n    // line.\n    if (oldcol == MAXCOL)\n\twin->w_cursor.coladd = 0;\n    else if (cur_ve_flags == VE_ALL)\n    {\n\tif (oldcoladd > win->w_cursor.col)\n\t{\n\t    win->w_cursor.coladd = oldcoladd - win->w_cursor.col;\n\n\t    // Make sure that coladd is not more than the char width.\n\t    // Not for the last character, coladd is then used when the cursor\n\t    // is actually after the last character.\n\t    if (win->w_cursor.col + 1 < len)\n\t    {\n\t\tint cs, ce;\n\n\t\tgetvcol(win, &win->w_cursor, &cs, NULL, &ce);\n\t\tif (win->w_cursor.coladd > ce - cs)\n\t\t    win->w_cursor.coladd = ce - cs;\n\t    }\n\t}\n\telse\n\t    // avoid weird number when there is a miscalculation or overflow\n\t    win->w_cursor.coladd = 0;\n    }\n}\n\n/*\n * make sure curwin->w_cursor in on a valid character\n */\n    void\ncheck_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_col();\n}\n\n#if defined(FEAT_TEXTOBJ) || defined(PROTO)\n/*\n * Make sure curwin->w_cursor is not on the NUL at the end of the line.\n * Allow it when in Visual mode and 'selection' is not \"old\".\n */\n    void\nadjust_cursor_col(void)\n{\n    if (curwin->w_cursor.col > 0\n\t    && (!VIsual_active || *p_sel == 'o')\n\t    && gchar_cursor() == NUL)\n\t--curwin->w_cursor.col;\n}\n#endif\n\n/*\n * When curwin->w_leftcol has changed, adjust the cursor position.\n * Return TRUE if the cursor was moved.\n */\n    int\nleftcol_changed(void)\n{\n    long\tlastcol;\n    colnr_T\ts, e;\n    int\t\tretval = FALSE;\n    long\tsiso = get_sidescrolloff_value();\n\n    changed_cline_bef_curs();\n    lastcol = curwin->w_leftcol + curwin->w_width - curwin_col_off() - 1;\n    validate_virtcol();\n\n    /*\n     * If the cursor is right or left of the screen, move it to last or first\n     * character.\n     */\n    if (curwin->w_virtcol > (colnr_T)(lastcol - siso))\n    {\n\tretval = TRUE;\n\tcoladvance((colnr_T)(lastcol - siso));\n    }\n    else if (curwin->w_virtcol < curwin->w_leftcol + siso)\n    {\n\tretval = TRUE;\n\t(void)coladvance((colnr_T)(curwin->w_leftcol + siso));\n    }\n\n    /*\n     * If the start of the character under the cursor is not on the screen,\n     * advance the cursor one more char.  If this fails (last char of the\n     * line) adjust the scrolling.\n     */\n    getvvcol(curwin, &curwin->w_cursor, &s, NULL, &e);\n    if (e > (colnr_T)lastcol)\n    {\n\tretval = TRUE;\n\tcoladvance(s - 1);\n    }\n    else if (s < curwin->w_leftcol)\n    {\n\tretval = TRUE;\n\tif (coladvance(e + 1) == FAIL)\t// there isn't another character\n\t{\n\t    curwin->w_leftcol = s;\t// adjust w_leftcol instead\n\t    changed_cline_bef_curs();\n\t}\n    }\n\n    if (retval)\n\tcurwin->w_set_curswant = TRUE;\n    redraw_later(NOT_VALID);\n    return retval;\n}\n\n/*\n * Isolate one part of a string option where parts are separated with\n * \"sep_chars\".\n * The part is copied into \"buf[maxlen]\".\n * \"*option\" is advanced to the next part.\n * The length is returned.\n */\n    int\ncopy_option_part(\n    char_u\t**option,\n    char_u\t*buf,\n    int\t\tmaxlen,\n    char\t*sep_chars)\n{\n    int\t    len = 0;\n    char_u  *p = *option;\n\n    // skip '.' at start of option part, for 'suffixes'\n    if (*p == '.')\n\tbuf[len++] = *p++;\n    while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL)\n    {\n\t/*\n\t * Skip backslash before a separator character and space.\n\t */\n\tif (p[0] == '\\\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL)\n\t    ++p;\n\tif (len < maxlen - 1)\n\t    buf[len++] = *p;\n\t++p;\n    }\n    buf[len] = NUL;\n\n    if (*p != NUL && *p != ',')\t// skip non-standard separator\n\t++p;\n    p = skip_to_option_part(p);\t// p points to next file name\n\n    *option = p;\n    return len;\n}\n\n#ifndef HAVE_MEMSET\n    void *\nvim_memset(void *ptr, int c, size_t size)\n{\n    char *p = ptr;\n\n    while (size-- > 0)\n\t*p++ = c;\n    return ptr;\n}\n#endif\n\n/*\n * Vim has its own isspace() function, because on some machines isspace()\n * can't handle characters above 128.\n */\n    int\nvim_isspace(int x)\n{\n    return ((x >= 9 && x <= 13) || x == ' ');\n}\n\n/************************************************************************\n * functions that use lookup tables for various things, generally to do with\n * special key codes.\n */\n\n/*\n * Some useful tables.\n */\n\nstatic struct modmasktable\n{\n    short\tmod_mask;\t// Bit-mask for particular key modifier\n    short\tmod_flag;\t// Bit(s) for particular key modifier\n    char_u\tname;\t\t// Single letter name of modifier\n} mod_mask_table[] =\n{\n    {MOD_MASK_ALT,\t\tMOD_MASK_ALT,\t\t(char_u)'M'},\n    {MOD_MASK_META,\t\tMOD_MASK_META,\t\t(char_u)'T'},\n    {MOD_MASK_CTRL,\t\tMOD_MASK_CTRL,\t\t(char_u)'C'},\n    {MOD_MASK_SHIFT,\t\tMOD_MASK_SHIFT,\t\t(char_u)'S'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_2CLICK,\t(char_u)'2'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_3CLICK,\t(char_u)'3'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_4CLICK,\t(char_u)'4'},\n#ifdef MACOS_X\n    {MOD_MASK_CMD,\t\tMOD_MASK_CMD,\t\t(char_u)'D'},\n#endif\n    // 'A' must be the last one\n    {MOD_MASK_ALT,\t\tMOD_MASK_ALT,\t\t(char_u)'A'},\n    {0, 0, NUL}\n    // NOTE: when adding an entry, update MAX_KEY_NAME_LEN!\n};\n\n/*\n * Shifted key terminal codes and their unshifted equivalent.\n * Don't add mouse codes here, they are handled separately!\n */\n#define MOD_KEYS_ENTRY_SIZE 5\n\nstatic char_u modifier_keys_table[] =\n{\n//  mod mask\t    with modifier\t\twithout modifier\n    MOD_MASK_SHIFT, '&', '9',\t\t\t'@', '1',\t// begin\n    MOD_MASK_SHIFT, '&', '0',\t\t\t'@', '2',\t// cancel\n    MOD_MASK_SHIFT, '*', '1',\t\t\t'@', '4',\t// command\n    MOD_MASK_SHIFT, '*', '2',\t\t\t'@', '5',\t// copy\n    MOD_MASK_SHIFT, '*', '3',\t\t\t'@', '6',\t// create\n    MOD_MASK_SHIFT, '*', '4',\t\t\t'k', 'D',\t// delete char\n    MOD_MASK_SHIFT, '*', '5',\t\t\t'k', 'L',\t// delete line\n    MOD_MASK_SHIFT, '*', '7',\t\t\t'@', '7',\t// end\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,\t'@', '7',\t// end\n    MOD_MASK_SHIFT, '*', '9',\t\t\t'@', '9',\t// exit\n    MOD_MASK_SHIFT, '*', '0',\t\t\t'@', '0',\t// find\n    MOD_MASK_SHIFT, '#', '1',\t\t\t'%', '1',\t// help\n    MOD_MASK_SHIFT, '#', '2',\t\t\t'k', 'h',\t// home\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,\t'k', 'h',\t// home\n    MOD_MASK_SHIFT, '#', '3',\t\t\t'k', 'I',\t// insert\n    MOD_MASK_SHIFT, '#', '4',\t\t\t'k', 'l',\t// left arrow\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,\t'k', 'l',\t// left arrow\n    MOD_MASK_SHIFT, '%', 'a',\t\t\t'%', '3',\t// message\n    MOD_MASK_SHIFT, '%', 'b',\t\t\t'%', '4',\t// move\n    MOD_MASK_SHIFT, '%', 'c',\t\t\t'%', '5',\t// next\n    MOD_MASK_SHIFT, '%', 'd',\t\t\t'%', '7',\t// options\n    MOD_MASK_SHIFT, '%', 'e',\t\t\t'%', '8',\t// previous\n    MOD_MASK_SHIFT, '%', 'f',\t\t\t'%', '9',\t// print\n    MOD_MASK_SHIFT, '%', 'g',\t\t\t'%', '0',\t// redo\n    MOD_MASK_SHIFT, '%', 'h',\t\t\t'&', '3',\t// replace\n    MOD_MASK_SHIFT, '%', 'i',\t\t\t'k', 'r',\t// right arr.\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,\t'k', 'r',\t// right arr.\n    MOD_MASK_SHIFT, '%', 'j',\t\t\t'&', '5',\t// resume\n    MOD_MASK_SHIFT, '!', '1',\t\t\t'&', '6',\t// save\n    MOD_MASK_SHIFT, '!', '2',\t\t\t'&', '7',\t// suspend\n    MOD_MASK_SHIFT, '!', '3',\t\t\t'&', '8',\t// undo\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,\t'k', 'u',\t// up arrow\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,\t'k', 'd',\t// down arrow\n\n\t\t\t\t\t\t\t\t// vt100 F1\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,\tKS_EXTRA, (int)KE_XF1,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,\tKS_EXTRA, (int)KE_XF2,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,\tKS_EXTRA, (int)KE_XF3,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,\tKS_EXTRA, (int)KE_XF4,\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,\t'k', '1',\t// F1\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,\t'k', '2',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,\t'k', '3',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,\t'k', '4',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F5,\t'k', '5',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F6,\t'k', '6',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,\t'k', '7',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,\t'k', '8',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,\t'k', '9',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,\t'k', ';',\t// F10\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,\t'F', '1',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,\t'F', '2',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F13,\t'F', '3',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F14,\t'F', '4',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F15,\t'F', '5',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F16,\t'F', '6',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F17,\t'F', '7',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F18,\t'F', '8',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F19,\t'F', '9',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F20,\t'F', 'A',\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F21,\t'F', 'B',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F22,\t'F', 'C',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F23,\t'F', 'D',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F24,\t'F', 'E',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F25,\t'F', 'F',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F26,\t'F', 'G',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F27,\t'F', 'H',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F28,\t'F', 'I',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F29,\t'F', 'J',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F30,\t'F', 'K',\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F31,\t'F', 'L',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F32,\t'F', 'M',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F33,\t'F', 'N',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F34,\t'F', 'O',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F35,\t'F', 'P',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,\t'F', 'Q',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,\t'F', 'R',\n\n\t\t\t\t\t\t\t    // TAB pseudo code\n    MOD_MASK_SHIFT, 'k', 'B',\t\t\tKS_EXTRA, (int)KE_TAB,\n\n    NUL\n};\n\nstatic struct key_name_entry\n{\n    int\t    key;\t// Special key code or ascii value\n    char_u  *name;\t// Name of key\n} key_names_table[] =\n{\n    {' ',\t\t(char_u *)\"Space\"},\n    {TAB,\t\t(char_u *)\"Tab\"},\n    {K_TAB,\t\t(char_u *)\"Tab\"},\n    {NL,\t\t(char_u *)\"NL\"},\n    {NL,\t\t(char_u *)\"NewLine\"},\t// Alternative name\n    {NL,\t\t(char_u *)\"LineFeed\"},\t// Alternative name\n    {NL,\t\t(char_u *)\"LF\"},\t// Alternative name\n    {CAR,\t\t(char_u *)\"CR\"},\n    {CAR,\t\t(char_u *)\"Return\"},\t// Alternative name\n    {CAR,\t\t(char_u *)\"Enter\"},\t// Alternative name\n    {K_BS,\t\t(char_u *)\"BS\"},\n    {K_BS,\t\t(char_u *)\"BackSpace\"},\t// Alternative name\n    {ESC,\t\t(char_u *)\"Esc\"},\n    {CSI,\t\t(char_u *)\"CSI\"},\n    {K_CSI,\t\t(char_u *)\"xCSI\"},\n    {'|',\t\t(char_u *)\"Bar\"},\n    {'\\\\',\t\t(char_u *)\"Bslash\"},\n    {K_DEL,\t\t(char_u *)\"Del\"},\n    {K_DEL,\t\t(char_u *)\"Delete\"},\t// Alternative name\n    {K_KDEL,\t\t(char_u *)\"kDel\"},\n    {K_UP,\t\t(char_u *)\"Up\"},\n    {K_DOWN,\t\t(char_u *)\"Down\"},\n    {K_LEFT,\t\t(char_u *)\"Left\"},\n    {K_RIGHT,\t\t(char_u *)\"Right\"},\n    {K_XUP,\t\t(char_u *)\"xUp\"},\n    {K_XDOWN,\t\t(char_u *)\"xDown\"},\n    {K_XLEFT,\t\t(char_u *)\"xLeft\"},\n    {K_XRIGHT,\t\t(char_u *)\"xRight\"},\n    {K_PS,\t\t(char_u *)\"PasteStart\"},\n    {K_PE,\t\t(char_u *)\"PasteEnd\"},\n\n    {K_F1,\t\t(char_u *)\"F1\"},\n    {K_F2,\t\t(char_u *)\"F2\"},\n    {K_F3,\t\t(char_u *)\"F3\"},\n    {K_F4,\t\t(char_u *)\"F4\"},\n    {K_F5,\t\t(char_u *)\"F5\"},\n    {K_F6,\t\t(char_u *)\"F6\"},\n    {K_F7,\t\t(char_u *)\"F7\"},\n    {K_F8,\t\t(char_u *)\"F8\"},\n    {K_F9,\t\t(char_u *)\"F9\"},\n    {K_F10,\t\t(char_u *)\"F10\"},\n\n    {K_F11,\t\t(char_u *)\"F11\"},\n    {K_F12,\t\t(char_u *)\"F12\"},\n    {K_F13,\t\t(char_u *)\"F13\"},\n    {K_F14,\t\t(char_u *)\"F14\"},\n    {K_F15,\t\t(char_u *)\"F15\"},\n    {K_F16,\t\t(char_u *)\"F16\"},\n    {K_F17,\t\t(char_u *)\"F17\"},\n    {K_F18,\t\t(char_u *)\"F18\"},\n    {K_F19,\t\t(char_u *)\"F19\"},\n    {K_F20,\t\t(char_u *)\"F20\"},\n\n    {K_F21,\t\t(char_u *)\"F21\"},\n    {K_F22,\t\t(char_u *)\"F22\"},\n    {K_F23,\t\t(char_u *)\"F23\"},\n    {K_F24,\t\t(char_u *)\"F24\"},\n    {K_F25,\t\t(char_u *)\"F25\"},\n    {K_F26,\t\t(char_u *)\"F26\"},\n    {K_F27,\t\t(char_u *)\"F27\"},\n    {K_F28,\t\t(char_u *)\"F28\"},\n    {K_F29,\t\t(char_u *)\"F29\"},\n    {K_F30,\t\t(char_u *)\"F30\"},\n\n    {K_F31,\t\t(char_u *)\"F31\"},\n    {K_F32,\t\t(char_u *)\"F32\"},\n    {K_F33,\t\t(char_u *)\"F33\"},\n    {K_F34,\t\t(char_u *)\"F34\"},\n    {K_F35,\t\t(char_u *)\"F35\"},\n    {K_F36,\t\t(char_u *)\"F36\"},\n    {K_F37,\t\t(char_u *)\"F37\"},\n\n    {K_XF1,\t\t(char_u *)\"xF1\"},\n    {K_XF2,\t\t(char_u *)\"xF2\"},\n    {K_XF3,\t\t(char_u *)\"xF3\"},\n    {K_XF4,\t\t(char_u *)\"xF4\"},\n\n    {K_HELP,\t\t(char_u *)\"Help\"},\n    {K_UNDO,\t\t(char_u *)\"Undo\"},\n    {K_INS,\t\t(char_u *)\"Insert\"},\n    {K_INS,\t\t(char_u *)\"Ins\"},\t// Alternative name\n    {K_KINS,\t\t(char_u *)\"kInsert\"},\n    {K_HOME,\t\t(char_u *)\"Home\"},\n    {K_KHOME,\t\t(char_u *)\"kHome\"},\n    {K_XHOME,\t\t(char_u *)\"xHome\"},\n    {K_ZHOME,\t\t(char_u *)\"zHome\"},\n    {K_END,\t\t(char_u *)\"End\"},\n    {K_KEND,\t\t(char_u *)\"kEnd\"},\n    {K_XEND,\t\t(char_u *)\"xEnd\"},\n    {K_ZEND,\t\t(char_u *)\"zEnd\"},\n    {K_PAGEUP,\t\t(char_u *)\"PageUp\"},\n    {K_PAGEDOWN,\t(char_u *)\"PageDown\"},\n    {K_KPAGEUP,\t\t(char_u *)\"kPageUp\"},\n    {K_KPAGEDOWN,\t(char_u *)\"kPageDown\"},\n\n    {K_KPLUS,\t\t(char_u *)\"kPlus\"},\n    {K_KMINUS,\t\t(char_u *)\"kMinus\"},\n    {K_KDIVIDE,\t\t(char_u *)\"kDivide\"},\n    {K_KMULTIPLY,\t(char_u *)\"kMultiply\"},\n    {K_KENTER,\t\t(char_u *)\"kEnter\"},\n    {K_KPOINT,\t\t(char_u *)\"kPoint\"},\n\n    {K_K0,\t\t(char_u *)\"k0\"},\n    {K_K1,\t\t(char_u *)\"k1\"},\n    {K_K2,\t\t(char_u *)\"k2\"},\n    {K_K3,\t\t(char_u *)\"k3\"},\n    {K_K4,\t\t(char_u *)\"k4\"},\n    {K_K5,\t\t(char_u *)\"k5\"},\n    {K_K6,\t\t(char_u *)\"k6\"},\n    {K_K7,\t\t(char_u *)\"k7\"},\n    {K_K8,\t\t(char_u *)\"k8\"},\n    {K_K9,\t\t(char_u *)\"k9\"},\n\n    {'<',\t\t(char_u *)\"lt\"},\n\n    {K_MOUSE,\t\t(char_u *)\"Mouse\"},\n#ifdef FEAT_MOUSE_NET\n    {K_NETTERM_MOUSE,\t(char_u *)\"NetMouse\"},\n#endif\n#ifdef FEAT_MOUSE_DEC\n    {K_DEC_MOUSE,\t(char_u *)\"DecMouse\"},\n#endif\n#ifdef FEAT_MOUSE_JSB\n    {K_JSBTERM_MOUSE,\t(char_u *)\"JsbMouse\"},\n#endif\n#ifdef FEAT_MOUSE_PTERM\n    {K_PTERM_MOUSE,\t(char_u *)\"PtermMouse\"},\n#endif\n#ifdef FEAT_MOUSE_URXVT\n    {K_URXVT_MOUSE,\t(char_u *)\"UrxvtMouse\"},\n#endif\n    {K_SGR_MOUSE,\t(char_u *)\"SgrMouse\"},\n    {K_SGR_MOUSERELEASE, (char_u *)\"SgrMouseRelease\"},\n    {K_LEFTMOUSE,\t(char_u *)\"LeftMouse\"},\n    {K_LEFTMOUSE_NM,\t(char_u *)\"LeftMouseNM\"},\n    {K_LEFTDRAG,\t(char_u *)\"LeftDrag\"},\n    {K_LEFTRELEASE,\t(char_u *)\"LeftRelease\"},\n    {K_LEFTRELEASE_NM,\t(char_u *)\"LeftReleaseNM\"},\n    {K_MOUSEMOVE,\t(char_u *)\"MouseMove\"},\n    {K_MIDDLEMOUSE,\t(char_u *)\"MiddleMouse\"},\n    {K_MIDDLEDRAG,\t(char_u *)\"MiddleDrag\"},\n    {K_MIDDLERELEASE,\t(char_u *)\"MiddleRelease\"},\n    {K_RIGHTMOUSE,\t(char_u *)\"RightMouse\"},\n    {K_RIGHTDRAG,\t(char_u *)\"RightDrag\"},\n    {K_RIGHTRELEASE,\t(char_u *)\"RightRelease\"},\n    {K_MOUSEDOWN,\t(char_u *)\"ScrollWheelUp\"},\n    {K_MOUSEUP,\t\t(char_u *)\"ScrollWheelDown\"},\n    {K_MOUSELEFT,\t(char_u *)\"ScrollWheelRight\"},\n    {K_MOUSERIGHT,\t(char_u *)\"ScrollWheelLeft\"},\n    {K_MOUSEDOWN,\t(char_u *)\"MouseDown\"}, // OBSOLETE: Use\n    {K_MOUSEUP,\t\t(char_u *)\"MouseUp\"},\t// ScrollWheelXXX instead\n    {K_X1MOUSE,\t\t(char_u *)\"X1Mouse\"},\n    {K_X1DRAG,\t\t(char_u *)\"X1Drag\"},\n    {K_X1RELEASE,\t\t(char_u *)\"X1Release\"},\n    {K_X2MOUSE,\t\t(char_u *)\"X2Mouse\"},\n    {K_X2DRAG,\t\t(char_u *)\"X2Drag\"},\n    {K_X2RELEASE,\t\t(char_u *)\"X2Release\"},\n    {K_DROP,\t\t(char_u *)\"Drop\"},\n    {K_ZERO,\t\t(char_u *)\"Nul\"},\n#ifdef FEAT_EVAL\n    {K_SNR,\t\t(char_u *)\"SNR\"},\n#endif\n    {K_PLUG,\t\t(char_u *)\"Plug\"},\n    {K_CURSORHOLD,\t(char_u *)\"CursorHold\"},\n    {K_IGNORE,\t\t(char_u *)\"Ignore\"},\n    {K_COMMAND,\t\t(char_u *)\"Cmd\"},\n    {K_SCRIPT_COMMAND,\t(char_u *)\"ScriptCmd\"},\n    {K_FOCUSGAINED,\t(char_u *)\"FocusGained\"},\n    {K_FOCUSLOST,\t(char_u *)\"FocusLost\"},\n    {0,\t\t\tNULL}\n    // NOTE: When adding a long name update MAX_KEY_NAME_LEN.\n};\n\n#define KEY_NAMES_TABLE_LEN ARRAY_LENGTH(key_names_table)\n\n/*\n * Return the modifier mask bit (MOD_MASK_*) which corresponds to the given\n * modifier name ('S' for Shift, 'C' for Ctrl etc).\n */\n    static int\nname_to_mod_mask(int c)\n{\n    int\t    i;\n\n    c = TOUPPER_ASC(c);\n    for (i = 0; mod_mask_table[i].mod_mask != 0; i++)\n\tif (c == mod_mask_table[i].name)\n\t    return mod_mask_table[i].mod_flag;\n    return 0;\n}\n\n/*\n * Check if if there is a special key code for \"key\" that includes the\n * modifiers specified.\n */\n    int\nsimplify_key(int key, int *modifiers)\n{\n    int\t    i;\n    int\t    key0;\n    int\t    key1;\n\n    if (*modifiers & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))\n    {\n\t// TAB is a special case\n\tif (key == TAB && (*modifiers & MOD_MASK_SHIFT))\n\t{\n\t    *modifiers &= ~MOD_MASK_SHIFT;\n\t    return K_S_TAB;\n\t}\n\tkey0 = KEY2TERMCAP0(key);\n\tkey1 = KEY2TERMCAP1(key);\n\tfor (i = 0; modifier_keys_table[i] != NUL; i += MOD_KEYS_ENTRY_SIZE)\n\t    if (key0 == modifier_keys_table[i + 3]\n\t\t    && key1 == modifier_keys_table[i + 4]\n\t\t    && (*modifiers & modifier_keys_table[i]))\n\t    {\n\t\t*modifiers &= ~modifier_keys_table[i];\n\t\treturn TERMCAP2KEY(modifier_keys_table[i + 1],\n\t\t\t\t\t\t   modifier_keys_table[i + 2]);\n\t    }\n    }\n    return key;\n}\n\n/*\n * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n */\n    int\nhandle_x_keys(int key)\n{\n    switch (key)\n    {\n\tcase K_XUP:\treturn K_UP;\n\tcase K_XDOWN:\treturn K_DOWN;\n\tcase K_XLEFT:\treturn K_LEFT;\n\tcase K_XRIGHT:\treturn K_RIGHT;\n\tcase K_XHOME:\treturn K_HOME;\n\tcase K_ZHOME:\treturn K_HOME;\n\tcase K_XEND:\treturn K_END;\n\tcase K_ZEND:\treturn K_END;\n\tcase K_XF1:\treturn K_F1;\n\tcase K_XF2:\treturn K_F2;\n\tcase K_XF3:\treturn K_F3;\n\tcase K_XF4:\treturn K_F4;\n\tcase K_S_XF1:\treturn K_S_F1;\n\tcase K_S_XF2:\treturn K_S_F2;\n\tcase K_S_XF3:\treturn K_S_F3;\n\tcase K_S_XF4:\treturn K_S_F4;\n    }\n    return key;\n}\n\n/*\n * Return a string which contains the name of the given key when the given\n * modifiers are down.\n */\n    char_u *\nget_special_key_name(int c, int modifiers)\n{\n    static char_u string[MAX_KEY_NAME_LEN + 1];\n\n    int\t    i, idx;\n    int\t    table_idx;\n    char_u  *s;\n\n    string[0] = '<';\n    idx = 1;\n\n    // Key that stands for a normal character.\n    if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)\n\tc = KEY2TERMCAP1(c);\n\n    /*\n     * Translate shifted special keys into unshifted keys and set modifier.\n     * Same for CTRL and ALT modifiers.\n     */\n    if (IS_SPECIAL(c))\n    {\n\tfor (i = 0; modifier_keys_table[i] != 0; i += MOD_KEYS_ENTRY_SIZE)\n\t    if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]\n\t\t    && (int)KEY2TERMCAP1(c) == (int)modifier_keys_table[i + 2])\n\t    {\n\t\tmodifiers |= modifier_keys_table[i];\n\t\tc = TERMCAP2KEY(modifier_keys_table[i + 3],\n\t\t\t\t\t\t   modifier_keys_table[i + 4]);\n\t\tbreak;\n\t    }\n    }\n\n    // try to find the key in the special key table\n    table_idx = find_special_key_in_table(c);\n\n    /*\n     * When not a known special key, and not a printable character, try to\n     * extract modifiers.\n     */\n    if (c > 0 && (*mb_char2len)(c) == 1)\n    {\n\tif (table_idx < 0\n\t\t&& (!vim_isprintc(c) || (c & 0x7f) == ' ')\n\t\t&& (c & 0x80))\n\t{\n\t    c &= 0x7f;\n\t    modifiers |= MOD_MASK_ALT;\n\t    // try again, to find the un-alted key in the special key table\n\t    table_idx = find_special_key_in_table(c);\n\t}\n\tif (table_idx < 0 && !vim_isprintc(c) && c < ' ')\n\t{\n\t    c += '@';\n\t    modifiers |= MOD_MASK_CTRL;\n\t}\n    }\n\n    // translate the modifier into a string\n    for (i = 0; mod_mask_table[i].name != 'A'; i++)\n\tif ((modifiers & mod_mask_table[i].mod_mask)\n\t\t\t\t\t\t== mod_mask_table[i].mod_flag)\n\t{\n\t    string[idx++] = mod_mask_table[i].name;\n\t    string[idx++] = (char_u)'-';\n\t}\n\n    if (table_idx < 0)\t\t// unknown special key, may output t_xx\n    {\n\tif (IS_SPECIAL(c))\n\t{\n\t    string[idx++] = 't';\n\t    string[idx++] = '_';\n\t    string[idx++] = KEY2TERMCAP0(c);\n\t    string[idx++] = KEY2TERMCAP1(c);\n\t}\n\t// Not a special key, only modifiers, output directly\n\telse\n\t{\n\t    if (has_mbyte && (*mb_char2len)(c) > 1)\n\t\tidx += (*mb_char2bytes)(c, string + idx);\n\t    else if (vim_isprintc(c))\n\t\tstring[idx++] = c;\n\t    else\n\t    {\n\t\ts = transchar(c);\n\t\twhile (*s)\n\t\t    string[idx++] = *s++;\n\t    }\n\t}\n    }\n    else\t\t// use name of special key\n    {\n\tsize_t len = STRLEN(key_names_table[table_idx].name);\n\n\tif (len + idx + 2 <= MAX_KEY_NAME_LEN)\n\t{\n\t    STRCPY(string + idx, key_names_table[table_idx].name);\n\t    idx += (int)len;\n\t}\n    }\n    string[idx++] = '>';\n    string[idx] = NUL;\n    return string;\n}\n\n/*\n * Try translating a <> name at (*srcp)[] to dst[].\n * Return the number of characters added to dst[], zero for no match.\n * If there is a match, srcp is advanced to after the <> name.\n * dst[] must be big enough to hold the result (up to six characters)!\n */\n    int\ntrans_special(\n    char_u\t**srcp,\n    char_u\t*dst,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\tescape_ks,\t// escape K_SPECIAL bytes in the character\n    int\t\t*did_simplify)  // FSK_SIMPLIFY and found <C-H> or <A-x>\n{\n    int\t\tmodifiers = 0;\n    int\t\tkey;\n\n    key = find_special_key(srcp, &modifiers, flags, did_simplify);\n    if (key == 0)\n\treturn 0;\n\n    return special_to_buf(key, modifiers, escape_ks, dst);\n}\n\n/*\n * Put the character sequence for \"key\" with \"modifiers\" into \"dst\" and return\n * the resulting length.\n * When \"escape_ks\" is TRUE escape K_SPECIAL bytes in the character.\n * The sequence is not NUL terminated.\n * This is how characters in a string are encoded.\n */\n    int\nspecial_to_buf(int key, int modifiers, int escape_ks, char_u *dst)\n{\n    int\t\tdlen = 0;\n\n    // Put the appropriate modifier in a string\n    if (modifiers != 0)\n    {\n\tdst[dlen++] = K_SPECIAL;\n\tdst[dlen++] = KS_MODIFIER;\n\tdst[dlen++] = modifiers;\n    }\n\n    if (IS_SPECIAL(key))\n    {\n\tdst[dlen++] = K_SPECIAL;\n\tdst[dlen++] = KEY2TERMCAP0(key);\n\tdst[dlen++] = KEY2TERMCAP1(key);\n    }\n    else if (escape_ks)\n\tdlen = (int)(add_char2buf(key, dst + dlen) - dst);\n    else if (has_mbyte)\n\tdlen += (*mb_char2bytes)(key, dst + dlen);\n    else\n\tdst[dlen++] = key;\n\n    return dlen;\n}\n\n/*\n * Try translating a <> name at (*srcp)[], return the key and modifiers.\n * srcp is advanced to after the <> name.\n * returns 0 if there is no match.\n */\n    int\nfind_special_key(\n    char_u\t**srcp,\n    int\t\t*modp,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\t*did_simplify)  // found <C-H> or <A-x>\n{\n    char_u\t*last_dash;\n    char_u\t*end_of_name;\n    char_u\t*src;\n    char_u\t*bp;\n    int\t\tin_string = flags & FSK_IN_STRING;\n    int\t\tmodifiers;\n    int\t\tbit;\n    int\t\tkey;\n    uvarnumber_T\tn;\n    int\t\tl;\n\n    src = *srcp;\n    if (src[0] != '<')\n\treturn 0;\n    if (src[1] == '*')\t    // <*xxx>: do not simplify\n\t++src;\n\n    // Find end of modifier list\n    last_dash = src;\n    for (bp = src + 1; *bp == '-' || vim_isNormalIDc(*bp); bp++)\n    {\n\tif (*bp == '-')\n\t{\n\t    last_dash = bp;\n\t    if (bp[1] != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t    l = mb_ptr2len(bp + 1);\n\t\telse\n\t\t    l = 1;\n\t\t// Anything accepted, like <C-?>.\n\t\t// <C-\"> or <M-\"> are not special in strings as \" is\n\t\t// the string delimiter. With a backslash it works: <M-\\\">\n\t\tif (!(in_string && bp[1] == '\"') && bp[l + 1] == '>')\n\t\t    bp += l;\n\t\telse if (in_string && bp[1] == '\\\\' && bp[2] == '\"'\n\t\t\t\t\t\t\t   && bp[3] == '>')\n\t\t    bp += 2;\n\t    }\n\t}\n\tif (bp[0] == 't' && bp[1] == '_' && bp[2] && bp[3])\n\t    bp += 3;\t// skip t_xx, xx may be '-' or '>'\n\telse if (STRNICMP(bp, \"char-\", 5) == 0)\n\t{\n\t    vim_str2nr(bp + 5, NULL, &l, STR2NR_ALL, NULL, NULL, 0, TRUE);\n\t    if (l == 0)\n\t    {\n\t\temsg(_(e_invalid_argument));\n\t\treturn 0;\n\t    }\n\t    bp += l + 5;\n\t    break;\n\t}\n    }\n\n    if (*bp == '>')\t// found matching '>'\n    {\n\tend_of_name = bp + 1;\n\n\t// Which modifiers are given?\n\tmodifiers = 0x0;\n\tfor (bp = src + 1; bp < last_dash; bp++)\n\t{\n\t    if (*bp != '-')\n\t    {\n\t\tbit = name_to_mod_mask(*bp);\n\t\tif (bit == 0x0)\n\t\t    break;\t// Illegal modifier name\n\t\tmodifiers |= bit;\n\t    }\n\t}\n\n\t/*\n\t * Legal modifier name.\n\t */\n\tif (bp >= last_dash)\n\t{\n\t    if (STRNICMP(last_dash + 1, \"char-\", 5) == 0\n\t\t\t\t\t\t && VIM_ISDIGIT(last_dash[6]))\n\t    {\n\t\t// <Char-123> or <Char-033> or <Char-0x33>\n\t\tvim_str2nr(last_dash + 6, NULL, &l, STR2NR_ALL, NULL,\n\t\t\t\t\t\t\t\t  &n, 0, TRUE);\n\t\tif (l == 0)\n\t\t{\n\t\t    emsg(_(e_invalid_argument));\n\t\t    return 0;\n\t\t}\n\t\tkey = (int)n;\n\t    }\n\t    else\n\t    {\n\t\tint off = 1;\n\n\t\t// Modifier with single letter, or special key name.\n\t\tif (in_string && last_dash[1] == '\\\\' && last_dash[2] == '\"')\n\t\t    off = 2;\n\t\tif (has_mbyte)\n\t\t    l = mb_ptr2len(last_dash + off);\n\t\telse\n\t\t    l = 1;\n\t\tif (modifiers != 0 && last_dash[l + off] == '>')\n\t\t    key = PTR2CHAR(last_dash + off);\n\t\telse\n\t\t{\n\t\t    key = get_special_key_code(last_dash + off);\n\t\t    if (!(flags & FSK_KEEP_X_KEY))\n\t\t\tkey = handle_x_keys(key);\n\t\t}\n\t    }\n\n\t    /*\n\t     * get_special_key_code() may return NUL for invalid\n\t     * special key name.\n\t     */\n\t    if (key != NUL)\n\t    {\n\t\t/*\n\t\t * Only use a modifier when there is no special key code that\n\t\t * includes the modifier.\n\t\t */\n\t\tkey = simplify_key(key, &modifiers);\n\n\t\tif (!(flags & FSK_KEYCODE))\n\t\t{\n\t\t    // don't want keycode, use single byte code\n\t\t    if (key == K_BS)\n\t\t\tkey = BS;\n\t\t    else if (key == K_DEL || key == K_KDEL)\n\t\t\tkey = DEL;\n\t\t}\n\n\t\t// Normal Key with modifier: Try to make a single byte code.\n\t\tif (!IS_SPECIAL(key))\n\t\t    key = extract_modifiers(key, &modifiers,\n\t\t\t\t\t   flags & FSK_SIMPLIFY, did_simplify);\n\n\t\t*modp = modifiers;\n\t\t*srcp = end_of_name;\n\t\treturn key;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n\n/*\n * Some keys are used with Ctrl without Shift and are still expected to be\n * mapped as if Shift was pressed:\n * CTRL-2 is CTRL-@\n * CTRL-6 is CTRL-^\n * CTRL-- is CTRL-_\n * Also, <C-H> and <C-h> mean the same thing, always use \"H\".\n * Returns the possibly adjusted key.\n */\n    int\nmay_adjust_key_for_ctrl(int modifiers, int key)\n{\n    if (modifiers & MOD_MASK_CTRL)\n    {\n\tif (ASCII_ISALPHA(key))\n\t    return TOUPPER_ASC(key);\n\tif (key == '2')\n\t    return '@';\n\tif (key == '6')\n\t    return '^';\n\tif (key == '-')\n\t    return '_';\n    }\n    return key;\n}\n\n/*\n * Some keys already have Shift included, pass them as normal keys.\n * When Ctrl is also used <C-H> and <C-S-H> are different, but <C-S-{> should\n * be <C-{>.  Same for <C-S-}> and <C-S-|>.\n * Also for <A-S-a> and <M-S-a>.\n * This includes all printable ASCII characters except numbers and a-z.\n */\n    int\nmay_remove_shift_modifier(int modifiers, int key)\n{\n    if ((modifiers == MOD_MASK_SHIFT\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_ALT)\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_META))\n\t    && ((key >= '!' && key <= '/')\n\t\t|| (key >= ':' && key <= 'Z')\n\t\t|| (key >= '[' && key <= '`')\n\t\t|| (key >= '{' && key <= '~')))\n\treturn modifiers & ~MOD_MASK_SHIFT;\n\n    if (modifiers == (MOD_MASK_SHIFT | MOD_MASK_CTRL)\n\t\t&& (key == '{' || key == '}' || key == '|'))\n\treturn modifiers & ~MOD_MASK_SHIFT;\n\n    return modifiers;\n}\n\n/*\n * Try to include modifiers in the key.\n * Changes \"Shift-a\" to 'A', \"Alt-A\" to 0xc0, etc.\n * When \"simplify\" is FALSE don't do Ctrl and Alt.\n * When \"simplify\" is TRUE and Ctrl or Alt is removed from modifiers set\n * \"did_simplify\" when it's not NULL.\n */\n    int\nextract_modifiers(int key, int *modp, int simplify, int *did_simplify)\n{\n    int\tmodifiers = *modp;\n\n#ifdef MACOS_X\n    // Command-key really special, no fancynest\n    if (!(modifiers & MOD_MASK_CMD))\n#endif\n    if ((modifiers & MOD_MASK_SHIFT) && ASCII_ISALPHA(key))\n    {\n\tkey = TOUPPER_ASC(key);\n\t// With <C-S-a> we keep the shift modifier.\n\t// With <S-a>, <A-S-a> and <S-A> we don't keep the shift modifier.\n\tif (simplify || modifiers == MOD_MASK_SHIFT\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_ALT)\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_META))\n\t    modifiers &= ~MOD_MASK_SHIFT;\n    }\n\n    // <C-H> and <C-h> mean the same thing, always use \"H\"\n    if ((modifiers & MOD_MASK_CTRL) && ASCII_ISALPHA(key))\n\tkey = TOUPPER_ASC(key);\n\n    if (simplify && (modifiers & MOD_MASK_CTRL)\n\t    && ((key >= '?' && key <= '_') || ASCII_ISALPHA(key)))\n    {\n\tkey = Ctrl_chr(key);\n\tmodifiers &= ~MOD_MASK_CTRL;\n\t// <C-@> is <Nul>\n\tif (key == NUL)\n\t    key = K_ZERO;\n\tif (did_simplify != NULL)\n\t    *did_simplify = TRUE;\n    }\n\n#ifdef MACOS_X\n    // Command-key really special, no fancynest\n    if (!(modifiers & MOD_MASK_CMD))\n#endif\n    if (simplify && (modifiers & MOD_MASK_ALT) && key < 0x80\n\t    && !enc_dbcs)\t\t// avoid creating a lead byte\n    {\n\tkey |= 0x80;\n\tmodifiers &= ~MOD_MASK_ALT;\t// remove the META modifier\n\tif (did_simplify != NULL)\n\t    *did_simplify = TRUE;\n    }\n\n    *modp = modifiers;\n    return key;\n}\n\n/*\n * Try to find key \"c\" in the special key table.\n * Return the index when found, -1 when not found.\n */\n    int\nfind_special_key_in_table(int c)\n{\n    int\t    i;\n\n    for (i = 0; key_names_table[i].name != NULL; i++)\n\tif (c == key_names_table[i].key)\n\t    break;\n    if (key_names_table[i].name == NULL)\n\ti = -1;\n    return i;\n}\n\n/*\n * Find the special key with the given name (the given string does not have to\n * end with NUL, the name is assumed to end before the first non-idchar).\n * If the name starts with \"t_\" the next two characters are interpreted as a\n * termcap name.\n * Return the key code, or 0 if not found.\n */\n    int\nget_special_key_code(char_u *name)\n{\n    char_u  *table_name;\n    char_u  string[3];\n    int\t    i, j;\n\n    /*\n     * If it's <t_xx> we get the code for xx from the termcap\n     */\n    if (name[0] == 't' && name[1] == '_' && name[2] != NUL && name[3] != NUL)\n    {\n\tstring[0] = name[2];\n\tstring[1] = name[3];\n\tstring[2] = NUL;\n\tif (add_termcap_entry(string, FALSE) == OK)\n\t    return TERMCAP2KEY(name[2], name[3]);\n    }\n    else\n\tfor (i = 0; key_names_table[i].name != NULL; i++)\n\t{\n\t    table_name = key_names_table[i].name;\n\t    for (j = 0; vim_isNormalIDc(name[j]) && table_name[j] != NUL; j++)\n\t\tif (TOLOWER_ASC(table_name[j]) != TOLOWER_ASC(name[j]))\n\t\t    break;\n\t    if (!vim_isNormalIDc(name[j]) && table_name[j] == NUL)\n\t\treturn key_names_table[i].key;\n\t}\n    return 0;\n}\n\n    char_u *\nget_key_name(int i)\n{\n    if (i >= (int)KEY_NAMES_TABLE_LEN)\n\treturn NULL;\n    return  key_names_table[i].name;\n}\n\n/*\n * Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.\n */\n    int\nget_fileformat(buf_T *buf)\n{\n    int\t\tc = *buf->b_p_ff;\n\n    if (buf->b_p_bin || c == 'u')\n\treturn EOL_UNIX;\n    if (c == 'm')\n\treturn EOL_MAC;\n    return EOL_DOS;\n}\n\n/*\n * Like get_fileformat(), but override 'fileformat' with \"p\" for \"++opt=val\"\n * argument.\n */\n    int\nget_fileformat_force(\n    buf_T\t*buf,\n    exarg_T\t*eap)\t    // can be NULL!\n{\n    int\t\tc;\n\n    if (eap != NULL && eap->force_ff != 0)\n\tc = eap->force_ff;\n    else\n    {\n\tif ((eap != NULL && eap->force_bin != 0)\n\t\t\t       ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin)\n\t    return EOL_UNIX;\n\tc = *buf->b_p_ff;\n    }\n    if (c == 'u')\n\treturn EOL_UNIX;\n    if (c == 'm')\n\treturn EOL_MAC;\n    return EOL_DOS;\n}\n\n/*\n * Set the current end-of-line type to EOL_DOS, EOL_UNIX or EOL_MAC.\n * Sets both 'textmode' and 'fileformat'.\n * Note: Does _not_ set global value of 'textmode'!\n */\n    void\nset_fileformat(\n    int\t\tt,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    char\t*p = NULL;\n\n    switch (t)\n    {\n    case EOL_DOS:\n\tp = FF_DOS;\n\tcurbuf->b_p_tx = TRUE;\n\tbreak;\n    case EOL_UNIX:\n\tp = FF_UNIX;\n\tcurbuf->b_p_tx = FALSE;\n\tbreak;\n    case EOL_MAC:\n\tp = FF_MAC;\n\tcurbuf->b_p_tx = FALSE;\n\tbreak;\n    }\n    if (p != NULL)\n\tset_string_option_direct((char_u *)\"ff\", -1, (char_u *)p,\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n\n    // This may cause the buffer to become (un)modified.\n    check_status(curbuf);\n    redraw_tabline = TRUE;\n    need_maketitle = TRUE;\t    // set window title later\n}\n\n/*\n * Return the default fileformat from 'fileformats'.\n */\n    int\ndefault_fileformat(void)\n{\n    switch (*p_ffs)\n    {\n\tcase 'm':   return EOL_MAC;\n\tcase 'd':   return EOL_DOS;\n    }\n    return EOL_UNIX;\n}\n\n/*\n * Call shell.\tCalls mch_call_shell, with 'shellxquote' added.\n */\n    int\ncall_shell(char_u *cmd, int opt)\n{\n    char_u\t*ncmd;\n    int\t\tretval;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n\n    if (p_verbose > 3)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Calling shell to execute: \\\"%s\\\"\"), cmd == NULL ? p_sh : cmd);\n\tout_char('\\n');\n\tcursor_on();\n\tverbose_leave();\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time);\n#endif\n\n    if (*p_sh == NUL)\n    {\n\temsg(_(e_shell_option_is_empty));\n\tretval = -1;\n    }\n    else\n    {\n#ifdef FEAT_GUI_MSWIN\n\t// Don't hide the pointer while executing a shell command.\n\tgui_mch_mousehide(FALSE);\n#endif\n#ifdef FEAT_GUI\n\t++hold_gui_events;\n#endif\n\t// The external command may update a tags file, clear cached tags.\n\ttag_freematch();\n\n\tif (cmd == NULL || *p_sxq == NUL)\n\t    retval = mch_call_shell(cmd, opt);\n\telse\n\t{\n\t    char_u *ecmd = cmd;\n\n\t    if (*p_sxe != NUL && *p_sxq == '(')\n\t    {\n\t\tecmd = vim_strsave_escaped_ext(cmd, p_sxe, '^', FALSE);\n\t\tif (ecmd == NULL)\n\t\t    ecmd = cmd;\n\t    }\n\t    ncmd = alloc(STRLEN(ecmd) + STRLEN(p_sxq) * 2 + 1);\n\t    if (ncmd != NULL)\n\t    {\n\t\tSTRCPY(ncmd, p_sxq);\n\t\tSTRCAT(ncmd, ecmd);\n\t\t// When 'shellxquote' is ( append ).\n\t\t// When 'shellxquote' is \"( append )\".\n\t\tSTRCAT(ncmd, *p_sxq == '(' ? (char_u *)\")\"\n\t\t    : *p_sxq == '\"' && *(p_sxq+1) == '(' ? (char_u *)\")\\\"\"\n\t\t    : p_sxq);\n\t\tretval = mch_call_shell(ncmd, opt);\n\t\tvim_free(ncmd);\n\t    }\n\t    else\n\t\tretval = -1;\n\t    if (ecmd != cmd)\n\t\tvim_free(ecmd);\n\t}\n#ifdef FEAT_GUI\n\t--hold_gui_events;\n#endif\n\t/*\n\t * Check the window size, in case it changed while executing the\n\t * external command.\n\t */\n\tshell_resized_check();\n    }\n\n#ifdef FEAT_EVAL\n    set_vim_var_nr(VV_SHELL_ERROR, (long)retval);\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n\n    return retval;\n}\n\n/*\n * MODE_VISUAL, MODE_SELECT and MODE_OP_PENDING State are never set, they are\n * equal to MODE_NORMAL State with a condition.  This function returns the real\n * State.\n */\n    int\nget_real_state(void)\n{\n    if (State & MODE_NORMAL)\n    {\n\tif (VIsual_active)\n\t{\n\t    if (VIsual_select)\n\t\treturn MODE_SELECT;\n\t    return MODE_VISUAL;\n\t}\n\telse if (finish_op)\n\t    return MODE_OP_PENDING;\n    }\n    return State;\n}\n\n/*\n * Return TRUE if \"p\" points to just after a path separator.\n * Takes care of multi-byte characters.\n * \"b\" must point to the start of the file name\n */\n    int\nafter_pathsep(char_u *b, char_u *p)\n{\n    return p > b && vim_ispathsep(p[-1])\n\t\t\t     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);\n}\n\n/*\n * Return TRUE if file names \"f1\" and \"f2\" are in the same directory.\n * \"f1\" may be a short name, \"f2\" must be a full path.\n */\n    int\nsame_directory(char_u *f1, char_u *f2)\n{\n    char_u\tffname[MAXPATHL];\n    char_u\t*t1;\n    char_u\t*t2;\n\n    // safety check\n    if (f1 == NULL || f2 == NULL)\n\treturn FALSE;\n\n    (void)vim_FullName(f1, ffname, MAXPATHL, FALSE);\n    t1 = gettail_sep(ffname);\n    t2 = gettail_sep(f2);\n    return (t1 - ffname == t2 - f2\n\t     && pathcmp((char *)ffname, (char *)f2, (int)(t1 - ffname)) == 0);\n}\n\n#if defined(FEAT_SESSION) || defined(FEAT_AUTOCHDIR) \\\n\t|| defined(MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_NETBEANS_INTG) \\\n\t|| defined(PROTO)\n/*\n * Change to a file's directory.\n * Caller must call shorten_fnames()!\n * Return OK or FAIL.\n */\n    int\nvim_chdirfile(char_u *fname, char *trigger_autocmd)\n{\n    char_u\told_dir[MAXPATHL];\n    char_u\tnew_dir[MAXPATHL];\n\n    if (mch_dirname(old_dir, MAXPATHL) != OK)\n\t*old_dir = NUL;\n\n    vim_strncpy(new_dir, fname, MAXPATHL - 1);\n    *gettail_sep(new_dir) = NUL;\n\n    if (pathcmp((char *)old_dir, (char *)new_dir, -1) == 0)\n\t// nothing to do\n\treturn OK;\n\n    if (trigger_autocmd != NULL)\n\ttrigger_DirChangedPre((char_u *)trigger_autocmd, new_dir);\n\n    if (mch_chdir((char *)new_dir) != 0)\n\treturn FAIL;\n\n    if (trigger_autocmd != NULL)\n\tapply_autocmds(EVENT_DIRCHANGED, (char_u *)trigger_autocmd,\n\t\t\t\t\t\t       new_dir, FALSE, curbuf);\n    return OK;\n}\n#endif\n\n#if defined(STAT_IGNORES_SLASH) || defined(PROTO)\n/*\n * Check if \"name\" ends in a slash and is not a directory.\n * Used for systems where stat() ignores a trailing slash on a file name.\n * The Vim code assumes a trailing slash is only ignored for a directory.\n */\n    static int\nillegal_slash(const char *name)\n{\n    if (name[0] == NUL)\n\treturn FALSE;\t    // no file name is not illegal\n    if (name[strlen(name) - 1] != '/')\n\treturn FALSE;\t    // no trailing slash\n    if (mch_isdir((char_u *)name))\n\treturn FALSE;\t    // trailing slash for a directory\n    return TRUE;\n}\n\n/*\n * Special implementation of mch_stat() for Solaris.\n */\n    int\nvim_stat(const char *name, stat_T *stp)\n{\n    // On Solaris stat() accepts \"file/\" as if it was \"file\".  Return -1 if\n    // the name ends in \"/\" and it's not a directory.\n    return illegal_slash(name) ? -1 : stat(name, stp);\n}\n#endif\n\n#if defined(CURSOR_SHAPE) || defined(PROTO)\n\n/*\n * Handling of cursor and mouse pointer shapes in various modes.\n */\n\ncursorentry_T shape_table[SHAPE_IDX_COUNT] =\n{\n    // The values will be filled in from the 'guicursor' and 'mouseshape'\n    // defaults when Vim starts.\n    // Adjust the SHAPE_IDX_ defines when making changes!\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"n\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"v\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"i\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"r\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"c\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"ci\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"cr\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"o\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"ve\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"e\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"s\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"sd\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"vs\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"vd\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"m\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"ml\", SHAPE_MOUSE},\n    {0,\t0, 0, 100L, 100L, 100L, 0, 0, \"sm\", SHAPE_CURSOR},\n};\n\n#ifdef FEAT_MOUSESHAPE\n/*\n * Table with names for mouse shapes.  Keep in sync with all the tables for\n * mch_set_mouse_shape()!.\n */\nstatic char * mshape_names[] =\n{\n    \"arrow\",\t// default, must be the first one\n    \"blank\",\t// hidden\n    \"beam\",\n    \"updown\",\n    \"udsizing\",\n    \"leftright\",\n    \"lrsizing\",\n    \"busy\",\n    \"no\",\n    \"crosshair\",\n    \"hand1\",\n    \"hand2\",\n    \"pencil\",\n    \"question\",\n    \"rightup-arrow\",\n    \"up-arrow\",\n    NULL\n};\n#endif\n\n/*\n * Parse the 'guicursor' option (\"what\" is SHAPE_CURSOR) or 'mouseshape'\n * (\"what\" is SHAPE_MOUSE).\n * Returns error message for an illegal option, NULL otherwise.\n */\n    char *\nparse_shape_opt(int what)\n{\n    char_u\t*modep;\n    char_u\t*colonp;\n    char_u\t*commap;\n    char_u\t*slashp;\n    char_u\t*p, *endp;\n    int\t\tidx = 0;\t\t// init for GCC\n    int\t\tall_idx;\n    int\t\tlen;\n    int\t\ti;\n    long\tn;\n    int\t\tfound_ve = FALSE;\t// found \"ve\" flag\n    int\t\tround;\n\n    /*\n     * First round: check for errors; second round: do it for real.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Repeat for all comma separated parts.\n\t */\n#ifdef FEAT_MOUSESHAPE\n\tif (what == SHAPE_MOUSE)\n\t    modep = p_mouseshape;\n\telse\n#endif\n\t    modep = p_guicursor;\n\twhile (*modep != NUL)\n\t{\n\t    colonp = vim_strchr(modep, ':');\n\t    commap = vim_strchr(modep, ',');\n\n\t    if (colonp == NULL || (commap != NULL && commap < colonp))\n\t\treturn e_missing_colon_2;\n\t    if (colonp == modep)\n\t\treturn e_illegal_mode;\n\n\t    /*\n\t     * Repeat for all mode's before the colon.\n\t     * For the 'a' mode, we loop to handle all the modes.\n\t     */\n\t    all_idx = -1;\n\t    while (modep < colonp || all_idx >= 0)\n\t    {\n\t\tif (all_idx < 0)\n\t\t{\n\t\t    // Find the mode.\n\t\t    if (modep[1] == '-' || modep[1] == ':')\n\t\t\tlen = 1;\n\t\t    else\n\t\t\tlen = 2;\n\t\t    if (len == 1 && TOLOWER_ASC(modep[0]) == 'a')\n\t\t\tall_idx = SHAPE_IDX_COUNT - 1;\n\t\t    else\n\t\t    {\n\t\t\tfor (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)\n\t\t\t    if (STRNICMP(modep, shape_table[idx].name, len)\n\t\t\t\t\t\t\t\t\t == 0)\n\t\t\t\tbreak;\n\t\t\tif (idx == SHAPE_IDX_COUNT\n\t\t\t\t   || (shape_table[idx].used_for & what) == 0)\n\t\t\t    return e_illegal_mode;\n\t\t\tif (len == 2 && modep[0] == 'v' && modep[1] == 'e')\n\t\t\t    found_ve = TRUE;\n\t\t    }\n\t\t    modep += len + 1;\n\t\t}\n\n\t\tif (all_idx >= 0)\n\t\t    idx = all_idx--;\n\t\telse if (round == 2)\n\t\t{\n#ifdef FEAT_MOUSESHAPE\n\t\t    if (what == SHAPE_MOUSE)\n\t\t    {\n\t\t\t// Set the default, for the missing parts\n\t\t\tshape_table[idx].mshape = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\t// Set the defaults, for the missing parts\n\t\t\tshape_table[idx].shape = SHAPE_BLOCK;\n\t\t\tshape_table[idx].blinkwait = 700L;\n\t\t\tshape_table[idx].blinkon = 400L;\n\t\t\tshape_table[idx].blinkoff = 250L;\n\t\t    }\n\t\t}\n\n\t\t// Parse the part after the colon\n\t\tfor (p = colonp + 1; *p && *p != ','; )\n\t\t{\n#ifdef FEAT_MOUSESHAPE\n\t\t    if (what == SHAPE_MOUSE)\n\t\t    {\n\t\t\tfor (i = 0; ; ++i)\n\t\t\t{\n\t\t\t    if (mshape_names[i] == NULL)\n\t\t\t    {\n\t\t\t\tif (!VIM_ISDIGIT(*p))\n\t\t\t\t    return e_illegal_mouseshape;\n\t\t\t\tif (round == 2)\n\t\t\t\t    shape_table[idx].mshape =\n\t\t\t\t\t      getdigits(&p) + MSHAPE_NUMBERED;\n\t\t\t\telse\n\t\t\t\t    (void)getdigits(&p);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    len = (int)STRLEN(mshape_names[i]);\n\t\t\t    if (STRNICMP(p, mshape_names[i], len) == 0)\n\t\t\t    {\n\t\t\t\tif (round == 2)\n\t\t\t\t    shape_table[idx].mshape = i;\n\t\t\t\tp += len;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else // if (what == SHAPE_MOUSE)\n#endif\n\t\t    {\n\t\t\t/*\n\t\t\t * First handle the ones with a number argument.\n\t\t\t */\n\t\t\ti = *p;\n\t\t\tlen = 0;\n\t\t\tif (STRNICMP(p, \"ver\", 3) == 0)\n\t\t\t    len = 3;\n\t\t\telse if (STRNICMP(p, \"hor\", 3) == 0)\n\t\t\t    len = 3;\n\t\t\telse if (STRNICMP(p, \"blinkwait\", 9) == 0)\n\t\t\t    len = 9;\n\t\t\telse if (STRNICMP(p, \"blinkon\", 7) == 0)\n\t\t\t    len = 7;\n\t\t\telse if (STRNICMP(p, \"blinkoff\", 8) == 0)\n\t\t\t    len = 8;\n\t\t\tif (len != 0)\n\t\t\t{\n\t\t\t    p += len;\n\t\t\t    if (!VIM_ISDIGIT(*p))\n\t\t\t\treturn e_digit_expected;\n\t\t\t    n = getdigits(&p);\n\t\t\t    if (len == 3)   // \"ver\" or \"hor\"\n\t\t\t    {\n\t\t\t\tif (n == 0)\n\t\t\t\t    return e_illegal_percentage;\n\t\t\t\tif (round == 2)\n\t\t\t\t{\n\t\t\t\t    if (TOLOWER_ASC(i) == 'v')\n\t\t\t\t\tshape_table[idx].shape = SHAPE_VER;\n\t\t\t\t    else\n\t\t\t\t\tshape_table[idx].shape = SHAPE_HOR;\n\t\t\t\t    shape_table[idx].percentage = n;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else if (round == 2)\n\t\t\t    {\n\t\t\t\tif (len == 9)\n\t\t\t\t    shape_table[idx].blinkwait = n;\n\t\t\t\telse if (len == 7)\n\t\t\t\t    shape_table[idx].blinkon = n;\n\t\t\t\telse\n\t\t\t\t    shape_table[idx].blinkoff = n;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (STRNICMP(p, \"block\", 5) == 0)\n\t\t\t{\n\t\t\t    if (round == 2)\n\t\t\t\tshape_table[idx].shape = SHAPE_BLOCK;\n\t\t\t    p += 5;\n\t\t\t}\n\t\t\telse\t// must be a highlight group name then\n\t\t\t{\n\t\t\t    endp = vim_strchr(p, '-');\n\t\t\t    if (commap == NULL)\t\t    // last part\n\t\t\t    {\n\t\t\t\tif (endp == NULL)\n\t\t\t\t    endp = p + STRLEN(p);   // find end of part\n\t\t\t    }\n\t\t\t    else if (endp > commap || endp == NULL)\n\t\t\t\tendp = commap;\n\t\t\t    slashp = vim_strchr(p, '/');\n\t\t\t    if (slashp != NULL && slashp < endp)\n\t\t\t    {\n\t\t\t\t// \"group/langmap_group\"\n\t\t\t\ti = syn_check_group(p, (int)(slashp - p));\n\t\t\t\tp = slashp + 1;\n\t\t\t    }\n\t\t\t    if (round == 2)\n\t\t\t    {\n\t\t\t\tshape_table[idx].id = syn_check_group(p,\n\t\t\t\t\t\t\t     (int)(endp - p));\n\t\t\t\tshape_table[idx].id_lm = shape_table[idx].id;\n\t\t\t\tif (slashp != NULL && slashp < endp)\n\t\t\t\t    shape_table[idx].id = i;\n\t\t\t    }\n\t\t\t    p = endp;\n\t\t\t}\n\t\t    } // if (what != SHAPE_MOUSE)\n\n\t\t    if (*p == '-')\n\t\t\t++p;\n\t\t}\n\t    }\n\t    modep = p;\n\t    if (*modep == ',')\n\t\t++modep;\n\t}\n    }\n\n    // If the 's' flag is not given, use the 'v' cursor for 's'\n    if (!found_ve)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif (what == SHAPE_MOUSE)\n\t{\n\t    shape_table[SHAPE_IDX_VE].mshape = shape_table[SHAPE_IDX_V].mshape;\n\t}\n\telse\n#endif\n\t{\n\t    shape_table[SHAPE_IDX_VE].shape = shape_table[SHAPE_IDX_V].shape;\n\t    shape_table[SHAPE_IDX_VE].percentage =\n\t\t\t\t\t shape_table[SHAPE_IDX_V].percentage;\n\t    shape_table[SHAPE_IDX_VE].blinkwait =\n\t\t\t\t\t  shape_table[SHAPE_IDX_V].blinkwait;\n\t    shape_table[SHAPE_IDX_VE].blinkon =\n\t\t\t\t\t    shape_table[SHAPE_IDX_V].blinkon;\n\t    shape_table[SHAPE_IDX_VE].blinkoff =\n\t\t\t\t\t   shape_table[SHAPE_IDX_V].blinkoff;\n\t    shape_table[SHAPE_IDX_VE].id = shape_table[SHAPE_IDX_V].id;\n\t    shape_table[SHAPE_IDX_VE].id_lm = shape_table[SHAPE_IDX_V].id_lm;\n\t}\n    }\n\n    return NULL;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return the index into shape_table[] for the current mode.\n * When \"mouse\" is TRUE, consider indexes valid for the mouse pointer.\n */\n    int\nget_shape_idx(int mouse)\n{\n#ifdef FEAT_MOUSESHAPE\n    if (mouse && (State == MODE_HITRETURN || State == MODE_ASKMORE))\n    {\n# ifdef FEAT_GUI\n\tint x, y;\n\tgui_mch_getmouse(&x, &y);\n\tif (Y_2_ROW(y) == Rows - 1)\n\t    return SHAPE_IDX_MOREL;\n# endif\n\treturn SHAPE_IDX_MORE;\n    }\n    if (mouse && drag_status_line)\n\treturn SHAPE_IDX_SDRAG;\n    if (mouse && drag_sep_line)\n\treturn SHAPE_IDX_VDRAG;\n#endif\n    if (!mouse && State == MODE_SHOWMATCH)\n\treturn SHAPE_IDX_SM;\n    if (State & VREPLACE_FLAG)\n\treturn SHAPE_IDX_R;\n    if (State & REPLACE_FLAG)\n\treturn SHAPE_IDX_R;\n    if (State & MODE_INSERT)\n\treturn SHAPE_IDX_I;\n    if (State & MODE_CMDLINE)\n    {\n\tif (cmdline_at_end())\n\t    return SHAPE_IDX_C;\n\tif (cmdline_overstrike())\n\t    return SHAPE_IDX_CR;\n\treturn SHAPE_IDX_CI;\n    }\n    if (finish_op)\n\treturn SHAPE_IDX_O;\n    if (VIsual_active)\n    {\n\tif (*p_sel == 'e')\n\t    return SHAPE_IDX_VE;\n\telse\n\t    return SHAPE_IDX_V;\n    }\n    return SHAPE_IDX_N;\n}\n#endif\n\n# if defined(FEAT_MOUSESHAPE) || defined(PROTO)\nstatic int old_mouse_shape = 0;\n\n/*\n * Set the mouse shape:\n * If \"shape\" is -1, use shape depending on the current mode,\n * depending on the current state.\n * If \"shape\" is -2, only update the shape when it's CLINE or STATUS (used\n * when the mouse moves off the status or command line).\n */\n    void\nupdate_mouseshape(int shape_idx)\n{\n    int new_mouse_shape;\n\n    // Only works in GUI mode.\n    if (!gui.in_use || gui.starting)\n\treturn;\n\n    // Postpone the updating when more is to come.  Speeds up executing of\n    // mappings.\n    if (shape_idx == -1 && char_avail())\n    {\n\tpostponed_mouseshape = TRUE;\n\treturn;\n    }\n\n    // When ignoring the mouse don't change shape on the statusline.\n    if (*p_mouse == NUL\n\t    && (shape_idx == SHAPE_IDX_CLINE\n\t\t|| shape_idx == SHAPE_IDX_STATUS\n\t\t|| shape_idx == SHAPE_IDX_VSEP))\n\tshape_idx = -2;\n\n    if (shape_idx == -2\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_CLINE].mshape\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_STATUS].mshape\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_VSEP].mshape)\n\treturn;\n    if (shape_idx < 0)\n\tnew_mouse_shape = shape_table[get_shape_idx(TRUE)].mshape;\n    else\n\tnew_mouse_shape = shape_table[shape_idx].mshape;\n    if (new_mouse_shape != old_mouse_shape)\n    {\n\tmch_set_mouse_shape(new_mouse_shape);\n\told_mouse_shape = new_mouse_shape;\n    }\n    postponed_mouseshape = FALSE;\n}\n# endif\n\n#endif // CURSOR_SHAPE\n\n\n/*\n * Change directory to \"new_dir\".  If FEAT_SEARCHPATH is defined, search\n * 'cdpath' for relative directory names, otherwise just mch_chdir().\n */\n    int\nvim_chdir(char_u *new_dir)\n{\n#ifndef FEAT_SEARCHPATH\n    return mch_chdir((char *)new_dir);\n#else\n    char_u\t*dir_name;\n    int\t\tr;\n\n    dir_name = find_directory_in_path(new_dir, (int)STRLEN(new_dir),\n\t\t\t\t\t\tFNAME_MESS, curbuf->b_ffname);\n    if (dir_name == NULL)\n\treturn -1;\n    r = mch_chdir((char *)dir_name);\n    vim_free(dir_name);\n    return r;\n#endif\n}\n\n/*\n * Get user name from machine-specific function.\n * Returns the user name in \"buf[len]\".\n * Some systems are quite slow in obtaining the user name (Windows NT), thus\n * cache the result.\n * Returns OK or FAIL.\n */\n    int\nget_user_name(char_u *buf, int len)\n{\n    if (username == NULL)\n    {\n\tif (mch_get_user_name(buf, len) == FAIL)\n\t    return FAIL;\n\tusername = vim_strsave(buf);\n    }\n    else\n\tvim_strncpy(buf, username, len - 1);\n    return OK;\n}\n\n#if defined(EXITFREE) || defined(PROTOS)\n/*\n * Free the memory allocated by get_user_name()\n */\n    void\nfree_username(void)\n{\n    vim_free(username);\n}\n#endif\n\n#ifndef HAVE_QSORT\n/*\n * Our own qsort(), for systems that don't have it.\n * It's simple and slow.  From the K&R C book.\n */\n    void\nqsort(\n    void\t*base,\n    size_t\telm_count,\n    size_t\telm_size,\n    int (*cmp)(const void *, const void *))\n{\n    char_u\t*buf;\n    char_u\t*p1;\n    char_u\t*p2;\n    int\t\ti, j;\n    int\t\tgap;\n\n    buf = alloc(elm_size);\n    if (buf == NULL)\n\treturn;\n\n    for (gap = elm_count / 2; gap > 0; gap /= 2)\n\tfor (i = gap; i < elm_count; ++i)\n\t    for (j = i - gap; j >= 0; j -= gap)\n\t    {\n\t\t// Compare the elements.\n\t\tp1 = (char_u *)base + j * elm_size;\n\t\tp2 = (char_u *)base + (j + gap) * elm_size;\n\t\tif ((*cmp)((void *)p1, (void *)p2) <= 0)\n\t\t    break;\n\t\t// Exchange the elements.\n\t\tmch_memmove(buf, p1, elm_size);\n\t\tmch_memmove(p1, p2, elm_size);\n\t\tmch_memmove(p2, buf, elm_size);\n\t    }\n\n    vim_free(buf);\n}\n#endif\n\n/*\n * The putenv() implementation below comes from the \"screen\" program.\n * Included with permission from Juergen Weigert.\n * See pty.c for the copyright notice.\n */\n\n/*\n *  putenv  --\tput value into environment\n *\n *  Usage:  i = putenv (string)\n *    int i;\n *    char  *string;\n *\n *  where string is of the form <name>=<value>.\n *  Putenv returns 0 normally, -1 on error (not enough core for malloc).\n *\n *  Putenv may need to add a new name into the environment, or to\n *  associate a value longer than the current value with a particular\n *  name.  So, to make life simpler, putenv() copies your entire\n *  environment into the heap (i.e. malloc()) from the stack\n *  (i.e. where it resides when your process is initiated) the first\n *  time you call it.\n *\n *  (history removed, not very interesting.  See the \"screen\" sources.)\n */\n\n#if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)\n\n#define EXTRASIZE 5\t\t// increment to add to env. size\n\nstatic int  envsize = -1;\t// current size of environment\nextern char **environ;\t\t// the global which is your env.\n\nstatic int  findenv(char *name); // look for a name in the env.\nstatic int  newenv(void);\t// copy env. from stack to heap\nstatic int  moreenv(void);\t// incr. size of env.\n\n    int\nputenv(const char *string)\n{\n    int\t    i;\n    char    *p;\n\n    if (envsize < 0)\n    {\t\t\t\t// first time putenv called\n\tif (newenv() < 0)\t// copy env. to heap\n\t    return -1;\n    }\n\n    i = findenv((char *)string); // look for name in environment\n\n    if (i < 0)\n    {\t\t\t\t// name must be added\n\tfor (i = 0; environ[i]; i++);\n\tif (i >= (envsize - 1))\n\t{\t\t\t// need new slot\n\t    if (moreenv() < 0)\n\t\treturn -1;\n\t}\n\tp = alloc(strlen(string) + 1);\n\tif (p == NULL)\t\t// not enough core\n\t    return -1;\n\tenviron[i + 1] = 0;\t// new end of env.\n    }\n    else\n    {\t\t\t\t// name already in env.\n\tp = vim_realloc(environ[i], strlen(string) + 1);\n\tif (p == NULL)\n\t    return -1;\n    }\n    sprintf(p, \"%s\", string);\t// copy into env.\n    environ[i] = p;\n\n    return 0;\n}\n\n    static int\nfindenv(char *name)\n{\n    char    *namechar, *envchar;\n    int\t    i, found;\n\n    found = 0;\n    for (i = 0; environ[i] && !found; i++)\n    {\n\tenvchar = environ[i];\n\tnamechar = name;\n\twhile (*namechar && *namechar != '=' && (*namechar == *envchar))\n\t{\n\t    namechar++;\n\t    envchar++;\n\t}\n\tfound = ((*namechar == '\\0' || *namechar == '=') && *envchar == '=');\n    }\n    return found ? i - 1 : -1;\n}\n\n    static int\nnewenv(void)\n{\n    char    **env, *elem;\n    int\t    i, esize;\n\n    for (i = 0; environ[i]; i++)\n\t;\n\n    esize = i + EXTRASIZE + 1;\n    env = ALLOC_MULT(char *, esize);\n    if (env == NULL)\n\treturn -1;\n\n    for (i = 0; environ[i]; i++)\n    {\n\telem = alloc(strlen(environ[i]) + 1);\n\tif (elem == NULL)\n\t    return -1;\n\tenv[i] = elem;\n\tstrcpy(elem, environ[i]);\n    }\n\n    env[i] = 0;\n    environ = env;\n    envsize = esize;\n    return 0;\n}\n\n    static int\nmoreenv(void)\n{\n    int\t    esize;\n    char    **env;\n\n    esize = envsize + EXTRASIZE;\n    env = vim_realloc((char *)environ, esize * sizeof (*env));\n    if (env == 0)\n\treturn -1;\n    environ = env;\n    envsize = esize;\n    return 0;\n}\n\n# ifdef USE_VIMPTY_GETENV\n/*\n * Used for mch_getenv() for Mac.\n */\n    char_u *\nvimpty_getenv(const char_u *string)\n{\n    int i;\n    char_u *p;\n\n    if (envsize < 0)\n\treturn NULL;\n\n    i = findenv((char *)string);\n\n    if (i < 0)\n\treturn NULL;\n\n    p = vim_strchr((char_u *)environ[i], '=');\n    return (p + 1);\n}\n# endif\n\n#endif // !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return 0 for not writable, 1 for writable file, 2 for a dir which we have\n * rights to write into.\n */\n    int\nfilewritable(char_u *fname)\n{\n    int\t\tretval = 0;\n#if defined(UNIX) || defined(VMS)\n    int\t\tperm = 0;\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    perm = mch_getperm(fname);\n#endif\n    if (\n# ifdef MSWIN\n\t    mch_writable(fname) &&\n# else\n# if defined(UNIX) || defined(VMS)\n\t    (perm & 0222) &&\n#  endif\n# endif\n\t    mch_access((char *)fname, W_OK) == 0\n       )\n    {\n\t++retval;\n\tif (mch_isdir(fname))\n\t    ++retval;\n    }\n    return retval;\n}\n#endif\n\n#if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n/*\n * Read 2 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget2c(FILE *fd)\n{\n    int\t\tc, n;\n\n    n = getc(fd);\n    if (n == EOF) return -1;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    return (n << 8) + c;\n}\n\n/*\n * Read 3 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget3c(FILE *fd)\n{\n    int\t\tc, n;\n\n    n = getc(fd);\n    if (n == EOF) return -1;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    return (n << 8) + c;\n}\n\n/*\n * Read 4 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget4c(FILE *fd)\n{\n    int\t\tc;\n    // Use unsigned rather than int otherwise result is undefined\n    // when left-shift sets the MSB.\n    unsigned\tn;\n\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    return (int)n;\n}\n\n/*\n * Read a string of length \"cnt\" from \"fd\" into allocated memory.\n * Returns NULL when out of memory or unable to read that many bytes.\n */\n    char_u *\nread_string(FILE *fd, int cnt)\n{\n    char_u\t*str;\n    int\t\ti;\n    int\t\tc;\n\n    // allocate memory\n    str = alloc(cnt + 1);\n    if (str != NULL)\n    {\n\t// Read the string.  Quit when running into the EOF.\n\tfor (i = 0; i < cnt; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t    {\n\t\tvim_free(str);\n\t\treturn NULL;\n\t    }\n\t    str[i] = c;\n\t}\n\tstr[i] = NUL;\n    }\n    return str;\n}\n\n/*\n * Write a number to file \"fd\", MSB first, in \"len\" bytes.\n */\n    int\nput_bytes(FILE *fd, long_u nr, int len)\n{\n    int\t    i;\n\n    for (i = len - 1; i >= 0; --i)\n\tif (putc((int)(nr >> (i * 8)), fd) == EOF)\n\t    return FAIL;\n    return OK;\n}\n\n#endif\n\n#ifndef PROTO  // proto is defined in vim.h\n# ifdef ELAPSED_TIMEVAL\n/*\n * Return time in msec since \"start_tv\".\n */\n    long\nelapsed(struct timeval *start_tv)\n{\n    struct timeval  now_tv;\n\n    gettimeofday(&now_tv, NULL);\n    return (now_tv.tv_sec - start_tv->tv_sec) * 1000L\n\t + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;\n}\n# endif\n\n# ifdef ELAPSED_TICKCOUNT\n/*\n * Return time in msec since \"start_tick\".\n */\n    long\nelapsed(DWORD start_tick)\n{\n    DWORD\tnow = GetTickCount();\n\n    return (long)now - (long)start_tick;\n}\n# endif\n#endif\n\n#if defined(FEAT_JOB_CHANNEL) \\\n\t|| (defined(UNIX) && (!defined(USE_SYSTEM) \\\n\t|| (defined(FEAT_GUI) && defined(FEAT_TERMINAL)))) \\\n\t|| defined(PROTO)\n/*\n * Parse \"cmd\" and put the white-separated parts in \"argv\".\n * \"argv\" is an allocated array with \"argc\" entries and room for 4 more.\n * Returns FAIL when out of memory.\n */\n    int\nmch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc)\n{\n    int\t\ti;\n    char_u\t*p, *d;\n    int\t\tinquote;\n\n    /*\n     * Do this loop twice:\n     * 1: find number of arguments\n     * 2: separate them and build argv[]\n     */\n    for (i = 1; i <= 2; ++i)\n    {\n\tp = skipwhite(cmd);\n\tinquote = FALSE;\n\t*argc = 0;\n\twhile (*p != NUL)\n\t{\n\t    if (i == 2)\n\t\t(*argv)[*argc] = (char *)p;\n\t    ++*argc;\n\t    d = p;\n\t    while (*p != NUL && (inquote || (*p != ' ' && *p != TAB)))\n\t    {\n\t\tif (p[0] == '\"')\n\t\t    // quotes surrounding an argument and are dropped\n\t\t    inquote = !inquote;\n\t\telse\n\t\t{\n\t\t    if (rem_backslash(p))\n\t\t    {\n\t\t\t// First pass: skip over \"\\ \" and \"\\\"\".\n\t\t\t// Second pass: Remove the backslash.\n\t\t\t++p;\n\t\t    }\n\t\t    if (i == 2)\n\t\t\t*d++ = *p;\n\t\t}\n\t\t++p;\n\t    }\n\t    if (*p == NUL)\n\t    {\n\t\tif (i == 2)\n\t\t    *d++ = NUL;\n\t\tbreak;\n\t    }\n\t    if (i == 2)\n\t\t*d++ = NUL;\n\t    p = skipwhite(p + 1);\n\t}\n\tif (*argv == NULL)\n\t{\n\t    if (use_shcf)\n\t    {\n\t\t// Account for possible multiple args in p_shcf.\n\t\tp = p_shcf;\n\t\tfor (;;)\n\t\t{\n\t\t    p = skiptowhite(p);\n\t\t    if (*p == NUL)\n\t\t\tbreak;\n\t\t    ++*argc;\n\t\t    p = skipwhite(p);\n\t\t}\n\t    }\n\n\t    *argv = ALLOC_MULT(char *, *argc + 4);\n\t    if (*argv == NULL)\t    // out of memory\n\t\treturn FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Build \"argv[argc]\" from the string \"cmd\".\n * \"argv[argc]\" is set to NULL;\n * Return FAIL when out of memory.\n */\n    int\nbuild_argv_from_string(char_u *cmd, char ***argv, int *argc)\n{\n    char_u\t*cmd_copy;\n    int\t\ti;\n\n    // Make a copy, parsing will modify \"cmd\".\n    cmd_copy = vim_strsave(cmd);\n    if (cmd_copy == NULL\n\t    || mch_parse_cmd(cmd_copy, FALSE, argv, argc) == FAIL)\n    {\n\tvim_free(cmd_copy);\n\treturn FAIL;\n    }\n    for (i = 0; i < *argc; i++)\n\t(*argv)[i] = (char *)vim_strsave((char_u *)(*argv)[i]);\n    (*argv)[*argc] = NULL;\n    vim_free(cmd_copy);\n    return OK;\n}\n\n# if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Build \"argv[argc]\" from the list \"l\".\n * \"argv[argc]\" is set to NULL;\n * Return FAIL when out of memory.\n */\n    int\nbuild_argv_from_list(list_T *l, char ***argv, int *argc)\n{\n    listitem_T  *li;\n    char_u\t*s;\n\n    // Pass argv[] to mch_call_shell().\n    *argv = ALLOC_MULT(char *, l->lv_len + 1);\n    if (*argv == NULL)\n\treturn FAIL;\n    *argc = 0;\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string_chk(&li->li_tv);\n\tif (s == NULL)\n\t{\n\t    int i;\n\n\t    for (i = 0; i < *argc; ++i)\n\t\tVIM_CLEAR((*argv)[i]);\n\t    (*argv)[0] = NULL;\n\t    return FAIL;\n\t}\n\t(*argv)[*argc] = (char *)vim_strsave(s);\n\t*argc += 1;\n    }\n    (*argv)[*argc] = NULL;\n    return OK;\n}\n# endif\n#endif\n\n/*\n * Change the behavior of vterm.\n * 0: As usual.\n * 1: Windows 10 version 1809\n *      The bug causes unstable handling of ambiguous width character.\n * 2: Windows 10 version 1903 & 1909\n *      Use the wrong result because each result is different.\n * 3: Windows 10 insider preview (current latest logic)\n */\n    int\nget_special_pty_type(void)\n{\n#ifdef MSWIN\n    return get_conpty_type();\n#else\n    return 0;\n#endif\n}\n", "/* misc2.c */\nint virtual_active(void);\nint getviscol(void);\nint coladvance_force(colnr_T wcol);\nint getviscol2(colnr_T col, colnr_T coladd);\nint coladvance(colnr_T wcol);\nint getvpos(pos_T *pos, colnr_T wcol);\nint inc_cursor(void);\nint inc(pos_T *lp);\nint incl(pos_T *lp);\nint dec_cursor(void);\nint dec(pos_T *lp);\nint decl(pos_T *lp);\nlinenr_T get_cursor_rel_lnum(win_T *wp, linenr_T lnum);\nvoid check_pos(buf_T *buf, pos_T *pos);\nvoid check_cursor_lnum(void);\nvoid check_cursor_col(void);\nvoid check_cursor_col_win(win_T *win);\nvoid check_cursor(void);\nvoid adjust_cursor_col(void);\nint leftcol_changed(void);\nint copy_option_part(char_u **option, char_u *buf, int maxlen, char *sep_chars);\nint vim_isspace(int x);\nint simplify_key(int key, int *modifiers);\nint handle_x_keys(int key);\nchar_u *get_special_key_name(int c, int modifiers);\nint trans_special(char_u **srcp, char_u *dst, int flags, int escape_ks, int *did_simplify);\nint special_to_buf(int key, int modifiers, int escape_ks, char_u *dst);\nint find_special_key(char_u **srcp, int *modp, int flags, int *did_simplify);\nint may_adjust_key_for_ctrl(int modifiers, int key);\nint may_remove_shift_modifier(int modifiers, int key);\nint extract_modifiers(int key, int *modp, int simplify, int *did_simplify);\nint find_special_key_in_table(int c);\nint get_special_key_code(char_u *name);\nchar_u *get_key_name(int i);\nint get_fileformat(buf_T *buf);\nint get_fileformat_force(buf_T *buf, exarg_T *eap);\nvoid set_fileformat(int t, int opt_flags);\nint default_fileformat(void);\nint call_shell(char_u *cmd, int opt);\nint get_real_state(void);\nint after_pathsep(char_u *b, char_u *p);\nint same_directory(char_u *f1, char_u *f2);\nint vim_chdirfile(char_u *fname, char *trigger_autocmd);\nint vim_stat(const char *name, stat_T *stp);\nchar *parse_shape_opt(int what);\nint get_shape_idx(int mouse);\nvoid update_mouseshape(int shape_idx);\nint vim_chdir(char_u *new_dir);\nint get_user_name(char_u *buf, int len);\nvoid free_username(void);\nint filewritable(char_u *fname);\nint get2c(FILE *fd);\nint get3c(FILE *fd);\nint get4c(FILE *fd);\nchar_u *read_string(FILE *fd, int cnt);\nint put_bytes(FILE *fd, long_u nr, int len);\nint mch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc);\nint build_argv_from_string(char_u *cmd, char ***argv, int *argc);\nint build_argv_from_list(list_T *l, char ***argv, int *argc);\nint get_special_pty_type(void);\n/* vim: set ft=c : */\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_yank_zy()\n  new\n  \" this was reading before the start of the line\n  exe \"norm o\\<C-T>\\<Esc>\\<C-V>zy\"\n  bwipe!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\" This was leaving the end of the Visual area beyond the end of a line.\n\" Set 'undolevels' to start a new undo block.\nfunc Test_visual_undo_deletes_last_line()\n  new\n  call setline(1, [\"aaa\", \"ccc\", \"dyd\"])\n  set undolevels=100\n  exe \"normal obbbbbbbbbxbb\\<Esc>\"\n  set undolevels=100\n  /y\n  exe \"normal ggvjfxO\"\n  undo\n  normal gNU\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste()\n  new\n\n  \" v_p overwrites unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vp\n  call assert_equal('f', @\")\n  call assert_equal('f', @-)\n  call assert_equal('bazooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('bazooxxf', getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste_clipboard()\n  CheckFeature clipboard_working\n\n  if has('gui')\n    \" auto select feature breaks tests\n    set guioptions-=a\n  endif\n\n  \" v_P does not overwrite unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxfoo', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfoo', getline(1))\n  normal $vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfobaz', getline(1))\n\n  \" Test for unnamed clipboard\n  set clipboard=unnamed\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  call setreg('*', 'baz')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('baz', @*)\n  call assert_equal('bazxxx', getline(1))\n\n  \" Test for unnamedplus clipboard\n  if has('unnamedplus')\n    set clipboard=unnamedplus\n    call setline(1, ['xxxx'])\n    call setreg('\"', 'foo')\n    call setreg('-', 'bar')\n    call setreg('+', 'baz')\n    normal gg0vP\n    call assert_equal('foo', @\")\n    call assert_equal('bar', @-)\n    call assert_equal('baz', @+)\n    call assert_equal('bazxxx', getline(1))\n  endif\n\n  set clipboard&\n  if has('gui')\n    set guioptions&\n  endif\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * change.c: functions related to changing text\n */\n\n#include \"vim.h\"\n\n/*\n * If the file is readonly, give a warning message with the first change.\n * Don't do this for autocommands.\n * Doesn't use emsg(), because it flushes the macro buffer.\n * If we have undone all changes b_changed will be FALSE, but \"b_did_warn\"\n * will be TRUE.\n * \"col\" is the column for the message; non-zero when in insert mode and\n * 'showmode' is on.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchange_warning(int col)\n{\n    static char *w_readonly = N_(\"W10: Warning: Changing a readonly file\");\n\n    if (curbuf->b_did_warn == FALSE\n\t    && curbufIsChanged() == 0\n\t    && !autocmd_busy\n\t    && curbuf->b_p_ro)\n    {\n\t++curbuf_lock;\n\tapply_autocmds(EVENT_FILECHANGEDRO, NULL, NULL, FALSE, curbuf);\n\t--curbuf_lock;\n\tif (!curbuf->b_p_ro)\n\t    return;\n\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tif (msg_row == Rows - 1)\n\t    msg_col = col;\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts_attr(_(w_readonly), HL_ATTR(HLF_W) | MSG_HIST);\n#ifdef FEAT_EVAL\n\tset_vim_var_string(VV_WARNINGMSG, (char_u *)_(w_readonly), -1);\n#endif\n\tmsg_clr_eos();\n\t(void)msg_end();\n\tif (msg_silent == 0 && !silent_mode\n#ifdef FEAT_EVAL\n\t\t&& time_for_testing != 1\n#endif\n\t\t)\n\t{\n\t    out_flush();\n\t    ui_delay(1002L, TRUE); // give the user time to think about it\n\t}\n\tcurbuf->b_did_warn = TRUE;\n\tredraw_cmdline = FALSE;\t// don't redraw and erase the message\n\tif (msg_row < Rows - 1)\n\t    showmode();\n    }\n}\n\n/*\n * Call this function when something in the current buffer is changed.\n *\n * Most often called through changed_bytes() and changed_lines(), which also\n * mark the area of the display to be redrawn.\n *\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged(void)\n{\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n    if (p_imst == IM_ON_THE_SPOT)\n    {\n\t// The text of the preediting area is inserted, but this doesn't\n\t// mean a change of the buffer yet.  That is delayed until the\n\t// text is committed. (this means preedit becomes empty)\n\tif (im_is_preediting() && !xim_changed_while_preediting)\n\t    return;\n\txim_changed_while_preediting = FALSE;\n    }\n#endif\n\n    if (!curbuf->b_changed)\n    {\n\tint\tsave_msg_scroll = msg_scroll;\n\n\t// Give a warning about changing a read-only file.  This may also\n\t// check-out the file, thus change \"curbuf\"!\n\tchange_warning(0);\n\n\t// Create a swap file if that is wanted.\n\t// Don't do this for \"nofile\" and \"nowrite\" buffer types.\n\tif (curbuf->b_may_swap\n#ifdef FEAT_QUICKFIX\n\t\t&& !bt_dontwrite(curbuf)\n#endif\n\t\t)\n\t{\n\t    int save_need_wait_return = need_wait_return;\n\n\t    need_wait_return = FALSE;\n\t    ml_open_file(curbuf);\n\n\t    // The ml_open_file() can cause an ATTENTION message.\n\t    // Wait two seconds, to make sure the user reads this unexpected\n\t    // message.  Since we could be anywhere, call wait_return() now,\n\t    // and don't let the emsg() set msg_scroll.\n\t    if (need_wait_return && emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(2002L, TRUE);\n\t\twait_return(TRUE);\n\t\tmsg_scroll = save_msg_scroll;\n\t    }\n\t    else\n\t\tneed_wait_return = save_need_wait_return;\n\t}\n\tchanged_internal();\n    }\n    ++CHANGEDTICK(curbuf);\n\n#ifdef FEAT_SEARCH_EXTRA\n    // If a pattern is highlighted, the position may now be invalid.\n    highlight_match = FALSE;\n#endif\n}\n\n/*\n * Internal part of changed(), no user interaction.\n * Also used for recovery.\n */\n    void\nchanged_internal(void)\n{\n    curbuf->b_changed = TRUE;\n    ml_setflags(curbuf);\n    check_status(curbuf);\n    redraw_tabline = TRUE;\n    need_maketitle = TRUE;\t    // set window title later\n}\n\n#ifdef FEAT_EVAL\nstatic long next_listener_id = 0;\n\n/*\n * Check if the change at \"lnum\" is above or overlaps with an existing\n * change. If above then flush changes and invoke listeners.\n */\n    static void\ncheck_recorded_changes(\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnum,\n\tlinenr_T\tlnume,\n\tlong\t\txtra)\n{\n    if (buf->b_recorded_changes != NULL && xtra != 0)\n    {\n\tlistitem_T *li;\n\tlinenr_T    prev_lnum;\n\tlinenr_T    prev_lnume;\n\n\tFOR_ALL_LIST_ITEMS(buf->b_recorded_changes, li)\n\t{\n\t    prev_lnum = (linenr_T)dict_get_number(\n\t\t\t\t      li->li_tv.vval.v_dict, (char_u *)\"lnum\");\n\t    prev_lnume = (linenr_T)dict_get_number(\n\t\t\t\t       li->li_tv.vval.v_dict, (char_u *)\"end\");\n\t    if (prev_lnum >= lnum || prev_lnum > lnume || prev_lnume >= lnum)\n\t    {\n\t\t// the current change is going to make the line number in\n\t\t// the older change invalid, flush now\n\t\tinvoke_listeners(curbuf);\n\t\tbreak;\n\t    }\n\t}\n    }\n}\n\n/*\n * Record a change for listeners added with listener_add().\n * Always for the current buffer.\n */\n    static void\nmay_record_change(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    dict_T\t*dict;\n\n    if (curbuf->b_listener == NULL)\n\treturn;\n\n    // If the new change is going to change the line numbers in already listed\n    // changes, then flush.\n    check_recorded_changes(curbuf, lnum, lnume, xtra);\n\n    if (curbuf->b_recorded_changes == NULL)\n    {\n\tcurbuf->b_recorded_changes = list_alloc();\n\tif (curbuf->b_recorded_changes == NULL)  // out of memory\n\t    return;\n\t++curbuf->b_recorded_changes->lv_refcount;\n\tcurbuf->b_recorded_changes->lv_lock = VAR_FIXED;\n    }\n\n    dict = dict_alloc();\n    if (dict == NULL)\n\treturn;\n    dict_add_number(dict, \"lnum\", (varnumber_T)lnum);\n    dict_add_number(dict, \"end\", (varnumber_T)lnume);\n    dict_add_number(dict, \"added\", (varnumber_T)xtra);\n    dict_add_number(dict, \"col\", (varnumber_T)col + 1);\n\n    list_append_dict(curbuf->b_recorded_changes, dict);\n}\n\n/*\n * listener_add() function\n */\n    void\nf_listener_add(typval_T *argvars, typval_T *rettv)\n{\n    callback_T\tcallback;\n    listener_T\t*lnr;\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 1) == FAIL)\n\treturn;\n\n    callback = get_callback(&argvars[0]);\n    if (callback.cb_name == NULL)\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[1]);\n\tif (buf == NULL)\n\t{\n\t    free_callback(&callback);\n\t    return;\n\t}\n    }\n\n    lnr = ALLOC_CLEAR_ONE(listener_T);\n    if (lnr == NULL)\n    {\n\tfree_callback(&callback);\n\treturn;\n    }\n    lnr->lr_next = buf->b_listener;\n    buf->b_listener = lnr;\n\n    set_callback(&lnr->lr_callback, &callback);\n\n    lnr->lr_id = ++next_listener_id;\n    rettv->vval.v_number = lnr->lr_id;\n}\n\n/*\n * listener_flush() function\n */\n    void\nf_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[0]);\n\tif (buf == NULL)\n\t    return;\n    }\n    invoke_listeners(buf);\n}\n\n\n    static void\nremove_listener(buf_T *buf, listener_T *lnr, listener_T *prev)\n{\n    if (prev != NULL)\n\tprev->lr_next = lnr->lr_next;\n    else\n\tbuf->b_listener = lnr->lr_next;\n    free_callback(&lnr->lr_callback);\n    vim_free(lnr);\n}\n\n/*\n * listener_remove() function\n */\n    void\nf_listener_remove(typval_T *argvars, typval_T *rettv)\n{\n    listener_T\t*lnr;\n    listener_T\t*next;\n    listener_T\t*prev;\n    int\t\tid;\n    buf_T\t*buf;\n\n    if (in_vim9script() && check_for_number_arg(argvars, 0) == FAIL)\n\treturn;\n\n    id = tv_get_number(argvars);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tprev = NULL;\n\tfor (lnr = buf->b_listener; lnr != NULL; lnr = next)\n\t{\n\t    next = lnr->lr_next;\n\t    if (lnr->lr_id == id)\n\t    {\n\t\tif (textwinlock > 0)\n\t\t{\n\t\t    // in invoke_listeners(), clear ID and delete later\n\t\t    lnr->lr_id = 0;\n\t\t    return;\n\t\t}\n\t\tremove_listener(buf, lnr, prev);\n\t\trettv->vval.v_number = 1;\n\t\treturn;\n\t    }\n\t    prev = lnr;\n\t}\n    }\n}\n\n/*\n * Called before inserting a line above \"lnum\"/\"lnum3\" or deleting line \"lnum\"\n * to \"lnume\".\n */\n    void\nmay_invoke_listeners(buf_T *buf, linenr_T lnum, linenr_T lnume, int added)\n{\n    check_recorded_changes(buf, lnum, lnume, added);\n}\n\n/*\n * Called when a sequence of changes is done: invoke listeners added with\n * listener_add().\n */\n    void\ninvoke_listeners(buf_T *buf)\n{\n    listener_T\t*lnr;\n    typval_T\trettv;\n    typval_T\targv[6];\n    listitem_T\t*li;\n    linenr_T\tstart = MAXLNUM;\n    linenr_T\tend = 0;\n    linenr_T\tadded = 0;\n    int\t\tsave_updating_screen = updating_screen;\n    static int\trecursive = FALSE;\n    listener_T\t*next;\n\n    if (buf->b_recorded_changes == NULL  // nothing changed\n\t    || buf->b_listener == NULL   // no listeners\n\t    || recursive)\t\t // already busy\n\treturn;\n    recursive = TRUE;\n\n    // Block messages on channels from being handled, so that they don't make\n    // text changes here.\n    ++updating_screen;\n\n    argv[0].v_type = VAR_NUMBER;\n    argv[0].vval.v_number = buf->b_fnum; // a:bufnr\n\n    FOR_ALL_LIST_ITEMS(buf->b_recorded_changes, li)\n    {\n\tvarnumber_T lnum;\n\n\tlnum = dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"lnum\");\n\tif (start > lnum)\n\t    start = lnum;\n\tlnum = dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"end\");\n\tif (end < lnum)\n\t    end = lnum;\n\tadded += dict_get_number(li->li_tv.vval.v_dict, (char_u *)\"added\");\n    }\n    argv[1].v_type = VAR_NUMBER;\n    argv[1].vval.v_number = start;\n    argv[2].v_type = VAR_NUMBER;\n    argv[2].vval.v_number = end;\n    argv[3].v_type = VAR_NUMBER;\n    argv[3].vval.v_number = added;\n\n    argv[4].v_type = VAR_LIST;\n    argv[4].vval.v_list = buf->b_recorded_changes;\n    ++textwinlock;\n\n    for (lnr = buf->b_listener; lnr != NULL; lnr = lnr->lr_next)\n    {\n\tcall_callback(&lnr->lr_callback, -1, &rettv, 5, argv);\n\tclear_tv(&rettv);\n    }\n\n    // If f_listener_remove() was called may have to remove a listener now.\n    for (lnr = buf->b_listener; lnr != NULL; lnr = next)\n    {\n\tlistener_T\t*prev = NULL;\n\n\tnext = lnr->lr_next;\n\tif (lnr->lr_id == 0)\n\t    remove_listener(buf, lnr, prev);\n\telse\n\t    prev = lnr;\n    }\n\n    --textwinlock;\n    list_unref(buf->b_recorded_changes);\n    buf->b_recorded_changes = NULL;\n\n    if (save_updating_screen)\n\tupdating_screen = TRUE;\n    else\n\tafter_updating_screen(TRUE);\n    recursive = FALSE;\n}\n\n/*\n * Remove all listeners associated with \"buf\".\n */\n    void\nremove_listeners(buf_T *buf)\n{\n    listener_T\t*lnr;\n    listener_T\t*next;\n\n    for (lnr = buf->b_listener; lnr != NULL; lnr = next)\n    {\n\tnext = lnr->lr_next;\n\tfree_callback(&lnr->lr_callback);\n\tvim_free(lnr);\n    }\n    buf->b_listener = NULL;\n}\n#endif\n\n/*\n * Common code for when a change was made.\n * See changed_lines() for the arguments.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    static void\nchanged_common(\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    linenr_T\tlnume,\n    long\txtra)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n    int\t\ti;\n    int\t\tcols;\n    pos_T\t*p;\n    int\t\tadd;\n\n    // mark the buffer as modified\n    changed();\n\n#ifdef FEAT_EVAL\n    may_record_change(lnum, col, lnume, xtra);\n#endif\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff && diff_internal())\n\tcurtab->tp_diff_update = TRUE;\n#endif\n\n    // set the '. mark\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n    {\n\tcurbuf->b_last_change.lnum = lnum;\n\tcurbuf->b_last_change.col = col;\n\n\t// Create a new entry if a new undo-able change was started or we\n\t// don't have an entry yet.\n\tif (curbuf->b_new_change || curbuf->b_changelistlen == 0)\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\tadd = TRUE;\n\t    else\n\t    {\n\t\t// Don't create a new entry when the line number is the same\n\t\t// as the last one and the column is not too far away.  Avoids\n\t\t// creating many entries for typing \"xxxxx\".\n\t\tp = &curbuf->b_changelist[curbuf->b_changelistlen - 1];\n\t\tif (p->lnum != lnum)\n\t\t    add = TRUE;\n\t\telse\n\t\t{\n\t\t    cols = comp_textwidth(FALSE);\n\t\t    if (cols == 0)\n\t\t\tcols = 79;\n\t\t    add = (p->col + cols < col || col + cols < p->col);\n\t\t}\n\t    }\n\t    if (add)\n\t    {\n\t\t// This is the first of a new sequence of undo-able changes\n\t\t// and it's at some distance of the last change.  Use a new\n\t\t// position in the changelist.\n\t\tcurbuf->b_new_change = FALSE;\n\n\t\tif (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // changelist is full: remove oldest entry\n\t\t    curbuf->b_changelistlen = JUMPLISTSIZE - 1;\n\t\t    mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1,\n\t\t\t\t\t  sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t    FOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t    {\n\t\t\t// Correct position in changelist for other windows on\n\t\t\t// this buffer.\n\t\t\tif (wp->w_buffer == curbuf && wp->w_changelistidx > 0)\n\t\t\t    --wp->w_changelistidx;\n\t\t    }\n\t\t}\n\t\tFOR_ALL_TAB_WINDOWS(tp, wp)\n\t\t{\n\t\t    // For other windows, if the position in the changelist is\n\t\t    // at the end it stays at the end.\n\t\t    if (wp->w_buffer == curbuf\n\t\t\t    && wp->w_changelistidx == curbuf->b_changelistlen)\n\t\t\t++wp->w_changelistidx;\n\t\t}\n\t\t++curbuf->b_changelistlen;\n\t    }\n\t}\n\tcurbuf->b_changelist[curbuf->b_changelistlen - 1] =\n\t\t\t\t\t\t\tcurbuf->b_last_change;\n\t// The current window is always after the last change, so that \"g,\"\n\t// takes you back to it.\n\tcurwin->w_changelistidx = curbuf->b_changelistlen;\n    }\n\n    if (VIsual_active)\n\tcheck_visual_pos();\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n    {\n\tif (wp->w_buffer == curbuf)\n\t{\n#ifdef FEAT_FOLDING\n\t    linenr_T last = lnume + xtra - 1;  // last line after the change\n#endif\n\t    // Mark this window to be redrawn later.\n\t    if (wp->w_redr_type < VALID)\n\t\twp->w_redr_type = VALID;\n\n\t    // Check if a change in the buffer has invalidated the cached\n\t    // values for the cursor.\n#ifdef FEAT_FOLDING\n\t    // Update the folds for this window.  Can't postpone this, because\n\t    // a following operator might work on the whole fold: \">>dd\".\n\t    foldUpdate(wp, lnum, last);\n\n\t    // The change may cause lines above or below the change to become\n\t    // included in a fold.  Set lnum/lnume to the first/last line that\n\t    // might be displayed differently.\n\t    // Set w_cline_folded here as an efficient way to update it when\n\t    // inserting lines just above a closed fold.\n\t    i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == lnum)\n\t\twp->w_cline_folded = i;\n\t    i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL);\n\t    if (wp->w_cursor.lnum == last)\n\t\twp->w_cline_folded = i;\n\n\t    // If the changed line is in a range of previously folded lines,\n\t    // compare with the first line in that range.\n\t    if (wp->w_cursor.lnum <= lnum)\n\t    {\n\t\ti = find_wl_entry(wp, lnum);\n\t\tif (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum)\n\t\t    changed_line_abv_curs_win(wp);\n\t    }\n#endif\n\t    if (wp->w_cursor.lnum > lnum)\n\t\tchanged_line_abv_curs_win(wp);\n\t    else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col)\n\t\tchanged_cline_bef_curs_win(wp);\n\t    if (wp->w_botline >= lnum)\n\t    {\n\t\tif (xtra < 0)\n\t\t    invalidate_botline_win(wp);\n\t\telse\n\t\t    // Assume that botline doesn't change (inserted lines make\n\t\t    // other lines scroll down below botline).\n\t\t    approximate_botline_win(wp);\n\t    }\n\n\t    // Check if any w_lines[] entries have become invalid.\n\t    // For entries below the change: Correct the lnums for\n\t    // inserted/deleted lines.  Makes it possible to stop displaying\n\t    // after the change.\n\t    for (i = 0; i < wp->w_lines_valid; ++i)\n\t\tif (wp->w_lines[i].wl_valid)\n\t\t{\n\t\t    if (wp->w_lines[i].wl_lnum >= lnum)\n\t\t    {\n\t\t\tif (wp->w_lines[i].wl_lnum < lnume)\n\t\t\t{\n\t\t\t    // line included in change\n\t\t\t    wp->w_lines[i].wl_valid = FALSE;\n\t\t\t}\n\t\t\telse if (xtra != 0)\n\t\t\t{\n\t\t\t    // line below change\n\t\t\t    wp->w_lines[i].wl_lnum += xtra;\n#ifdef FEAT_FOLDING\n\t\t\t    wp->w_lines[i].wl_lastlnum += xtra;\n#endif\n\t\t\t}\n\t\t    }\n#ifdef FEAT_FOLDING\n\t\t    else if (wp->w_lines[i].wl_lastlnum >= lnum)\n\t\t    {\n\t\t\t// change somewhere inside this range of folded lines,\n\t\t\t// may need to be redrawn\n\t\t\twp->w_lines[i].wl_valid = FALSE;\n\t\t    }\n#endif\n\t\t}\n\n#ifdef FEAT_FOLDING\n\t    // Take care of side effects for setting w_topline when folds have\n\t    // changed.  Esp. when the buffer was changed in another window.\n\t    if (hasAnyFolding(wp))\n\t\tset_topline(wp, wp->w_topline);\n#endif\n\t    // If lines have been added or removed, relative numbering always\n\t    // requires a redraw.\n\t    if (wp->w_p_rnu && xtra != 0)\n\t    {\n\t\twp->w_last_cursor_lnum_rnu = 0;\n\t\tredraw_win_later(wp, VALID);\n\t    }\n#ifdef FEAT_SYN_HL\n\t    // Cursor line highlighting probably need to be updated with\n\t    // \"VALID\" if it's below the change.\n\t    // If the cursor line is inside the change we need to redraw more.\n\t    if (wp->w_p_cul)\n\t    {\n\t\tif (xtra == 0)\n\t\t    redraw_win_later(wp, VALID);\n\t\telse if (lnum <= wp->w_last_cursorline)\n\t\t    redraw_win_later(wp, SOME_VALID);\n\t    }\n#endif\n\t}\n    }\n\n    // Call update_screen() later, which checks out what needs to be redrawn,\n    // since it notices b_mod_set and then uses b_mod_*.\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n\n    // when the cursor line is changed always trigger CursorMoved\n    if (lnum <= curwin->w_cursor.lnum\n\t\t && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum)\n\tlast_cursormoved.lnum = 0;\n}\n\n    static void\nchangedOneline(buf_T *buf, linenr_T lnum)\n{\n    if (buf->b_mod_set)\n    {\n\t// find the maximum area that must be redisplayed\n\tif (lnum < buf->b_mod_top)\n\t    buf->b_mod_top = lnum;\n\telse if (lnum >= buf->b_mod_bot)\n\t    buf->b_mod_bot = lnum + 1;\n    }\n    else\n    {\n\t// set the area that must be redisplayed to one line\n\tbuf->b_mod_set = TRUE;\n\tbuf->b_mod_top = lnum;\n\tbuf->b_mod_bot = lnum + 1;\n\tbuf->b_mod_xlines = 0;\n    }\n}\n\n/*\n * Changed bytes within a single line for the current buffer.\n * - marks the windows on this buffer to be redisplayed\n * - marks the buffer changed by calling changed()\n * - invalidates cached values\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged_bytes(linenr_T lnum, colnr_T col)\n{\n    changedOneline(curbuf, lnum);\n    changed_common(lnum, col, lnum + 1, 0L);\n\n#ifdef FEAT_DIFF\n    // Diff highlighting in other diff windows may need to be updated too.\n    if (curwin->w_p_diff)\n    {\n\twin_T\t    *wp;\n\tlinenr_T    wlnum;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_diff && wp != curwin)\n\t    {\n\t\tredraw_win_later(wp, VALID);\n\t\twlnum = diff_lnum_win(lnum, wp);\n\t\tif (wlnum > 0)\n\t\t    changedOneline(wp->w_buffer, wlnum);\n\t    }\n    }\n#endif\n}\n\n/*\n * Like changed_bytes() but also adjust text properties for \"added\" bytes.\n * When \"added\" is negative text was deleted.\n */\n    void\ninserted_bytes(linenr_T lnum, colnr_T col, int added UNUSED)\n{\n#ifdef FEAT_PROP_POPUP\n    if (curbuf->b_has_textprop && added != 0)\n\tadjust_prop_columns(lnum, col, added, 0);\n#endif\n\n    changed_bytes(lnum, col);\n}\n\n/*\n * Appended \"count\" lines below line \"lnum\" in the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * Takes care of marking the buffer to be redrawn and sets the changed flag.\n */\n    void\nappended_lines(linenr_T lnum, long count)\n{\n    changed_lines(lnum + 1, 0, lnum + 1, count);\n}\n\n/*\n * Like appended_lines(), but adjust marks first.\n */\n    void\nappended_lines_mark(linenr_T lnum, long count)\n{\n    // Skip mark_adjust when adding a line after the last one, there can't\n    // be marks there. But it's still needed in diff mode.\n    if (lnum + count < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t    || curwin->w_p_diff\n#endif\n\t)\n\tmark_adjust(lnum + 1, (linenr_T)MAXLNUM, count, 0L);\n    changed_lines(lnum + 1, 0, lnum + 1, count);\n}\n\n/*\n * Deleted \"count\" lines at line \"lnum\" in the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * Takes care of marking the buffer to be redrawn and sets the changed flag.\n */\n    void\ndeleted_lines(linenr_T lnum, long count)\n{\n    changed_lines(lnum, 0, lnum + count, -count);\n}\n\n/*\n * Like deleted_lines(), but adjust marks first.\n * Make sure the cursor is on a valid line before calling, a GUI callback may\n * be triggered to display the cursor.\n */\n    void\ndeleted_lines_mark(linenr_T lnum, long count)\n{\n    mark_adjust(lnum, (linenr_T)(lnum + count - 1), (long)MAXLNUM, -count);\n    changed_lines(lnum, 0, lnum + count, -count);\n}\n\n/*\n * Marks the area to be redrawn after a change.\n */\n    void\nchanged_lines_buf(\n    buf_T\t*buf,\n    linenr_T\tlnum,\t    // first line with change\n    linenr_T\tlnume,\t    // line below last changed line\n    long\txtra)\t    // number of extra lines (negative when deleting)\n{\n    if (buf->b_mod_set)\n    {\n\t// find the maximum area that must be redisplayed\n\tif (lnum < buf->b_mod_top)\n\t    buf->b_mod_top = lnum;\n\tif (lnum < buf->b_mod_bot)\n\t{\n\t    // adjust old bot position for xtra lines\n\t    buf->b_mod_bot += xtra;\n\t    if (buf->b_mod_bot < lnum)\n\t\tbuf->b_mod_bot = lnum;\n\t}\n\tif (lnume + xtra > buf->b_mod_bot)\n\t    buf->b_mod_bot = lnume + xtra;\n\tbuf->b_mod_xlines += xtra;\n    }\n    else\n    {\n\t// set the area that must be redisplayed\n\tbuf->b_mod_set = TRUE;\n\tbuf->b_mod_top = lnum;\n\tbuf->b_mod_bot = lnume + xtra;\n\tbuf->b_mod_xlines = xtra;\n    }\n}\n\n/*\n * Changed lines for the current buffer.\n * Must be called AFTER the change and after mark_adjust().\n * - mark the buffer changed by calling changed()\n * - mark the windows on this buffer to be redisplayed\n * - invalidate cached values\n * \"lnum\" is the first line that needs displaying, \"lnume\" the first line\n * below the changed lines (BEFORE the change).\n * When only inserting lines, \"lnum\" and \"lnume\" are equal.\n * Takes care of calling changed() and updating b_mod_*.\n * Careful: may trigger autocommands that reload the buffer.\n */\n    void\nchanged_lines(\n    linenr_T\tlnum,\t    // first line with change\n    colnr_T\tcol,\t    // column in first line with change\n    linenr_T\tlnume,\t    // line below last changed line\n    long\txtra)\t    // number of extra lines (negative when deleting)\n{\n    changed_lines_buf(curbuf, lnum, lnume, xtra);\n\n#ifdef FEAT_DIFF\n    if (xtra == 0 && curwin->w_p_diff && !diff_internal())\n    {\n\t// When the number of lines doesn't change then mark_adjust() isn't\n\t// called and other diff buffers still need to be marked for\n\t// displaying.\n\twin_T\t    *wp;\n\tlinenr_T    wlnum;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_p_diff && wp != curwin)\n\t    {\n\t\tredraw_win_later(wp, VALID);\n\t\twlnum = diff_lnum_win(lnum, wp);\n\t\tif (wlnum > 0)\n\t\t    changed_lines_buf(wp->w_buffer, wlnum,\n\t\t\t\t\t\t    lnume - lnum + wlnum, 0L);\n\t    }\n    }\n#endif\n\n    changed_common(lnum, col, lnume, xtra);\n}\n\n/*\n * Called when the changed flag must be reset for buffer \"buf\".\n * When \"ff\" is TRUE also reset 'fileformat'.\n * When \"always_inc_changedtick\" is TRUE b:changedtick is incremented also when\n * the changed flag was off.\n */\n    void\nunchanged(buf_T *buf, int ff, int always_inc_changedtick)\n{\n    if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))\n    {\n\tbuf->b_changed = 0;\n\tml_setflags(buf);\n\tif (ff)\n\t    save_file_ff(buf);\n\tcheck_status(buf);\n\tredraw_tabline = TRUE;\n\tneed_maketitle = TRUE;\t    // set window title later\n\t++CHANGEDTICK(buf);\n    }\n    else if (always_inc_changedtick)\n\t++CHANGEDTICK(buf);\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_unmodified(buf);\n#endif\n}\n\n/*\n * Save the current values of 'fileformat' and 'fileencoding', so that we know\n * the file must be considered changed when the value is different.\n */\n    void\nsave_file_ff(buf_T *buf)\n{\n    buf->b_start_ffc = *buf->b_p_ff;\n    buf->b_start_eol = buf->b_p_eol;\n    buf->b_start_bomb = buf->b_p_bomb;\n\n    // Only use free/alloc when necessary, they take time.\n    if (buf->b_start_fenc == NULL\n\t\t\t     || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0)\n    {\n\tvim_free(buf->b_start_fenc);\n\tbuf->b_start_fenc = vim_strsave(buf->b_p_fenc);\n    }\n}\n\n/*\n * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value\n * from when editing started (save_file_ff() called).\n * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was\n * changed and 'binary' is not set.\n * Also when 'endofline' was changed and 'fixeol' is not set.\n * When \"ignore_empty\" is true don't consider a new, empty buffer to be\n * changed.\n */\n    int\nfile_ff_differs(buf_T *buf, int ignore_empty)\n{\n    // In a buffer that was never loaded the options are not valid.\n    if (buf->b_flags & BF_NEVERLOADED)\n\treturn FALSE;\n    if (ignore_empty\n\t    && (buf->b_flags & BF_NEW)\n\t    && buf->b_ml.ml_line_count == 1\n\t    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)\n\treturn FALSE;\n    if (buf->b_start_ffc != *buf->b_p_ff)\n\treturn TRUE;\n    if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol)\n\treturn TRUE;\n    if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)\n\treturn TRUE;\n    if (buf->b_start_fenc == NULL)\n\treturn (*buf->b_p_fenc != NUL);\n    return (STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0);\n}\n\n/*\n * Insert string \"p\" at the cursor position.  Stops at a NUL byte.\n * Handles Replace mode and multi-byte characters.\n */\n    void\nins_bytes(char_u *p)\n{\n    ins_bytes_len(p, (int)STRLEN(p));\n}\n\n/*\n * Insert string \"p\" with length \"len\" at the cursor position.\n * Handles Replace mode and multi-byte characters.\n */\n    void\nins_bytes_len(char_u *p, int len)\n{\n    int\t\ti;\n    int\t\tn;\n\n    if (has_mbyte)\n\tfor (i = 0; i < len; i += n)\n\t{\n\t    if (enc_utf8)\n\t\t// avoid reading past p[len]\n\t\tn = utfc_ptr2len_len(p + i, len - i);\n\t    else\n\t\tn = (*mb_ptr2len)(p + i);\n\t    ins_char_bytes(p + i, n);\n\t}\n    else\n\tfor (i = 0; i < len; ++i)\n\t    ins_char(p[i]);\n}\n\n/*\n * Insert or replace a single character at the cursor position.\n * When in MODE_REPLACE or MODE_VREPLACE state, replace any existing character.\n * Caller must have prepared for undo.\n * For multi-byte characters we get the whole character, the caller must\n * convert bytes to a character.\n */\n    void\nins_char(int c)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tn = (*mb_char2bytes)(c, buf);\n\n    // When \"c\" is 0x100, 0x200, etc. we don't want to insert a NUL byte.\n    // Happens for CTRL-Vu9900.\n    if (buf[0] == 0)\n\tbuf[0] = '\\n';\n\n    ins_char_bytes(buf, n);\n}\n\n    void\nins_char_bytes(char_u *buf, int charlen)\n{\n    int\t\tc = buf[0];\n    int\t\tnewlen;\t\t// nr of bytes inserted\n    int\t\toldlen;\t\t// nr of bytes deleted (0 when not replacing)\n    char_u\t*p;\n    char_u\t*newp;\n    char_u\t*oldp;\n    int\t\tlinelen;\t// length of old line including NUL\n    colnr_T\tcol;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\ti;\n\n    // Break tabs if needed.\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance_force(getviscol());\n\n    col = curwin->w_cursor.col;\n    oldp = ml_get(lnum);\n    linelen = (int)STRLEN(oldp) + 1;\n\n    // The lengths default to the values for when not replacing.\n    oldlen = 0;\n    newlen = charlen;\n\n    if (State & REPLACE_FLAG)\n    {\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    colnr_T\tnew_vcol = 0;   // init for GCC\n\t    colnr_T\tvcol;\n\t    int\t\told_list;\n\n\t    // Disable 'list' temporarily, unless 'cpo' contains the 'L' flag.\n\t    // Returns the old value of list, so when finished,\n\t    // curwin->w_p_list should be set back to this.\n\t    old_list = curwin->w_p_list;\n\t    if (old_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t\tcurwin->w_p_list = FALSE;\n\n\t    // In virtual replace mode each character may replace one or more\n\t    // characters (zero if it's a TAB).  Count the number of bytes to\n\t    // be deleted to make room for the new character, counting screen\n\t    // cells.  May result in adding spaces to fill a gap.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &vcol, NULL);\n\t    new_vcol = vcol + chartabsize(buf, vcol);\n\t    while (oldp[col + oldlen] != NUL && vcol < new_vcol)\n\t    {\n\t\tvcol += chartabsize(oldp + col + oldlen, vcol);\n\t\t// Don't need to remove a TAB that takes us to the right\n\t\t// position.\n\t\tif (vcol > new_vcol && oldp[col + oldlen] == TAB)\n\t\t    break;\n\t\toldlen += (*mb_ptr2len)(oldp + col + oldlen);\n\t\t// Deleted a bit too much, insert spaces.\n\t\tif (vcol > new_vcol)\n\t\t    newlen += vcol - new_vcol;\n\t    }\n\t    curwin->w_p_list = old_list;\n\t}\n\telse if (oldp[col] != NUL)\n\t{\n\t    // normal replace\n\t    oldlen = (*mb_ptr2len)(oldp + col);\n\t}\n\n\n\t// Push the replaced bytes onto the replace stack, so that they can be\n\t// put back when BS is used.  The bytes of a multi-byte character are\n\t// done the other way around, so that the first byte is popped off\n\t// first (it tells the byte length of the character).\n\treplace_push(NUL);\n\tfor (i = 0; i < oldlen; ++i)\n\t{\n\t    if (has_mbyte)\n\t\ti += replace_push_mb(oldp + col + i) - 1;\n\t    else\n\t\treplace_push(oldp[col + i]);\n\t}\n    }\n\n    newp = alloc(linelen + newlen - oldlen);\n    if (newp == NULL)\n\treturn;\n\n    // Copy bytes before the cursor.\n    if (col > 0)\n\tmch_memmove(newp, oldp, (size_t)col);\n\n    // Copy bytes after the changed character(s).\n    p = newp + col;\n    if (linelen > col + oldlen)\n\tmch_memmove(p + newlen, oldp + col + oldlen,\n\t\t\t\t\t    (size_t)(linelen - col - oldlen));\n\n    // Insert or overwrite the new character.\n    mch_memmove(p, buf, charlen);\n    i = charlen;\n\n    // Fill with spaces when necessary.\n    while (i < newlen)\n\tp[i++] = ' ';\n\n    // Replace the line in the buffer.\n    ml_replace(lnum, newp, FALSE);\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, col, newlen - oldlen);\n\n    // If we're in Insert or Replace mode and 'showmatch' is set, then briefly\n    // show the match for right parens and braces.\n    if (p_sm && (State & MODE_INSERT)\n\t    && msg_silent == 0\n\t    && !ins_compl_active())\n    {\n\tif (has_mbyte)\n\t    showmatch(mb_ptr2char(buf));\n\telse\n\t    showmatch(c);\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (!p_ri || (State & REPLACE_FLAG))\n#endif\n    {\n\t// Normal insert: move cursor right\n\tcurwin->w_cursor.col += charlen;\n    }\n\n    // TODO: should try to update w_row here, to avoid recomputing it later.\n}\n\n/*\n * Insert a string at the cursor position.\n * Note: Does NOT handle Replace mode.\n * Caller must have prepared for undo.\n */\n    void\nins_str(char_u *s)\n{\n    char_u\t*oldp, *newp;\n    int\t\tnewlen = (int)STRLEN(s);\n    int\t\toldlen;\n    colnr_T\tcol;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance_force(getviscol());\n\n    col = curwin->w_cursor.col;\n    oldp = ml_get(lnum);\n    oldlen = (int)STRLEN(oldp);\n\n    newp = alloc(oldlen + newlen + 1);\n    if (newp == NULL)\n\treturn;\n    if (col > 0)\n\tmch_memmove(newp, oldp, (size_t)col);\n    mch_memmove(newp + col, s, (size_t)newlen);\n    mch_memmove(newp + col + newlen, oldp + col, (size_t)(oldlen - col + 1));\n    ml_replace(lnum, newp, FALSE);\n    inserted_bytes(lnum, col, newlen);\n    curwin->w_cursor.col += newlen;\n}\n\n/*\n * Delete one character under the cursor.\n * If \"fixpos\" is TRUE, don't leave the cursor on the NUL after the line.\n * Caller must have prepared for undo.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ndel_char(int fixpos)\n{\n    if (has_mbyte)\n    {\n\t// Make sure the cursor is at the start of a character.\n\tmb_adjust_cursor();\n\tif (*ml_get_cursor() == NUL)\n\t    return FAIL;\n\treturn del_chars(1L, fixpos);\n    }\n    return del_bytes(1L, fixpos, TRUE);\n}\n\n/*\n * Like del_bytes(), but delete characters instead of bytes.\n */\n    int\ndel_chars(long count, int fixpos)\n{\n    long\tbytes = 0;\n    long\ti;\n    char_u\t*p;\n    int\t\tl;\n\n    p = ml_get_cursor();\n    for (i = 0; i < count && *p != NUL; ++i)\n    {\n\tl = (*mb_ptr2len)(p);\n\tbytes += l;\n\tp += l;\n    }\n    return del_bytes(bytes, fixpos, TRUE);\n}\n\n/*\n * Delete \"count\" bytes under the cursor.\n * If \"fixpos\" is TRUE, don't leave the cursor on the NUL after the line.\n * Caller must have prepared for undo.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndel_bytes(\n    long\tcount,\n    int\t\tfixpos_arg,\n    int\t\tuse_delcombine UNUSED)\t    // 'delcombine' option applies\n{\n    char_u\t*oldp, *newp;\n    colnr_T\toldlen;\n    colnr_T\tnewlen;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    int\t\talloc_newp;\n    long\tmovelen;\n    int\t\tfixpos = fixpos_arg;\n\n    oldp = ml_get(lnum);\n    oldlen = (int)STRLEN(oldp);\n\n    // Can't do anything when the cursor is on the NUL after the line.\n    if (col >= oldlen)\n\treturn FAIL;\n\n    // If \"count\" is zero there is nothing to do.\n    if (count == 0)\n\treturn OK;\n\n    // If \"count\" is negative the caller must be doing something wrong.\n    if (count < 1)\n    {\n\tsiemsg(e_invalid_count_for_del_bytes_nr, count);\n\treturn FAIL;\n    }\n\n    // If 'delcombine' is set and deleting (less than) one character, only\n    // delete the last combining character.\n    if (p_deco && use_delcombine && enc_utf8\n\t\t\t\t\t && utfc_ptr2len(oldp + col) >= count)\n    {\n\tint\tcc[MAX_MCO];\n\tint\tn;\n\n\t(void)utfc_ptr2char(oldp + col, cc);\n\tif (cc[0] != NUL)\n\t{\n\t    // Find the last composing char, there can be several.\n\t    n = col;\n\t    do\n\t    {\n\t\tcol = n;\n\t\tcount = utf_ptr2len(oldp + n);\n\t\tn += count;\n\t    } while (UTF_COMPOSINGLIKE(oldp + col, oldp + n));\n\t    fixpos = 0;\n\t}\n    }\n\n    // When count is too big, reduce it.\n    movelen = (long)oldlen - (long)col - count + 1; // includes trailing NUL\n    if (movelen <= 1)\n    {\n\t// If we just took off the last character of a non-blank line, and\n\t// fixpos is TRUE, we don't want to end up positioned at the NUL,\n\t// unless \"restart_edit\" is set or 'virtualedit' contains \"onemore\".\n\tif (col > 0 && fixpos && restart_edit == 0\n\t\t\t\t\t      && (get_ve_flags() & VE_ONEMORE) == 0)\n\t{\n\t    --curwin->w_cursor.col;\n\t    curwin->w_cursor.coladd = 0;\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col -=\n\t\t\t    (*mb_head_off)(oldp, oldp + curwin->w_cursor.col);\n\t}\n\tcount = oldlen - col;\n\tmovelen = 1;\n    }\n    newlen = oldlen - count;\n\n    // If the old line has been allocated the deletion can be done in the\n    // existing line. Otherwise a new line has to be allocated\n    // Can't do this when using Netbeans, because we would need to invoke\n    // netbeans_removed(), which deallocates the line.  Let ml_replace() take\n    // care of notifying Netbeans.\n#ifdef FEAT_NETBEANS_INTG\n    if (netbeans_active())\n\talloc_newp = TRUE;\n    else\n#endif\n\talloc_newp = !ml_line_alloced();    // check if oldp was allocated\n    if (!alloc_newp)\n\tnewp = oldp;\t\t\t    // use same allocated memory\n    else\n    {\t\t\t\t\t    // need to allocate a new line\n\tnewp = alloc(newlen + 1);\n\tif (newp == NULL)\n\t    return FAIL;\n\tmch_memmove(newp, oldp, (size_t)col);\n    }\n    mch_memmove(newp + col, oldp + col + count, (size_t)movelen);\n    if (alloc_newp)\n\tml_replace(lnum, newp, FALSE);\n#ifdef FEAT_PROP_POPUP\n    else\n    {\n\t// Also move any following text properties.\n\tif (oldlen + 1 < curbuf->b_ml.ml_line_len)\n\t    mch_memmove(newp + newlen + 1, oldp + oldlen + 1,\n\t\t\t       (size_t)curbuf->b_ml.ml_line_len - oldlen - 1);\n\tcurbuf->b_ml.ml_line_len -= count;\n    }\n#endif\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, col, -count);\n\n    return OK;\n}\n\n/*\n * open_line: Add a new line below or above the current line.\n *\n * For MODE_VREPLACE state, we only add a new line when we get to the end of\n * the file, otherwise we just start replacing the next line.\n *\n * Caller must take care of undo.  Since MODE_VREPLACE may affect any number of\n * lines however, it may call u_save_cursor() again when starting to change a\n * new line.\n * \"flags\": OPENLINE_DELSPACES\tdelete spaces after cursor\n *\t    OPENLINE_DO_COM\tformat comments\n *\t    OPENLINE_KEEPTRAIL\tkeep trailing spaces\n *\t    OPENLINE_MARKFIX\tadjust mark positions after the line break\n *\t    OPENLINE_COM_LIST\tformat comments with list or 2nd line indent\n *\n * \"second_line_indent\": indent for after ^^D in Insert mode or if flag\n *\t\t\t  OPENLINE_COM_LIST\n * \"did_do_comment\" is set to TRUE when intentionally putting the comment\n * leader in fromt of the new line.\n *\n * Return OK for success, FAIL for failure\n */\n    int\nopen_line(\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tflags,\n    int\t\tsecond_line_indent,\n    int\t\t*did_do_comment UNUSED)\n{\n    char_u\t*saved_line;\t\t// copy of the original line\n    char_u\t*next_line = NULL;\t// copy of the next line\n    char_u\t*p_extra = NULL;\t// what goes to next line\n    int\t\tless_cols = 0;\t\t// less columns for mark in new line\n    int\t\tless_cols_off = 0;\t// columns to skip for mark and\n\t\t\t\t\t// textprop adjustment\n    pos_T\told_cursor;\t\t// old cursor position\n    int\t\tnewcol = 0;\t\t// new cursor column\n    int\t\tnewindent = 0;\t\t// auto-indent of the new line\n    int\t\tn;\n    int\t\ttrunc_line = FALSE;\t// truncate current line afterwards\n    int\t\tretval = FAIL;\t\t// return value\n    int\t\textra_len = 0;\t\t// length of p_extra string\n    int\t\tlead_len;\t\t// length of comment leader\n    int\t\tcomment_start = 0;\t// start index of the comment leader\n    char_u\t*lead_flags;\t// position in 'comments' for comment leader\n    char_u\t*leader = NULL;\t\t// copy of comment leader\n    char_u\t*allocated = NULL;\t// allocated memory\n    char_u\t*p;\n    int\t\tsaved_char = NUL;\t// init for GCC\n    pos_T\t*pos;\n#ifdef FEAT_CINDENT\n    int\t\tdo_cindent;\n#endif\n#ifdef FEAT_SMARTINDENT\n    int\t\tdo_si = may_do_si();\n    int\t\tno_si = FALSE;\t\t// reset did_si afterwards\n    int\t\tfirst_char = NUL;\t// init for GCC\n#endif\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    int\t\tvreplace_mode;\n#endif\n    int\t\tdid_append;\t\t// appended a new line\n    int\t\tsaved_pi = curbuf->b_p_pi; // copy of preserveindent setting\n\n    // make a copy of the current line so we can mess with it\n    saved_line = vim_strsave(ml_get_curline());\n    if (saved_line == NULL)\t    // out of memory!\n\treturn FALSE;\n\n    if (State & VREPLACE_FLAG)\n    {\n\t// With MODE_VREPLACE we make a copy of the next line, which we will be\n\t// starting to replace.  First make the new line empty and let vim play\n\t// with the indenting and comment leader to its heart's content.  Then\n\t// we grab what it ended up putting on the new line, put back the\n\t// original line, and call ins_char() to put each new character onto\n\t// the line, replacing what was there before and pushing the right\n\t// stuff onto the replace stack.  -- webb.\n\tif (curwin->w_cursor.lnum < orig_line_count)\n\t    next_line = vim_strsave(ml_get(curwin->w_cursor.lnum + 1));\n\telse\n\t    next_line = vim_strsave((char_u *)\"\");\n\tif (next_line == NULL)\t    // out of memory!\n\t    goto theend;\n\n\t// In MODE_VREPLACE state, a NL replaces the rest of the line, and\n\t// starts replacing the next line, so push all of the characters left\n\t// on the line onto the replace stack.  We'll push any other characters\n\t// that might be replaced at the start of the next line (due to\n\t// autoindent etc) a bit later.\n\treplace_push(NUL);  // Call twice because BS over NL expects it\n\treplace_push(NUL);\n\tp = saved_line + curwin->w_cursor.col;\n\twhile (*p != NUL)\n\t{\n\t    if (has_mbyte)\n\t\tp += replace_push_mb(p);\n\t    else\n\t\treplace_push(*p++);\n\t}\n\tsaved_line[curwin->w_cursor.col] = NUL;\n    }\n\n    if ((State & MODE_INSERT) && (State & VREPLACE_FLAG) == 0)\n    {\n\tp_extra = saved_line + curwin->w_cursor.col;\n#ifdef FEAT_SMARTINDENT\n\tif (do_si)\t\t// need first char after new line break\n\t{\n\t    p = skipwhite(p_extra);\n\t    first_char = *p;\n\t}\n#endif\n\textra_len = (int)STRLEN(p_extra);\n\tsaved_char = *p_extra;\n\t*p_extra = NUL;\n    }\n\n    u_clearline();\t\t// cannot do \"U\" command when adding lines\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n#endif\n    ai_col = 0;\n\n    // If we just did an auto-indent, then we didn't type anything on\n    // the prior line, and it should be truncated.  Do this even if 'ai' is not\n    // set because automatically inserting a comment leader also sets did_ai.\n    if (dir == FORWARD && did_ai)\n\ttrunc_line = TRUE;\n\n    // If 'autoindent' and/or 'smartindent' is set, try to figure out what\n    // indent to use for the new line.\n    if (curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t|| do_si\n#endif\n\t\t\t\t\t    )\n    {\n\t// count white space on current line\n#ifdef FEAT_VARTABS\n\tnewindent = get_indent_str_vtab(saved_line, curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n\tnewindent = get_indent_str(saved_line, (int)curbuf->b_p_ts, FALSE);\n#endif\n\tif (newindent == 0 && !(flags & OPENLINE_COM_LIST))\n\t    newindent = second_line_indent; // for ^^D command in insert mode\n\n#ifdef FEAT_SMARTINDENT\n\t// Do smart indenting.\n\t// In insert/replace mode (only when dir == FORWARD)\n\t// we may move some text to the next line. If it starts with '{'\n\t// don't add an indent. Fixes inserting a NL before '{' in line\n\t//\t\"if (condition) {\"\n\tif (!trunc_line && do_si && *saved_line != NUL\n\t\t\t\t    && (p_extra == NULL || first_char != '{'))\n\t{\n\t    char_u  *ptr;\n\t    char_u  last_char;\n\n\t    old_cursor = curwin->w_cursor;\n\t    ptr = saved_line;\n\t    if (flags & OPENLINE_DO_COM)\n\t\tlead_len = get_leader_len(ptr, NULL, FALSE, TRUE);\n\t    else\n\t\tlead_len = 0;\n\t    if (dir == FORWARD)\n\t    {\n\t\t// Skip preprocessor directives, unless they are\n\t\t// recognised as comments.\n\t\tif ( lead_len == 0 && ptr[0] == '#')\n\t\t{\n\t\t    while (ptr[0] == '#' && curwin->w_cursor.lnum > 1)\n\t\t\tptr = ml_get(--curwin->w_cursor.lnum);\n\t\t    newindent = get_indent();\n\t\t}\n\t\tif (flags & OPENLINE_DO_COM)\n\t\t    lead_len = get_leader_len(ptr, NULL, FALSE, TRUE);\n\t\telse\n\t\t    lead_len = 0;\n\t\tif (lead_len > 0)\n\t\t{\n\t\t    // This case gets the following right:\n\t\t    //\t    /*\n\t\t    //\t     * A comment (read '\\' as '/').\n\t\t    //\t     */\n\t\t    // #define IN_THE_WAY\n\t\t    //\t    This should line up here;\n\t\t    p = skipwhite(ptr);\n\t\t    if (p[0] == '/' && p[1] == '*')\n\t\t\tp++;\n\t\t    if (p[0] == '*')\n\t\t    {\n\t\t\tfor (p++; *p; p++)\n\t\t\t{\n\t\t\t    if (p[0] == '/' && p[-1] == '*')\n\t\t\t    {\n\t\t\t\t// End of C comment, indent should line up\n\t\t\t\t// with the line containing the start of\n\t\t\t\t// the comment\n\t\t\t\tcurwin->w_cursor.col = (colnr_T)(p - ptr);\n\t\t\t\tif ((pos = findmatch(NULL, NUL)) != NULL)\n\t\t\t\t{\n\t\t\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t\t\t    newindent = get_indent();\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse\t// Not a comment line\n\t\t{\n\t\t    // Find last non-blank in line\n\t\t    p = ptr + STRLEN(ptr) - 1;\n\t\t    while (p > ptr && VIM_ISWHITE(*p))\n\t\t\t--p;\n\t\t    last_char = *p;\n\n\t\t    // find the character just before the '{' or ';'\n\t\t    if (last_char == '{' || last_char == ';')\n\t\t    {\n\t\t\tif (p > ptr)\n\t\t\t    --p;\n\t\t\twhile (p > ptr && VIM_ISWHITE(*p))\n\t\t\t    --p;\n\t\t    }\n\t\t    // Try to catch lines that are split over multiple\n\t\t    // lines.  eg:\n\t\t    //\t    if (condition &&\n\t\t    //\t\t\tcondition) {\n\t\t    //\t\tShould line up here!\n\t\t    //\t    }\n\t\t    if (*p == ')')\n\t\t    {\n\t\t\tcurwin->w_cursor.col = (colnr_T)(p - ptr);\n\t\t\tif ((pos = findmatch(NULL, '(')) != NULL)\n\t\t\t{\n\t\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t\t    newindent = get_indent();\n\t\t\t    ptr = ml_get_curline();\n\t\t\t}\n\t\t    }\n\t\t    // If last character is '{' do indent, without\n\t\t    // checking for \"if\" and the like.\n\t\t    if (last_char == '{')\n\t\t    {\n\t\t\tdid_si = TRUE;\t// do indent\n\t\t\tno_si = TRUE;\t// don't delete it when '{' typed\n\t\t    }\n\t\t    // Look for \"if\" and the like, use 'cinwords'.\n\t\t    // Don't do this if the previous line ended in ';' or\n\t\t    // '}'.\n\t\t    else if (last_char != ';' && last_char != '}'\n\t\t\t\t\t\t       && cin_is_cinword(ptr))\n\t\t\tdid_si = TRUE;\n\t\t}\n\t    }\n\t    else // dir == BACKWARD\n\t    {\n\t\t// Skip preprocessor directives, unless they are\n\t\t// recognised as comments.\n\t\tif (lead_len == 0 && ptr[0] == '#')\n\t\t{\n\t\t    int was_backslashed = FALSE;\n\n\t\t    while ((ptr[0] == '#' || was_backslashed) &&\n\t\t\t curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t\t    {\n\t\t\tif (*ptr && ptr[STRLEN(ptr) - 1] == '\\\\')\n\t\t\t    was_backslashed = TRUE;\n\t\t\telse\n\t\t\t    was_backslashed = FALSE;\n\t\t\tptr = ml_get(++curwin->w_cursor.lnum);\n\t\t    }\n\t\t    if (was_backslashed)\n\t\t\tnewindent = 0;\t    // Got to end of file\n\t\t    else\n\t\t\tnewindent = get_indent();\n\t\t}\n\t\tp = skipwhite(ptr);\n\t\tif (*p == '}')\t    // if line starts with '}': do indent\n\t\t    did_si = TRUE;\n\t\telse\t\t    // can delete indent when '{' typed\n\t\t    can_si_back = TRUE;\n\t    }\n\t    curwin->w_cursor = old_cursor;\n\t}\n\tif (do_si)\n\t    can_si = TRUE;\n#endif // FEAT_SMARTINDENT\n\n\tdid_ai = TRUE;\n    }\n\n#ifdef FEAT_CINDENT\n    // May do indenting after opening a new line.\n    do_cindent = !p_paste && (curbuf->b_p_cin\n# ifdef FEAT_EVAL\n\t\t    || *curbuf->b_p_inde != NUL\n# endif\n\t\t)\n\t    && in_cinkeys(dir == FORWARD\n\t\t? KEY_OPEN_FORW\n\t\t: KEY_OPEN_BACK, ' ', linewhite(curwin->w_cursor.lnum));\n#endif\n\n    // Find out if the current line starts with a comment leader.\n    // This may then be inserted in front of the new line.\n    end_comment_pending = NUL;\n    if (flags & OPENLINE_DO_COM)\n    {\n\tlead_len = get_leader_len(saved_line, &lead_flags,\n\t\t\t\t\t\t\tdir == BACKWARD, TRUE);\n#ifdef FEAT_CINDENT\n\tif (lead_len == 0 && curbuf->b_p_cin && do_cindent && dir == FORWARD\n\t\t\t\t\t&& !has_format_option(FO_NO_OPEN_COMS))\n\t{\n\t    // Check for a line comment after code.\n\t    comment_start = check_linecomment(saved_line);\n\t    if (comment_start != MAXCOL)\n\t    {\n\t\tlead_len = get_leader_len(saved_line + comment_start,\n\t\t\t\t\t\t     &lead_flags, FALSE, TRUE);\n\t\tif (lead_len != 0)\n\t\t{\n\t\t    lead_len += comment_start;\n\t\t    if (did_do_comment != NULL)\n\t\t\t*did_do_comment = TRUE;\n\t\t}\n\t    }\n\t}\n#endif\n    }\n    else\n\tlead_len = 0;\n    if (lead_len > 0)\n    {\n\tchar_u\t*lead_repl = NULL;\t    // replaces comment leader\n\tint\tlead_repl_len = 0;\t    // length of *lead_repl\n\tchar_u\tlead_middle[COM_MAX_LEN];   // middle-comment string\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tchar_u\t*comment_end = NULL;\t    // where lead_end has been found\n\tint\textra_space = FALSE;\t    // append extra space\n\tint\tcurrent_flag;\n\tint\trequire_blank = FALSE;\t    // requires blank after middle\n\tchar_u\t*p2;\n\n\t// If the comment leader has the start, middle or end flag, it may not\n\t// be used or may be replaced with the middle leader.\n\tfor (p = lead_flags; *p && *p != ':'; ++p)\n\t{\n\t    if (*p == COM_BLANK)\n\t    {\n\t\trequire_blank = TRUE;\n\t\tcontinue;\n\t    }\n\t    if (*p == COM_START || *p == COM_MIDDLE)\n\t    {\n\t\tcurrent_flag = *p;\n\t\tif (*p == COM_START)\n\t\t{\n\t\t    // Doing \"O\" on a start of comment does not insert leader.\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\tlead_len = 0;\n\t\t\tbreak;\n\t\t    }\n\n\t\t    // find start of middle part\n\t\t    (void)copy_option_part(&p, lead_middle, COM_MAX_LEN, \",\");\n\t\t    require_blank = FALSE;\n\t\t}\n\n\t\t// Isolate the strings of the middle and end leader.\n\t\twhile (*p && p[-1] != ':')\t// find end of middle flags\n\t\t{\n\t\t    if (*p == COM_BLANK)\n\t\t\trequire_blank = TRUE;\n\t\t    ++p;\n\t\t}\n\t\t(void)copy_option_part(&p, lead_middle, COM_MAX_LEN, \",\");\n\n\t\twhile (*p && p[-1] != ':')\t// find end of end flags\n\t\t{\n\t\t    // Check whether we allow automatic ending of comments\n\t\t    if (*p == COM_AUTO_END)\n\t\t\tend_comment_pending = -1; // means we want to set it\n\t\t    ++p;\n\t\t}\n\t\tn = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t\tif (end_comment_pending == -1)\t// we can set it now\n\t\t    end_comment_pending = lead_end[n - 1];\n\n\t\t// If the end of the comment is in the same line, don't use\n\t\t// the comment leader.\n\t\tif (dir == FORWARD)\n\t\t{\n\t\t    for (p = saved_line + lead_len; *p; ++p)\n\t\t\tif (STRNCMP(p, lead_end, n) == 0)\n\t\t\t{\n\t\t\t    comment_end = p;\n\t\t\t    lead_len = 0;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\n\t\t// Doing \"o\" on a start of comment inserts the middle leader.\n\t\tif (lead_len > 0)\n\t\t{\n\t\t    if (current_flag == COM_START)\n\t\t    {\n\t\t\tlead_repl = lead_middle;\n\t\t\tlead_repl_len = (int)STRLEN(lead_middle);\n\t\t    }\n\n\t\t    // If we have hit RETURN immediately after the start\n\t\t    // comment leader, then put a space after the middle\n\t\t    // comment leader on the next line.\n\t\t    if (!VIM_ISWHITE(saved_line[lead_len - 1])\n\t\t\t    && ((p_extra != NULL\n\t\t\t\t    && (int)curwin->w_cursor.col == lead_len)\n\t\t\t\t|| (p_extra == NULL\n\t\t\t\t    && saved_line[lead_len] == NUL)\n\t\t\t\t|| require_blank))\n\t\t\textra_space = TRUE;\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (*p == COM_END)\n\t    {\n\t\t// Doing \"o\" on the end of a comment does not insert leader.\n\t\t// Remember where the end is, might want to use it to find the\n\t\t// start (for C-comments).\n\t\tif (dir == FORWARD)\n\t\t{\n\t\t    comment_end = skipwhite(saved_line);\n\t\t    lead_len = 0;\n\t\t    break;\n\t\t}\n\n\t\t// Doing \"O\" on the end of a comment inserts the middle leader.\n\t\t// Find the string for the middle leader, searching backwards.\n\t\twhile (p > curbuf->b_p_com && *p != ',')\n\t\t    --p;\n\t\tfor (lead_repl = p; lead_repl > curbuf->b_p_com\n\t\t\t\t\t && lead_repl[-1] != ':'; --lead_repl)\n\t\t    ;\n\t\tlead_repl_len = (int)(p - lead_repl);\n\n\t\t// We can probably always add an extra space when doing \"O\" on\n\t\t// the comment-end\n\t\textra_space = TRUE;\n\n\t\t// Check whether we allow automatic ending of comments\n\t\tfor (p2 = p; *p2 && *p2 != ':'; p2++)\n\t\t{\n\t\t    if (*p2 == COM_AUTO_END)\n\t\t\tend_comment_pending = -1; // means we want to set it\n\t\t}\n\t\tif (end_comment_pending == -1)\n\t\t{\n\t\t    // Find last character in end-comment string\n\t\t    while (*p2 && *p2 != ',')\n\t\t\tp2++;\n\t\t    end_comment_pending = p2[-1];\n\t\t}\n\t\tbreak;\n\t    }\n\t    if (*p == COM_FIRST)\n\t    {\n\t\t// Comment leader for first line only:\tDon't repeat leader\n\t\t// when using \"O\", blank out leader when using \"o\".\n\t\tif (dir == BACKWARD)\n\t\t    lead_len = 0;\n\t\telse\n\t\t{\n\t\t    lead_repl = (char_u *)\"\";\n\t\t    lead_repl_len = 0;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tif (lead_len)\n\t{\n\t    // allocate buffer (may concatenate p_extra later)\n\t    leader = alloc(lead_len + lead_repl_len + extra_space + extra_len\n\t\t     + (second_line_indent > 0 ? second_line_indent : 0) + 1);\n\t    allocated = leader;\t\t    // remember to free it later\n\n\t    if (leader == NULL)\n\t\tlead_len = 0;\n\t    else\n\t    {\n\t\tint li;\n\n\t\tvim_strncpy(leader, saved_line, lead_len);\n\n\t\t// TODO: handle multi-byte and double width chars\n\t\tfor (li = 0; li < comment_start; ++li)\n\t\t    if (!VIM_ISWHITE(leader[li]))\n\t\t\tleader[li] = ' ';\n\n\t\t// Replace leader with lead_repl, right or left adjusted\n\t\tif (lead_repl != NULL)\n\t\t{\n\t\t    int\t\tc = 0;\n\t\t    int\t\toff = 0;\n\n\t\t    for (p = lead_flags; *p != NUL && *p != ':'; )\n\t\t    {\n\t\t\tif (*p == COM_RIGHT || *p == COM_LEFT)\n\t\t\t    c = *p++;\n\t\t\telse if (VIM_ISDIGIT(*p) || *p == '-')\n\t\t\t    off = getdigits(&p);\n\t\t\telse\n\t\t\t    ++p;\n\t\t    }\n\t\t    if (c == COM_RIGHT)    // right adjusted leader\n\t\t    {\n\t\t\t// find last non-white in the leader to line up with\n\t\t\tfor (p = leader + lead_len - 1; p > leader\n\t\t\t\t\t\t      && VIM_ISWHITE(*p); --p)\n\t\t\t    ;\n\t\t\t++p;\n\n\t\t\t// Compute the length of the replaced characters in\n\t\t\t// screen characters, not bytes.\n\t\t\t{\n\t\t\t    int\t    repl_size = vim_strnsize(lead_repl,\n\t\t\t\t\t\t\t       lead_repl_len);\n\t\t\t    int\t    old_size = 0;\n\t\t\t    char_u  *endp = p;\n\t\t\t    int\t    l;\n\n\t\t\t    while (old_size < repl_size && p > leader)\n\t\t\t    {\n\t\t\t\tMB_PTR_BACK(leader, p);\n\t\t\t\told_size += ptr2cells(p);\n\t\t\t    }\n\t\t\t    l = lead_repl_len - (int)(endp - p);\n\t\t\t    if (l != 0)\n\t\t\t\tmch_memmove(endp + l, endp,\n\t\t\t\t\t(size_t)((leader + lead_len) - endp));\n\t\t\t    lead_len += l;\n\t\t\t}\n\t\t\tmch_memmove(p, lead_repl, (size_t)lead_repl_len);\n\t\t\tif (p + lead_repl_len > leader + lead_len)\n\t\t\t    p[lead_repl_len] = NUL;\n\n\t\t\t// blank-out any other chars from the old leader.\n\t\t\twhile (--p >= leader)\n\t\t\t{\n\t\t\t    int l = mb_head_off(leader, p);\n\n\t\t\t    if (l > 1)\n\t\t\t    {\n\t\t\t\tp -= l;\n\t\t\t\tif (ptr2cells(p) > 1)\n\t\t\t\t{\n\t\t\t\t    p[1] = ' ';\n\t\t\t\t    --l;\n\t\t\t\t}\n\t\t\t\tmch_memmove(p + 1, p + l + 1,\n\t\t\t\t   (size_t)((leader + lead_len) - (p + l + 1)));\n\t\t\t\tlead_len -= l;\n\t\t\t\t*p = ' ';\n\t\t\t    }\n\t\t\t    else if (!VIM_ISWHITE(*p))\n\t\t\t\t*p = ' ';\n\t\t\t}\n\t\t    }\n\t\t    else\t// left adjusted leader\n\t\t    {\n\t\t\tp = skipwhite(leader);\n\n\t\t\t// Compute the length of the replaced characters in\n\t\t\t// screen characters, not bytes. Move the part that is\n\t\t\t// not to be overwritten.\n\t\t\t{\n\t\t\t    int\t    repl_size = vim_strnsize(lead_repl,\n\t\t\t\t\t\t\t       lead_repl_len);\n\t\t\t    int\t    i;\n\t\t\t    int\t    l;\n\n\t\t\t    for (i = 0; i < lead_len && p[i] != NUL; i += l)\n\t\t\t    {\n\t\t\t\tl = (*mb_ptr2len)(p + i);\n\t\t\t\tif (vim_strnsize(p, i + l) > repl_size)\n\t\t\t\t    break;\n\t\t\t    }\n\t\t\t    if (i != lead_repl_len)\n\t\t\t    {\n\t\t\t\tmch_memmove(p + lead_repl_len, p + i,\n\t\t\t\t       (size_t)(lead_len - i - (p - leader)));\n\t\t\t\tlead_len += lead_repl_len - i;\n\t\t\t    }\n\t\t\t}\n\t\t\tmch_memmove(p, lead_repl, (size_t)lead_repl_len);\n\n\t\t\t// Replace any remaining non-white chars in the old\n\t\t\t// leader by spaces.  Keep Tabs, the indent must\n\t\t\t// remain the same.\n\t\t\tfor (p += lead_repl_len; p < leader + lead_len; ++p)\n\t\t\t    if (!VIM_ISWHITE(*p))\n\t\t\t    {\n\t\t\t\t// Don't put a space before a TAB.\n\t\t\t\tif (p + 1 < leader + lead_len && p[1] == TAB)\n\t\t\t\t{\n\t\t\t\t    --lead_len;\n\t\t\t\t    mch_memmove(p, p + 1,\n\t\t\t\t\t\t     (leader + lead_len) - p);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    int\t    l = (*mb_ptr2len)(p);\n\n\t\t\t\t    if (l > 1)\n\t\t\t\t    {\n\t\t\t\t\tif (ptr2cells(p) > 1)\n\t\t\t\t\t{\n\t\t\t\t\t    // Replace a double-wide char with\n\t\t\t\t\t    // two spaces\n\t\t\t\t\t    --l;\n\t\t\t\t\t    *p++ = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tmch_memmove(p + 1, p + l,\n\t\t\t\t\t\t     (leader + lead_len) - p);\n\t\t\t\t\tlead_len -= l - 1;\n\t\t\t\t    }\n\t\t\t\t    *p = ' ';\n\t\t\t\t}\n\t\t\t    }\n\t\t\t*p = NUL;\n\t\t    }\n\n\t\t    // Recompute the indent, it may have changed.\n\t\t    if (curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t\t|| do_si\n#endif\n\t\t\t\t\t\t\t   )\n#ifdef FEAT_VARTABS\n\t\t\tnewindent = get_indent_str_vtab(leader, curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n\t\t\tnewindent = get_indent_str(leader,\n\t\t\t\t\t\t   (int)curbuf->b_p_ts, FALSE);\n#endif\n\n\t\t    // Add the indent offset\n\t\t    if (newindent + off < 0)\n\t\t    {\n\t\t\toff = -newindent;\n\t\t\tnewindent = 0;\n\t\t    }\n\t\t    else\n\t\t\tnewindent += off;\n\n\t\t    // Correct trailing spaces for the shift, so that\n\t\t    // alignment remains equal.\n\t\t    while (off > 0 && lead_len > 0\n\t\t\t\t\t       && leader[lead_len - 1] == ' ')\n\t\t    {\n\t\t\t// Don't do it when there is a tab before the space\n\t\t\tif (vim_strchr(skipwhite(leader), '\\t') != NULL)\n\t\t\t    break;\n\t\t\t--lead_len;\n\t\t\t--off;\n\t\t    }\n\n\t\t    // If the leader ends in white space, don't add an\n\t\t    // extra space\n\t\t    if (lead_len > 0 && VIM_ISWHITE(leader[lead_len - 1]))\n\t\t\textra_space = FALSE;\n\t\t    leader[lead_len] = NUL;\n\t\t}\n\n\t\tif (extra_space)\n\t\t{\n\t\t    leader[lead_len++] = ' ';\n\t\t    leader[lead_len] = NUL;\n\t\t}\n\n\t\tnewcol = lead_len;\n\n\t\t// if a new indent will be set below, remove the indent that\n\t\t// is in the comment leader\n\t\tif (newindent\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t|| did_si\n#endif\n\t\t\t\t\t   )\n\t\t{\n\t\t    while (lead_len && VIM_ISWHITE(*leader))\n\t\t    {\n\t\t\t--lead_len;\n\t\t\t--newcol;\n\t\t\t++leader;\n\t\t    }\n\t\t}\n\n\t    }\n#ifdef FEAT_SMARTINDENT\n\t    did_si = can_si = FALSE;\n#endif\n\t}\n\telse if (comment_end != NULL)\n\t{\n\t    // We have finished a comment, so we don't use the leader.\n\t    // If this was a C-comment and 'ai' or 'si' is set do a normal\n\t    // indent to align with the line containing the start of the\n\t    // comment.\n\t    if (comment_end[0] == '*' && comment_end[1] == '/' &&\n\t\t\t(curbuf->b_p_ai\n#ifdef FEAT_SMARTINDENT\n\t\t\t\t\t|| do_si\n#endif\n\t\t\t\t\t\t\t   ))\n\t    {\n\t\told_cursor = curwin->w_cursor;\n\t\tcurwin->w_cursor.col = (colnr_T)(comment_end - saved_line);\n\t\tif ((pos = findmatch(NULL, NUL)) != NULL)\n\t\t{\n\t\t    curwin->w_cursor.lnum = pos->lnum;\n\t\t    newindent = get_indent();\n\t\t}\n\t\tcurwin->w_cursor = old_cursor;\n\t    }\n\t}\n    }\n\n    // (State == MODE_INSERT || State == MODE_REPLACE), only when dir == FORWARD\n    if (p_extra != NULL)\n    {\n\t*p_extra = saved_char;\t\t// restore char that NUL replaced\n\n\t// When 'ai' set or \"flags\" has OPENLINE_DELSPACES, skip to the first\n\t// non-blank.\n\t//\n\t// When in MODE_REPLACE state, put the deleted blanks on the replace\n\t// stack, preceded by a NUL, so they can be put back when a BS is\n\t// entered.\n\tif (REPLACE_NORMAL(State))\n\t    replace_push(NUL);\t    // end of extra blanks\n\tif (curbuf->b_p_ai || (flags & OPENLINE_DELSPACES))\n\t{\n\t    while ((*p_extra == ' ' || *p_extra == '\\t')\n\t\t    && (!enc_utf8\n\t\t\t       || !utf_iscomposing(utf_ptr2char(p_extra + 1))))\n\t    {\n\t\tif (REPLACE_NORMAL(State))\n\t\t    replace_push(*p_extra);\n\t\t++p_extra;\n\t\t++less_cols_off;\n\t    }\n\t}\n\n\t// columns for marks adjusted for removed columns\n\tless_cols = (int)(p_extra - saved_line);\n    }\n\n    if (p_extra == NULL)\n\tp_extra = (char_u *)\"\";\t\t    // append empty line\n\n    // concatenate leader and p_extra, if there is a leader\n    if (lead_len)\n    {\n\tif (flags & OPENLINE_COM_LIST && second_line_indent > 0)\n\t{\n\t    int i;\n\t    int padding = second_line_indent\n\t\t\t\t\t  - (newindent + (int)STRLEN(leader));\n\n\t    // Here whitespace is inserted after the comment char.\n\t    // Below, set_indent(newindent, SIN_INSERT) will insert the\n\t    // whitespace needed before the comment char.\n\t    for (i = 0; i < padding; i++)\n\t    {\n\t\tSTRCAT(leader, \" \");\n\t\tless_cols--;\n\t\tnewcol++;\n\t    }\n\t}\n\tSTRCAT(leader, p_extra);\n\tp_extra = leader;\n\tdid_ai = TRUE;\t    // So truncating blanks works with comments\n\tless_cols -= lead_len;\n    }\n    else\n\tend_comment_pending = NUL;  // turns out there was no leader\n\n    old_cursor = curwin->w_cursor;\n    if (dir == BACKWARD)\n\t--curwin->w_cursor.lnum;\n    if (!(State & VREPLACE_FLAG) || old_cursor.lnum >= orig_line_count)\n    {\n\tif (ml_append(curwin->w_cursor.lnum, p_extra, (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t    goto theend;\n\t// Postpone calling changed_lines(), because it would mess up folding\n\t// with markers.\n\t// Skip mark_adjust when adding a line after the last one, there can't\n\t// be marks there. But still needed in diff mode.\n\tif (curwin->w_cursor.lnum + 1 < curbuf->b_ml.ml_line_count\n#ifdef FEAT_DIFF\n\t\t|| curwin->w_p_diff\n#endif\n\t    )\n\t    mark_adjust(curwin->w_cursor.lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);\n\tdid_append = TRUE;\n#ifdef FEAT_PROP_POPUP\n\tif ((State & MODE_INSERT) && (State & VREPLACE_FLAG) == 0)\n\t    // Properties after the split move to the next line.\n\t    adjust_props_for_split(curwin->w_cursor.lnum, curwin->w_cursor.lnum,\n\t\t    curwin->w_cursor.col + 1, 0);\n#endif\n    }\n    else\n    {\n\t// In MODE_VREPLACE state we are starting to replace the next line.\n\tcurwin->w_cursor.lnum++;\n\tif (curwin->w_cursor.lnum >= Insstart.lnum + vr_lines_changed)\n\t{\n\t    // In case we NL to a new line, BS to the previous one, and NL\n\t    // again, we don't want to save the new line for undo twice.\n\t    (void)u_save_cursor();\t\t    // errors are ignored!\n\t    vr_lines_changed++;\n\t}\n\tml_replace(curwin->w_cursor.lnum, p_extra, TRUE);\n\tchanged_bytes(curwin->w_cursor.lnum, 0);\n\tcurwin->w_cursor.lnum--;\n\tdid_append = FALSE;\n    }\n\n    if (newindent\n#ifdef FEAT_SMARTINDENT\n\t\t    || did_si\n#endif\n\t\t\t\t)\n    {\n\t++curwin->w_cursor.lnum;\n#ifdef FEAT_SMARTINDENT\n\tif (did_si)\n\t{\n\t    int sw = (int)get_sw_value(curbuf);\n\n\t    if (p_sr)\n\t\tnewindent -= newindent % sw;\n\t    newindent += sw;\n\t}\n#endif\n\t// Copy the indent\n\tif (curbuf->b_p_ci)\n\t{\n\t    (void)copy_indent(newindent, saved_line);\n\n\t    // Set the 'preserveindent' option so that any further screwing\n\t    // with the line doesn't entirely destroy our efforts to preserve\n\t    // it.  It gets restored at the function end.\n\t    curbuf->b_p_pi = TRUE;\n\t}\n\telse\n\t    (void)set_indent(newindent, SIN_INSERT);\n\tless_cols -= curwin->w_cursor.col;\n\n\tai_col = curwin->w_cursor.col;\n\n\t// In MODE_REPLACE state, for each character in the new indent, there\n\t// must be a NUL on the replace stack, for when it is deleted with BS\n\tif (REPLACE_NORMAL(State))\n\t    for (n = 0; n < (int)curwin->w_cursor.col; ++n)\n\t\treplace_push(NUL);\n\tnewcol += curwin->w_cursor.col;\n#ifdef FEAT_SMARTINDENT\n\tif (no_si)\n\t    did_si = FALSE;\n#endif\n    }\n\n    // In MODE_REPLACE state, for each character in the extra leader, there\n    // must be a NUL on the replace stack, for when it is deleted with BS.\n    if (REPLACE_NORMAL(State))\n\twhile (lead_len-- > 0)\n\t    replace_push(NUL);\n\n    curwin->w_cursor = old_cursor;\n\n    if (dir == FORWARD)\n    {\n\tif (trunc_line || (State & MODE_INSERT))\n\t{\n\t    // truncate current line at cursor\n\t    saved_line[curwin->w_cursor.col] = NUL;\n\t    // Remove trailing white space, unless OPENLINE_KEEPTRAIL used.\n\t    if (trunc_line && !(flags & OPENLINE_KEEPTRAIL))\n\t\ttruncate_spaces(saved_line);\n\t    ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);\n\t    saved_line = NULL;\n\t    if (did_append)\n\t    {\n\t\tchanged_lines(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t       curwin->w_cursor.lnum + 1, 1L);\n\t\tdid_append = FALSE;\n\n\t\t// Move marks after the line break to the new line.\n\t\tif (flags & OPENLINE_MARKFIX)\n\t\t    mark_col_adjust(curwin->w_cursor.lnum,\n\t\t\t\t\t curwin->w_cursor.col + less_cols_off,\n\t\t\t\t\t\t      1L, (long)-less_cols, 0);\n#ifdef FEAT_PROP_POPUP\n\t\t// Keep into account the deleted blanks on the new line.\n\t\tif (curbuf->b_has_textprop && less_cols_off != 0)\n\t\t    adjust_prop_columns(curwin->w_cursor.lnum + 1, 0,\n\t\t\t\t\t\t\t    -less_cols_off, 0);\n#endif\n\t    }\n\t    else\n\t\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\t}\n\n\t// Put the cursor on the new line.  Careful: the scrollup() above may\n\t// have moved w_cursor, we must use old_cursor.\n\tcurwin->w_cursor.lnum = old_cursor.lnum + 1;\n    }\n    if (did_append)\n\tchanged_lines(curwin->w_cursor.lnum, 0, curwin->w_cursor.lnum, 1L);\n\n    curwin->w_cursor.col = newcol;\n    curwin->w_cursor.coladd = 0;\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    // In MODE_VREPLACE state, we are handling the replace stack ourselves, so\n    // stop fixthisline() from doing it (via change_indent()) by telling it\n    // we're in normal MODE_INSERT state.\n    if (State & VREPLACE_FLAG)\n    {\n\tvreplace_mode = State;\t// So we know to put things right later\n\tState = MODE_INSERT;\n    }\n    else\n\tvreplace_mode = 0;\n#endif\n#ifdef FEAT_LISP\n    // May do lisp indenting.\n    if (!p_paste\n\t    && leader == NULL\n\t    && curbuf->b_p_lisp\n\t    && curbuf->b_p_ai)\n    {\n\tfixthisline(get_lisp_indent);\n\tai_col = (colnr_T)getwhitecols_curline();\n    }\n#endif\n#ifdef FEAT_CINDENT\n    // May do indenting after opening a new line.\n    if (do_cindent)\n    {\n\tdo_c_expr_indent();\n\tai_col = (colnr_T)getwhitecols_curline();\n    }\n#endif\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (vreplace_mode != 0)\n\tState = vreplace_mode;\n#endif\n\n    // Finally, MODE_VREPLACE gets the stuff on the new line, then puts back\n    // the original line, and inserts the new stuff char by char, pushing old\n    // stuff onto the replace stack (via ins_char()).\n    if (State & VREPLACE_FLAG)\n    {\n\t// Put new line in p_extra\n\tp_extra = vim_strsave(ml_get_curline());\n\tif (p_extra == NULL)\n\t    goto theend;\n\n\t// Put back original line\n\tml_replace(curwin->w_cursor.lnum, next_line, FALSE);\n\n\t// Insert new stuff into line again\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\tins_bytes(p_extra);\t// will call changed_bytes()\n\tvim_free(p_extra);\n\tnext_line = NULL;\n    }\n\n    retval = OK;\t\t// success!\ntheend:\n    curbuf->b_p_pi = saved_pi;\n    vim_free(saved_line);\n    vim_free(next_line);\n    vim_free(allocated);\n    return retval;\n}\n\n/*\n * Delete from cursor to end of line.\n * Caller must have prepared for undo.\n * If \"fixpos\" is TRUE fix the cursor position when done.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ntruncate_line(int fixpos)\n{\n    char_u\t*newp;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    colnr_T\tcol = curwin->w_cursor.col;\n    char_u\t*old_line;\n    int\t\tdeleted;\n\n    old_line = ml_get(lnum);\n    if (col == 0)\n\tnewp = vim_strsave((char_u *)\"\");\n    else\n\tnewp = vim_strnsave(old_line, col);\n    deleted = (int)STRLEN(old_line) - col;\n\n    if (newp == NULL)\n\treturn FAIL;\n\n    ml_replace(lnum, newp, FALSE);\n\n    // mark the buffer as changed and prepare for displaying\n    inserted_bytes(lnum, curwin->w_cursor.col, -deleted);\n\n    // If \"fixpos\" is TRUE we don't want to end up positioned at the NUL.\n    if (fixpos && curwin->w_cursor.col > 0)\n\t--curwin->w_cursor.col;\n\n    return OK;\n}\n\n/*\n * Delete \"nlines\" lines at the cursor.\n * Saves the lines for undo first if \"undo\" is TRUE.\n */\n    void\ndel_lines(long nlines,\tint undo)\n{\n    long\tn;\n    linenr_T\tfirst = curwin->w_cursor.lnum;\n\n    if (nlines <= 0)\n\treturn;\n\n    // save the deleted lines for undo\n    if (undo && u_savedel(first, nlines) == FAIL)\n\treturn;\n\n    for (n = 0; n < nlines; )\n    {\n\tif (curbuf->b_ml.ml_flags & ML_EMPTY)\t    // nothing to delete\n\t    break;\n\n\tml_delete_flags(first, ML_DEL_MESSAGE);\n\t++n;\n\n\t// If we delete the last line in the file, stop\n\tif (first > curbuf->b_ml.ml_line_count)\n\t    break;\n    }\n\n    // Correct the cursor position before calling deleted_lines_mark(), it may\n    // trigger a callback to display the cursor.\n    curwin->w_cursor.col = 0;\n    check_cursor_lnum();\n\n    // adjust marks, mark the buffer as changed and prepare for displaying\n    deleted_lines_mark(first, n);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * edit.c: functions for Insert mode\n */\n\n#include \"vim.h\"\n\n#define BACKSPACE_CHAR\t\t    1\n#define BACKSPACE_WORD\t\t    2\n#define BACKSPACE_WORD_NOT_SPACE    3\n#define BACKSPACE_LINE\t\t    4\n\n// Set when doing something for completion that may call edit() recursively,\n// which is not allowed.\nstatic int\tcompl_busy = FALSE;\n\n\nstatic void ins_ctrl_v(void);\nstatic void insert_special(int, int, int);\nstatic void redo_literal(int c);\nstatic void start_arrow_common(pos_T *end_insert_pos, int change);\n#ifdef FEAT_SPELL\nstatic void check_spell_redraw(void);\n#endif\nstatic void stop_insert(pos_T *end_insert_pos, int esc, int nomove);\nstatic int  echeck_abbr(int);\nstatic void mb_replace_pop_ins(int cc);\nstatic void replace_flush(void);\nstatic void replace_do_bs(int limit_col);\nstatic int del_char_after_col(int limit_col);\nstatic void ins_reg(void);\nstatic void ins_ctrl_g(void);\nstatic void ins_ctrl_hat(void);\nstatic int  ins_esc(long *count, int cmdchar, int nomove);\n#ifdef FEAT_RIGHTLEFT\nstatic void ins_ctrl_(void);\n#endif\nstatic int ins_start_select(int c);\nstatic void ins_insert(int replaceState);\nstatic void ins_ctrl_o(void);\nstatic void ins_shift(int c, int lastc);\nstatic void ins_del(void);\nstatic int  ins_bs(int c, int mode, int *inserted_space_p);\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\nstatic void ins_tabline(int c);\n#endif\nstatic void ins_left(void);\nstatic void ins_home(int c);\nstatic void ins_end(int c);\nstatic void ins_s_left(void);\nstatic void ins_right(void);\nstatic void ins_s_right(void);\nstatic void ins_up(int startcol);\nstatic void ins_pageup(void);\nstatic void ins_down(int startcol);\nstatic void ins_pagedown(void);\n#ifdef FEAT_DND\nstatic void ins_drop(void);\n#endif\nstatic int  ins_tab(void);\n#ifdef FEAT_DIGRAPHS\nstatic int  ins_digraph(void);\n#endif\nstatic int  ins_ctrl_ey(int tc);\n#if defined(FEAT_EVAL)\nstatic char_u *do_insert_char_pre(int c);\n#endif\n\nstatic colnr_T\tInsstart_textlen;\t// length of line when insert started\nstatic colnr_T\tInsstart_blank_vcol;\t// vcol for first inserted blank\nstatic int\tupdate_Insstart_orig = TRUE; // set Insstart_orig to Insstart\n\nstatic char_u\t*last_insert = NULL;\t// the text of the previous insert,\n\t\t\t\t\t// K_SPECIAL and CSI are escaped\nstatic int\tlast_insert_skip; // nr of chars in front of previous insert\nstatic int\tnew_insert_skip;  // nr of chars in front of current insert\nstatic int\tdid_restart_edit;\t// \"restart_edit\" when calling edit()\n\n#ifdef FEAT_CINDENT\nstatic int\tcan_cindent;\t\t// may do cindenting on this line\n#endif\n\n#ifdef FEAT_RIGHTLEFT\nstatic int\trevins_on;\t\t// reverse insert mode on\nstatic int\trevins_chars;\t\t// how much to skip after edit\nstatic int\trevins_legal;\t\t// was the last char 'legal'?\nstatic int\trevins_scol;\t\t// start column of revins session\n#endif\n\nstatic int\tins_need_undo;\t\t// call u_save() before inserting a\n\t\t\t\t\t// char.  Set when edit() is called.\n\t\t\t\t\t// after that arrow_used is used.\n\nstatic int\tdont_sync_undo = FALSE;\t// CTRL-G U prevents syncing undo for\n\t\t\t\t\t// the next left/right cursor key\n\n/*\n * edit(): Start inserting text.\n *\n * \"cmdchar\" can be:\n * 'i'\tnormal insert command\n * 'a'\tnormal append command\n * K_PS bracketed paste\n * 'R'\treplace command\n * 'r'\t\"r<CR>\" command: insert one <CR>.  Note: count can be > 1, for redo,\n *\tbut still only one <CR> is inserted.  The <Esc> is not used for redo.\n * 'g'\t\"gI\" command.\n * 'V'\t\"gR\" command for Virtual Replace mode.\n * 'v'\t\"gr\" command for single character Virtual Replace mode.\n *\n * This function is not called recursively.  For CTRL-O commands, it returns\n * and lets the caller handle the Normal-mode command.\n *\n * Return TRUE if a CTRL-O command caused the return (insert mode pending).\n */\n    int\nedit(\n    int\t\tcmdchar,\n    int\t\tstartln,\t// if set, insert at start of line\n    long\tcount)\n{\n    int\t\tc = 0;\n    char_u\t*ptr;\n    int\t\tlastc = 0;\n    int\t\tmincol;\n    static linenr_T o_lnum = 0;\n    int\t\ti;\n    int\t\tdid_backspace = TRUE;\t    // previous char was backspace\n#ifdef FEAT_CINDENT\n    int\t\tline_is_white = FALSE;\t    // line is empty before insert\n#endif\n    linenr_T\told_topline = 0;\t    // topline before insertion\n#ifdef FEAT_DIFF\n    int\t\told_topfill = -1;\n#endif\n    int\t\tinserted_space = FALSE;     // just inserted a space\n    int\t\treplaceState = MODE_REPLACE;\n    int\t\tnomove = FALSE;\t\t    // don't move cursor on return\n#ifdef FEAT_JOB_CHANNEL\n    int\t\tcmdchar_todo = cmdchar;\n#endif\n#ifdef FEAT_CONCEAL\n    int\t\tcursor_line_was_concealed;\n#endif\n\n    // Remember whether editing was restarted after CTRL-O.\n    did_restart_edit = restart_edit;\n\n    // sleep before redrawing, needed for \"CTRL-O :\" that results in an\n    // error message\n    check_for_delay(TRUE);\n\n    // set Insstart_orig to Insstart\n    update_Insstart_orig = TRUE;\n\n#ifdef HAVE_SANDBOX\n    // Don't allow inserting in the sandbox.\n    if (sandbox != 0)\n    {\n\temsg(_(e_not_allowed_in_sandbox));\n\treturn FALSE;\n    }\n#endif\n    // Don't allow changes in the buffer while editing the cmdline.  The\n    // caller of getcmdline() may get confused.\n    // Don't allow recursive insert mode when busy with completion.\n    if (textwinlock != 0 || textlock != 0\n\t\t\t  || ins_compl_active() || compl_busy || pum_visible())\n    {\n\temsg(_(e_not_allowed_to_change_text_or_change_window));\n\treturn FALSE;\n    }\n    ins_compl_clear();\t    // clear stuff for CTRL-X mode\n\n    /*\n     * Trigger InsertEnter autocommands.  Do not do this for \"r<CR>\" or \"grx\".\n     */\n    if (cmdchar != 'r' && cmdchar != 'v')\n    {\n\tpos_T   save_cursor = curwin->w_cursor;\n\n#ifdef FEAT_EVAL\n\tif (cmdchar == 'R')\n\t    ptr = (char_u *)\"r\";\n\telse if (cmdchar == 'V')\n\t    ptr = (char_u *)\"v\";\n\telse\n\t    ptr = (char_u *)\"i\";\n\tset_vim_var_string(VV_INSERTMODE, ptr, 1);\n\tset_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n#endif\n\tins_apply_autocmds(EVENT_INSERTENTER);\n\n\t// Check for changed highlighting, e.g. for ModeMsg.\n\tif (need_highlight_changed)\n\t    highlight_changed();\n\n\t// Make sure the cursor didn't move.  Do call check_cursor_col() in\n\t// case the text was modified.  Since Insert mode was not started yet\n\t// a call to check_cursor_col() may move the cursor, especially with\n\t// the \"A\" command, thus set State to avoid that. Also check that the\n\t// line number is still valid (lines may have been deleted).\n\t// Do not restore if v:char was set to a non-empty string.\n\tif (!EQUAL_POS(curwin->w_cursor, save_cursor)\n#ifdef FEAT_EVAL\n\t\t&& *get_vim_var_str(VV_CHAR) == NUL\n#endif\n\t\t&& save_cursor.lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    int save_state = State;\n\n\t    curwin->w_cursor = save_cursor;\n\t    State = MODE_INSERT;\n\t    check_cursor_col();\n\t    State = save_state;\n\t}\n    }\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line was concealed before changing State.\n    cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    /*\n     * When doing a paste with the middle mouse button, Insstart is set to\n     * where the paste started.\n     */\n    if (where_paste_started.lnum != 0)\n\tInsstart = where_paste_started;\n    else\n    {\n\tInsstart = curwin->w_cursor;\n\tif (startln)\n\t    Insstart.col = 0;\n    }\n    Insstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n    Insstart_blank_vcol = MAXCOL;\n    if (!did_ai)\n\tai_col = 0;\n\n    if (cmdchar != NUL && restart_edit == 0)\n    {\n\tResetRedobuff();\n\tAppendNumberToRedobuff(count);\n\tif (cmdchar == 'V' || cmdchar == 'v')\n\t{\n\t    // \"gR\" or \"gr\" command\n\t    AppendCharToRedobuff('g');\n\t    AppendCharToRedobuff((cmdchar == 'v') ? 'r' : 'R');\n\t}\n\telse\n\t{\n\t    if (cmdchar == K_PS)\n\t\tAppendCharToRedobuff('a');\n\t    else\n\t\tAppendCharToRedobuff(cmdchar);\n\t    if (cmdchar == 'g')\t\t    // \"gI\" command\n\t\tAppendCharToRedobuff('I');\n\t    else if (cmdchar == 'r')\t    // \"r<CR>\" command\n\t\tcount = 1;\t\t    // insert only one <CR>\n\t}\n    }\n\n    if (cmdchar == 'R')\n    {\n\tState = MODE_REPLACE;\n    }\n    else if (cmdchar == 'V' || cmdchar == 'v')\n    {\n\tState = MODE_VREPLACE;\n\treplaceState = MODE_VREPLACE;\n\torig_line_count = curbuf->b_ml.ml_line_count;\n\tvr_lines_changed = 1;\n    }\n    else\n\tState = MODE_INSERT;\n\n    may_trigger_modechanged();\n    stop_insert_mode = FALSE;\n\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"n\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    /*\n     * Enable langmap or IME, indicated by 'iminsert'.\n     * Note that IME may enabled/disabled without us noticing here, thus the\n     * 'iminsert' value may not reflect what is actually used.  It is updated\n     * when hitting <Esc>.\n     */\n    if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n\tState |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n    im_set_active(curbuf->b_p_iminsert == B_IMODE_IM);\n#endif\n\n    setmouse();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n#ifdef FEAT_RIGHTLEFT\n    // there is no reverse replace mode\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n\tundisplay_dollar();\n    revins_chars = 0;\n    revins_legal = 0;\n    revins_scol = -1;\n#endif\n    if (!p_ek)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tch_log_output = TRUE;\n#endif\n\t// Disable bracketed paste mode, we won't recognize the escape\n\t// sequences.\n\tout_str(T_BD);\n\n\t// Disable modifyOtherKeys, keys with modifiers would cause exiting\n\t// Insert mode.\n\tout_str(T_CTE);\n    }\n\n    /*\n     * Handle restarting Insert mode.\n     * Don't do this for \"CTRL-O .\" (repeat an insert): In that case we get\n     * here with something in the stuff buffer.\n     */\n    if (restart_edit != 0 && stuff_empty())\n    {\n\t/*\n\t * After a paste we consider text typed to be part of the insert for\n\t * the pasted text. You can backspace over the pasted text too.\n\t */\n\tif (where_paste_started.lnum)\n\t    arrow_used = FALSE;\n\telse\n\t    arrow_used = TRUE;\n\trestart_edit = 0;\n\n\t/*\n\t * If the cursor was after the end-of-line before the CTRL-O and it is\n\t * now at the end-of-line, put it after the end-of-line (this is not\n\t * correct in very rare cases).\n\t * Also do this if curswant is greater than the current virtual\n\t * column.  Eg after \"^O$\" or \"^O80|\".\n\t */\n\tvalidate_virtcol();\n\tupdate_curswant();\n\tif (((ins_at_eol && curwin->w_cursor.lnum == o_lnum)\n\t\t    || curwin->w_curswant > curwin->w_virtcol)\n\t\t&& *(ptr = ml_get_curline() + curwin->w_cursor.col) != NUL)\n\t{\n\t    if (ptr[1] == NUL)\n\t\t++curwin->w_cursor.col;\n\t    else if (has_mbyte)\n\t    {\n\t\ti = (*mb_ptr2len)(ptr);\n\t\tif (ptr[i] == NUL)\n\t\t    curwin->w_cursor.col += i;\n\t    }\n\t}\n\tins_at_eol = FALSE;\n    }\n    else\n\tarrow_used = FALSE;\n\n    // we are in insert mode now, don't need to start it anymore\n    need_start_insertmode = FALSE;\n\n    // Need to save the line for undo before inserting the first char.\n    ins_need_undo = TRUE;\n\n    where_paste_started.lnum = 0;\n#ifdef FEAT_CINDENT\n    can_cindent = TRUE;\n#endif\n#ifdef FEAT_FOLDING\n    // The cursor line is not in a closed fold, unless 'insertmode' is set or\n    // restarting.\n    if (!p_im && did_restart_edit == 0)\n\tfoldOpenCursor();\n#endif\n\n    /*\n     * If 'showmode' is set, show the current (insert/replace/..) mode.\n     * A warning message for changing a readonly file is given here, before\n     * actually changing anything.  It's put after the mode, if any.\n     */\n    i = 0;\n    if (p_smd && msg_silent == 0)\n\ti = showmode();\n\n    if (!p_im && did_restart_edit == 0)\n\tchange_warning(i == 0 ? 0 : i + 1);\n\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n#ifdef FEAT_DIGRAPHS\n    do_digraph(-1);\t\t// clear digraphs\n#endif\n\n    /*\n     * Get the current length of the redo buffer, those characters have to be\n     * skipped if we want to get to the inserted characters.\n     */\n    ptr = get_inserted();\n    if (ptr == NULL)\n\tnew_insert_skip = 0;\n    else\n    {\n\tnew_insert_skip = (int)STRLEN(ptr);\n\tvim_free(ptr);\n    }\n\n    old_indent = 0;\n\n    /*\n     * Main loop in Insert mode: repeat until Insert mode is left.\n     */\n    for (;;)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (!revins_legal)\n\t    revins_scol = -1;\t    // reset on illegal motions\n\telse\n\t    revins_legal = 0;\n#endif\n\tif (arrow_used)\t    // don't repeat insert when arrow key used\n\t    count = 0;\n\n\tif (update_Insstart_orig)\n\t    Insstart_orig = Insstart;\n\n\tif (stop_insert_mode && !ins_compl_active())\n\t{\n\t    // \":stopinsert\" used or 'insertmode' reset\n\t    count = 0;\n\t    goto doESCkey;\n\t}\n\n\t// set curwin->w_curswant for next K_DOWN or K_UP\n\tif (!arrow_used)\n\t    curwin->w_set_curswant = TRUE;\n\n\t// If there is no typeahead may check for timestamps (e.g., for when a\n\t// menu invoked a shell command).\n\tif (stuff_empty())\n\t{\n\t    did_check_timestamps = FALSE;\n\t    if (need_check_timestamps)\n\t\tcheck_timestamps(FALSE);\n\t}\n\n\t/*\n\t * When emsg() was called msg_scroll will have been set.\n\t */\n\tmsg_scroll = FALSE;\n\n#ifdef FEAT_GUI\n\t// When 'mousefocus' is set a mouse movement may have taken us to\n\t// another window.  \"need_mouse_correct\" may then be set because of an\n\t// autocommand.\n\tif (need_mouse_correct)\n\t    gui_mouse_correct();\n#endif\n\n#ifdef FEAT_FOLDING\n\t// Open fold at the cursor line, according to 'foldopen'.\n\tif (fdo_flags & FDO_INSERT)\n\t    foldOpenCursor();\n\t// Close folds where the cursor isn't, according to 'foldclose'\n\tif (!char_avail())\n\t    foldCheckClose();\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    init_prompt(cmdchar_todo);\n\t    cmdchar_todo = NUL;\n\t}\n#endif\n\n\t/*\n\t * If we inserted a character at the last position of the last line in\n\t * the window, scroll the window one line up. This avoids an extra\n\t * redraw.\n\t * This is detected when the cursor column is smaller after inserting\n\t * something.\n\t * Don't do this when the topline changed already, it has\n\t * already been adjusted (by insertchar() calling open_line())).\n\t */\n\tif (curbuf->b_mod_set\n\t\t&& curwin->w_p_wrap\n\t\t&& !did_backspace\n\t\t&& curwin->w_topline == old_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == old_topfill\n#endif\n\t\t)\n\t{\n\t    mincol = curwin->w_wcol;\n\t    validate_cursor_col();\n\n\t    if (\n#ifdef FEAT_VARTABS\n\t\tcurwin->w_wcol < mincol - tabstop_at(\n\t\t\t\t\t  get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t\t curbuf->b_p_vts_array)\n#else\n\t\t(int)curwin->w_wcol < mincol - curbuf->b_p_ts\n#endif\n\t\t    && curwin->w_wrow == W_WINROW(curwin)\n\t\t\t\t + curwin->w_height - 1 - get_scrolloff_value()\n\t\t    && (curwin->w_cursor.lnum != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill > 0\n#endif\n\t\t    ))\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (curwin->w_topfill > 0)\n\t\t    --curwin->w_topfill;\n\t\telse\n#endif\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline, NULL, &old_topline))\n\t\t    set_topline(curwin, old_topline + 1);\n\t\telse\n#endif\n\t\t    set_topline(curwin, curwin->w_topline + 1);\n\t    }\n\t}\n\n\t// May need to adjust w_topline to show the cursor.\n\tupdate_topline();\n\n\tdid_backspace = FALSE;\n\n\tvalidate_cursor();\t\t// may set must_redraw\n\n\t/*\n\t * Redraw the display when no characters are waiting.\n\t * Also shows mode, ruler and positions cursor.\n\t */\n\tins_redraw(TRUE);\n\n\tif (curwin->w_p_scb)\n\t    do_check_scrollbind(TRUE);\n\n\tif (curwin->w_p_crb)\n\t    do_check_cursorbind();\n\tupdate_curswant();\n\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n\told_topfill = curwin->w_topfill;\n#endif\n\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n\t/*\n\t * Get a character for Insert mode.  Ignore K_IGNORE and K_NOP.\n\t */\n\tif (c != K_CURSORHOLD)\n\t    lastc = c;\t\t// remember the previous char for CTRL-D\n\n\t// After using CTRL-G U the next cursor key will not break undo.\n\tif (dont_sync_undo == MAYBE)\n\t    dont_sync_undo = TRUE;\n\telse\n\t    dont_sync_undo = FALSE;\n\tif (cmdchar == K_PS)\n\t    // Got here from normal mode when bracketed paste started.\n\t    c = K_PS;\n\telse\n\t    do\n\t    {\n\t\tc = safe_vgetc();\n\n\t\tif (stop_insert_mode\n#ifdef FEAT_TERMINAL\n\t\t\t|| (c == K_IGNORE && term_use_loop())\n#endif\n\t\t   )\n\t\t{\n\t\t    // Insert mode ended, possibly from a callback, or a timer\n\t\t    // must have opened a terminal window.\n\t\t    if (c != K_IGNORE && c != K_NOP)\n\t\t\tvungetc(c);\n\t\t    count = 0;\n\t\t    nomove = TRUE;\n\t\t    ins_compl_prep(ESC);\n\t\t    goto doESCkey;\n\t\t}\n\t    } while (c == K_IGNORE || c == K_NOP);\n\n\t// Don't want K_CURSORHOLD for the second key, e.g., after CTRL-V.\n\tdid_cursorhold = TRUE;\n\n#ifdef FEAT_RIGHTLEFT\n\tif (p_hkmap && KeyTyped)\n\t    c = hkmap(c);\t\t// Hebrew mode mapping\n#endif\n\n\t// If the window was made so small that nothing shows, make it at least\n\t// one line and one column when typing.\n\tif (KeyTyped && !KeyStuffed)\n\t    win_ensure_size();\n\n\t/*\n\t * Special handling of keys while the popup menu is visible or wanted\n\t * and the cursor is still in the completed word.  Only when there is\n\t * a match, skip this when no matches were found.\n\t */\n\tif (ins_compl_active()\n\t\t&& pum_wanted()\n\t\t&& curwin->w_cursor.col >= ins_compl_col()\n\t\t&& ins_compl_has_shown_match())\n\t{\n\t    // BS: Delete one character from \"compl_leader\".\n\t    if ((c == K_BS || c == Ctrl_H)\n\t\t\t&& curwin->w_cursor.col > ins_compl_col()\n\t\t\t&& (c = ins_compl_bs()) == NUL)\n\t\tcontinue;\n\n\t    // When no match was selected or it was edited.\n\t    if (!ins_compl_used_match())\n\t    {\n\t\t// CTRL-L: Add one character from the current match to\n\t\t// \"compl_leader\".  Except when at the original match and\n\t\t// there is nothing to add, CTRL-L works like CTRL-P then.\n\t\tif (c == Ctrl_L\n\t\t\t&& (!ctrl_x_mode_line_or_eval()\n\t\t\t    || ins_compl_long_shown_match()))\n\t\t{\n\t\t    ins_compl_addfrommatch();\n\t\t    continue;\n\t\t}\n\n\t\t// A non-white character that fits in with the current\n\t\t// completion: Add to \"compl_leader\".\n\t\tif (ins_compl_accept_char(c))\n\t\t{\n#if defined(FEAT_EVAL)\n\t\t    // Trigger InsertCharPre.\n\t\t    char_u *str = do_insert_char_pre(c);\n\t\t    char_u *p;\n\n\t\t    if (str != NULL)\n\t\t    {\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t    ins_compl_addleader(PTR2CHAR(p));\n\t\t\tvim_free(str);\n\t\t    }\n\t\t    else\n#endif\n\t\t\tins_compl_addleader(c);\n\t\t    continue;\n\t\t}\n\n\t\t// Pressing CTRL-Y selects the current match.  When\n\t\t// ins_compl_enter_selects() is set the Enter key does the\n\t\t// same.\n\t\tif ((c == Ctrl_Y || (ins_compl_enter_selects()\n\t\t\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t\t\t&& stop_arrow() == OK)\n\t\t{\n\t\t    ins_compl_delete();\n\t\t    ins_compl_insert(FALSE);\n\t\t}\n\t    }\n\t}\n\n\t// Prepare for or stop CTRL-X mode.  This doesn't do completion, but\n\t// it does fix up the text when finishing completion.\n\tins_compl_init_get_longest();\n\tif (ins_compl_prep(c))\n\t    continue;\n\n\t// CTRL-\\ CTRL-N goes to Normal mode,\n\t// CTRL-\\ CTRL-G goes to mode selected with 'insertmode',\n\t// CTRL-\\ CTRL-O is like CTRL-O but without moving the cursor.\n\tif (c == Ctrl_BSL)\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\t    ++no_mapping;\n\t    ++allow_keys;\n\t    c = plain_vgetc();\n\t    --no_mapping;\n\t    --allow_keys;\n\t    if (c != Ctrl_N && c != Ctrl_G && c != Ctrl_O)\n\t    {\n\t\t// it's something else\n\t\tvungetc(c);\n\t\tc = Ctrl_BSL;\n\t    }\n\t    else if (c == Ctrl_G && p_im)\n\t\tcontinue;\n\t    else\n\t    {\n\t\tif (c == Ctrl_O)\n\t\t{\n\t\t    ins_ctrl_o();\n\t\t    ins_at_eol = FALSE;\t// cursor keeps its column\n\t\t    nomove = TRUE;\n\t\t}\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tc = do_digraph(c);\n#endif\n\n\tif ((c == Ctrl_V || c == Ctrl_Q) && ctrl_x_mode_cmdline())\n\t    goto docomplete;\n\tif (c == Ctrl_V || c == Ctrl_Q)\n\t{\n\t    ins_ctrl_v();\n\t    c = Ctrl_V;\t// pretend CTRL-V is last typed character\n\t    continue;\n\t}\n\n#ifdef FEAT_CINDENT\n\tif (cindent_on() && ctrl_x_mode_none())\n\t{\n\t    // A key name preceded by a bang means this key is not to be\n\t    // inserted.  Skip ahead to the re-indenting below.\n\t    // A key name preceded by a star means that indenting has to be\n\t    // done before inserting the key.\n\t    line_is_white = inindent(0);\n\t    if (in_cinkeys(c, '!', line_is_white))\n\t\tgoto force_cindent;\n\t    if (can_cindent && in_cinkeys(c, '*', line_is_white)\n\t\t\t\t\t\t\t&& stop_arrow() == OK)\n\t\tdo_c_expr_indent();\n\t}\n#endif\n\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t    switch (c)\n\t    {\n\t\tcase K_LEFT:\tc = K_RIGHT; break;\n\t\tcase K_S_LEFT:\tc = K_S_RIGHT; break;\n\t\tcase K_C_LEFT:\tc = K_C_RIGHT; break;\n\t\tcase K_RIGHT:\tc = K_LEFT; break;\n\t\tcase K_S_RIGHT: c = K_S_LEFT; break;\n\t\tcase K_C_RIGHT: c = K_C_LEFT; break;\n\t    }\n#endif\n\n\t/*\n\t * If 'keymodel' contains \"startsel\", may start selection.  If it\n\t * does, a CTRL-O and c will be stuffed, we need to get these\n\t * characters.\n\t */\n\tif (ins_start_select(c))\n\t    continue;\n\n\t/*\n\t * The big switch to handle a character in insert mode.\n\t */\n\tswitch (c)\n\t{\n\tcase ESC:\t// End input mode\n\t    if (echeck_abbr(ESC + ABBR_OFF))\n\t\tbreak;\n\t    // FALLTHROUGH\n\n\tcase Ctrl_C:\t// End input mode\n#ifdef FEAT_CMDWIN\n\t    if (c == Ctrl_C && cmdwin_type != 0)\n\t    {\n\t\t// Close the cmdline window.\n\t\tcmdwin_result = K_IGNORE;\n\t\tgot_int = FALSE; // don't stop executing autocommands et al.\n\t\tnomove = TRUE;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (c == Ctrl_C && bt_prompt(curbuf))\n\t    {\n\t\tif (invoke_prompt_interrupt())\n\t\t{\n\t\t    if (!bt_prompt(curbuf))\n\t\t\t// buffer changed to a non-prompt buffer, get out of\n\t\t\t// Insert mode\n\t\t\tgoto doESCkey;\n\t\t    break;\n\t\t}\n\t    }\n#endif\n\n#ifdef UNIX\ndo_intr:\n#endif\n\t    // when 'insertmode' set, and not halfway a mapping, don't leave\n\t    // Insert mode\n\t    if (goto_im())\n\t    {\n\t\tif (got_int)\n\t\t{\n\t\t    (void)vgetc();\t\t// flush all buffers\n\t\t    got_int = FALSE;\n\t\t}\n\t\telse\n\t\t    vim_beep(BO_IM);\n\t\tbreak;\n\t    }\ndoESCkey:\n\t    /*\n\t     * This is the ONLY return from edit()!\n\t     */\n\t    // Always update o_lnum, so that a \"CTRL-O .\" that adds a line\n\t    // still puts the cursor back after the inserted text.\n\t    if (ins_at_eol && gchar_cursor() == NUL)\n\t\to_lnum = curwin->w_cursor.lnum;\n\n\t    if (ins_esc(&count, cmdchar, nomove))\n\t    {\n\t\t// When CTRL-C was typed got_int will be set, with the result\n\t\t// that the autocommands won't be executed. When mapped got_int\n\t\t// is not set, but let's keep the behavior the same.\n\t\tif (cmdchar != 'r' && cmdchar != 'v' && c != Ctrl_C)\n\t\t    ins_apply_autocmds(EVENT_INSERTLEAVE);\n\t\tdid_cursorhold = FALSE;\n\t\treturn (c == Ctrl_O);\n\t    }\n\t    continue;\n\n\tcase Ctrl_Z:\t// suspend when 'insertmode' set\n\t    if (!p_im)\n\t\tgoto normalchar;\t// insert CTRL-Z as normal char\n\t    do_cmdline_cmd((char_u *)\"stop\");\n#ifdef CURSOR_SHAPE\n\t    ui_cursor_shape();\t\t// may need to update cursor shape\n#endif\n\t    continue;\n\n\tcase Ctrl_O:\t// execute one command\n#ifdef FEAT_COMPL_FUNC\n\t    if (ctrl_x_mode_omni())\n\t\tgoto docomplete;\n#endif\n\t    if (echeck_abbr(Ctrl_O + ABBR_OFF))\n\t\tbreak;\n\t    ins_ctrl_o();\n\n\t    // don't move the cursor left when 'virtualedit' has \"onemore\".\n\t    if (get_ve_flags() & VE_ONEMORE)\n\t    {\n\t\tins_at_eol = FALSE;\n\t\tnomove = TRUE;\n\t    }\n\t    count = 0;\n\t    goto doESCkey;\n\n\tcase K_INS:\t// toggle insert/replace mode\n\tcase K_KINS:\n\t    ins_insert(replaceState);\n\t    break;\n\n\tcase K_SELECT:\t// end of Select mode mapping - ignore\n\t    break;\n\n\tcase K_HELP:\t// Help key works like <ESC> <Help>\n\tcase K_F1:\n\tcase K_XF1:\n\t    stuffcharReadbuff(K_HELP);\n\t    if (p_im)\n\t\tneed_start_insertmode = TRUE;\n\t    goto doESCkey;\n\n#ifdef FEAT_NETBEANS_INTG\n\tcase K_F21:\t// NetBeans command\n\t    ++no_mapping;\t\t// don't map the next key hits\n\t    i = plain_vgetc();\n\t    --no_mapping;\n\t    netbeans_keycommand(i);\n\t    break;\n#endif\n\n\tcase K_ZERO:\t// Insert the previously inserted text.\n\tcase NUL:\n\tcase Ctrl_A:\n\t    // For ^@ the trailing ESC will end the insert, unless there is an\n\t    // error.\n\t    if (stuff_inserted(NUL, 1L, (c == Ctrl_A)) == FAIL\n\t\t\t\t\t\t   && c != Ctrl_A && !p_im)\n\t\tgoto doESCkey;\t\t// quit insert mode\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_R:\t// insert the contents of a register\n\t    ins_reg();\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_G:\t// commands starting with CTRL-G\n\t    ins_ctrl_g();\n\t    break;\n\n\tcase Ctrl_HAT:\t// switch input mode and/or langmap\n\t    ins_ctrl_hat();\n\t    break;\n\n#ifdef FEAT_RIGHTLEFT\n\tcase Ctrl__:\t// switch between languages\n\t    if (!p_ari)\n\t\tgoto normalchar;\n\t    ins_ctrl_();\n\t    break;\n#endif\n\n\tcase Ctrl_D:\t// Make indent one shiftwidth smaller.\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_defines())\n\t\tgoto docomplete;\n#endif\n\t    // FALLTHROUGH\n\n\tcase Ctrl_T:\t// Make indent one shiftwidth greater.\n\t    if (c == Ctrl_T && ctrl_x_mode_thesaurus())\n\t    {\n\t\tif (has_compl_option(FALSE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n\n\t    ins_shift(c, lastc);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_DEL:\t// delete character under the cursor\n\tcase K_KDEL:\n\t    ins_del();\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_BS:\t// delete character before the cursor\n\tcase K_S_BS:\n\tcase Ctrl_H:\n\t    did_backspace = ins_bs(c, BACKSPACE_CHAR, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_W:\t// delete word before the cursor\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf) && (mod_mask & MOD_MASK_SHIFT) == 0)\n\t    {\n\t\t// In a prompt window CTRL-W is used for window commands.\n\t\t// Use Shift-CTRL-W to delete a word.\n\t\tstuffcharReadbuff(Ctrl_W);\n\t\trestart_edit = 'A';\n\t\tnomove = TRUE;\n\t\tcount = 0;\n\t\tgoto doESCkey;\n\t    }\n#endif\n\t    did_backspace = ins_bs(c, BACKSPACE_WORD, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase Ctrl_U:\t// delete all inserted text in current line\n# ifdef FEAT_COMPL_FUNC\n\t    // CTRL-X CTRL-U completes with 'completefunc'.\n\t    if (ctrl_x_mode_function())\n\t\tgoto docomplete;\n# endif\n\t    did_backspace = ins_bs(c, BACKSPACE_LINE, &inserted_space);\n\t    auto_format(FALSE, TRUE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase K_LEFTMOUSE:   // mouse keys\n\tcase K_LEFTMOUSE_NM:\n\tcase K_LEFTDRAG:\n\tcase K_LEFTRELEASE:\n\tcase K_LEFTRELEASE_NM:\n\tcase K_MOUSEMOVE:\n\tcase K_MIDDLEMOUSE:\n\tcase K_MIDDLEDRAG:\n\tcase K_MIDDLERELEASE:\n\tcase K_RIGHTMOUSE:\n\tcase K_RIGHTDRAG:\n\tcase K_RIGHTRELEASE:\n\tcase K_X1MOUSE:\n\tcase K_X1DRAG:\n\tcase K_X1RELEASE:\n\tcase K_X2MOUSE:\n\tcase K_X2DRAG:\n\tcase K_X2RELEASE:\n\t    ins_mouse(c);\n\t    break;\n\n\tcase K_MOUSEDOWN: // Default action for scroll wheel up: scroll up\n\t    ins_mousescroll(MSCR_DOWN);\n\t    break;\n\n\tcase K_MOUSEUP:\t// Default action for scroll wheel down: scroll down\n\t    ins_mousescroll(MSCR_UP);\n\t    break;\n\n\tcase K_MOUSELEFT: // Scroll wheel left\n\t    ins_mousescroll(MSCR_LEFT);\n\t    break;\n\n\tcase K_MOUSERIGHT: // Scroll wheel right\n\t    ins_mousescroll(MSCR_RIGHT);\n\t    break;\n\n\tcase K_PS:\n\t    bracketed_paste(PASTE_INSERT, FALSE, NULL);\n\t    if (cmdchar == K_PS)\n\t\t// invoked from normal mode, bail out\n\t\tgoto doESCkey;\n\t    break;\n\tcase K_PE:\n\t    // Got K_PE without K_PS, ignore.\n\t    break;\n\n#ifdef FEAT_GUI_TABLINE\n\tcase K_TABLINE:\n\tcase K_TABMENU:\n\t    ins_tabline(c);\n\t    break;\n#endif\n\n\tcase K_IGNORE:\t// Something mapped to nothing\n\t    break;\n\n\tcase K_COMMAND:\t\t    // <Cmd>command<CR>\n\tcase K_SCRIPT_COMMAND:\t    // <ScriptCmd>command<CR>\n\t    do_cmdkey_command(c, 0);\n#ifdef FEAT_TERMINAL\n\t    if (term_use_loop())\n\t\t// Started a terminal that gets the input, exit Insert mode.\n\t\tgoto doESCkey;\n#endif\n\t    break;\n\n\tcase K_CURSORHOLD:\t// Didn't type something for a while.\n\t    ins_apply_autocmds(EVENT_CURSORHOLDI);\n\t    did_cursorhold = TRUE;\n\t    // If CTRL-G U was used apply it to the next typed key.\n\t    if (dont_sync_undo == TRUE)\n\t\tdont_sync_undo = MAYBE;\n\t    break;\n\n#ifdef FEAT_GUI_MSWIN\n\t    // On MS-Windows ignore <M-F4>, we get it when closing the window\n\t    // was cancelled.\n\tcase K_F4:\n\t    if (mod_mask != MOD_MASK_ALT)\n\t\tgoto normalchar;\n\t    break;\n#endif\n\n#ifdef FEAT_GUI\n\tcase K_VER_SCROLLBAR:\n\t    ins_scroll();\n\t    break;\n\n\tcase K_HOR_SCROLLBAR:\n\t    ins_horscroll();\n\t    break;\n#endif\n\n\tcase K_HOME:\t// <Home>\n\tcase K_KHOME:\n\tcase K_S_HOME:\n\tcase K_C_HOME:\n\t    ins_home(c);\n\t    break;\n\n\tcase K_END:\t// <End>\n\tcase K_KEND:\n\tcase K_S_END:\n\tcase K_C_END:\n\t    ins_end(c);\n\t    break;\n\n\tcase K_LEFT:\t// <Left>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_left();\n\t    else\n\t\tins_left();\n\t    break;\n\n\tcase K_S_LEFT:\t// <S-Left>\n\tcase K_C_LEFT:\n\t    ins_s_left();\n\t    break;\n\n\tcase K_RIGHT:\t// <Right>\n\t    if (mod_mask & (MOD_MASK_SHIFT|MOD_MASK_CTRL))\n\t\tins_s_right();\n\t    else\n\t\tins_right();\n\t    break;\n\n\tcase K_S_RIGHT:\t// <S-Right>\n\tcase K_C_RIGHT:\n\t    ins_s_right();\n\t    break;\n\n\tcase K_UP:\t// <Up>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pageup();\n\t    else\n\t\tins_up(FALSE);\n\t    break;\n\n\tcase K_S_UP:\t// <S-Up>\n\tcase K_PAGEUP:\n\tcase K_KPAGEUP:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pageup();\n\t    break;\n\n\tcase K_DOWN:\t// <Down>\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    if (mod_mask & MOD_MASK_SHIFT)\n\t\tins_pagedown();\n\t    else\n\t\tins_down(FALSE);\n\t    break;\n\n\tcase K_S_DOWN:\t// <S-Down>\n\tcase K_PAGEDOWN:\n\tcase K_KPAGEDOWN:\n\t    if (pum_visible())\n\t\tgoto docomplete;\n\t    ins_pagedown();\n\t    break;\n\n#ifdef FEAT_DND\n\tcase K_DROP:\t// drag-n-drop event\n\t    ins_drop();\n\t    break;\n#endif\n\n\tcase K_S_TAB:\t// When not mapped, use like a normal TAB\n\t    c = TAB;\n\t    // FALLTHROUGH\n\n\tcase TAB:\t// TAB or Complete patterns along path\n#if defined(FEAT_FIND_ID)\n\t    if (ctrl_x_mode_path_patterns())\n\t\tgoto docomplete;\n#endif\n\t    inserted_space = FALSE;\n\t    if (ins_tab())\n\t\tgoto normalchar;\t// insert TAB as a normal char\n\t    auto_format(FALSE, TRUE);\n\t    break;\n\n\tcase K_KENTER:\t// <Enter>\n\t    c = CAR;\n\t    // FALLTHROUGH\n\tcase CAR:\n\tcase NL:\n#if defined(FEAT_QUICKFIX)\n\t    // In a quickfix window a <CR> jumps to the error under the\n\t    // cursor.\n\t    if (bt_quickfix(curbuf) && c == CAR)\n\t    {\n\t\tif (curwin->w_llist_ref == NULL)    // quickfix window\n\t\t    do_cmdline_cmd((char_u *)\".cc\");\n\t\telse\t\t\t\t    // location list window\n\t\t    do_cmdline_cmd((char_u *)\".ll\");\n\t\tbreak;\n\t    }\n#endif\n#ifdef FEAT_CMDWIN\n\t    if (cmdwin_type != 0)\n\t    {\n\t\t// Execute the command in the cmdline window.\n\t\tcmdwin_result = CAR;\n\t\tgoto doESCkey;\n\t    }\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    if (bt_prompt(curbuf))\n\t    {\n\t\tinvoke_prompt_callback();\n\t\tif (!bt_prompt(curbuf))\n\t\t    // buffer changed to a non-prompt buffer, get out of\n\t\t    // Insert mode\n\t\t    goto doESCkey;\n\t\tbreak;\n\t    }\n#endif\n\t    if (ins_eol(c) == FAIL && !p_im)\n\t\tgoto doESCkey;\t    // out of memory\n\t    auto_format(FALSE, FALSE);\n\t    inserted_space = FALSE;\n\t    break;\n\n\tcase Ctrl_K:\t    // digraph or keyword completion\n\t    if (ctrl_x_mode_dictionary())\n\t    {\n\t\tif (has_compl_option(TRUE))\n\t\t    goto docomplete;\n\t\tbreak;\n\t    }\n#ifdef FEAT_DIGRAPHS\n\t    c = ins_digraph();\n\t    if (c == NUL)\n\t\tbreak;\n#endif\n\t    goto normalchar;\n\n\tcase Ctrl_X:\t// Enter CTRL-X mode\n\t    ins_ctrl_x();\n\t    break;\n\n\tcase Ctrl_RSB:\t// Tag name completion after ^X\n\t    if (!ctrl_x_mode_tags())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_F:\t// File name completion after ^X\n\t    if (!ctrl_x_mode_files())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase 's':\t// Spelling completion after ^X\n\tcase Ctrl_S:\n\t    if (!ctrl_x_mode_spell())\n\t\tgoto normalchar;\n\t    goto docomplete;\n\n\tcase Ctrl_L:\t// Whole line completion after ^X\n\t    if (!ctrl_x_mode_whole_line())\n\t    {\n\t\t// CTRL-L with 'insertmode' set: Leave Insert mode\n\t\tif (p_im)\n\t\t{\n\t\t    if (echeck_abbr(Ctrl_L + ABBR_OFF))\n\t\t\tbreak;\n\t\t    goto doESCkey;\n\t\t}\n\t\tgoto normalchar;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase Ctrl_P:\t// Do previous/next pattern completion\n\tcase Ctrl_N:\n\t    // if 'complete' is empty then plain ^P is no longer special,\n\t    // but it is under other ^X modes\n\t    if (*curbuf->b_p_cpt == NUL\n\t\t    && (ctrl_x_mode_normal() || ctrl_x_mode_whole_line())\n\t\t    && !compl_status_local())\n\t\tgoto normalchar;\n\ndocomplete:\n\t    compl_busy = TRUE;\n#ifdef FEAT_FOLDING\n\t    disable_fold_update++;  // don't redraw folds here\n#endif\n\t    if (ins_complete(c, TRUE) == FAIL)\n\t\tcompl_status_clear();\n#ifdef FEAT_FOLDING\n\t    disable_fold_update--;\n#endif\n\t    compl_busy = FALSE;\n#ifdef FEAT_SMARTINDENT\n\t    can_si = may_do_si(); // allow smartindenting\n#endif\n\t    break;\n\n\tcase Ctrl_Y:\t// copy from previous line or scroll down\n\tcase Ctrl_E:\t// copy from next line\t   or scroll up\n\t    c = ins_ctrl_ey(c);\n\t    break;\n\n\t  default:\n#ifdef UNIX\n\t    if (c == intr_char)\t\t// special interrupt char\n\t\tgoto do_intr;\n#endif\n\nnormalchar:\n\t    /*\n\t     * Insert a normal character.\n\t     */\n#if defined(FEAT_EVAL)\n\t    if (!p_paste)\n\t    {\n\t\t// Trigger InsertCharPre.\n\t\tchar_u *str = do_insert_char_pre(c);\n\t\tchar_u *p;\n\n\t\tif (str != NULL)\n\t\t{\n\t\t    if (*str != NUL && stop_arrow() != FAIL)\n\t\t    {\n\t\t\t// Insert the new value of v:char literally.\n\t\t\tfor (p = str; *p != NUL; MB_PTR_ADV(p))\n\t\t\t{\n\t\t\t    c = PTR2CHAR(p);\n\t\t\t    if (c == CAR || c == K_KENTER || c == NL)\n\t\t\t\tins_eol(c);\n\t\t\t    else\n\t\t\t\tins_char(c);\n\t\t\t}\n\t\t\tAppendToRedobuffLit(str, -1);\n\t\t    }\n\t\t    vim_free(str);\n\t\t    c = NUL;\n\t\t}\n\n\t\t// If the new value is already inserted or an empty string\n\t\t// then don't insert any character.\n\t\tif (c == NUL)\n\t\t    break;\n\t    }\n#endif\n#ifdef FEAT_SMARTINDENT\n\t    // Try to perform smart-indenting.\n\t    ins_try_si(c);\n#endif\n\n\t    if (c == ' ')\n\t    {\n\t\tinserted_space = TRUE;\n#ifdef FEAT_CINDENT\n\t\tif (inindent(0))\n\t\t    can_cindent = FALSE;\n#endif\n\t\tif (Insstart_blank_vcol == MAXCOL\n\t\t\t&& curwin->w_cursor.lnum == Insstart.lnum)\n\t\t    Insstart_blank_vcol = get_nolist_virtcol();\n\t    }\n\n\t    // Insert a normal character and check for abbreviations on a\n\t    // special character.  Let CTRL-] expand abbreviations without\n\t    // inserting it.\n\t    if (vim_iswordc(c) || (!echeck_abbr(\n\t\t\t// Add ABBR_OFF for characters above 0x100, this is\n\t\t\t// what check_abbr() expects.\n\t\t\t\t(has_mbyte && c >= 0x100) ? (c + ABBR_OFF) : c)\n\t\t\t&& c != Ctrl_RSB))\n\t    {\n\t\tinsert_special(c, FALSE, FALSE);\n#ifdef FEAT_RIGHTLEFT\n\t\trevins_legal++;\n\t\trevins_chars++;\n#endif\n\t    }\n\n\t    auto_format(FALSE, TRUE);\n\n#ifdef FEAT_FOLDING\n\t    // When inserting a character the cursor line must never be in a\n\t    // closed fold.\n\t    foldOpenCursor();\n#endif\n\t    break;\n\t}   // end of switch (c)\n\n\t// If typed something may trigger CursorHoldI again.\n\tif (c != K_CURSORHOLD\n#ifdef FEAT_COMPL_FUNC\n\t\t// but not in CTRL-X mode, a script can't restore the state\n\t\t&& ctrl_x_mode_normal()\n#endif\n\t       )\n\t    did_cursorhold = FALSE;\n\n\t// If the cursor was moved we didn't just insert a space\n\tif (arrow_used)\n\t    inserted_space = FALSE;\n\n#ifdef FEAT_CINDENT\n\tif (can_cindent && cindent_on() && ctrl_x_mode_normal())\n\t{\nforce_cindent:\n\t    /*\n\t     * Indent now if a key was typed that is in 'cinkeys'.\n\t     */\n\t    if (in_cinkeys(c, ' ', line_is_white))\n\t    {\n\t\tif (stop_arrow() == OK)\n\t\t    // re-indent the current line\n\t\t    do_c_expr_indent();\n\t    }\n\t}\n#endif // FEAT_CINDENT\n\n    }\t// for (;;)\n    // NOTREACHED\n}\n\n    int\nins_need_undo_get(void)\n{\n    return ins_need_undo;\n}\n\n/*\n * Redraw for Insert mode.\n * This is postponed until getting the next character to make '$' in the 'cpo'\n * option work correctly.\n * Only redraw when there are no characters available.  This speeds up\n * inserting sequences of characters (e.g., for CTRL-R).\n */\n    void\nins_redraw(int ready)\t    // not busy with something\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\tconceal_old_cursor_line = 0;\n    linenr_T\tconceal_new_cursor_line = 0;\n    int\t\tconceal_update_lines = FALSE;\n#endif\n\n    if (char_avail())\n\treturn;\n\n    // Trigger CursorMoved if the cursor moved.  Not when the popup menu is\n    // visible, the command might delete it.\n    if (ready && (has_cursormovedI()\n# ifdef FEAT_PROP_POPUP\n\t\t|| popup_visible\n# endif\n# if defined(FEAT_CONCEAL)\n\t\t|| curwin->w_p_cole > 0\n# endif\n\t\t)\n\t    && !EQUAL_POS(last_cursormoved, curwin->w_cursor)\n\t    && !pum_visible())\n    {\n# ifdef FEAT_SYN_HL\n\t// Need to update the screen first, to make sure syntax\n\t// highlighting is correct after making a change (e.g., inserting\n\t// a \"(\".  The autocommand may also require a redraw, so it's done\n\t// again below, unfortunately.\n\tif (syntax_present(curwin) && must_redraw)\n\t    update_screen(0);\n# endif\n\tif (has_cursormovedI())\n\t{\n\t    // Make sure curswant is correct, an autocommand may call\n\t    // getcurpos().\n\t    update_curswant();\n\t    ins_apply_autocmds(EVENT_CURSORMOVEDI);\n\t}\n#ifdef FEAT_PROP_POPUP\n\tif (popup_visible)\n\t    popup_check_cursor_pos();\n#endif\n# ifdef FEAT_CONCEAL\n\tif (curwin->w_p_cole > 0)\n\t{\n\t    conceal_old_cursor_line = last_cursormoved.lnum;\n\t    conceal_new_cursor_line = curwin->w_cursor.lnum;\n\t    conceal_update_lines = TRUE;\n\t}\n# endif\n\tlast_cursormoved = curwin->w_cursor;\n    }\n\n    // Trigger TextChangedI if b_changedtick_i differs.\n    if (ready && has_textchangedI()\n\t    && curbuf->b_last_changedtick_i != CHANGEDTICK(curbuf)\n\t    && !pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDI, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    // Trigger TextChangedP if b_changedtick_pum differs. When the popupmenu\n    // closes TextChangedI will need to trigger for backwards compatibility,\n    // thus use different b_last_changedtick* variables.\n    if (ready && has_textchangedP()\n\t    && curbuf->b_last_changedtick_pum != CHANGEDTICK(curbuf)\n\t    && pum_visible())\n    {\n\taco_save_T\taco;\n\tvarnumber_T\ttick = CHANGEDTICK(curbuf);\n\n\t// save and restore curwin and curbuf, in case the autocmd changes them\n\taucmd_prepbuf(&aco, curbuf);\n\tapply_autocmds(EVENT_TEXTCHANGEDP, NULL, NULL, FALSE, curbuf);\n\taucmd_restbuf(&aco);\n\tcurbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\tif (tick != CHANGEDTICK(curbuf))  // see ins_apply_autocmds()\n\t    u_save(curwin->w_cursor.lnum,\n\t\t\t\t\t(linenr_T)(curwin->w_cursor.lnum + 1));\n    }\n\n    if (ready)\n\tmay_trigger_winscrolled();\n\n    // Trigger SafeState if nothing is pending.\n    may_trigger_safestate(ready\n\t    && !ins_compl_active()\n\t    && !pum_visible());\n\n#if defined(FEAT_CONCEAL)\n    if ((conceal_update_lines\n\t    && (conceal_old_cursor_line != conceal_new_cursor_line\n\t\t|| conceal_cursor_line(curwin)))\n\t    || need_cursor_line_redraw)\n    {\n\tif (conceal_old_cursor_line != conceal_new_cursor_line)\n\t    redrawWinline(curwin, conceal_old_cursor_line);\n\tredrawWinline(curwin, conceal_new_cursor_line == 0\n\t\t\t    ? curwin->w_cursor.lnum : conceal_new_cursor_line);\n\tcurwin->w_valid &= ~VALID_CROW;\n\tneed_cursor_line_redraw = FALSE;\n    }\n#endif\n    if (must_redraw)\n\tupdate_screen(0);\n    else if (clear_cmdline || redraw_cmdline)\n\tshowmode();\t\t// clear cmdline and show mode\n    showruler(FALSE);\n    setcursor();\n    emsg_on_display = FALSE;\t// may remove error message now\n}\n\n/*\n * Handle a CTRL-V or CTRL-Q typed in Insert mode.\n */\n    static void\nins_ctrl_v(void)\n{\n    int\t\tc;\n    int\t\tdid_putchar = FALSE;\n\n    // may need to redraw when no more chars available now\n    ins_redraw(FALSE);\n\n    if (redrawing() && !char_avail())\n    {\n\tedit_putchar('^', TRUE);\n\tdid_putchar = TRUE;\n    }\n    AppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\n#ifdef FEAT_CMDL_INFO\n    add_to_showcmd_c(Ctrl_V);\n#endif\n\n    // Do not change any modifyOtherKeys ESC sequence to a normal key for\n    // CTRL-SHIFT-V.\n    c = get_literal(mod_mask & MOD_MASK_SHIFT);\n    if (did_putchar)\n\t// when the line fits in 'columns' the '^' is at the start of the next\n\t// line and will not removed by the redraw\n\tedit_unputchar();\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    insert_special(c, FALSE, TRUE);\n#ifdef FEAT_RIGHTLEFT\n    revins_chars++;\n    revins_legal++;\n#endif\n}\n\n/*\n * After getting an ESC or CSI for a literal key: If the typeahead buffer\n * contains a modifyOtherKeys sequence then decode it and return the result.\n * Otherwise return \"c\".\n * Note that this doesn't wait for characters, they must be in the typeahead\n * buffer already.\n */\n    static int\ndecodeModifyOtherKeys(int c)\n{\n    char_u  *p = typebuf.tb_buf + typebuf.tb_off;\n    int\t    idx;\n    int\t    form = 0;\n    int\t    argidx = 0;\n    int\t    arg[2] = {0, 0};\n\n    // Recognize:\n    // form 0: {lead}{key};{modifier}u\n    // form 1: {lead}27;{modifier};{key}~\n    if (typebuf.tb_len >= 4 && (c == CSI || (c == ESC && *p == '[')))\n    {\n\tidx = (*p == '[');\n\tif (p[idx] == '2' && p[idx + 1] == '7' && p[idx + 2] == ';')\n\t{\n\t    form = 1;\n\t    idx += 3;\n\t}\n\twhile (idx < typebuf.tb_len && argidx < 2)\n\t{\n\t    if (p[idx] == ';')\n\t\t++argidx;\n\t    else if (VIM_ISDIGIT(p[idx]))\n\t\targ[argidx] = arg[argidx] * 10 + (p[idx] - '0');\n\t    else\n\t\tbreak;\n\t    ++idx;\n\t}\n\tif (idx < typebuf.tb_len\n\t\t&& p[idx] == (form == 1 ? '~' : 'u')\n\t\t&& argidx == 1)\n\t{\n\t    // Match, consume the code.\n\t    typebuf.tb_off += idx + 1;\n\t    typebuf.tb_len -= idx + 1;\n#if defined(FEAT_CLIENTSERVER) || defined(FEAT_EVAL)\n\t    if (typebuf.tb_len == 0)\n\t\ttypebuf_was_filled = FALSE;\n#endif\n\n\t    mod_mask = decode_modifiers(arg[!form]);\n\t    c = merge_modifyOtherKeys(arg[form], &mod_mask);\n\t}\n    }\n\n    return c;\n}\n\n/*\n * Put a character directly onto the screen.  It's not stored in a buffer.\n * Used while handling CTRL-K, CTRL-V, etc. in Insert mode.\n */\nstatic int  pc_status;\n#define PC_STATUS_UNSET\t0\t// pc_bytes was not set\n#define PC_STATUS_RIGHT\t1\t// right half of double-wide char\n#define PC_STATUS_LEFT\t2\t// left half of double-wide char\n#define PC_STATUS_SET\t3\t// pc_bytes was filled\nstatic char_u pc_bytes[MB_MAXBYTES + 1]; // saved bytes\nstatic int  pc_attr;\nstatic int  pc_row;\nstatic int  pc_col;\n\n    void\nedit_putchar(int c, int highlight)\n{\n    int\t    attr;\n\n    if (ScreenLines != NULL)\n    {\n\tupdate_topline();\t// just in case w_topline isn't valid\n\tvalidate_cursor();\n\tif (highlight)\n\t    attr = HL_ATTR(HLF_8);\n\telse\n\t    attr = 0;\n\tpc_row = W_WINROW(curwin) + curwin->w_wrow;\n\tpc_col = curwin->w_wincol;\n\tpc_status = PC_STATUS_UNSET;\n#ifdef FEAT_RIGHTLEFT\n\tif (curwin->w_p_rl)\n\t{\n\t    pc_col += curwin->w_width - 1 - curwin->w_wcol;\n\t    if (has_mbyte)\n\t    {\n\t\tint fix_col = mb_fix_col(pc_col, pc_row);\n\n\t\tif (fix_col != pc_col)\n\t\t{\n\t\t    screen_putchar(' ', pc_row, fix_col, attr);\n\t\t    --curwin->w_wcol;\n\t\t    pc_status = PC_STATUS_RIGHT;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    pc_col += curwin->w_wcol;\n\t    if (mb_lefthalve(pc_row, pc_col))\n\t\tpc_status = PC_STATUS_LEFT;\n\t}\n\n\t// save the character to be able to put it back\n\tif (pc_status == PC_STATUS_UNSET)\n\t{\n\t    screen_getbytes(pc_row, pc_col, pc_bytes, &pc_attr);\n\t    pc_status = PC_STATUS_SET;\n\t}\n\tscreen_putchar(c, pc_row, pc_col, attr);\n    }\n}\n\n#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Set the insert start position for when using a prompt buffer.\n */\n    void\nset_insstart(linenr_T lnum, int col)\n{\n    Insstart.lnum = lnum;\n    Insstart.col = col;\n    Insstart_orig = Insstart;\n    Insstart_textlen = Insstart.col;\n    Insstart_blank_vcol = MAXCOL;\n    arrow_used = FALSE;\n}\n#endif\n\n/*\n * Undo the previous edit_putchar().\n */\n    void\nedit_unputchar(void)\n{\n    if (pc_status != PC_STATUS_UNSET && pc_row >= msg_scrolled)\n    {\n\tif (pc_status == PC_STATUS_RIGHT)\n\t    ++curwin->w_wcol;\n\tif (pc_status == PC_STATUS_RIGHT || pc_status == PC_STATUS_LEFT)\n\t    redrawWinline(curwin, curwin->w_cursor.lnum);\n\telse\n\t    screen_puts(pc_bytes, pc_row - msg_scrolled, pc_col, pc_attr);\n    }\n}\n\n/*\n * Called when p_dollar is set: display a '$' at the end of the changed text\n * Only works when cursor is in the line that changes.\n */\n    void\ndisplay_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\t// If on the last byte of a multi-byte move to the first byte.\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    // recompute w_wrow and w_wcol\n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}\n\n/*\n * Call this function before moving the cursor from the normal insert position\n * in insert mode.\n */\n    void\nundisplay_dollar(void)\n{\n    if (dollar_vcol >= 0)\n    {\n\tdollar_vcol = -1;\n\tredrawWinline(curwin, curwin->w_cursor.lnum);\n    }\n}\n\n/*\n * Truncate the space at the end of a line.  This is to be used only in an\n * insert mode.  It handles fixing the replace stack for MODE_REPLACE and\n * MODE_VREPLACE modes.\n */\n    void\ntruncate_spaces(char_u *line)\n{\n    int\t    i;\n\n    // find start of trailing white space\n    for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)\n    {\n\tif (State & REPLACE_FLAG)\n\t    replace_join(0);\t    // remove a NUL from the replace stack\n    }\n    line[i + 1] = NUL;\n}\n\n/*\n * Backspace the cursor until the given column.  Handles MODE_REPLACE and\n * MODE_VREPLACE modes correctly.  May also be used when not in insert mode at\n * all.  Will attempt not to go before \"col\" even when there is a composing\n * character.\n */\n    void\nbackspace_until_column(int col)\n{\n    while ((int)curwin->w_cursor.col > col)\n    {\n\tcurwin->w_cursor.col--;\n\tif (State & REPLACE_FLAG)\n\t    replace_do_bs(col);\n\telse if (!del_char_after_col(col))\n\t    break;\n    }\n}\n\n/*\n * Like del_char(), but make sure not to go before column \"limit_col\".\n * Only matters when there are composing characters.\n * Return TRUE when something was deleted.\n */\n   static int\ndel_char_after_col(int limit_col UNUSED)\n{\n    if (enc_utf8 && limit_col >= 0)\n    {\n\tcolnr_T ecol = curwin->w_cursor.col + 1;\n\n\t// Make sure the cursor is at the start of a character, but\n\t// skip forward again when going too far back because of a\n\t// composing character.\n\tmb_adjust_cursor();\n\twhile (curwin->w_cursor.col < (colnr_T)limit_col)\n\t{\n\t    int l = utf_ptr2len(ml_get_cursor());\n\n\t    if (l == 0)  // end of line\n\t\tbreak;\n\t    curwin->w_cursor.col += l;\n\t}\n\tif (*ml_get_cursor() == NUL || curwin->w_cursor.col == ecol)\n\t    return FALSE;\n\tdel_bytes((long)((int)ecol - curwin->w_cursor.col), FALSE, TRUE);\n    }\n    else\n\t(void)del_char(FALSE);\n    return TRUE;\n}\n\n/*\n * Next character is interpreted literally.\n * A one, two or three digit decimal number is interpreted as its byte value.\n * If one or two digits are entered, the next character is given to vungetc().\n * For Unicode a character > 255 may be returned.\n * If \"noReduceKeys\" is TRUE do not change any modifyOtherKeys ESC sequence\n * into a normal key, return ESC.\n */\n    int\nget_literal(int noReduceKeys)\n{\n    int\t\tcc;\n    int\t\tnc;\n    int\t\ti;\n    int\t\thex = FALSE;\n    int\t\toctal = FALSE;\n    int\t\tunicode = 0;\n\n    if (got_int)\n\treturn Ctrl_C;\n\n#ifdef FEAT_GUI\n    /*\n     * In GUI there is no point inserting the internal code for a special key.\n     * It is more useful to insert the string \"<KEY>\" instead.\tThis would\n     * probably be useful in a text window too, but it would not be\n     * vi-compatible (maybe there should be an option for it?) -- webb\n     */\n    if (gui.in_use)\n    {\n\t++allow_keys;\n\tif (noReduceKeys)\n\t    ++no_reduce_keys;\n    }\n#endif\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\t\t// don't map the next key hits\n    cc = 0;\n    i = 0;\n    for (;;)\n    {\n\tnc = plain_vgetc();\n\tif ((nc == ESC || nc == CSI) && !noReduceKeys)\n\t    nc = decodeModifyOtherKeys(nc);\n\n\tif ((mod_mask & ~MOD_MASK_SHIFT) != 0)\n\t    // A character with non-Shift modifiers should not be a valid\n\t    // character for i_CTRL-V_digit.\n\t    break;\n\n#ifdef FEAT_CMDL_INFO\n\tif ((State & MODE_CMDLINE) == 0 && MB_BYTE2LEN_CHECK(nc) == 1)\n\t    add_to_showcmd(nc);\n#endif\n\tif (nc == 'x' || nc == 'X')\n\t    hex = TRUE;\n\telse if (nc == 'o' || nc == 'O')\n\t    octal = TRUE;\n\telse if (nc == 'u' || nc == 'U')\n\t    unicode = nc;\n\telse\n\t{\n\t    if (hex || unicode != 0)\n\t    {\n\t\tif (!vim_isxdigit(nc))\n\t\t    break;\n\t\tcc = cc * 16 + hex2nr(nc);\n\t    }\n\t    else if (octal)\n\t    {\n\t\tif (nc < '0' || nc > '7')\n\t\t    break;\n\t\tcc = cc * 8 + nc - '0';\n\t    }\n\t    else\n\t    {\n\t\tif (!VIM_ISDIGIT(nc))\n\t\t    break;\n\t\tcc = cc * 10 + nc - '0';\n\t    }\n\n\t    ++i;\n\t}\n\n\tif (cc > 255 && unicode == 0)\n\t    cc = 255;\t\t// limit range to 0-255\n\tnc = 0;\n\n\tif (hex)\t\t// hex: up to two chars\n\t{\n\t    if (i >= 2)\n\t\tbreak;\n\t}\n\telse if (unicode)\t// Unicode: up to four or eight chars\n\t{\n\t    if ((unicode == 'u' && i >= 4) || (unicode == 'U' && i >= 8))\n\t\tbreak;\n\t}\n\telse if (i >= 3)\t// decimal or octal: up to three chars\n\t    break;\n    }\n    if (i == 0)\t    // no number entered\n    {\n\tif (nc == K_ZERO)   // NUL is stored as NL\n\t{\n\t    cc = '\\n';\n\t    nc = 0;\n\t}\n\telse\n\t{\n\t    cc = nc;\n\t    nc = 0;\n\t}\n    }\n\n    if (cc == 0)\t// NUL is stored as NL\n\tcc = '\\n';\n    if (enc_dbcs && (cc & 0xff) == 0)\n\tcc = '?';\t// don't accept an illegal DBCS char, the NUL in the\n\t\t\t// second byte will cause trouble!\n\n    --no_mapping;\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\t--allow_keys;\n\tif (noReduceKeys)\n\t    --no_reduce_keys;\n    }\n#endif\n    if (nc)\n    {\n\tvungetc(nc);\n\t// A character typed with i_CTRL-V_digit cannot have modifiers.\n\tmod_mask = 0;\n    }\n    got_int = FALSE;\t    // CTRL-C typed after CTRL-V is not an interrupt\n    return cc;\n}\n\n/*\n * Insert character, taking care of special keys and mod_mask\n */\n    static void\ninsert_special(\n    int\t    c,\n    int\t    allow_modmask,\n    int\t    ctrlv)\t    // c was typed after CTRL-V\n{\n    char_u  *p;\n    int\t    len;\n\n    /*\n     * Special function key, translate into \"<Key>\". Up to the last '>' is\n     * inserted with ins_str(), so as not to replace characters in replace\n     * mode.\n     * Only use mod_mask for special keys, to avoid things like <S-Space>,\n     * unless 'allow_modmask' is TRUE.\n     */\n#ifdef MACOS_X\n    // Command-key never produces a normal key\n    if (mod_mask & MOD_MASK_CMD)\n\tallow_modmask = TRUE;\n#endif\n    if (IS_SPECIAL(c) || (mod_mask && allow_modmask))\n    {\n\tp = get_special_key_name(c, mod_mask);\n\tlen = (int)STRLEN(p);\n\tc = p[len - 1];\n\tif (len > 2)\n\t{\n\t    if (stop_arrow() == FAIL)\n\t\treturn;\n\t    p[len - 1] = NUL;\n\t    ins_str(p);\n\t    AppendToRedobuffLit(p, -1);\n\t    ctrlv = FALSE;\n\t}\n    }\n    if (stop_arrow() == OK)\n\tinsertchar(c, ctrlv ? INSCHAR_CTRLV : 0, -1);\n}\n\n/*\n * Special characters in this context are those that need processing other\n * than the simple insertion that can be performed here. This includes ESC\n * which terminates the insert, and CR/NL which need special processing to\n * open up a new line. This routine tries to optimize insertions performed by\n * the \"redo\", \"undo\" or \"put\" commands, so it needs to know when it should\n * stop and defer processing to the \"normal\" mechanism.\n * '0' and '^' are special, because they can be followed by CTRL-D.\n */\n#define ISSPECIAL(c)\t((c) < ' ' || (c) >= DEL || (c) == '0' || (c) == '^')\n\n/*\n * \"flags\": INSCHAR_FORMAT - force formatting\n *\t    INSCHAR_CTRLV  - char typed just after CTRL-V\n *\t    INSCHAR_NO_FEX - don't use 'formatexpr'\n *\n *   NOTE: passes the flags value straight through to internal_format() which,\n *\t   beside INSCHAR_FORMAT (above), is also looking for these:\n *\t    INSCHAR_DO_COM   - format comments\n *\t    INSCHAR_COM_LIST - format comments with num list or 2nd line indent\n */\n    void\ninsertchar(\n    int\t\tc,\t\t\t// character to insert or NUL\n    int\t\tflags,\t\t\t// INSCHAR_FORMAT, etc.\n    int\t\tsecond_indent)\t\t// indent for second line if >= 0\n{\n    int\t\ttextwidth;\n    char_u\t*p;\n    int\t\tfo_ins_blank;\n    int\t\tforce_format = flags & INSCHAR_FORMAT;\n\n    textwidth = comp_textwidth(force_format);\n    fo_ins_blank = has_format_option(FO_INS_BLANK);\n\n    /*\n     * Try to break the line in two or more pieces when:\n     * - Always do this if we have been called to do formatting only.\n     * - Always do this when 'formatoptions' has the 'a' flag and the line\n     *   ends in white space.\n     * - Otherwise:\n     *\t - Don't do this if inserting a blank\n     *\t - Don't do this if an existing character is being replaced, unless\n     *\t   we're in MODE_VREPLACE state.\n     *\t - Do this if the cursor is not on the line where insert started\n     *\t or - 'formatoptions' doesn't have 'l' or the line was not too long\n     *\t       before the insert.\n     *\t    - 'formatoptions' doesn't have 'b' or a blank was inserted at or\n     *\t      before 'textwidth'\n     */\n    if (textwidth > 0\n\t    && (force_format\n\t\t|| (!VIM_ISWHITE(c)\n\t\t    && !((State & REPLACE_FLAG)\n\t\t\t&& !(State & VREPLACE_FLAG)\n\t\t\t&& *ml_get_cursor() != NUL)\n\t\t    && (curwin->w_cursor.lnum != Insstart.lnum\n\t\t\t|| ((!has_format_option(FO_INS_LONG)\n\t\t\t\t|| Insstart_textlen <= (colnr_T)textwidth)\n\t\t\t    && (!fo_ins_blank\n\t\t\t\t|| Insstart_blank_vcol <= (colnr_T)textwidth\n\t\t\t    ))))))\n    {\n\t// Format with 'formatexpr' when it's set.  Use internal formatting\n\t// when 'formatexpr' isn't set or it returns non-zero.\n#if defined(FEAT_EVAL)\n\tint     do_internal = TRUE;\n\tcolnr_T virtcol = get_nolist_virtcol()\n\t\t\t\t  + char2cells(c != NUL ? c : gchar_cursor());\n\n\tif (*curbuf->b_p_fex != NUL && (flags & INSCHAR_NO_FEX) == 0\n\t\t&& (force_format || virtcol > (colnr_T)textwidth))\n\t{\n\t    do_internal = (fex_format(curwin->w_cursor.lnum, 1L, c) != 0);\n\t    // It may be required to save for undo again, e.g. when setline()\n\t    // was called.\n\t    ins_need_undo = TRUE;\n\t}\n\tif (do_internal)\n#endif\n\t    internal_format(textwidth, second_indent, flags, c == NUL, c);\n    }\n\n    if (c == NUL)\t    // only formatting was wanted\n\treturn;\n\n    // Check whether this character should end a comment.\n    if (did_ai && c == end_comment_pending)\n    {\n\tchar_u  *line;\n\tchar_u\tlead_end[COM_MAX_LEN];\t    // end-comment string\n\tint\tmiddle_len, end_len;\n\tint\ti;\n\n\t/*\n\t * Need to remove existing (middle) comment leader and insert end\n\t * comment leader.  First, check what comment leader we can find.\n\t */\n\ti = get_leader_len(line = ml_get_curline(), &p, FALSE, TRUE);\n\tif (i > 0 && vim_strchr(p, COM_MIDDLE) != NULL)\t// Just checking\n\t{\n\t    // Skip middle-comment string\n\t    while (*p && p[-1] != ':')\t// find end of middle flags\n\t\t++p;\n\t    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\t    // Don't count trailing white space for middle_len\n\t    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))\n\t\t--middle_len;\n\n\t    // Find the end-comment string\n\t    while (*p && p[-1] != ':')\t// find end of end flags\n\t\t++p;\n\t    end_len = copy_option_part(&p, lead_end, COM_MAX_LEN, \",\");\n\n\t    // Skip white space before the cursor\n\t    i = curwin->w_cursor.col;\n\t    while (--i >= 0 && VIM_ISWHITE(line[i]))\n\t\t;\n\t    i++;\n\n\t    // Skip to before the middle leader\n\t    i -= middle_len;\n\n\t    // Check some expected things before we go on\n\t    if (i >= 0 && lead_end[end_len - 1] == end_comment_pending)\n\t    {\n\t\t// Backspace over all the stuff we want to replace\n\t\tbackspace_until_column(i);\n\n\t\t// Insert the end-comment string, except for the last\n\t\t// character, which will get inserted as normal later.\n\t\tins_bytes_len(lead_end, end_len - 1);\n\t    }\n\t}\n    }\n    end_comment_pending = NUL;\n\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    /*\n     * If there's any pending input, grab up to INPUT_BUFLEN at once.\n     * This speeds up normal text input considerably.\n     * Don't do this when 'cindent' or 'indentexpr' is set, because we might\n     * need to re-indent at a ':', or any other character (but not what\n     * 'paste' is set)..\n     * Don't do this when there an InsertCharPre autocommand is defined,\n     * because we need to fire the event for every character.\n     * Do the check for InsertCharPre before the call to vpeekc() because the\n     * InsertCharPre autocommand could change the input buffer.\n     */\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t\t// allow scrolling here\n#endif\n\n    if (       !ISSPECIAL(c)\n\t    && (!has_mbyte || (*mb_char2len)(c) == 1)\n\t    && !has_insertcharpre()\n\t    && vpeekc() != NUL\n\t    && !(State & REPLACE_FLAG)\n#ifdef FEAT_CINDENT\n\t    && !cindent_on()\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t    && !p_ri\n#endif\n\t   )\n    {\n#define INPUT_BUFLEN 100\n\tchar_u\t\tbuf[INPUT_BUFLEN + 1];\n\tint\t\ti;\n\tcolnr_T\t\tvirtcol = 0;\n\n\tbuf[0] = c;\n\ti = 1;\n\tif (textwidth > 0)\n\t    virtcol = get_nolist_virtcol();\n\t/*\n\t * Stop the string when:\n\t * - no more chars available\n\t * - finding a special character (command key)\n\t * - buffer is full\n\t * - running into the 'textwidth' boundary\n\t * - need to check for abbreviation: A non-word char after a word-char\n\t */\n\twhile (\t   (c = vpeekc()) != NUL\n\t\t&& !ISSPECIAL(c)\n\t\t&& (!has_mbyte || MB_BYTE2LEN_CHECK(c) == 1)\n\t\t&& i < INPUT_BUFLEN\n\t\t&& (textwidth == 0\n\t\t    || (virtcol += byte2cells(buf[i - 1])) < (colnr_T)textwidth)\n\t\t&& !(!no_abbr && !vim_iswordc(c) && vim_iswordc(buf[i - 1])))\n\t{\n#ifdef FEAT_RIGHTLEFT\n\t    c = vgetc();\n\t    if (p_hkmap && KeyTyped)\n\t\tc = hkmap(c);\t\t    // Hebrew mode mapping\n\t    buf[i++] = c;\n#else\n\t    buf[i++] = vgetc();\n#endif\n\t}\n\n#ifdef FEAT_DIGRAPHS\n\tdo_digraph(-1);\t\t\t// clear digraphs\n\tdo_digraph(buf[i-1]);\t\t// may be the start of a digraph\n#endif\n\tbuf[i] = NUL;\n\tins_str(buf);\n\tif (flags & INSCHAR_CTRLV)\n\t{\n\t    redo_literal(*buf);\n\t    i = 1;\n\t}\n\telse\n\t    i = 0;\n\tif (buf[i] != NUL)\n\t    AppendToRedobuffLit(buf + i, -1);\n    }\n    else\n    {\n\tint\t\tcc;\n\n\tif (has_mbyte && (cc = (*mb_char2len)(c)) > 1)\n\t{\n\t    char_u\tbuf[MB_MAXBYTES + 1];\n\n\t    (*mb_char2bytes)(c, buf);\n\t    buf[cc] = NUL;\n\t    ins_char_bytes(buf, cc);\n\t    AppendCharToRedobuff(c);\n\t}\n\telse\n\t{\n\t    ins_char(c);\n\t    if (flags & INSCHAR_CTRLV)\n\t\tredo_literal(c);\n\t    else\n\t\tAppendCharToRedobuff(c);\n\t}\n    }\n}\n\n/*\n * Put a character in the redo buffer, for when just after a CTRL-V.\n */\n    static void\nredo_literal(int c)\n{\n    char_u\tbuf[10];\n\n    // Only digits need special treatment.  Translate them into a string of\n    // three digits.\n    if (VIM_ISDIGIT(c))\n    {\n\tvim_snprintf((char *)buf, sizeof(buf), \"%03d\", c);\n\tAppendToRedobuff(buf);\n    }\n    else\n\tAppendCharToRedobuff(c);\n}\n\n/*\n * start_arrow() is called when an arrow key is used in insert mode.\n * For undo/redo it resembles hitting the <ESC> key.\n */\n    void\nstart_arrow(\n    pos_T    *end_insert_pos)\t\t// can be NULL\n{\n    start_arrow_common(end_insert_pos, TRUE);\n}\n\n/*\n * Like start_arrow() but with end_change argument.\n * Will prepare for redo of CTRL-G U if \"end_change\" is FALSE.\n */\n    static void\nstart_arrow_with_change(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    start_arrow_common(end_insert_pos, end_change);\n    if (!end_change)\n    {\n\tAppendCharToRedobuff(Ctrl_G);\n\tAppendCharToRedobuff('U');\n    }\n}\n\n    static void\nstart_arrow_common(\n    pos_T    *end_insert_pos,\t\t// can be NULL\n    int\t      end_change)\t\t// end undoable change\n{\n    if (!arrow_used && end_change)\t// something has been inserted\n    {\n\tAppendToRedobuff(ESC_STR);\n\tstop_insert(end_insert_pos, FALSE, FALSE);\n\tarrow_used = TRUE;\t// this means we stopped the current insert\n    }\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n}\n\n#ifdef FEAT_SPELL\n/*\n * If we skipped highlighting word at cursor, do it now.\n * It may be skipped again, thus reset spell_redraw_lnum first.\n */\n    static void\ncheck_spell_redraw(void)\n{\n    if (spell_redraw_lnum != 0)\n    {\n\tlinenr_T\tlnum = spell_redraw_lnum;\n\n\tspell_redraw_lnum = 0;\n\tredrawWinline(curwin, lnum);\n    }\n}\n\n#endif\n\n/*\n * stop_arrow() is called before a change is made in insert mode.\n * If an arrow key has been used, start a new insertion.\n * Returns FAIL if undo is impossible, shouldn't insert then.\n */\n    int\nstop_arrow(void)\n{\n    if (arrow_used)\n    {\n\tInsstart = curwin->w_cursor;\t// new insertion starts here\n\tif (Insstart.col > Insstart_orig.col && !ins_need_undo)\n\t    // Don't update the original insert position when moved to the\n\t    // right, except when nothing was inserted yet.\n\t    update_Insstart_orig = FALSE;\n\tInsstart_textlen = (colnr_T)linetabsize(ml_get_curline());\n\n\tif (u_save_cursor() == OK)\n\t{\n\t    arrow_used = FALSE;\n\t    ins_need_undo = FALSE;\n\t}\n\n\tai_col = 0;\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    orig_line_count = curbuf->b_ml.ml_line_count;\n\t    vr_lines_changed = 1;\n\t}\n\tResetRedobuff();\n\tAppendToRedobuff((char_u *)\"1i\");   // pretend we start an insertion\n\tnew_insert_skip = 2;\n    }\n    else if (ins_need_undo)\n    {\n\tif (u_save_cursor() == OK)\n\t    ins_need_undo = FALSE;\n    }\n\n#ifdef FEAT_FOLDING\n    // Always open fold at the cursor line when inserting something.\n    foldOpenCursor();\n#endif\n\n    return (arrow_used || ins_need_undo ? FAIL : OK);\n}\n\n/*\n * Do a few things to stop inserting.\n * \"end_insert_pos\" is where insert ended.  It is NULL when we already jumped\n * to another window/buffer.\n */\n    static void\nstop_insert(\n    pos_T\t*end_insert_pos,\n    int\t\tesc,\t\t\t// called by ins_esc()\n    int\t\tnomove)\t\t\t// <c-\\><c-o>, don't move cursor\n{\n    int\t\tcc;\n    char_u\t*ptr;\n\n    stop_redo_ins();\n    replace_flush();\t\t// abandon replace stack\n\n    /*\n     * Save the inserted text for later redo with ^@ and CTRL-A.\n     * Don't do it when \"restart_edit\" was set and nothing was inserted,\n     * otherwise CTRL-O w and then <Left> will clear \"last_insert\".\n     */\n    ptr = get_inserted();\n    if (did_restart_edit == 0 || (ptr != NULL\n\t\t\t\t       && (int)STRLEN(ptr) > new_insert_skip))\n    {\n\tvim_free(last_insert);\n\tlast_insert = ptr;\n\tlast_insert_skip = new_insert_skip;\n    }\n    else\n\tvim_free(ptr);\n\n    if (!arrow_used && end_insert_pos != NULL)\n    {\n\t// Auto-format now.  It may seem strange to do this when stopping an\n\t// insertion (or moving the cursor), but it's required when appending\n\t// a line and having it end in a space.  But only do it when something\n\t// was actually inserted, otherwise undo won't work.\n\tif (!ins_need_undo && has_format_option(FO_AUTO))\n\t{\n\t    pos_T   tpos = curwin->w_cursor;\n\n\t    // When the cursor is at the end of the line after a space the\n\t    // formatting will move it to the following word.  Avoid that by\n\t    // moving the cursor onto the space.\n\t    cc = 'x';\n\t    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL)\n\t    {\n\t\tdec_cursor();\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    curwin->w_cursor = tpos;\n\t    }\n\n\t    auto_format(TRUE, FALSE);\n\n\t    if (VIM_ISWHITE(cc))\n\t    {\n\t\tif (gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t\t// If the cursor is still at the same character, also keep\n\t\t// the \"coladd\".\n\t\tif (gchar_cursor() == NUL\n\t\t\t&& curwin->w_cursor.lnum == tpos.lnum\n\t\t\t&& curwin->w_cursor.col == tpos.col)\n\t\t    curwin->w_cursor.coladd = tpos.coladd;\n\t    }\n\t}\n\n\t// If a space was inserted for auto-formatting, remove it now.\n\tcheck_auto_format(TRUE);\n\n\t// If we just did an auto-indent, remove the white space from the end\n\t// of the line, and put the cursor back.\n\t// Do this when ESC was used or moving the cursor up/down.\n\t// Check for the old position still being valid, just in case the text\n\t// got changed unexpectedly.\n\tif (!nomove && did_ai && (esc || (vim_strchr(p_cpo, CPO_INDENT) == NULL\n\t\t\t&& curwin->w_cursor.lnum != end_insert_pos->lnum))\n\t\t&& end_insert_pos->lnum <= curbuf->b_ml.ml_line_count)\n\t{\n\t    pos_T\ttpos = curwin->w_cursor;\n\n\t    curwin->w_cursor = *end_insert_pos;\n\t    check_cursor_col();  // make sure it is not past the line\n\t    for (;;)\n\t    {\n\t\tif (gchar_cursor() == NUL && curwin->w_cursor.col > 0)\n\t\t    --curwin->w_cursor.col;\n\t\tcc = gchar_cursor();\n\t\tif (!VIM_ISWHITE(cc))\n\t\t    break;\n\t\tif (del_char(TRUE) == FAIL)\n\t\t    break;  // should not happen\n\t    }\n\t    if (curwin->w_cursor.lnum != tpos.lnum)\n\t\tcurwin->w_cursor = tpos;\n\t    else\n\t    {\n\t\t// reset tpos, could have been invalidated in the loop above\n\t\ttpos = curwin->w_cursor;\n\t\ttpos.col++;\n\t\tif (cc != NUL && gchar_pos(&tpos) == NUL)\n\t\t    ++curwin->w_cursor.col;\t// put cursor back on the NUL\n\t    }\n\n\t    // <C-S-Right> may have started Visual mode, adjust the position for\n\t    // deleted characters.\n\t    if (VIsual_active)\n\t\tcheck_visual_pos();\n\t}\n    }\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n\n    // Set '[ and '] to the inserted text.  When end_insert_pos is NULL we are\n    // now in a different buffer.\n    if (end_insert_pos != NULL)\n    {\n\tcurbuf->b_op_start = Insstart;\n\tcurbuf->b_op_start_orig = Insstart_orig;\n\tcurbuf->b_op_end = *end_insert_pos;\n    }\n}\n\n/*\n * Set the last inserted text to a single character.\n * Used for the replace command.\n */\n    void\nset_last_insert(int c)\n{\n    char_u\t*s;\n\n    vim_free(last_insert);\n    last_insert = alloc(MB_MAXBYTES * 3 + 5);\n    if (last_insert != NULL)\n    {\n\ts = last_insert;\n\t// Use the CTRL-V only when entering a special char\n\tif (c < ' ' || c == DEL)\n\t    *s++ = Ctrl_V;\n\ts = add_char2buf(c, s);\n\t*s++ = ESC;\n\t*s++ = NUL;\n\tlast_insert_skip = 0;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_last_insert(void)\n{\n    VIM_CLEAR(last_insert);\n}\n#endif\n\n/*\n * Add character \"c\" to buffer \"s\".  Escape the special meaning of K_SPECIAL\n * and CSI.  Handle multi-byte characters.\n * Returns a pointer to after the added bytes.\n */\n    char_u *\nadd_char2buf(int c, char_u *s)\n{\n    char_u\ttemp[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tlen;\n\n    len = (*mb_char2bytes)(c, temp);\n    for (i = 0; i < len; ++i)\n    {\n\tc = temp[i];\n\t// Need to escape K_SPECIAL and CSI like in the typeahead buffer.\n\tif (c == K_SPECIAL)\n\t{\n\t    *s++ = K_SPECIAL;\n\t    *s++ = KS_SPECIAL;\n\t    *s++ = KE_FILLER;\n\t}\n#ifdef FEAT_GUI\n\telse if (c == CSI)\n\t{\n\t    *s++ = CSI;\n\t    *s++ = KS_EXTRA;\n\t    *s++ = (int)KE_CSI;\n\t}\n#endif\n\telse\n\t    *s++ = c;\n    }\n    return s;\n}\n\n/*\n * move cursor to start of line\n * if flags & BL_WHITE\tmove to first non-white\n * if flags & BL_SOL\tmove to first non-white if startofline is set,\n *\t\t\t    otherwise keep \"curswant\" column\n * if flags & BL_FIX\tdon't leave the cursor on a NUL.\n */\n    void\nbeginline(int flags)\n{\n    if ((flags & BL_SOL) && !p_sol)\n\tcoladvance(curwin->w_curswant);\n    else\n    {\n\tcurwin->w_cursor.col = 0;\n\tcurwin->w_cursor.coladd = 0;\n\n\tif (flags & (BL_WHITE | BL_SOL))\n\t{\n\t    char_u  *ptr;\n\n\t    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)\n\t\t\t       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)\n\t\t++curwin->w_cursor.col;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * oneright oneleft cursor_down cursor_up\n *\n * Move one char {right,left,down,up}.\n * Doesn't move onto the NUL past the end of the line, unless it is allowed.\n * Return OK when successful, FAIL when we hit a line of file boundary.\n */\n\n    int\noneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\n\t// Adjust for multi-wide char (excluding TAB)\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\t// Return OK if the cursor moved, FAIL otherwise (at window edge).\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    // already at the very end\n\n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n\n    // move \"l\" bytes right, but don't end up on the NUL, unless 'virtualedit'\n    // contains \"onemore\".\n    if (ptr[l] == NUL && (get_ve_flags() & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}\n\n    int\noneleft(void)\n{\n    if (virtual_active())\n    {\n#ifdef FEAT_LINEBREAK\n\tint width;\n#endif\n\tint v = getviscol();\n\n\tif (v == 0)\n\t    return FAIL;\n\n#ifdef FEAT_LINEBREAK\n\t// We might get stuck on 'showbreak', skip over it.\n\twidth = 1;\n\tfor (;;)\n\t{\n\t    coladvance(v - width);\n\t    // getviscol() is slow, skip it when 'showbreak' is empty,\n\t    // 'breakindent' is not set and there are no multi-byte\n\t    // characters\n\t    if ((*get_showbreak_value(curwin) == NUL && !curwin->w_p_bri\n\t\t\t\t\t     && !has_mbyte) || getviscol() < v)\n\t\tbreak;\n\t    ++width;\n\t}\n#else\n\tcoladvance(v - 1);\n#endif\n\n\tif (curwin->w_cursor.coladd == 1)\n\t{\n\t    char_u *ptr;\n\n\t    // Adjust for multi-wide char (not a TAB)\n\t    ptr = ml_get_cursor();\n\t    if (*ptr != TAB && vim_isprintc((*mb_ptr2char)(ptr))\n\t\t\t\t\t\t\t && ptr2cells(ptr) > 1)\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\n\tcurwin->w_set_curswant = TRUE;\n\treturn OK;\n    }\n\n    if (curwin->w_cursor.col == 0)\n\treturn FAIL;\n\n    curwin->w_set_curswant = TRUE;\n    --curwin->w_cursor.col;\n\n    // if the character on the left of the current cursor is a multi-byte\n    // character, move to its first byte\n    if (has_mbyte)\n\tmb_adjust_cursor();\n    return OK;\n}\n\n    int\ncursor_up(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n\t// This fails if the cursor is already in the first line or the count\n\t// is larger than the line number and '-' is in 'cpoptions'\n\tif (lnum <= 1 || (n >= lnum && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (n >= lnum)\n\t    lnum = 1;\n\telse\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t{\n\t    /*\n\t     * Count each sequence of folded lines as one logical line.\n\t     */\n\t    // go to the start of the current fold\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\n\t    while (n--)\n\t    {\n\t\t// move up one line\n\t\t--lnum;\n\t\tif (lnum <= 1)\n\t\t    break;\n\t\t// If we entered a fold, move to the beginning, unless in\n\t\t// Insert mode or when 'foldopen' contains \"all\": it will open\n\t\t// in a moment.\n\t\tif (n > 0 || !((State & MODE_INSERT) || (fdo_flags & FDO_ALL)))\n\t\t    (void)hasFolding(lnum, &lnum, NULL);\n\t    }\n\t    if (lnum < 1)\n\t\tlnum = 1;\n\t}\n\telse\n#endif\n\t    lnum -= n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Cursor down a number of logical lines.\n */\n    int\ncursor_down(\n    long\tn,\n    int\t\tupd_topline)\t    // When TRUE: update topline\n{\n    linenr_T\tlnum;\n\n    if (n > 0)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Move to last line of fold, will fail if it's the end-of-file.\n\t(void)hasFolding(lnum, NULL, &lnum);\n#endif\n\t// This fails if the cursor is already in the last line or would move\n\t// beyond the last line and '-' is in 'cpoptions'\n\tif (lnum >= curbuf->b_ml.ml_line_count\n\t\t|| (lnum + n > curbuf->b_ml.ml_line_count\n\t\t    && vim_strchr(p_cpo, CPO_MINUS) != NULL))\n\t    return FAIL;\n\tif (lnum + n >= curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count;\n\telse\n#ifdef FEAT_FOLDING\n\tif (hasAnyFolding(curwin))\n\t{\n\t    linenr_T\tlast;\n\n\t    // count each sequence of folded lines as one logical line\n\t    while (n--)\n\t    {\n\t\tif (hasFolding(lnum, NULL, &last))\n\t\t    lnum = last + 1;\n\t\telse\n\t\t    ++lnum;\n\t\tif (lnum >= curbuf->b_ml.ml_line_count)\n\t\t    break;\n\t    }\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t\tlnum = curbuf->b_ml.ml_line_count;\n\t}\n\telse\n#endif\n\t    lnum += n;\n\tcurwin->w_cursor.lnum = lnum;\n    }\n\n    // try to advance to the column we want to be at\n    coladvance(curwin->w_curswant);\n\n    if (upd_topline)\n\tupdate_topline();\t// make sure curwin->w_topline is valid\n\n    return OK;\n}\n\n/*\n * Stuff the last inserted text in the read buffer.\n * Last_insert actually is a copy of the redo buffer, so we\n * first have to remove the command.\n */\n    int\nstuff_inserted(\n    int\t    c,\t\t// Command character to be inserted\n    long    count,\t// Repeat this many times\n    int\t    no_esc)\t// Don't add an ESC at the end\n{\n    char_u\t*esc_ptr;\n    char_u\t*ptr;\n    char_u\t*last_ptr;\n    char_u\tlast = NUL;\n\n    ptr = get_last_insert();\n    if (ptr == NULL)\n    {\n\temsg(_(e_no_inserted_text_yet));\n\treturn FAIL;\n    }\n\n    // may want to stuff the command character, to start Insert mode\n    if (c != NUL)\n\tstuffcharReadbuff(c);\n    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)\n\t*esc_ptr = NUL;\t    // remove the ESC\n\n    // when the last char is either \"0\" or \"^\" it will be quoted if no ESC\n    // comes after it OR if it will inserted more than once and \"ptr\"\n    // starts with ^D.\t-- Acevedo\n    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;\n    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')\n\t    && (no_esc || (*ptr == Ctrl_D && count > 1)))\n    {\n\tlast = *last_ptr;\n\t*last_ptr = NUL;\n    }\n\n    do\n    {\n\tstuffReadbuff(ptr);\n\t// a trailing \"0\" is inserted as \"<C-V>048\", \"^\" as \"<C-V>^\"\n\tif (last)\n\t    stuffReadbuff(\n\t\t       (char_u *)(last == '0' ? \"\\026\\060\\064\\070\" : \"\\026^\"));\n    }\n    while (--count > 0);\n\n    if (last)\n\t*last_ptr = last;\n\n    if (esc_ptr != NULL)\n\t*esc_ptr = ESC;\t    // put the ESC back\n\n    // may want to stuff a trailing ESC, to get out of Insert mode\n    if (!no_esc)\n\tstuffcharReadbuff(ESC);\n\n    return OK;\n}\n\n    char_u *\nget_last_insert(void)\n{\n    if (last_insert == NULL)\n\treturn NULL;\n    return last_insert + last_insert_skip;\n}\n\n/*\n * Get last inserted string, and remove trailing <Esc>.\n * Returns pointer to allocated memory (must be freed) or NULL.\n */\n    char_u *\nget_last_insert_save(void)\n{\n    char_u\t*s;\n    int\t\tlen;\n\n    if (last_insert == NULL)\n\treturn NULL;\n    s = vim_strsave(last_insert + last_insert_skip);\n    if (s != NULL)\n    {\n\tlen = (int)STRLEN(s);\n\tif (len > 0 && s[len - 1] == ESC)\t// remove trailing ESC\n\t    s[len - 1] = NUL;\n    }\n    return s;\n}\n\n/*\n * Check the word in front of the cursor for an abbreviation.\n * Called when the non-id character \"c\" has been entered.\n * When an abbreviation is recognized it is removed from the text and\n * the replacement string is inserted in typebuf.tb_buf[], followed by \"c\".\n */\n    static int\necheck_abbr(int c)\n{\n    // Don't check for abbreviation in paste mode, when disabled and just\n    // after moving around with cursor keys.\n    if (p_paste || no_abbr || arrow_used)\n\treturn FALSE;\n\n    return check_abbr(c, ml_get_curline(), curwin->w_cursor.col,\n\t\tcurwin->w_cursor.lnum == Insstart.lnum ? Insstart.col : 0);\n}\n\n/*\n * replace-stack functions\n *\n * When replacing characters, the replaced characters are remembered for each\n * new character.  This is used to re-insert the old text when backspacing.\n *\n * There is a NUL headed list of characters for each character that is\n * currently in the file after the insertion point.  When BS is used, one NUL\n * headed list is put back for the deleted character.\n *\n * For a newline, there are two NUL headed lists.  One contains the characters\n * that the NL replaced.  The extra one stores the characters after the cursor\n * that were deleted (always white space).\n *\n * Replace_offset is normally 0, in which case replace_push will add a new\n * character at the end of the stack.  If replace_offset is not 0, that many\n * characters will be left on the stack above the newly inserted character.\n */\n\nstatic char_u\t*replace_stack = NULL;\nstatic long\treplace_stack_nr = 0;\t    // next entry in replace stack\nstatic long\treplace_stack_len = 0;\t    // max. number of entries\n\n    void\nreplace_push(\n    int\t    c)\t    // character that is replaced (NUL is none)\n{\n    char_u  *p;\n\n    if (replace_stack_nr < replace_offset)\t// nothing to do\n\treturn;\n    if (replace_stack_len <= replace_stack_nr)\n    {\n\treplace_stack_len += 50;\n\tp = ALLOC_MULT(char_u, replace_stack_len);\n\tif (p == NULL)\t    // out of memory\n\t{\n\t    replace_stack_len -= 50;\n\t    return;\n\t}\n\tif (replace_stack != NULL)\n\t{\n\t    mch_memmove(p, replace_stack,\n\t\t\t\t (size_t)(replace_stack_nr * sizeof(char_u)));\n\t    vim_free(replace_stack);\n\t}\n\treplace_stack = p;\n    }\n    p = replace_stack + replace_stack_nr - replace_offset;\n    if (replace_offset)\n\tmch_memmove(p + 1, p, (size_t)(replace_offset * sizeof(char_u)));\n    *p = c;\n    ++replace_stack_nr;\n}\n\n/*\n * Push a character onto the replace stack.  Handles a multi-byte character in\n * reverse byte order, so that the first byte is popped off first.\n * Return the number of bytes done (includes composing characters).\n */\n    int\nreplace_push_mb(char_u *p)\n{\n    int l = (*mb_ptr2len)(p);\n    int j;\n\n    for (j = l - 1; j >= 0; --j)\n\treplace_push(p[j]);\n    return l;\n}\n\n/*\n * Pop one item from the replace stack.\n * return -1 if stack empty\n * return replaced character or NUL otherwise\n */\n    static int\nreplace_pop(void)\n{\n    if (replace_stack_nr == 0)\n\treturn -1;\n    return (int)replace_stack[--replace_stack_nr];\n}\n\n/*\n * Join the top two items on the replace stack.  This removes to \"off\"'th NUL\n * encountered.\n */\n    void\nreplace_join(\n    int\t    off)\t// offset for which NUL to remove\n{\n    int\t    i;\n\n    for (i = replace_stack_nr; --i >= 0; )\n\tif (replace_stack[i] == NUL && off-- <= 0)\n\t{\n\t    --replace_stack_nr;\n\t    mch_memmove(replace_stack + i, replace_stack + i + 1,\n\t\t\t\t\t      (size_t)(replace_stack_nr - i));\n\t    return;\n\t}\n}\n\n/*\n * Pop bytes from the replace stack until a NUL is found, and insert them\n * before the cursor.  Can only be used in MODE_REPLACE or MODE_VREPLACE state.\n */\n    static void\nreplace_pop_ins(void)\n{\n    int\t    cc;\n    int\t    oldState = State;\n\n    State = MODE_NORMAL;\t\t\t// don't want MODE_REPLACE here\n    while ((cc = replace_pop()) > 0)\n    {\n\tmb_replace_pop_ins(cc);\n\tdec_cursor();\n    }\n    State = oldState;\n}\n\n/*\n * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it\n * indicates a multi-byte char, pop the other bytes too.\n */\n    static void\nmb_replace_pop_ins(int cc)\n{\n    int\t\tn;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\ti;\n    int\t\tc;\n\n    if (has_mbyte && (n = MB_BYTE2LEN(cc)) > 1)\n    {\n\tbuf[0] = cc;\n\tfor (i = 1; i < n; ++i)\n\t    buf[i] = replace_pop();\n\tins_bytes_len(buf, n);\n    }\n    else\n\tins_char(cc);\n\n    if (enc_utf8)\n\t// Handle composing chars.\n\tfor (;;)\n\t{\n\t    c = replace_pop();\n\t    if (c == -1)\t    // stack empty\n\t\tbreak;\n\t    if ((n = MB_BYTE2LEN(c)) == 1)\n\t    {\n\t\t// Not a multi-byte char, put it back.\n\t\treplace_push(c);\n\t\tbreak;\n\t    }\n\n\t    buf[0] = c;\n\t    for (i = 1; i < n; ++i)\n\t\tbuf[i] = replace_pop();\n\t    if (utf_iscomposing(utf_ptr2char(buf)))\n\t\tins_bytes_len(buf, n);\n\t    else\n\t    {\n\t\t// Not a composing char, put it back.\n\t\tfor (i = n - 1; i >= 0; --i)\n\t\t    replace_push(buf[i]);\n\t\tbreak;\n\t    }\n\n\t}\n}\n\n/*\n * make the replace stack empty\n * (called when exiting replace mode)\n */\n    static void\nreplace_flush(void)\n{\n    VIM_CLEAR(replace_stack);\n    replace_stack_len = 0;\n    replace_stack_nr = 0;\n}\n\n/*\n * Handle doing a BS for one character.\n * cc < 0: replace stack empty, just move cursor\n * cc == 0: character was inserted, delete it\n * cc > 0: character was replaced, put cc (first byte of original char) back\n * and check for more characters to be put back\n * When \"limit_col\" is >= 0, don't delete before this column.  Matters when\n * using composing characters, use del_char_after_col() instead of del_char().\n */\n    static void\nreplace_do_bs(int limit_col)\n{\n    int\t\tcc;\n    int\t\torig_len = 0;\n    int\t\tins_len;\n    int\t\torig_vcols = 0;\n    colnr_T\tstart_vcol;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tvcol;\n\n    cc = replace_pop();\n    if (cc > 0)\n    {\n#ifdef FEAT_PROP_POPUP\n\tsize_t\tlen_before = 0;  // init to shut up GCC\n\n\tif (curbuf->b_has_textprop)\n\t{\n\t    // Do not adjust text properties for individual delete and insert\n\t    // operations, do it afterwards on the resulting text.\n\t    len_before = STRLEN(ml_get_curline());\n\t    ++text_prop_frozen;\n\t}\n#endif\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the character we are\n\t    // going to delete.\n\t    getvcol(curwin, &curwin->w_cursor, NULL, &start_vcol, NULL);\n\t    orig_vcols = chartabsize(ml_get_cursor(), start_vcol);\n\t}\n\tif (has_mbyte)\n\t{\n\t    (void)del_char_after_col(limit_col);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor());\n\t    replace_push(cc);\n\t}\n\telse\n\t{\n\t    pchar_cursor(cc);\n\t    if (State & VREPLACE_FLAG)\n\t\torig_len = (int)STRLEN(ml_get_cursor()) - 1;\n\t}\n\treplace_pop_ins();\n\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    // Get the number of screen cells used by the inserted characters\n\t    p = ml_get_cursor();\n\t    ins_len = (int)STRLEN(p) - orig_len;\n\t    vcol = start_vcol;\n\t    for (i = 0; i < ins_len; ++i)\n\t    {\n\t\tvcol += chartabsize(p + i, vcol);\n\t\ti += (*mb_ptr2len)(p) - 1;\n\t    }\n\t    vcol -= start_vcol;\n\n\t    // Delete spaces that were inserted after the cursor to keep the\n\t    // text aligned.\n\t    curwin->w_cursor.col += ins_len;\n\t    while (vcol > orig_vcols && gchar_cursor() == ' ')\n\t    {\n\t\tdel_char(FALSE);\n\t\t++orig_vcols;\n\t    }\n\t    curwin->w_cursor.col -= ins_len;\n\t}\n\n\t// mark the buffer as changed and prepare for displaying\n\tchanged_bytes(curwin->w_cursor.lnum, curwin->w_cursor.col);\n\n#ifdef FEAT_PROP_POPUP\n\tif (curbuf->b_has_textprop)\n\t{\n\t    size_t len_now = STRLEN(ml_get_curline());\n\n\t    --text_prop_frozen;\n\t    adjust_prop_columns(curwin->w_cursor.lnum, curwin->w_cursor.col,\n\t\t\t\t\t   (int)(len_now - len_before), 0);\n\t}\n#endif\n    }\n    else if (cc == 0)\n\t(void)del_char_after_col(limit_col);\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Map Hebrew keyboard when in hkmap mode.\n */\n    int\nhkmap(int c)\n{\n    if (p_hkmapp)   // phonetic mapping, by Ilya Dogolazky\n    {\n\tenum {hALEF=0, BET, GIMEL, DALET, HEI, VAV, ZAIN, HET, TET, IUD,\n\t    KAFsofit, hKAF, LAMED, MEMsofit, MEM, NUNsofit, NUN, SAMEH, AIN,\n\t    PEIsofit, PEI, ZADIsofit, ZADI, KOF, RESH, hSHIN, TAV};\n\tstatic char_u map[26] =\n\t    {(char_u)hALEF/*a*/, (char_u)BET  /*b*/, (char_u)hKAF    /*c*/,\n\t     (char_u)DALET/*d*/, (char_u)-1   /*e*/, (char_u)PEIsofit/*f*/,\n\t     (char_u)GIMEL/*g*/, (char_u)HEI  /*h*/, (char_u)IUD     /*i*/,\n\t     (char_u)HET  /*j*/, (char_u)KOF  /*k*/, (char_u)LAMED   /*l*/,\n\t     (char_u)MEM  /*m*/, (char_u)NUN  /*n*/, (char_u)SAMEH   /*o*/,\n\t     (char_u)PEI  /*p*/, (char_u)-1   /*q*/, (char_u)RESH    /*r*/,\n\t     (char_u)ZAIN /*s*/, (char_u)TAV  /*t*/, (char_u)TET     /*u*/,\n\t     (char_u)VAV  /*v*/, (char_u)hSHIN/*w*/, (char_u)-1      /*x*/,\n\t     (char_u)AIN  /*y*/, (char_u)ZADI /*z*/};\n\n\tif (c == 'N' || c == 'M' || c == 'P' || c == 'C' || c == 'Z')\n\t    return (int)(map[CharOrd(c)] - 1 + p_aleph);\n\t\t\t\t\t\t\t    // '-1'='sofit'\n\telse if (c == 'x')\n\t    return 'X';\n\telse if (c == 'q')\n\t    return '\\''; // {geresh}={'}\n\telse if (c == 246)\n\t    return ' ';  // \\\"o --> ' ' for a german keyboard\n\telse if (c == 228)\n\t    return ' ';  // \\\"a --> ' '      -- / --\n\telse if (c == 252)\n\t    return ' ';  // \\\"u --> ' '      -- / --\n\t// NOTE: islower() does not do the right thing for us on Linux so we\n\t// do this the same was as 5.7 and previous, so it works correctly on\n\t// all systems.  Specifically, the e.g. Delete and Arrow keys are\n\t// munged and won't work if e.g. searching for Hebrew text.\n\telse if (c >= 'a' && c <= 'z')\n\t    return (int)(map[CharOrdLow(c)] + p_aleph);\n\telse\n\t    return c;\n    }\n    else\n    {\n\tswitch (c)\n\t{\n\t    case '`':\treturn ';';\n\t    case '/':\treturn '.';\n\t    case '\\'':\treturn ',';\n\t    case 'q':\treturn '/';\n\t    case 'w':\treturn '\\'';\n\n\t\t\t// Hebrew letters - set offset from 'a'\n\t    case ',':\tc = '{'; break;\n\t    case '.':\tc = 'v'; break;\n\t    case ';':\tc = 't'; break;\n\t    default: {\n\t\t\t static char str[] = \"zqbcxlsjphmkwonu ydafe rig\";\n\n\t\t\t if (c < 'a' || c > 'z')\n\t\t\t     return c;\n\t\t\t c = str[CharOrdLow(c)];\n\t\t\t break;\n\t\t     }\n\t}\n\n\treturn (int)(CharOrdLow(c) + p_aleph);\n    }\n}\n#endif\n\n    static void\nins_reg(void)\n{\n    int\t\tneed_redraw = FALSE;\n    int\t\tregname;\n    int\t\tliterally = 0;\n    int\t\tvis_active = VIsual_active;\n\n    /*\n     * If we are going to wait for a character, show a '\"'.\n     */\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('\"', TRUE);\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_R);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    /*\n     * Don't map the register name. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    regname = plain_vgetc();\n    LANGMAP_ADJUST(regname, TRUE);\n    if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P)\n    {\n\t// Get a third key for literal register insertion\n\tliterally = regname;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(literally);\n#endif\n\tregname = plain_vgetc();\n\tLANGMAP_ADJUST(regname, TRUE);\n    }\n    --no_mapping;\n    --allow_keys;\n\n#ifdef FEAT_EVAL\n    // Don't call u_sync() while typing the expression or giving an error\n    // message for it. Only call it explicitly.\n    ++no_u_sync;\n    if (regname == '=')\n    {\n\tpos_T\tcurpos = curwin->w_cursor;\n# ifdef HAVE_INPUT_METHOD\n\tint\tim_on = im_get_status();\n# endif\n\t// Sync undo when evaluating the expression calls setline() or\n\t// append(), so that it can be undone separately.\n\tu_sync_once = 2;\n\n\tregname = get_expr_register();\n\n\t// Cursor may be moved back a column.\n\tcurwin->w_cursor = curpos;\n\tcheck_cursor();\n# ifdef HAVE_INPUT_METHOD\n\t// Restore the Input Method.\n\tif (im_on)\n\t    im_set_active(TRUE);\n# endif\n    }\n    if (regname == NUL || !valid_yank_reg(regname, FALSE))\n    {\n\tvim_beep(BO_REG);\n\tneed_redraw = TRUE;\t// remove the '\"'\n    }\n    else\n    {\n#endif\n\tif (literally == Ctrl_O || literally == Ctrl_P)\n\t{\n\t    // Append the command to the redo buffer.\n\t    AppendCharToRedobuff(Ctrl_R);\n\t    AppendCharToRedobuff(literally);\n\t    AppendCharToRedobuff(regname);\n\n\t    do_put(regname, NULL, BACKWARD, 1L,\n\t\t (literally == Ctrl_P ? PUT_FIXINDENT : 0) | PUT_CURSEND);\n\t}\n\telse if (insert_reg(regname, literally) == FAIL)\n\t{\n\t    vim_beep(BO_REG);\n\t    need_redraw = TRUE;\t// remove the '\"'\n\t}\n\telse if (stop_insert_mode)\n\t    // When the '=' register was used and a function was invoked that\n\t    // did \":stopinsert\" then stuff_empty() returns FALSE but we won't\n\t    // insert anything, need to remove the '\"'\n\t    need_redraw = TRUE;\n\n#ifdef FEAT_EVAL\n    }\n    --no_u_sync;\n    if (u_sync_once == 1)\n\tins_need_undo = TRUE;\n    u_sync_once = 0;\n#endif\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n\n    // If the inserted register is empty, we need to remove the '\"'\n    if (need_redraw || stuff_empty())\n\tedit_unputchar();\n\n    // Disallow starting Visual mode here, would get a weird mode.\n    if (!vis_active && VIsual_active)\n\tend_visual_mode();\n}\n\n/*\n * CTRL-G commands in Insert mode.\n */\n    static void\nins_ctrl_g(void)\n{\n    int\t\tc;\n\n    // Right after CTRL-X the cursor will be after the ruler.\n    setcursor();\n\n    /*\n     * Don't map the second key. This also prevents the mode message to be\n     * deleted when ESC is hit.\n     */\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    switch (c)\n    {\n\t// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col\n\tcase K_UP:\n\tcase Ctrl_K:\n\tcase 'k': ins_up(TRUE);\n\t\t  break;\n\n\t// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col\n\tcase K_DOWN:\n\tcase Ctrl_J:\n\tcase 'j': ins_down(TRUE);\n\t\t  break;\n\n\t// CTRL-G u: start new undoable edit\n\tcase 'u': u_sync(TRUE);\n\t\t  ins_need_undo = TRUE;\n\n\t\t  // Need to reset Insstart, esp. because a BS that joins\n\t\t  // a line to the previous one must save for undo.\n\t\t  update_Insstart_orig = FALSE;\n\t\t  Insstart = curwin->w_cursor;\n\t\t  break;\n\n\t// CTRL-G U: do not break undo with the next char\n\tcase 'U':\n\t\t  // Allow one left/right cursor movement with the next char,\n\t\t  // without breaking undo.\n\t\t  dont_sync_undo = MAYBE;\n\t\t  break;\n\n\t// Unknown CTRL-G command, reserved for future expansion.\n\tdefault:  vim_beep(BO_CTRLG);\n    }\n}\n\n/*\n * CTRL-^ in Insert mode.\n */\n    static void\nins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", MODE_LANGMAP, FALSE))\n    {\n\t// \":lmap\" mappings exists, Toggle use of \":lmap\" mappings.\n\tif (State & MODE_LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~MODE_LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\t// There are no \":lmap\" mappings, toggle IM\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~MODE_LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    // may show different cursor shape or color\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    // Show/unshow value of 'keymap' in status lines.\n    status_redraw_curbuf();\n#endif\n}\n\n/*\n * Handle ESC in insert mode.\n * Returns TRUE when leaving insert mode, FALSE when going to repeat the\n * insert.\n */\n    static int\nins_esc(\n    long\t*count,\n    int\t\tcmdchar,\n    int\t\tnomove)\t    // don't move cursor\n{\n    int\t\ttemp;\n    static int\tdisabled_redraw = FALSE;\n#ifdef FEAT_CONCEAL\n    // Remember if the cursor line was concealed before changing State.\n    int\t\tcursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n#ifdef FEAT_SPELL\n    check_spell_redraw();\n#endif\n\n    temp = curwin->w_cursor.col;\n    if (disabled_redraw)\n    {\n\t--RedrawingDisabled;\n\tdisabled_redraw = FALSE;\n    }\n    if (!arrow_used)\n    {\n\t/*\n\t * Don't append the ESC for \"r<CR>\" and \"grx\".\n\t * When 'insertmode' is set only CTRL-L stops Insert mode.  Needed for\n\t * when \"count\" is non-zero.\n\t */\n\tif (cmdchar != 'r' && cmdchar != 'v')\n\t    AppendToRedobuff(p_im ? (char_u *)\"\\014\" : ESC_STR);\n\n\t/*\n\t * Repeating insert may take a long time.  Check for\n\t * interrupt now and then.\n\t */\n\tif (*count > 0)\n\t{\n\t    line_breakcheck();\n\t    if (got_int)\n\t\t*count = 0;\n\t}\n\n\tif (--*count > 0)\t// repeat what was typed\n\t{\n\t    // Vi repeats the insert without replacing characters.\n\t    if (vim_strchr(p_cpo, CPO_REPLCNT) != NULL)\n\t\tState &= ~REPLACE_FLAG;\n\n\t    (void)start_redo_ins();\n\t    if (cmdchar == 'r' || cmdchar == 'v')\n\t\tstuffRedoReadbuff(ESC_STR);\t// no ESC in redo buffer\n\t    ++RedrawingDisabled;\n\t    disabled_redraw = TRUE;\n\t    return FALSE;\t// repeat the insert\n\t}\n\tstop_insert(&curwin->w_cursor, TRUE, nomove);\n\tundisplay_dollar();\n    }\n\n    if (cmdchar != 'r' && cmdchar != 'v')\n\tins_apply_autocmds(EVENT_INSERTLEAVEPRE);\n\n    // When an autoindent was removed, curswant stays after the\n    // indent\n    if (restart_edit == NUL && (colnr_T)temp == curwin->w_cursor.col)\n\tcurwin->w_set_curswant = TRUE;\n\n    // Remember the last Insert position in the '^ mark.\n    if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0)\n\tcurbuf->b_last_insert = curwin->w_cursor;\n\n    /*\n     * The cursor should end up on the last inserted character.\n     * Don't do it for CTRL-O, unless past the end of the line.\n     */\n    if (!nomove\n\t    && (curwin->w_cursor.col != 0\n\t\t|| curwin->w_cursor.coladd > 0)\n\t    && (restart_edit == NUL\n\t\t   || (gchar_cursor() == NUL && !VIsual_active))\n#ifdef FEAT_RIGHTLEFT\n\t    && !revins_on\n#endif\n\t\t\t\t      )\n    {\n\tif (curwin->w_cursor.coladd > 0 || get_ve_flags() == VE_ALL)\n\t{\n\t    oneleft();\n\t    if (restart_edit != NUL)\n\t\t++curwin->w_cursor.coladd;\n\t}\n\telse\n\t{\n\t    --curwin->w_cursor.col;\n\t    // Correct cursor for multi-byte character.\n\t    if (has_mbyte)\n\t\tmb_adjust_cursor();\n\t}\n    }\n\n#ifdef HAVE_INPUT_METHOD\n    // Disable IM to allow typing English directly for Normal mode commands.\n    // When \":lmap\" is enabled don't change 'iminsert' (IM can be enabled as\n    // well).\n    if (!(State & MODE_LANGMAP))\n\tim_save_status(&curbuf->b_p_iminsert);\n    im_set_active(FALSE);\n#endif\n\n    State = MODE_NORMAL;\n    may_trigger_modechanged();\n    // need to position cursor again when on a TAB\n    if (gchar_cursor() == TAB)\n\tcurwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);\n\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    if (!p_ek)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tch_log_output = TRUE;\n#endif\n\t// Re-enable bracketed paste mode.\n\tout_str(T_BE);\n\n\t// Re-enable modifyOtherKeys.\n\tout_str(T_CTI);\n    }\n#ifdef FEAT_CONCEAL\n    // Check if the cursor line needs redrawing after changing State.  If\n    // 'concealcursor' is \"i\" it needs to be redrawn without concealing.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    // When recording or for CTRL-O, need to display the new mode.\n    // Otherwise remove the mode message.\n    if (reg_recording != 0 || restart_edit != NUL)\n\tshowmode();\n    else if (p_smd && (got_int || !skip_showmode()))\n\tmsg(\"\");\n\n    return TRUE;\t    // exit Insert mode\n}\n\n#ifdef FEAT_RIGHTLEFT\n/*\n * Toggle language: hkmap and revins_on.\n * Move to end of reverse inserted text.\n */\n    static void\nins_ctrl_(void)\n{\n    if (revins_on && revins_chars && revins_scol >= 0)\n    {\n\twhile (gchar_cursor() != NUL && revins_chars--)\n\t    ++curwin->w_cursor.col;\n    }\n    p_ri = !p_ri;\n    revins_on = (State == MODE_INSERT && p_ri);\n    if (revins_on)\n    {\n\trevins_scol = curwin->w_cursor.col;\n\trevins_legal++;\n\trevins_chars = 0;\n\tundisplay_dollar();\n    }\n    else\n\trevins_scol = -1;\n    p_hkmap = curwin->w_p_rl ^ p_ri;    // be consistent!\n    showmode();\n}\n#endif\n\n/*\n * If 'keymodel' contains \"startsel\", may start selection.\n * Returns TRUE when a CTRL-O and other keys stuffed.\n */\n    static int\nins_start_select(int c)\n{\n    if (km_startsel)\n\tswitch (c)\n\t{\n\t    case K_KHOME:\n\t    case K_KEND:\n\t    case K_PAGEUP:\n\t    case K_KPAGEUP:\n\t    case K_PAGEDOWN:\n\t    case K_KPAGEDOWN:\n# ifdef MACOS_X\n\t    case K_LEFT:\n\t    case K_RIGHT:\n\t    case K_UP:\n\t    case K_DOWN:\n\t    case K_END:\n\t    case K_HOME:\n# endif\n\t\tif (!(mod_mask & MOD_MASK_SHIFT))\n\t\t    break;\n\t\t// FALLTHROUGH\n\t    case K_S_LEFT:\n\t    case K_S_RIGHT:\n\t    case K_S_UP:\n\t    case K_S_DOWN:\n\t    case K_S_END:\n\t    case K_S_HOME:\n\t\t// Start selection right away, the cursor can move with\n\t\t// CTRL-O when beyond the end of the line.\n\t\tstart_selection();\n\n\t\t// Execute the key in (insert) Select mode.\n\t\tstuffcharReadbuff(Ctrl_O);\n\t\tif (mod_mask)\n\t\t{\n\t\t    char_u\t    buf[4];\n\n\t\t    buf[0] = K_SPECIAL;\n\t\t    buf[1] = KS_MODIFIER;\n\t\t    buf[2] = mod_mask;\n\t\t    buf[3] = NUL;\n\t\t    stuffReadbuff(buf);\n\t\t}\n\t\tstuffcharReadbuff(c);\n\t\treturn TRUE;\n\t}\n    return FALSE;\n}\n\n/*\n * <Insert> key in Insert mode: toggle insert/replace mode.\n */\n    static void\nins_insert(int replaceState)\n{\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_INSERTMODE,\n\t\t   (char_u *)((State & REPLACE_FLAG) ? \"i\"\n\t\t\t    : replaceState == MODE_VREPLACE ? \"v\" : \"r\"), 1);\n#endif\n    ins_apply_autocmds(EVENT_INSERTCHANGE);\n    if (State & REPLACE_FLAG)\n\tState = MODE_INSERT | (State & MODE_LANGMAP);\n    else\n\tState = replaceState | (State & MODE_LANGMAP);\n    may_trigger_modechanged();\n    AppendCharToRedobuff(K_INS);\n    showmode();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Pressed CTRL-O in Insert mode.\n */\n    static void\nins_ctrl_o(void)\n{\n    if (State & VREPLACE_FLAG)\n\trestart_edit = 'V';\n    else if (State & REPLACE_FLAG)\n\trestart_edit = 'R';\n    else\n\trestart_edit = 'I';\n    if (virtual_active())\n\tins_at_eol = FALSE;\t// cursor always keeps its column\n    else\n\tins_at_eol = (gchar_cursor() == NUL);\n}\n\n/*\n * If the cursor is on an indent, ^T/^D insert/delete one\n * shiftwidth.\tOtherwise ^T/^D behave like a \"<<\" or \">>\".\n * Always round the indent to 'shiftwidth', this is compatible\n * with vi.  But vi only supports ^T and ^D after an\n * autoindent, we support it everywhere.\n */\n    static void\nins_shift(int c, int lastc)\n{\n    if (stop_arrow() == FAIL)\n\treturn;\n    AppendCharToRedobuff(c);\n\n    /*\n     * 0^D and ^^D: remove all indent.\n     */\n    if (c == Ctrl_D && (lastc == '0' || lastc == '^')\n\t\t\t\t\t\t  && curwin->w_cursor.col > 0)\n    {\n\t--curwin->w_cursor.col;\n\t(void)del_char(FALSE);\t\t// delete the '^' or '0'\n\t// In Replace mode, restore the characters that '^' or '0' replaced.\n\tif (State & REPLACE_FLAG)\n\t    replace_pop_ins();\n\tif (lastc == '^')\n\t    old_indent = get_indent();\t// remember curr. indent\n\tchange_indent(INDENT_SET, 0, TRUE, 0, TRUE);\n    }\n    else\n\tchange_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);\n\n    if (did_ai && *skipwhite(ml_get_curline()) != NUL)\n\tdid_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n#ifdef FEAT_CINDENT\n    can_cindent = FALSE;\t// no cindenting after ^D or ^T\n#endif\n}\n\n    static void\nins_del(void)\n{\n    int\t    temp;\n\n    if (stop_arrow() == FAIL)\n\treturn;\n    if (gchar_cursor() == NUL)\t\t// delete newline\n    {\n\ttemp = curwin->w_cursor.col;\n\tif (!can_bs(BS_EOL)\t\t// only if \"eol\" included\n\t\t|| do_join(2, FALSE, TRUE, FALSE, FALSE) == FAIL)\n\t    vim_beep(BO_BS);\n\telse\n\t{\n\t    curwin->w_cursor.col = temp;\n\t    // Adjust orig_line_count in case more lines have been deleted than\n\t    // have been added. That makes sure, that open_line() later\n\t    // can access all buffer lines correctly\n\t    if (State & VREPLACE_FLAG &&\n\t\t    orig_line_count > curbuf->b_ml.ml_line_count)\n\t\torig_line_count = curbuf->b_ml.ml_line_count;\n\t}\n    }\n    else if (del_char(FALSE) == FAIL)  // delete char under cursor\n\tvim_beep(BO_BS);\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    AppendCharToRedobuff(K_DEL);\n}\n\n/*\n * Delete one character for ins_bs().\n */\n    static void\nins_bs_one(colnr_T *vcolp)\n{\n    dec_cursor();\n    getvcol(curwin, &curwin->w_cursor, vcolp, NULL, NULL);\n    if (State & REPLACE_FLAG)\n    {\n\t// Don't delete characters before the insert point when in\n\t// Replace mode\n\tif (curwin->w_cursor.lnum != Insstart.lnum\n\t\t|| curwin->w_cursor.col >= Insstart.col)\n\t    replace_do_bs(-1);\n    }\n    else\n\t(void)del_char(FALSE);\n}\n\n/*\n * Handle Backspace, delete-word and delete-line in Insert mode.\n * Return TRUE when backspace was actually used.\n */\n    static int\nins_bs(\n    int\t\tc,\n    int\t\tmode,\n    int\t\t*inserted_space_p)\n{\n    linenr_T\tlnum;\n    int\t\tcc;\n    int\t\ttemp = 0;\t    // init for GCC\n    colnr_T\tsave_col;\n    colnr_T\tmincol;\n    int\t\tdid_backspace = FALSE;\n    int\t\tin_indent;\n    int\t\toldState;\n    int\t\tcpc[MAX_MCO];\t    // composing characters\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    int\t\tcall_fix_indent = FALSE;\n#endif\n\n    /*\n     * can't delete anything in an empty file\n     * can't backup past first character in buffer\n     * can't backup past starting point unless 'backspace' > 1\n     * can backup to a previous line if 'backspace' == 0\n     */\n    if (       BUFEMPTY()\n\t    || (\n#ifdef FEAT_RIGHTLEFT\n\t\t!revins_on &&\n#endif\n\t\t((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col == 0)\n\t\t    || (!can_bs(BS_START)\n\t\t\t&& ((arrow_used\n#ifdef FEAT_JOB_CHANNEL\n\t\t\t\t&& !bt_prompt(curbuf)\n#endif\n\t\t\t) || (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t&& curwin->w_cursor.col <= Insstart_orig.col)))\n\t\t    || (!can_bs(BS_INDENT) && !arrow_used && ai_col > 0\n\t\t\t\t\t && curwin->w_cursor.col <= ai_col)\n\t\t    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))\n    {\n\tvim_beep(BO_BS);\n\treturn FALSE;\n    }\n\n    if (stop_arrow() == FAIL)\n\treturn FALSE;\n    in_indent = inindent(0);\n#ifdef FEAT_CINDENT\n    if (in_indent)\n\tcan_cindent = FALSE;\n#endif\n    end_comment_pending = NUL;\t// After BS, don't auto-end comment\n#ifdef FEAT_RIGHTLEFT\n    if (revins_on)\t    // put cursor after last inserted char\n\tinc_cursor();\n#endif\n\n    // Virtualedit:\n    //\tBACKSPACE_CHAR eats a virtual space\n    //\tBACKSPACE_WORD eats all coladd\n    //\tBACKSPACE_LINE eats all coladd and keeps going\n    if (curwin->w_cursor.coladd > 0)\n    {\n\tif (mode == BACKSPACE_CHAR)\n\t{\n\t    --curwin->w_cursor.coladd;\n\t    return TRUE;\n\t}\n\tif (mode == BACKSPACE_WORD)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    return TRUE;\n\t}\n\tcurwin->w_cursor.coladd = 0;\n    }\n\n    /*\n     * Delete newline!\n     */\n    if (curwin->w_cursor.col == 0)\n    {\n\tlnum = Insstart.lnum;\n\tif (curwin->w_cursor.lnum == lnum\n#ifdef FEAT_RIGHTLEFT\n\t\t\t|| revins_on\n#endif\n\t\t\t\t    )\n\t{\n\t    if (u_save((linenr_T)(curwin->w_cursor.lnum - 2),\n\t\t\t       (linenr_T)(curwin->w_cursor.lnum + 1)) == FAIL)\n\t\treturn FALSE;\n\t    --Insstart.lnum;\n\t    Insstart.col = (colnr_T)STRLEN(ml_get(Insstart.lnum));\n\t}\n\t/*\n\t * In replace mode:\n\t * cc < 0: NL was inserted, delete it\n\t * cc >= 0: NL was replaced, put original characters back\n\t */\n\tcc = -1;\n\tif (State & REPLACE_FLAG)\n\t    cc = replace_pop();\t    // returns -1 if NL was inserted\n\t/*\n\t * In replace mode, in the line we started replacing, we only move the\n\t * cursor.\n\t */\n\tif ((State & REPLACE_FLAG) && curwin->w_cursor.lnum <= lnum)\n\t{\n\t    dec_cursor();\n\t}\n\telse\n\t{\n\t    if (!(State & VREPLACE_FLAG)\n\t\t\t\t   || curwin->w_cursor.lnum > orig_line_count)\n\t    {\n\t\ttemp = gchar_cursor();\t// remember current char\n\t\t--curwin->w_cursor.lnum;\n\n\t\t// When \"aw\" is in 'formatoptions' we must delete the space at\n\t\t// the end of the line, otherwise the line will be broken\n\t\t// again when auto-formatting.\n\t\tif (has_format_option(FO_AUTO)\n\t\t\t\t\t   && has_format_option(FO_WHITE_PAR))\n\t\t{\n\t\t    char_u  *ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t\tTRUE);\n\t\t    int\t    len;\n\n\t\t    len = (int)STRLEN(ptr);\n\t\t    if (len > 0 && ptr[len - 1] == ' ')\n\t\t\tptr[len - 1] = NUL;\n\t\t}\n\n\t\t(void)do_join(2, FALSE, FALSE, FALSE, FALSE);\n\t\tif (temp == NUL && gchar_cursor() != NUL)\n\t\t    inc_cursor();\n\t    }\n\t    else\n\t\tdec_cursor();\n\n\t    /*\n\t     * In MODE_REPLACE mode we have to put back the text that was\n\t     * replaced by the NL. On the replace stack is first a\n\t     * NUL-terminated sequence of characters that were deleted and then\n\t     * the characters that NL replaced.\n\t     */\n\t    if (State & REPLACE_FLAG)\n\t    {\n\t\t/*\n\t\t * Do the next ins_char() in MODE_NORMAL state, to\n\t\t * prevent ins_char() from replacing characters and\n\t\t * avoiding showmatch().\n\t\t */\n\t\toldState = State;\n\t\tState = MODE_NORMAL;\n\t\t/*\n\t\t * restore characters (blanks) deleted after cursor\n\t\t */\n\t\twhile (cc > 0)\n\t\t{\n\t\t    save_col = curwin->w_cursor.col;\n\t\t    mb_replace_pop_ins(cc);\n\t\t    curwin->w_cursor.col = save_col;\n\t\t    cc = replace_pop();\n\t\t}\n\t\t// restore the characters that NL replaced\n\t\treplace_pop_ins();\n\t\tState = oldState;\n\t    }\n\t}\n\tdid_ai = FALSE;\n    }\n    else\n    {\n\t/*\n\t * Delete character(s) before the cursor.\n\t */\n#ifdef FEAT_RIGHTLEFT\n\tif (revins_on)\t\t// put cursor on last inserted char\n\t    dec_cursor();\n#endif\n\tmincol = 0;\n\t\t\t\t\t\t// keep indent\n\tif (mode == BACKSPACE_LINE\n\t\t&& (curbuf->b_p_ai\n#ifdef FEAT_CINDENT\n\t\t    || cindent_on()\n#endif\n\t\t   )\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !revins_on\n#endif\n\t\t\t    )\n\t{\n\t    save_col = curwin->w_cursor.col;\n\t    beginline(BL_WHITE);\n\t    if (curwin->w_cursor.col < save_col)\n\t    {\n\t\tmincol = curwin->w_cursor.col;\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n\t\t// should now fix the indent to match with the previous line\n\t\tcall_fix_indent = TRUE;\n#endif\n\t    }\n\t    curwin->w_cursor.col = save_col;\n\t}\n\n\t/*\n\t * Handle deleting one 'shiftwidth' or 'softtabstop'.\n\t */\n\tif (\t   mode == BACKSPACE_CHAR\n\t\t&& ((p_sta && in_indent)\n\t\t    || ((get_sts_value() != 0\n#ifdef FEAT_VARTABS\n\t\t\t|| tabstop_count(curbuf->b_p_vsts_array)\n#endif\n\t\t\t)\n\t\t\t&& curwin->w_cursor.col > 0\n\t\t\t&& (*(ml_get_cursor() - 1) == TAB\n\t\t\t    || (*(ml_get_cursor() - 1) == ' '\n\t\t\t\t&& (!*inserted_space_p\n\t\t\t\t    || arrow_used))))))\n\t{\n\t    int\t\tts;\n\t    colnr_T\tvcol;\n\t    colnr_T\twant_vcol;\n\t    colnr_T\tstart_vcol;\n\n\t    *inserted_space_p = FALSE;\n\t    // Compute the virtual column where we want to be.  Since\n\t    // 'showbreak' may get in the way, need to get the last column of\n\t    // the previous character.\n\t    getvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    start_vcol = vcol;\n\t    dec_cursor();\n\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &want_vcol);\n\t    inc_cursor();\n#ifdef FEAT_VARTABS\n\t    if (p_sta && in_indent)\n\t    {\n\t\tts = (int)get_sw_value(curbuf);\n\t\twant_vcol = (want_vcol / ts) * ts;\n\t    }\n\t    else\n\t\twant_vcol = tabstop_start(want_vcol, get_sts_value(),\n\t\t\t\t\t\t       curbuf->b_p_vsts_array);\n#else\n\t    if (p_sta && in_indent)\n\t\tts = (int)get_sw_value(curbuf);\n\t    else\n\t\tts = (int)get_sts_value();\n\t    want_vcol = (want_vcol / ts) * ts;\n#endif\n\n\t    // delete characters until we are at or before want_vcol\n\t    while (vcol > want_vcol\n\t\t    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))\n\t\tins_bs_one(&vcol);\n\n\t    // insert extra spaces until we are at want_vcol\n\t    while (vcol < want_vcol)\n\t    {\n\t\t// Remember the first char we inserted\n\t\tif (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t   && curwin->w_cursor.col < Insstart_orig.col)\n\t\t    Insstart_orig.col = curwin->w_cursor.col;\n\n\t\tif (State & VREPLACE_FLAG)\n\t\t    ins_char(' ');\n\t\telse\n\t\t{\n\t\t    ins_str((char_u *)\" \");\n\t\t    if ((State & REPLACE_FLAG))\n\t\t\treplace_push(NUL);\n\t\t}\n\t\tgetvcol(curwin, &curwin->w_cursor, &vcol, NULL, NULL);\n\t    }\n\n\t    // If we are now back where we started delete one character.  Can\n\t    // happen when using 'sts' and 'linebreak'.\n\t    if (vcol >= start_vcol)\n\t\tins_bs_one(&vcol);\n\t}\n\n\t/*\n\t * Delete up to starting point, start of line or previous word.\n\t */\n\telse\n\t{\n\t    int cclass = 0, prev_cclass = 0;\n\n\t    if (has_mbyte)\n\t\tcclass = mb_get_class(ml_get_cursor());\n\t    do\n\t    {\n#ifdef FEAT_RIGHTLEFT\n\t\tif (!revins_on) // put cursor on char to be deleted\n#endif\n\t\t    dec_cursor();\n\n\t\tcc = gchar_cursor();\n\t\t// look multi-byte character class\n\t\tif (has_mbyte)\n\t\t{\n\t\t    prev_cclass = cclass;\n\t\t    cclass = mb_get_class(ml_get_cursor());\n\t\t}\n\n\t\t// start of word?\n\t\tif (mode == BACKSPACE_WORD && !vim_isspace(cc))\n\t\t{\n\t\t    mode = BACKSPACE_WORD_NOT_SPACE;\n\t\t    temp = vim_iswordc(cc);\n\t\t}\n\t\t// end of word?\n\t\telse if (mode == BACKSPACE_WORD_NOT_SPACE\n\t\t\t&& ((vim_isspace(cc) || vim_iswordc(cc) != temp)\n\t\t\t|| prev_cclass != cclass))\n\t\t{\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (!revins_on)\n#endif\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    else if (State & REPLACE_FLAG)\n\t\t\tdec_cursor();\n#endif\n\t\t    break;\n\t\t}\n\t\tif (State & REPLACE_FLAG)\n\t\t    replace_do_bs(-1);\n\t\telse\n\t\t{\n\t\t    if (enc_utf8 && p_deco)\n\t\t\t(void)utfc_ptr2char(ml_get_cursor(), cpc);\n\t\t    (void)del_char(FALSE);\n\t\t    /*\n\t\t     * If there are combining characters and 'delcombine' is set\n\t\t     * move the cursor back.  Don't back up before the base\n\t\t     * character.\n\t\t     */\n\t\t    if (enc_utf8 && p_deco && cpc[0] != NUL)\n\t\t\tinc_cursor();\n#ifdef FEAT_RIGHTLEFT\n\t\t    if (revins_chars)\n\t\t    {\n\t\t\trevins_chars--;\n\t\t\trevins_legal++;\n\t\t    }\n\t\t    if (revins_on && gchar_cursor() == NUL)\n\t\t\tbreak;\n#endif\n\t\t}\n\t\t// Just a single backspace?:\n\t\tif (mode == BACKSPACE_CHAR)\n\t\t    break;\n\t    } while (\n#ifdef FEAT_RIGHTLEFT\n\t\t    revins_on ||\n#endif\n\t\t    (curwin->w_cursor.col > mincol\n\t\t    &&  (can_bs(BS_NOSTOP)\n\t\t\t|| (curwin->w_cursor.lnum != Insstart_orig.lnum\n\t\t\t|| curwin->w_cursor.col != Insstart_orig.col)\n\t\t    )));\n\t}\n\tdid_backspace = TRUE;\n    }\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    if (curwin->w_cursor.col <= 1)\n\tdid_ai = FALSE;\n\n#if defined(FEAT_LISP) || defined(FEAT_CINDENT)\n    if (call_fix_indent)\n\tfix_indent();\n#endif\n\n    /*\n     * It's a little strange to put backspaces into the redo\n     * buffer, but it makes auto-indent a lot easier to deal\n     * with.\n     */\n    AppendCharToRedobuff(c);\n\n    // If deleted before the insertion point, adjust it\n    if (curwin->w_cursor.lnum == Insstart_orig.lnum\n\t\t\t\t  && curwin->w_cursor.col < Insstart_orig.col)\n\tInsstart_orig.col = curwin->w_cursor.col;\n\n    // vi behaviour: the cursor moves backward but the character that\n    //\t\t     was there remains visible\n    // Vim behaviour: the cursor moves backward and the character that\n    //\t\t      was there is erased from the screen.\n    // We can emulate the vi behaviour by pretending there is a dollar\n    // displayed even when there isn't.\n    //  --pkv Sun Jan 19 01:56:40 EST 2003\n    if (vim_strchr(p_cpo, CPO_BACKSPACE) != NULL && dollar_vcol == -1)\n\tdollar_vcol = curwin->w_virtcol;\n\n#ifdef FEAT_FOLDING\n    // When deleting a char the cursor line must never be in a closed fold.\n    // E.g., when 'foldmethod' is indent and deleting the first non-white\n    // char before a Tab.\n    if (did_backspace)\n\tfoldOpenCursor();\n#endif\n\n    return did_backspace;\n}\n\n/*\n * Handle receiving P_PS: start paste mode.  Inserts the following text up to\n * P_PE literally.\n * When \"drop\" is TRUE then consume the text and drop it.\n */\n    int\nbracketed_paste(paste_mode_T mode, int drop, garray_T *gap)\n{\n    int\t\tc;\n    char_u\tbuf[NUMBUFLEN + MB_MAXBYTES];\n    int\t\tidx = 0;\n    char_u\t*end = find_termcode((char_u *)\"PE\");\n    int\t\tret_char = -1;\n    int\t\tsave_allow_keys = allow_keys;\n    int\t\tsave_paste = p_paste;\n\n    // If the end code is too long we can't detect it, read everything.\n    if (end != NULL && STRLEN(end) >= NUMBUFLEN)\n\tend = NULL;\n    ++no_mapping;\n    allow_keys = 0;\n    if (!p_paste)\n\t// Also have the side effects of setting 'paste' to make it work much\n\t// faster.\n\tset_option_value_give_err((char_u *)\"paste\", TRUE, NULL, 0);\n\n    for (;;)\n    {\n\t// When the end is not defined read everything there is.\n\tif (end == NULL && vpeekc() == NUL)\n\t    break;\n\tdo\n\t    c = vgetc();\n\twhile (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR);\n\tif (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C))\n\t    // When CTRL-C was encountered the typeahead will be flushed and we\n\t    // won't get the end sequence.  Except when using \":normal\".\n\t    break;\n\n\tif (has_mbyte)\n\t    idx += (*mb_char2bytes)(c, buf + idx);\n\telse\n\t    buf[idx++] = c;\n\tbuf[idx] = NUL;\n\tif (end != NULL && STRNCMP(buf, end, idx) == 0)\n\t{\n\t    if (end[idx] == NUL)\n\t\tbreak; // Found the end of paste code.\n\t    continue;\n\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {\n\t\t\tc = buf[0];\n\t\t\tif (idx == 1 && (c == CAR || c == K_KENTER || c == NL))\n\t\t\t    ins_eol(c);\n\t\t\telse\n\t\t\t{\n\t\t\t    ins_char_bytes(buf, idx);\n\t\t\t    AppendToRedobuffLit(buf, idx);\n\t\t\t}\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_ONE_CHAR:\n\t\t    if (ret_char == -1)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    ret_char = (*mb_ptr2char)(buf);\n\t\t\telse\n\t\t\t    ret_char = buf[0];\n\t\t    }\n\t\t    break;\n\t    }\n\t}\n\tidx = 0;\n    }\n\n    --no_mapping;\n    allow_keys = save_allow_keys;\n    if (!save_paste)\n\tset_option_value_give_err((char_u *)\"paste\", FALSE, NULL, 0);\n\n    return ret_char;\n}\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n    static void\nins_tabline(int c)\n{\n    // We will be leaving the current window, unless closing another tab.\n    if (c != K_TABMENU || current_tabmenu != TABLINE_MENU_CLOSE\n\t\t|| (current_tab != 0 && current_tab != tabpage_index(curtab)))\n    {\n\tundisplay_dollar();\n\tstart_arrow(&curwin->w_cursor);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n\n    if (c == K_TABLINE)\n\tgoto_tabpage(current_tab);\n    else\n    {\n\thandle_tabmenu();\n\tredraw_statuslines();\t// will redraw the tabline when needed\n    }\n}\n#endif\n\n#if defined(FEAT_GUI) || defined(PROTO)\n    void\nins_scroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_scroll())\n    {\n\tstart_arrow(&tpos);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n}\n\n    void\nins_horscroll(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (gui_do_horiz_scroll(scrollbar_value, FALSE))\n    {\n\tstart_arrow(&tpos);\n# ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n# endif\n    }\n}\n#endif\n\n    static void\nins_left(void)\n{\n    pos_T\ttpos;\n    int\t\tend_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (oneleft() == OK)\n    {\n#if defined(FEAT_XIM) && defined(FEAT_GUI_GTK)\n\t// Only call start_arrow() when not busy with preediting, it will\n\t// break undo.  K_LEFT is inserted in im_correct_cursor().\n\tif (p_imst == IM_OVER_THE_SPOT || !im_is_preediting())\n#endif\n\t{\n\t    start_arrow_with_change(&tpos, end_change);\n\t    if (!end_change)\n\t\tAppendCharToRedobuff(K_LEFT);\n\t}\n#ifdef FEAT_RIGHTLEFT\n\t// If exit reversed string, position is fixed\n\tif (revins_scol != -1 && (int)curwin->w_cursor.col >= revins_scol)\n\t    revins_legal++;\n\trevins_chars++;\n#endif\n    }\n\n    /*\n     * if 'whichwrap' set for cursor in insert mode may go to\n     * previous line\n     */\n    else if (vim_strchr(p_ww, '[') != NULL && curwin->w_cursor.lnum > 1)\n    {\n\t// always break undo when moving upwards/downwards, else undo may break\n\tstart_arrow(&tpos);\n\t--(curwin->w_cursor.lnum);\n\tcoladvance((colnr_T)MAXCOL);\n\tcurwin->w_set_curswant = TRUE;\t// so we stay at the end\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_home(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_HOME)\n\tcurwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    start_arrow(&tpos);\n}\n\n    static void\nins_end(int c)\n{\n    pos_T\ttpos;\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (c == K_C_END)\n\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    coladvance((colnr_T)MAXCOL);\n    curwin->w_curswant = MAXCOL;\n\n    start_arrow(&tpos);\n}\n\n    static void\nins_s_left()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum > 1 || curwin->w_cursor.col > 0)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_LEFT);\n\t(void)bck_word(1L, FALSE, FALSE);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_right(void)\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (gchar_cursor() != NUL || virtual_active())\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_RIGHT);\n\tcurwin->w_set_curswant = TRUE;\n\tif (virtual_active())\n\t    oneright();\n\telse\n\t{\n\t    if (has_mbyte)\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t\t++curwin->w_cursor.col;\n\t}\n\n#ifdef FEAT_RIGHTLEFT\n\trevins_legal++;\n\tif (revins_chars)\n\t    revins_chars--;\n#endif\n    }\n    // if 'whichwrap' set for cursor in insert mode, may move the\n    // cursor to the next line\n    else if (vim_strchr(p_ww, ']') != NULL\n\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n    {\n\tstart_arrow(&curwin->w_cursor);\n\tcurwin->w_set_curswant = TRUE;\n\t++curwin->w_cursor.lnum;\n\tcurwin->w_cursor.col = 0;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_s_right()\n{\n    int end_change = dont_sync_undo == FALSE; // end undoable change\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    undisplay_dollar();\n    if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count\n\t    || gchar_cursor() != NUL)\n    {\n\tstart_arrow_with_change(&curwin->w_cursor, end_change);\n\tif (!end_change)\n\t    AppendCharToRedobuff(K_S_RIGHT);\n\t(void)fwd_word(1L, FALSE, 0);\n\tcurwin->w_set_curswant = TRUE;\n    }\n    else\n\tvim_beep(BO_CRSR);\n    dont_sync_undo = FALSE;\n}\n\n    static void\nins_up(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_up(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pageup(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageUp>: tab page back\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(-1);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(BACKWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_down(\n    int\t\tstartcol)\t// when TRUE move to Insstart.col\n{\n    pos_T\ttpos;\n    linenr_T\told_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\told_topfill = curwin->w_topfill;\n#endif\n\n    undisplay_dollar();\n    tpos = curwin->w_cursor;\n    if (cursor_down(1L, TRUE) == OK)\n    {\n\tif (startcol)\n\t    coladvance(getvcol_nolist(&Insstart));\n\tif (old_topline != curwin->w_topline\n#ifdef FEAT_DIFF\n\t\t|| old_topfill != curwin->w_topfill\n#endif\n\t\t)\n\t    redraw_later(VALID);\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n    static void\nins_pagedown(void)\n{\n    pos_T\ttpos;\n\n    undisplay_dollar();\n\n    if (mod_mask & MOD_MASK_CTRL)\n    {\n\t// <C-PageDown>: tab page forward\n\tif (first_tabpage->tp_next != NULL)\n\t{\n\t    start_arrow(&curwin->w_cursor);\n\t    goto_tabpage(0);\n\t}\n\treturn;\n    }\n\n    tpos = curwin->w_cursor;\n    if (onepage(FORWARD, 1L) == OK)\n    {\n\tstart_arrow(&tpos);\n#ifdef FEAT_CINDENT\n\tcan_cindent = TRUE;\n#endif\n    }\n    else\n\tvim_beep(BO_CRSR);\n}\n\n#ifdef FEAT_DND\n    static void\nins_drop(void)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Handle TAB in Insert or Replace mode.\n * Return TRUE when the TAB needs to be inserted like a normal character.\n */\n    static int\nins_tab(void)\n{\n    int\t\tind;\n    int\t\ti;\n    int\t\ttemp;\n\n    if (Insstart_blank_vcol == MAXCOL && curwin->w_cursor.lnum == Insstart.lnum)\n\tInsstart_blank_vcol = get_nolist_virtcol();\n    if (echeck_abbr(TAB + ABBR_OFF))\n\treturn FALSE;\n\n    ind = inindent(0);\n#ifdef FEAT_CINDENT\n    if (ind)\n\tcan_cindent = FALSE;\n#endif\n\n    /*\n     * When nothing special, insert TAB like a normal character.\n     */\n    if (!curbuf->b_p_et\n#ifdef FEAT_VARTABS\n\t    && !(p_sta && ind\n\t\t// These five lines mean 'tabstop' != 'shiftwidth'\n\t\t&& ((tabstop_count(curbuf->b_p_vts_array) > 1)\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 1\n\t\t\t&& tabstop_first(curbuf->b_p_vts_array)\n\t\t\t\t\t\t       != get_sw_value(curbuf))\n\t\t    || (tabstop_count(curbuf->b_p_vts_array) == 0\n\t\t\t&& curbuf->b_p_ts != get_sw_value(curbuf))))\n\t    && tabstop_count(curbuf->b_p_vsts_array) == 0\n#else\n\t    && !(p_sta && ind && curbuf->b_p_ts != get_sw_value(curbuf))\n#endif\n\t    && get_sts_value() == 0)\n\treturn TRUE;\n\n    if (stop_arrow() == FAIL)\n\treturn TRUE;\n\n    did_ai = FALSE;\n#ifdef FEAT_SMARTINDENT\n    did_si = FALSE;\n    can_si = FALSE;\n    can_si_back = FALSE;\n#endif\n    AppendToRedobuff((char_u *)\"\\t\");\n\n#ifdef FEAT_VARTABS\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n    {\n\ttemp = (int)get_sw_value(curbuf);\n\ttemp -= get_nolist_virtcol() % temp;\n    }\n    else if (tabstop_count(curbuf->b_p_vsts_array) > 0 || curbuf->b_p_sts != 0)\n\t\t\t\t// use 'softtabstop' when set\n\ttemp = tabstop_padding(get_nolist_virtcol(), get_sts_value(),\n\t\t\t\t\t\t     curbuf->b_p_vsts_array);\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = tabstop_padding(get_nolist_virtcol(), curbuf->b_p_ts,\n\t\t\t\t\t\t     curbuf->b_p_vts_array);\n#else\n    if (p_sta && ind)\t\t// insert tab in indent, use 'shiftwidth'\n\ttemp = (int)get_sw_value(curbuf);\n    else if (curbuf->b_p_sts != 0) // use 'softtabstop' when set\n\ttemp = (int)get_sts_value();\n    else\t\t\t// otherwise use 'tabstop'\n\ttemp = (int)curbuf->b_p_ts;\n    temp -= get_nolist_virtcol() % temp;\n#endif\n\n    /*\n     * Insert the first space with ins_char().\tIt will delete one char in\n     * replace mode.  Insert the rest with ins_str(); it will not delete any\n     * chars.  For MODE_VREPLACE state, we use ins_char() for all characters.\n     */\n    ins_char(' ');\n    while (--temp > 0)\n    {\n\tif (State & VREPLACE_FLAG)\n\t    ins_char(' ');\n\telse\n\t{\n\t    ins_str((char_u *)\" \");\n\t    if (State & REPLACE_FLAG)\t    // no char replaced\n\t\treplace_push(NUL);\n\t}\n    }\n\n    /*\n     * When 'expandtab' not set: Replace spaces by TABs where possible.\n     */\n#ifdef FEAT_VARTABS\n    if (!curbuf->b_p_et && (tabstop_count(curbuf->b_p_vsts_array) > 0\n\t\t\t    || get_sts_value() > 0\n\t\t\t    || (p_sta && ind)))\n#else\n    if (!curbuf->b_p_et && (get_sts_value() || (p_sta && ind)))\n#endif\n    {\n\tchar_u\t\t*ptr;\n\tchar_u\t\t*saved_line = NULL;\t// init for GCC\n\tpos_T\t\tpos;\n\tpos_T\t\tfpos;\n\tpos_T\t\t*cursor;\n\tcolnr_T\t\twant_vcol, vcol;\n\tint\t\tchange_col = -1;\n\tint\t\tsave_list = curwin->w_p_list;\n\n\t/*\n\t * Get the current line.  For MODE_VREPLACE state, don't make real\n\t * changes yet, just work on a copy of the line.\n\t */\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    pos = curwin->w_cursor;\n\t    cursor = &pos;\n\t    saved_line = vim_strsave(ml_get_curline());\n\t    if (saved_line == NULL)\n\t\treturn FALSE;\n\t    ptr = saved_line + pos.col;\n\t}\n\telse\n\t{\n\t    ptr = ml_get_cursor();\n\t    cursor = &curwin->w_cursor;\n\t}\n\n\t// When 'L' is not in 'cpoptions' a tab always takes up 'ts' spaces.\n\tif (vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\t    curwin->w_p_list = FALSE;\n\n\t// Find first white before the cursor\n\tfpos = curwin->w_cursor;\n\twhile (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))\n\t{\n\t    --fpos.col;\n\t    --ptr;\n\t}\n\n\t// In Replace mode, don't change characters before the insert point.\n\tif ((State & REPLACE_FLAG)\n\t\t&& fpos.lnum == Insstart.lnum\n\t\t&& fpos.col < Insstart.col)\n\t{\n\t    ptr += Insstart.col - fpos.col;\n\t    fpos.col = Insstart.col;\n\t}\n\n\t// compute virtual column numbers of first white and cursor\n\tgetvcol(curwin, &fpos, &vcol, NULL, NULL);\n\tgetvcol(curwin, cursor, &want_vcol, NULL, NULL);\n\n\t// Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'\n\t// and 'linebreak' adding extra virtual columns.\n\twhile (VIM_ISWHITE(*ptr))\n\t{\n\t    i = lbr_chartabsize(NULL, (char_u *)\"\\t\", vcol);\n\t    if (vcol + i > want_vcol)\n\t\tbreak;\n\t    if (*ptr != TAB)\n\t    {\n\t\t*ptr = TAB;\n\t\tif (change_col < 0)\n\t\t{\n\t\t    change_col = fpos.col;  // Column of first change\n\t\t    // May have to adjust Insstart\n\t\t    if (fpos.lnum == Insstart.lnum && fpos.col < Insstart.col)\n\t\t\tInsstart.col = fpos.col;\n\t\t}\n\t    }\n\t    ++fpos.col;\n\t    ++ptr;\n\t    vcol += i;\n\t}\n\n\tif (change_col >= 0)\n\t{\n\t    int repl_off = 0;\n\t    char_u *line = ptr;\n\n\t    // Skip over the spaces we need.\n\t    while (vcol < want_vcol && *ptr == ' ')\n\t    {\n\t\tvcol += lbr_chartabsize(line, ptr, vcol);\n\t\t++ptr;\n\t\t++repl_off;\n\t    }\n\t    if (vcol > want_vcol)\n\t    {\n\t\t// Must have a char with 'showbreak' just before it.\n\t\t--ptr;\n\t\t--repl_off;\n\t    }\n\t    fpos.col += repl_off;\n\n\t    // Delete following spaces.\n\t    i = cursor->col - fpos.col;\n\t    if (i > 0)\n\t    {\n#ifdef FEAT_PROP_POPUP\n\t\tif (!(State & VREPLACE_FLAG))\n\t\t{\n\t\t    char_u  *newp;\n\t\t    int\t    col;\n\n\t\t    newp = alloc(curbuf->b_ml.ml_line_len - i);\n\t\t    if (newp == NULL)\n\t\t\treturn FALSE;\n\n\t\t    col = ptr - curbuf->b_ml.ml_line_ptr;\n\t\t    if (col > 0)\n\t\t\tmch_memmove(newp, ptr - col, col);\n\t\t    mch_memmove(newp + col, ptr + i,\n\t\t\t\t\t   curbuf->b_ml.ml_line_len - col - i);\n\n\t\t    if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)\n\t\t\tvim_free(curbuf->b_ml.ml_line_ptr);\n\t\t    curbuf->b_ml.ml_line_ptr = newp;\n\t\t    curbuf->b_ml.ml_line_len -= i;\n\t\t    curbuf->b_ml.ml_flags =\n\t\t\t   (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;\n\t\t}\n\t\telse\n#endif\n\t\t    STRMOVE(ptr, ptr + i);\n\t\t// correct replace stack.\n\t\tif ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\t\t    for (temp = i; --temp >= 0; )\n\t\t\treplace_join(repl_off);\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tnetbeans_removed(curbuf, fpos.lnum, cursor->col, (long)(i + 1));\n\t\tnetbeans_inserted(curbuf, fpos.lnum, cursor->col,\n\t\t\t\t\t\t\t   (char_u *)\"\\t\", 1);\n\t    }\n#endif\n\t    cursor->col -= i;\n\n\t    /*\n\t     * In MODE_VREPLACE state, we haven't changed anything yet.  Do it\n\t     * now by backspacing over the changed spacing and then inserting\n\t     * the new spacing.\n\t     */\n\t    if (State & VREPLACE_FLAG)\n\t    {\n\t\t// Backspace from real cursor to change_col\n\t\tbackspace_until_column(change_col);\n\n\t\t// Insert each char in saved_line from changed_col to\n\t\t// ptr-cursor\n\t\tins_bytes_len(saved_line + change_col,\n\t\t\t\t\t\t    cursor->col - change_col);\n\t    }\n\t}\n\n\tif (State & VREPLACE_FLAG)\n\t    vim_free(saved_line);\n\tcurwin->w_p_list = save_list;\n    }\n\n    return FALSE;\n}\n\n/*\n * Handle CR or NL in insert mode.\n * Return FAIL when out of memory or can't undo.\n */\n    int\nins_eol(int c)\n{\n    int\t    i;\n\n    if (echeck_abbr(c + ABBR_OFF))\n\treturn OK;\n    if (stop_arrow() == FAIL)\n\treturn FAIL;\n    undisplay_dollar();\n\n    /*\n     * Strange Vi behaviour: In Replace mode, typing a NL will not delete the\n     * character under the cursor.  Only push a NUL on the replace stack,\n     * nothing to put back when the NL is deleted.\n     */\n    if ((State & REPLACE_FLAG) && !(State & VREPLACE_FLAG))\n\treplace_push(NUL);\n\n    /*\n     * In MODE_VREPLACE state, a NL replaces the rest of the line, and starts\n     * replacing the next line, so we push all of the characters left on the\n     * line onto the replace stack.  This is not done here though, it is done\n     * in open_line().\n     */\n\n    // Put cursor on NUL if on the last char and coladd is 1 (happens after\n    // CTRL-O).\n    if (virtual_active() && curwin->w_cursor.coladd > 0)\n\tcoladvance(getviscol());\n\n#ifdef FEAT_RIGHTLEFT\n    // NL in reverse insert will always start in the end of\n    // current line.\n    if (revins_on)\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n#endif\n\n    AppendToRedobuff(NL_STR);\n    i = open_line(FORWARD,\n\t    has_format_option(FO_RET_COMS) ? OPENLINE_DO_COM : 0, old_indent,\n\t    NULL);\n    old_indent = 0;\n#ifdef FEAT_CINDENT\n    can_cindent = TRUE;\n#endif\n#ifdef FEAT_FOLDING\n    // When inserting a line the cursor line must never be in a closed fold.\n    foldOpenCursor();\n#endif\n\n    return i;\n}\n\n#ifdef FEAT_DIGRAPHS\n/*\n * Handle digraph in insert mode.\n * Returns character still to be inserted, or NUL when nothing remaining to be\n * done.\n */\n    static int\nins_digraph(void)\n{\n    int\t    c;\n    int\t    cc;\n    int\t    did_putchar = FALSE;\n\n    pc_status = PC_STATUS_UNSET;\n    if (redrawing() && !char_avail())\n    {\n\t// may need to redraw when no more chars available now\n\tins_redraw(FALSE);\n\n\tedit_putchar('?', TRUE);\n\tdid_putchar = TRUE;\n#ifdef FEAT_CMDL_INFO\n\tadd_to_showcmd_c(Ctrl_K);\n#endif\n    }\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\n    // don't map the digraph chars. This also prevents the\n    // mode message to be deleted when ESC is hit\n    ++no_mapping;\n    ++allow_keys;\n    c = plain_vgetc();\n    --no_mapping;\n    --allow_keys;\n    if (did_putchar)\n\t// when the line fits in 'columns' the '?' is at the start of the next\n\t// line and will not be removed by the redraw\n\tedit_unputchar();\n\n    if (IS_SPECIAL(c) || mod_mask)\t    // special key\n    {\n#ifdef FEAT_CMDL_INFO\n\tclear_showcmd();\n#endif\n\tinsert_special(c, TRUE, FALSE);\n\treturn NUL;\n    }\n    if (c != ESC)\n    {\n\tdid_putchar = FALSE;\n\tif (redrawing() && !char_avail())\n\t{\n\t    // may need to redraw when no more chars available now\n\t    ins_redraw(FALSE);\n\n\t    if (char2cells(c) == 1)\n\t    {\n\t\tins_redraw(FALSE);\n\t\tedit_putchar(c, TRUE);\n\t\tdid_putchar = TRUE;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    add_to_showcmd_c(c);\n#endif\n\t}\n\t++no_mapping;\n\t++allow_keys;\n\tcc = plain_vgetc();\n\t--no_mapping;\n\t--allow_keys;\n\tif (did_putchar)\n\t    // when the line fits in 'columns' the '?' is at the start of the\n\t    // next line and will not be removed by a redraw\n\t    edit_unputchar();\n\tif (cc != ESC)\n\t{\n\t    AppendToRedobuff((char_u *)CTRL_V_STR);\n\t    c = digraph_get(c, cc, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    clear_showcmd();\n#endif\n\t    return c;\n\t}\n    }\n#ifdef FEAT_CMDL_INFO\n    clear_showcmd();\n#endif\n    return NUL;\n}\n#endif\n\n/*\n * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line.\n * Returns the char to be inserted, or NUL if none found.\n */\n    int\nins_copychar(linenr_T lnum)\n{\n    int\t    c;\n    int\t    temp;\n    char_u  *ptr, *prev_ptr;\n    char_u  *line;\n\n    if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)\n    {\n\tvim_beep(BO_COPY);\n\treturn NUL;\n    }\n\n    // try to advance to the cursor column\n    temp = 0;\n    line = ptr = ml_get(lnum);\n    prev_ptr = ptr;\n    validate_virtcol();\n    while ((colnr_T)temp < curwin->w_virtcol && *ptr != NUL)\n    {\n\tprev_ptr = ptr;\n\ttemp += lbr_chartabsize_adv(line, &ptr, (colnr_T)temp);\n    }\n    if ((colnr_T)temp > curwin->w_virtcol)\n\tptr = prev_ptr;\n\n    c = (*mb_ptr2char)(ptr);\n    if (c == NUL)\n\tvim_beep(BO_COPY);\n    return c;\n}\n\n/*\n * CTRL-Y or CTRL-E typed in Insert mode.\n */\n    static int\nins_ctrl_ey(int tc)\n{\n    int\t    c = tc;\n\n    if (ctrl_x_mode_scroll())\n    {\n\tif (c == Ctrl_Y)\n\t    scrolldown_clamp();\n\telse\n\t    scrollup_clamp();\n\tredraw_later(VALID);\n    }\n    else\n    {\n\tc = ins_copychar(curwin->w_cursor.lnum + (c == Ctrl_Y ? -1 : 1));\n\tif (c != NUL)\n\t{\n\t    long\ttw_save;\n\n\t    // The character must be taken literally, insert like it\n\t    // was typed after a CTRL-V, and pretend 'textwidth'\n\t    // wasn't set.  Digits, 'o' and 'x' are special after a\n\t    // CTRL-V, don't use it for these.\n\t    if (c < 256 && !isalnum(c))\n\t\tAppendToRedobuff((char_u *)CTRL_V_STR);\t// CTRL-V\n\t    tw_save = curbuf->b_p_tw;\n\t    curbuf->b_p_tw = -1;\n\t    insert_special(c, TRUE, FALSE);\n\t    curbuf->b_p_tw = tw_save;\n#ifdef FEAT_RIGHTLEFT\n\t    revins_chars++;\n\t    revins_legal++;\n#endif\n\t    c = Ctrl_V;\t// pretend CTRL-V is last character\n\t    auto_format(FALSE, TRUE);\n\t}\n    }\n    return c;\n}\n\n/*\n * Get the value that w_virtcol would have when 'list' is off.\n * Unless 'cpo' contains the 'L' flag.\n */\n    colnr_T\nget_nolist_virtcol(void)\n{\n    // check validity of cursor in current buffer\n    if (curwin->w_buffer == NULL\n\t|| curwin->w_buffer->b_ml.ml_mfp == NULL\n\t|| curwin->w_cursor.lnum > curwin->w_buffer->b_ml.ml_line_count)\n\treturn 0;\n    if (curwin->w_p_list && vim_strchr(p_cpo, CPO_LISTWM) == NULL)\n\treturn getvcol_nolist(&curwin->w_cursor);\n    validate_virtcol();\n    return curwin->w_virtcol;\n}\n\n#if defined(FEAT_EVAL)\n/*\n * Handle the InsertCharPre autocommand.\n * \"c\" is the character that was typed.\n * Return a pointer to allocated memory with the replacement string.\n * Return NULL to continue inserting \"c\".\n */\n    static char_u *\ndo_insert_char_pre(int c)\n{\n    char_u\t*res;\n    char_u\tbuf[MB_MAXBYTES + 1];\n    int\t\tsave_State = State;\n\n    // Return quickly when there is nothing to do.\n    if (!has_insertcharpre())\n\treturn NULL;\n\n    if (has_mbyte)\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    else\n    {\n\tbuf[0] = c;\n\tbuf[1] = NUL;\n    }\n\n    // Lock the text to avoid weird things from happening.\n    ++textwinlock;\n    set_vim_var_string(VV_CHAR, buf, -1);  // set v:char\n\n    res = NULL;\n    if (ins_apply_autocmds(EVENT_INSERTCHARPRE))\n    {\n\t// Get the value of v:char.  It may be empty or more than one\n\t// character.  Only use it when changed, otherwise continue with the\n\t// original character to avoid breaking autoindent.\n\tif (STRCMP(buf, get_vim_var_str(VV_CHAR)) != 0)\n\t    res = vim_strsave(get_vim_var_str(VV_CHAR));\n    }\n\n    set_vim_var_string(VV_CHAR, NULL, -1);  // clear v:char\n    --textwinlock;\n\n    // Restore the State, it may have been changed.\n    State = save_State;\n\n    return res;\n}\n#endif\n\n#if defined(FEAT_CINDENT) || defined(PROTO)\n    int\nget_can_cindent(void)\n{\n    return can_cindent;\n}\n\n    void\nset_can_cindent(int val)\n{\n    can_cindent = val;\n}\n#endif\n\n/*\n * Trigger \"event\" and take care of fixing undo.\n */\n    int\nins_apply_autocmds(event_T event)\n{\n    varnumber_T\ttick = CHANGEDTICK(curbuf);\n    int r;\n\n    r = apply_autocmds(event, NULL, NULL, FALSE, curbuf);\n\n    // If u_savesub() was called then we are not prepared to start\n    // a new line.  Call u_save() with no contents to fix that.\n    // Except when leaving Insert mode.\n    if (event != EVENT_INSERTLEAVE && tick != CHANGEDTICK(curbuf))\n\tu_save(curwin->w_cursor.lnum, (linenr_T)(curwin->w_cursor.lnum + 1));\n\n    return r;\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * misc2.c: Various functions.\n */\n#include \"vim.h\"\n\nstatic char_u\t*username = NULL; // cached result of mch_get_user_name()\n\nstatic int coladvance2(pos_T *pos, int addspaces, int finetune, colnr_T wcol);\n\n/*\n * Return TRUE if in the current mode we need to use virtual.\n */\n    int\nvirtual_active(void)\n{\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    // While an operator is being executed we return \"virtual_op\", because\n    // VIsual_active has already been reset, thus we can't check for \"block\"\n    // being used.\n    if (virtual_op != MAYBE)\n\treturn virtual_op;\n    return (cur_ve_flags == VE_ALL\n\t    || ((cur_ve_flags & VE_BLOCK) && VIsual_active\n\t\t\t\t\t\t      && VIsual_mode == Ctrl_V)\n\t    || ((cur_ve_flags & VE_INSERT) && (State & MODE_INSERT)));\n}\n\n/*\n * Get the screen position of the cursor.\n */\n    int\ngetviscol(void)\n{\n    colnr_T\tx;\n\n    getvvcol(curwin, &curwin->w_cursor, &x, NULL, NULL);\n    return (int)x;\n}\n\n/*\n * Go to column \"wcol\", and add/insert white space as necessary to get the\n * cursor in that column.\n * The caller must have saved the cursor line for undo!\n */\n    int\ncoladvance_force(colnr_T wcol)\n{\n    int rc = coladvance2(&curwin->w_cursor, TRUE, FALSE, wcol);\n\n    if (wcol == MAXCOL)\n\tcurwin->w_valid &= ~VALID_VIRTCOL;\n    else\n    {\n\t// Virtcol is valid\n\tcurwin->w_valid |= VALID_VIRTCOL;\n\tcurwin->w_virtcol = wcol;\n    }\n    return rc;\n}\n\n/*\n * Get the screen position of character col with a coladd in the cursor line.\n */\n    int\ngetviscol2(colnr_T col, colnr_T coladd UNUSED)\n{\n    colnr_T\tx;\n    pos_T\tpos;\n\n    pos.lnum = curwin->w_cursor.lnum;\n    pos.col = col;\n    pos.coladd = coladd;\n    getvvcol(curwin, &pos, &x, NULL, NULL);\n    return (int)x;\n}\n\n/*\n * Try to advance the Cursor to the specified screen column.\n * If virtual editing: fine tune the cursor position.\n * Note that all virtual positions off the end of a line should share\n * a curwin->w_cursor.col value (n.b. this is equal to STRLEN(line)),\n * beginning at coladd 0.\n *\n * return OK if desired column is reached, FAIL if not\n */\n    int\ncoladvance(colnr_T wcol)\n{\n    int rc = getvpos(&curwin->w_cursor, wcol);\n\n    if (wcol == MAXCOL || rc == FAIL)\n\tcurwin->w_valid &= ~VALID_VIRTCOL;\n    else if (*ml_get_cursor() != TAB)\n    {\n\t// Virtcol is valid when not on a TAB\n\tcurwin->w_valid |= VALID_VIRTCOL;\n\tcurwin->w_virtcol = wcol;\n    }\n    return rc;\n}\n\n/*\n * Return in \"pos\" the position of the cursor advanced to screen column \"wcol\".\n * return OK if desired column is reached, FAIL if not\n */\n    int\ngetvpos(pos_T *pos, colnr_T wcol)\n{\n    return coladvance2(pos, FALSE, virtual_active(), wcol);\n}\n\n    static int\ncoladvance2(\n    pos_T\t*pos,\n    int\t\taddspaces,\t// change the text to achieve our goal?\n    int\t\tfinetune,\t// change char offset for the exact column\n    colnr_T\twcol_arg)\t// column to move to (can be negative)\n{\n    colnr_T\twcol = wcol_arg;\n    int\t\tidx;\n    char_u\t*ptr;\n    char_u\t*line;\n    colnr_T\tcol = 0;\n    int\t\tcsize = 0;\n    int\t\tone_more;\n#ifdef FEAT_LINEBREAK\n    int\t\thead = 0;\n#endif\n\n    one_more = (State & MODE_INSERT)\n\t\t    || restart_edit != NUL\n\t\t    || (VIsual_active && *p_sel != 'o')\n\t\t    || ((get_ve_flags() & VE_ONEMORE) && wcol < MAXCOL);\n    line = ml_get_buf(curbuf, pos->lnum, FALSE);\n\n    if (wcol >= MAXCOL)\n    {\n\t    idx = (int)STRLEN(line) - 1 + one_more;\n\t    col = wcol;\n\n\t    if ((addspaces || finetune) && !VIsual_active)\n\t    {\n\t\tcurwin->w_curswant = linetabsize(line) + one_more;\n\t\tif (curwin->w_curswant > 0)\n\t\t    --curwin->w_curswant;\n\t    }\n    }\n    else\n    {\n\tint width = curwin->w_width - win_col_off(curwin);\n\n\tif (finetune\n\t\t&& curwin->w_p_wrap\n\t\t&& curwin->w_width != 0\n\t\t&& wcol >= (colnr_T)width\n\t\t&& width > 0)\n\t{\n\t    csize = linetabsize(line);\n\t    if (csize > 0)\n\t\tcsize--;\n\n\t    if (wcol / width > (colnr_T)csize / width\n\t\t    && ((State & MODE_INSERT) == 0 || (int)wcol > csize + 1))\n\t    {\n\t\t// In case of line wrapping don't move the cursor beyond the\n\t\t// right screen edge.  In Insert mode allow going just beyond\n\t\t// the last character (like what happens when typing and\n\t\t// reaching the right window edge).\n\t\twcol = (csize / width + 1) * width - 1;\n\t    }\n\t}\n\n\tptr = line;\n\twhile (col <= wcol && *ptr != NUL)\n\t{\n\t    // Count a tab for what it's worth (if list mode not on)\n#ifdef FEAT_LINEBREAK\n\t    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);\n\t    MB_PTR_ADV(ptr);\n#else\n\t    csize = lbr_chartabsize_adv(line, &ptr, col);\n#endif\n\t    col += csize;\n\t}\n\tidx = (int)(ptr - line);\n\t/*\n\t * Handle all the special cases.  The virtual_active() check\n\t * is needed to ensure that a virtual position off the end of\n\t * a line has the correct indexing.  The one_more comparison\n\t * replaces an explicit add of one_more later on.\n\t */\n\tif (col > wcol || (!virtual_active() && one_more == 0))\n\t{\n\t    idx -= 1;\n# ifdef FEAT_LINEBREAK\n\t    // Don't count the chars from 'showbreak'.\n\t    csize -= head;\n# endif\n\t    col -= csize;\n\t}\n\n\tif (virtual_active()\n\t\t&& addspaces\n\t\t&& wcol >= 0\n\t\t&& ((col != wcol && col != wcol + 1) || csize > 1))\n\t{\n\t    // 'virtualedit' is set: The difference between wcol and col is\n\t    // filled with spaces.\n\n\t    if (line[idx] == NUL)\n\t    {\n\t\t// Append spaces\n\t\tint\tcorrect = wcol - col;\n\t\tchar_u\t*newline = alloc(idx + correct + 1);\n\t\tint\tt;\n\n\t\tif (newline == NULL)\n\t\t    return FAIL;\n\n\t\tfor (t = 0; t < idx; ++t)\n\t\t    newline[t] = line[t];\n\n\t\tfor (t = 0; t < correct; ++t)\n\t\t    newline[t + idx] = ' ';\n\n\t\tnewline[idx + correct] = NUL;\n\n\t\tml_replace(pos->lnum, newline, FALSE);\n\t\tchanged_bytes(pos->lnum, (colnr_T)idx);\n\t\tidx += correct;\n\t\tcol = wcol;\n\t    }\n\t    else\n\t    {\n\t\t// Break a tab\n\t\tint\tlinelen = (int)STRLEN(line);\n\t\tint\tcorrect = wcol - col - csize + 1; // negative!!\n\t\tchar_u\t*newline;\n\t\tint\tt, s = 0;\n\t\tint\tv;\n\n\t\tif (-correct > csize)\n\t\t    return FAIL;\n\n\t\tnewline = alloc(linelen + csize);\n\t\tif (newline == NULL)\n\t\t    return FAIL;\n\n\t\tfor (t = 0; t < linelen; t++)\n\t\t{\n\t\t    if (t != idx)\n\t\t\tnewline[s++] = line[t];\n\t\t    else\n\t\t\tfor (v = 0; v < csize; v++)\n\t\t\t    newline[s++] = ' ';\n\t\t}\n\n\t\tnewline[linelen + csize - 1] = NUL;\n\n\t\tml_replace(pos->lnum, newline, FALSE);\n\t\tchanged_bytes(pos->lnum, idx);\n\t\tidx += (csize - 1 + correct);\n\t\tcol += correct;\n\t    }\n\t}\n    }\n\n    if (idx < 0)\n\tpos->col = 0;\n    else\n\tpos->col = idx;\n\n    pos->coladd = 0;\n\n    if (finetune)\n    {\n\tif (wcol == MAXCOL)\n\t{\n\t    // The width of the last character is used to set coladd.\n\t    if (!one_more)\n\t    {\n\t\tcolnr_T\t    scol, ecol;\n\n\t\tgetvcol(curwin, pos, &scol, NULL, &ecol);\n\t\tpos->coladd = ecol - scol;\n\t    }\n\t}\n\telse\n\t{\n\t    int b = (int)wcol - (int)col;\n\n\t    // The difference between wcol and col is used to set coladd.\n\t    if (b > 0 && b < (MAXCOL - 2 * curwin->w_width))\n\t\tpos->coladd = b;\n\n\t    col += b;\n\t}\n    }\n\n    // prevent from moving onto a trail byte\n    if (has_mbyte)\n\tmb_adjustpos(curbuf, pos);\n\n    if (wcol < 0 || col < wcol)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Increment the cursor position.  See inc() for return values.\n */\n    int\ninc_cursor(void)\n{\n    return inc(&curwin->w_cursor);\n}\n\n/*\n * Increment the line pointer \"lp\" crossing line boundaries as necessary.\n * Return 1 when going to the next line.\n * Return 2 when moving forward onto a NUL at the end of the line).\n * Return -1 when at the end of file.\n * Return 0 otherwise.\n */\n    int\ninc(pos_T *lp)\n{\n    char_u  *p;\n\n    // when searching position may be set to end of a line\n    if (lp->col != MAXCOL)\n    {\n\tp = ml_get_pos(lp);\n\tif (*p != NUL)\t// still within line, move to next char (may be NUL)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tint l = (*mb_ptr2len)(p);\n\n\t\tlp->col += l;\n\t\treturn ((p[l] != NUL) ? 0 : 2);\n\t    }\n\t    lp->col++;\n\t    lp->coladd = 0;\n\t    return ((p[1] != NUL) ? 0 : 2);\n\t}\n    }\n    if (lp->lnum != curbuf->b_ml.ml_line_count)     // there is a next line\n    {\n\tlp->col = 0;\n\tlp->lnum++;\n\tlp->coladd = 0;\n\treturn 1;\n    }\n    return -1;\n}\n\n/*\n * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines\n */\n    int\nincl(pos_T *lp)\n{\n    int\t    r;\n\n    if ((r = inc(lp)) >= 1 && lp->col)\n\tr = inc(lp);\n    return r;\n}\n\n/*\n * dec(p)\n *\n * Decrement the line pointer 'p' crossing line boundaries as necessary.\n * Return 1 when crossing a line, -1 when at start of file, 0 otherwise.\n */\n    int\ndec_cursor(void)\n{\n    return dec(&curwin->w_cursor);\n}\n\n    int\ndec(pos_T *lp)\n{\n    char_u\t*p;\n\n    lp->coladd = 0;\n    if (lp->col == MAXCOL)\n    {\n\t// past end of line\n\tp = ml_get(lp->lnum);\n\tlp->col = (colnr_T)STRLEN(p);\n\tif (has_mbyte)\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\treturn 0;\n    }\n\n    if (lp->col > 0)\n    {\n\t// still within line\n\tlp->col--;\n\tif (has_mbyte)\n\t{\n\t    p = ml_get(lp->lnum);\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\t}\n\treturn 0;\n    }\n\n    if (lp->lnum > 1)\n    {\n\t// there is a prior line\n\tlp->lnum--;\n\tp = ml_get(lp->lnum);\n\tlp->col = (colnr_T)STRLEN(p);\n\tif (has_mbyte)\n\t    lp->col -= (*mb_head_off)(p, p + lp->col);\n\treturn 1;\n    }\n\n    // at start of file\n    return -1;\n}\n\n/*\n * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines\n */\n    int\ndecl(pos_T *lp)\n{\n    int\t    r;\n\n    if ((r = dec(lp)) == 1 && lp->col)\n\tr = dec(lp);\n    return r;\n}\n\n/*\n * Get the line number relative to the current cursor position, i.e. the\n * difference between line number and cursor position. Only look for lines that\n * can be visible, folded lines don't count.\n */\n    linenr_T\nget_cursor_rel_lnum(\n    win_T\t*wp,\n    linenr_T\tlnum)\t\t    // line number to get the result for\n{\n    linenr_T\tcursor = wp->w_cursor.lnum;\n    linenr_T\tretval = 0;\n\n#ifdef FEAT_FOLDING\n    if (hasAnyFolding(wp))\n    {\n\tif (lnum > cursor)\n\t{\n\t    while (lnum > cursor)\n\t    {\n\t\t(void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);\n\t\t// if lnum and cursor are in the same fold,\n\t\t// now lnum <= cursor\n\t\tif (lnum > cursor)\n\t\t    retval++;\n\t\tlnum--;\n\t    }\n\t}\n\telse if (lnum < cursor)\n\t{\n\t    while (lnum < cursor)\n\t    {\n\t\t(void)hasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);\n\t\t// if lnum and cursor are in the same fold,\n\t\t// now lnum >= cursor\n\t\tif (lnum < cursor)\n\t\t    retval--;\n\t\tlnum++;\n\t    }\n\t}\n\t// else if (lnum == cursor)\n\t//     retval = 0;\n    }\n    else\n#endif\n\tretval = lnum - cursor;\n\n    return retval;\n}\n\n/*\n * Make sure \"pos.lnum\" and \"pos.col\" are valid in \"buf\".\n * This allows for the col to be on the NUL byte.\n */\n    void\ncheck_pos(buf_T *buf, pos_T *pos)\n{\n    char_u *line;\n    colnr_T len;\n\n    if (pos->lnum > buf->b_ml.ml_line_count)\n\tpos->lnum = buf->b_ml.ml_line_count;\n\n    if (pos->col > 0)\n    {\n\tline = ml_get_buf(buf, pos->lnum, FALSE);\n\tlen = (colnr_T)STRLEN(line);\n\tif (pos->col > len)\n\t    pos->col = len;\n    }\n}\n\n/*\n * Make sure curwin->w_cursor.lnum is valid.\n */\n    void\ncheck_cursor_lnum(void)\n{\n    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n    {\n#ifdef FEAT_FOLDING\n\t// If there is a closed fold at the end of the file, put the cursor in\n\t// its first line.  Otherwise in the last line.\n\tif (!hasFolding(curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL))\n#endif\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n    if (curwin->w_cursor.lnum <= 0)\n\tcurwin->w_cursor.lnum = 1;\n}\n\n/*\n * Make sure curwin->w_cursor.col is valid.\n */\n    void\ncheck_cursor_col(void)\n{\n    check_cursor_col_win(curwin);\n}\n\n/*\n * Make sure win->w_cursor.col is valid.\n */\n    void\ncheck_cursor_col_win(win_T *win)\n{\n    colnr_T      len;\n    colnr_T      oldcol = win->w_cursor.col;\n    colnr_T      oldcoladd = win->w_cursor.col + win->w_cursor.coladd;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n    len = (colnr_T)STRLEN(ml_get_buf(win->w_buffer, win->w_cursor.lnum, FALSE));\n    if (len == 0)\n\twin->w_cursor.col = 0;\n    else if (win->w_cursor.col >= len)\n    {\n\t// Allow cursor past end-of-line when:\n\t// - in Insert mode or restarting Insert mode\n\t// - in Visual mode and 'selection' isn't \"old\"\n\t// - 'virtualedit' is set\n\tif ((State & MODE_INSERT) || restart_edit\n\t\t|| (VIsual_active && *p_sel != 'o')\n\t\t|| (cur_ve_flags & VE_ONEMORE)\n\t\t|| virtual_active())\n\t    win->w_cursor.col = len;\n\telse\n\t{\n\t    win->w_cursor.col = len - 1;\n\t    // Move the cursor to the head byte.\n\t    if (has_mbyte)\n\t\tmb_adjustpos(win->w_buffer, &win->w_cursor);\n\t}\n    }\n    else if (win->w_cursor.col < 0)\n\twin->w_cursor.col = 0;\n\n    // If virtual editing is on, we can leave the cursor on the old position,\n    // only we must set it to virtual.  But don't do it when at the end of the\n    // line.\n    if (oldcol == MAXCOL)\n\twin->w_cursor.coladd = 0;\n    else if (cur_ve_flags == VE_ALL)\n    {\n\tif (oldcoladd > win->w_cursor.col)\n\t{\n\t    win->w_cursor.coladd = oldcoladd - win->w_cursor.col;\n\n\t    // Make sure that coladd is not more than the char width.\n\t    // Not for the last character, coladd is then used when the cursor\n\t    // is actually after the last character.\n\t    if (win->w_cursor.col + 1 < len)\n\t    {\n\t\tint cs, ce;\n\n\t\tgetvcol(win, &win->w_cursor, &cs, NULL, &ce);\n\t\tif (win->w_cursor.coladd > ce - cs)\n\t\t    win->w_cursor.coladd = ce - cs;\n\t    }\n\t}\n\telse\n\t    // avoid weird number when there is a miscalculation or overflow\n\t    win->w_cursor.coladd = 0;\n    }\n}\n\n/*\n * make sure curwin->w_cursor in on a valid character\n */\n    void\ncheck_cursor(void)\n{\n    check_cursor_lnum();\n    check_cursor_col();\n}\n\n/*\n * Check if VIsual position is valid, correct it if not.\n * Can be called when in Visual mode and a change has been made.\n */\n    void\ncheck_visual_pos(void)\n{\n    if (VIsual.lnum > curbuf->b_ml.ml_line_count)\n    {\n\tVIsual.lnum = curbuf->b_ml.ml_line_count;\n\tVIsual.col = 0;\n\tVIsual.coladd = 0;\n    }\n    else\n    {\n\tint len = (int)STRLEN(ml_get(VIsual.lnum));\n\n\tif (VIsual.col > len)\n\t{\n\t    VIsual.col = len;\n\t    VIsual.coladd = 0;\n\t}\n    }\n}\n\n#if defined(FEAT_TEXTOBJ) || defined(PROTO)\n/*\n * Make sure curwin->w_cursor is not on the NUL at the end of the line.\n * Allow it when in Visual mode and 'selection' is not \"old\".\n */\n    void\nadjust_cursor_col(void)\n{\n    if (curwin->w_cursor.col > 0\n\t    && (!VIsual_active || *p_sel == 'o')\n\t    && gchar_cursor() == NUL)\n\t--curwin->w_cursor.col;\n}\n#endif\n\n/*\n * When curwin->w_leftcol has changed, adjust the cursor position.\n * Return TRUE if the cursor was moved.\n */\n    int\nleftcol_changed(void)\n{\n    long\tlastcol;\n    colnr_T\ts, e;\n    int\t\tretval = FALSE;\n    long\tsiso = get_sidescrolloff_value();\n\n    changed_cline_bef_curs();\n    lastcol = curwin->w_leftcol + curwin->w_width - curwin_col_off() - 1;\n    validate_virtcol();\n\n    /*\n     * If the cursor is right or left of the screen, move it to last or first\n     * character.\n     */\n    if (curwin->w_virtcol > (colnr_T)(lastcol - siso))\n    {\n\tretval = TRUE;\n\tcoladvance((colnr_T)(lastcol - siso));\n    }\n    else if (curwin->w_virtcol < curwin->w_leftcol + siso)\n    {\n\tretval = TRUE;\n\t(void)coladvance((colnr_T)(curwin->w_leftcol + siso));\n    }\n\n    /*\n     * If the start of the character under the cursor is not on the screen,\n     * advance the cursor one more char.  If this fails (last char of the\n     * line) adjust the scrolling.\n     */\n    getvvcol(curwin, &curwin->w_cursor, &s, NULL, &e);\n    if (e > (colnr_T)lastcol)\n    {\n\tretval = TRUE;\n\tcoladvance(s - 1);\n    }\n    else if (s < curwin->w_leftcol)\n    {\n\tretval = TRUE;\n\tif (coladvance(e + 1) == FAIL)\t// there isn't another character\n\t{\n\t    curwin->w_leftcol = s;\t// adjust w_leftcol instead\n\t    changed_cline_bef_curs();\n\t}\n    }\n\n    if (retval)\n\tcurwin->w_set_curswant = TRUE;\n    redraw_later(NOT_VALID);\n    return retval;\n}\n\n/*\n * Isolate one part of a string option where parts are separated with\n * \"sep_chars\".\n * The part is copied into \"buf[maxlen]\".\n * \"*option\" is advanced to the next part.\n * The length is returned.\n */\n    int\ncopy_option_part(\n    char_u\t**option,\n    char_u\t*buf,\n    int\t\tmaxlen,\n    char\t*sep_chars)\n{\n    int\t    len = 0;\n    char_u  *p = *option;\n\n    // skip '.' at start of option part, for 'suffixes'\n    if (*p == '.')\n\tbuf[len++] = *p++;\n    while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL)\n    {\n\t/*\n\t * Skip backslash before a separator character and space.\n\t */\n\tif (p[0] == '\\\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL)\n\t    ++p;\n\tif (len < maxlen - 1)\n\t    buf[len++] = *p;\n\t++p;\n    }\n    buf[len] = NUL;\n\n    if (*p != NUL && *p != ',')\t// skip non-standard separator\n\t++p;\n    p = skip_to_option_part(p);\t// p points to next file name\n\n    *option = p;\n    return len;\n}\n\n#ifndef HAVE_MEMSET\n    void *\nvim_memset(void *ptr, int c, size_t size)\n{\n    char *p = ptr;\n\n    while (size-- > 0)\n\t*p++ = c;\n    return ptr;\n}\n#endif\n\n/*\n * Vim has its own isspace() function, because on some machines isspace()\n * can't handle characters above 128.\n */\n    int\nvim_isspace(int x)\n{\n    return ((x >= 9 && x <= 13) || x == ' ');\n}\n\n/************************************************************************\n * functions that use lookup tables for various things, generally to do with\n * special key codes.\n */\n\n/*\n * Some useful tables.\n */\n\nstatic struct modmasktable\n{\n    short\tmod_mask;\t// Bit-mask for particular key modifier\n    short\tmod_flag;\t// Bit(s) for particular key modifier\n    char_u\tname;\t\t// Single letter name of modifier\n} mod_mask_table[] =\n{\n    {MOD_MASK_ALT,\t\tMOD_MASK_ALT,\t\t(char_u)'M'},\n    {MOD_MASK_META,\t\tMOD_MASK_META,\t\t(char_u)'T'},\n    {MOD_MASK_CTRL,\t\tMOD_MASK_CTRL,\t\t(char_u)'C'},\n    {MOD_MASK_SHIFT,\t\tMOD_MASK_SHIFT,\t\t(char_u)'S'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_2CLICK,\t(char_u)'2'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_3CLICK,\t(char_u)'3'},\n    {MOD_MASK_MULTI_CLICK,\tMOD_MASK_4CLICK,\t(char_u)'4'},\n#ifdef MACOS_X\n    {MOD_MASK_CMD,\t\tMOD_MASK_CMD,\t\t(char_u)'D'},\n#endif\n    // 'A' must be the last one\n    {MOD_MASK_ALT,\t\tMOD_MASK_ALT,\t\t(char_u)'A'},\n    {0, 0, NUL}\n    // NOTE: when adding an entry, update MAX_KEY_NAME_LEN!\n};\n\n/*\n * Shifted key terminal codes and their unshifted equivalent.\n * Don't add mouse codes here, they are handled separately!\n */\n#define MOD_KEYS_ENTRY_SIZE 5\n\nstatic char_u modifier_keys_table[] =\n{\n//  mod mask\t    with modifier\t\twithout modifier\n    MOD_MASK_SHIFT, '&', '9',\t\t\t'@', '1',\t// begin\n    MOD_MASK_SHIFT, '&', '0',\t\t\t'@', '2',\t// cancel\n    MOD_MASK_SHIFT, '*', '1',\t\t\t'@', '4',\t// command\n    MOD_MASK_SHIFT, '*', '2',\t\t\t'@', '5',\t// copy\n    MOD_MASK_SHIFT, '*', '3',\t\t\t'@', '6',\t// create\n    MOD_MASK_SHIFT, '*', '4',\t\t\t'k', 'D',\t// delete char\n    MOD_MASK_SHIFT, '*', '5',\t\t\t'k', 'L',\t// delete line\n    MOD_MASK_SHIFT, '*', '7',\t\t\t'@', '7',\t// end\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,\t'@', '7',\t// end\n    MOD_MASK_SHIFT, '*', '9',\t\t\t'@', '9',\t// exit\n    MOD_MASK_SHIFT, '*', '0',\t\t\t'@', '0',\t// find\n    MOD_MASK_SHIFT, '#', '1',\t\t\t'%', '1',\t// help\n    MOD_MASK_SHIFT, '#', '2',\t\t\t'k', 'h',\t// home\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,\t'k', 'h',\t// home\n    MOD_MASK_SHIFT, '#', '3',\t\t\t'k', 'I',\t// insert\n    MOD_MASK_SHIFT, '#', '4',\t\t\t'k', 'l',\t// left arrow\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,\t'k', 'l',\t// left arrow\n    MOD_MASK_SHIFT, '%', 'a',\t\t\t'%', '3',\t// message\n    MOD_MASK_SHIFT, '%', 'b',\t\t\t'%', '4',\t// move\n    MOD_MASK_SHIFT, '%', 'c',\t\t\t'%', '5',\t// next\n    MOD_MASK_SHIFT, '%', 'd',\t\t\t'%', '7',\t// options\n    MOD_MASK_SHIFT, '%', 'e',\t\t\t'%', '8',\t// previous\n    MOD_MASK_SHIFT, '%', 'f',\t\t\t'%', '9',\t// print\n    MOD_MASK_SHIFT, '%', 'g',\t\t\t'%', '0',\t// redo\n    MOD_MASK_SHIFT, '%', 'h',\t\t\t'&', '3',\t// replace\n    MOD_MASK_SHIFT, '%', 'i',\t\t\t'k', 'r',\t// right arr.\n    MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,\t'k', 'r',\t// right arr.\n    MOD_MASK_SHIFT, '%', 'j',\t\t\t'&', '5',\t// resume\n    MOD_MASK_SHIFT, '!', '1',\t\t\t'&', '6',\t// save\n    MOD_MASK_SHIFT, '!', '2',\t\t\t'&', '7',\t// suspend\n    MOD_MASK_SHIFT, '!', '3',\t\t\t'&', '8',\t// undo\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,\t'k', 'u',\t// up arrow\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,\t'k', 'd',\t// down arrow\n\n\t\t\t\t\t\t\t\t// vt100 F1\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,\tKS_EXTRA, (int)KE_XF1,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,\tKS_EXTRA, (int)KE_XF2,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,\tKS_EXTRA, (int)KE_XF3,\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,\tKS_EXTRA, (int)KE_XF4,\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,\t'k', '1',\t// F1\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,\t'k', '2',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,\t'k', '3',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,\t'k', '4',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F5,\t'k', '5',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F6,\t'k', '6',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,\t'k', '7',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,\t'k', '8',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,\t'k', '9',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,\t'k', ';',\t// F10\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,\t'F', '1',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,\t'F', '2',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F13,\t'F', '3',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F14,\t'F', '4',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F15,\t'F', '5',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F16,\t'F', '6',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F17,\t'F', '7',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F18,\t'F', '8',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F19,\t'F', '9',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F20,\t'F', 'A',\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F21,\t'F', 'B',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F22,\t'F', 'C',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F23,\t'F', 'D',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F24,\t'F', 'E',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F25,\t'F', 'F',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F26,\t'F', 'G',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F27,\t'F', 'H',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F28,\t'F', 'I',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F29,\t'F', 'J',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F30,\t'F', 'K',\n\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F31,\t'F', 'L',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F32,\t'F', 'M',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F33,\t'F', 'N',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F34,\t'F', 'O',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F35,\t'F', 'P',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,\t'F', 'Q',\n    MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,\t'F', 'R',\n\n\t\t\t\t\t\t\t    // TAB pseudo code\n    MOD_MASK_SHIFT, 'k', 'B',\t\t\tKS_EXTRA, (int)KE_TAB,\n\n    NUL\n};\n\nstatic struct key_name_entry\n{\n    int\t    key;\t// Special key code or ascii value\n    char_u  *name;\t// Name of key\n} key_names_table[] =\n{\n    {' ',\t\t(char_u *)\"Space\"},\n    {TAB,\t\t(char_u *)\"Tab\"},\n    {K_TAB,\t\t(char_u *)\"Tab\"},\n    {NL,\t\t(char_u *)\"NL\"},\n    {NL,\t\t(char_u *)\"NewLine\"},\t// Alternative name\n    {NL,\t\t(char_u *)\"LineFeed\"},\t// Alternative name\n    {NL,\t\t(char_u *)\"LF\"},\t// Alternative name\n    {CAR,\t\t(char_u *)\"CR\"},\n    {CAR,\t\t(char_u *)\"Return\"},\t// Alternative name\n    {CAR,\t\t(char_u *)\"Enter\"},\t// Alternative name\n    {K_BS,\t\t(char_u *)\"BS\"},\n    {K_BS,\t\t(char_u *)\"BackSpace\"},\t// Alternative name\n    {ESC,\t\t(char_u *)\"Esc\"},\n    {CSI,\t\t(char_u *)\"CSI\"},\n    {K_CSI,\t\t(char_u *)\"xCSI\"},\n    {'|',\t\t(char_u *)\"Bar\"},\n    {'\\\\',\t\t(char_u *)\"Bslash\"},\n    {K_DEL,\t\t(char_u *)\"Del\"},\n    {K_DEL,\t\t(char_u *)\"Delete\"},\t// Alternative name\n    {K_KDEL,\t\t(char_u *)\"kDel\"},\n    {K_UP,\t\t(char_u *)\"Up\"},\n    {K_DOWN,\t\t(char_u *)\"Down\"},\n    {K_LEFT,\t\t(char_u *)\"Left\"},\n    {K_RIGHT,\t\t(char_u *)\"Right\"},\n    {K_XUP,\t\t(char_u *)\"xUp\"},\n    {K_XDOWN,\t\t(char_u *)\"xDown\"},\n    {K_XLEFT,\t\t(char_u *)\"xLeft\"},\n    {K_XRIGHT,\t\t(char_u *)\"xRight\"},\n    {K_PS,\t\t(char_u *)\"PasteStart\"},\n    {K_PE,\t\t(char_u *)\"PasteEnd\"},\n\n    {K_F1,\t\t(char_u *)\"F1\"},\n    {K_F2,\t\t(char_u *)\"F2\"},\n    {K_F3,\t\t(char_u *)\"F3\"},\n    {K_F4,\t\t(char_u *)\"F4\"},\n    {K_F5,\t\t(char_u *)\"F5\"},\n    {K_F6,\t\t(char_u *)\"F6\"},\n    {K_F7,\t\t(char_u *)\"F7\"},\n    {K_F8,\t\t(char_u *)\"F8\"},\n    {K_F9,\t\t(char_u *)\"F9\"},\n    {K_F10,\t\t(char_u *)\"F10\"},\n\n    {K_F11,\t\t(char_u *)\"F11\"},\n    {K_F12,\t\t(char_u *)\"F12\"},\n    {K_F13,\t\t(char_u *)\"F13\"},\n    {K_F14,\t\t(char_u *)\"F14\"},\n    {K_F15,\t\t(char_u *)\"F15\"},\n    {K_F16,\t\t(char_u *)\"F16\"},\n    {K_F17,\t\t(char_u *)\"F17\"},\n    {K_F18,\t\t(char_u *)\"F18\"},\n    {K_F19,\t\t(char_u *)\"F19\"},\n    {K_F20,\t\t(char_u *)\"F20\"},\n\n    {K_F21,\t\t(char_u *)\"F21\"},\n    {K_F22,\t\t(char_u *)\"F22\"},\n    {K_F23,\t\t(char_u *)\"F23\"},\n    {K_F24,\t\t(char_u *)\"F24\"},\n    {K_F25,\t\t(char_u *)\"F25\"},\n    {K_F26,\t\t(char_u *)\"F26\"},\n    {K_F27,\t\t(char_u *)\"F27\"},\n    {K_F28,\t\t(char_u *)\"F28\"},\n    {K_F29,\t\t(char_u *)\"F29\"},\n    {K_F30,\t\t(char_u *)\"F30\"},\n\n    {K_F31,\t\t(char_u *)\"F31\"},\n    {K_F32,\t\t(char_u *)\"F32\"},\n    {K_F33,\t\t(char_u *)\"F33\"},\n    {K_F34,\t\t(char_u *)\"F34\"},\n    {K_F35,\t\t(char_u *)\"F35\"},\n    {K_F36,\t\t(char_u *)\"F36\"},\n    {K_F37,\t\t(char_u *)\"F37\"},\n\n    {K_XF1,\t\t(char_u *)\"xF1\"},\n    {K_XF2,\t\t(char_u *)\"xF2\"},\n    {K_XF3,\t\t(char_u *)\"xF3\"},\n    {K_XF4,\t\t(char_u *)\"xF4\"},\n\n    {K_HELP,\t\t(char_u *)\"Help\"},\n    {K_UNDO,\t\t(char_u *)\"Undo\"},\n    {K_INS,\t\t(char_u *)\"Insert\"},\n    {K_INS,\t\t(char_u *)\"Ins\"},\t// Alternative name\n    {K_KINS,\t\t(char_u *)\"kInsert\"},\n    {K_HOME,\t\t(char_u *)\"Home\"},\n    {K_KHOME,\t\t(char_u *)\"kHome\"},\n    {K_XHOME,\t\t(char_u *)\"xHome\"},\n    {K_ZHOME,\t\t(char_u *)\"zHome\"},\n    {K_END,\t\t(char_u *)\"End\"},\n    {K_KEND,\t\t(char_u *)\"kEnd\"},\n    {K_XEND,\t\t(char_u *)\"xEnd\"},\n    {K_ZEND,\t\t(char_u *)\"zEnd\"},\n    {K_PAGEUP,\t\t(char_u *)\"PageUp\"},\n    {K_PAGEDOWN,\t(char_u *)\"PageDown\"},\n    {K_KPAGEUP,\t\t(char_u *)\"kPageUp\"},\n    {K_KPAGEDOWN,\t(char_u *)\"kPageDown\"},\n\n    {K_KPLUS,\t\t(char_u *)\"kPlus\"},\n    {K_KMINUS,\t\t(char_u *)\"kMinus\"},\n    {K_KDIVIDE,\t\t(char_u *)\"kDivide\"},\n    {K_KMULTIPLY,\t(char_u *)\"kMultiply\"},\n    {K_KENTER,\t\t(char_u *)\"kEnter\"},\n    {K_KPOINT,\t\t(char_u *)\"kPoint\"},\n\n    {K_K0,\t\t(char_u *)\"k0\"},\n    {K_K1,\t\t(char_u *)\"k1\"},\n    {K_K2,\t\t(char_u *)\"k2\"},\n    {K_K3,\t\t(char_u *)\"k3\"},\n    {K_K4,\t\t(char_u *)\"k4\"},\n    {K_K5,\t\t(char_u *)\"k5\"},\n    {K_K6,\t\t(char_u *)\"k6\"},\n    {K_K7,\t\t(char_u *)\"k7\"},\n    {K_K8,\t\t(char_u *)\"k8\"},\n    {K_K9,\t\t(char_u *)\"k9\"},\n\n    {'<',\t\t(char_u *)\"lt\"},\n\n    {K_MOUSE,\t\t(char_u *)\"Mouse\"},\n#ifdef FEAT_MOUSE_NET\n    {K_NETTERM_MOUSE,\t(char_u *)\"NetMouse\"},\n#endif\n#ifdef FEAT_MOUSE_DEC\n    {K_DEC_MOUSE,\t(char_u *)\"DecMouse\"},\n#endif\n#ifdef FEAT_MOUSE_JSB\n    {K_JSBTERM_MOUSE,\t(char_u *)\"JsbMouse\"},\n#endif\n#ifdef FEAT_MOUSE_PTERM\n    {K_PTERM_MOUSE,\t(char_u *)\"PtermMouse\"},\n#endif\n#ifdef FEAT_MOUSE_URXVT\n    {K_URXVT_MOUSE,\t(char_u *)\"UrxvtMouse\"},\n#endif\n    {K_SGR_MOUSE,\t(char_u *)\"SgrMouse\"},\n    {K_SGR_MOUSERELEASE, (char_u *)\"SgrMouseRelease\"},\n    {K_LEFTMOUSE,\t(char_u *)\"LeftMouse\"},\n    {K_LEFTMOUSE_NM,\t(char_u *)\"LeftMouseNM\"},\n    {K_LEFTDRAG,\t(char_u *)\"LeftDrag\"},\n    {K_LEFTRELEASE,\t(char_u *)\"LeftRelease\"},\n    {K_LEFTRELEASE_NM,\t(char_u *)\"LeftReleaseNM\"},\n    {K_MOUSEMOVE,\t(char_u *)\"MouseMove\"},\n    {K_MIDDLEMOUSE,\t(char_u *)\"MiddleMouse\"},\n    {K_MIDDLEDRAG,\t(char_u *)\"MiddleDrag\"},\n    {K_MIDDLERELEASE,\t(char_u *)\"MiddleRelease\"},\n    {K_RIGHTMOUSE,\t(char_u *)\"RightMouse\"},\n    {K_RIGHTDRAG,\t(char_u *)\"RightDrag\"},\n    {K_RIGHTRELEASE,\t(char_u *)\"RightRelease\"},\n    {K_MOUSEDOWN,\t(char_u *)\"ScrollWheelUp\"},\n    {K_MOUSEUP,\t\t(char_u *)\"ScrollWheelDown\"},\n    {K_MOUSELEFT,\t(char_u *)\"ScrollWheelRight\"},\n    {K_MOUSERIGHT,\t(char_u *)\"ScrollWheelLeft\"},\n    {K_MOUSEDOWN,\t(char_u *)\"MouseDown\"}, // OBSOLETE: Use\n    {K_MOUSEUP,\t\t(char_u *)\"MouseUp\"},\t// ScrollWheelXXX instead\n    {K_X1MOUSE,\t\t(char_u *)\"X1Mouse\"},\n    {K_X1DRAG,\t\t(char_u *)\"X1Drag\"},\n    {K_X1RELEASE,\t\t(char_u *)\"X1Release\"},\n    {K_X2MOUSE,\t\t(char_u *)\"X2Mouse\"},\n    {K_X2DRAG,\t\t(char_u *)\"X2Drag\"},\n    {K_X2RELEASE,\t\t(char_u *)\"X2Release\"},\n    {K_DROP,\t\t(char_u *)\"Drop\"},\n    {K_ZERO,\t\t(char_u *)\"Nul\"},\n#ifdef FEAT_EVAL\n    {K_SNR,\t\t(char_u *)\"SNR\"},\n#endif\n    {K_PLUG,\t\t(char_u *)\"Plug\"},\n    {K_CURSORHOLD,\t(char_u *)\"CursorHold\"},\n    {K_IGNORE,\t\t(char_u *)\"Ignore\"},\n    {K_COMMAND,\t\t(char_u *)\"Cmd\"},\n    {K_SCRIPT_COMMAND,\t(char_u *)\"ScriptCmd\"},\n    {K_FOCUSGAINED,\t(char_u *)\"FocusGained\"},\n    {K_FOCUSLOST,\t(char_u *)\"FocusLost\"},\n    {0,\t\t\tNULL}\n    // NOTE: When adding a long name update MAX_KEY_NAME_LEN.\n};\n\n#define KEY_NAMES_TABLE_LEN ARRAY_LENGTH(key_names_table)\n\n/*\n * Return the modifier mask bit (MOD_MASK_*) which corresponds to the given\n * modifier name ('S' for Shift, 'C' for Ctrl etc).\n */\n    static int\nname_to_mod_mask(int c)\n{\n    int\t    i;\n\n    c = TOUPPER_ASC(c);\n    for (i = 0; mod_mask_table[i].mod_mask != 0; i++)\n\tif (c == mod_mask_table[i].name)\n\t    return mod_mask_table[i].mod_flag;\n    return 0;\n}\n\n/*\n * Check if if there is a special key code for \"key\" that includes the\n * modifiers specified.\n */\n    int\nsimplify_key(int key, int *modifiers)\n{\n    int\t    i;\n    int\t    key0;\n    int\t    key1;\n\n    if (*modifiers & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))\n    {\n\t// TAB is a special case\n\tif (key == TAB && (*modifiers & MOD_MASK_SHIFT))\n\t{\n\t    *modifiers &= ~MOD_MASK_SHIFT;\n\t    return K_S_TAB;\n\t}\n\tkey0 = KEY2TERMCAP0(key);\n\tkey1 = KEY2TERMCAP1(key);\n\tfor (i = 0; modifier_keys_table[i] != NUL; i += MOD_KEYS_ENTRY_SIZE)\n\t    if (key0 == modifier_keys_table[i + 3]\n\t\t    && key1 == modifier_keys_table[i + 4]\n\t\t    && (*modifiers & modifier_keys_table[i]))\n\t    {\n\t\t*modifiers &= ~modifier_keys_table[i];\n\t\treturn TERMCAP2KEY(modifier_keys_table[i + 1],\n\t\t\t\t\t\t   modifier_keys_table[i + 2]);\n\t    }\n    }\n    return key;\n}\n\n/*\n * Change <xHome> to <Home>, <xUp> to <Up>, etc.\n */\n    int\nhandle_x_keys(int key)\n{\n    switch (key)\n    {\n\tcase K_XUP:\treturn K_UP;\n\tcase K_XDOWN:\treturn K_DOWN;\n\tcase K_XLEFT:\treturn K_LEFT;\n\tcase K_XRIGHT:\treturn K_RIGHT;\n\tcase K_XHOME:\treturn K_HOME;\n\tcase K_ZHOME:\treturn K_HOME;\n\tcase K_XEND:\treturn K_END;\n\tcase K_ZEND:\treturn K_END;\n\tcase K_XF1:\treturn K_F1;\n\tcase K_XF2:\treturn K_F2;\n\tcase K_XF3:\treturn K_F3;\n\tcase K_XF4:\treturn K_F4;\n\tcase K_S_XF1:\treturn K_S_F1;\n\tcase K_S_XF2:\treturn K_S_F2;\n\tcase K_S_XF3:\treturn K_S_F3;\n\tcase K_S_XF4:\treturn K_S_F4;\n    }\n    return key;\n}\n\n/*\n * Return a string which contains the name of the given key when the given\n * modifiers are down.\n */\n    char_u *\nget_special_key_name(int c, int modifiers)\n{\n    static char_u string[MAX_KEY_NAME_LEN + 1];\n\n    int\t    i, idx;\n    int\t    table_idx;\n    char_u  *s;\n\n    string[0] = '<';\n    idx = 1;\n\n    // Key that stands for a normal character.\n    if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)\n\tc = KEY2TERMCAP1(c);\n\n    /*\n     * Translate shifted special keys into unshifted keys and set modifier.\n     * Same for CTRL and ALT modifiers.\n     */\n    if (IS_SPECIAL(c))\n    {\n\tfor (i = 0; modifier_keys_table[i] != 0; i += MOD_KEYS_ENTRY_SIZE)\n\t    if (       KEY2TERMCAP0(c) == (int)modifier_keys_table[i + 1]\n\t\t    && (int)KEY2TERMCAP1(c) == (int)modifier_keys_table[i + 2])\n\t    {\n\t\tmodifiers |= modifier_keys_table[i];\n\t\tc = TERMCAP2KEY(modifier_keys_table[i + 3],\n\t\t\t\t\t\t   modifier_keys_table[i + 4]);\n\t\tbreak;\n\t    }\n    }\n\n    // try to find the key in the special key table\n    table_idx = find_special_key_in_table(c);\n\n    /*\n     * When not a known special key, and not a printable character, try to\n     * extract modifiers.\n     */\n    if (c > 0 && (*mb_char2len)(c) == 1)\n    {\n\tif (table_idx < 0\n\t\t&& (!vim_isprintc(c) || (c & 0x7f) == ' ')\n\t\t&& (c & 0x80))\n\t{\n\t    c &= 0x7f;\n\t    modifiers |= MOD_MASK_ALT;\n\t    // try again, to find the un-alted key in the special key table\n\t    table_idx = find_special_key_in_table(c);\n\t}\n\tif (table_idx < 0 && !vim_isprintc(c) && c < ' ')\n\t{\n\t    c += '@';\n\t    modifiers |= MOD_MASK_CTRL;\n\t}\n    }\n\n    // translate the modifier into a string\n    for (i = 0; mod_mask_table[i].name != 'A'; i++)\n\tif ((modifiers & mod_mask_table[i].mod_mask)\n\t\t\t\t\t\t== mod_mask_table[i].mod_flag)\n\t{\n\t    string[idx++] = mod_mask_table[i].name;\n\t    string[idx++] = (char_u)'-';\n\t}\n\n    if (table_idx < 0)\t\t// unknown special key, may output t_xx\n    {\n\tif (IS_SPECIAL(c))\n\t{\n\t    string[idx++] = 't';\n\t    string[idx++] = '_';\n\t    string[idx++] = KEY2TERMCAP0(c);\n\t    string[idx++] = KEY2TERMCAP1(c);\n\t}\n\t// Not a special key, only modifiers, output directly\n\telse\n\t{\n\t    if (has_mbyte && (*mb_char2len)(c) > 1)\n\t\tidx += (*mb_char2bytes)(c, string + idx);\n\t    else if (vim_isprintc(c))\n\t\tstring[idx++] = c;\n\t    else\n\t    {\n\t\ts = transchar(c);\n\t\twhile (*s)\n\t\t    string[idx++] = *s++;\n\t    }\n\t}\n    }\n    else\t\t// use name of special key\n    {\n\tsize_t len = STRLEN(key_names_table[table_idx].name);\n\n\tif (len + idx + 2 <= MAX_KEY_NAME_LEN)\n\t{\n\t    STRCPY(string + idx, key_names_table[table_idx].name);\n\t    idx += (int)len;\n\t}\n    }\n    string[idx++] = '>';\n    string[idx] = NUL;\n    return string;\n}\n\n/*\n * Try translating a <> name at (*srcp)[] to dst[].\n * Return the number of characters added to dst[], zero for no match.\n * If there is a match, srcp is advanced to after the <> name.\n * dst[] must be big enough to hold the result (up to six characters)!\n */\n    int\ntrans_special(\n    char_u\t**srcp,\n    char_u\t*dst,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\tescape_ks,\t// escape K_SPECIAL bytes in the character\n    int\t\t*did_simplify)  // FSK_SIMPLIFY and found <C-H> or <A-x>\n{\n    int\t\tmodifiers = 0;\n    int\t\tkey;\n\n    key = find_special_key(srcp, &modifiers, flags, did_simplify);\n    if (key == 0)\n\treturn 0;\n\n    return special_to_buf(key, modifiers, escape_ks, dst);\n}\n\n/*\n * Put the character sequence for \"key\" with \"modifiers\" into \"dst\" and return\n * the resulting length.\n * When \"escape_ks\" is TRUE escape K_SPECIAL bytes in the character.\n * The sequence is not NUL terminated.\n * This is how characters in a string are encoded.\n */\n    int\nspecial_to_buf(int key, int modifiers, int escape_ks, char_u *dst)\n{\n    int\t\tdlen = 0;\n\n    // Put the appropriate modifier in a string\n    if (modifiers != 0)\n    {\n\tdst[dlen++] = K_SPECIAL;\n\tdst[dlen++] = KS_MODIFIER;\n\tdst[dlen++] = modifiers;\n    }\n\n    if (IS_SPECIAL(key))\n    {\n\tdst[dlen++] = K_SPECIAL;\n\tdst[dlen++] = KEY2TERMCAP0(key);\n\tdst[dlen++] = KEY2TERMCAP1(key);\n    }\n    else if (escape_ks)\n\tdlen = (int)(add_char2buf(key, dst + dlen) - dst);\n    else if (has_mbyte)\n\tdlen += (*mb_char2bytes)(key, dst + dlen);\n    else\n\tdst[dlen++] = key;\n\n    return dlen;\n}\n\n/*\n * Try translating a <> name at (*srcp)[], return the key and modifiers.\n * srcp is advanced to after the <> name.\n * returns 0 if there is no match.\n */\n    int\nfind_special_key(\n    char_u\t**srcp,\n    int\t\t*modp,\n    int\t\tflags,\t\t// FSK_ values\n    int\t\t*did_simplify)  // found <C-H> or <A-x>\n{\n    char_u\t*last_dash;\n    char_u\t*end_of_name;\n    char_u\t*src;\n    char_u\t*bp;\n    int\t\tin_string = flags & FSK_IN_STRING;\n    int\t\tmodifiers;\n    int\t\tbit;\n    int\t\tkey;\n    uvarnumber_T\tn;\n    int\t\tl;\n\n    src = *srcp;\n    if (src[0] != '<')\n\treturn 0;\n    if (src[1] == '*')\t    // <*xxx>: do not simplify\n\t++src;\n\n    // Find end of modifier list\n    last_dash = src;\n    for (bp = src + 1; *bp == '-' || vim_isNormalIDc(*bp); bp++)\n    {\n\tif (*bp == '-')\n\t{\n\t    last_dash = bp;\n\t    if (bp[1] != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t    l = mb_ptr2len(bp + 1);\n\t\telse\n\t\t    l = 1;\n\t\t// Anything accepted, like <C-?>.\n\t\t// <C-\"> or <M-\"> are not special in strings as \" is\n\t\t// the string delimiter. With a backslash it works: <M-\\\">\n\t\tif (!(in_string && bp[1] == '\"') && bp[l + 1] == '>')\n\t\t    bp += l;\n\t\telse if (in_string && bp[1] == '\\\\' && bp[2] == '\"'\n\t\t\t\t\t\t\t   && bp[3] == '>')\n\t\t    bp += 2;\n\t    }\n\t}\n\tif (bp[0] == 't' && bp[1] == '_' && bp[2] && bp[3])\n\t    bp += 3;\t// skip t_xx, xx may be '-' or '>'\n\telse if (STRNICMP(bp, \"char-\", 5) == 0)\n\t{\n\t    vim_str2nr(bp + 5, NULL, &l, STR2NR_ALL, NULL, NULL, 0, TRUE);\n\t    if (l == 0)\n\t    {\n\t\temsg(_(e_invalid_argument));\n\t\treturn 0;\n\t    }\n\t    bp += l + 5;\n\t    break;\n\t}\n    }\n\n    if (*bp == '>')\t// found matching '>'\n    {\n\tend_of_name = bp + 1;\n\n\t// Which modifiers are given?\n\tmodifiers = 0x0;\n\tfor (bp = src + 1; bp < last_dash; bp++)\n\t{\n\t    if (*bp != '-')\n\t    {\n\t\tbit = name_to_mod_mask(*bp);\n\t\tif (bit == 0x0)\n\t\t    break;\t// Illegal modifier name\n\t\tmodifiers |= bit;\n\t    }\n\t}\n\n\t/*\n\t * Legal modifier name.\n\t */\n\tif (bp >= last_dash)\n\t{\n\t    if (STRNICMP(last_dash + 1, \"char-\", 5) == 0\n\t\t\t\t\t\t && VIM_ISDIGIT(last_dash[6]))\n\t    {\n\t\t// <Char-123> or <Char-033> or <Char-0x33>\n\t\tvim_str2nr(last_dash + 6, NULL, &l, STR2NR_ALL, NULL,\n\t\t\t\t\t\t\t\t  &n, 0, TRUE);\n\t\tif (l == 0)\n\t\t{\n\t\t    emsg(_(e_invalid_argument));\n\t\t    return 0;\n\t\t}\n\t\tkey = (int)n;\n\t    }\n\t    else\n\t    {\n\t\tint off = 1;\n\n\t\t// Modifier with single letter, or special key name.\n\t\tif (in_string && last_dash[1] == '\\\\' && last_dash[2] == '\"')\n\t\t    off = 2;\n\t\tif (has_mbyte)\n\t\t    l = mb_ptr2len(last_dash + off);\n\t\telse\n\t\t    l = 1;\n\t\tif (modifiers != 0 && last_dash[l + off] == '>')\n\t\t    key = PTR2CHAR(last_dash + off);\n\t\telse\n\t\t{\n\t\t    key = get_special_key_code(last_dash + off);\n\t\t    if (!(flags & FSK_KEEP_X_KEY))\n\t\t\tkey = handle_x_keys(key);\n\t\t}\n\t    }\n\n\t    /*\n\t     * get_special_key_code() may return NUL for invalid\n\t     * special key name.\n\t     */\n\t    if (key != NUL)\n\t    {\n\t\t/*\n\t\t * Only use a modifier when there is no special key code that\n\t\t * includes the modifier.\n\t\t */\n\t\tkey = simplify_key(key, &modifiers);\n\n\t\tif (!(flags & FSK_KEYCODE))\n\t\t{\n\t\t    // don't want keycode, use single byte code\n\t\t    if (key == K_BS)\n\t\t\tkey = BS;\n\t\t    else if (key == K_DEL || key == K_KDEL)\n\t\t\tkey = DEL;\n\t\t}\n\n\t\t// Normal Key with modifier: Try to make a single byte code.\n\t\tif (!IS_SPECIAL(key))\n\t\t    key = extract_modifiers(key, &modifiers,\n\t\t\t\t\t   flags & FSK_SIMPLIFY, did_simplify);\n\n\t\t*modp = modifiers;\n\t\t*srcp = end_of_name;\n\t\treturn key;\n\t    }\n\t}\n    }\n    return 0;\n}\n\n\n/*\n * Some keys are used with Ctrl without Shift and are still expected to be\n * mapped as if Shift was pressed:\n * CTRL-2 is CTRL-@\n * CTRL-6 is CTRL-^\n * CTRL-- is CTRL-_\n * Also, <C-H> and <C-h> mean the same thing, always use \"H\".\n * Returns the possibly adjusted key.\n */\n    int\nmay_adjust_key_for_ctrl(int modifiers, int key)\n{\n    if (modifiers & MOD_MASK_CTRL)\n    {\n\tif (ASCII_ISALPHA(key))\n\t    return TOUPPER_ASC(key);\n\tif (key == '2')\n\t    return '@';\n\tif (key == '6')\n\t    return '^';\n\tif (key == '-')\n\t    return '_';\n    }\n    return key;\n}\n\n/*\n * Some keys already have Shift included, pass them as normal keys.\n * When Ctrl is also used <C-H> and <C-S-H> are different, but <C-S-{> should\n * be <C-{>.  Same for <C-S-}> and <C-S-|>.\n * Also for <A-S-a> and <M-S-a>.\n * This includes all printable ASCII characters except numbers and a-z.\n */\n    int\nmay_remove_shift_modifier(int modifiers, int key)\n{\n    if ((modifiers == MOD_MASK_SHIFT\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_ALT)\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_META))\n\t    && ((key >= '!' && key <= '/')\n\t\t|| (key >= ':' && key <= 'Z')\n\t\t|| (key >= '[' && key <= '`')\n\t\t|| (key >= '{' && key <= '~')))\n\treturn modifiers & ~MOD_MASK_SHIFT;\n\n    if (modifiers == (MOD_MASK_SHIFT | MOD_MASK_CTRL)\n\t\t&& (key == '{' || key == '}' || key == '|'))\n\treturn modifiers & ~MOD_MASK_SHIFT;\n\n    return modifiers;\n}\n\n/*\n * Try to include modifiers in the key.\n * Changes \"Shift-a\" to 'A', \"Alt-A\" to 0xc0, etc.\n * When \"simplify\" is FALSE don't do Ctrl and Alt.\n * When \"simplify\" is TRUE and Ctrl or Alt is removed from modifiers set\n * \"did_simplify\" when it's not NULL.\n */\n    int\nextract_modifiers(int key, int *modp, int simplify, int *did_simplify)\n{\n    int\tmodifiers = *modp;\n\n#ifdef MACOS_X\n    // Command-key really special, no fancynest\n    if (!(modifiers & MOD_MASK_CMD))\n#endif\n    if ((modifiers & MOD_MASK_SHIFT) && ASCII_ISALPHA(key))\n    {\n\tkey = TOUPPER_ASC(key);\n\t// With <C-S-a> we keep the shift modifier.\n\t// With <S-a>, <A-S-a> and <S-A> we don't keep the shift modifier.\n\tif (simplify || modifiers == MOD_MASK_SHIFT\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_ALT)\n\t\t|| modifiers == (MOD_MASK_SHIFT | MOD_MASK_META))\n\t    modifiers &= ~MOD_MASK_SHIFT;\n    }\n\n    // <C-H> and <C-h> mean the same thing, always use \"H\"\n    if ((modifiers & MOD_MASK_CTRL) && ASCII_ISALPHA(key))\n\tkey = TOUPPER_ASC(key);\n\n    if (simplify && (modifiers & MOD_MASK_CTRL)\n\t    && ((key >= '?' && key <= '_') || ASCII_ISALPHA(key)))\n    {\n\tkey = Ctrl_chr(key);\n\tmodifiers &= ~MOD_MASK_CTRL;\n\t// <C-@> is <Nul>\n\tif (key == NUL)\n\t    key = K_ZERO;\n\tif (did_simplify != NULL)\n\t    *did_simplify = TRUE;\n    }\n\n#ifdef MACOS_X\n    // Command-key really special, no fancynest\n    if (!(modifiers & MOD_MASK_CMD))\n#endif\n    if (simplify && (modifiers & MOD_MASK_ALT) && key < 0x80\n\t    && !enc_dbcs)\t\t// avoid creating a lead byte\n    {\n\tkey |= 0x80;\n\tmodifiers &= ~MOD_MASK_ALT;\t// remove the META modifier\n\tif (did_simplify != NULL)\n\t    *did_simplify = TRUE;\n    }\n\n    *modp = modifiers;\n    return key;\n}\n\n/*\n * Try to find key \"c\" in the special key table.\n * Return the index when found, -1 when not found.\n */\n    int\nfind_special_key_in_table(int c)\n{\n    int\t    i;\n\n    for (i = 0; key_names_table[i].name != NULL; i++)\n\tif (c == key_names_table[i].key)\n\t    break;\n    if (key_names_table[i].name == NULL)\n\ti = -1;\n    return i;\n}\n\n/*\n * Find the special key with the given name (the given string does not have to\n * end with NUL, the name is assumed to end before the first non-idchar).\n * If the name starts with \"t_\" the next two characters are interpreted as a\n * termcap name.\n * Return the key code, or 0 if not found.\n */\n    int\nget_special_key_code(char_u *name)\n{\n    char_u  *table_name;\n    char_u  string[3];\n    int\t    i, j;\n\n    /*\n     * If it's <t_xx> we get the code for xx from the termcap\n     */\n    if (name[0] == 't' && name[1] == '_' && name[2] != NUL && name[3] != NUL)\n    {\n\tstring[0] = name[2];\n\tstring[1] = name[3];\n\tstring[2] = NUL;\n\tif (add_termcap_entry(string, FALSE) == OK)\n\t    return TERMCAP2KEY(name[2], name[3]);\n    }\n    else\n\tfor (i = 0; key_names_table[i].name != NULL; i++)\n\t{\n\t    table_name = key_names_table[i].name;\n\t    for (j = 0; vim_isNormalIDc(name[j]) && table_name[j] != NUL; j++)\n\t\tif (TOLOWER_ASC(table_name[j]) != TOLOWER_ASC(name[j]))\n\t\t    break;\n\t    if (!vim_isNormalIDc(name[j]) && table_name[j] == NUL)\n\t\treturn key_names_table[i].key;\n\t}\n    return 0;\n}\n\n    char_u *\nget_key_name(int i)\n{\n    if (i >= (int)KEY_NAMES_TABLE_LEN)\n\treturn NULL;\n    return  key_names_table[i].name;\n}\n\n/*\n * Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.\n */\n    int\nget_fileformat(buf_T *buf)\n{\n    int\t\tc = *buf->b_p_ff;\n\n    if (buf->b_p_bin || c == 'u')\n\treturn EOL_UNIX;\n    if (c == 'm')\n\treturn EOL_MAC;\n    return EOL_DOS;\n}\n\n/*\n * Like get_fileformat(), but override 'fileformat' with \"p\" for \"++opt=val\"\n * argument.\n */\n    int\nget_fileformat_force(\n    buf_T\t*buf,\n    exarg_T\t*eap)\t    // can be NULL!\n{\n    int\t\tc;\n\n    if (eap != NULL && eap->force_ff != 0)\n\tc = eap->force_ff;\n    else\n    {\n\tif ((eap != NULL && eap->force_bin != 0)\n\t\t\t       ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin)\n\t    return EOL_UNIX;\n\tc = *buf->b_p_ff;\n    }\n    if (c == 'u')\n\treturn EOL_UNIX;\n    if (c == 'm')\n\treturn EOL_MAC;\n    return EOL_DOS;\n}\n\n/*\n * Set the current end-of-line type to EOL_DOS, EOL_UNIX or EOL_MAC.\n * Sets both 'textmode' and 'fileformat'.\n * Note: Does _not_ set global value of 'textmode'!\n */\n    void\nset_fileformat(\n    int\t\tt,\n    int\t\topt_flags)\t// OPT_LOCAL and/or OPT_GLOBAL\n{\n    char\t*p = NULL;\n\n    switch (t)\n    {\n    case EOL_DOS:\n\tp = FF_DOS;\n\tcurbuf->b_p_tx = TRUE;\n\tbreak;\n    case EOL_UNIX:\n\tp = FF_UNIX;\n\tcurbuf->b_p_tx = FALSE;\n\tbreak;\n    case EOL_MAC:\n\tp = FF_MAC;\n\tcurbuf->b_p_tx = FALSE;\n\tbreak;\n    }\n    if (p != NULL)\n\tset_string_option_direct((char_u *)\"ff\", -1, (char_u *)p,\n\t\t\t\t\t\t     OPT_FREE | opt_flags, 0);\n\n    // This may cause the buffer to become (un)modified.\n    check_status(curbuf);\n    redraw_tabline = TRUE;\n    need_maketitle = TRUE;\t    // set window title later\n}\n\n/*\n * Return the default fileformat from 'fileformats'.\n */\n    int\ndefault_fileformat(void)\n{\n    switch (*p_ffs)\n    {\n\tcase 'm':   return EOL_MAC;\n\tcase 'd':   return EOL_DOS;\n    }\n    return EOL_UNIX;\n}\n\n/*\n * Call shell.\tCalls mch_call_shell, with 'shellxquote' added.\n */\n    int\ncall_shell(char_u *cmd, int opt)\n{\n    char_u\t*ncmd;\n    int\t\tretval;\n#ifdef FEAT_PROFILE\n    proftime_T\twait_time;\n#endif\n\n    if (p_verbose > 3)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Calling shell to execute: \\\"%s\\\"\"), cmd == NULL ? p_sh : cmd);\n\tout_char('\\n');\n\tcursor_on();\n\tverbose_leave();\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_enter(&wait_time);\n#endif\n\n    if (*p_sh == NUL)\n    {\n\temsg(_(e_shell_option_is_empty));\n\tretval = -1;\n    }\n    else\n    {\n#ifdef FEAT_GUI_MSWIN\n\t// Don't hide the pointer while executing a shell command.\n\tgui_mch_mousehide(FALSE);\n#endif\n#ifdef FEAT_GUI\n\t++hold_gui_events;\n#endif\n\t// The external command may update a tags file, clear cached tags.\n\ttag_freematch();\n\n\tif (cmd == NULL || *p_sxq == NUL)\n\t    retval = mch_call_shell(cmd, opt);\n\telse\n\t{\n\t    char_u *ecmd = cmd;\n\n\t    if (*p_sxe != NUL && *p_sxq == '(')\n\t    {\n\t\tecmd = vim_strsave_escaped_ext(cmd, p_sxe, '^', FALSE);\n\t\tif (ecmd == NULL)\n\t\t    ecmd = cmd;\n\t    }\n\t    ncmd = alloc(STRLEN(ecmd) + STRLEN(p_sxq) * 2 + 1);\n\t    if (ncmd != NULL)\n\t    {\n\t\tSTRCPY(ncmd, p_sxq);\n\t\tSTRCAT(ncmd, ecmd);\n\t\t// When 'shellxquote' is ( append ).\n\t\t// When 'shellxquote' is \"( append )\".\n\t\tSTRCAT(ncmd, *p_sxq == '(' ? (char_u *)\")\"\n\t\t    : *p_sxq == '\"' && *(p_sxq+1) == '(' ? (char_u *)\")\\\"\"\n\t\t    : p_sxq);\n\t\tretval = mch_call_shell(ncmd, opt);\n\t\tvim_free(ncmd);\n\t    }\n\t    else\n\t\tretval = -1;\n\t    if (ecmd != cmd)\n\t\tvim_free(ecmd);\n\t}\n#ifdef FEAT_GUI\n\t--hold_gui_events;\n#endif\n\t/*\n\t * Check the window size, in case it changed while executing the\n\t * external command.\n\t */\n\tshell_resized_check();\n    }\n\n#ifdef FEAT_EVAL\n    set_vim_var_nr(VV_SHELL_ERROR, (long)retval);\n# ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprof_child_exit(&wait_time);\n# endif\n#endif\n\n    return retval;\n}\n\n/*\n * MODE_VISUAL, MODE_SELECT and MODE_OP_PENDING State are never set, they are\n * equal to MODE_NORMAL State with a condition.  This function returns the real\n * State.\n */\n    int\nget_real_state(void)\n{\n    if (State & MODE_NORMAL)\n    {\n\tif (VIsual_active)\n\t{\n\t    if (VIsual_select)\n\t\treturn MODE_SELECT;\n\t    return MODE_VISUAL;\n\t}\n\telse if (finish_op)\n\t    return MODE_OP_PENDING;\n    }\n    return State;\n}\n\n/*\n * Return TRUE if \"p\" points to just after a path separator.\n * Takes care of multi-byte characters.\n * \"b\" must point to the start of the file name\n */\n    int\nafter_pathsep(char_u *b, char_u *p)\n{\n    return p > b && vim_ispathsep(p[-1])\n\t\t\t     && (!has_mbyte || (*mb_head_off)(b, p - 1) == 0);\n}\n\n/*\n * Return TRUE if file names \"f1\" and \"f2\" are in the same directory.\n * \"f1\" may be a short name, \"f2\" must be a full path.\n */\n    int\nsame_directory(char_u *f1, char_u *f2)\n{\n    char_u\tffname[MAXPATHL];\n    char_u\t*t1;\n    char_u\t*t2;\n\n    // safety check\n    if (f1 == NULL || f2 == NULL)\n\treturn FALSE;\n\n    (void)vim_FullName(f1, ffname, MAXPATHL, FALSE);\n    t1 = gettail_sep(ffname);\n    t2 = gettail_sep(f2);\n    return (t1 - ffname == t2 - f2\n\t     && pathcmp((char *)ffname, (char *)f2, (int)(t1 - ffname)) == 0);\n}\n\n#if defined(FEAT_SESSION) || defined(FEAT_AUTOCHDIR) \\\n\t|| defined(MSWIN) || defined(FEAT_GUI_GTK) \\\n\t|| defined(FEAT_NETBEANS_INTG) \\\n\t|| defined(PROTO)\n/*\n * Change to a file's directory.\n * Caller must call shorten_fnames()!\n * Return OK or FAIL.\n */\n    int\nvim_chdirfile(char_u *fname, char *trigger_autocmd)\n{\n    char_u\told_dir[MAXPATHL];\n    char_u\tnew_dir[MAXPATHL];\n\n    if (mch_dirname(old_dir, MAXPATHL) != OK)\n\t*old_dir = NUL;\n\n    vim_strncpy(new_dir, fname, MAXPATHL - 1);\n    *gettail_sep(new_dir) = NUL;\n\n    if (pathcmp((char *)old_dir, (char *)new_dir, -1) == 0)\n\t// nothing to do\n\treturn OK;\n\n    if (trigger_autocmd != NULL)\n\ttrigger_DirChangedPre((char_u *)trigger_autocmd, new_dir);\n\n    if (mch_chdir((char *)new_dir) != 0)\n\treturn FAIL;\n\n    if (trigger_autocmd != NULL)\n\tapply_autocmds(EVENT_DIRCHANGED, (char_u *)trigger_autocmd,\n\t\t\t\t\t\t       new_dir, FALSE, curbuf);\n    return OK;\n}\n#endif\n\n#if defined(STAT_IGNORES_SLASH) || defined(PROTO)\n/*\n * Check if \"name\" ends in a slash and is not a directory.\n * Used for systems where stat() ignores a trailing slash on a file name.\n * The Vim code assumes a trailing slash is only ignored for a directory.\n */\n    static int\nillegal_slash(const char *name)\n{\n    if (name[0] == NUL)\n\treturn FALSE;\t    // no file name is not illegal\n    if (name[strlen(name) - 1] != '/')\n\treturn FALSE;\t    // no trailing slash\n    if (mch_isdir((char_u *)name))\n\treturn FALSE;\t    // trailing slash for a directory\n    return TRUE;\n}\n\n/*\n * Special implementation of mch_stat() for Solaris.\n */\n    int\nvim_stat(const char *name, stat_T *stp)\n{\n    // On Solaris stat() accepts \"file/\" as if it was \"file\".  Return -1 if\n    // the name ends in \"/\" and it's not a directory.\n    return illegal_slash(name) ? -1 : stat(name, stp);\n}\n#endif\n\n#if defined(CURSOR_SHAPE) || defined(PROTO)\n\n/*\n * Handling of cursor and mouse pointer shapes in various modes.\n */\n\ncursorentry_T shape_table[SHAPE_IDX_COUNT] =\n{\n    // The values will be filled in from the 'guicursor' and 'mouseshape'\n    // defaults when Vim starts.\n    // Adjust the SHAPE_IDX_ defines when making changes!\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"n\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"v\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"i\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"r\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"c\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"ci\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"cr\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"o\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0, 700L, 400L, 250L, 0, 0, \"ve\", SHAPE_CURSOR+SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"e\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"s\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"sd\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"vs\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"vd\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"m\", SHAPE_MOUSE},\n    {0,\t0, 0,   0L,   0L,   0L, 0, 0, \"ml\", SHAPE_MOUSE},\n    {0,\t0, 0, 100L, 100L, 100L, 0, 0, \"sm\", SHAPE_CURSOR},\n};\n\n#ifdef FEAT_MOUSESHAPE\n/*\n * Table with names for mouse shapes.  Keep in sync with all the tables for\n * mch_set_mouse_shape()!.\n */\nstatic char * mshape_names[] =\n{\n    \"arrow\",\t// default, must be the first one\n    \"blank\",\t// hidden\n    \"beam\",\n    \"updown\",\n    \"udsizing\",\n    \"leftright\",\n    \"lrsizing\",\n    \"busy\",\n    \"no\",\n    \"crosshair\",\n    \"hand1\",\n    \"hand2\",\n    \"pencil\",\n    \"question\",\n    \"rightup-arrow\",\n    \"up-arrow\",\n    NULL\n};\n#endif\n\n/*\n * Parse the 'guicursor' option (\"what\" is SHAPE_CURSOR) or 'mouseshape'\n * (\"what\" is SHAPE_MOUSE).\n * Returns error message for an illegal option, NULL otherwise.\n */\n    char *\nparse_shape_opt(int what)\n{\n    char_u\t*modep;\n    char_u\t*colonp;\n    char_u\t*commap;\n    char_u\t*slashp;\n    char_u\t*p, *endp;\n    int\t\tidx = 0;\t\t// init for GCC\n    int\t\tall_idx;\n    int\t\tlen;\n    int\t\ti;\n    long\tn;\n    int\t\tfound_ve = FALSE;\t// found \"ve\" flag\n    int\t\tround;\n\n    /*\n     * First round: check for errors; second round: do it for real.\n     */\n    for (round = 1; round <= 2; ++round)\n    {\n\t/*\n\t * Repeat for all comma separated parts.\n\t */\n#ifdef FEAT_MOUSESHAPE\n\tif (what == SHAPE_MOUSE)\n\t    modep = p_mouseshape;\n\telse\n#endif\n\t    modep = p_guicursor;\n\twhile (*modep != NUL)\n\t{\n\t    colonp = vim_strchr(modep, ':');\n\t    commap = vim_strchr(modep, ',');\n\n\t    if (colonp == NULL || (commap != NULL && commap < colonp))\n\t\treturn e_missing_colon_2;\n\t    if (colonp == modep)\n\t\treturn e_illegal_mode;\n\n\t    /*\n\t     * Repeat for all mode's before the colon.\n\t     * For the 'a' mode, we loop to handle all the modes.\n\t     */\n\t    all_idx = -1;\n\t    while (modep < colonp || all_idx >= 0)\n\t    {\n\t\tif (all_idx < 0)\n\t\t{\n\t\t    // Find the mode.\n\t\t    if (modep[1] == '-' || modep[1] == ':')\n\t\t\tlen = 1;\n\t\t    else\n\t\t\tlen = 2;\n\t\t    if (len == 1 && TOLOWER_ASC(modep[0]) == 'a')\n\t\t\tall_idx = SHAPE_IDX_COUNT - 1;\n\t\t    else\n\t\t    {\n\t\t\tfor (idx = 0; idx < SHAPE_IDX_COUNT; ++idx)\n\t\t\t    if (STRNICMP(modep, shape_table[idx].name, len)\n\t\t\t\t\t\t\t\t\t == 0)\n\t\t\t\tbreak;\n\t\t\tif (idx == SHAPE_IDX_COUNT\n\t\t\t\t   || (shape_table[idx].used_for & what) == 0)\n\t\t\t    return e_illegal_mode;\n\t\t\tif (len == 2 && modep[0] == 'v' && modep[1] == 'e')\n\t\t\t    found_ve = TRUE;\n\t\t    }\n\t\t    modep += len + 1;\n\t\t}\n\n\t\tif (all_idx >= 0)\n\t\t    idx = all_idx--;\n\t\telse if (round == 2)\n\t\t{\n#ifdef FEAT_MOUSESHAPE\n\t\t    if (what == SHAPE_MOUSE)\n\t\t    {\n\t\t\t// Set the default, for the missing parts\n\t\t\tshape_table[idx].mshape = 0;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\t// Set the defaults, for the missing parts\n\t\t\tshape_table[idx].shape = SHAPE_BLOCK;\n\t\t\tshape_table[idx].blinkwait = 700L;\n\t\t\tshape_table[idx].blinkon = 400L;\n\t\t\tshape_table[idx].blinkoff = 250L;\n\t\t    }\n\t\t}\n\n\t\t// Parse the part after the colon\n\t\tfor (p = colonp + 1; *p && *p != ','; )\n\t\t{\n#ifdef FEAT_MOUSESHAPE\n\t\t    if (what == SHAPE_MOUSE)\n\t\t    {\n\t\t\tfor (i = 0; ; ++i)\n\t\t\t{\n\t\t\t    if (mshape_names[i] == NULL)\n\t\t\t    {\n\t\t\t\tif (!VIM_ISDIGIT(*p))\n\t\t\t\t    return e_illegal_mouseshape;\n\t\t\t\tif (round == 2)\n\t\t\t\t    shape_table[idx].mshape =\n\t\t\t\t\t      getdigits(&p) + MSHAPE_NUMBERED;\n\t\t\t\telse\n\t\t\t\t    (void)getdigits(&p);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    len = (int)STRLEN(mshape_names[i]);\n\t\t\t    if (STRNICMP(p, mshape_names[i], len) == 0)\n\t\t\t    {\n\t\t\t\tif (round == 2)\n\t\t\t\t    shape_table[idx].mshape = i;\n\t\t\t\tp += len;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    else // if (what == SHAPE_MOUSE)\n#endif\n\t\t    {\n\t\t\t/*\n\t\t\t * First handle the ones with a number argument.\n\t\t\t */\n\t\t\ti = *p;\n\t\t\tlen = 0;\n\t\t\tif (STRNICMP(p, \"ver\", 3) == 0)\n\t\t\t    len = 3;\n\t\t\telse if (STRNICMP(p, \"hor\", 3) == 0)\n\t\t\t    len = 3;\n\t\t\telse if (STRNICMP(p, \"blinkwait\", 9) == 0)\n\t\t\t    len = 9;\n\t\t\telse if (STRNICMP(p, \"blinkon\", 7) == 0)\n\t\t\t    len = 7;\n\t\t\telse if (STRNICMP(p, \"blinkoff\", 8) == 0)\n\t\t\t    len = 8;\n\t\t\tif (len != 0)\n\t\t\t{\n\t\t\t    p += len;\n\t\t\t    if (!VIM_ISDIGIT(*p))\n\t\t\t\treturn e_digit_expected;\n\t\t\t    n = getdigits(&p);\n\t\t\t    if (len == 3)   // \"ver\" or \"hor\"\n\t\t\t    {\n\t\t\t\tif (n == 0)\n\t\t\t\t    return e_illegal_percentage;\n\t\t\t\tif (round == 2)\n\t\t\t\t{\n\t\t\t\t    if (TOLOWER_ASC(i) == 'v')\n\t\t\t\t\tshape_table[idx].shape = SHAPE_VER;\n\t\t\t\t    else\n\t\t\t\t\tshape_table[idx].shape = SHAPE_HOR;\n\t\t\t\t    shape_table[idx].percentage = n;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else if (round == 2)\n\t\t\t    {\n\t\t\t\tif (len == 9)\n\t\t\t\t    shape_table[idx].blinkwait = n;\n\t\t\t\telse if (len == 7)\n\t\t\t\t    shape_table[idx].blinkon = n;\n\t\t\t\telse\n\t\t\t\t    shape_table[idx].blinkoff = n;\n\t\t\t    }\n\t\t\t}\n\t\t\telse if (STRNICMP(p, \"block\", 5) == 0)\n\t\t\t{\n\t\t\t    if (round == 2)\n\t\t\t\tshape_table[idx].shape = SHAPE_BLOCK;\n\t\t\t    p += 5;\n\t\t\t}\n\t\t\telse\t// must be a highlight group name then\n\t\t\t{\n\t\t\t    endp = vim_strchr(p, '-');\n\t\t\t    if (commap == NULL)\t\t    // last part\n\t\t\t    {\n\t\t\t\tif (endp == NULL)\n\t\t\t\t    endp = p + STRLEN(p);   // find end of part\n\t\t\t    }\n\t\t\t    else if (endp > commap || endp == NULL)\n\t\t\t\tendp = commap;\n\t\t\t    slashp = vim_strchr(p, '/');\n\t\t\t    if (slashp != NULL && slashp < endp)\n\t\t\t    {\n\t\t\t\t// \"group/langmap_group\"\n\t\t\t\ti = syn_check_group(p, (int)(slashp - p));\n\t\t\t\tp = slashp + 1;\n\t\t\t    }\n\t\t\t    if (round == 2)\n\t\t\t    {\n\t\t\t\tshape_table[idx].id = syn_check_group(p,\n\t\t\t\t\t\t\t     (int)(endp - p));\n\t\t\t\tshape_table[idx].id_lm = shape_table[idx].id;\n\t\t\t\tif (slashp != NULL && slashp < endp)\n\t\t\t\t    shape_table[idx].id = i;\n\t\t\t    }\n\t\t\t    p = endp;\n\t\t\t}\n\t\t    } // if (what != SHAPE_MOUSE)\n\n\t\t    if (*p == '-')\n\t\t\t++p;\n\t\t}\n\t    }\n\t    modep = p;\n\t    if (*modep == ',')\n\t\t++modep;\n\t}\n    }\n\n    // If the 's' flag is not given, use the 'v' cursor for 's'\n    if (!found_ve)\n    {\n#ifdef FEAT_MOUSESHAPE\n\tif (what == SHAPE_MOUSE)\n\t{\n\t    shape_table[SHAPE_IDX_VE].mshape = shape_table[SHAPE_IDX_V].mshape;\n\t}\n\telse\n#endif\n\t{\n\t    shape_table[SHAPE_IDX_VE].shape = shape_table[SHAPE_IDX_V].shape;\n\t    shape_table[SHAPE_IDX_VE].percentage =\n\t\t\t\t\t shape_table[SHAPE_IDX_V].percentage;\n\t    shape_table[SHAPE_IDX_VE].blinkwait =\n\t\t\t\t\t  shape_table[SHAPE_IDX_V].blinkwait;\n\t    shape_table[SHAPE_IDX_VE].blinkon =\n\t\t\t\t\t    shape_table[SHAPE_IDX_V].blinkon;\n\t    shape_table[SHAPE_IDX_VE].blinkoff =\n\t\t\t\t\t   shape_table[SHAPE_IDX_V].blinkoff;\n\t    shape_table[SHAPE_IDX_VE].id = shape_table[SHAPE_IDX_V].id;\n\t    shape_table[SHAPE_IDX_VE].id_lm = shape_table[SHAPE_IDX_V].id_lm;\n\t}\n    }\n\n    return NULL;\n}\n\n# if defined(MCH_CURSOR_SHAPE) || defined(FEAT_GUI) \\\n\t|| defined(FEAT_MOUSESHAPE) || defined(PROTO)\n/*\n * Return the index into shape_table[] for the current mode.\n * When \"mouse\" is TRUE, consider indexes valid for the mouse pointer.\n */\n    int\nget_shape_idx(int mouse)\n{\n#ifdef FEAT_MOUSESHAPE\n    if (mouse && (State == MODE_HITRETURN || State == MODE_ASKMORE))\n    {\n# ifdef FEAT_GUI\n\tint x, y;\n\tgui_mch_getmouse(&x, &y);\n\tif (Y_2_ROW(y) == Rows - 1)\n\t    return SHAPE_IDX_MOREL;\n# endif\n\treturn SHAPE_IDX_MORE;\n    }\n    if (mouse && drag_status_line)\n\treturn SHAPE_IDX_SDRAG;\n    if (mouse && drag_sep_line)\n\treturn SHAPE_IDX_VDRAG;\n#endif\n    if (!mouse && State == MODE_SHOWMATCH)\n\treturn SHAPE_IDX_SM;\n    if (State & VREPLACE_FLAG)\n\treturn SHAPE_IDX_R;\n    if (State & REPLACE_FLAG)\n\treturn SHAPE_IDX_R;\n    if (State & MODE_INSERT)\n\treturn SHAPE_IDX_I;\n    if (State & MODE_CMDLINE)\n    {\n\tif (cmdline_at_end())\n\t    return SHAPE_IDX_C;\n\tif (cmdline_overstrike())\n\t    return SHAPE_IDX_CR;\n\treturn SHAPE_IDX_CI;\n    }\n    if (finish_op)\n\treturn SHAPE_IDX_O;\n    if (VIsual_active)\n    {\n\tif (*p_sel == 'e')\n\t    return SHAPE_IDX_VE;\n\telse\n\t    return SHAPE_IDX_V;\n    }\n    return SHAPE_IDX_N;\n}\n#endif\n\n# if defined(FEAT_MOUSESHAPE) || defined(PROTO)\nstatic int old_mouse_shape = 0;\n\n/*\n * Set the mouse shape:\n * If \"shape\" is -1, use shape depending on the current mode,\n * depending on the current state.\n * If \"shape\" is -2, only update the shape when it's CLINE or STATUS (used\n * when the mouse moves off the status or command line).\n */\n    void\nupdate_mouseshape(int shape_idx)\n{\n    int new_mouse_shape;\n\n    // Only works in GUI mode.\n    if (!gui.in_use || gui.starting)\n\treturn;\n\n    // Postpone the updating when more is to come.  Speeds up executing of\n    // mappings.\n    if (shape_idx == -1 && char_avail())\n    {\n\tpostponed_mouseshape = TRUE;\n\treturn;\n    }\n\n    // When ignoring the mouse don't change shape on the statusline.\n    if (*p_mouse == NUL\n\t    && (shape_idx == SHAPE_IDX_CLINE\n\t\t|| shape_idx == SHAPE_IDX_STATUS\n\t\t|| shape_idx == SHAPE_IDX_VSEP))\n\tshape_idx = -2;\n\n    if (shape_idx == -2\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_CLINE].mshape\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_STATUS].mshape\n\t    && old_mouse_shape != shape_table[SHAPE_IDX_VSEP].mshape)\n\treturn;\n    if (shape_idx < 0)\n\tnew_mouse_shape = shape_table[get_shape_idx(TRUE)].mshape;\n    else\n\tnew_mouse_shape = shape_table[shape_idx].mshape;\n    if (new_mouse_shape != old_mouse_shape)\n    {\n\tmch_set_mouse_shape(new_mouse_shape);\n\told_mouse_shape = new_mouse_shape;\n    }\n    postponed_mouseshape = FALSE;\n}\n# endif\n\n#endif // CURSOR_SHAPE\n\n\n/*\n * Change directory to \"new_dir\".  If FEAT_SEARCHPATH is defined, search\n * 'cdpath' for relative directory names, otherwise just mch_chdir().\n */\n    int\nvim_chdir(char_u *new_dir)\n{\n#ifndef FEAT_SEARCHPATH\n    return mch_chdir((char *)new_dir);\n#else\n    char_u\t*dir_name;\n    int\t\tr;\n\n    dir_name = find_directory_in_path(new_dir, (int)STRLEN(new_dir),\n\t\t\t\t\t\tFNAME_MESS, curbuf->b_ffname);\n    if (dir_name == NULL)\n\treturn -1;\n    r = mch_chdir((char *)dir_name);\n    vim_free(dir_name);\n    return r;\n#endif\n}\n\n/*\n * Get user name from machine-specific function.\n * Returns the user name in \"buf[len]\".\n * Some systems are quite slow in obtaining the user name (Windows NT), thus\n * cache the result.\n * Returns OK or FAIL.\n */\n    int\nget_user_name(char_u *buf, int len)\n{\n    if (username == NULL)\n    {\n\tif (mch_get_user_name(buf, len) == FAIL)\n\t    return FAIL;\n\tusername = vim_strsave(buf);\n    }\n    else\n\tvim_strncpy(buf, username, len - 1);\n    return OK;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free the memory allocated by get_user_name()\n */\n    void\nfree_username(void)\n{\n    vim_free(username);\n}\n#endif\n\n#ifndef HAVE_QSORT\n/*\n * Our own qsort(), for systems that don't have it.\n * It's simple and slow.  From the K&R C book.\n */\n    void\nqsort(\n    void\t*base,\n    size_t\telm_count,\n    size_t\telm_size,\n    int (*cmp)(const void *, const void *))\n{\n    char_u\t*buf;\n    char_u\t*p1;\n    char_u\t*p2;\n    int\t\ti, j;\n    int\t\tgap;\n\n    buf = alloc(elm_size);\n    if (buf == NULL)\n\treturn;\n\n    for (gap = elm_count / 2; gap > 0; gap /= 2)\n\tfor (i = gap; i < elm_count; ++i)\n\t    for (j = i - gap; j >= 0; j -= gap)\n\t    {\n\t\t// Compare the elements.\n\t\tp1 = (char_u *)base + j * elm_size;\n\t\tp2 = (char_u *)base + (j + gap) * elm_size;\n\t\tif ((*cmp)((void *)p1, (void *)p2) <= 0)\n\t\t    break;\n\t\t// Exchange the elements.\n\t\tmch_memmove(buf, p1, elm_size);\n\t\tmch_memmove(p1, p2, elm_size);\n\t\tmch_memmove(p2, buf, elm_size);\n\t    }\n\n    vim_free(buf);\n}\n#endif\n\n/*\n * The putenv() implementation below comes from the \"screen\" program.\n * Included with permission from Juergen Weigert.\n * See pty.c for the copyright notice.\n */\n\n/*\n *  putenv  --\tput value into environment\n *\n *  Usage:  i = putenv (string)\n *    int i;\n *    char  *string;\n *\n *  where string is of the form <name>=<value>.\n *  Putenv returns 0 normally, -1 on error (not enough core for malloc).\n *\n *  Putenv may need to add a new name into the environment, or to\n *  associate a value longer than the current value with a particular\n *  name.  So, to make life simpler, putenv() copies your entire\n *  environment into the heap (i.e. malloc()) from the stack\n *  (i.e. where it resides when your process is initiated) the first\n *  time you call it.\n *\n *  (history removed, not very interesting.  See the \"screen\" sources.)\n */\n\n#if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)\n\n#define EXTRASIZE 5\t\t// increment to add to env. size\n\nstatic int  envsize = -1;\t// current size of environment\nextern char **environ;\t\t// the global which is your env.\n\nstatic int  findenv(char *name); // look for a name in the env.\nstatic int  newenv(void);\t// copy env. from stack to heap\nstatic int  moreenv(void);\t// incr. size of env.\n\n    int\nputenv(const char *string)\n{\n    int\t    i;\n    char    *p;\n\n    if (envsize < 0)\n    {\t\t\t\t// first time putenv called\n\tif (newenv() < 0)\t// copy env. to heap\n\t    return -1;\n    }\n\n    i = findenv((char *)string); // look for name in environment\n\n    if (i < 0)\n    {\t\t\t\t// name must be added\n\tfor (i = 0; environ[i]; i++);\n\tif (i >= (envsize - 1))\n\t{\t\t\t// need new slot\n\t    if (moreenv() < 0)\n\t\treturn -1;\n\t}\n\tp = alloc(strlen(string) + 1);\n\tif (p == NULL)\t\t// not enough core\n\t    return -1;\n\tenviron[i + 1] = 0;\t// new end of env.\n    }\n    else\n    {\t\t\t\t// name already in env.\n\tp = vim_realloc(environ[i], strlen(string) + 1);\n\tif (p == NULL)\n\t    return -1;\n    }\n    sprintf(p, \"%s\", string);\t// copy into env.\n    environ[i] = p;\n\n    return 0;\n}\n\n    static int\nfindenv(char *name)\n{\n    char    *namechar, *envchar;\n    int\t    i, found;\n\n    found = 0;\n    for (i = 0; environ[i] && !found; i++)\n    {\n\tenvchar = environ[i];\n\tnamechar = name;\n\twhile (*namechar && *namechar != '=' && (*namechar == *envchar))\n\t{\n\t    namechar++;\n\t    envchar++;\n\t}\n\tfound = ((*namechar == '\\0' || *namechar == '=') && *envchar == '=');\n    }\n    return found ? i - 1 : -1;\n}\n\n    static int\nnewenv(void)\n{\n    char    **env, *elem;\n    int\t    i, esize;\n\n    for (i = 0; environ[i]; i++)\n\t;\n\n    esize = i + EXTRASIZE + 1;\n    env = ALLOC_MULT(char *, esize);\n    if (env == NULL)\n\treturn -1;\n\n    for (i = 0; environ[i]; i++)\n    {\n\telem = alloc(strlen(environ[i]) + 1);\n\tif (elem == NULL)\n\t    return -1;\n\tenv[i] = elem;\n\tstrcpy(elem, environ[i]);\n    }\n\n    env[i] = 0;\n    environ = env;\n    envsize = esize;\n    return 0;\n}\n\n    static int\nmoreenv(void)\n{\n    int\t    esize;\n    char    **env;\n\n    esize = envsize + EXTRASIZE;\n    env = vim_realloc((char *)environ, esize * sizeof (*env));\n    if (env == 0)\n\treturn -1;\n    environ = env;\n    envsize = esize;\n    return 0;\n}\n\n# ifdef USE_VIMPTY_GETENV\n/*\n * Used for mch_getenv() for Mac.\n */\n    char_u *\nvimpty_getenv(const char_u *string)\n{\n    int i;\n    char_u *p;\n\n    if (envsize < 0)\n\treturn NULL;\n\n    i = findenv((char *)string);\n\n    if (i < 0)\n\treturn NULL;\n\n    p = vim_strchr((char_u *)environ[i], '=');\n    return (p + 1);\n}\n# endif\n\n#endif // !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)\n\n#if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Return 0 for not writable, 1 for writable file, 2 for a dir which we have\n * rights to write into.\n */\n    int\nfilewritable(char_u *fname)\n{\n    int\t\tretval = 0;\n#if defined(UNIX) || defined(VMS)\n    int\t\tperm = 0;\n#endif\n\n#if defined(UNIX) || defined(VMS)\n    perm = mch_getperm(fname);\n#endif\n    if (\n# ifdef MSWIN\n\t    mch_writable(fname) &&\n# else\n# if defined(UNIX) || defined(VMS)\n\t    (perm & 0222) &&\n#  endif\n# endif\n\t    mch_access((char *)fname, W_OK) == 0\n       )\n    {\n\t++retval;\n\tif (mch_isdir(fname))\n\t    ++retval;\n    }\n    return retval;\n}\n#endif\n\n#if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)\n/*\n * Read 2 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget2c(FILE *fd)\n{\n    int\t\tc, n;\n\n    n = getc(fd);\n    if (n == EOF) return -1;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    return (n << 8) + c;\n}\n\n/*\n * Read 3 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget3c(FILE *fd)\n{\n    int\t\tc, n;\n\n    n = getc(fd);\n    if (n == EOF) return -1;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    return (n << 8) + c;\n}\n\n/*\n * Read 4 bytes from \"fd\" and turn them into an int, MSB first.\n * Returns -1 when encountering EOF.\n */\n    int\nget4c(FILE *fd)\n{\n    int\t\tc;\n    // Use unsigned rather than int otherwise result is undefined\n    // when left-shift sets the MSB.\n    unsigned\tn;\n\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    c = getc(fd);\n    if (c == EOF) return -1;\n    n = (n << 8) + (unsigned)c;\n    return (int)n;\n}\n\n/*\n * Read a string of length \"cnt\" from \"fd\" into allocated memory.\n * Returns NULL when out of memory or unable to read that many bytes.\n */\n    char_u *\nread_string(FILE *fd, int cnt)\n{\n    char_u\t*str;\n    int\t\ti;\n    int\t\tc;\n\n    // allocate memory\n    str = alloc(cnt + 1);\n    if (str != NULL)\n    {\n\t// Read the string.  Quit when running into the EOF.\n\tfor (i = 0; i < cnt; ++i)\n\t{\n\t    c = getc(fd);\n\t    if (c == EOF)\n\t    {\n\t\tvim_free(str);\n\t\treturn NULL;\n\t    }\n\t    str[i] = c;\n\t}\n\tstr[i] = NUL;\n    }\n    return str;\n}\n\n/*\n * Write a number to file \"fd\", MSB first, in \"len\" bytes.\n */\n    int\nput_bytes(FILE *fd, long_u nr, int len)\n{\n    int\t    i;\n\n    for (i = len - 1; i >= 0; --i)\n\tif (putc((int)(nr >> (i * 8)), fd) == EOF)\n\t    return FAIL;\n    return OK;\n}\n\n#endif\n\n#ifndef PROTO  // proto is defined in vim.h\n# ifdef ELAPSED_TIMEVAL\n/*\n * Return time in msec since \"start_tv\".\n */\n    long\nelapsed(struct timeval *start_tv)\n{\n    struct timeval  now_tv;\n\n    gettimeofday(&now_tv, NULL);\n    return (now_tv.tv_sec - start_tv->tv_sec) * 1000L\n\t + (now_tv.tv_usec - start_tv->tv_usec) / 1000L;\n}\n# endif\n\n# ifdef ELAPSED_TICKCOUNT\n/*\n * Return time in msec since \"start_tick\".\n */\n    long\nelapsed(DWORD start_tick)\n{\n    DWORD\tnow = GetTickCount();\n\n    return (long)now - (long)start_tick;\n}\n# endif\n#endif\n\n#if defined(FEAT_JOB_CHANNEL) \\\n\t|| (defined(UNIX) && (!defined(USE_SYSTEM) \\\n\t|| (defined(FEAT_GUI) && defined(FEAT_TERMINAL)))) \\\n\t|| defined(PROTO)\n/*\n * Parse \"cmd\" and put the white-separated parts in \"argv\".\n * \"argv\" is an allocated array with \"argc\" entries and room for 4 more.\n * Returns FAIL when out of memory.\n */\n    int\nmch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc)\n{\n    int\t\ti;\n    char_u\t*p, *d;\n    int\t\tinquote;\n\n    /*\n     * Do this loop twice:\n     * 1: find number of arguments\n     * 2: separate them and build argv[]\n     */\n    for (i = 1; i <= 2; ++i)\n    {\n\tp = skipwhite(cmd);\n\tinquote = FALSE;\n\t*argc = 0;\n\twhile (*p != NUL)\n\t{\n\t    if (i == 2)\n\t\t(*argv)[*argc] = (char *)p;\n\t    ++*argc;\n\t    d = p;\n\t    while (*p != NUL && (inquote || (*p != ' ' && *p != TAB)))\n\t    {\n\t\tif (p[0] == '\"')\n\t\t    // quotes surrounding an argument and are dropped\n\t\t    inquote = !inquote;\n\t\telse\n\t\t{\n\t\t    if (rem_backslash(p))\n\t\t    {\n\t\t\t// First pass: skip over \"\\ \" and \"\\\"\".\n\t\t\t// Second pass: Remove the backslash.\n\t\t\t++p;\n\t\t    }\n\t\t    if (i == 2)\n\t\t\t*d++ = *p;\n\t\t}\n\t\t++p;\n\t    }\n\t    if (*p == NUL)\n\t    {\n\t\tif (i == 2)\n\t\t    *d++ = NUL;\n\t\tbreak;\n\t    }\n\t    if (i == 2)\n\t\t*d++ = NUL;\n\t    p = skipwhite(p + 1);\n\t}\n\tif (*argv == NULL)\n\t{\n\t    if (use_shcf)\n\t    {\n\t\t// Account for possible multiple args in p_shcf.\n\t\tp = p_shcf;\n\t\tfor (;;)\n\t\t{\n\t\t    p = skiptowhite(p);\n\t\t    if (*p == NUL)\n\t\t\tbreak;\n\t\t    ++*argc;\n\t\t    p = skipwhite(p);\n\t\t}\n\t    }\n\n\t    *argv = ALLOC_MULT(char *, *argc + 4);\n\t    if (*argv == NULL)\t    // out of memory\n\t\treturn FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Build \"argv[argc]\" from the string \"cmd\".\n * \"argv[argc]\" is set to NULL;\n * Return FAIL when out of memory.\n */\n    int\nbuild_argv_from_string(char_u *cmd, char ***argv, int *argc)\n{\n    char_u\t*cmd_copy;\n    int\t\ti;\n\n    // Make a copy, parsing will modify \"cmd\".\n    cmd_copy = vim_strsave(cmd);\n    if (cmd_copy == NULL\n\t    || mch_parse_cmd(cmd_copy, FALSE, argv, argc) == FAIL)\n    {\n\tvim_free(cmd_copy);\n\treturn FAIL;\n    }\n    for (i = 0; i < *argc; i++)\n\t(*argv)[i] = (char *)vim_strsave((char_u *)(*argv)[i]);\n    (*argv)[*argc] = NULL;\n    vim_free(cmd_copy);\n    return OK;\n}\n\n# if defined(FEAT_JOB_CHANNEL) || defined(PROTO)\n/*\n * Build \"argv[argc]\" from the list \"l\".\n * \"argv[argc]\" is set to NULL;\n * Return FAIL when out of memory.\n */\n    int\nbuild_argv_from_list(list_T *l, char ***argv, int *argc)\n{\n    listitem_T  *li;\n    char_u\t*s;\n\n    // Pass argv[] to mch_call_shell().\n    *argv = ALLOC_MULT(char *, l->lv_len + 1);\n    if (*argv == NULL)\n\treturn FAIL;\n    *argc = 0;\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\ts = tv_get_string_chk(&li->li_tv);\n\tif (s == NULL)\n\t{\n\t    int i;\n\n\t    for (i = 0; i < *argc; ++i)\n\t\tVIM_CLEAR((*argv)[i]);\n\t    (*argv)[0] = NULL;\n\t    return FAIL;\n\t}\n\t(*argv)[*argc] = (char *)vim_strsave(s);\n\t*argc += 1;\n    }\n    (*argv)[*argc] = NULL;\n    return OK;\n}\n# endif\n#endif\n\n/*\n * Change the behavior of vterm.\n * 0: As usual.\n * 1: Windows 10 version 1809\n *      The bug causes unstable handling of ambiguous width character.\n * 2: Windows 10 version 1903 & 1909\n *      Use the wrong result because each result is different.\n * 3: Windows 10 insider preview (current latest logic)\n */\n    int\nget_special_pty_type(void)\n{\n#ifdef MSWIN\n    return get_conpty_type();\n#else\n    return 0;\n#endif\n}\n", "/* misc2.c */\nint virtual_active(void);\nint getviscol(void);\nint coladvance_force(colnr_T wcol);\nint getviscol2(colnr_T col, colnr_T coladd);\nint coladvance(colnr_T wcol);\nint getvpos(pos_T *pos, colnr_T wcol);\nint inc_cursor(void);\nint inc(pos_T *lp);\nint incl(pos_T *lp);\nint dec_cursor(void);\nint dec(pos_T *lp);\nint decl(pos_T *lp);\nlinenr_T get_cursor_rel_lnum(win_T *wp, linenr_T lnum);\nvoid check_pos(buf_T *buf, pos_T *pos);\nvoid check_cursor_lnum(void);\nvoid check_cursor_col(void);\nvoid check_cursor_col_win(win_T *win);\nvoid check_cursor(void);\nvoid check_visual_pos(void);\nvoid adjust_cursor_col(void);\nint leftcol_changed(void);\nint copy_option_part(char_u **option, char_u *buf, int maxlen, char *sep_chars);\nint vim_isspace(int x);\nint simplify_key(int key, int *modifiers);\nint handle_x_keys(int key);\nchar_u *get_special_key_name(int c, int modifiers);\nint trans_special(char_u **srcp, char_u *dst, int flags, int escape_ks, int *did_simplify);\nint special_to_buf(int key, int modifiers, int escape_ks, char_u *dst);\nint find_special_key(char_u **srcp, int *modp, int flags, int *did_simplify);\nint may_adjust_key_for_ctrl(int modifiers, int key);\nint may_remove_shift_modifier(int modifiers, int key);\nint extract_modifiers(int key, int *modp, int simplify, int *did_simplify);\nint find_special_key_in_table(int c);\nint get_special_key_code(char_u *name);\nchar_u *get_key_name(int i);\nint get_fileformat(buf_T *buf);\nint get_fileformat_force(buf_T *buf, exarg_T *eap);\nvoid set_fileformat(int t, int opt_flags);\nint default_fileformat(void);\nint call_shell(char_u *cmd, int opt);\nint get_real_state(void);\nint after_pathsep(char_u *b, char_u *p);\nint same_directory(char_u *f1, char_u *f2);\nint vim_chdirfile(char_u *fname, char *trigger_autocmd);\nint vim_stat(const char *name, stat_T *stp);\nchar *parse_shape_opt(int what);\nint get_shape_idx(int mouse);\nvoid update_mouseshape(int shape_idx);\nint vim_chdir(char_u *new_dir);\nint get_user_name(char_u *buf, int len);\nvoid free_username(void);\nint filewritable(char_u *fname);\nint get2c(FILE *fd);\nint get3c(FILE *fd);\nint get4c(FILE *fd);\nchar_u *read_string(FILE *fd, int cnt);\nint put_bytes(FILE *fd, long_u nr, int len);\nint mch_parse_cmd(char_u *cmd, int use_shcf, char ***argv, int *argc);\nint build_argv_from_string(char_u *cmd, char ***argv, int *argc);\nint build_argv_from_list(list_T *l, char ***argv, int *argc);\nint get_special_pty_type(void);\n/* vim: set ft=c : */\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  \" replace a character with composing characters\n  call setline(1, \"xa\u0303\u0333x\")\n  normal gg0lvrb\n  call assert_equal(\"xbx\", getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_yank_zy()\n  new\n  \" this was reading before the start of the line\n  exe \"norm o\\<C-T>\\<Esc>\\<C-V>zy\"\n  bwipe!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_block_append_invalid_char()\n  \" this was going over the end of the line\n  set isprint=@,161-255\n  new\n  call setline(1, ['\t   let xxx', 'xxxxx\u0088', 'xxxxxxxxxxx'])\n  exe \"normal 0\\<C-V>jjA-\\<Esc>\"\n  call assert_equal(['\t-   let xxx', 'xxxxx   -\u0088', 'xxxxxxxx-xxx'], getline(1, 3))\n  bwipe!\n  set isprint&\nendfunc\n\nfunc Test_visual_block_with_substitute()\n  \" this was reading beyond the end of the line\n  new\n  norm a0)\n  sil! norm \u0016 O\n  s/)\n  sil! norm \u001d\n  bwipe!\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\nfunc Test_visual_block_insert_round_off()\n  new\n  \" The number of characters are tuned to fill a 4096 byte allocated block,\n  \" so that valgrind reports going over the end.\n  call setline(1, ['xxxxx', repeat('0', 1350), \"\\t\", repeat('x', 60)])\n  exe \"normal gg0\\<C-V>GI\" .. repeat('0', 1320) .. \"\\<Esc>\"\n  bwipe!\nendfunc\n\n\" this was causing an ml_get error\nfunc Test_visual_exchange_windows()\n  enew!\n  new\n  call setline(1, ['foo', 'bar'])\n  exe \"normal G\\<C-V>gg\\<C-W>\\<C-X>OO\\<Esc>\"\n  bwipe!\n  bwipe!\nendfunc\n\n\" this was leaving the end of the Visual area beyond the end of a line\nfunc Test_visual_ex_copy_line()\n  new\n  call setline(1, [\"aaa\", \"bbbbbbbbbxbb\"])\n  /x\n  exe \"normal ggvjfxO\"\n  t0\n  normal gNU\n  bwipe!\nendfunc\n\n\" This was leaving the end of the Visual area beyond the end of a line.\n\" Set 'undolevels' to start a new undo block.\nfunc Test_visual_undo_deletes_last_line()\n  new\n  call setline(1, [\"aaa\", \"ccc\", \"dyd\"])\n  set undolevels=100\n  exe \"normal obbbbbbbbbxbb\\<Esc>\"\n  set undolevels=100\n  /y\n  exe \"normal ggvjfxO\"\n  undo\n  normal gNU\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste()\n  new\n\n  \" v_p overwrites unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('fooxxx', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vp\n  call assert_equal('f', @\")\n  call assert_equal('f', @-)\n  call assert_equal('bazooxxx', getline(1))\n  normal $vp\n  call assert_equal('x', @\")\n  call assert_equal('x', @-)\n  call assert_equal('bazooxxf', getline(1))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_paste_clipboard()\n  CheckFeature clipboard_working\n\n  if has('gui')\n    \" auto select feature breaks tests\n    set guioptions-=a\n  endif\n\n  \" v_P does not overwrite unnamed register.\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxx', getline(1))\n  normal $vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('fooxxfoo', getline(1))\n  \" Test with a different register as unnamed register.\n  call setline(2, ['baz'])\n  normal 2gg0\"rD\n  call assert_equal('baz', @\")\n  normal gg0vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfoo', getline(1))\n  normal $vP\n  call assert_equal('baz', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('bazooxxfobaz', getline(1))\n\n  \" Test for unnamed clipboard\n  set clipboard=unnamed\n  call setline(1, ['xxxx'])\n  call setreg('\"', 'foo')\n  call setreg('-', 'bar')\n  call setreg('*', 'baz')\n  normal gg0vP\n  call assert_equal('foo', @\")\n  call assert_equal('bar', @-)\n  call assert_equal('baz', @*)\n  call assert_equal('bazxxx', getline(1))\n\n  \" Test for unnamedplus clipboard\n  if has('unnamedplus')\n    set clipboard=unnamedplus\n    call setline(1, ['xxxx'])\n    call setreg('\"', 'foo')\n    call setreg('-', 'bar')\n    call setreg('+', 'baz')\n    normal gg0vP\n    call assert_equal('foo', @\")\n    call assert_equal('bar', @-)\n    call assert_equal('baz', @+)\n    call assert_equal('bazxxx', getline(1))\n  endif\n\n  set clipboard&\n  if has('gui')\n    set guioptions&\n  endif\n  bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/change.c", "src/edit.c", "src/misc2.c", "src/proto/misc2.pro", "src/testdir/test_visual.vim", "src/version.c"], "buggy_code_start_loc": [549, 2544, 622, 19, 1298, 748], "buggy_code_end_loc": [549, 2554, 2420, 19, 1298, 748], "fixing_code_start_loc": [550, 2544, 623, 20, 1299, 749], "fixing_code_end_loc": [553, 2546, 2445, 21, 1310, 751], "type": "CWE-120", "message": "Classic Buffer Overflow in GitHub repository vim/vim prior to 8.2.4969.", "other": {"cve": {"id": "CVE-2022-1735", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-17T19:15:08.150", "lastModified": "2023-05-03T12:15:27.790", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Classic Buffer Overflow in GitHub repository vim/vim prior to 8.2.4969."}, {"lang": "es", "value": "Un Desbordamiento de B\u00fafer Cl\u00e1sico en el repositorio GitHub vim/vim versiones anteriores a 8.2.4969"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4969", "matchCriteriaId": "F82A8E1C-FF11-4CC1-B5DA-027B5CE6AAEC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "13.0", "matchCriteriaId": "71E032AD-F827-4944-9699-BB1E6D4233FC"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Oct/28", "source": "security@huntr.dev"}, {"url": "http://seclists.org/fulldisclosure/2022/Oct/41", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c9f85608-ff11-48e4-933d-53d1759d44d9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213488", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/7ce5b2b590256ce53d6af28c1d203fb3bc1d2d97"}}