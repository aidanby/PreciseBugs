{"buggy_code": ["import discord\nfrom typing import Optional\nfrom datetime import datetime\nfrom redbot.core import commands, checks, Config, modlog\n\n\nclass Ticketer(commands.Cog):\n    \"\"\"Ticketer\"\"\"\n    __version__=\"1.0.0\"\n\n    async def red_delete_data_for_user(self, *, requester, user_id):\n        # This cog stores no EUD\n        return\n\n    def format_help_for_context(self, ctx: commands.Context) -> str:\n        #Thanks Sinbad! And Trusty in whose cogs I found this.\n        pre_processed = super().format_help_for_context(ctx)\n        return f\"{pre_processed}\\n\\nVersion: {self.__version__}\"\n\n    def __init__(self):\n        self.config = Config.get_conf(self, 200730042020, force_registration=True)\n        default_guild = {\n            \"channel\": None,\n            \"use_counter\": False,\n            \"closed_category\": None,\n            \"open_category\": None,\n            \"current_ticket\": 0,\n            \"role\": None,\n            \"message\": \"Your ticket has been created. You can add information by typing in this channel. \\n\\nA member of the ticket-handling-team will be with you as soon as they can.\",\n            \"active\": [],\n            \"modlog\": True,\n            \"closed\": [],\n        }\n        self.config.register_guild(**default_guild)\n\n    @staticmethod\n    async def register_casetypes():\n        new_types = [\n            {\n                \"name\": \"ticket_created\",\n                \"default_setting\": True,\n                \"image\": \"\\N{BALLOT BOX WITH BALLOT}\\N{VARIATION SELECTOR-16}\",\n                \"case_str\": \"Ticket created\",\n            }\n        ]\n        await modlog.register_casetypes(new_types)\n\n    @commands.group()\n    @checks.admin()\n    async def ticketer(self, ctx):\n        \"\"\"All ticketer settings.\"\"\"\n        pass\n\n    @ticketer.command()\n    async def channel(self, ctx, channel: discord.TextChannel):\n        \"\"\"Set the ticket-management channel.\"\"\"\n        await self.config.guild(ctx.guild).channel.set(channel.id)\n        await ctx.send(f\"Channel has been set to {channel.mention}.\")\n\n    @ticketer.command()\n    async def role(self, ctx, role: discord.Role):\n        \"\"\"Set the role for ticket managers.\"\"\"\n        await self.config.guild(ctx.guild).role.set(role.id)\n        await ctx.send(f\"Ticket manager role has been set to {role.mention}.\")\n\n    @ticketer.group()\n    async def category(self, ctx):\n        \"\"\"Set the categories for open and closed tickets.\"\"\"\n\n    @category.group()\n    async def open(self, ctx, *, category: discord.CategoryChannel):\n        \"\"\"Set the category for open tickets.\"\"\"\n        await self.config.guild(ctx.guild).open_category.set(category.id)\n        await ctx.send(f\"Category for open tickets has been set to {category.mention}\")\n\n    @category.group()\n    async def closed(self, ctx, *, category: discord.CategoryChannel):\n        \"\"\"Set the category for open tickets.\"\"\"\n        await self.config.guild(ctx.guild).closed_category.set(category.id)\n        await ctx.send(f\"Category for closed tickets has been set to {category.mention}\")\n\n    @ticketer.command()\n    async def message(self, ctx, *, message: str):\n        \"\"\"Set the message that is shown at the start of each ticket channel.\\n\\nUse ``{user.mention}`` to mention the person who created the ticket.\"\"\"\n        try:\n            message.format(user=ctx.author)\n            await self.config.guild(ctx.guild).message.set(message)\n            await ctx.send(f\"The message has been set to `{message}`.\")\n        except KeyError:\n            await ctx.send(\n                \"Setting the message failed. Please make sure to only use supported variables in  `\\{\\}`\"\n            )\n\n    @ticketer.command()\n    async def counter(self, ctx, true_or_false: bool):\n        \"\"\"Toggle if the ticket channels should be named using a user's name and ID or counting upwards starting at 0.\"\"\"\n        await self.config.guild(ctx.guild).use_counter.set(true_or_false)\n        await ctx.send(\n            \"The counter has been {}.\".format(\"enabled\" if true_or_false else \"disabled\")\n        )\n\n    @ticketer.command()\n    async def modlog(self, ctx, true_or_false: bool):\n        \"\"\"Decide if ticketer should log to modlog.\"\"\"\n        await self.config.guild(ctx.guild).modlog.set(true_or_false)\n        await ctx.send(\n            \"Logging to modlog has been {}.\".format(\"enabled\" if true_or_false else \"disabled\")\n        )\n\n    @ticketer.command()\n    async def quicksetup(self, ctx):\n        \"\"\"Sets configurations automatically.\"\"\"\n        settings = await self.config.guild(ctx.guild).all()\n        if not settings[\"role\"]:\n            role = await ctx.guild.create_role(\n                name=\"Ticketmanagers\",\n                hoist=True,\n                mentionable=False,\n                reason=\"Ticketer quicksetup\",\n            )\n            await self.config.guild(ctx.guild).role.set(role.id)\n            await ctx.send(\"Ticket-manager role created.\")\n        if not settings[\"open_category\"]:\n            category = await ctx.guild.create_category(\n                name=\"Open-tickets\", reason=\"Ticketer quicksetup\"\n            )\n            await self.config.guild(ctx.guild).open_category.set(category.id)\n            await ctx.send(\"Category for open tickets created.\")\n        if not settings[\"closed_category\"]:\n            category = await ctx.guild.create_category(\n                name=\"Closed-tickets\", reason=\"Ticketer quicksetup\"\n            )\n            await self.config.guild(ctx.guild).closed_category.set(category.id)\n            await ctx.send(\"Category for closed tickets created.\")\n        settings = await self.config.guild(ctx.guild).all()\n        if not settings[\"channel\"]:\n            await ctx.send(\"Config queried for channel setup.\")\n            overwrite = {\n                ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                    read_messages=True,\n                    send_messages=True,\n                    embed_links=True,\n                    attach_files=True,\n                    manage_messages=True,\n                ),\n            }\n            channel = await ctx.guild.create_text_channel(\n                \"ticket-management\",\n                overwrites=overwrite,\n                category=ctx.guild.get_channel(settings[\"open_category\"]),\n                topic=\"Ticket management channel.\",\n                reason=\"Ticketer quicksetup\",\n            )\n            await self.config.guild(ctx.guild).channel.set(channel.id)\n            await ctx.send(\"Channel for ticket management created.\")\n        await ctx.send(\"Checking settings...\")\n        if await self._check_settings(ctx):\n            await ctx.send(\"Quicksetup completed.\")\n        else:\n            await ctx.send(\"Something went wrong...\")\n\n    @ticketer.command()\n    async def purge(self, ctx, are_you_sure: Optional[bool]):\n        \"\"\"Deletes all closed ticket channels.\"\"\"\n        if are_you_sure:\n            async with self.config.guild(ctx.guild).closed() as closed:\n                for channel in closed:\n                    try:\n                        channel_obj = ctx.guild.get_channel(channel)\n                        if channel_obj:\n                            await channel_obj.delete(reason=\"Ticket purge\")\n                        closed.remove(channel)\n                    except discord.Forbidden:\n                        await ctx.send(\n                            f\"I could not delete channel ID {channel} because I don't have the required permissions.\"\n                        )\n                    except discord.NotFound:\n                        closed.remove(channel)\n                    except discord.HTTPException:\n                        await ctx.send(\"Something went wrong. Aborting.\")\n                        return\n        else:\n            await ctx.send(\n                f\"This action will permanently delete all closed ticket channels.\\nThis action is irreversible.\\nConfirm with ``{ctx.clean_prefix}ticketer purge true``\"\n            )\n\n    @commands.group()\n    async def ticket(self, ctx):\n        \"\"\"Manage a ticket.\"\"\"\n        pass\n\n    @ticket.command(aliases=[\"open\"])\n    async def create(\n        self,\n        ctx,\n        *,\n        reason: Optional[str] = \"No reason provided.\",\n    ):\n        \"\"\"Create a ticket.\"\"\"\n        if await self._check_settings(ctx):\n            settings = await self.config.guild(ctx.guild).all()\n            if settings[\"use_counter\"]:\n                name = f\"ticket-{settings['current_ticket']}\"\n                await self.config.guild(ctx.guild).current_ticket.set(\n                    settings[\"current_ticket\"] + 1\n                )\n            else:\n                name = f\"{ctx.author.name}-{ctx.author.id}\"\n            found = False\n            for channel in ctx.guild.channels:\n                if channel.name == name.lower():\n                    found = True\n            if not found:\n                if settings[\"modlog\"]:\n                    await modlog.create_case(\n                        ctx.bot,\n                        ctx.guild,\n                        ctx.message.created_at,\n                        action_type=\"ticket_created\",\n                        user=ctx.author,\n                        moderator=ctx.author,\n                        reason=reason,\n                    )\n                overwrite = {\n                    ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                    ctx.author: discord.PermissionOverwrite(\n                        read_messages=True,\n                        send_messages=True,\n                        embed_links=True,\n                        attach_files=True,\n                    ),\n                    ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                        read_messages=True,\n                        send_messages=True,\n                        embed_links=True,\n                        attach_files=True,\n                        manage_messages=True,\n                    ),\n                }\n                ticketchannel = await ctx.guild.create_text_channel(\n                    name,\n                    overwrites=overwrite,\n                    category=ctx.guild.get_channel(settings[\"open_category\"]),\n                    topic=reason,\n                )\n                await ticketchannel.send(settings[\"message\"].format(user=ctx.author))\n                embed = discord.Embed(\n                    title=name,\n                    description=reason,\n                    timestamp=datetime.utcnow(),\n                ).set_footer(text=\"Last updated at:\")\n                message = await ctx.guild.get_channel(settings[\"channel\"]).send(embed=embed)\n                async with self.config.guild(ctx.guild).active() as active:\n                    active.append((ticketchannel.id, message.id))\n            else:\n                await ctx.send(\"You already have an open ticket.\")\n        else:\n            await ctx.send(\"Please finish the setup process before creating a ticket.\")\n\n    @ticket.command()\n    async def close(self, ctx):\n        \"\"\"Close a ticket.\"\"\"\n        settings = await self.config.guild(ctx.guild).all()\n        active = settings[\"active\"]\n        success = False\n        for ticket in active:\n            if ctx.channel.id in ticket:\n                new_embed = (\n                    await ctx.guild.get_channel(settings[\"channel\"]).fetch_message(ticket[1])\n                ).embeds[0]\n                new_embed.add_field(\n                    name=datetime.utcnow().strftime(\"%H:%m UTC\"),\n                    value=f\"Ticket closed by {ctx.author}\",\n                )\n                new_embed.timestamp = datetime.utcnow()\n                await (\n                    await ctx.guild.get_channel(settings[\"channel\"]).fetch_message(ticket[1])\n                ).edit(\n                    embed=new_embed,\n                    delete_after=10,\n                )\n                await ctx.send(embed=new_embed)\n                await ctx.send(\n                    \"This ticket can no longer be edited using ticketer.\",\n                    delete_after=30,\n                )\n                await ctx.channel.edit(\n                    category=ctx.guild.get_channel(settings[\"closed_category\"]),\n                    name=f\"{ctx.channel.name}-c-{datetime.utcnow().strftime('%B-%d-%Y-%H-%m')}\",\n                    overwrites={\n                        ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                        ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                            read_messages=True,\n                            send_messages=True,\n                            embed_links=True,\n                            attach_files=True,\n                            manage_messages=True,\n                        ),\n                    },\n                )\n                await ctx.send(\"Ticket closed.\")\n                active.remove(ticket)\n                async with self.config.guild(ctx.guild).closed() as closed:\n                    closed.append(ticket[0])\n                success = True\n        if not success:\n            await ctx.send(\"This is not a ticket channel.\")\n        await self.config.guild(ctx.guild).active.set(active)\n\n    @ticket.command()\n    @checks.mod()\n    async def update(self, ctx, ticket: Optional[discord.TextChannel] = None, *, update: str):\n        \"\"\"Update a ticket. This is visible to all participants of the ticket.\"\"\"\n        if ticket is None:\n            channel = ctx.channel\n        else:\n            channel = ticket\n        settings = await self.config.guild(ctx.guild).all()\n        active = settings[\"active\"]\n        for ticket in active:\n            if channel.id in ticket:\n                await channel.edit(topic=f'{channel.topic}\\n\\n{ctx.author}:\"{update}\"')\n                await ctx.send(\"Ticket updated.\", delete_after=10)\n            else:\n                ctx.send(f\"{channel.mention} is not a ticket channel.\")\n\n    @ticket.command()\n    @checks.mod()\n    async def note(self, ctx, ticket: discord.TextChannel, *, note: str):\n        \"\"\"Add a staff-only note to a ticket.\"\"\"\n        channel = ticket\n        ticket_found = False\n        for ticket in await self.config.guild(ctx.guild).active():\n            if channel.id in ticket:\n                message = await ctx.guild.get_channel(\n                    await self.config.guild(ctx.guild).channel()\n                ).fetch_message(ticket[1])\n                new_embed = message.embeds[0]\n                new_embed.add_field(name=f\"{ctx.author}\", value=note)\n                new_embed.timestamp = datetime.utcnow()\n                await message.edit(embed=new_embed)\n                await ctx.send(\"Note added.\", delete_after=10)\n                ticket_found = True\n        if not ticket_found:\n            await ctx.send(\"This is not a ticket channel.\")\n\n    async def _check_settings(self, ctx: commands.Context) -> bool:\n        settings = await self.config.guild(ctx.guild).all()\n        count = 0\n        if settings[\"channel\"]:\n            count += 1\n        else:\n            await ctx.send(\"Management channel not set up yet.\")\n        if settings[\"closed_category\"]:\n            count += 1\n        else:\n            await ctx.send(\"Category for closed tickets not set up yet.\")\n        if settings[\"open_category\"]:\n            count += 1\n        else:\n            await ctx.send(\"Category for open tickets not set up yet.\")\n        if settings[\"role\"]:\n            count += 1\n        else:\n            await ctx.send(\"Ticket manager role not set up yet.\")\n        if count == 4:\n            return True\n        else:\n            return False\n"], "fixing_code": ["import discord\nfrom typing import Optional\nfrom datetime import datetime\nfrom redbot.core import commands, checks, Config, modlog\n\n\nclass Ticketer(commands.Cog):\n    \"\"\"Ticketer\"\"\"\n\n    __version__ = \"1.0.1\"\n\n    async def red_delete_data_for_user(self, *, requester, user_id):\n        # This cog stores no EUD\n        return\n\n    def format_help_for_context(self, ctx: commands.Context) -> str:\n        # Thanks Sinbad! And Trusty in whose cogs I found this.\n        pre_processed = super().format_help_for_context(ctx)\n        return f\"{pre_processed}\\n\\nVersion: {self.__version__}\"\n\n    def __init__(self):\n        self.config = Config.get_conf(self, 200730042020, force_registration=True)\n        default_guild = {\n            \"channel\": None,\n            \"use_counter\": False,\n            \"closed_category\": None,\n            \"open_category\": None,\n            \"current_ticket\": 0,\n            \"role\": None,\n            \"message\": \"Your ticket has been created. You can add information by typing in this channel. \\n\\nA member of the ticket-handling-team will be with you as soon as they can.\",\n            \"active\": [],\n            \"modlog\": True,\n            \"closed\": [],\n        }\n        self.config.register_guild(**default_guild)\n\n    @staticmethod\n    async def register_casetypes():\n        new_types = [\n            {\n                \"name\": \"ticket_created\",\n                \"default_setting\": True,\n                \"image\": \"\\N{BALLOT BOX WITH BALLOT}\\N{VARIATION SELECTOR-16}\",\n                \"case_str\": \"Ticket created\",\n            }\n        ]\n        await modlog.register_casetypes(new_types)\n\n    @commands.group()\n    @checks.admin()\n    async def ticketer(self, ctx):\n        \"\"\"All ticketer settings.\"\"\"\n        pass\n\n    @ticketer.command()\n    async def channel(self, ctx, channel: discord.TextChannel):\n        \"\"\"Set the ticket-management channel.\"\"\"\n        await self.config.guild(ctx.guild).channel.set(channel.id)\n        await ctx.send(f\"Channel has been set to {channel.mention}.\")\n\n    @ticketer.command()\n    async def role(self, ctx, role: discord.Role):\n        \"\"\"Set the role for ticket managers.\"\"\"\n        await self.config.guild(ctx.guild).role.set(role.id)\n        await ctx.send(f\"Ticket manager role has been set to {role.mention}.\")\n\n    @ticketer.group()\n    async def category(self, ctx):\n        \"\"\"Set the categories for open and closed tickets.\"\"\"\n\n    @category.group()\n    async def open(self, ctx, *, category: discord.CategoryChannel):\n        \"\"\"Set the category for open tickets.\"\"\"\n        await self.config.guild(ctx.guild).open_category.set(category.id)\n        await ctx.send(f\"Category for open tickets has been set to {category.mention}\")\n\n    @category.group()\n    async def closed(self, ctx, *, category: discord.CategoryChannel):\n        \"\"\"Set the category for open tickets.\"\"\"\n        await self.config.guild(ctx.guild).closed_category.set(category.id)\n        await ctx.send(f\"Category for closed tickets has been set to {category.mention}\")\n\n    @ticketer.command()\n    async def message(self, ctx, *, message: str):\n        \"\"\"Set the message that is shown at the start of each ticket channel.\\n\\nUse ``{user.mention}`` to mention the person who created the ticket.\"\"\"\n        try:\n            message.format(user=SafeMember(ctx.author))\n            await self.config.guild(ctx.guild).message.set(message)\n            await ctx.send(f\"The message has been set to `{message}`.\")\n        except KeyError:\n            await ctx.send(\n                \"Setting the message failed. Please make sure to only use supported variables in  `\\{\\}`\"\n            )\n\n    @ticketer.command()\n    async def counter(self, ctx, true_or_false: bool):\n        \"\"\"Toggle if the ticket channels should be named using a user's name and ID or counting upwards starting at 0.\"\"\"\n        await self.config.guild(ctx.guild).use_counter.set(true_or_false)\n        await ctx.send(\n            \"The counter has been {}.\".format(\"enabled\" if true_or_false else \"disabled\")\n        )\n\n    @ticketer.command()\n    async def modlog(self, ctx, true_or_false: bool):\n        \"\"\"Decide if ticketer should log to modlog.\"\"\"\n        await self.config.guild(ctx.guild).modlog.set(true_or_false)\n        await ctx.send(\n            \"Logging to modlog has been {}.\".format(\"enabled\" if true_or_false else \"disabled\")\n        )\n\n    @ticketer.command()\n    async def quicksetup(self, ctx):\n        \"\"\"Sets configurations automatically.\"\"\"\n        settings = await self.config.guild(ctx.guild).all()\n        if not settings[\"role\"]:\n            role = await ctx.guild.create_role(\n                name=\"Ticketmanagers\",\n                hoist=True,\n                mentionable=False,\n                reason=\"Ticketer quicksetup\",\n            )\n            await self.config.guild(ctx.guild).role.set(role.id)\n            await ctx.send(\"Ticket-manager role created.\")\n        if not settings[\"open_category\"]:\n            category = await ctx.guild.create_category(\n                name=\"Open-tickets\", reason=\"Ticketer quicksetup\"\n            )\n            await self.config.guild(ctx.guild).open_category.set(category.id)\n            await ctx.send(\"Category for open tickets created.\")\n        if not settings[\"closed_category\"]:\n            category = await ctx.guild.create_category(\n                name=\"Closed-tickets\", reason=\"Ticketer quicksetup\"\n            )\n            await self.config.guild(ctx.guild).closed_category.set(category.id)\n            await ctx.send(\"Category for closed tickets created.\")\n        settings = await self.config.guild(ctx.guild).all()\n        if not settings[\"channel\"]:\n            await ctx.send(\"Config queried for channel setup.\")\n            overwrite = {\n                ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                    read_messages=True,\n                    send_messages=True,\n                    embed_links=True,\n                    attach_files=True,\n                    manage_messages=True,\n                ),\n            }\n            channel = await ctx.guild.create_text_channel(\n                \"ticket-management\",\n                overwrites=overwrite,\n                category=ctx.guild.get_channel(settings[\"open_category\"]),\n                topic=\"Ticket management channel.\",\n                reason=\"Ticketer quicksetup\",\n            )\n            await self.config.guild(ctx.guild).channel.set(channel.id)\n            await ctx.send(\"Channel for ticket management created.\")\n        await ctx.send(\"Checking settings...\")\n        if await self._check_settings(ctx):\n            await ctx.send(\"Quicksetup completed.\")\n        else:\n            await ctx.send(\"Something went wrong...\")\n\n    @ticketer.command()\n    async def purge(self, ctx, are_you_sure: Optional[bool]):\n        \"\"\"Deletes all closed ticket channels.\"\"\"\n        if are_you_sure:\n            async with self.config.guild(ctx.guild).closed() as closed:\n                for channel in closed:\n                    try:\n                        channel_obj = ctx.guild.get_channel(channel)\n                        if channel_obj:\n                            await channel_obj.delete(reason=\"Ticket purge\")\n                        closed.remove(channel)\n                    except discord.Forbidden:\n                        await ctx.send(\n                            f\"I could not delete channel ID {channel} because I don't have the required permissions.\"\n                        )\n                    except discord.NotFound:\n                        closed.remove(channel)\n                    except discord.HTTPException:\n                        await ctx.send(\"Something went wrong. Aborting.\")\n                        return\n        else:\n            await ctx.send(\n                f\"This action will permanently delete all closed ticket channels.\\nThis action is irreversible.\\nConfirm with ``{ctx.clean_prefix}ticketer purge true``\"\n            )\n\n    @commands.group()\n    async def ticket(self, ctx):\n        \"\"\"Manage a ticket.\"\"\"\n        pass\n\n    @ticket.command(aliases=[\"open\"])\n    async def create(\n        self,\n        ctx,\n        *,\n        reason: Optional[str] = \"No reason provided.\",\n    ):\n        \"\"\"Create a ticket.\"\"\"\n        if await self._check_settings(ctx):\n            settings = await self.config.guild(ctx.guild).all()\n            if settings[\"use_counter\"]:\n                name = f\"ticket-{settings['current_ticket']}\"\n                await self.config.guild(ctx.guild).current_ticket.set(\n                    settings[\"current_ticket\"] + 1\n                )\n            else:\n                name = f\"{ctx.author.name}-{ctx.author.id}\"\n            found = False\n            for channel in ctx.guild.channels:\n                if channel.name == name.lower():\n                    found = True\n            if not found:\n                if settings[\"modlog\"]:\n                    await modlog.create_case(\n                        ctx.bot,\n                        ctx.guild,\n                        ctx.message.created_at,\n                        action_type=\"ticket_created\",\n                        user=ctx.author,\n                        moderator=ctx.author,\n                        reason=reason,\n                    )\n                overwrite = {\n                    ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                    ctx.author: discord.PermissionOverwrite(\n                        read_messages=True,\n                        send_messages=True,\n                        embed_links=True,\n                        attach_files=True,\n                    ),\n                    ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                        read_messages=True,\n                        send_messages=True,\n                        embed_links=True,\n                        attach_files=True,\n                        manage_messages=True,\n                    ),\n                }\n                ticketchannel = await ctx.guild.create_text_channel(\n                    name,\n                    overwrites=overwrite,\n                    category=ctx.guild.get_channel(settings[\"open_category\"]),\n                    topic=reason,\n                )\n                await ticketchannel.send(settings[\"message\"].format(user=SafeMember(ctx.author)))\n                embed = discord.Embed(\n                    title=name,\n                    description=reason,\n                    timestamp=datetime.utcnow(),\n                ).set_footer(text=\"Last updated at:\")\n                message = await ctx.guild.get_channel(settings[\"channel\"]).send(embed=embed)\n                async with self.config.guild(ctx.guild).active() as active:\n                    active.append((ticketchannel.id, message.id))\n            else:\n                await ctx.send(\"You already have an open ticket.\")\n        else:\n            await ctx.send(\"Please finish the setup process before creating a ticket.\")\n\n    @ticket.command()\n    async def close(self, ctx):\n        \"\"\"Close a ticket.\"\"\"\n        settings = await self.config.guild(ctx.guild).all()\n        active = settings[\"active\"]\n        success = False\n        for ticket in active:\n            if ctx.channel.id in ticket:\n                new_embed = (\n                    await ctx.guild.get_channel(settings[\"channel\"]).fetch_message(ticket[1])\n                ).embeds[0]\n                new_embed.add_field(\n                    name=datetime.utcnow().strftime(\"%H:%m UTC\"),\n                    value=f\"Ticket closed by {ctx.author}\",\n                )\n                new_embed.timestamp = datetime.utcnow()\n                await (\n                    await ctx.guild.get_channel(settings[\"channel\"]).fetch_message(ticket[1])\n                ).edit(\n                    embed=new_embed,\n                    delete_after=10,\n                )\n                await ctx.send(embed=new_embed)\n                await ctx.send(\n                    \"This ticket can no longer be edited using ticketer.\",\n                    delete_after=30,\n                )\n                await ctx.channel.edit(\n                    category=ctx.guild.get_channel(settings[\"closed_category\"]),\n                    name=f\"{ctx.channel.name}-c-{datetime.utcnow().strftime('%B-%d-%Y-%H-%m')}\",\n                    overwrites={\n                        ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),\n                        ctx.guild.get_role(settings[\"role\"]): discord.PermissionOverwrite(\n                            read_messages=True,\n                            send_messages=True,\n                            embed_links=True,\n                            attach_files=True,\n                            manage_messages=True,\n                        ),\n                    },\n                )\n                await ctx.send(\"Ticket closed.\")\n                active.remove(ticket)\n                async with self.config.guild(ctx.guild).closed() as closed:\n                    closed.append(ticket[0])\n                success = True\n        if not success:\n            await ctx.send(\"This is not a ticket channel.\")\n        await self.config.guild(ctx.guild).active.set(active)\n\n    @ticket.command()\n    @checks.mod()\n    async def update(self, ctx, ticket: Optional[discord.TextChannel] = None, *, update: str):\n        \"\"\"Update a ticket. This is visible to all participants of the ticket.\"\"\"\n        if ticket is None:\n            channel = ctx.channel\n        else:\n            channel = ticket\n        settings = await self.config.guild(ctx.guild).all()\n        active = settings[\"active\"]\n        for ticket in active:\n            if channel.id in ticket:\n                await channel.edit(topic=f'{channel.topic}\\n\\n{ctx.author}:\"{update}\"')\n                await ctx.send(\"Ticket updated.\", delete_after=10)\n            else:\n                ctx.send(f\"{channel.mention} is not a ticket channel.\")\n\n    @ticket.command()\n    @checks.mod()\n    async def note(self, ctx, ticket: discord.TextChannel, *, note: str):\n        \"\"\"Add a staff-only note to a ticket.\"\"\"\n        channel = ticket\n        ticket_found = False\n        for ticket in await self.config.guild(ctx.guild).active():\n            if channel.id in ticket:\n                message = await ctx.guild.get_channel(\n                    await self.config.guild(ctx.guild).channel()\n                ).fetch_message(ticket[1])\n                new_embed = message.embeds[0]\n                new_embed.add_field(name=f\"{ctx.author}\", value=note)\n                new_embed.timestamp = datetime.utcnow()\n                await message.edit(embed=new_embed)\n                await ctx.send(\"Note added.\", delete_after=10)\n                ticket_found = True\n        if not ticket_found:\n            await ctx.send(\"This is not a ticket channel.\")\n\n    async def _check_settings(self, ctx: commands.Context) -> bool:\n        settings = await self.config.guild(ctx.guild).all()\n        count = 0\n        if settings[\"channel\"]:\n            count += 1\n        else:\n            await ctx.send(\"Management channel not set up yet.\")\n        if settings[\"closed_category\"]:\n            count += 1\n        else:\n            await ctx.send(\"Category for closed tickets not set up yet.\")\n        if settings[\"open_category\"]:\n            count += 1\n        else:\n            await ctx.send(\"Category for open tickets not set up yet.\")\n        if settings[\"role\"]:\n            count += 1\n        else:\n            await ctx.send(\"Ticket manager role not set up yet.\")\n        if count == 4:\n            return True\n        else:\n            return False\n\n\nclass SafeMember:\n    \"\"\"Thank you kenny https://github.com/kennnyshiwa/kennnyshiwa-cogs\"\"\"\n\n    def __init__(self, member: discord.Member):\n        self.name = member.name\n        self.mention = member.mention\n\n    def __str__(self):\n        return self.name\n\n    def __getattr__(self, name):\n        return \"\""], "filenames": ["ticketer/ticketer.py"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [370], "fixing_code_start_loc": [9], "fixing_code_end_loc": [386], "type": "CWE-77", "message": "Ticketer is a command based ticket system cog (plugin) for the red discord bot. A vulnerability allowing discord users to expose sensitive information has been found in the Ticketer cog. Please upgrade to version 1.0.1 as soon as possible. As a workaround users may unload the ticketer cog to disable the exploitable code.", "other": {"cve": {"id": "CVE-2021-29501", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-10T17:15:07.807", "lastModified": "2022-10-25T19:55:37.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ticketer is a command based ticket system cog (plugin) for the red discord bot. A vulnerability allowing discord users to expose sensitive information has been found in the Ticketer cog. Please upgrade to version 1.0.1 as soon as possible. As a workaround users may unload the ticketer cog to disable the exploitable code."}, {"lang": "es", "value": "Ticketer es un engranaje del sistema (plugin) de tickets basado en comandos para el bot red discord.&#xa0;Una vulnerabilidad permite a usuarios de discord exponer informaci\u00f3n confidencial que ha sido encontrada en el Ticketer cog.&#xa0;Actualice a la versi\u00f3n 1.0.1 lo antes posible.&#xa0;Como soluci\u00f3n alternativa, los usuarios pueden descargar el engranaje de ticketer cog para deshabilitar el c\u00f3digo explotable"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dav-cogs_project:dav-cogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1", "matchCriteriaId": "E33CBB67-F1C1-4F77-8886-644206CB57F0"}]}]}], "references": [{"url": "https://github.com/Dav-Git/Dav-Cogs/commit/3d54ef9b52ce03f139b7d6c1cc38c375e65593fd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Dav-Git/Dav-Cogs/security/advisories/GHSA-r2cf-49r7-pfj7", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Dav-Git/Dav-Cogs/commit/3d54ef9b52ce03f139b7d6c1cc38c375e65593fd"}}