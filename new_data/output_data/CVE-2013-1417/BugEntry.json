{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990,1991,2001,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, krb5_db_entry **,\n               const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock * tgskey = 0;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_transited enc_tkt_transited;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_timestamp rtime;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *krbtgt = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n\n    reply.padata = 0; /* For cleanup handler */\n    reply_encpart.enc_padata = 0;\n    enc_tkt_reply.authorization_data = NULL;\n\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &krbtgt, &tgskey, &subkey, &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    if (errcode !=0) {\n        status = \"kdc_find_fast\";\n        goto cleanup;\n    }\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n    /* XXX until nothing depends on request being mutated */\n    krb5_free_principal(kdc_context, request->server);\n    request->server = NULL;\n    errcode = krb5_copy_principal(kdc_context, server->princ,\n                                  &request->server);\n    if (errcode != 0) {\n        status = \"COPYING RESOLVED SERVER\";\n        goto cleanup;\n    }\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    is_referral = krb5_is_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, tgs_server, server->princ);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = 0;\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /*\n     * Fix header_ticket's starttime; if it's zero, fill in the\n     * authtime's value.\n     */\n    if (!(header_enc_tkt->times.starttime))\n        header_enc_tkt->times.starttime = authtime;\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDED))\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXIABLE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXY);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_MAY_POSTDATE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_POSTDATED);\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_life = enc_tkt_reply.times.endtime - enc_tkt_reply.times.starttime;\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            min(header_ticket->enc_part2->times.renew_till,\n                kdc_time + old_life);\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n\n        if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n            (enc_tkt_reply.times.endtime < request->till) &&\n            isflagset(header_enc_tkt->flags, TKT_FLG_RENEWABLE)) {\n            setflag(request->kdc_options, KDC_OPT_RENEWABLE);\n            request->rtime =\n                min(request->till, header_enc_tkt->times.renew_till);\n        }\n    }\n    rtime = (request->rtime == 0) ? kdc_infinity : request->rtime;\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE)) {\n        /* already checked above in policy check to reject request for a\n           renewable ticket using a non-renewable ticket */\n        setflag(enc_tkt_reply.flags, TKT_FLG_RENEWABLE);\n        enc_tkt_reply.times.renew_till =\n            min(rtime,\n                min(header_enc_tkt->times.renew_till,\n                    enc_tkt_reply.times.starttime +\n                    min(server->max_renewable_life,\n                        max_renewable_life_for_realm)));\n    } else {\n        enc_tkt_reply.times.renew_till = 0;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        setflag(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /*\n     * Propagate the preauthentication flags through to the returned ticket.\n     */\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_PRE_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PRE_AUTH);\n\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_HW_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_HW_AUTH);\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server, krbtgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              tgskey,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"BAD_TRTYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        enc_tkt_transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        enc_tkt_transited.magic = 0;\n        enc_tkt_transited.tr_contents.magic = 0;\n        enc_tkt_transited.tr_contents.data = 0;\n        enc_tkt_transited.tr_contents.length = 0;\n        enc_tkt_reply.transited = enc_tkt_transited;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TR_FAIL\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, krbtgt);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (reject_bad_transit\n        && !isflagset (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"TKT_ENCRYPT\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"KDC_RETURN_S4U2SELF_PADATA\";\n            goto cleanup;\n        }\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"Preparing FAST padata\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"generating reply key\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > 128)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    krb5_db_free_principal(kdc_context, client);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (tgskey != NULL)\n        krb5_free_keyblock(kdc_context, tgskey);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    if (state) {\n        retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                       &errpkt, &fast_edata);\n    }\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * Get the key for the second ticket, if any, and decrypt it.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, krb5_db_entry **server_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server;\n    krb5_keyblock *key;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    if (!(req->kdc_options & STKT_OPTIONS))\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt,\n                                flags,\n                                TRUE, /* match_enctype */\n                                &server,\n                                &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key,\n                                   req->second_ticket[0]);\n    krb5_free_keyblock(kdc_context, key);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *server_out = server;\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            goto cleanup;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n    retval = krb5_c_make_random_key(kdc_context, useenctype, skey);\n    if (retval != 0) {\n        /* random key failed */\n        *status = \"RANDOM_KEY_FAILED\";\n        goto cleanup;\n    }\ncleanup:\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *ref_services = kdc_active_realm->realm_host_based_services;\n    char *nonref_services = kdc_active_realm->realm_no_host_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (kdc_active_realm->realm_host_based_services != NULL) {\n            if (!krb5_match_config_pattern(ref_services, stype) &&\n                !krb5_match_config_pattern(ref_services, KRB5_CONF_ASTERISK))\n                goto cleanup;\n        } else\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (kdc_active_realm->realm_no_host_referral != NULL) {\n            if (krb5_match_config_pattern(nonref_services, stype))\n                goto cleanup;\n            if (krb5_match_config_pattern(nonref_services, KRB5_CONF_ASTERISK))\n                goto cleanup;\n        }\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990,1991,2001,2007,2008,2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, krb5_db_entry **,\n               const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(struct server_handle *handle, krb5_data *pkt,\n                const krb5_fulladdr *from, krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock * tgskey = 0;\n    krb5_kdc_req *request = 0;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    int st_idx = 0;\n    krb5_enc_tkt_part enc_tkt_reply;\n    krb5_transited enc_tkt_transited;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key;\n    krb5_timestamp rtime;\n    krb5_keyblock *reply_key = NULL;\n    krb5_key_data  *server_key;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *krbtgt = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    kdc_realm_t *kdc_active_realm = NULL;\n\n    reply.padata = 0; /* For cleanup handler */\n    reply_encpart.enc_padata = 0;\n    enc_tkt_reply.authorization_data = NULL;\n\n    session_key.contents = NULL;\n\n    retval = decode_krb5_tgs_req(pkt, &request);\n    if (retval)\n        return retval;\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    /*\n     * setup_server_realm() sets up the global realm-specific data pointer.\n     */\n    kdc_active_realm = setup_server_realm(handle, request->server);\n    if (kdc_active_realm == NULL) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return KRB5KDC_ERR_WRONG_REALM;\n    }\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode !=0) {\n        krb5_free_kdc_req(handle->kdc_err_context, request);\n        return errcode;\n    }\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &krbtgt, &tgskey, &subkey, &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        status=\"UNEXPECTED NULL in header_ticket\";\n        goto cleanup;\n    }\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    if (errcode !=0) {\n        status = \"kdc_find_fast\";\n        goto cleanup;\n    }\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    setflag(s_flags, KRB5_KDB_FLAG_ALIAS_OK);\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n    /* XXX until nothing depends on request being mutated */\n    krb5_free_principal(kdc_context, request->server);\n    request->server = NULL;\n    errcode = krb5_copy_principal(kdc_context, server->princ,\n                                  &request->server);\n    if (errcode != 0) {\n        status = \"COPYING RESOLVED SERVER\";\n        goto cleanup;\n    }\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time))) {\n        status = \"TIME_OF_DAY\";\n        goto cleanup;\n    }\n\n    if ((retval = validate_tgs_request(kdc_active_realm,\n                                       request, *server, header_ticket,\n                                       kdc_time, &status, &e_data))) {\n        if (!status)\n            status = \"UNKNOWN_REASON\";\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (!is_local_principal(kdc_active_realm, header_enc_tkt->client))\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n\n    is_referral = krb5_is_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, tgs_server, server->princ);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm,\n                                       request,\n                                       header_enc_tkt->client,\n                                       server,\n                                       subkey,\n                                       header_enc_tkt->session,\n                                       kdc_time,\n                                       &s4u_x509_user,\n                                       &client,\n                                       &status);\n    if (errcode)\n        goto cleanup;\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt_server, &status);\n    if (errcode)\n        goto cleanup;\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks */\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm,\n                                            request,\n                                            request->second_ticket[st_idx]->enc_part2,\n                                            stkt_server,\n                                            header_ticket->enc_part2->client,\n                                            request->server,\n                                            &status);\n        if (errcode)\n            goto cleanup;\n\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        assert(client == NULL); /* assured by kdc_process_s4u2self_req() */\n        client = stkt_server;\n        stkt_server = NULL;\n    } else if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        krb5_db_free_principal(kdc_context, stkt_server);\n        stkt_server = NULL;\n    } else\n        assert(stkt_server == NULL);\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION))\n        subject_tkt = request->second_ticket[st_idx]->enc_part2;\n    else\n        subject_tkt = header_enc_tkt;\n    authtime = subject_tkt->times.authtime;\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = 0;\n    enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(server->attributes, KRB5_KDB_OK_AS_DELEGATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_OK_AS_DELEGATE);\n\n    /*\n     * Fix header_ticket's starttime; if it's zero, fill in the\n     * authtime's value.\n     */\n    if (!(header_enc_tkt->times.starttime))\n        header_enc_tkt->times.starttime = authtime;\n    setflag(enc_tkt_reply.flags, TKT_FLG_ENC_PA_REP);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDABLE)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n        if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /*\n             * If S4U2Self principal is not forwardable, then mark ticket as\n             * unforwardable. This behaviour matches Windows, but it is\n             * different to the MIT AS-REQ path, which returns an error\n             * (KDC_ERR_POLICY) if forwardable tickets cannot be issued.\n             *\n             * Consider this block the S4U2Self equivalent to\n             * validate_forwardable().\n             */\n            if (client != NULL &&\n                isflagset(client->attributes, KRB5_KDB_DISALLOW_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * Forwardable flag is propagated along referral path.\n             */\n            else if (!isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDABLE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n            /*\n             * OK_TO_AUTH_AS_DELEGATE must be set on the service requesting\n             * S4U2Self in order for forwardable tickets to be returned.\n             */\n            else if (!is_referral &&\n                     !isflagset(server->attributes,\n                                KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n                clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n        }\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_FORWARDED))\n        setflag(enc_tkt_reply.flags, TKT_FLG_FORWARDED);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXIABLE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_PROXY);\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE))\n        setflag(enc_tkt_reply.flags, TKT_FLG_MAY_POSTDATE);\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED)) {\n        setflag(enc_tkt_reply.flags, TKT_FLG_POSTDATED);\n        setflag(enc_tkt_reply.flags, TKT_FLG_INVALID);\n        enc_tkt_reply.times.starttime = request->from;\n    } else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_life = enc_tkt_reply.times.endtime - enc_tkt_reply.times.starttime;\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            min(header_ticket->enc_part2->times.renew_till,\n                kdc_time + old_life);\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n\n        if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE_OK) &&\n            (enc_tkt_reply.times.endtime < request->till) &&\n            isflagset(header_enc_tkt->flags, TKT_FLG_RENEWABLE)) {\n            setflag(request->kdc_options, KDC_OPT_RENEWABLE);\n            request->rtime =\n                min(request->till, header_enc_tkt->times.renew_till);\n        }\n    }\n    rtime = (request->rtime == 0) ? kdc_infinity : request->rtime;\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEWABLE)) {\n        /* already checked above in policy check to reject request for a\n           renewable ticket using a non-renewable ticket */\n        setflag(enc_tkt_reply.flags, TKT_FLG_RENEWABLE);\n        enc_tkt_reply.times.renew_till =\n            min(rtime,\n                min(header_enc_tkt->times.renew_till,\n                    enc_tkt_reply.times.starttime +\n                    min(server->max_renewable_life,\n                        max_renewable_life_for_realm)));\n    } else {\n        enc_tkt_reply.times.renew_till = 0;\n    }\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_ANONYMOUS))\n        setflag(enc_tkt_reply.flags, TKT_FLG_ANONYMOUS);\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /*\n     * Propagate the preauthentication flags through to the returned ticket.\n     */\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_PRE_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_PRE_AUTH);\n\n    if (isflagset(header_enc_tkt->flags, TKT_FLG_HW_AUTH))\n        setflag(enc_tkt_reply.flags, TKT_FLG_HW_AUTH);\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        altcprinc = subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        encrypting_key = *(t2enc->session);\n    } else {\n        /*\n         * Find the server key\n         */\n        if ((errcode = krb5_dbe_find_enctype(kdc_context, server,\n                                             -1, /* ignore keytype */\n                                             -1, /* Ignore salttype */\n                                             0,  /* Get highest kvno */\n                                             &server_key))) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n\n        /*\n         * Convert server.key into a real key\n         * (it may be encrypted in the database)\n         */\n        if ((errcode = krb5_dbe_decrypt_key_data(kdc_context, NULL,\n                                                 server_key, &encrypting_key,\n                                                 NULL))) {\n            status = \"DECRYPT_SERVER_KEY\";\n            goto cleanup;\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /*\n         * If we are not doing protocol transition/constrained delegation\n         * try to lookup the client principal so plugins can add additional\n         * authorization information.\n         *\n         * Always validate authorization data for constrained delegation\n         * because we must validate the KDC signatures.\n         */\n        if (!isflagset(c_flags, KRB5_KDB_FLAGS_S4U)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM))\n        enc_tkt_reply.client = s4u_x509_user->user_id.user;\n    else\n        enc_tkt_reply.client = subject_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server, krbtgt,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              &encrypting_key, /* U2U or server key */\n                              tgskey,\n                              pkt,\n                              request,\n                              s4u_x509_user ?\n                              s4u_x509_user->user_id.user : NULL,\n                              subject_tkt,\n                              &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the local realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    /* realm compare is like strcmp, but knows how to deal with these args */\n    if (krb5_realm_compare(kdc_context, header_ticket->server, tgs_server) ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"BAD_TRTYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        enc_tkt_transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        enc_tkt_transited.magic = 0;\n        enc_tkt_transited.tr_contents.magic = 0;\n        enc_tkt_transited.tr_contents.data = 0;\n        enc_tkt_transited.tr_contents.length = 0;\n        enc_tkt_reply.transited = enc_tkt_transited;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TR_FAIL\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CROSS_REALM)) {\n        errcode = validate_transit_path(kdc_context, header_enc_tkt->client,\n                                        server, krbtgt);\n        if (errcode) {\n            status = \"NON_TRANSITIVE\";\n            goto cleanup;\n        }\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (reject_bad_transit\n        && !isflagset (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /*\n     * If we are doing user-to-user authentication, then make sure\n     * that the client for the second ticket matches the request\n     * server, and then encrypt the ticket using the session key of\n     * the second ticket.\n     */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        /*\n         * Make sure the client for the second ticket matches\n         * requested server.\n         */\n        krb5_enc_tkt_part *t2enc = request->second_ticket[st_idx]->enc_part2;\n        krb5_principal client2 = t2enc->client;\n        if (!krb5_principal_compare(kdc_context, request->server, client2)) {\n            altcprinc = client2;\n            errcode = KRB5KDC_ERR_SERVER_NOMATCH;\n            status = \"2ND_TKT_MISMATCH\";\n            goto cleanup;\n        }\n\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = t2enc->session->enctype;\n        st_idx++;\n    } else {\n        ticket_kvno = server_key->key_data_kvno;\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, &encrypting_key,\n                                    &ticket_reply);\n    if (!isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY))\n        krb5_free_keyblock_contents(kdc_context, &encrypting_key);\n    if (errcode) {\n        status = \"TKT_ENCRYPT\";\n        goto cleanup;\n    }\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode) {\n            status = \"KDC_RETURN_S4U2SELF_PADATA\";\n            goto cleanup;\n        }\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode !=0 ) {\n        status = \"Preparing FAST padata\";\n        goto cleanup;\n    }\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode) {\n        status  = \"generating reply key\";\n        goto cleanup;\n    }\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (errcode) {\n        status = \"ENCODE_KDC_REP\";\n    } else {\n        status = \"ISSUE\";\n    }\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > 128)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, krbtgt);\n    krb5_db_free_principal(kdc_context, client);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (tgskey != NULL)\n        krb5_free_keyblock(kdc_context, tgskey);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.ctime = request->nonce;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    if (state) {\n        retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                       &errpkt, &fast_edata);\n    }\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * Get the key for the second ticket, if any, and decrypt it.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, krb5_db_entry **server_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server;\n    krb5_keyblock *key;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    if (!(req->kdc_options & STKT_OPTIONS))\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt,\n                                flags,\n                                TRUE, /* match_enctype */\n                                &server,\n                                &key,\n                                &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key,\n                                   req->second_ticket[0]);\n    krb5_free_keyblock(kdc_context, key);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *server_out = server;\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            goto cleanup;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        retval = KRB5KDC_ERR_ETYPE_NOSUPP;\n        goto cleanup;\n    }\n    retval = krb5_c_make_random_key(kdc_context, useenctype, skey);\n    if (retval != 0) {\n        /* random key failed */\n        *status = \"RANDOM_KEY_FAILED\";\n        goto cleanup;\n    }\ncleanup:\n    return retval;\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *ref_services = kdc_active_realm->realm_host_based_services;\n    char *nonref_services = kdc_active_realm->realm_no_host_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (kdc_active_realm->realm_host_based_services != NULL) {\n            if (!krb5_match_config_pattern(ref_services, stype) &&\n                !krb5_match_config_pattern(ref_services, KRB5_CONF_ASTERISK))\n                goto cleanup;\n        } else\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (kdc_active_realm->realm_no_host_referral != NULL) {\n            if (krb5_match_config_pattern(nonref_services, stype))\n                goto cleanup;\n            if (krb5_match_config_pattern(nonref_services, KRB5_CONF_ASTERISK))\n                goto cleanup;\n        }\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n"], "filenames": ["src/kdc/do_tgs_req.c"], "buggy_code_start_loc": [1059], "buggy_code_end_loc": [1153], "fixing_code_start_loc": [1060], "fixing_code_end_loc": [1155], "type": "CWE-20", "message": "do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) 1.11 before 1.11.4, when a single-component realm name is used, allows remote authenticated users to cause a denial of service (daemon crash) via a TGS-REQ request that triggers an attempted cross-realm referral for a host-based service principal.", "other": {"cve": {"id": "CVE-2013-1417", "sourceIdentifier": "cve@mitre.org", "published": "2013-11-20T14:12:44.960", "lastModified": "2020-01-21T15:46:38.133", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "do_tgs_req.c in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) 1.11 before 1.11.4, when a single-component realm name is used, allows remote authenticated users to cause a denial of service (daemon crash) via a TGS-REQ request that triggers an attempted cross-realm referral for a host-based service principal."}, {"lang": "es", "value": "do_tgs_req.c en Key Distribution Center (KDC) de Kerberos 5 (tambi\u00e9n conocido como krb5) 1.11 anterior a la versi\u00f3n 1.11.4, cuando el nombre realm de un \u00fanico componente es usado, permite a usuarios autenticados provocar una denegaci\u00f3n de servicio (ca\u00edda del demonio) a trav\u00e9s de peticiones TGS-REQ que desencadenan una referencia cruzada en un servicio principal basado en host."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "65BCD38A-33AD-4FD7-AF5B-8470B24C4139"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "E11F9209-799A-428B-9513-DBD0F19C7BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "1DA40FAA-B858-4282-8438-247E99FBB002"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2013-12/msg00026.html", "source": "cve@mitre.org"}, {"url": "http://web.mit.edu/kerberos/krb5-1.11/README-1.11.4.txt", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1030743", "source": "cve@mitre.org"}, {"url": "https://github.com/krb5/krb5/commit/4c023ba43c16396f0d199e2df1cfa59b88b62acc", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/4c023ba43c16396f0d199e2df1cfa59b88b62acc"}}