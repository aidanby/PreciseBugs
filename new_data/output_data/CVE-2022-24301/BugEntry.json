{"buggy_code": ["/*\nMinetest\nCopyright (C) 2015 nerzhul, Loic Blot <loic.blot@unix-experience.fr>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 2.1 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"chatmessage.h\"\n#include \"server.h\"\n#include \"log.h\"\n#include \"emerge.h\"\n#include \"mapblock.h\"\n#include \"modchannels.h\"\n#include \"nodedef.h\"\n#include \"remoteplayer.h\"\n#include \"rollback_interface.h\"\n#include \"scripting_server.h\"\n#include \"settings.h\"\n#include \"tool.h\"\n#include \"version.h\"\n#include \"network/connection.h\"\n#include \"network/networkprotocol.h\"\n#include \"network/serveropcodes.h\"\n#include \"server/player_sao.h\"\n#include \"server/serverinventorymgr.h\"\n#include \"util/auth.h\"\n#include \"util/base64.h\"\n#include \"util/pointedthing.h\"\n#include \"util/serialize.h\"\n#include \"util/srp.h\"\n\nvoid Server::handleCommand_Deprecated(NetworkPacket* pkt)\n{\n\tinfostream << \"Server: \" << toServerCommandTable[pkt->getCommand()].name\n\t\t<< \" not supported anymore\" << std::endl;\n}\n\nvoid Server::handleCommand_Init(NetworkPacket* pkt)\n{\n\n\tif(pkt->getSize() < 1)\n\t\treturn;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Created);\n\n\tstd::string addr_s;\n\ttry {\n\t\tAddress address = getPeerAddress(peer_id);\n\t\taddr_s = address.serializeString();\n\t}\n\tcatch (con::PeerNotFoundException &e) {\n\t\t/*\n\t\t * no peer for this packet found\n\t\t * most common reason is peer timeout, e.g. peer didn't\n\t\t * respond for some time, your server was overloaded or\n\t\t * things like that.\n\t\t */\n\t\tinfostream << \"Server::ProcessData(): Canceling: peer \" << peer_id <<\n\t\t\t\" not found\" << std::endl;\n\t\treturn;\n\t}\n\n\t// If net_proto_version is set, this client has already been handled\n\tif (client->getState() > CS_Created) {\n\t\tverbosestream << \"Server: Ignoring multiple TOSERVER_INITs from \" <<\n\t\t\taddr_s << \" (peer_id=\" << peer_id << \")\" << std::endl;\n\t\treturn;\n\t}\n\n\tverbosestream << \"Server: Got TOSERVER_INIT from \" << addr_s <<\n\t\t\" (peer_id=\" << peer_id << \")\" << std::endl;\n\n\t// Do not allow multiple players in simple singleplayer mode.\n\t// This isn't a perfect way to do it, but will suffice for now\n\tif (m_simple_singleplayer_mode && m_clients.getClientIDs().size() > 1) {\n\t\tinfostream << \"Server: Not allowing another client (\" << addr_s <<\n\t\t\t\") to connect in simple singleplayer mode\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SINGLEPLAYER);\n\t\treturn;\n\t}\n\n\t// First byte after command is maximum supported\n\t// serialization version\n\tu8 client_max;\n\tu16 supp_compr_modes;\n\tu16 min_net_proto_version = 0;\n\tu16 max_net_proto_version;\n\tstd::string playerName;\n\n\t*pkt >> client_max >> supp_compr_modes >> min_net_proto_version\n\t\t\t>> max_net_proto_version >> playerName;\n\n\tu8 our_max = SER_FMT_VER_HIGHEST_READ;\n\t// Use the highest version supported by both\n\tu8 depl_serial_v = std::min(client_max, our_max);\n\t// If it's lower than the lowest supported, give up.\n\tif (depl_serial_v < SER_FMT_VER_LOWEST_READ)\n\t\tdepl_serial_v = SER_FMT_VER_INVALID;\n\n\tif (depl_serial_v == SER_FMT_VER_INVALID) {\n\t\tactionstream << \"Server: A mismatched client tried to connect from \" <<\n\t\t\taddr_s << \" ser_fmt_max=\" << (int)client_max << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_VERSION);\n\t\treturn;\n\t}\n\n\tclient->setPendingSerializationVersion(depl_serial_v);\n\n\t/*\n\t\tRead and check network protocol version\n\t*/\n\n\tu16 net_proto_version = 0;\n\n\t// Figure out a working version if it is possible at all\n\tif (max_net_proto_version >= SERVER_PROTOCOL_VERSION_MIN ||\n\t\t\tmin_net_proto_version <= SERVER_PROTOCOL_VERSION_MAX) {\n\t\t// If maximum is larger than our maximum, go with our maximum\n\t\tif (max_net_proto_version > SERVER_PROTOCOL_VERSION_MAX)\n\t\t\tnet_proto_version = SERVER_PROTOCOL_VERSION_MAX;\n\t\t// Else go with client's maximum\n\t\telse\n\t\t\tnet_proto_version = max_net_proto_version;\n\t}\n\n\tverbosestream << \"Server: \" << addr_s << \": Protocol version: min: \"\n\t\t\t<< min_net_proto_version << \", max: \" << max_net_proto_version\n\t\t\t<< \", chosen: \" << net_proto_version << std::endl;\n\n\tclient->net_proto_version = net_proto_version;\n\n\tif ((g_settings->getBool(\"strict_protocol_version_checking\") &&\n\t\t\tnet_proto_version != LATEST_PROTOCOL_VERSION) ||\n\t\t\tnet_proto_version < SERVER_PROTOCOL_VERSION_MIN ||\n\t\t\tnet_proto_version > SERVER_PROTOCOL_VERSION_MAX) {\n\t\tactionstream << \"Server: A mismatched client tried to connect from \" <<\n\t\t\taddr_s << \" proto_max=\" << (int)max_net_proto_version << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_VERSION);\n\t\treturn;\n\t}\n\n\t/*\n\t\tValidate player name\n\t*/\n\tconst char* playername = playerName.c_str();\n\n\tsize_t pns = playerName.size();\n\tif (pns == 0 || pns > PLAYERNAME_SIZE) {\n\t\tactionstream << \"Server: Player with \" <<\n\t\t\t((pns > PLAYERNAME_SIZE) ? \"a too long\" : \"an empty\") <<\n\t\t\t\" name tried to connect from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_NAME);\n\t\treturn;\n\t}\n\n\tif (!string_allowed(playerName, PLAYERNAME_ALLOWED_CHARS)) {\n\t\tactionstream << \"Server: Player with an invalid name tried to connect \"\n\t\t\t\"from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_CHARS_IN_NAME);\n\t\treturn;\n\t}\n\n\tm_clients.setPlayerName(peer_id, playername);\n\t//TODO (later) case insensitivity\n\n\tstd::string legacyPlayerNameCasing = playerName;\n\n\tif (!isSingleplayer() && strcasecmp(playername, \"singleplayer\") == 0) {\n\t\tactionstream << \"Server: Player with the name \\\"singleplayer\\\" tried \"\n\t\t\t\"to connect from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_NAME);\n\t\treturn;\n\t}\n\n\t{\n\t\tstd::string reason;\n\t\tif (m_script->on_prejoinplayer(playername, addr_s, &reason)) {\n\t\t\tactionstream << \"Server: Player with the name \\\"\" << playerName <<\n\t\t\t\t\"\\\" tried to connect from \" << addr_s <<\n\t\t\t\t\" but it was disallowed for the following reason: \" << reason <<\n\t\t\t\tstd::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_CUSTOM_STRING, reason);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinfostream << \"Server: New connection: \\\"\" << playerName << \"\\\" from \" <<\n\t\taddr_s << \" (peer_id=\" << peer_id << \")\" << std::endl;\n\n\t// Enforce user limit.\n\t// Don't enforce for users that have some admin right or mod permits it.\n\tif (m_clients.isUserLimitReached() &&\n\t\t\tplayername != g_settings->get(\"name\") &&\n\t\t\t!m_script->can_bypass_userlimit(playername, addr_s)) {\n\t\tactionstream << \"Server: \" << playername << \" tried to join from \" <<\n\t\t\taddr_s << \", but there are already max_users=\" <<\n\t\t\tg_settings->getU16(\"max_users\") << \" players.\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_TOO_MANY_USERS);\n\t\treturn;\n\t}\n\n\t/*\n\t\tCompose auth methods for answer\n\t*/\n\tstd::string encpwd; // encrypted Password field for the user\n\tbool has_auth = m_script->getAuth(playername, &encpwd, NULL);\n\tu32 auth_mechs = 0;\n\n\tclient->chosen_mech = AUTH_MECHANISM_NONE;\n\n\tif (has_auth) {\n\t\tstd::vector<std::string> pwd_components = str_split(encpwd, '#');\n\t\tif (pwd_components.size() == 4) {\n\t\t\tif (pwd_components[1] == \"1\") { // 1 means srp\n\t\t\t\tauth_mechs |= AUTH_MECHANISM_SRP;\n\t\t\t\tclient->enc_pwd = encpwd;\n\t\t\t} else {\n\t\t\t\tactionstream << \"User \" << playername << \" tried to log in, \"\n\t\t\t\t\t\"but password field was invalid (unknown mechcode).\" <<\n\t\t\t\t\tstd::endl;\n\t\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (base64_is_valid(encpwd)) {\n\t\t\tauth_mechs |= AUTH_MECHANISM_LEGACY_PASSWORD;\n\t\t\tclient->enc_pwd = encpwd;\n\t\t} else {\n\t\t\tactionstream << \"User \" << playername << \" tried to log in, but \"\n\t\t\t\t\"password field was invalid (invalid base64).\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tstd::string default_password = g_settings->get(\"default_password\");\n\t\tif (default_password.length() == 0) {\n\t\t\tauth_mechs |= AUTH_MECHANISM_FIRST_SRP;\n\t\t} else {\n\t\t\t// Take care of default passwords.\n\t\t\tclient->enc_pwd = get_encoded_srp_verifier(playerName, default_password);\n\t\t\tauth_mechs |= AUTH_MECHANISM_SRP;\n\t\t\t// Allocate player in db, but only on successful login.\n\t\t\tclient->create_player_on_auth_success = true;\n\t\t}\n\t}\n\n\t/*\n\t\tAnswer with a TOCLIENT_HELLO\n\t*/\n\n\tverbosestream << \"Sending TOCLIENT_HELLO with auth method field: \"\n\t\t<< auth_mechs << std::endl;\n\n\tNetworkPacket resp_pkt(TOCLIENT_HELLO,\n\t\t1 + 4 + legacyPlayerNameCasing.size(), peer_id);\n\n\tu16 depl_compress_mode = NETPROTO_COMPRESSION_NONE;\n\tresp_pkt << depl_serial_v << depl_compress_mode << net_proto_version\n\t\t<< auth_mechs << legacyPlayerNameCasing;\n\n\tSend(&resp_pkt);\n\n\tclient->allowed_auth_mechs = auth_mechs;\n\tclient->setDeployedCompressionMode(depl_compress_mode);\n\n\tm_clients.event(peer_id, CSE_Hello);\n}\n\nvoid Server::handleCommand_Init2(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tverbosestream << \"Server: Got TOSERVER_INIT2 from \" << peer_id << std::endl;\n\n\tm_clients.event(peer_id, CSE_GotInit2);\n\tu16 protocol_version = m_clients.getProtocolVersion(peer_id);\n\n\tstd::string lang;\n\tif (pkt->getSize() > 0)\n\t\t*pkt >> lang;\n\n\t/*\n\t\tSend some initialization data\n\t*/\n\n\tinfostream << \"Server: Sending content to \" << getPlayerName(peer_id) <<\n\t\tstd::endl;\n\n\t// Send item definitions\n\tSendItemDef(peer_id, m_itemdef, protocol_version);\n\n\t// Send node definitions\n\tSendNodeDef(peer_id, m_nodedef, protocol_version);\n\n\tm_clients.event(peer_id, CSE_SetDefinitionsSent);\n\n\t// Send media announcement\n\tsendMediaAnnouncement(peer_id, lang);\n\n\tRemoteClient *client = getClient(peer_id, CS_InitDone);\n\n\t// Keep client language for server translations\n\tclient->setLangCode(lang);\n\n\t// Send active objects\n\t{\n\t\tPlayerSAO *sao = getPlayerSAO(peer_id);\n\t\tif (client && sao)\n\t\t\tSendActiveObjectRemoveAdd(client, sao);\n\t}\n\n\t// Send detached inventories\n\tsendDetachedInventories(peer_id, false);\n\n\t// Send player movement settings\n\tSendMovement(peer_id);\n\n\t// Send time of day\n\tu16 time = m_env->getTimeOfDay();\n\tfloat time_speed = g_settings->getFloat(\"time_speed\");\n\tSendTimeOfDay(peer_id, time, time_speed);\n\n\tSendCSMRestrictionFlags(peer_id);\n\n\t// Warnings about protocol version can be issued here\n\tif (client->net_proto_version < LATEST_PROTOCOL_VERSION) {\n\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\tL\"# Server: WARNING: YOUR CLIENT'S VERSION MAY NOT BE FULLY COMPATIBLE \"\n\t\t\tL\"WITH THIS SERVER!\"));\n\t}\n}\n\nvoid Server::handleCommand_RequestMedia(NetworkPacket* pkt)\n{\n\tstd::vector<std::string> tosend;\n\tu16 numfiles;\n\n\t*pkt >> numfiles;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tinfostream << \"Sending \" << numfiles << \" files to \" <<\n\t\tgetPlayerName(peer_id) << std::endl;\n\tverbosestream << \"TOSERVER_REQUEST_MEDIA: \" << std::endl;\n\n\tfor (u16 i = 0; i < numfiles; i++) {\n\t\tstd::string name;\n\n\t\t*pkt >> name;\n\n\t\ttosend.push_back(name);\n\t\tverbosestream << \"TOSERVER_REQUEST_MEDIA: requested file \"\n\t\t\t\t<< name << std::endl;\n\t}\n\n\tsendRequestedMedia(peer_id, tosend);\n}\n\nvoid Server::handleCommand_ClientReady(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\n\tPlayerSAO* playersao = StageTwoClientInit(peer_id);\n\n\tif (playersao == NULL) {\n\t\terrorstream << \"TOSERVER_CLIENT_READY stage 2 client init failed \"\n\t\t\t\"peer_id=\" << peer_id << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\n\tif (pkt->getSize() < 8) {\n\t\terrorstream << \"TOSERVER_CLIENT_READY client sent inconsistent data, \"\n\t\t\t\"disconnecting peer_id: \" << peer_id << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tu8 major_ver, minor_ver, patch_ver, reserved;\n\tstd::string full_ver;\n\t*pkt >> major_ver >> minor_ver >> patch_ver >> reserved >> full_ver;\n\n\tm_clients.setClientVersion(peer_id, major_ver, minor_ver, patch_ver,\n\t\tfull_ver);\n\n\tif (pkt->getRemainingBytes() >= 2)\n\t\t*pkt >> playersao->getPlayer()->formspec_version;\n\n\tconst std::vector<std::string> &players = m_clients.getPlayerNames();\n\tNetworkPacket list_pkt(TOCLIENT_UPDATE_PLAYER_LIST, 0, peer_id);\n\tlist_pkt << (u8) PLAYER_LIST_INIT << (u16) players.size();\n\tfor (const std::string &player: players) {\n\t\tlist_pkt <<  player;\n\t}\n\tm_clients.send(peer_id, 0, &list_pkt, true);\n\n\tNetworkPacket notice_pkt(TOCLIENT_UPDATE_PLAYER_LIST, 0, PEER_ID_INEXISTENT);\n\t// (u16) 1 + std::string represents a pseudo vector serialization representation\n\tnotice_pkt << (u8) PLAYER_LIST_ADD << (u16) 1 << std::string(playersao->getPlayer()->getName());\n\tm_clients.sendToAll(&notice_pkt);\n\tm_clients.event(peer_id, CSE_SetClientReady);\n\n\ts64 last_login;\n\tm_script->getAuth(playersao->getPlayer()->getName(), nullptr, nullptr, &last_login);\n\tm_script->on_joinplayer(playersao, last_login);\n\n\t// Send shutdown timer if shutdown has been scheduled\n\tif (m_shutdown_state.isTimerRunning()) {\n\t\tSendChatMessage(peer_id, m_shutdown_state.getShutdownTimerMessage());\n\t}\n}\n\nvoid Server::handleCommand_GotBlocks(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 1)\n\t\treturn;\n\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 count\n\t\t[3] v3s16 pos_0\n\t\t[3+6] v3s16 pos_1\n\t\t...\n\t*/\n\n\tu8 count;\n\t*pkt >> count;\n\n\tRemoteClient *client = getClient(pkt->getPeerId());\n\n\tif ((s16)pkt->getSize() < 1 + (int)count * 6) {\n\t\tthrow con::InvalidIncomingDataException\n\t\t\t\t(\"GOTBLOCKS length is too short\");\n\t}\n\n\tfor (u16 i = 0; i < count; i++) {\n\t\tv3s16 p;\n\t\t*pkt >> p;\n\t\tclient->GotBlock(p);\n\t}\n}\n\nvoid Server::process_PlayerPos(RemotePlayer *player, PlayerSAO *playersao,\n\tNetworkPacket *pkt)\n{\n\tif (pkt->getRemainingBytes() < 12 + 12 + 4 + 4 + 4 + 1 + 1)\n\t\treturn;\n\n\tv3s32 ps, ss;\n\ts32 f32pitch, f32yaw;\n\tu8 f32fov;\n\n\t*pkt >> ps;\n\t*pkt >> ss;\n\t*pkt >> f32pitch;\n\t*pkt >> f32yaw;\n\n\tf32 pitch = (f32)f32pitch / 100.0f;\n\tf32 yaw = (f32)f32yaw / 100.0f;\n\tu32 keyPressed = 0;\n\n\t// default behavior (in case an old client doesn't send these)\n\tf32 fov = 0;\n\tu8 wanted_range = 0;\n\n\t*pkt >> keyPressed;\n\t*pkt >> f32fov;\n\tfov = (f32)f32fov / 80.0f;\n\t*pkt >> wanted_range;\n\n\tv3f position((f32)ps.X / 100.0f, (f32)ps.Y / 100.0f, (f32)ps.Z / 100.0f);\n\tv3f speed((f32)ss.X / 100.0f, (f32)ss.Y / 100.0f, (f32)ss.Z / 100.0f);\n\n\tpitch = modulo360f(pitch);\n\tyaw = wrapDegrees_0_360(yaw);\n\n\tplayersao->setBasePosition(position);\n\tplayer->setSpeed(speed);\n\tplayersao->setLookPitch(pitch);\n\tplayersao->setPlayerYaw(yaw);\n\tplayersao->setFov(fov);\n\tplayersao->setWantedRange(wanted_range);\n\n\tplayer->keyPressed = keyPressed;\n\tplayer->control.up    = (keyPressed & (0x1 << 0));\n\tplayer->control.down  = (keyPressed & (0x1 << 1));\n\tplayer->control.left  = (keyPressed & (0x1 << 2));\n\tplayer->control.right = (keyPressed & (0x1 << 3));\n\tplayer->control.jump  = (keyPressed & (0x1 << 4));\n\tplayer->control.aux1  = (keyPressed & (0x1 << 5));\n\tplayer->control.sneak = (keyPressed & (0x1 << 6));\n\tplayer->control.dig   = (keyPressed & (0x1 << 7));\n\tplayer->control.place = (keyPressed & (0x1 << 8));\n\tplayer->control.zoom  = (keyPressed & (0x1 << 9));\n\n\tif (playersao->checkMovementCheat()) {\n\t\t// Call callbacks\n\t\tm_script->on_cheat(playersao, \"moved_too_fast\");\n\t\tSendMovePlayer(pkt->getPeerId());\n\t}\n}\n\nvoid Server::handleCommand_PlayerPos(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// If player is dead we don't care of this packet\n\tif (playersao->isDead()) {\n\t\tverbosestream << \"TOSERVER_PLAYERPOS: \" << player->getName()\n\t\t\t\t<< \" is dead. Ignoring packet\";\n\t\treturn;\n\t}\n\n\tprocess_PlayerPos(player, playersao, pkt);\n}\n\nvoid Server::handleCommand_DeletedBlocks(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 1)\n\t\treturn;\n\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 count\n\t\t[3] v3s16 pos_0\n\t\t[3+6] v3s16 pos_1\n\t\t...\n\t*/\n\n\tu8 count;\n\t*pkt >> count;\n\n\tRemoteClient *client = getClient(pkt->getPeerId());\n\n\tif ((s16)pkt->getSize() < 1 + (int)count * 6) {\n\t\tthrow con::InvalidIncomingDataException\n\t\t\t\t(\"DELETEDBLOCKS length is too short\");\n\t}\n\n\tfor (u16 i = 0; i < count; i++) {\n\t\tv3s16 p;\n\t\t*pkt >> p;\n\t\tclient->SetBlockNotSent(p);\n\t}\n}\n\nvoid Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}\n\nvoid Server::handleCommand_ChatMessage(NetworkPacket* pkt)\n{\n\t/*\n\t\tu16 command\n\t\tu16 length\n\t\twstring message\n\t*/\n\tu16 len;\n\t*pkt >> len;\n\n\tstd::wstring message;\n\tfor (u16 i = 0; i < len; i++) {\n\t\tu16 tmp_wchar;\n\t\t*pkt >> tmp_wchar;\n\n\t\tmessage += (wchar_t)tmp_wchar;\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Get player name of this client\n\tstd::string name = player->getName();\n\tstd::wstring wname = narrow_to_wide(name);\n\n\tstd::wstring answer_to_sender = handleChat(name, wname, message, true, player);\n\tif (!answer_to_sender.empty()) {\n\t\t// Send the answer to sender\n\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_NORMAL,\n\t\t\tanswer_to_sender, wname));\n\t}\n}\n\nvoid Server::handleCommand_Damage(NetworkPacket* pkt)\n{\n\tu16 damage;\n\n\t*pkt >> damage;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (!playersao->isImmortal()) {\n\t\tif (playersao->isDead()) {\n\t\t\tverbosestream << \"Server::ProcessData(): Info: \"\n\t\t\t\t\"Ignoring damage as player \" << player->getName()\n\t\t\t\t<< \" is already dead.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t\tactionstream << player->getName() << \" damaged by \"\n\t\t\t\t<< (int)damage << \" hp at \" << PP(playersao->getBasePosition() / BS)\n\t\t\t\t<< std::endl;\n\n\t\tPlayerHPChangeReason reason(PlayerHPChangeReason::FALL);\n\t\tplayersao->setHP((s32)playersao->getHP() - (s32)damage, reason);\n\t\tSendPlayerHPOrDie(playersao, reason);\n\t}\n}\n\nvoid Server::handleCommand_PlayerItem(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 2)\n\t\treturn;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tu16 item;\n\n\t*pkt >> item;\n\n\tplayersao->getPlayer()->setWieldIndex(item);\n}\n\nvoid Server::handleCommand_Respawn(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tassert(playersao);\n\n\tif (!playersao->isDead())\n\t\treturn;\n\n\tRespawnPlayer(peer_id);\n\n\tactionstream << player->getName() << \" respawns at \"\n\t\t\t<< PP(playersao->getBasePosition() / BS) << std::endl;\n\n\t// ActiveObject is added to environment in AsyncRunStep after\n\t// the previous addition has been successfully removed\n}\n\nbool Server::checkInteractDistance(RemotePlayer *player, const f32 d, const std::string &what)\n{\n\tItemStack selected_item, hand_item;\n\tplayer->getWieldedItem(&selected_item, &hand_item);\n\tf32 max_d = BS * getToolRange(selected_item.getDefinition(m_itemdef),\n\t\t\thand_item.getDefinition(m_itemdef));\n\n\t// Cube diagonal * 1.5 for maximal supported node extents:\n\t// sqrt(3) * 1.5 \u2245 2.6\n\tif (d > max_d + 2.6f * BS) {\n\t\tactionstream << \"Player \" << player->getName()\n\t\t\t\t<< \" tried to access \" << what\n\t\t\t\t<< \" from too far: \"\n\t\t\t\t<< \"d=\" << d << \", max_d=\" << max_d\n\t\t\t\t<< \"; ignoring.\" << std::endl;\n\t\t// Call callbacks\n\t\tm_script->on_cheat(player->getPlayerSAO(), \"interacted_too_far\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid Server::handleCommand_Interact(NetworkPacket *pkt)\n{\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 action\n\t\t[3] u16 item\n\t\t[5] u32 length of the next item (plen)\n\t\t[9] serialized PointedThing\n\t\t[9 + plen] player position information\n\t*/\n\n\tInteractAction action;\n\tu16 item_i;\n\n\t*pkt >> (u8 &)action;\n\t*pkt >> item_i;\n\n\tstd::istringstream tmp_is(pkt->readLongString(), std::ios::binary);\n\tPointedThing pointed;\n\tpointed.deSerialize(tmp_is);\n\n\tverbosestream << \"TOSERVER_INTERACT: action=\" << (int)action << \", item=\"\n\t\t\t<< item_i << \", pointed=\" << pointed.dump() << std::endl;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (playersao->isDead()) {\n\t\tactionstream << \"Server: \" << player->getName()\n\t\t\t\t<< \" tried to interact while dead; ignoring.\" << std::endl;\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\t// Re-send block to revert change on client-side\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\tv3s16 blockpos = getNodeBlockPos(pointed.node_undersurface);\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\t// Call callbacks\n\t\tm_script->on_cheat(playersao, \"interacted_while_dead\");\n\t\treturn;\n\t}\n\n\tprocess_PlayerPos(player, playersao, pkt);\n\n\tv3f player_pos = playersao->getLastGoodPosition();\n\n\t// Update wielded item\n\tplayersao->getPlayer()->setWieldIndex(item_i);\n\n\t// Get pointed to node (undefined if not POINTEDTYPE_NODE)\n\tv3s16 p_under = pointed.node_undersurface;\n\tv3s16 p_above = pointed.node_abovesurface;\n\n\t// Get pointed to object (NULL if not POINTEDTYPE_OBJECT)\n\tServerActiveObject *pointed_object = NULL;\n\tif (pointed.type == POINTEDTHING_OBJECT) {\n\t\tpointed_object = m_env->getActiveObject(pointed.object_id);\n\t\tif (pointed_object == NULL) {\n\t\t\tverbosestream << \"TOSERVER_INTERACT: \"\n\t\t\t\t\"pointed object is NULL\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tv3f pointed_pos_under = player_pos;\n\tv3f pointed_pos_above = player_pos;\n\tif (pointed.type == POINTEDTHING_NODE) {\n\t\tpointed_pos_under = intToFloat(p_under, BS);\n\t\tpointed_pos_above = intToFloat(p_above, BS);\n\t}\n\telse if (pointed.type == POINTEDTHING_OBJECT) {\n\t\tpointed_pos_under = pointed_object->getBasePosition();\n\t\tpointed_pos_above = pointed_pos_under;\n\t}\n\n\t/*\n\t\tMake sure the player is allowed to do it\n\t*/\n\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\tactionstream << player->getName() << \" attempted to interact with \" <<\n\t\t\t\tpointed.dump() << \" without 'interact' privilege\" << std::endl;\n\n\t\t// Re-send block to revert change on client-side\n\t\tRemoteClient *client = getClient(peer_id);\n\t\t// Digging completed -> under\n\t\tif (action == INTERACT_DIGGING_COMPLETED) {\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\t// Placement -> above\n\t\telse if (action == INTERACT_PLACE) {\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_above, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t\tCheck that target is reasonably close\n\t\t(only when digging or placing things)\n\t*/\n\tstatic thread_local const bool enable_anticheat =\n\t\t\t!g_settings->getBool(\"disable_anticheat\");\n\n\tif ((action == INTERACT_START_DIGGING || action == INTERACT_DIGGING_COMPLETED ||\n\t\t\taction == INTERACT_PLACE || action == INTERACT_USE) &&\n\t\t\tenable_anticheat && !isSingleplayer()) {\n\t\tfloat d = playersao->getEyePosition().getDistanceFrom(pointed_pos_under);\n\n\t\tif (!checkInteractDistance(player, d, pointed.dump())) {\n\t\t\t// Re-send block to revert change on client-side\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t\tIf something goes wrong, this player is to blame\n\t*/\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\t0: start digging or punch object\n\t*/\n\tif (action == INTERACT_START_DIGGING) {\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\tMapNode n(CONTENT_IGNORE);\n\t\t\tbool pos_ok;\n\n\t\t\tn = m_env->getMap().getNode(p_under, &pos_ok);\n\t\t\tif (!pos_ok) {\n\t\t\t\tinfostream << \"Server: Not punching: Node not found. \"\n\t\t\t\t\t\"Adding block to emerge queue.\" << std::endl;\n\t\t\t\tm_emerge->enqueueBlockEmerge(peer_id, getNodeBlockPos(p_above),\n\t\t\t\t\tfalse);\n\t\t\t}\n\n\t\t\tif (n.getContent() != CONTENT_IGNORE)\n\t\t\t\tm_script->node_on_punch(p_under, n, playersao, pointed);\n\n\t\t\t// Cheat prevention\n\t\t\tplayersao->noCheatDigStart(p_under);\n\t\t}\n\t\telse if (pointed.type == POINTEDTHING_OBJECT) {\n\t\t\t// Skip if object can't be interacted with anymore\n\t\t\tif (pointed_object->isGone())\n\t\t\t\treturn;\n\n\t\t\tItemStack selected_item, hand_item;\n\t\t\tItemStack tool_item = playersao->getWieldedItem(&selected_item, &hand_item);\n\t\t\tToolCapabilities toolcap =\n\t\t\t\t\ttool_item.getToolCapabilities(m_itemdef);\n\t\t\tv3f dir = (pointed_object->getBasePosition() -\n\t\t\t\t\t(playersao->getBasePosition() + playersao->getEyeOffset())\n\t\t\t\t\t\t).normalize();\n\t\t\tfloat time_from_last_punch =\n\t\t\t\tplayersao->resetTimeFromLastPunch();\n\n\t\t\tu16 src_original_hp = pointed_object->getHP();\n\t\t\tu16 dst_origin_hp = playersao->getHP();\n\n\t\t\tu16 wear = pointed_object->punch(dir, &toolcap, playersao,\n\t\t\t\t\ttime_from_last_punch);\n\n\t\t\t// Callback may have changed item, so get it again\n\t\t\tplayersao->getWieldedItem(&selected_item);\n\t\t\tbool changed = selected_item.addWear(wear, m_itemdef);\n\t\t\tif (changed)\n\t\t\t\tplayersao->setWieldedItem(selected_item);\n\n\t\t\t// If the object is a player and its HP changed\n\t\t\tif (src_original_hp != pointed_object->getHP() &&\n\t\t\t\t\tpointed_object->getType() == ACTIVEOBJECT_TYPE_PLAYER) {\n\t\t\t\tSendPlayerHPOrDie((PlayerSAO *)pointed_object,\n\t\t\t\t\t\tPlayerHPChangeReason(PlayerHPChangeReason::PLAYER_PUNCH, playersao));\n\t\t\t}\n\n\t\t\t// If the puncher is a player and its HP changed\n\t\t\tif (dst_origin_hp != playersao->getHP())\n\t\t\t\tSendPlayerHPOrDie(playersao,\n\t\t\t\t\t\tPlayerHPChangeReason(PlayerHPChangeReason::PLAYER_PUNCH, pointed_object));\n\t\t}\n\n\t} // action == INTERACT_START_DIGGING\n\n\t/*\n\t\t1: stop digging\n\t*/\n\telse if (action == INTERACT_STOP_DIGGING) {\n\t} // action == INTERACT_STOP_DIGGING\n\n\t/*\n\t\t2: Digging completed\n\t*/\n\telse if (action == INTERACT_DIGGING_COMPLETED) {\n\t\t// Only digging of nodes\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\tbool pos_ok;\n\t\t\tMapNode n = m_env->getMap().getNode(p_under, &pos_ok);\n\t\t\tif (!pos_ok) {\n\t\t\t\tinfostream << \"Server: Not finishing digging: Node not found. \"\n\t\t\t\t\t\"Adding block to emerge queue.\" << std::endl;\n\t\t\t\tm_emerge->enqueueBlockEmerge(peer_id, getNodeBlockPos(p_above),\n\t\t\t\t\tfalse);\n\t\t\t}\n\n\t\t\t/* Cheat prevention */\n\t\t\tbool is_valid_dig = true;\n\t\t\tif (enable_anticheat && !isSingleplayer()) {\n\t\t\t\tv3s16 nocheat_p = playersao->getNoCheatDigPos();\n\t\t\t\tfloat nocheat_t = playersao->getNoCheatDigTime();\n\t\t\t\tplayersao->noCheatDigEnd();\n\t\t\t\t// If player didn't start digging this, ignore dig\n\t\t\t\tif (nocheat_p != p_under) {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" started digging \"\n\t\t\t\t\t\t\t<< PP(nocheat_p) << \" and completed digging \"\n\t\t\t\t\t\t\t<< PP(p_under) << \"; not digging.\" << std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"finished_unknown_dig\");\n\t\t\t\t}\n\n\t\t\t\t// Get player's wielded item\n\t\t\t\t// See also: Game::handleDigging\n\t\t\t\tItemStack selected_item, hand_item;\n\t\t\t\tplayersao->getPlayer()->getWieldedItem(&selected_item, &hand_item);\n\n\t\t\t\t// Get diggability and expected digging time\n\t\t\t\tDigParams params = getDigParams(m_nodedef->get(n).groups,\n\t\t\t\t\t\t&selected_item.getToolCapabilities(m_itemdef));\n\t\t\t\t// If can't dig, try hand\n\t\t\t\tif (!params.diggable) {\n\t\t\t\t\tparams = getDigParams(m_nodedef->get(n).groups,\n\t\t\t\t\t\t&hand_item.getToolCapabilities(m_itemdef));\n\t\t\t\t}\n\t\t\t\t// If can't dig, ignore dig\n\t\t\t\tif (!params.diggable) {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" completed digging \" << PP(p_under)\n\t\t\t\t\t\t\t<< \", which is not diggable with tool; not digging.\"\n\t\t\t\t\t\t\t<< std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"dug_unbreakable\");\n\t\t\t\t}\n\t\t\t\t// Check digging time\n\t\t\t\t// If already invalidated, we don't have to\n\t\t\t\tif (!is_valid_dig) {\n\t\t\t\t\t// Well not our problem then\n\t\t\t\t}\n\t\t\t\t// Clean and long dig\n\t\t\t\telse if (params.time > 2.0 && nocheat_t * 1.2 > params.time) {\n\t\t\t\t\t// All is good, but grab time from pool; don't care if\n\t\t\t\t\t// it's actually available\n\t\t\t\t\tplayersao->getDigPool().grab(params.time);\n\t\t\t\t}\n\t\t\t\t// Short or laggy dig\n\t\t\t\t// Try getting the time from pool\n\t\t\t\telse if (playersao->getDigPool().grab(params.time)) {\n\t\t\t\t\t// All is good\n\t\t\t\t}\n\t\t\t\t// Dig not possible\n\t\t\t\telse {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" completed digging \" << PP(p_under)\n\t\t\t\t\t\t\t<< \"too fast; not digging.\" << std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"dug_too_fast\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Actually dig node */\n\n\t\t\tif (is_valid_dig && n.getContent() != CONTENT_IGNORE)\n\t\t\t\tm_script->node_on_dig(p_under, n, playersao);\n\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\t// Send unusual result (that is, node not being removed)\n\t\t\tif (m_env->getMap().getNode(p_under).getContent() != CONTENT_AIR) {\n\t\t\t\t// Re-send block to revert change on client-side\n\t\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclient->ResendBlockIfOnWire(blockpos);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_DIGGING_COMPLETED\n\n\t/*\n\t\t3: place block or right-click object\n\t*/\n\telse if (action == INTERACT_PLACE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\t// Reset build time counter\n\t\tif (pointed.type == POINTEDTHING_NODE &&\n\t\t\t\tselected_item.getDefinition(m_itemdef).type == ITEM_NODE)\n\t\t\tgetClient(peer_id)->m_time_from_building = 0.0;\n\n\t\tif (pointed.type == POINTEDTHING_OBJECT) {\n\t\t\t// Right click object\n\n\t\t\t// Skip if object can't be interacted with anymore\n\t\t\tif (pointed_object->isGone())\n\t\t\t\treturn;\n\n\t\t\tactionstream << player->getName() << \" right-clicks object \"\n\t\t\t\t\t<< pointed.object_id << \": \"\n\t\t\t\t\t<< pointed_object->getDescription() << std::endl;\n\n\t\t\t// Do stuff\n\t\t\tif (m_script->item_OnSecondaryUse(\n\t\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\t\tSendInventory(playersao, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpointed_object->rightClick(playersao);\n\t\t} else if (m_script->item_OnPlace(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t// Placement was handled in lua\n\n\t\t\t// Apply returned ItemStack\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\n\t\t// If item has node placement prediction, always send the\n\t\t// blocks to make sure the client knows what exactly happened\n\t\tRemoteClient *client = getClient(peer_id);\n\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_above, BS));\n\t\tv3s16 blockpos2 = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\tif (!selected_item.getDefinition(m_itemdef).node_placement_prediction.empty()) {\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\tif (blockpos2 != blockpos) {\n\t\t\t\tclient->SetBlockNotSent(blockpos2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tclient->ResendBlockIfOnWire(blockpos);\n\t\t\tif (blockpos2 != blockpos) {\n\t\t\t\tclient->ResendBlockIfOnWire(blockpos2);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_PLACE\n\n\t/*\n\t\t4: use\n\t*/\n\telse if (action == INTERACT_USE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\tactionstream << player->getName() << \" uses \" << selected_item.name\n\t\t\t\t<< \", pointing at \" << pointed.dump() << std::endl;\n\n\t\tif (m_script->item_OnUse(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t// Apply returned ItemStack\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\n\t} // action == INTERACT_USE\n\n\t/*\n\t\t5: rightclick air\n\t*/\n\telse if (action == INTERACT_ACTIVATE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\tactionstream << player->getName() << \" activates \"\n\t\t\t\t<< selected_item.name << std::endl;\n\n\t\tpointed.type = POINTEDTHING_NOTHING; // can only ever be NOTHING\n\n\t\tif (m_script->item_OnSecondaryUse(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_ACTIVATE\n\n\n\t/*\n\t\tCatch invalid actions\n\t*/\n\telse {\n\t\twarningstream << \"Server: Invalid action \"\n\t\t\t\t<< action << std::endl;\n\t}\n}\n\nvoid Server::handleCommand_RemovedSounds(NetworkPacket* pkt)\n{\n\tu16 num;\n\t*pkt >> num;\n\tfor (u16 k = 0; k < num; k++) {\n\t\ts32 id;\n\n\t\t*pkt >> id;\n\n\t\tstd::unordered_map<s32, ServerPlayingSound>::iterator i =\n\t\t\tm_playing_sounds.find(id);\n\t\tif (i == m_playing_sounds.end())\n\t\t\tcontinue;\n\n\t\tServerPlayingSound &psound = i->second;\n\t\tpsound.clients.erase(pkt->getPeerId());\n\t\tif (psound.clients.empty())\n\t\t\tm_playing_sounds.erase(i++);\n\t}\n}\n\nvoid Server::handleCommand_NodeMetaFields(NetworkPacket* pkt)\n{\n\tv3s16 p;\n\tstd::string formname;\n\tu16 num;\n\n\t*pkt >> p >> formname >> num;\n\n\tStringMap fields;\n\tfor (u16 k = 0; k < num; k++) {\n\t\tstd::string fieldname;\n\t\t*pkt >> fieldname;\n\t\tfields[fieldname] = pkt->readLongString();\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t// Check the target node for rollback data; leave others unnoticed\n\tRollbackNode rn_old(&m_env->getMap(), p, this);\n\n\tm_script->node_on_receive_fields(p, formname, fields, playersao);\n\n\t// Report rollback data\n\tRollbackNode rn_new(&m_env->getMap(), p, this);\n\tif (rollback() && rn_new != rn_old) {\n\t\tRollbackAction action;\n\t\taction.setSetNode(p, rn_old, rn_new);\n\t\trollback()->reportAction(action);\n\t}\n}\n\nvoid Server::handleCommand_InventoryFields(NetworkPacket* pkt)\n{\n\tstd::string client_formspec_name;\n\tu16 num;\n\n\t*pkt >> client_formspec_name >> num;\n\n\tStringMap fields;\n\tfor (u16 k = 0; k < num; k++) {\n\t\tstd::string fieldname;\n\t\t*pkt >> fieldname;\n\t\tfields[fieldname] = pkt->readLongString();\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (client_formspec_name.empty()) { // pass through inventory submits\n\t\tm_script->on_playerReceiveFields(playersao, client_formspec_name, fields);\n\t\treturn;\n\t}\n\n\t// verify that we displayed the formspec to the user\n\tconst auto peer_state_iterator = m_formspec_state_data.find(peer_id);\n\tif (peer_state_iterator != m_formspec_state_data.end()) {\n\t\tconst std::string &server_formspec_name = peer_state_iterator->second;\n\t\tif (client_formspec_name == server_formspec_name) {\n\t\t\tauto it = fields.find(\"quit\");\n\t\t\tif (it != fields.end() && it->second == \"true\")\n\t\t\t\tm_formspec_state_data.erase(peer_state_iterator);\n\n\t\t\tm_script->on_playerReceiveFields(playersao, client_formspec_name, fields);\n\t\t\treturn;\n\t\t}\n\t\tactionstream << \"'\" << player->getName()\n\t\t\t<< \"' submitted formspec ('\" << client_formspec_name\n\t\t\t<< \"') but the name of the formspec doesn't match the\"\n\t\t\t\" expected name ('\" << server_formspec_name << \"')\";\n\n\t} else {\n\t\tactionstream << \"'\" << player->getName()\n\t\t\t<< \"' submitted formspec ('\" << client_formspec_name\n\t\t\t<< \"') but server hasn't sent formspec to client\";\n\t}\n\tactionstream << \", possible exploitation attempt\" << std::endl;\n}\n\nvoid Server::handleCommand_FirstSrp(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\n\tstd::string playername = client->getName();\n\n\tstd::string salt;\n\tstd::string verification_key;\n\n\tstd::string addr_s = getPeerAddress(peer_id).serializeString();\n\tu8 is_empty;\n\n\t*pkt >> salt >> verification_key >> is_empty;\n\n\tverbosestream << \"Server: Got TOSERVER_FIRST_SRP from \" << addr_s\n\t\t<< \", with is_empty=\" << (is_empty == 1) << std::endl;\n\n\t// Either this packet is sent because the user is new or to change the password\n\tif (cstate == CS_HelloSent) {\n\t\tif (!client->isMechAllowed(AUTH_MECHANISM_FIRST_SRP)) {\n\t\t\tactionstream << \"Server: Client from \" << addr_s\n\t\t\t\t\t<< \" tried to set password without being \"\n\t\t\t\t\t<< \"authenticated, or the username being new.\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!isSingleplayer() &&\n\t\t\t\tg_settings->getBool(\"disallow_empty_password\") &&\n\t\t\t\tis_empty == 1) {\n\t\t\tactionstream << \"Server: \" << playername\n\t\t\t\t\t<< \" supplied empty password from \" << addr_s << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_EMPTY_PASSWORD);\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string initial_ver_key;\n\n\t\tinitial_ver_key = encode_srp_verifier(verification_key, salt);\n\t\tm_script->createAuth(playername, initial_ver_key);\n\t\tm_script->on_authplayer(playername, addr_s, true);\n\n\t\tacceptAuth(peer_id, false);\n\t} else {\n\t\tif (cstate < CS_SudoMode) {\n\t\t\tinfostream << \"Server::ProcessData(): Ignoring TOSERVER_FIRST_SRP from \"\n\t\t\t\t\t<< addr_s << \": \" << \"Client has wrong state \" << cstate << \".\"\n\t\t\t\t\t<< std::endl;\n\t\t\treturn;\n\t\t}\n\t\tm_clients.event(peer_id, CSE_SudoLeave);\n\t\tstd::string pw_db_field = encode_srp_verifier(verification_key, salt);\n\t\tbool success = m_script->setPassword(playername, pw_db_field);\n\t\tif (success) {\n\t\t\tactionstream << playername << \" changes password\" << std::endl;\n\t\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\t\tL\"Password change successful.\"));\n\t\t} else {\n\t\t\tactionstream << playername <<\n\t\t\t\t\" tries to change password but it fails\" << std::endl;\n\t\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\t\tL\"Password change failed or unavailable.\"));\n\t\t}\n\t}\n}\n\nvoid Server::handleCommand_SrpBytesA(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\n\tbool wantSudo = (cstate == CS_Active);\n\n\tif (!((cstate == CS_HelloSent) || (cstate == CS_Active))) {\n\t\tactionstream << \"Server: got SRP _A packet in wrong state \" << cstate <<\n\t\t\t\" from \" << getPeerAddress(peer_id).serializeString() <<\n\t\t\t\". Ignoring.\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (client->chosen_mech != AUTH_MECHANISM_NONE) {\n\t\tactionstream << \"Server: got SRP _A packet, while auth is already \"\n\t\t\t\"going on with mech \" << client->chosen_mech << \" from \" <<\n\t\t\tgetPeerAddress(peer_id).serializeString() <<\n\t\t\t\" (wantSudo=\" << wantSudo << \"). Ignoring.\" << std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tstd::string bytes_A;\n\tu8 based_on;\n\t*pkt >> bytes_A >> based_on;\n\n\tinfostream << \"Server: TOSERVER_SRP_BYTES_A received with \"\n\t\t<< \"based_on=\" << int(based_on) << \" and len_A=\"\n\t\t<< bytes_A.length() << \".\" << std::endl;\n\n\tAuthMechanism chosen = (based_on == 0) ?\n\t\tAUTH_MECHANISM_LEGACY_PASSWORD : AUTH_MECHANISM_SRP;\n\n\tif (wantSudo) {\n\t\tif (!client->isSudoMechAllowed(chosen)) {\n\t\t\tactionstream << \"Server: Player \\\"\" << client->getName() <<\n\t\t\t\t\"\\\" at \" << getPeerAddress(peer_id).serializeString() <<\n\t\t\t\t\" tried to change password using unallowed mech \" << chosen <<\n\t\t\t\t\".\" << std::endl;\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!client->isMechAllowed(chosen)) {\n\t\t\tactionstream << \"Server: Client tried to authenticate from \" <<\n\t\t\t\tgetPeerAddress(peer_id).serializeString() <<\n\t\t\t\t\" using unallowed mech \" << chosen << \".\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclient->chosen_mech = chosen;\n\n\tstd::string salt;\n\tstd::string verifier;\n\n\tif (based_on == 0) {\n\n\t\tgenerate_srp_verifier_and_salt(client->getName(), client->enc_pwd,\n\t\t\t&verifier, &salt);\n\t} else if (!decode_srp_verifier_and_salt(client->enc_pwd, &verifier, &salt)) {\n\t\t// Non-base64 errors should have been catched in the init handler\n\t\tactionstream << \"Server: User \" << client->getName() <<\n\t\t\t\" tried to log in, but srp verifier field was invalid (most likely \"\n\t\t\t\"invalid base64).\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\treturn;\n\t}\n\n\tchar *bytes_B = 0;\n\tsize_t len_B = 0;\n\n\tclient->auth_data = srp_verifier_new(SRP_SHA256, SRP_NG_2048,\n\t\tclient->getName().c_str(),\n\t\t(const unsigned char *) salt.c_str(), salt.size(),\n\t\t(const unsigned char *) verifier.c_str(), verifier.size(),\n\t\t(const unsigned char *) bytes_A.c_str(), bytes_A.size(),\n\t\tNULL, 0,\n\t\t(unsigned char **) &bytes_B, &len_B, NULL, NULL);\n\n\tif (!bytes_B) {\n\t\tactionstream << \"Server: User \" << client->getName()\n\t\t\t<< \" tried to log in, SRP-6a safety check violated in _A handler.\"\n\t\t\t<< std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tNetworkPacket resp_pkt(TOCLIENT_SRP_BYTES_S_B, 0, peer_id);\n\tresp_pkt << salt << std::string(bytes_B, len_B);\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_SrpBytesM(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\tstd::string addr_s = getPeerAddress(pkt->getPeerId()).serializeString();\n\tstd::string playername = client->getName();\n\n\tbool wantSudo = (cstate == CS_Active);\n\n\tverbosestream << \"Server: Received TOCLIENT_SRP_BYTES_M.\" << std::endl;\n\n\tif (!((cstate == CS_HelloSent) || (cstate == CS_Active))) {\n\t\tactionstream << \"Server: got SRP _M packet in wrong state \"\n\t\t\t<< cstate << \" from \" << addr_s\n\t\t\t<< \". Ignoring.\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (client->chosen_mech != AUTH_MECHANISM_SRP &&\n\t\t\tclient->chosen_mech != AUTH_MECHANISM_LEGACY_PASSWORD) {\n\t\tactionstream << \"Server: got SRP _M packet, while auth\"\n\t\t\t<< \"is going on with mech \" << client->chosen_mech << \" from \"\n\t\t\t<< addr_s << \" (wantSudo=\" << wantSudo << \"). Denying.\" << std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tstd::string bytes_M;\n\t*pkt >> bytes_M;\n\n\tif (srp_verifier_get_session_key_length((SRPVerifier *) client->auth_data)\n\t\t\t!= bytes_M.size()) {\n\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t<< \" sent bytes_M with invalid length \" << bytes_M.size() << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tunsigned char *bytes_HAMK = 0;\n\n\tsrp_verifier_verify_session((SRPVerifier *) client->auth_data,\n\t\t(unsigned char *)bytes_M.c_str(), &bytes_HAMK);\n\n\tif (!bytes_HAMK) {\n\t\tif (wantSudo) {\n\t\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t\t<< \" tried to change their password, but supplied wrong\"\n\t\t\t\t<< \" (SRP) password for authentication.\" << std::endl;\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t<< \" supplied wrong password (auth mechanism: SRP).\" << std::endl;\n\t\tm_script->on_authplayer(playername, addr_s, false);\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_PASSWORD);\n\t\treturn;\n\t}\n\n\tif (client->create_player_on_auth_success) {\n\t\tm_script->createAuth(playername, client->enc_pwd);\n\n\t\tstd::string checkpwd; // not used, but needed for passing something\n\t\tif (!m_script->getAuth(playername, &checkpwd, NULL)) {\n\t\t\tactionstream << \"Server: \" << playername <<\n\t\t\t\t\" cannot be authenticated (auth handler does not work?)\" <<\n\t\t\t\tstd::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\treturn;\n\t\t}\n\t\tclient->create_player_on_auth_success = false;\n\t}\n\n\tm_script->on_authplayer(playername, addr_s, true);\n\tacceptAuth(peer_id, wantSudo);\n}\n\n/*\n * Mod channels\n */\n\nvoid Server::handleCommand_ModChannelJoin(NetworkPacket *pkt)\n{\n\tstd::string channel_name;\n\t*pkt >> channel_name;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t1 + 2 + channel_name.size(), peer_id);\n\n\t// Send signal to client to notify join succeed or not\n\tif (g_settings->getBool(\"enable_mod_channels\") &&\n\t\t\tm_modchannel_mgr->joinChannel(channel_name, peer_id)) {\n\t\tresp_pkt << (u8) MODCHANNEL_SIGNAL_JOIN_OK;\n\t\tinfostream << \"Peer \" << peer_id << \" joined channel \" <<\n\t\t\tchannel_name << std::endl;\n\t}\n\telse {\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_JOIN_FAILURE;\n\t\tinfostream << \"Peer \" << peer_id << \" tried to join channel \" <<\n\t\t\tchannel_name << \", but was already registered.\" << std::endl;\n\t}\n\tresp_pkt << channel_name;\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_ModChannelLeave(NetworkPacket *pkt)\n{\n\tstd::string channel_name;\n\t*pkt >> channel_name;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t1 + 2 + channel_name.size(), peer_id);\n\n\t// Send signal to client to notify join succeed or not\n\tif (g_settings->getBool(\"enable_mod_channels\") &&\n\t\t\tm_modchannel_mgr->leaveChannel(channel_name, peer_id)) {\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_LEAVE_OK;\n\t\tinfostream << \"Peer \" << peer_id << \" left channel \" << channel_name <<\n\t\t\tstd::endl;\n\t} else {\n\t\tresp_pkt << (u8) MODCHANNEL_SIGNAL_LEAVE_FAILURE;\n\t\tinfostream << \"Peer \" << peer_id << \" left channel \" << channel_name <<\n\t\t\t\", but was not registered.\" << std::endl;\n\t}\n\tresp_pkt << channel_name;\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_ModChannelMsg(NetworkPacket *pkt)\n{\n\tstd::string channel_name, channel_msg;\n\t*pkt >> channel_name >> channel_msg;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tverbosestream << \"Mod channel message received from peer \" << peer_id <<\n\t\t\" on channel \" << channel_name << \" message: \" << channel_msg <<\n\t\tstd::endl;\n\n\t// If mod channels are not enabled, discard message\n\tif (!g_settings->getBool(\"enable_mod_channels\")) {\n\t\treturn;\n\t}\n\n\t// If channel not registered, signal it and ignore message\n\tif (!m_modchannel_mgr->channelRegistered(channel_name)) {\n\t\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t\t1 + 2 + channel_name.size(), peer_id);\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_CHANNEL_NOT_REGISTERED << channel_name;\n\t\tSend(&resp_pkt);\n\t\treturn;\n\t}\n\n\t// @TODO: filter, rate limit\n\n\tbroadcastModChannelMessage(channel_name, channel_msg, peer_id);\n}\n"], "fixing_code": ["/*\nMinetest\nCopyright (C) 2015 nerzhul, Loic Blot <loic.blot@unix-experience.fr>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation; either version 2.1 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along\nwith this program; if not, write to the Free Software Foundation, Inc.,\n51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"chatmessage.h\"\n#include \"server.h\"\n#include \"log.h\"\n#include \"emerge.h\"\n#include \"mapblock.h\"\n#include \"modchannels.h\"\n#include \"nodedef.h\"\n#include \"remoteplayer.h\"\n#include \"rollback_interface.h\"\n#include \"scripting_server.h\"\n#include \"settings.h\"\n#include \"tool.h\"\n#include \"version.h\"\n#include \"network/connection.h\"\n#include \"network/networkprotocol.h\"\n#include \"network/serveropcodes.h\"\n#include \"server/player_sao.h\"\n#include \"server/serverinventorymgr.h\"\n#include \"util/auth.h\"\n#include \"util/base64.h\"\n#include \"util/pointedthing.h\"\n#include \"util/serialize.h\"\n#include \"util/srp.h\"\n\nvoid Server::handleCommand_Deprecated(NetworkPacket* pkt)\n{\n\tinfostream << \"Server: \" << toServerCommandTable[pkt->getCommand()].name\n\t\t<< \" not supported anymore\" << std::endl;\n}\n\nvoid Server::handleCommand_Init(NetworkPacket* pkt)\n{\n\n\tif(pkt->getSize() < 1)\n\t\treturn;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Created);\n\n\tstd::string addr_s;\n\ttry {\n\t\tAddress address = getPeerAddress(peer_id);\n\t\taddr_s = address.serializeString();\n\t}\n\tcatch (con::PeerNotFoundException &e) {\n\t\t/*\n\t\t * no peer for this packet found\n\t\t * most common reason is peer timeout, e.g. peer didn't\n\t\t * respond for some time, your server was overloaded or\n\t\t * things like that.\n\t\t */\n\t\tinfostream << \"Server::ProcessData(): Canceling: peer \" << peer_id <<\n\t\t\t\" not found\" << std::endl;\n\t\treturn;\n\t}\n\n\t// If net_proto_version is set, this client has already been handled\n\tif (client->getState() > CS_Created) {\n\t\tverbosestream << \"Server: Ignoring multiple TOSERVER_INITs from \" <<\n\t\t\taddr_s << \" (peer_id=\" << peer_id << \")\" << std::endl;\n\t\treturn;\n\t}\n\n\tverbosestream << \"Server: Got TOSERVER_INIT from \" << addr_s <<\n\t\t\" (peer_id=\" << peer_id << \")\" << std::endl;\n\n\t// Do not allow multiple players in simple singleplayer mode.\n\t// This isn't a perfect way to do it, but will suffice for now\n\tif (m_simple_singleplayer_mode && m_clients.getClientIDs().size() > 1) {\n\t\tinfostream << \"Server: Not allowing another client (\" << addr_s <<\n\t\t\t\") to connect in simple singleplayer mode\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SINGLEPLAYER);\n\t\treturn;\n\t}\n\n\t// First byte after command is maximum supported\n\t// serialization version\n\tu8 client_max;\n\tu16 supp_compr_modes;\n\tu16 min_net_proto_version = 0;\n\tu16 max_net_proto_version;\n\tstd::string playerName;\n\n\t*pkt >> client_max >> supp_compr_modes >> min_net_proto_version\n\t\t\t>> max_net_proto_version >> playerName;\n\n\tu8 our_max = SER_FMT_VER_HIGHEST_READ;\n\t// Use the highest version supported by both\n\tu8 depl_serial_v = std::min(client_max, our_max);\n\t// If it's lower than the lowest supported, give up.\n\tif (depl_serial_v < SER_FMT_VER_LOWEST_READ)\n\t\tdepl_serial_v = SER_FMT_VER_INVALID;\n\n\tif (depl_serial_v == SER_FMT_VER_INVALID) {\n\t\tactionstream << \"Server: A mismatched client tried to connect from \" <<\n\t\t\taddr_s << \" ser_fmt_max=\" << (int)client_max << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_VERSION);\n\t\treturn;\n\t}\n\n\tclient->setPendingSerializationVersion(depl_serial_v);\n\n\t/*\n\t\tRead and check network protocol version\n\t*/\n\n\tu16 net_proto_version = 0;\n\n\t// Figure out a working version if it is possible at all\n\tif (max_net_proto_version >= SERVER_PROTOCOL_VERSION_MIN ||\n\t\t\tmin_net_proto_version <= SERVER_PROTOCOL_VERSION_MAX) {\n\t\t// If maximum is larger than our maximum, go with our maximum\n\t\tif (max_net_proto_version > SERVER_PROTOCOL_VERSION_MAX)\n\t\t\tnet_proto_version = SERVER_PROTOCOL_VERSION_MAX;\n\t\t// Else go with client's maximum\n\t\telse\n\t\t\tnet_proto_version = max_net_proto_version;\n\t}\n\n\tverbosestream << \"Server: \" << addr_s << \": Protocol version: min: \"\n\t\t\t<< min_net_proto_version << \", max: \" << max_net_proto_version\n\t\t\t<< \", chosen: \" << net_proto_version << std::endl;\n\n\tclient->net_proto_version = net_proto_version;\n\n\tif ((g_settings->getBool(\"strict_protocol_version_checking\") &&\n\t\t\tnet_proto_version != LATEST_PROTOCOL_VERSION) ||\n\t\t\tnet_proto_version < SERVER_PROTOCOL_VERSION_MIN ||\n\t\t\tnet_proto_version > SERVER_PROTOCOL_VERSION_MAX) {\n\t\tactionstream << \"Server: A mismatched client tried to connect from \" <<\n\t\t\taddr_s << \" proto_max=\" << (int)max_net_proto_version << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_VERSION);\n\t\treturn;\n\t}\n\n\t/*\n\t\tValidate player name\n\t*/\n\tconst char* playername = playerName.c_str();\n\n\tsize_t pns = playerName.size();\n\tif (pns == 0 || pns > PLAYERNAME_SIZE) {\n\t\tactionstream << \"Server: Player with \" <<\n\t\t\t((pns > PLAYERNAME_SIZE) ? \"a too long\" : \"an empty\") <<\n\t\t\t\" name tried to connect from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_NAME);\n\t\treturn;\n\t}\n\n\tif (!string_allowed(playerName, PLAYERNAME_ALLOWED_CHARS)) {\n\t\tactionstream << \"Server: Player with an invalid name tried to connect \"\n\t\t\t\"from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_CHARS_IN_NAME);\n\t\treturn;\n\t}\n\n\tm_clients.setPlayerName(peer_id, playername);\n\t//TODO (later) case insensitivity\n\n\tstd::string legacyPlayerNameCasing = playerName;\n\n\tif (!isSingleplayer() && strcasecmp(playername, \"singleplayer\") == 0) {\n\t\tactionstream << \"Server: Player with the name \\\"singleplayer\\\" tried \"\n\t\t\t\"to connect from \" << addr_s << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_NAME);\n\t\treturn;\n\t}\n\n\t{\n\t\tstd::string reason;\n\t\tif (m_script->on_prejoinplayer(playername, addr_s, &reason)) {\n\t\t\tactionstream << \"Server: Player with the name \\\"\" << playerName <<\n\t\t\t\t\"\\\" tried to connect from \" << addr_s <<\n\t\t\t\t\" but it was disallowed for the following reason: \" << reason <<\n\t\t\t\tstd::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_CUSTOM_STRING, reason);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tinfostream << \"Server: New connection: \\\"\" << playerName << \"\\\" from \" <<\n\t\taddr_s << \" (peer_id=\" << peer_id << \")\" << std::endl;\n\n\t// Enforce user limit.\n\t// Don't enforce for users that have some admin right or mod permits it.\n\tif (m_clients.isUserLimitReached() &&\n\t\t\tplayername != g_settings->get(\"name\") &&\n\t\t\t!m_script->can_bypass_userlimit(playername, addr_s)) {\n\t\tactionstream << \"Server: \" << playername << \" tried to join from \" <<\n\t\t\taddr_s << \", but there are already max_users=\" <<\n\t\t\tg_settings->getU16(\"max_users\") << \" players.\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_TOO_MANY_USERS);\n\t\treturn;\n\t}\n\n\t/*\n\t\tCompose auth methods for answer\n\t*/\n\tstd::string encpwd; // encrypted Password field for the user\n\tbool has_auth = m_script->getAuth(playername, &encpwd, NULL);\n\tu32 auth_mechs = 0;\n\n\tclient->chosen_mech = AUTH_MECHANISM_NONE;\n\n\tif (has_auth) {\n\t\tstd::vector<std::string> pwd_components = str_split(encpwd, '#');\n\t\tif (pwd_components.size() == 4) {\n\t\t\tif (pwd_components[1] == \"1\") { // 1 means srp\n\t\t\t\tauth_mechs |= AUTH_MECHANISM_SRP;\n\t\t\t\tclient->enc_pwd = encpwd;\n\t\t\t} else {\n\t\t\t\tactionstream << \"User \" << playername << \" tried to log in, \"\n\t\t\t\t\t\"but password field was invalid (unknown mechcode).\" <<\n\t\t\t\t\tstd::endl;\n\t\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (base64_is_valid(encpwd)) {\n\t\t\tauth_mechs |= AUTH_MECHANISM_LEGACY_PASSWORD;\n\t\t\tclient->enc_pwd = encpwd;\n\t\t} else {\n\t\t\tactionstream << \"User \" << playername << \" tried to log in, but \"\n\t\t\t\t\"password field was invalid (invalid base64).\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tstd::string default_password = g_settings->get(\"default_password\");\n\t\tif (default_password.length() == 0) {\n\t\t\tauth_mechs |= AUTH_MECHANISM_FIRST_SRP;\n\t\t} else {\n\t\t\t// Take care of default passwords.\n\t\t\tclient->enc_pwd = get_encoded_srp_verifier(playerName, default_password);\n\t\t\tauth_mechs |= AUTH_MECHANISM_SRP;\n\t\t\t// Allocate player in db, but only on successful login.\n\t\t\tclient->create_player_on_auth_success = true;\n\t\t}\n\t}\n\n\t/*\n\t\tAnswer with a TOCLIENT_HELLO\n\t*/\n\n\tverbosestream << \"Sending TOCLIENT_HELLO with auth method field: \"\n\t\t<< auth_mechs << std::endl;\n\n\tNetworkPacket resp_pkt(TOCLIENT_HELLO,\n\t\t1 + 4 + legacyPlayerNameCasing.size(), peer_id);\n\n\tu16 depl_compress_mode = NETPROTO_COMPRESSION_NONE;\n\tresp_pkt << depl_serial_v << depl_compress_mode << net_proto_version\n\t\t<< auth_mechs << legacyPlayerNameCasing;\n\n\tSend(&resp_pkt);\n\n\tclient->allowed_auth_mechs = auth_mechs;\n\tclient->setDeployedCompressionMode(depl_compress_mode);\n\n\tm_clients.event(peer_id, CSE_Hello);\n}\n\nvoid Server::handleCommand_Init2(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tverbosestream << \"Server: Got TOSERVER_INIT2 from \" << peer_id << std::endl;\n\n\tm_clients.event(peer_id, CSE_GotInit2);\n\tu16 protocol_version = m_clients.getProtocolVersion(peer_id);\n\n\tstd::string lang;\n\tif (pkt->getSize() > 0)\n\t\t*pkt >> lang;\n\n\t/*\n\t\tSend some initialization data\n\t*/\n\n\tinfostream << \"Server: Sending content to \" << getPlayerName(peer_id) <<\n\t\tstd::endl;\n\n\t// Send item definitions\n\tSendItemDef(peer_id, m_itemdef, protocol_version);\n\n\t// Send node definitions\n\tSendNodeDef(peer_id, m_nodedef, protocol_version);\n\n\tm_clients.event(peer_id, CSE_SetDefinitionsSent);\n\n\t// Send media announcement\n\tsendMediaAnnouncement(peer_id, lang);\n\n\tRemoteClient *client = getClient(peer_id, CS_InitDone);\n\n\t// Keep client language for server translations\n\tclient->setLangCode(lang);\n\n\t// Send active objects\n\t{\n\t\tPlayerSAO *sao = getPlayerSAO(peer_id);\n\t\tif (client && sao)\n\t\t\tSendActiveObjectRemoveAdd(client, sao);\n\t}\n\n\t// Send detached inventories\n\tsendDetachedInventories(peer_id, false);\n\n\t// Send player movement settings\n\tSendMovement(peer_id);\n\n\t// Send time of day\n\tu16 time = m_env->getTimeOfDay();\n\tfloat time_speed = g_settings->getFloat(\"time_speed\");\n\tSendTimeOfDay(peer_id, time, time_speed);\n\n\tSendCSMRestrictionFlags(peer_id);\n\n\t// Warnings about protocol version can be issued here\n\tif (client->net_proto_version < LATEST_PROTOCOL_VERSION) {\n\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\tL\"# Server: WARNING: YOUR CLIENT'S VERSION MAY NOT BE FULLY COMPATIBLE \"\n\t\t\tL\"WITH THIS SERVER!\"));\n\t}\n}\n\nvoid Server::handleCommand_RequestMedia(NetworkPacket* pkt)\n{\n\tstd::vector<std::string> tosend;\n\tu16 numfiles;\n\n\t*pkt >> numfiles;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tinfostream << \"Sending \" << numfiles << \" files to \" <<\n\t\tgetPlayerName(peer_id) << std::endl;\n\tverbosestream << \"TOSERVER_REQUEST_MEDIA: \" << std::endl;\n\n\tfor (u16 i = 0; i < numfiles; i++) {\n\t\tstd::string name;\n\n\t\t*pkt >> name;\n\n\t\ttosend.push_back(name);\n\t\tverbosestream << \"TOSERVER_REQUEST_MEDIA: requested file \"\n\t\t\t\t<< name << std::endl;\n\t}\n\n\tsendRequestedMedia(peer_id, tosend);\n}\n\nvoid Server::handleCommand_ClientReady(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\n\tPlayerSAO* playersao = StageTwoClientInit(peer_id);\n\n\tif (playersao == NULL) {\n\t\terrorstream << \"TOSERVER_CLIENT_READY stage 2 client init failed \"\n\t\t\t\"peer_id=\" << peer_id << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\n\tif (pkt->getSize() < 8) {\n\t\terrorstream << \"TOSERVER_CLIENT_READY client sent inconsistent data, \"\n\t\t\t\"disconnecting peer_id: \" << peer_id << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tu8 major_ver, minor_ver, patch_ver, reserved;\n\tstd::string full_ver;\n\t*pkt >> major_ver >> minor_ver >> patch_ver >> reserved >> full_ver;\n\n\tm_clients.setClientVersion(peer_id, major_ver, minor_ver, patch_ver,\n\t\tfull_ver);\n\n\tif (pkt->getRemainingBytes() >= 2)\n\t\t*pkt >> playersao->getPlayer()->formspec_version;\n\n\tconst std::vector<std::string> &players = m_clients.getPlayerNames();\n\tNetworkPacket list_pkt(TOCLIENT_UPDATE_PLAYER_LIST, 0, peer_id);\n\tlist_pkt << (u8) PLAYER_LIST_INIT << (u16) players.size();\n\tfor (const std::string &player: players) {\n\t\tlist_pkt <<  player;\n\t}\n\tm_clients.send(peer_id, 0, &list_pkt, true);\n\n\tNetworkPacket notice_pkt(TOCLIENT_UPDATE_PLAYER_LIST, 0, PEER_ID_INEXISTENT);\n\t// (u16) 1 + std::string represents a pseudo vector serialization representation\n\tnotice_pkt << (u8) PLAYER_LIST_ADD << (u16) 1 << std::string(playersao->getPlayer()->getName());\n\tm_clients.sendToAll(&notice_pkt);\n\tm_clients.event(peer_id, CSE_SetClientReady);\n\n\ts64 last_login;\n\tm_script->getAuth(playersao->getPlayer()->getName(), nullptr, nullptr, &last_login);\n\tm_script->on_joinplayer(playersao, last_login);\n\n\t// Send shutdown timer if shutdown has been scheduled\n\tif (m_shutdown_state.isTimerRunning()) {\n\t\tSendChatMessage(peer_id, m_shutdown_state.getShutdownTimerMessage());\n\t}\n}\n\nvoid Server::handleCommand_GotBlocks(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 1)\n\t\treturn;\n\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 count\n\t\t[3] v3s16 pos_0\n\t\t[3+6] v3s16 pos_1\n\t\t...\n\t*/\n\n\tu8 count;\n\t*pkt >> count;\n\n\tRemoteClient *client = getClient(pkt->getPeerId());\n\n\tif ((s16)pkt->getSize() < 1 + (int)count * 6) {\n\t\tthrow con::InvalidIncomingDataException\n\t\t\t\t(\"GOTBLOCKS length is too short\");\n\t}\n\n\tfor (u16 i = 0; i < count; i++) {\n\t\tv3s16 p;\n\t\t*pkt >> p;\n\t\tclient->GotBlock(p);\n\t}\n}\n\nvoid Server::process_PlayerPos(RemotePlayer *player, PlayerSAO *playersao,\n\tNetworkPacket *pkt)\n{\n\tif (pkt->getRemainingBytes() < 12 + 12 + 4 + 4 + 4 + 1 + 1)\n\t\treturn;\n\n\tv3s32 ps, ss;\n\ts32 f32pitch, f32yaw;\n\tu8 f32fov;\n\n\t*pkt >> ps;\n\t*pkt >> ss;\n\t*pkt >> f32pitch;\n\t*pkt >> f32yaw;\n\n\tf32 pitch = (f32)f32pitch / 100.0f;\n\tf32 yaw = (f32)f32yaw / 100.0f;\n\tu32 keyPressed = 0;\n\n\t// default behavior (in case an old client doesn't send these)\n\tf32 fov = 0;\n\tu8 wanted_range = 0;\n\n\t*pkt >> keyPressed;\n\t*pkt >> f32fov;\n\tfov = (f32)f32fov / 80.0f;\n\t*pkt >> wanted_range;\n\n\tv3f position((f32)ps.X / 100.0f, (f32)ps.Y / 100.0f, (f32)ps.Z / 100.0f);\n\tv3f speed((f32)ss.X / 100.0f, (f32)ss.Y / 100.0f, (f32)ss.Z / 100.0f);\n\n\tpitch = modulo360f(pitch);\n\tyaw = wrapDegrees_0_360(yaw);\n\n\tplayersao->setBasePosition(position);\n\tplayer->setSpeed(speed);\n\tplayersao->setLookPitch(pitch);\n\tplayersao->setPlayerYaw(yaw);\n\tplayersao->setFov(fov);\n\tplayersao->setWantedRange(wanted_range);\n\n\tplayer->keyPressed = keyPressed;\n\tplayer->control.up    = (keyPressed & (0x1 << 0));\n\tplayer->control.down  = (keyPressed & (0x1 << 1));\n\tplayer->control.left  = (keyPressed & (0x1 << 2));\n\tplayer->control.right = (keyPressed & (0x1 << 3));\n\tplayer->control.jump  = (keyPressed & (0x1 << 4));\n\tplayer->control.aux1  = (keyPressed & (0x1 << 5));\n\tplayer->control.sneak = (keyPressed & (0x1 << 6));\n\tplayer->control.dig   = (keyPressed & (0x1 << 7));\n\tplayer->control.place = (keyPressed & (0x1 << 8));\n\tplayer->control.zoom  = (keyPressed & (0x1 << 9));\n\n\tif (playersao->checkMovementCheat()) {\n\t\t// Call callbacks\n\t\tm_script->on_cheat(playersao, \"moved_too_fast\");\n\t\tSendMovePlayer(pkt->getPeerId());\n\t}\n}\n\nvoid Server::handleCommand_PlayerPos(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// If player is dead we don't care of this packet\n\tif (playersao->isDead()) {\n\t\tverbosestream << \"TOSERVER_PLAYERPOS: \" << player->getName()\n\t\t\t\t<< \" is dead. Ignoring packet\";\n\t\treturn;\n\t}\n\n\tprocess_PlayerPos(player, playersao, pkt);\n}\n\nvoid Server::handleCommand_DeletedBlocks(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 1)\n\t\treturn;\n\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 count\n\t\t[3] v3s16 pos_0\n\t\t[3+6] v3s16 pos_1\n\t\t...\n\t*/\n\n\tu8 count;\n\t*pkt >> count;\n\n\tRemoteClient *client = getClient(pkt->getPeerId());\n\n\tif ((s16)pkt->getSize() < 1 + (int)count * 6) {\n\t\tthrow con::InvalidIncomingDataException\n\t\t\t\t(\"DELETEDBLOCKS length is too short\");\n\t}\n\n\tfor (u16 i = 0; i < count; i++) {\n\t\tv3s16 p;\n\t\t*pkt >> p;\n\t\tclient->SetBlockNotSent(p);\n\t}\n}\n\nvoid Server::handleCommand_InventoryAction(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Strip command and create a stream\n\tstd::string datastring(pkt->getString(0), pkt->getSize());\n\tverbosestream << \"TOSERVER_INVENTORY_ACTION: data=\" << datastring\n\t\t<< std::endl;\n\tstd::istringstream is(datastring, std::ios_base::binary);\n\t// Create an action\n\tInventoryAction *a = InventoryAction::deSerialize(is);\n\tif (!a) {\n\t\tinfostream << \"TOSERVER_INVENTORY_ACTION: \"\n\t\t\t\t<< \"InventoryAction::deSerialize() returned NULL\"\n\t\t\t\t<< std::endl;\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\tNote: Always set inventory not sent, to repair cases\n\t\twhere the client made a bad prediction.\n\t*/\n\n\t/*\n\t\tHandle restrictions and special cases of the move action\n\t*/\n\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))\n\t\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items out of craftpreview\n\t\t*/\n\t\tif (ma->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because src is \" << ma->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t\tDisable moving items into craftresult and craftpreview\n\t\t*/\n\t\tif (ma->to_list == \"craftpreview\" || ma->to_list == \"craftresult\") {\n\t\t\tinfostream << \"Ignoring IMoveAction from \"\n\t\t\t\t\t<< (ma->from_inv.dump()) << \":\" << ma->from_list\n\t\t\t\t\t<< \" to \" << (ma->to_inv.dump()) << \":\" << ma->to_list\n\t\t\t\t\t<< \" because dst is \" << ma->to_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow moving items in elsewhere than player's inventory\n\t\t// if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\") &&\n\t\t\t\t(!from_inv_is_current_player ||\n\t\t\t\t!to_inv_is_current_player)) {\n\t\t\tinfostream << \"Cannot move outside of player's inventory: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the drop action\n\t*/\n\telse if (a->getType() == IAction::Drop) {\n\t\tIDropAction *da = (IDropAction*)a;\n\n\t\tda->from_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(da->from_inv);\n\n\t\t/*\n\t\t\tDisable dropping items out of craftpreview\n\t\t*/\n\t\tif (da->from_list == \"craftpreview\") {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because src is \" << da->from_list << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\n\t\t// Disallow dropping items if dead\n\t\tif (playersao->isDead()) {\n\t\t\tinfostream << \"Ignoring IDropAction from \"\n\t\t\t\t\t<< (da->from_inv.dump()) << \":\" << da->from_list\n\t\t\t\t\t<< \" because player is dead.\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t\tHandle restrictions and special cases of the craft action\n\t*/\n\telse if (a->getType() == IAction::Craft) {\n\t\tICraftAction *ca = (ICraftAction*)a;\n\n\t\tca->craft_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ca->craft_inv);\n\n\t\t//bool craft_inv_is_current_player =\n\t\t//\t(ca->craft_inv.type == InventoryLocation::PLAYER) &&\n\t\t//\t(ca->craft_inv.name == player->getName());\n\n\t\t// Disallow crafting if not allowed to interact\n\t\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\t\tinfostream << \"Cannot craft: \"\n\t\t\t\t\t<< \"No interact privilege\" << std::endl;\n\t\t\tdelete a;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Do the action\n\ta->apply(m_inventory_mgr.get(), playersao, this);\n\t// Eat the action\n\tdelete a;\n}\n\nvoid Server::handleCommand_ChatMessage(NetworkPacket* pkt)\n{\n\t/*\n\t\tu16 command\n\t\tu16 length\n\t\twstring message\n\t*/\n\tu16 len;\n\t*pkt >> len;\n\n\tstd::wstring message;\n\tfor (u16 i = 0; i < len; i++) {\n\t\tu16 tmp_wchar;\n\t\t*pkt >> tmp_wchar;\n\n\t\tmessage += (wchar_t)tmp_wchar;\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// Get player name of this client\n\tstd::string name = player->getName();\n\tstd::wstring wname = narrow_to_wide(name);\n\n\tstd::wstring answer_to_sender = handleChat(name, wname, message, true, player);\n\tif (!answer_to_sender.empty()) {\n\t\t// Send the answer to sender\n\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_NORMAL,\n\t\t\tanswer_to_sender, wname));\n\t}\n}\n\nvoid Server::handleCommand_Damage(NetworkPacket* pkt)\n{\n\tu16 damage;\n\n\t*pkt >> damage;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (!playersao->isImmortal()) {\n\t\tif (playersao->isDead()) {\n\t\t\tverbosestream << \"Server::ProcessData(): Info: \"\n\t\t\t\t\"Ignoring damage as player \" << player->getName()\n\t\t\t\t<< \" is already dead.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t\tactionstream << player->getName() << \" damaged by \"\n\t\t\t\t<< (int)damage << \" hp at \" << PP(playersao->getBasePosition() / BS)\n\t\t\t\t<< std::endl;\n\n\t\tPlayerHPChangeReason reason(PlayerHPChangeReason::FALL);\n\t\tplayersao->setHP((s32)playersao->getHP() - (s32)damage, reason);\n\t\tSendPlayerHPOrDie(playersao, reason);\n\t}\n}\n\nvoid Server::handleCommand_PlayerItem(NetworkPacket* pkt)\n{\n\tif (pkt->getSize() < 2)\n\t\treturn;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tu16 item;\n\n\t*pkt >> item;\n\n\tplayersao->getPlayer()->setWieldIndex(item);\n}\n\nvoid Server::handleCommand_Respawn(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tassert(playersao);\n\n\tif (!playersao->isDead())\n\t\treturn;\n\n\tRespawnPlayer(peer_id);\n\n\tactionstream << player->getName() << \" respawns at \"\n\t\t\t<< PP(playersao->getBasePosition() / BS) << std::endl;\n\n\t// ActiveObject is added to environment in AsyncRunStep after\n\t// the previous addition has been successfully removed\n}\n\nbool Server::checkInteractDistance(RemotePlayer *player, const f32 d, const std::string &what)\n{\n\tItemStack selected_item, hand_item;\n\tplayer->getWieldedItem(&selected_item, &hand_item);\n\tf32 max_d = BS * getToolRange(selected_item.getDefinition(m_itemdef),\n\t\t\thand_item.getDefinition(m_itemdef));\n\n\t// Cube diagonal * 1.5 for maximal supported node extents:\n\t// sqrt(3) * 1.5 \u2245 2.6\n\tif (d > max_d + 2.6f * BS) {\n\t\tactionstream << \"Player \" << player->getName()\n\t\t\t\t<< \" tried to access \" << what\n\t\t\t\t<< \" from too far: \"\n\t\t\t\t<< \"d=\" << d << \", max_d=\" << max_d\n\t\t\t\t<< \"; ignoring.\" << std::endl;\n\t\t// Call callbacks\n\t\tm_script->on_cheat(player->getPlayerSAO(), \"interacted_too_far\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid Server::handleCommand_Interact(NetworkPacket *pkt)\n{\n\t/*\n\t\t[0] u16 command\n\t\t[2] u8 action\n\t\t[3] u16 item\n\t\t[5] u32 length of the next item (plen)\n\t\t[9] serialized PointedThing\n\t\t[9 + plen] player position information\n\t*/\n\n\tInteractAction action;\n\tu16 item_i;\n\n\t*pkt >> (u8 &)action;\n\t*pkt >> item_i;\n\n\tstd::istringstream tmp_is(pkt->readLongString(), std::ios::binary);\n\tPointedThing pointed;\n\tpointed.deSerialize(tmp_is);\n\n\tverbosestream << \"TOSERVER_INTERACT: action=\" << (int)action << \", item=\"\n\t\t\t<< item_i << \", pointed=\" << pointed.dump() << std::endl;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (playersao->isDead()) {\n\t\tactionstream << \"Server: \" << player->getName()\n\t\t\t\t<< \" tried to interact while dead; ignoring.\" << std::endl;\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\t// Re-send block to revert change on client-side\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\tv3s16 blockpos = getNodeBlockPos(pointed.node_undersurface);\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\t// Call callbacks\n\t\tm_script->on_cheat(playersao, \"interacted_while_dead\");\n\t\treturn;\n\t}\n\n\tprocess_PlayerPos(player, playersao, pkt);\n\n\tv3f player_pos = playersao->getLastGoodPosition();\n\n\t// Update wielded item\n\tplayersao->getPlayer()->setWieldIndex(item_i);\n\n\t// Get pointed to node (undefined if not POINTEDTYPE_NODE)\n\tv3s16 p_under = pointed.node_undersurface;\n\tv3s16 p_above = pointed.node_abovesurface;\n\n\t// Get pointed to object (NULL if not POINTEDTYPE_OBJECT)\n\tServerActiveObject *pointed_object = NULL;\n\tif (pointed.type == POINTEDTHING_OBJECT) {\n\t\tpointed_object = m_env->getActiveObject(pointed.object_id);\n\t\tif (pointed_object == NULL) {\n\t\t\tverbosestream << \"TOSERVER_INTERACT: \"\n\t\t\t\t\"pointed object is NULL\" << std::endl;\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\tv3f pointed_pos_under = player_pos;\n\tv3f pointed_pos_above = player_pos;\n\tif (pointed.type == POINTEDTHING_NODE) {\n\t\tpointed_pos_under = intToFloat(p_under, BS);\n\t\tpointed_pos_above = intToFloat(p_above, BS);\n\t}\n\telse if (pointed.type == POINTEDTHING_OBJECT) {\n\t\tpointed_pos_under = pointed_object->getBasePosition();\n\t\tpointed_pos_above = pointed_pos_under;\n\t}\n\n\t/*\n\t\tMake sure the player is allowed to do it\n\t*/\n\tif (!checkPriv(player->getName(), \"interact\")) {\n\t\tactionstream << player->getName() << \" attempted to interact with \" <<\n\t\t\t\tpointed.dump() << \" without 'interact' privilege\" << std::endl;\n\n\t\t// Re-send block to revert change on client-side\n\t\tRemoteClient *client = getClient(peer_id);\n\t\t// Digging completed -> under\n\t\tif (action == INTERACT_DIGGING_COMPLETED) {\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\t// Placement -> above\n\t\telse if (action == INTERACT_PLACE) {\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_above, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t}\n\t\treturn;\n\t}\n\n\t/*\n\t\tCheck that target is reasonably close\n\t\t(only when digging or placing things)\n\t*/\n\tstatic thread_local const bool enable_anticheat =\n\t\t\t!g_settings->getBool(\"disable_anticheat\");\n\n\tif ((action == INTERACT_START_DIGGING || action == INTERACT_DIGGING_COMPLETED ||\n\t\t\taction == INTERACT_PLACE || action == INTERACT_USE) &&\n\t\t\tenable_anticheat && !isSingleplayer()) {\n\t\tfloat d = playersao->getEyePosition().getDistanceFrom(pointed_pos_under);\n\n\t\tif (!checkInteractDistance(player, d, pointed.dump())) {\n\t\t\t// Re-send block to revert change on client-side\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t\tIf something goes wrong, this player is to blame\n\t*/\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t/*\n\t\t0: start digging or punch object\n\t*/\n\tif (action == INTERACT_START_DIGGING) {\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\tMapNode n(CONTENT_IGNORE);\n\t\t\tbool pos_ok;\n\n\t\t\tn = m_env->getMap().getNode(p_under, &pos_ok);\n\t\t\tif (!pos_ok) {\n\t\t\t\tinfostream << \"Server: Not punching: Node not found. \"\n\t\t\t\t\t\"Adding block to emerge queue.\" << std::endl;\n\t\t\t\tm_emerge->enqueueBlockEmerge(peer_id, getNodeBlockPos(p_above),\n\t\t\t\t\tfalse);\n\t\t\t}\n\n\t\t\tif (n.getContent() != CONTENT_IGNORE)\n\t\t\t\tm_script->node_on_punch(p_under, n, playersao, pointed);\n\n\t\t\t// Cheat prevention\n\t\t\tplayersao->noCheatDigStart(p_under);\n\t\t}\n\t\telse if (pointed.type == POINTEDTHING_OBJECT) {\n\t\t\t// Skip if object can't be interacted with anymore\n\t\t\tif (pointed_object->isGone())\n\t\t\t\treturn;\n\n\t\t\tItemStack selected_item, hand_item;\n\t\t\tItemStack tool_item = playersao->getWieldedItem(&selected_item, &hand_item);\n\t\t\tToolCapabilities toolcap =\n\t\t\t\t\ttool_item.getToolCapabilities(m_itemdef);\n\t\t\tv3f dir = (pointed_object->getBasePosition() -\n\t\t\t\t\t(playersao->getBasePosition() + playersao->getEyeOffset())\n\t\t\t\t\t\t).normalize();\n\t\t\tfloat time_from_last_punch =\n\t\t\t\tplayersao->resetTimeFromLastPunch();\n\n\t\t\tu16 src_original_hp = pointed_object->getHP();\n\t\t\tu16 dst_origin_hp = playersao->getHP();\n\n\t\t\tu16 wear = pointed_object->punch(dir, &toolcap, playersao,\n\t\t\t\t\ttime_from_last_punch);\n\n\t\t\t// Callback may have changed item, so get it again\n\t\t\tplayersao->getWieldedItem(&selected_item);\n\t\t\tbool changed = selected_item.addWear(wear, m_itemdef);\n\t\t\tif (changed)\n\t\t\t\tplayersao->setWieldedItem(selected_item);\n\n\t\t\t// If the object is a player and its HP changed\n\t\t\tif (src_original_hp != pointed_object->getHP() &&\n\t\t\t\t\tpointed_object->getType() == ACTIVEOBJECT_TYPE_PLAYER) {\n\t\t\t\tSendPlayerHPOrDie((PlayerSAO *)pointed_object,\n\t\t\t\t\t\tPlayerHPChangeReason(PlayerHPChangeReason::PLAYER_PUNCH, playersao));\n\t\t\t}\n\n\t\t\t// If the puncher is a player and its HP changed\n\t\t\tif (dst_origin_hp != playersao->getHP())\n\t\t\t\tSendPlayerHPOrDie(playersao,\n\t\t\t\t\t\tPlayerHPChangeReason(PlayerHPChangeReason::PLAYER_PUNCH, pointed_object));\n\t\t}\n\n\t} // action == INTERACT_START_DIGGING\n\n\t/*\n\t\t1: stop digging\n\t*/\n\telse if (action == INTERACT_STOP_DIGGING) {\n\t} // action == INTERACT_STOP_DIGGING\n\n\t/*\n\t\t2: Digging completed\n\t*/\n\telse if (action == INTERACT_DIGGING_COMPLETED) {\n\t\t// Only digging of nodes\n\t\tif (pointed.type == POINTEDTHING_NODE) {\n\t\t\tbool pos_ok;\n\t\t\tMapNode n = m_env->getMap().getNode(p_under, &pos_ok);\n\t\t\tif (!pos_ok) {\n\t\t\t\tinfostream << \"Server: Not finishing digging: Node not found. \"\n\t\t\t\t\t\"Adding block to emerge queue.\" << std::endl;\n\t\t\t\tm_emerge->enqueueBlockEmerge(peer_id, getNodeBlockPos(p_above),\n\t\t\t\t\tfalse);\n\t\t\t}\n\n\t\t\t/* Cheat prevention */\n\t\t\tbool is_valid_dig = true;\n\t\t\tif (enable_anticheat && !isSingleplayer()) {\n\t\t\t\tv3s16 nocheat_p = playersao->getNoCheatDigPos();\n\t\t\t\tfloat nocheat_t = playersao->getNoCheatDigTime();\n\t\t\t\tplayersao->noCheatDigEnd();\n\t\t\t\t// If player didn't start digging this, ignore dig\n\t\t\t\tif (nocheat_p != p_under) {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" started digging \"\n\t\t\t\t\t\t\t<< PP(nocheat_p) << \" and completed digging \"\n\t\t\t\t\t\t\t<< PP(p_under) << \"; not digging.\" << std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"finished_unknown_dig\");\n\t\t\t\t}\n\n\t\t\t\t// Get player's wielded item\n\t\t\t\t// See also: Game::handleDigging\n\t\t\t\tItemStack selected_item, hand_item;\n\t\t\t\tplayersao->getPlayer()->getWieldedItem(&selected_item, &hand_item);\n\n\t\t\t\t// Get diggability and expected digging time\n\t\t\t\tDigParams params = getDigParams(m_nodedef->get(n).groups,\n\t\t\t\t\t\t&selected_item.getToolCapabilities(m_itemdef));\n\t\t\t\t// If can't dig, try hand\n\t\t\t\tif (!params.diggable) {\n\t\t\t\t\tparams = getDigParams(m_nodedef->get(n).groups,\n\t\t\t\t\t\t&hand_item.getToolCapabilities(m_itemdef));\n\t\t\t\t}\n\t\t\t\t// If can't dig, ignore dig\n\t\t\t\tif (!params.diggable) {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" completed digging \" << PP(p_under)\n\t\t\t\t\t\t\t<< \", which is not diggable with tool; not digging.\"\n\t\t\t\t\t\t\t<< std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"dug_unbreakable\");\n\t\t\t\t}\n\t\t\t\t// Check digging time\n\t\t\t\t// If already invalidated, we don't have to\n\t\t\t\tif (!is_valid_dig) {\n\t\t\t\t\t// Well not our problem then\n\t\t\t\t}\n\t\t\t\t// Clean and long dig\n\t\t\t\telse if (params.time > 2.0 && nocheat_t * 1.2 > params.time) {\n\t\t\t\t\t// All is good, but grab time from pool; don't care if\n\t\t\t\t\t// it's actually available\n\t\t\t\t\tplayersao->getDigPool().grab(params.time);\n\t\t\t\t}\n\t\t\t\t// Short or laggy dig\n\t\t\t\t// Try getting the time from pool\n\t\t\t\telse if (playersao->getDigPool().grab(params.time)) {\n\t\t\t\t\t// All is good\n\t\t\t\t}\n\t\t\t\t// Dig not possible\n\t\t\t\telse {\n\t\t\t\t\tinfostream << \"Server: \" << player->getName()\n\t\t\t\t\t\t\t<< \" completed digging \" << PP(p_under)\n\t\t\t\t\t\t\t<< \"too fast; not digging.\" << std::endl;\n\t\t\t\t\tis_valid_dig = false;\n\t\t\t\t\t// Call callbacks\n\t\t\t\t\tm_script->on_cheat(playersao, \"dug_too_fast\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Actually dig node */\n\n\t\t\tif (is_valid_dig && n.getContent() != CONTENT_IGNORE)\n\t\t\t\tm_script->node_on_dig(p_under, n, playersao);\n\n\t\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\t\tRemoteClient *client = getClient(peer_id);\n\t\t\t// Send unusual result (that is, node not being removed)\n\t\t\tif (m_env->getMap().getNode(p_under).getContent() != CONTENT_AIR) {\n\t\t\t\t// Re-send block to revert change on client-side\n\t\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclient->ResendBlockIfOnWire(blockpos);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_DIGGING_COMPLETED\n\n\t/*\n\t\t3: place block or right-click object\n\t*/\n\telse if (action == INTERACT_PLACE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\t// Reset build time counter\n\t\tif (pointed.type == POINTEDTHING_NODE &&\n\t\t\t\tselected_item.getDefinition(m_itemdef).type == ITEM_NODE)\n\t\t\tgetClient(peer_id)->m_time_from_building = 0.0;\n\n\t\tif (pointed.type == POINTEDTHING_OBJECT) {\n\t\t\t// Right click object\n\n\t\t\t// Skip if object can't be interacted with anymore\n\t\t\tif (pointed_object->isGone())\n\t\t\t\treturn;\n\n\t\t\tactionstream << player->getName() << \" right-clicks object \"\n\t\t\t\t\t<< pointed.object_id << \": \"\n\t\t\t\t\t<< pointed_object->getDescription() << std::endl;\n\n\t\t\t// Do stuff\n\t\t\tif (m_script->item_OnSecondaryUse(\n\t\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\t\tSendInventory(playersao, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpointed_object->rightClick(playersao);\n\t\t} else if (m_script->item_OnPlace(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t// Placement was handled in lua\n\n\t\t\t// Apply returned ItemStack\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\n\t\t// If item has node placement prediction, always send the\n\t\t// blocks to make sure the client knows what exactly happened\n\t\tRemoteClient *client = getClient(peer_id);\n\t\tv3s16 blockpos = getNodeBlockPos(floatToInt(pointed_pos_above, BS));\n\t\tv3s16 blockpos2 = getNodeBlockPos(floatToInt(pointed_pos_under, BS));\n\t\tif (!selected_item.getDefinition(m_itemdef).node_placement_prediction.empty()) {\n\t\t\tclient->SetBlockNotSent(blockpos);\n\t\t\tif (blockpos2 != blockpos) {\n\t\t\t\tclient->SetBlockNotSent(blockpos2);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tclient->ResendBlockIfOnWire(blockpos);\n\t\t\tif (blockpos2 != blockpos) {\n\t\t\t\tclient->ResendBlockIfOnWire(blockpos2);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_PLACE\n\n\t/*\n\t\t4: use\n\t*/\n\telse if (action == INTERACT_USE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\tactionstream << player->getName() << \" uses \" << selected_item.name\n\t\t\t\t<< \", pointing at \" << pointed.dump() << std::endl;\n\n\t\tif (m_script->item_OnUse(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\t// Apply returned ItemStack\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\n\t} // action == INTERACT_USE\n\n\t/*\n\t\t5: rightclick air\n\t*/\n\telse if (action == INTERACT_ACTIVATE) {\n\t\tItemStack selected_item;\n\t\tplayersao->getWieldedItem(&selected_item, nullptr);\n\n\t\tactionstream << player->getName() << \" activates \"\n\t\t\t\t<< selected_item.name << std::endl;\n\n\t\tpointed.type = POINTEDTHING_NOTHING; // can only ever be NOTHING\n\n\t\tif (m_script->item_OnSecondaryUse(\n\t\t\t\tselected_item, playersao, pointed)) {\n\t\t\tif (playersao->setWieldedItem(selected_item)) {\n\t\t\t\tSendInventory(playersao, true);\n\t\t\t}\n\t\t}\n\t} // action == INTERACT_ACTIVATE\n\n\n\t/*\n\t\tCatch invalid actions\n\t*/\n\telse {\n\t\twarningstream << \"Server: Invalid action \"\n\t\t\t\t<< action << std::endl;\n\t}\n}\n\nvoid Server::handleCommand_RemovedSounds(NetworkPacket* pkt)\n{\n\tu16 num;\n\t*pkt >> num;\n\tfor (u16 k = 0; k < num; k++) {\n\t\ts32 id;\n\n\t\t*pkt >> id;\n\n\t\tstd::unordered_map<s32, ServerPlayingSound>::iterator i =\n\t\t\tm_playing_sounds.find(id);\n\t\tif (i == m_playing_sounds.end())\n\t\t\tcontinue;\n\n\t\tServerPlayingSound &psound = i->second;\n\t\tpsound.clients.erase(pkt->getPeerId());\n\t\tif (psound.clients.empty())\n\t\t\tm_playing_sounds.erase(i++);\n\t}\n}\n\nvoid Server::handleCommand_NodeMetaFields(NetworkPacket* pkt)\n{\n\tv3s16 p;\n\tstd::string formname;\n\tu16 num;\n\n\t*pkt >> p >> formname >> num;\n\n\tStringMap fields;\n\tfor (u16 k = 0; k < num; k++) {\n\t\tstd::string fieldname;\n\t\t*pkt >> fieldname;\n\t\tfields[fieldname] = pkt->readLongString();\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\t// If something goes wrong, this player is to blame\n\tRollbackScopeActor rollback_scope(m_rollback,\n\t\t\tstd::string(\"player:\")+player->getName());\n\n\t// Check the target node for rollback data; leave others unnoticed\n\tRollbackNode rn_old(&m_env->getMap(), p, this);\n\n\tm_script->node_on_receive_fields(p, formname, fields, playersao);\n\n\t// Report rollback data\n\tRollbackNode rn_new(&m_env->getMap(), p, this);\n\tif (rollback() && rn_new != rn_old) {\n\t\tRollbackAction action;\n\t\taction.setSetNode(p, rn_old, rn_new);\n\t\trollback()->reportAction(action);\n\t}\n}\n\nvoid Server::handleCommand_InventoryFields(NetworkPacket* pkt)\n{\n\tstd::string client_formspec_name;\n\tu16 num;\n\n\t*pkt >> client_formspec_name >> num;\n\n\tStringMap fields;\n\tfor (u16 k = 0; k < num; k++) {\n\t\tstd::string fieldname;\n\t\t*pkt >> fieldname;\n\t\tfields[fieldname] = pkt->readLongString();\n\t}\n\n\tsession_t peer_id = pkt->getPeerId();\n\tRemotePlayer *player = m_env->getPlayer(peer_id);\n\n\tif (player == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tPlayerSAO *playersao = player->getPlayerSAO();\n\tif (playersao == NULL) {\n\t\terrorstream <<\n\t\t\t\"Server::ProcessData(): Canceling: No player object for peer_id=\" <<\n\t\t\tpeer_id << \" disconnecting peer!\" << std::endl;\n\t\tDisconnectPeer(peer_id);\n\t\treturn;\n\t}\n\n\tif (client_formspec_name.empty()) { // pass through inventory submits\n\t\tm_script->on_playerReceiveFields(playersao, client_formspec_name, fields);\n\t\treturn;\n\t}\n\n\t// verify that we displayed the formspec to the user\n\tconst auto peer_state_iterator = m_formspec_state_data.find(peer_id);\n\tif (peer_state_iterator != m_formspec_state_data.end()) {\n\t\tconst std::string &server_formspec_name = peer_state_iterator->second;\n\t\tif (client_formspec_name == server_formspec_name) {\n\t\t\tauto it = fields.find(\"quit\");\n\t\t\tif (it != fields.end() && it->second == \"true\")\n\t\t\t\tm_formspec_state_data.erase(peer_state_iterator);\n\n\t\t\tm_script->on_playerReceiveFields(playersao, client_formspec_name, fields);\n\t\t\treturn;\n\t\t}\n\t\tactionstream << \"'\" << player->getName()\n\t\t\t<< \"' submitted formspec ('\" << client_formspec_name\n\t\t\t<< \"') but the name of the formspec doesn't match the\"\n\t\t\t\" expected name ('\" << server_formspec_name << \"')\";\n\n\t} else {\n\t\tactionstream << \"'\" << player->getName()\n\t\t\t<< \"' submitted formspec ('\" << client_formspec_name\n\t\t\t<< \"') but server hasn't sent formspec to client\";\n\t}\n\tactionstream << \", possible exploitation attempt\" << std::endl;\n}\n\nvoid Server::handleCommand_FirstSrp(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\n\tstd::string playername = client->getName();\n\n\tstd::string salt;\n\tstd::string verification_key;\n\n\tstd::string addr_s = getPeerAddress(peer_id).serializeString();\n\tu8 is_empty;\n\n\t*pkt >> salt >> verification_key >> is_empty;\n\n\tverbosestream << \"Server: Got TOSERVER_FIRST_SRP from \" << addr_s\n\t\t<< \", with is_empty=\" << (is_empty == 1) << std::endl;\n\n\t// Either this packet is sent because the user is new or to change the password\n\tif (cstate == CS_HelloSent) {\n\t\tif (!client->isMechAllowed(AUTH_MECHANISM_FIRST_SRP)) {\n\t\t\tactionstream << \"Server: Client from \" << addr_s\n\t\t\t\t\t<< \" tried to set password without being \"\n\t\t\t\t\t<< \"authenticated, or the username being new.\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!isSingleplayer() &&\n\t\t\t\tg_settings->getBool(\"disallow_empty_password\") &&\n\t\t\t\tis_empty == 1) {\n\t\t\tactionstream << \"Server: \" << playername\n\t\t\t\t\t<< \" supplied empty password from \" << addr_s << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_EMPTY_PASSWORD);\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string initial_ver_key;\n\n\t\tinitial_ver_key = encode_srp_verifier(verification_key, salt);\n\t\tm_script->createAuth(playername, initial_ver_key);\n\t\tm_script->on_authplayer(playername, addr_s, true);\n\n\t\tacceptAuth(peer_id, false);\n\t} else {\n\t\tif (cstate < CS_SudoMode) {\n\t\t\tinfostream << \"Server::ProcessData(): Ignoring TOSERVER_FIRST_SRP from \"\n\t\t\t\t\t<< addr_s << \": \" << \"Client has wrong state \" << cstate << \".\"\n\t\t\t\t\t<< std::endl;\n\t\t\treturn;\n\t\t}\n\t\tm_clients.event(peer_id, CSE_SudoLeave);\n\t\tstd::string pw_db_field = encode_srp_verifier(verification_key, salt);\n\t\tbool success = m_script->setPassword(playername, pw_db_field);\n\t\tif (success) {\n\t\t\tactionstream << playername << \" changes password\" << std::endl;\n\t\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\t\tL\"Password change successful.\"));\n\t\t} else {\n\t\t\tactionstream << playername <<\n\t\t\t\t\" tries to change password but it fails\" << std::endl;\n\t\t\tSendChatMessage(peer_id, ChatMessage(CHATMESSAGE_TYPE_SYSTEM,\n\t\t\t\tL\"Password change failed or unavailable.\"));\n\t\t}\n\t}\n}\n\nvoid Server::handleCommand_SrpBytesA(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\n\tbool wantSudo = (cstate == CS_Active);\n\n\tif (!((cstate == CS_HelloSent) || (cstate == CS_Active))) {\n\t\tactionstream << \"Server: got SRP _A packet in wrong state \" << cstate <<\n\t\t\t\" from \" << getPeerAddress(peer_id).serializeString() <<\n\t\t\t\". Ignoring.\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (client->chosen_mech != AUTH_MECHANISM_NONE) {\n\t\tactionstream << \"Server: got SRP _A packet, while auth is already \"\n\t\t\t\"going on with mech \" << client->chosen_mech << \" from \" <<\n\t\t\tgetPeerAddress(peer_id).serializeString() <<\n\t\t\t\" (wantSudo=\" << wantSudo << \"). Ignoring.\" << std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tstd::string bytes_A;\n\tu8 based_on;\n\t*pkt >> bytes_A >> based_on;\n\n\tinfostream << \"Server: TOSERVER_SRP_BYTES_A received with \"\n\t\t<< \"based_on=\" << int(based_on) << \" and len_A=\"\n\t\t<< bytes_A.length() << \".\" << std::endl;\n\n\tAuthMechanism chosen = (based_on == 0) ?\n\t\tAUTH_MECHANISM_LEGACY_PASSWORD : AUTH_MECHANISM_SRP;\n\n\tif (wantSudo) {\n\t\tif (!client->isSudoMechAllowed(chosen)) {\n\t\t\tactionstream << \"Server: Player \\\"\" << client->getName() <<\n\t\t\t\t\"\\\" at \" << getPeerAddress(peer_id).serializeString() <<\n\t\t\t\t\" tried to change password using unallowed mech \" << chosen <<\n\t\t\t\t\".\" << std::endl;\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (!client->isMechAllowed(chosen)) {\n\t\t\tactionstream << \"Server: Client tried to authenticate from \" <<\n\t\t\t\tgetPeerAddress(peer_id).serializeString() <<\n\t\t\t\t\" using unallowed mech \" << chosen << \".\" << std::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclient->chosen_mech = chosen;\n\n\tstd::string salt;\n\tstd::string verifier;\n\n\tif (based_on == 0) {\n\n\t\tgenerate_srp_verifier_and_salt(client->getName(), client->enc_pwd,\n\t\t\t&verifier, &salt);\n\t} else if (!decode_srp_verifier_and_salt(client->enc_pwd, &verifier, &salt)) {\n\t\t// Non-base64 errors should have been catched in the init handler\n\t\tactionstream << \"Server: User \" << client->getName() <<\n\t\t\t\" tried to log in, but srp verifier field was invalid (most likely \"\n\t\t\t\"invalid base64).\" << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\treturn;\n\t}\n\n\tchar *bytes_B = 0;\n\tsize_t len_B = 0;\n\n\tclient->auth_data = srp_verifier_new(SRP_SHA256, SRP_NG_2048,\n\t\tclient->getName().c_str(),\n\t\t(const unsigned char *) salt.c_str(), salt.size(),\n\t\t(const unsigned char *) verifier.c_str(), verifier.size(),\n\t\t(const unsigned char *) bytes_A.c_str(), bytes_A.size(),\n\t\tNULL, 0,\n\t\t(unsigned char **) &bytes_B, &len_B, NULL, NULL);\n\n\tif (!bytes_B) {\n\t\tactionstream << \"Server: User \" << client->getName()\n\t\t\t<< \" tried to log in, SRP-6a safety check violated in _A handler.\"\n\t\t\t<< std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tNetworkPacket resp_pkt(TOCLIENT_SRP_BYTES_S_B, 0, peer_id);\n\tresp_pkt << salt << std::string(bytes_B, len_B);\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_SrpBytesM(NetworkPacket* pkt)\n{\n\tsession_t peer_id = pkt->getPeerId();\n\tRemoteClient *client = getClient(peer_id, CS_Invalid);\n\tClientState cstate = client->getState();\n\tstd::string addr_s = getPeerAddress(pkt->getPeerId()).serializeString();\n\tstd::string playername = client->getName();\n\n\tbool wantSudo = (cstate == CS_Active);\n\n\tverbosestream << \"Server: Received TOCLIENT_SRP_BYTES_M.\" << std::endl;\n\n\tif (!((cstate == CS_HelloSent) || (cstate == CS_Active))) {\n\t\tactionstream << \"Server: got SRP _M packet in wrong state \"\n\t\t\t<< cstate << \" from \" << addr_s\n\t\t\t<< \". Ignoring.\" << std::endl;\n\t\treturn;\n\t}\n\n\tif (client->chosen_mech != AUTH_MECHANISM_SRP &&\n\t\t\tclient->chosen_mech != AUTH_MECHANISM_LEGACY_PASSWORD) {\n\t\tactionstream << \"Server: got SRP _M packet, while auth\"\n\t\t\t<< \"is going on with mech \" << client->chosen_mech << \" from \"\n\t\t\t<< addr_s << \" (wantSudo=\" << wantSudo << \"). Denying.\" << std::endl;\n\t\tif (wantSudo) {\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tstd::string bytes_M;\n\t*pkt >> bytes_M;\n\n\tif (srp_verifier_get_session_key_length((SRPVerifier *) client->auth_data)\n\t\t\t!= bytes_M.size()) {\n\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t<< \" sent bytes_M with invalid length \" << bytes_M.size() << std::endl;\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_UNEXPECTED_DATA);\n\t\treturn;\n\t}\n\n\tunsigned char *bytes_HAMK = 0;\n\n\tsrp_verifier_verify_session((SRPVerifier *) client->auth_data,\n\t\t(unsigned char *)bytes_M.c_str(), &bytes_HAMK);\n\n\tif (!bytes_HAMK) {\n\t\tif (wantSudo) {\n\t\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t\t<< \" tried to change their password, but supplied wrong\"\n\t\t\t\t<< \" (SRP) password for authentication.\" << std::endl;\n\t\t\tDenySudoAccess(peer_id);\n\t\t\treturn;\n\t\t}\n\n\t\tactionstream << \"Server: User \" << playername << \" at \" << addr_s\n\t\t\t<< \" supplied wrong password (auth mechanism: SRP).\" << std::endl;\n\t\tm_script->on_authplayer(playername, addr_s, false);\n\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_WRONG_PASSWORD);\n\t\treturn;\n\t}\n\n\tif (client->create_player_on_auth_success) {\n\t\tm_script->createAuth(playername, client->enc_pwd);\n\n\t\tstd::string checkpwd; // not used, but needed for passing something\n\t\tif (!m_script->getAuth(playername, &checkpwd, NULL)) {\n\t\t\tactionstream << \"Server: \" << playername <<\n\t\t\t\t\" cannot be authenticated (auth handler does not work?)\" <<\n\t\t\t\tstd::endl;\n\t\t\tDenyAccess(peer_id, SERVER_ACCESSDENIED_SERVER_FAIL);\n\t\t\treturn;\n\t\t}\n\t\tclient->create_player_on_auth_success = false;\n\t}\n\n\tm_script->on_authplayer(playername, addr_s, true);\n\tacceptAuth(peer_id, wantSudo);\n}\n\n/*\n * Mod channels\n */\n\nvoid Server::handleCommand_ModChannelJoin(NetworkPacket *pkt)\n{\n\tstd::string channel_name;\n\t*pkt >> channel_name;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t1 + 2 + channel_name.size(), peer_id);\n\n\t// Send signal to client to notify join succeed or not\n\tif (g_settings->getBool(\"enable_mod_channels\") &&\n\t\t\tm_modchannel_mgr->joinChannel(channel_name, peer_id)) {\n\t\tresp_pkt << (u8) MODCHANNEL_SIGNAL_JOIN_OK;\n\t\tinfostream << \"Peer \" << peer_id << \" joined channel \" <<\n\t\t\tchannel_name << std::endl;\n\t}\n\telse {\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_JOIN_FAILURE;\n\t\tinfostream << \"Peer \" << peer_id << \" tried to join channel \" <<\n\t\t\tchannel_name << \", but was already registered.\" << std::endl;\n\t}\n\tresp_pkt << channel_name;\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_ModChannelLeave(NetworkPacket *pkt)\n{\n\tstd::string channel_name;\n\t*pkt >> channel_name;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t1 + 2 + channel_name.size(), peer_id);\n\n\t// Send signal to client to notify join succeed or not\n\tif (g_settings->getBool(\"enable_mod_channels\") &&\n\t\t\tm_modchannel_mgr->leaveChannel(channel_name, peer_id)) {\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_LEAVE_OK;\n\t\tinfostream << \"Peer \" << peer_id << \" left channel \" << channel_name <<\n\t\t\tstd::endl;\n\t} else {\n\t\tresp_pkt << (u8) MODCHANNEL_SIGNAL_LEAVE_FAILURE;\n\t\tinfostream << \"Peer \" << peer_id << \" left channel \" << channel_name <<\n\t\t\t\", but was not registered.\" << std::endl;\n\t}\n\tresp_pkt << channel_name;\n\tSend(&resp_pkt);\n}\n\nvoid Server::handleCommand_ModChannelMsg(NetworkPacket *pkt)\n{\n\tstd::string channel_name, channel_msg;\n\t*pkt >> channel_name >> channel_msg;\n\n\tsession_t peer_id = pkt->getPeerId();\n\tverbosestream << \"Mod channel message received from peer \" << peer_id <<\n\t\t\" on channel \" << channel_name << \" message: \" << channel_msg <<\n\t\tstd::endl;\n\n\t// If mod channels are not enabled, discard message\n\tif (!g_settings->getBool(\"enable_mod_channels\")) {\n\t\treturn;\n\t}\n\n\t// If channel not registered, signal it and ignore message\n\tif (!m_modchannel_mgr->channelRegistered(channel_name)) {\n\t\tNetworkPacket resp_pkt(TOCLIENT_MODCHANNEL_SIGNAL,\n\t\t\t1 + 2 + channel_name.size(), peer_id);\n\t\tresp_pkt << (u8)MODCHANNEL_SIGNAL_CHANNEL_NOT_REGISTERED << channel_name;\n\t\tSend(&resp_pkt);\n\t\treturn;\n\t}\n\n\t// @TODO: filter, rate limit\n\n\tbroadcastModChannelMessage(channel_name, channel_msg, peer_id);\n}\n"], "filenames": ["src/network/serverpackethandler.cpp"], "buggy_code_start_loc": [633], "buggy_code_end_loc": [640], "fixing_code_start_loc": [633], "fixing_code_end_loc": [646], "type": "CWE-276", "message": "In Minetest before 5.4.0, players can add or subtract items from a different player's inventory.", "other": {"cve": {"id": "CVE-2022-24301", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-02T06:15:06.807", "lastModified": "2022-02-28T15:33:16.667", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Minetest before 5.4.0, players can add or subtract items from a different player's inventory."}, {"lang": "es", "value": "En Minetest versiones anteriores a 5.4.0, los jugadores pueden a\u00f1adir o sustraer objetos del inventario de otro jugador"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minetest:minetest:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.4.0", "matchCriteriaId": "ADBC4BE4-39DD-443E-9B73-0D9A9323A266"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/minetest/minetest/commit/3693b6871eba268ecc79b3f52d00d3cefe761131", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minetest/minetest/security/advisories/GHSA-fvwv-qcq6-wmp5", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5075", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minetest/minetest/commit/3693b6871eba268ecc79b3f52d00d3cefe761131"}}