{"buggy_code": ["# frozen_string_literal: true\n\nclass DiscourseReactions::CustomReactionsController < ApplicationController\n  MAX_USERS_COUNT = 26\n\n  requires_plugin DiscourseReactions::PLUGIN_NAME\n\n  before_action :ensure_logged_in, except: [:post_reactions_users]\n\n  def toggle\n    post = fetch_post_from_params\n\n    unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n      return render_json_error(post)\n    end\n\n    begin\n      manager =\n        DiscourseReactions::ReactionManager.new(\n          reaction_value: params[:reaction],\n          user: current_user,\n          guardian: guardian,\n          post: post,\n        )\n      manager.toggle!\n    rescue ActiveRecord::RecordNotUnique\n      # If the user already performed this action, it's probably due to a different browser tab\n      # or non-debounced clicking. We can ignore.\n    end\n\n    post.publish_change_to_clients!(:acted)\n    publish_change_to_clients!(\n      post,\n      reaction: manager.reaction_value,\n      previous_reaction: manager.previous_reaction_value,\n    )\n\n    render_json_dump(post_serializer(post).as_json)\n  end\n\n  def reactions_given\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction, :post)\n        .joins(\"INNER JOIN topics t ON t.id = posts.topic_id AND t.deleted_at IS NULL\")\n        .joins(\"LEFT JOIN categories c ON c.id = t.category_id\")\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    reaction_users = secure_reaction_users!(reaction_users)\n\n    if params[:before_reaction_user_id]\n      reaction_users =\n        reaction_users.where(\n          \"discourse_reactions_reaction_users.id < ?\",\n          params[:before_reaction_user_id].to_i,\n        )\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20)\n\n    render_serialized(reaction_users.to_a, UserReactionSerializer)\n  end\n\n  def reactions_received\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    posts = Post.joins(:topic).where(user_id: user.id)\n    posts = guardian.filter_allowed_categories(posts)\n    post_ids = posts.pluck(:id)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    # Guarantee backwards compatibility if someone was calling this endpoint with the old param.\n    # TODO(roman): Remove after the 2.9 release.\n    before_reaction_id = params[:before_reaction_user_id]\n    if before_reaction_id.blank? && params[:before_post_id]\n      before_reaction_id = params[:before_post_id]\n    end\n\n    if before_reaction_id\n      reaction_users =\n        reaction_users.where(\"discourse_reactions_reaction_users.id < ?\", before_reaction_id.to_i)\n    end\n\n    if params[:acting_username]\n      reaction_users =\n        reaction_users.joins(:user).where(users: { username: params[:acting_username] })\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20).to_a\n\n    if params[:include_likes]\n      likes =\n        PostAction\n          .where(\n            post_id: post_ids,\n            deleted_at: nil,\n            post_action_type_id: PostActionType.types[:like],\n          )\n          .order(created_at: :desc)\n          .limit(20)\n\n      if params[:before_like_id]\n        likes = likes.where(\"post_actions.id < ?\", params[:before_like_id].to_i)\n      end\n\n      if params[:acting_username]\n        likes = likes.joins(:user).where(users: { username: params[:acting_username] })\n      end\n\n      reaction_users = reaction_users.concat(translate_to_reactions(likes))\n      reaction_users = reaction_users.sort { |a, b| b.created_at <=> a.created_at }\n    end\n\n    render_serialized reaction_users.first(20), UserReactionSerializer\n  end\n\n  def post_reactions_users\n    id = params.require(:id).to_i\n    reaction_value = params[:reaction_value]\n    post = Post.find_by(id: id)\n\n    raise Discourse::InvalidParameters if !post\n\n    reaction_users = []\n\n    likes =\n      post.post_actions.where(\n        \"deleted_at IS NULL AND post_action_type_id = ?\",\n        PostActionType.types[:like],\n      ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n    if likes.present?\n      main_reaction =\n        DiscourseReactions::Reaction.find_by(\n          reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n          post_id: post.id,\n        )\n      count = likes.length\n      users = format_likes_users(likes)\n\n      if main_reaction && main_reaction[:reaction_users_count]\n        (users << get_users(main_reaction)).flatten!\n        users.sort_by! { |user| user[:created_at] }\n        count += main_reaction.reaction_users_count.to_i\n      end\n\n      reaction_users << {\n        id: DiscourseReactions::Reaction.main_reaction_id,\n        count: count,\n        users: users.reverse.slice(0, MAX_USERS_COUNT + 1),\n      }\n    end\n\n    if !reaction_value\n      post\n        .reactions\n        .select do |reaction|\n          reaction[:reaction_users_count] &&\n            reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id\n        end\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n      post\n        .reactions\n        .where(reaction_value: reaction_value)\n        .select { |reaction| reaction[:reaction_users_count] }\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    end\n\n    render_json_dump(reaction_users: reaction_users)\n  end\n\n  private\n\n  def get_users(reaction)\n    reaction\n      .reaction_users\n      .includes(:user)\n      .order(\"discourse_reactions_reaction_users.created_at desc\")\n      .limit(MAX_USERS_COUNT + 1)\n      .map do |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s,\n        }\n      end\n  end\n\n  def post_serializer(post)\n    PostSerializer.new(post, scope: guardian, root: false)\n  end\n\n  def format_reaction_user(reaction)\n    {\n      id: reaction.reaction_value,\n      count: reaction.reaction_users_count.to_i,\n      users: get_users(reaction),\n    }\n  end\n\n  def format_like_user(like)\n    {\n      username: like.user.username,\n      name: like.user.name,\n      avatar_template: like.user.avatar_template,\n      can_undo: guardian.can_delete_post_action?(like),\n      created_at: like.created_at.to_s,\n    }\n  end\n\n  def format_likes_users(likes)\n    likes.includes([:user]).limit(MAX_USERS_COUNT + 1).map { |like| format_like_user(like) }\n  end\n\n  def fetch_post_from_params\n    post = Post.find(params[:post_id])\n    guardian.ensure_can_see!(post)\n    post\n  end\n\n  def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil)\n    MessageBus.publish(\n      \"/topic/#{post.topic.id}/reactions\",\n      post_id: post.id,\n      reactions: [reaction, previous_reaction].compact.uniq,\n    )\n  end\n\n  def secure_reaction_users!(reaction_users)\n    builder = DB.build(\"/*where*/\")\n    UserAction.filter_private_messages(builder, current_user.id, guardian)\n    UserAction.filter_categories(builder, guardian)\n    reaction_users.where(builder.to_sql.delete_prefix(\"/*where*/\").delete_prefix(\"WHERE\"))\n  end\n\n  def translate_to_reactions(likes)\n    likes.map do |like|\n      DiscourseReactions::ReactionUser.new(\n        id: like.id,\n        post: like.post,\n        user: like.user,\n        created_at: like.created_at,\n        reaction:\n          DiscourseReactions::Reaction.new(\n            id: like.id,\n            reaction_type: \"emoji\",\n            post_id: like.post_id,\n            reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n            created_at: like.created_at,\n            reaction_users_count: 1,\n          ),\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# name: discourse-reactions\n# about: Allows users to react with emojis to a post\n# version: 0.2\n# author: Ahmed Gagan, Rafael dos Santos Silva, Kris Aubuchon, Joffrey Jaffeux, Kris Kotlarek, Jordan Vidrine\n# url: https://github.com/discourse/discourse-reactions\n# transpile_js: true\n\nenabled_site_setting :discourse_reactions_enabled\n\nregister_asset \"stylesheets/common/discourse-reactions.scss\"\nregister_asset \"stylesheets/desktop/discourse-reactions.scss\", :desktop\nregister_asset \"stylesheets/mobile/discourse-reactions.scss\", :mobile\n\nregister_svg_icon \"fas fa-star\"\nregister_svg_icon \"far fa-star\"\n\nrequire_relative \"lib/reaction_for_like_site_setting_enum.rb\"\n\nafter_initialize do\n  SeedFu.fixture_paths << Rails.root.join(\"plugins\", \"discourse-reactions\", \"db\", \"fixtures\").to_s\n\n  module ::DiscourseReactions\n    PLUGIN_NAME ||= \"discourse-reactions\"\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace DiscourseReactions\n    end\n  end\n\n  %w[\n    app/controllers/discourse_reactions/custom_reactions_controller.rb\n    app/models/discourse_reactions/reaction_user.rb\n    app/models/discourse_reactions/reaction.rb\n    app/serializers/user_reaction_serializer.rb\n    app/services/discourse_reactions/reaction_manager.rb\n    app/services/discourse_reactions/reaction_notification.rb\n    lib/discourse_reactions/guardian_extension.rb\n    lib/discourse_reactions/notification_extension.rb\n    lib/discourse_reactions/post_alerter_extension.rb\n    lib/discourse_reactions/post_extension.rb\n    lib/discourse_reactions/topic_view_serializer_extension.rb\n  ].each { |path| require_relative path }\n\n  reloadable_patch do |plugin|\n    Post.class_eval { prepend DiscourseReactions::PostExtension }\n    TopicViewSerializer.class_eval { prepend DiscourseReactions::TopicViewSerializerExtension }\n    PostAlerter.class_eval { prepend DiscourseReactions::PostAlerterExtension }\n    Guardian.class_eval { prepend DiscourseReactions::GuardianExtension }\n    Notification.singleton_class.class_eval { prepend DiscourseReactions::NotificationExtension }\n  end\n\n  Discourse::Application.routes.append { mount ::DiscourseReactions::Engine, at: \"/\" }\n\n  DiscourseReactions::Engine.routes.draw do\n    get \"/discourse-reactions/custom-reactions\" => \"custom_reactions#index\",\n        :constraints => {\n          format: :json,\n        }\n    put \"/discourse-reactions/posts/:post_id/custom-reactions/:reaction/toggle\" =>\n          \"custom_reactions#toggle\",\n        :constraints => {\n          format: :json,\n        }\n    get \"/discourse-reactions/posts/reactions\" => \"custom_reactions#reactions_given\",\n        :as => \"reactions_given\"\n    get \"/discourse-reactions/posts/reactions-received\" => \"custom_reactions#reactions_received\",\n        :as => \"reactions_received\"\n    get \"/discourse-reactions/posts/:id/reactions-users\" => \"custom_reactions#post_reactions_users\",\n        :as => \"post_reactions_users\"\n  end\n\n  add_to_serializer(:post, :reactions) do\n    reactions =\n      object\n        .emoji_reactions\n        .select { |reaction| reaction[:reaction_users_count] }\n        .map do |reaction|\n          {\n            id: reaction.reaction_value,\n            type: reaction.reaction_type.to_sym,\n            count: reaction.reaction_users_count,\n          }\n        end\n\n    likes =\n      object.post_actions.select do |l|\n        l.post_action_type_id == PostActionType.types[:like] && l.deleted_at.blank?\n      end\n\n    return reactions.sort_by { |reaction| [-reaction[:count].to_i, reaction[:id]] } if likes.blank?\n\n    reaction_likes, reactions =\n      reactions.partition { |r| r[:id] == DiscourseReactions::Reaction.main_reaction_id }\n\n    reactions << {\n      id: DiscourseReactions::Reaction.main_reaction_id,\n      type: :emoji,\n      count: likes.size + reaction_likes.sum { |r| r[:count] },\n    }\n\n    reactions.sort_by { |reaction| [-reaction[:count].to_i, reaction[:id]] }\n  end\n\n  add_to_serializer(:post, :current_user_reaction) do\n    return nil unless scope.user.present?\n\n    object.emoji_reactions.each do |reaction|\n      reaction_user = reaction.reaction_users.find { |ru| ru.user_id == scope.user.id }\n\n      next unless reaction_user\n\n      if reaction.reaction_users_count\n        return(\n          {\n            id: reaction.reaction_value,\n            type: reaction.reaction_type.to_sym,\n            can_undo: reaction_user.can_undo?,\n          }\n        )\n      end\n    end\n\n    like =\n      object.post_actions.find do |l|\n        l.post_action_type_id == PostActionType.types[:like] && l.deleted_at.blank? &&\n          l.user_id == scope.user.id\n      end\n\n    return nil if like.blank?\n\n    like_reaction = {\n      id: DiscourseReactions::Reaction.main_reaction_id,\n      type: :emoji,\n      can_undo: scope.can_delete_post_action?(like),\n    }\n  end\n\n  add_to_serializer(:post, :reaction_users_count) do\n    return object.reaction_users_count unless object.reaction_users_count.nil?\n    TopicViewSerializer.posts_reaction_users_count(object.id)[object.id]\n  end\n\n  add_to_serializer(:post, :current_user_used_main_reaction) do\n    return false unless scope.user.present?\n\n    object.post_actions.any? do |l|\n      l.post_action_type_id == PostActionType.types[:like] && l.user_id == scope.user.id &&\n        l.deleted_at.blank?\n    end\n  end\n\n  add_to_serializer(:topic_view, :valid_reactions) { DiscourseReactions::Reaction.valid_reactions }\n\n  add_model_callback(User, :before_destroy) do\n    DiscourseReactions::ReactionUser.where(user_id: self.id).delete_all\n  end\n\n  add_report(\"reactions\") do |report|\n    main_id = DiscourseReactions::Reaction.main_reaction_id\n    count_relation = ->(relation, start_date) do\n      relation\n        .where(\"created_at >= ?\", start_date)\n        .where(\"created_at <= ?\", start_date + 1.day)\n        .count\n    end\n\n    report.icon = \"discourse-emojis\"\n    report.modes = [:table]\n\n    report.data = []\n\n    report.labels = [\n      { type: :date, property: :day, title: I18n.t(\"reports.reactions.labels.day\") },\n      {\n        type: :number,\n        property: :like_count,\n        html_title: PrettyText.unescape_emoji(CGI.escapeHTML(\":#{main_id}:\")),\n      },\n    ]\n\n    reactions = SiteSetting.discourse_reactions_enabled_reactions.split(\"|\") - [main_id]\n\n    reactions.each do |reaction|\n      report.labels << {\n        type: :number,\n        property: \"#{reaction}_count\",\n        html_title: PrettyText.unescape_emoji(CGI.escapeHTML(\":#{reaction}:\")),\n      }\n    end\n\n    reactions_results =\n      DB.query(<<~SQL, start_date: report.start_date.to_date, end_date: report.end_date.to_date)\n      SELECT\n        drr.reaction_value,\n        count(drru.id) as reactions_count,\n        date_trunc('day', drru.created_at)::date as day\n      FROM discourse_reactions_reactions as drr\n      LEFT OUTER JOIN discourse_reactions_reaction_users as drru on drr.id = drru.reaction_id\n      WHERE drr.reaction_users_count IS NOT NULL\n        AND drru.created_at >= :start_date::DATE AND drru.created_at <= :end_date::DATE\n      GROUP BY drr.reaction_value, day\n    SQL\n\n    likes_results =\n      DB.query(\n        <<~SQL,\n      SELECT\n        count(pa.id) as likes_count,\n        date_trunc('day', pa.created_at)::date as day\n      FROM post_actions as pa\n      WHERE pa.post_action_type_id = :likes\n      AND pa.created_at >= :start_date::DATE AND pa.created_at <= :end_date::DATE\n      GROUP BY day\n    SQL\n        start_date: report.start_date.to_date,\n        end_date: report.end_date.to_date,\n        likes: PostActionType.types[:like],\n      )\n\n    (report.start_date.to_date..report.end_date.to_date).each do |date|\n      data = { day: date }\n\n      like_count = 0\n      like_reaction_count = 0\n      likes_results.select { |r| r.day == date }.each { |result| like_count += result.likes_count }\n\n      reactions_results\n        .select { |r| r.day == date }\n        .each do |result|\n          if result.reaction_value == main_id\n            like_reaction_count += result.reactions_count\n          else\n            data[\"#{result.reaction_value}_count\"] ||= 0\n            data[\"#{result.reaction_value}_count\"] += result.reactions_count\n          end\n        end\n\n      data[:like_count] = like_reaction_count + like_count\n\n      report.data << data\n    end\n  end\n\n  field_key = \"display_username\"\n  consolidated_reactions =\n    Notifications::ConsolidateNotifications\n      .new(\n        from: Notification.types[:reaction],\n        to: Notification.types[:reaction],\n        threshold: -> { SiteSetting.notification_consolidation_threshold },\n        consolidation_window: SiteSetting.likes_notification_consolidation_window_mins.minutes,\n        unconsolidated_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(\n              \"data::json ->> 'username2' IS NULL AND data::json ->> 'consolidated' IS NULL\",\n            ).where(\"data::json ->> '#{field_key}' = ?\", data[field_key.to_sym].to_s)\n          end,\n        consolidated_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(\"(data::json ->> 'consolidated')::bool\").where(\n              \"data::json ->> '#{field_key}' = ?\",\n              data[field_key.to_sym].to_s,\n            )\n          end,\n      )\n      .set_mutations(\n        set_data_blk:\n          Proc.new do |notification|\n            data = notification.data_hash\n            data.merge(username: data[:display_username], consolidated: true)\n          end,\n      )\n      .set_precondition(precondition_blk: Proc.new { |data| data[:username2].blank? })\n\n  consolidated_reactions.before_consolidation_callbacks(\n    before_consolidation_blk:\n      Proc.new do |notifications, data|\n        new_icon = data[:reaction_icon]\n\n        if new_icon\n          icons = notifications.pluck(\"data::json ->> 'reaction_icon'\")\n\n          data.delete(:reaction_icon) if icons.any? { |i| i != new_icon }\n        end\n      end,\n    before_update_blk:\n      Proc.new do |consolidated, updated_data, notification|\n        if consolidated.data_hash[:reaction_icon] != notification.data_hash[:reaction_icon]\n          updated_data.delete(:reaction_icon)\n        end\n      end,\n  )\n\n  reacted_by_two_users =\n    Notifications::DeletePreviousNotifications\n      .new(\n        type: Notification.types[:reaction],\n        previous_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(id: data[:previous_notification_id])\n          end,\n      )\n      .set_mutations(\n        set_data_blk:\n          Proc.new do |notification|\n            existing_notification_of_same_type =\n              Notification\n                .where(user: notification.user)\n                .order(\"notifications.id DESC\")\n                .where(topic_id: notification.topic_id, post_number: notification.post_number)\n                .where(notification_type: notification.notification_type)\n                .where(\"created_at > ?\", 1.day.ago)\n                .first\n\n            data = notification.data_hash\n            if existing_notification_of_same_type\n              same_type_data = existing_notification_of_same_type.data_hash\n\n              new_data =\n                data.merge(\n                  previous_notification_id: existing_notification_of_same_type.id,\n                  username2: same_type_data[:display_username],\n                  count: (same_type_data[:count] || 1).to_i + 1,\n                )\n\n              new_data\n            else\n              data\n            end\n          end,\n      )\n      .set_precondition(\n        precondition_blk:\n          Proc.new do |data, notification|\n            always_freq = UserOption.like_notification_frequency_type[:always]\n\n            notification.user&.user_option&.like_notification_frequency == always_freq &&\n              data[:previous_notification_id].present?\n          end,\n      )\n\n  register_notification_consolidation_plan(reacted_by_two_users)\n  register_notification_consolidation_plan(consolidated_reactions)\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:like) do\n    Fabricate(\n      :post_action,\n      post: post_2,\n      user: user_5,\n      post_action_type_id: PostActionType.types[:like],\n    )\n  end\n  fab!(:reaction_user_1) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2)\n  end\n  fab!(:reaction_user_2) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2)\n  end\n  fab!(:reaction_user_3) do\n    Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2)\n  end\n  fab!(:reaction_user_4) do\n    Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2)\n  end\n\n  before do\n    SiteSetting.discourse_reactions_enabled = true\n    SiteSetting.discourse_reactions_like_icon = \"heart\"\n    SiteSetting.discourse_reactions_enabled_reactions =\n      \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  describe \"#toggle\" do\n    let(:payload_with_user) { [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }] }\n\n    it \"toggles reaction\" do\n      sign_in(user_1)\n      expected_payload = [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to not_change { DiscourseReactions::Reaction.count }.and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq([])\n    end\n\n    it \"publishes MessageBus messages\" do\n      sign_in(user_1)\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i[acted])\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\")\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/angry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\", \"angry\")\n    end\n\n    it \"errors when reaction is invalid\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.not_to change { DiscourseReactions::Reaction.count }\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  describe \"#reactions_given\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2) }\n    fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n    fab!(:secure_group) { Fabricate(:group) }\n    fab!(:secure_category) { Fabricate(:private_category, group: secure_group) }\n    fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n    fab!(:secure_post) { Fabricate(:post, topic: secure_topic) }\n    fab!(:private_reaction) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n    fab!(:secure_reaction) { Fabricate(:reaction, post: secure_post, reaction_value: \"hugs\") }\n    fab!(:private_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: private_reaction, user: user_2, post: private_post)\n    end\n    fab!(:secure_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: secure_reaction, user: user_2, post: secure_post)\n    end\n\n    it \"returns reactions given by a user\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_2.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_1.id)\n    end\n\n    it \"does not return reactions for private messages\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        private_post.id,\n      )\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(\n        private_post.id,\n      )\n    end\n\n    it \"does not return reactions for secure categories\" do\n      secure_group.add(user_2)\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        secure_post.id,\n      )\n\n      secure_group.add(user_1)\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n    end\n\n    describe \"a post with one of your reactions has been deleted\" do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) do\n        Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_on_kept_post) do\n        Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_user_on_deleted_post) do\n        Fabricate(\n          :reaction_user,\n          reaction: reaction_on_deleted_post,\n          user: user,\n          post: deleted_post,\n        )\n      end\n      fab!(:reaction_user_on_kept_post) do\n        Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post)\n      end\n\n      it \"doesn\u2019t return the deleted post/reaction\" do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"post_id\"]).to eq(kept_post.id)\n      end\n    end\n\n    context \"when op containing reactions is destroyed\" do\n      fab!(:topic) { create_topic }\n      fab!(:op) { Fabricate(:post, topic: topic) }\n\n      it \"doesn\u2019t return the reactions from deleted topic\" do\n        deleted_topic_id = topic.id\n        sign_in(user_1)\n        put \"/discourse-reactions/posts/#{op.id}/custom-reactions/hugs/toggle.json\"\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        expect(response.parsed_body.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, op).destroy\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"topic_id\"]).to_not eq(deleted_topic_id)\n      end\n    end\n  end\n\n  describe \"#reactions_received\" do\n    it \"returns reactions received by a user\" do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_3.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_2.id)\n    end\n\n    it \"filters by acting username\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            acting_username: user_4.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_4.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_3.id)\n    end\n\n    it \"include likes\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"also filter likes by id when including likes\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_5,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n            before_like_id: latest_like.id,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"filters likes by username\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_4,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n  end\n\n  describe \"#post_reactions_users\" do\n    it \"return reaction_users of post when theres no parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_5.avatar_template,\n      )\n    end\n\n    it \"return reaction_users of reaction when there are parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_1.avatar_template,\n      )\n    end\n\n    it \"gives 400 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(400)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(400)\n    end\n\n    it \"merges identic custom reaction into likes\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = \"laughing\"\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n  end\n\n  describe \"positive notifications\" do\n    before { PostActionNotifier.enable }\n\n    it \"creates notification when first like\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1).and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1).and change { PostAction.count }.by(-1)\n    end\n  end\n\n  describe \"reaction notifications\" do\n    it \"calls ReactinNotification service\" do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it \"allows to delete reaction only in undo action window frame\" do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to not_change { DiscourseReactions::Reaction.count }.and not_change {\n            DiscourseReactions::ReactionUser.count\n          }\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass DiscourseReactions::CustomReactionsController < ApplicationController\n  MAX_USERS_COUNT = 26\n\n  requires_plugin DiscourseReactions::PLUGIN_NAME\n\n  before_action :ensure_logged_in, except: [:post_reactions_users]\n\n  def toggle\n    post = fetch_post_from_params\n\n    unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n      return render_json_error(post)\n    end\n\n    begin\n      manager =\n        DiscourseReactions::ReactionManager.new(\n          reaction_value: params[:reaction],\n          user: current_user,\n          guardian: guardian,\n          post: post,\n        )\n      manager.toggle!\n    rescue ActiveRecord::RecordNotUnique\n      # If the user already performed this action, it's probably due to a different browser tab\n      # or non-debounced clicking. We can ignore.\n    end\n\n    post.publish_change_to_clients!(:acted)\n    publish_change_to_clients!(\n      post,\n      reaction: manager.reaction_value,\n      previous_reaction: manager.previous_reaction_value,\n    )\n\n    render_json_dump(post_serializer(post).as_json)\n  end\n\n  def reactions_given\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction, :post)\n        .joins(\"INNER JOIN topics t ON t.id = posts.topic_id AND t.deleted_at IS NULL\")\n        .joins(\"LEFT JOIN categories c ON c.id = t.category_id\")\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    reaction_users = secure_reaction_users!(reaction_users)\n\n    if params[:before_reaction_user_id]\n      reaction_users =\n        reaction_users.where(\n          \"discourse_reactions_reaction_users.id < ?\",\n          params[:before_reaction_user_id].to_i,\n        )\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20)\n\n    render_serialized(reaction_users.to_a, UserReactionSerializer)\n  end\n\n  def reactions_received\n    params.require(:username)\n    user =\n      fetch_user_from_params(\n        include_inactive:\n          current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts),\n      )\n    raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n    posts = Post.joins(:topic).where(user_id: user.id)\n    posts = guardian.filter_allowed_categories(posts)\n    post_ids = posts.pluck(:id)\n\n    reaction_users =\n      DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where(\"discourse_reactions_reactions.reaction_users_count IS NOT NULL\")\n\n    # Guarantee backwards compatibility if someone was calling this endpoint with the old param.\n    # TODO(roman): Remove after the 2.9 release.\n    before_reaction_id = params[:before_reaction_user_id]\n    if before_reaction_id.blank? && params[:before_post_id]\n      before_reaction_id = params[:before_post_id]\n    end\n\n    if before_reaction_id\n      reaction_users =\n        reaction_users.where(\"discourse_reactions_reaction_users.id < ?\", before_reaction_id.to_i)\n    end\n\n    if params[:acting_username]\n      reaction_users =\n        reaction_users.joins(:user).where(users: { username: params[:acting_username] })\n    end\n\n    reaction_users = reaction_users.order(created_at: :desc).limit(20).to_a\n\n    if params[:include_likes]\n      likes =\n        PostAction\n          .where(\n            post_id: post_ids,\n            deleted_at: nil,\n            post_action_type_id: PostActionType.types[:like],\n          )\n          .order(created_at: :desc)\n          .limit(20)\n\n      if params[:before_like_id]\n        likes = likes.where(\"post_actions.id < ?\", params[:before_like_id].to_i)\n      end\n\n      if params[:acting_username]\n        likes = likes.joins(:user).where(users: { username: params[:acting_username] })\n      end\n\n      reaction_users = reaction_users.concat(translate_to_reactions(likes))\n      reaction_users = reaction_users.sort { |a, b| b.created_at <=> a.created_at }\n    end\n\n    render_serialized reaction_users.first(20), UserReactionSerializer\n  end\n\n  def post_reactions_users\n    id = params.require(:id).to_i\n    reaction_value = params[:reaction_value]\n    post = fetch_post_from_params\n\n    raise Discourse::InvalidParameters if !post\n\n    reaction_users = []\n\n    likes =\n      post.post_actions.where(\n        \"deleted_at IS NULL AND post_action_type_id = ?\",\n        PostActionType.types[:like],\n      ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n    if likes.present?\n      main_reaction =\n        DiscourseReactions::Reaction.find_by(\n          reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n          post_id: post.id,\n        )\n      count = likes.length\n      users = format_likes_users(likes)\n\n      if main_reaction && main_reaction[:reaction_users_count]\n        (users << get_users(main_reaction)).flatten!\n        users.sort_by! { |user| user[:created_at] }\n        count += main_reaction.reaction_users_count.to_i\n      end\n\n      reaction_users << {\n        id: DiscourseReactions::Reaction.main_reaction_id,\n        count: count,\n        users: users.reverse.slice(0, MAX_USERS_COUNT + 1),\n      }\n    end\n\n    if !reaction_value\n      post\n        .reactions\n        .select do |reaction|\n          reaction[:reaction_users_count] &&\n            reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id\n        end\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n      post\n        .reactions\n        .where(reaction_value: reaction_value)\n        .select { |reaction| reaction[:reaction_users_count] }\n        .each { |reaction| reaction_users << format_reaction_user(reaction) }\n    end\n\n    render_json_dump(reaction_users: reaction_users)\n  end\n\n  private\n\n  def get_users(reaction)\n    reaction\n      .reaction_users\n      .includes(:user)\n      .order(\"discourse_reactions_reaction_users.created_at desc\")\n      .limit(MAX_USERS_COUNT + 1)\n      .map do |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s,\n        }\n      end\n  end\n\n  def post_serializer(post)\n    PostSerializer.new(post, scope: guardian, root: false)\n  end\n\n  def format_reaction_user(reaction)\n    {\n      id: reaction.reaction_value,\n      count: reaction.reaction_users_count.to_i,\n      users: get_users(reaction),\n    }\n  end\n\n  def format_like_user(like)\n    {\n      username: like.user.username,\n      name: like.user.name,\n      avatar_template: like.user.avatar_template,\n      can_undo: guardian.can_delete_post_action?(like),\n      created_at: like.created_at.to_s,\n    }\n  end\n\n  def format_likes_users(likes)\n    likes.includes([:user]).limit(MAX_USERS_COUNT + 1).map { |like| format_like_user(like) }\n  end\n\n  def fetch_post_from_params\n    post_id = params[:post_id] || params[:id]\n    post = Post.find(post_id)\n    guardian.ensure_can_see!(post)\n    post\n  end\n\n  def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil)\n    message = { post_id: post.id, reactions: [reaction, previous_reaction].compact.uniq }\n\n    opts = {}\n    secure_audience = post.topic.secure_audience_publish_messages\n    opts = secure_audience if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != []\n\n    MessageBus.publish(\"/topic/#{post.topic.id}/reactions\", message, opts)\n  end\n\n  def secure_reaction_users!(reaction_users)\n    builder = DB.build(\"/*where*/\")\n    UserAction.filter_private_messages(builder, current_user.id, guardian)\n    UserAction.filter_categories(builder, guardian)\n    reaction_users.where(builder.to_sql.delete_prefix(\"/*where*/\").delete_prefix(\"WHERE\"))\n  end\n\n  def translate_to_reactions(likes)\n    likes.map do |like|\n      DiscourseReactions::ReactionUser.new(\n        id: like.id,\n        post: like.post,\n        user: like.user,\n        created_at: like.created_at,\n        reaction:\n          DiscourseReactions::Reaction.new(\n            id: like.id,\n            reaction_type: \"emoji\",\n            post_id: like.post_id,\n            reaction_value: DiscourseReactions::Reaction.main_reaction_id,\n            created_at: like.created_at,\n            reaction_users_count: 1,\n          ),\n      )\n    end\n  end\nend\n", "# frozen_string_literal: true\n\n# name: discourse-reactions\n# about: Allows users to react with emojis to a post\n# version: 0.3\n# author: Ahmed Gagan, Rafael dos Santos Silva, Kris Aubuchon, Joffrey Jaffeux, Kris Kotlarek, Jordan Vidrine\n# url: https://github.com/discourse/discourse-reactions\n# transpile_js: true\n\nenabled_site_setting :discourse_reactions_enabled\n\nregister_asset \"stylesheets/common/discourse-reactions.scss\"\nregister_asset \"stylesheets/desktop/discourse-reactions.scss\", :desktop\nregister_asset \"stylesheets/mobile/discourse-reactions.scss\", :mobile\n\nregister_svg_icon \"fas fa-star\"\nregister_svg_icon \"far fa-star\"\n\nrequire_relative \"lib/reaction_for_like_site_setting_enum.rb\"\n\nafter_initialize do\n  SeedFu.fixture_paths << Rails.root.join(\"plugins\", \"discourse-reactions\", \"db\", \"fixtures\").to_s\n\n  module ::DiscourseReactions\n    PLUGIN_NAME ||= \"discourse-reactions\"\n\n    class Engine < ::Rails::Engine\n      engine_name PLUGIN_NAME\n      isolate_namespace DiscourseReactions\n    end\n  end\n\n  %w[\n    app/controllers/discourse_reactions/custom_reactions_controller.rb\n    app/models/discourse_reactions/reaction_user.rb\n    app/models/discourse_reactions/reaction.rb\n    app/serializers/user_reaction_serializer.rb\n    app/services/discourse_reactions/reaction_manager.rb\n    app/services/discourse_reactions/reaction_notification.rb\n    lib/discourse_reactions/guardian_extension.rb\n    lib/discourse_reactions/notification_extension.rb\n    lib/discourse_reactions/post_alerter_extension.rb\n    lib/discourse_reactions/post_extension.rb\n    lib/discourse_reactions/topic_view_serializer_extension.rb\n  ].each { |path| require_relative path }\n\n  reloadable_patch do |plugin|\n    Post.class_eval { prepend DiscourseReactions::PostExtension }\n    TopicViewSerializer.class_eval { prepend DiscourseReactions::TopicViewSerializerExtension }\n    PostAlerter.class_eval { prepend DiscourseReactions::PostAlerterExtension }\n    Guardian.class_eval { prepend DiscourseReactions::GuardianExtension }\n    Notification.singleton_class.class_eval { prepend DiscourseReactions::NotificationExtension }\n  end\n\n  Discourse::Application.routes.append { mount ::DiscourseReactions::Engine, at: \"/\" }\n\n  DiscourseReactions::Engine.routes.draw do\n    get \"/discourse-reactions/custom-reactions\" => \"custom_reactions#index\",\n        :constraints => {\n          format: :json,\n        }\n    put \"/discourse-reactions/posts/:post_id/custom-reactions/:reaction/toggle\" =>\n          \"custom_reactions#toggle\",\n        :constraints => {\n          format: :json,\n        }\n    get \"/discourse-reactions/posts/reactions\" => \"custom_reactions#reactions_given\",\n        :as => \"reactions_given\"\n    get \"/discourse-reactions/posts/reactions-received\" => \"custom_reactions#reactions_received\",\n        :as => \"reactions_received\"\n    get \"/discourse-reactions/posts/:id/reactions-users\" => \"custom_reactions#post_reactions_users\",\n        :as => \"post_reactions_users\"\n  end\n\n  add_to_serializer(:post, :reactions) do\n    reactions =\n      object\n        .emoji_reactions\n        .select { |reaction| reaction[:reaction_users_count] }\n        .map do |reaction|\n          {\n            id: reaction.reaction_value,\n            type: reaction.reaction_type.to_sym,\n            count: reaction.reaction_users_count,\n          }\n        end\n\n    likes =\n      object.post_actions.select do |l|\n        l.post_action_type_id == PostActionType.types[:like] && l.deleted_at.blank?\n      end\n\n    return reactions.sort_by { |reaction| [-reaction[:count].to_i, reaction[:id]] } if likes.blank?\n\n    reaction_likes, reactions =\n      reactions.partition { |r| r[:id] == DiscourseReactions::Reaction.main_reaction_id }\n\n    reactions << {\n      id: DiscourseReactions::Reaction.main_reaction_id,\n      type: :emoji,\n      count: likes.size + reaction_likes.sum { |r| r[:count] },\n    }\n\n    reactions.sort_by { |reaction| [-reaction[:count].to_i, reaction[:id]] }\n  end\n\n  add_to_serializer(:post, :current_user_reaction) do\n    return nil unless scope.user.present?\n\n    object.emoji_reactions.each do |reaction|\n      reaction_user = reaction.reaction_users.find { |ru| ru.user_id == scope.user.id }\n\n      next unless reaction_user\n\n      if reaction.reaction_users_count\n        return(\n          {\n            id: reaction.reaction_value,\n            type: reaction.reaction_type.to_sym,\n            can_undo: reaction_user.can_undo?,\n          }\n        )\n      end\n    end\n\n    like =\n      object.post_actions.find do |l|\n        l.post_action_type_id == PostActionType.types[:like] && l.deleted_at.blank? &&\n          l.user_id == scope.user.id\n      end\n\n    return nil if like.blank?\n\n    like_reaction = {\n      id: DiscourseReactions::Reaction.main_reaction_id,\n      type: :emoji,\n      can_undo: scope.can_delete_post_action?(like),\n    }\n  end\n\n  add_to_serializer(:post, :reaction_users_count) do\n    return object.reaction_users_count unless object.reaction_users_count.nil?\n    TopicViewSerializer.posts_reaction_users_count(object.id)[object.id]\n  end\n\n  add_to_serializer(:post, :current_user_used_main_reaction) do\n    return false unless scope.user.present?\n\n    object.post_actions.any? do |l|\n      l.post_action_type_id == PostActionType.types[:like] && l.user_id == scope.user.id &&\n        l.deleted_at.blank?\n    end\n  end\n\n  add_to_serializer(:topic_view, :valid_reactions) { DiscourseReactions::Reaction.valid_reactions }\n\n  add_model_callback(User, :before_destroy) do\n    DiscourseReactions::ReactionUser.where(user_id: self.id).delete_all\n  end\n\n  add_report(\"reactions\") do |report|\n    main_id = DiscourseReactions::Reaction.main_reaction_id\n    count_relation = ->(relation, start_date) do\n      relation\n        .where(\"created_at >= ?\", start_date)\n        .where(\"created_at <= ?\", start_date + 1.day)\n        .count\n    end\n\n    report.icon = \"discourse-emojis\"\n    report.modes = [:table]\n\n    report.data = []\n\n    report.labels = [\n      { type: :date, property: :day, title: I18n.t(\"reports.reactions.labels.day\") },\n      {\n        type: :number,\n        property: :like_count,\n        html_title: PrettyText.unescape_emoji(CGI.escapeHTML(\":#{main_id}:\")),\n      },\n    ]\n\n    reactions = SiteSetting.discourse_reactions_enabled_reactions.split(\"|\") - [main_id]\n\n    reactions.each do |reaction|\n      report.labels << {\n        type: :number,\n        property: \"#{reaction}_count\",\n        html_title: PrettyText.unescape_emoji(CGI.escapeHTML(\":#{reaction}:\")),\n      }\n    end\n\n    reactions_results =\n      DB.query(<<~SQL, start_date: report.start_date.to_date, end_date: report.end_date.to_date)\n      SELECT\n        drr.reaction_value,\n        count(drru.id) as reactions_count,\n        date_trunc('day', drru.created_at)::date as day\n      FROM discourse_reactions_reactions as drr\n      LEFT OUTER JOIN discourse_reactions_reaction_users as drru on drr.id = drru.reaction_id\n      WHERE drr.reaction_users_count IS NOT NULL\n        AND drru.created_at >= :start_date::DATE AND drru.created_at <= :end_date::DATE\n      GROUP BY drr.reaction_value, day\n    SQL\n\n    likes_results =\n      DB.query(\n        <<~SQL,\n      SELECT\n        count(pa.id) as likes_count,\n        date_trunc('day', pa.created_at)::date as day\n      FROM post_actions as pa\n      WHERE pa.post_action_type_id = :likes\n      AND pa.created_at >= :start_date::DATE AND pa.created_at <= :end_date::DATE\n      GROUP BY day\n    SQL\n        start_date: report.start_date.to_date,\n        end_date: report.end_date.to_date,\n        likes: PostActionType.types[:like],\n      )\n\n    (report.start_date.to_date..report.end_date.to_date).each do |date|\n      data = { day: date }\n\n      like_count = 0\n      like_reaction_count = 0\n      likes_results.select { |r| r.day == date }.each { |result| like_count += result.likes_count }\n\n      reactions_results\n        .select { |r| r.day == date }\n        .each do |result|\n          if result.reaction_value == main_id\n            like_reaction_count += result.reactions_count\n          else\n            data[\"#{result.reaction_value}_count\"] ||= 0\n            data[\"#{result.reaction_value}_count\"] += result.reactions_count\n          end\n        end\n\n      data[:like_count] = like_reaction_count + like_count\n\n      report.data << data\n    end\n  end\n\n  field_key = \"display_username\"\n  consolidated_reactions =\n    Notifications::ConsolidateNotifications\n      .new(\n        from: Notification.types[:reaction],\n        to: Notification.types[:reaction],\n        threshold: -> { SiteSetting.notification_consolidation_threshold },\n        consolidation_window: SiteSetting.likes_notification_consolidation_window_mins.minutes,\n        unconsolidated_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(\n              \"data::json ->> 'username2' IS NULL AND data::json ->> 'consolidated' IS NULL\",\n            ).where(\"data::json ->> '#{field_key}' = ?\", data[field_key.to_sym].to_s)\n          end,\n        consolidated_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(\"(data::json ->> 'consolidated')::bool\").where(\n              \"data::json ->> '#{field_key}' = ?\",\n              data[field_key.to_sym].to_s,\n            )\n          end,\n      )\n      .set_mutations(\n        set_data_blk:\n          Proc.new do |notification|\n            data = notification.data_hash\n            data.merge(username: data[:display_username], consolidated: true)\n          end,\n      )\n      .set_precondition(precondition_blk: Proc.new { |data| data[:username2].blank? })\n\n  consolidated_reactions.before_consolidation_callbacks(\n    before_consolidation_blk:\n      Proc.new do |notifications, data|\n        new_icon = data[:reaction_icon]\n\n        if new_icon\n          icons = notifications.pluck(\"data::json ->> 'reaction_icon'\")\n\n          data.delete(:reaction_icon) if icons.any? { |i| i != new_icon }\n        end\n      end,\n    before_update_blk:\n      Proc.new do |consolidated, updated_data, notification|\n        if consolidated.data_hash[:reaction_icon] != notification.data_hash[:reaction_icon]\n          updated_data.delete(:reaction_icon)\n        end\n      end,\n  )\n\n  reacted_by_two_users =\n    Notifications::DeletePreviousNotifications\n      .new(\n        type: Notification.types[:reaction],\n        previous_query_blk:\n          Proc.new do |notifications, data|\n            notifications.where(id: data[:previous_notification_id])\n          end,\n      )\n      .set_mutations(\n        set_data_blk:\n          Proc.new do |notification|\n            existing_notification_of_same_type =\n              Notification\n                .where(user: notification.user)\n                .order(\"notifications.id DESC\")\n                .where(topic_id: notification.topic_id, post_number: notification.post_number)\n                .where(notification_type: notification.notification_type)\n                .where(\"created_at > ?\", 1.day.ago)\n                .first\n\n            data = notification.data_hash\n            if existing_notification_of_same_type\n              same_type_data = existing_notification_of_same_type.data_hash\n\n              new_data =\n                data.merge(\n                  previous_notification_id: existing_notification_of_same_type.id,\n                  username2: same_type_data[:display_username],\n                  count: (same_type_data[:count] || 1).to_i + 1,\n                )\n\n              new_data\n            else\n              data\n            end\n          end,\n      )\n      .set_precondition(\n        precondition_blk:\n          Proc.new do |data, notification|\n            always_freq = UserOption.like_notification_frequency_type[:always]\n\n            notification.user&.user_option&.like_notification_frequency == always_freq &&\n              data[:previous_notification_id].present?\n          end,\n      )\n\n  register_notification_consolidation_plan(reacted_by_two_users)\n  register_notification_consolidation_plan(consolidated_reactions)\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:admin) { Fabricate(:admin) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2, recipient: admin) }\n  fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:reaction_4) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n  fab!(:like) do\n    Fabricate(\n      :post_action,\n      post: post_2,\n      user: user_5,\n      post_action_type_id: PostActionType.types[:like],\n    )\n  end\n  fab!(:reaction_user_1) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2)\n  end\n  fab!(:reaction_user_2) do\n    Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2)\n  end\n  fab!(:reaction_user_3) do\n    Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2)\n  end\n  fab!(:reaction_user_4) do\n    Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2)\n  end\n  fab!(:reaction_user_5) do\n    Fabricate(:reaction_user, reaction: reaction_4, user: admin, post: private_post)\n  end\n\n  before do\n    SiteSetting.discourse_reactions_enabled = true\n    SiteSetting.discourse_reactions_like_icon = \"heart\"\n    SiteSetting.discourse_reactions_enabled_reactions =\n      \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  describe \"#toggle\" do\n    let(:payload_with_user) { [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }] }\n    let(:api_key) { Fabricate(:api_key, user: admin, created_by: admin) }\n\n    it \"toggles reaction\" do\n      sign_in(user_1)\n      expected_payload = [{ \"id\" => \"hugs\", \"type\" => \"emoji\", \"count\" => 1 }]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq(\"hugs\")\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to not_change { DiscourseReactions::Reaction.count }.and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n              DiscourseReactions::ReactionUser.count\n            }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body[\"reactions\"]).to eq([])\n    end\n\n    it \"publishes MessageBus messages\" do\n      sign_in(user_1)\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i[acted])\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\")\n\n      messages =\n        MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n          put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/angry/toggle.json\"\n        end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n      expect(messages[0].data[:reactions]).to contain_exactly(\"cry\")\n      expect(messages[1].data[:reactions]).to contain_exactly(\"cry\", \"angry\")\n    end\n\n    it \"publishes MessageBus messages securely\" do\n      sign_in(user_1)\n      messages =\n        MessageBus.track_publish(\"/topic/#{private_post.topic.id}/reactions\") do\n          put \"/discourse-reactions/posts/#{private_post.id}/custom-reactions/cry/toggle.json\",\n              headers: {\n                \"HTTP_API_KEY\" => api_key.key,\n                \"HTTP_API_USERNAME\" => api_key.user.username,\n              }\n        end\n      user_1_messages = messages.find { |m| m.user_ids.include?(user_1.id) }\n      expect(messages.count).to eq(1)\n      expect(user_1_messages).to eq(nil)\n    end\n\n    it \"errors when reaction is invalid\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.not_to change { DiscourseReactions::Reaction.count }\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  describe \"#reactions_given\" do\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2) }\n    fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n    fab!(:secure_group) { Fabricate(:group) }\n    fab!(:secure_category) { Fabricate(:private_category, group: secure_group) }\n    fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n    fab!(:secure_post) { Fabricate(:post, topic: secure_topic) }\n    fab!(:private_reaction) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n    fab!(:secure_reaction) { Fabricate(:reaction, post: secure_post, reaction_value: \"hugs\") }\n    fab!(:private_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: private_reaction, user: user_2, post: private_post)\n    end\n    fab!(:secure_topic_reaction_user) do\n      Fabricate(:reaction_user, reaction: secure_reaction, user: user_2, post: secure_post)\n    end\n\n    it \"returns reactions given by a user\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_2.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_1.id)\n    end\n\n    it \"does not return reactions for private messages\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        private_post.id,\n      )\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(\n        private_post.id,\n      )\n    end\n\n    it \"does not return reactions for secure categories\" do\n      secure_group.add(user_2)\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(\n        secure_post.id,\n      )\n\n      secure_group.add(user_1)\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n    end\n\n    describe \"a post with one of your reactions has been deleted\" do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) do\n        Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_on_kept_post) do\n        Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\")\n      end\n      fab!(:reaction_user_on_deleted_post) do\n        Fabricate(\n          :reaction_user,\n          reaction: reaction_on_deleted_post,\n          user: user,\n          post: deleted_post,\n        )\n      end\n      fab!(:reaction_user_on_kept_post) do\n        Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post)\n      end\n\n      it \"doesn\u2019t return the deleted post/reaction\" do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"post_id\"]).to eq(kept_post.id)\n      end\n    end\n\n    context \"when op containing reactions is destroyed\" do\n      fab!(:topic) { create_topic }\n      fab!(:op) { Fabricate(:post, topic: topic) }\n\n      it \"doesn\u2019t return the reactions from deleted topic\" do\n        deleted_topic_id = topic.id\n        sign_in(user_1)\n        put \"/discourse-reactions/posts/#{op.id}/custom-reactions/hugs/toggle.json\"\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        expect(response.parsed_body.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, op).destroy\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user_1.username }\n\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(1)\n        expect(parsed[0][\"topic_id\"]).to_not eq(deleted_topic_id)\n      end\n    end\n  end\n\n  describe \"#reactions_received\" do\n    it \"returns reactions received by a user\" do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_3.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_2.id)\n    end\n\n    it \"filters by acting username\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            acting_username: user_4.username,\n          }\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_4.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(reaction_3.id)\n    end\n\n    it \"include likes\" do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"also filter likes by id when including likes\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_5,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n            before_like_id: latest_like.id,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n\n    it \"filters likes by username\" do\n      latest_like =\n        Fabricate(\n          :post_action,\n          post: post_1,\n          user: user_4,\n          post_action_type_id: PostActionType.types[:like],\n        )\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions-received.json\",\n          params: {\n            username: user_1.username,\n            include_likes: true,\n            acting_username: user_5.username,\n          }\n\n      parsed = response.parsed_body\n\n      expect(parsed.size).to eq(1)\n      expect(parsed[0][\"user\"][\"id\"]).to eq(user_5.id)\n      expect(parsed[0][\"post_id\"]).to eq(post_2.id)\n      expect(parsed[0][\"post\"][\"user\"][\"id\"]).to eq(user_1.id)\n      expect(parsed[0][\"reaction\"][\"id\"]).to eq(like.id)\n    end\n  end\n\n  describe \"#post_reactions_users\" do\n    it \"return reaction_users of post when theres no parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_5.avatar_template,\n      )\n    end\n\n    it \"return reaction_users of reaction when there are parameters\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(\n        user_1.avatar_template,\n      )\n    end\n\n    it \"gives 404 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(404)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(404)\n    end\n\n    it \"merges identic custom reaction into likes\" do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = \"laughing\"\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n\n    it \"does not show reaction_users on PMs without permission\" do\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(403)\n    end\n\n    it \"shows reaction_users on PMs with permission\" do\n      sign_in(user_2)\n      get \"/discourse-reactions/posts/#{private_post.id}/reactions-users.json\"\n      expect(response.status).to eq(200)\n    end\n  end\n\n  describe \"positive notifications\" do\n    before { PostActionNotifier.enable }\n\n    it \"creates notification when first like\" do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1).and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1).and change { PostAction.count }.by(-1)\n    end\n  end\n\n  describe \"reaction notifications\" do\n    it \"calls ReactinNotification service\" do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it \"allows to delete reaction only in undo action window frame\" do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1).and change {\n            DiscourseReactions::ReactionUser.count\n          }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to not_change { DiscourseReactions::Reaction.count }.and not_change {\n            DiscourseReactions::ReactionUser.count\n          }\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "filenames": ["app/controllers/discourse_reactions/custom_reactions_controller.rb", "plugin.rb", "spec/requests/custom_reactions_controller_spec.rb"], "buggy_code_start_loc": [141, 5, 11], "buggy_code_end_loc": [251, 6, 414], "fixing_code_start_loc": [141, 5, 12], "fixing_code_end_loc": [254, 6, 449], "type": "NVD-CWE-noinfo", "message": "Discourse-reactions is a plugin that allows user to add their reactions to the post in the Discourse messaging platform. In affected versions data about what reactions were performed on a post in a private topic could be leaked. This issue has been addressed in version 0.3. Users are advised to upgrade. Users unable to upgrade should disable the discourse-reactions plugin to fully mitigate the issue.", "other": {"cve": {"id": "CVE-2023-30611", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-19T18:15:07.490", "lastModified": "2023-05-01T18:12:23.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse-reactions is a plugin that allows user to add their reactions to the post in the Discourse messaging platform. In affected versions data about what reactions were performed on a post in a private topic could be leaked. This issue has been addressed in version 0.3. Users are advised to upgrade. Users unable to upgrade should disable the discourse-reactions plugin to fully mitigate the issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:reactions:0.2:*:*:*:*:*:*:*", "matchCriteriaId": "9EE39066-079F-4C5A-89ED-36279E53A69C"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-reactions/commit/01aca15b2774c088f3673118e92e9469f37d2fb6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/discourse/discourse-reactions/security/advisories/GHSA-4cgc-c7vh-94g6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-reactions/commit/01aca15b2774c088f3673118e92e9469f37d2fb6"}}