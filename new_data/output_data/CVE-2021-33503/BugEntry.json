{"buggy_code": ["from __future__ import absolute_import\n\nimport re\nfrom collections import namedtuple\n\nfrom ..exceptions import LocationParseError\nfrom ..packages import six\n\nurl_attrs = [\"scheme\", \"auth\", \"host\", \"port\", \"path\", \"query\", \"fragment\"]\n\n# We only want to normalize urls with an HTTP(S) scheme.\n# urllib3 infers URLs without a scheme (None) to be http.\nNORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\nPERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\nSCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\nURI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n\nIPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\nHEX_PAT = \"[0-9A-Fa-f]{1,4}\"\nLS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=HEX_PAT, ipv4=IPV4_PAT)\n_subs = {\"hex\": HEX_PAT, \"ls32\": LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s\",\n    # [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    \"(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s\",\n    # [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    \"(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s\",\n    # [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    \"(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s\",\n    # [ *6( h16 \":\" ) h16 ] \"::\"\n    \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",\n]\n\nUNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._!\\-~\"\nIPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\nZONE_ID_PAT = \"(?:%25|%)(?:[\" + UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\nIPV6_ADDRZ_PAT = r\"\\[\" + IPV6_PAT + r\"(?:\" + ZONE_ID_PAT + r\")?\\]\"\nREG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\nTARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n\nIPV4_RE = re.compile(\"^\" + IPV4_PAT + \"$\")\nIPV6_RE = re.compile(\"^\" + IPV6_PAT + \"$\")\nIPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT + \"$\")\nBRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT[2:-2] + \"$\")\nZONE_ID_RE = re.compile(\"(\" + ZONE_ID_PAT + r\")\\]$\")\n\nSUBAUTHORITY_PAT = (u\"^(?:(.*)@)?(%s|%s|%s)(?::([0-9]{0,5}))?$\") % (\n    REG_NAME_PAT,\n    IPV4_PAT,\n    IPV6_ADDRZ_PAT,\n)\nSUBAUTHORITY_RE = re.compile(SUBAUTHORITY_PAT, re.UNICODE | re.DOTALL)\n\nUNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\nSUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\nUSERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {\":\"}\nPATH_CHARS = USERINFO_CHARS | {\"@\", \"/\"}\nQUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {\"?\"}\n\n\nclass Url(namedtuple(\"Url\", url_attrs)):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls,\n        scheme=None,\n        auth=None,\n        host=None,\n        port=None,\n        path=None,\n        query=None,\n        fragment=None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super(Url, cls).__new__(\n            cls, scheme, auth, host, port, path, query, fragment\n        )\n\n    @property\n    def hostname(self):\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self):\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def netloc(self):\n        \"\"\"Network location including host and port\"\"\"\n        if self.port:\n            return \"%s:%d\" % (self.host, self.port)\n        return self.host\n\n    @property\n    def url(self):\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example: ::\n\n            >>> U = parse_url('http://google.com/mail/')\n            >>> U.url\n            'http://google.com/mail/'\n            >>> Url('http', 'username:password', 'host.com', 80,\n            ... '/path', 'query', 'fragment').url\n            'http://username:password@host.com:80/path?query#fragment'\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = u\"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + u\"://\"\n        if auth is not None:\n            url += auth + u\"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += u\":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += u\"?\" + query\n        if fragment is not None:\n            url += u\"#\" + fragment\n\n        return url\n\n    def __str__(self):\n        return self.url\n\n\ndef split_first(s, delims):\n    \"\"\"\n    .. deprecated:: 1.25\n\n    Given a string and an iterable of delimiters, split on the first found\n    delimiter. Return two split parts and the matched delimiter.\n\n    If not found, then the first part is the full input string.\n\n    Example::\n\n        >>> split_first('foo/bar?baz', '?/=')\n        ('foo', 'bar?baz', '/')\n        >>> split_first('foo/bar?baz', '123')\n        ('foo/bar?baz', '', None)\n\n    Scales linearly with number of delims. Not ideal for large number of delims.\n    \"\"\"\n    min_idx = None\n    min_delim = None\n    for d in delims:\n        idx = s.find(d)\n        if idx < 0:\n            continue\n\n        if min_idx is None or idx < min_idx:\n            min_idx = idx\n            min_delim = d\n\n    if min_idx is None or min_idx < 0:\n        return s, \"\", None\n\n    return s[:min_idx], s[min_idx + 1 :], min_delim\n\n\ndef _encode_invalid_chars(component, allowed_chars, encoding=\"utf-8\"):\n    \"\"\"Percent-encodes a URI component without reapplying\n    onto an already percent-encoded component.\n    \"\"\"\n    if component is None:\n        return component\n\n    component = six.ensure_text(component)\n\n    # Normalize existing percent-encoded bytes.\n    # Try to see if the component we're encoding is already percent-encoded\n    # so we can skip all '%' characters but still encode all others.\n    component, percent_encodings = PERCENT_RE.subn(\n        lambda match: match.group(0).upper(), component\n    )\n\n    uri_bytes = component.encode(\"utf-8\", \"surrogatepass\")\n    is_percent_encoded = percent_encodings == uri_bytes.count(b\"%\")\n    encoded_component = bytearray()\n\n    for i in range(0, len(uri_bytes)):\n        # Will return a single character bytestring on both Python 2 & 3\n        byte = uri_bytes[i : i + 1]\n        byte_ord = ord(byte)\n        if (is_percent_encoded and byte == b\"%\") or (\n            byte_ord < 128 and byte.decode() in allowed_chars\n        ):\n            encoded_component += byte\n            continue\n        encoded_component.extend(b\"%\" + (hex(byte_ord)[2:].encode().zfill(2).upper()))\n\n    return encoded_component.decode(encoding)\n\n\ndef _remove_path_dot_segments(path):\n    # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code\n    segments = path.split(\"/\")  # Turn the path into a list of segments\n    output = []  # Initialize the variable to use to store output\n\n    for segment in segments:\n        # '.' is the current directory, so ignore it, it is superfluous\n        if segment == \".\":\n            continue\n        # Anything other than '..', should be appended to the output\n        elif segment != \"..\":\n            output.append(segment)\n        # In this case segment == '..', if we can, we should pop the last\n        # element\n        elif output:\n            output.pop()\n\n    # If the path starts with '/' and the output is empty or the first string\n    # is non-empty\n    if path.startswith(\"/\") and (not output or output[0]):\n        output.insert(0, \"\")\n\n    # If the path starts with '/.' or '/..' ensure we add one more empty\n    # string to add a trailing '/'\n    if path.endswith((\"/.\", \"/..\")):\n        output.append(\"\")\n\n    return \"/\".join(output)\n\n\ndef _normalize_host(host, scheme):\n    if host:\n        if isinstance(host, six.binary_type):\n            host = six.ensure_str(host)\n\n        if scheme in NORMALIZABLE_SCHEMES:\n            is_ipv6 = IPV6_ADDRZ_RE.match(host)\n            if is_ipv6:\n                match = ZONE_ID_RE.search(host)\n                if match:\n                    start, end = match.span(1)\n                    zone_id = host[start:end]\n\n                    if zone_id.startswith(\"%25\") and zone_id != \"%25\":\n                        zone_id = zone_id[3:]\n                    else:\n                        zone_id = zone_id[1:]\n                    zone_id = \"%\" + _encode_invalid_chars(zone_id, UNRESERVED_CHARS)\n                    return host[:start].lower() + zone_id + host[end:]\n                else:\n                    return host.lower()\n            elif not IPV4_RE.match(host):\n                return six.ensure_str(\n                    b\".\".join([_idna_encode(label) for label in host.split(\".\")])\n                )\n    return host\n\n\ndef _idna_encode(name):\n    if name and any([ord(x) > 128 for x in name]):\n        try:\n            import idna\n        except ImportError:\n            six.raise_from(\n                LocationParseError(\"Unable to parse URL without the 'idna' module\"),\n                None,\n            )\n        try:\n            return idna.encode(name.lower(), strict=True, std3_rules=True)\n        except idna.IDNAError:\n            six.raise_from(\n                LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name), None\n            )\n    return name.lower().encode(\"ascii\")\n\n\ndef _encode_target(target):\n    \"\"\"Percent-encodes a request target so that there are no invalid characters\"\"\"\n    path, query = TARGET_RE.match(target).groups()\n    target = _encode_invalid_chars(path, PATH_CHARS)\n    query = _encode_invalid_chars(query, QUERY_CHARS)\n    if query is not None:\n        target += \"?\" + query\n    return target\n\n\ndef parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    try:\n        scheme, authority, path, query, fragment = URI_RE.match(url).groups()\n        normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, host, port = SUBAUTHORITY_RE.match(authority).groups()\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port = int(port)\n            if not (0 <= port <= 65535):\n                raise LocationParseError(url)\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError):\n        return six.raise_from(LocationParseError(source_url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    if isinstance(url, six.text_type):\n        ensure_func = six.ensure_text\n    else:\n        ensure_func = six.ensure_str\n\n    def ensure_type(x):\n        return x if x is None else ensure_func(x)\n\n    return Url(\n        scheme=ensure_type(scheme),\n        auth=ensure_type(auth),\n        host=ensure_type(host),\n        port=port,\n        path=ensure_type(path),\n        query=ensure_type(query),\n        fragment=ensure_type(fragment),\n    )\n\n\ndef get_host(url):\n    \"\"\"\n    Deprecated. Use :func:`parse_url` instead.\n    \"\"\"\n    p = parse_url(url)\n    return p.scheme or \"http\", p.hostname, p.port\n", "# coding: utf-8\nimport hashlib\nimport io\nimport logging\nimport socket\nimport ssl\nimport warnings\nfrom itertools import chain\nfrom test import notBrotlipy, onlyBrotlipy, onlyPy2, onlyPy3\n\nimport pytest\nfrom mock import Mock, patch\n\nfrom urllib3 import add_stderr_logger, disable_warnings, util\nfrom urllib3.exceptions import (\n    InsecureRequestWarning,\n    LocationParseError,\n    SNIMissingWarning,\n    TimeoutStateError,\n    UnrewindableBodyError,\n)\nfrom urllib3.packages import six\nfrom urllib3.poolmanager import ProxyConfig\nfrom urllib3.util import is_fp_closed\nfrom urllib3.util.connection import _has_ipv6, allowed_gai_family, create_connection\nfrom urllib3.util.proxy import connection_requires_http_tunnel, create_proxy_ssl_context\nfrom urllib3.util.request import _FAILEDTELL, make_headers, rewind_body\nfrom urllib3.util.response import assert_header_parsing\nfrom urllib3.util.ssl_ import (\n    _const_compare_digest_backport,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom urllib3.util.timeout import Timeout\nfrom urllib3.util.url import Url, get_host, parse_url, split_first\n\nfrom . import clear_warnings\n\n# This number represents a time in seconds, it doesn't mean anything in\n# isolation. Setting to a high-ish value to avoid conflicts with the smaller\n# numbers used for timeouts\nTIMEOUT_EPOCH = 1000\n\n\nclass TestUtil(object):\n\n    url_host_map = [\n        # Hosts\n        (\"http://google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/mail/\", (\"http\", \"google.com\", None)),\n        (\"google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/\", (\"http\", \"google.com\", None)),\n        (\"http://google.com\", (\"http\", \"google.com\", None)),\n        (\"http://www.google.com\", (\"http\", \"www.google.com\", None)),\n        (\"http://mail.google.com\", (\"http\", \"mail.google.com\", None)),\n        (\"http://google.com:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"http://google.com:8000\", (\"http\", \"google.com\", 8000)),\n        (\"https://google.com\", (\"https\", \"google.com\", None)),\n        (\"https://google.com:8000\", (\"https\", \"google.com\", 8000)),\n        (\"http://user:password@127.0.0.1:1234\", (\"http\", \"127.0.0.1\", 1234)),\n        (\"http://google.com/foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com?foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com#foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        # IPv4\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7/test\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7:80\", (\"http\", \"173.194.35.7\", 80)),\n        (\"http://173.194.35.7:80/test\", (\"http\", \"173.194.35.7\", 80)),\n        # IPv6\n        (\"[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\"http://[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\n            \"http://[2a00:1450:4001:c01::67]/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", None),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        # More IPv6 from http://www.ietf.org/rfc/rfc2732.txt\n        (\n            \"http://[fedc:ba98:7654:3210:fedc:ba98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"http://[1080:0:0:0:8:800:200c:417a]/index.html\",\n            (\"http\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"http://[3ffe:2a00:100:7031::1]\", (\"http\", \"[3ffe:2a00:100:7031::1]\", None)),\n        (\n            \"http://[1080::8:800:200c:417a]/foo\",\n            (\"http\", \"[1080::8:800:200c:417a]\", None),\n        ),\n        (\"http://[::192.9.5.5]/ipng\", (\"http\", \"[::192.9.5.5]\", None)),\n        (\n            \"http://[::ffff:129.144.52.38]:42/index.html\",\n            (\"http\", \"[::ffff:129.144.52.38]\", 42),\n        ),\n        (\n            \"http://[2010:836b:4179::836b:4179]\",\n            (\"http\", \"[2010:836b:4179::836b:4179]\", None),\n        ),\n        # Hosts\n        (\"HTTP://GOOGLE.COM/mail/\", (\"http\", \"google.com\", None)),\n        (\"GOogle.COM/mail\", (\"http\", \"google.com\", None)),\n        (\"HTTP://GoOgLe.CoM:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"HTTP://user:password@EXAMPLE.COM:1234\", (\"http\", \"example.com\", 1234)),\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"HTTP://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\n            \"HTTP://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"HTTP://[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"HTTPS://[1080:0:0:0:8:800:200c:417A]/index.html\",\n            (\"https\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"abOut://eXamPlE.com?info=1\", (\"about\", \"eXamPlE.com\", None)),\n        (\n            \"http+UNIX://%2fvar%2frun%2fSOCKET/path\",\n            (\"http+unix\", \"%2fvar%2frun%2fSOCKET\", None),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_host\", url_host_map)\n    def test_get_host(self, url, expected_host):\n        returned_host = get_host(url)\n        assert returned_host == expected_host\n\n    # TODO: Add more tests\n    @pytest.mark.parametrize(\n        \"location\",\n        [\n            \"http://google.com:foo\",\n            \"http://::1/\",\n            \"http://::1:80/\",\n            \"http://google.com:-80\",\n            six.u(\"http://google.com:\\xb2\\xb2\"),  # \\xb2 = ^2\n        ],\n    )\n    def test_invalid_host(self, location):\n        with pytest.raises(LocationParseError):\n            get_host(location)\n\n    @pytest.mark.parametrize(\n        \"url\",\n        [\n            # Invalid IDNA labels\n            u\"http://\\uD7FF.com\",\n            u\"http://\u2764\ufe0f\",\n            # Unicode surrogates\n            u\"http://\\uD800.com\",\n            u\"http://\\uDC00.com\",\n        ],\n    )\n    def test_invalid_url(self, url):\n        with pytest.raises(LocationParseError):\n            parse_url(url)\n\n    @pytest.mark.parametrize(\n        \"url, expected_normalized_url\",\n        [\n            (\"HTTP://GOOGLE.COM/MAIL/\", \"http://google.com/MAIL/\"),\n            (\n                \"http://user@domain.com:password@example.com/~tilde@?@\",\n                \"http://user%40domain.com:password@example.com/~tilde@?@\",\n            ),\n            (\n                \"HTTP://JeremyCline:Hunter2@Example.com:8080/\",\n                \"http://JeremyCline:Hunter2@example.com:8080/\",\n            ),\n            (\"HTTPS://Example.Com/?Key=Value\", \"https://example.com/?Key=Value\"),\n            (\"Https://Example.Com/#Fragment\", \"https://example.com/#Fragment\"),\n            (\"[::1%25]\", \"[::1%25]\"),\n            (\"[::Ff%etH0%Ff]/%ab%Af\", \"[::ff%etH0%FF]/%AB%AF\"),\n            (\n                \"http://user:pass@[AaAa::Ff%25etH0%Ff]/%ab%Af\",\n                \"http://user:pass@[aaaa::ff%etH0%FF]/%AB%AF\",\n            ),\n            # Invalid characters for the query/fragment getting encoded\n            (\n                'http://google.com/p[]?parameter[]=\"hello\"#fragment#',\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n            # Percent encoding isn't applied twice despite '%' being invalid\n            # but the percent encoding is still normalized.\n            (\n                \"http://google.com/p%5B%5d?parameter%5b%5D=%22hello%22#fragment%23\",\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n        ],\n    )\n    def test_parse_url_normalization(self, url, expected_normalized_url):\n        \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"\n        actual_normalized_url = parse_url(url).url\n        assert actual_normalized_url == expected_normalized_url\n\n    @pytest.mark.parametrize(\"char\", [chr(i) for i in range(0x00, 0x21)] + [\"\\x7F\"])\n    def test_control_characters_are_percent_encoded(self, char):\n        percent_char = \"%\" + (hex(ord(char))[2:].zfill(2).upper())\n        url = parse_url(\n            \"http://user{0}@example.com/path{0}?query{0}#fragment{0}\".format(char)\n        )\n\n        assert url == Url(\n            \"http\",\n            auth=\"user\" + percent_char,\n            host=\"example.com\",\n            path=\"/path\" + percent_char,\n            query=\"query\" + percent_char,\n            fragment=\"fragment\" + percent_char,\n        )\n\n    parse_url_host_map = [\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/mail/\", Url(\"http\", host=\"google.com\", path=\"/mail/\")),\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"mail\")),\n        (\"google.com/mail\", Url(host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com?foo\", Url(\"http\", host=\"google.com\", path=\"\", query=\"foo\")),\n        # Path/query/fragment\n        (\"\", Url()),\n        (\"/\", Url(path=\"/\")),\n        (\"#?/!google.com/?foo\", Url(path=\"\", fragment=\"?/!google.com/?foo\")),\n        (\"/foo\", Url(path=\"/foo\")),\n        (\"/foo?bar=baz\", Url(path=\"/foo\", query=\"bar=baz\")),\n        (\n            \"/foo?bar=baz#banana?apple/orange\",\n            Url(path=\"/foo\", query=\"bar=baz\", fragment=\"banana?apple/orange\"),\n        ),\n        (\n            \"/redirect?target=http://localhost:61020/\",\n            Url(path=\"redirect\", query=\"target=http://localhost:61020/\"),\n        ),\n        # Port\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com:80/\", Url(\"http\", host=\"google.com\", port=80, path=\"/\")),\n        (\"http://google.com:80\", Url(\"http\", host=\"google.com\", port=80)),\n        # Auth\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n        (\"http://foo@localhost/\", Url(\"http\", auth=\"foo\", host=\"localhost\", path=\"/\")),\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n        # Unicode type (Python 2.x)\n        (\n            u\"http://foo:bar@localhost/\",\n            Url(u\"http\", auth=u\"foo:bar\", host=u\"localhost\", path=u\"/\"),\n        ),\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n    ]\n\n    non_round_tripping_parse_url_host_map = [\n        # Path/query/fragment\n        (\"?\", Url(path=\"\", query=\"\")),\n        (\"#\", Url(path=\"\", fragment=\"\")),\n        # Path normalization\n        (\"/abc/../def\", Url(path=\"/def\")),\n        # Empty Port\n        (\"http://google.com:\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com:/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        # Uppercase IRI\n        (\n            u\"http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe\",\n            Url(\"http\", host=\"xn--knigsgchen-b4a3dun.de\", path=\"/stra%C3%9Fe\"),\n        ),\n        # Percent-encode in userinfo\n        (\n            u\"http://user@email.com:password@example.com/\",\n            Url(\"http\", auth=\"user%40email.com:password\", host=\"example.com\", path=\"/\"),\n        ),\n        (\n            u'http://user\":quoted@example.com/',\n            Url(\"http\", auth=\"user%22:quoted\", host=\"example.com\", path=\"/\"),\n        ),\n        # Unicode Surrogates\n        (u\"http://google.com/\\uD800\", Url(\"http\", host=\"google.com\", path=\"%ED%A0%80\")),\n        (\n            u\"http://google.com?q=\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", query=\"q=%ED%B0%80\"),\n        ),\n        (\n            u\"http://google.com#\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"%ED%B0%80\"),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\n        \"url, expected_url\",\n        chain(parse_url_host_map, non_round_tripping_parse_url_host_map),\n    )\n    def test_parse_url(self, url, expected_url):\n        returned_url = parse_url(url)\n        assert returned_url == expected_url\n\n    @pytest.mark.parametrize(\"url, expected_url\", parse_url_host_map)\n    def test_unparse_url(self, url, expected_url):\n        assert url == expected_url.url\n\n    @pytest.mark.parametrize(\n        [\"url\", \"expected_url\"],\n        [\n            # RFC 3986 5.2.4\n            (\"/abc/../def\", Url(path=\"/def\")),\n            (\"/..\", Url(path=\"/\")),\n            (\"/./abc/./def/\", Url(path=\"/abc/def/\")),\n            (\"/.\", Url(path=\"/\")),\n            (\"/./\", Url(path=\"/\")),\n            (\"/abc/./.././d/././e/.././f/./../../ghi\", Url(path=\"/ghi\")),\n        ],\n    )\n    def test_parse_and_normalize_url_paths(self, url, expected_url):\n        actual_url = parse_url(url)\n        assert actual_url == expected_url\n        assert actual_url.url == expected_url.url\n\n    def test_parse_url_invalid_IPv6(self):\n        with pytest.raises(LocationParseError):\n            parse_url(\"[::1\")\n\n    def test_parse_url_negative_port(self):\n        with pytest.raises(LocationParseError):\n            parse_url(\"https://www.google.com:-80/\")\n\n    def test_Url_str(self):\n        U = Url(\"http\", host=\"google.com\")\n        assert str(U) == U.url\n\n    request_uri_map = [\n        (\"http://google.com/mail\", \"/mail\"),\n        (\"http://google.com/mail/\", \"/mail/\"),\n        (\"http://google.com/\", \"/\"),\n        (\"http://google.com\", \"/\"),\n        (\"\", \"/\"),\n        (\"/\", \"/\"),\n        (\"?\", \"/?\"),\n        (\"#\", \"/\"),\n        (\"/foo?bar=baz\", \"/foo?bar=baz\"),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_request_uri\", request_uri_map)\n    def test_request_uri(self, url, expected_request_uri):\n        returned_url = parse_url(url)\n        assert returned_url.request_uri == expected_request_uri\n\n    url_netloc_map = [\n        (\"http://google.com/mail\", \"google.com\"),\n        (\"http://google.com:80/mail\", \"google.com:80\"),\n        (\"google.com/foobar\", \"google.com\"),\n        (\"google.com:12345\", \"google.com:12345\"),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_netloc\", url_netloc_map)\n    def test_netloc(self, url, expected_netloc):\n        assert parse_url(url).netloc == expected_netloc\n\n    url_vulnerabilities = [\n        # urlparse doesn't follow RFC 3986 Section 3.2\n        (\n            \"http://google.com#@evil.com/\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"@evil.com/\"),\n        ),\n        # CVE-2016-5699\n        (\n            \"http://127.0.0.1%0d%0aConnection%3a%20keep-alive\",\n            Url(\"http\", host=\"127.0.0.1%0d%0aconnection%3a%20keep-alive\"),\n        ),\n        # NodeJS unicode -> double dot\n        (\n            u\"http://google.com/\\uff2e\\uff2e/abc\",\n            Url(\"http\", host=\"google.com\", path=\"/%EF%BC%AE%EF%BC%AE/abc\"),\n        ),\n        # Scheme without ://\n        (\n            \"javascript:a='@google.com:12345/';alert(0)\",\n            Url(scheme=\"javascript\", path=\"a='@google.com:12345/';alert(0)\"),\n        ),\n        (\"//google.com/a/b/c\", Url(host=\"google.com\", path=\"/a/b/c\")),\n        # International URLs\n        (\n            u\"http://\u30d2:\u30ad@\u30d2.abc.\u30cb/\u30d2?\u30ad#\u30ef\",\n            Url(\n                u\"http\",\n                host=u\"xn--pdk.abc.xn--idk\",\n                auth=u\"%E3%83%92:%E3%82%AD\",\n                path=u\"/%E3%83%92\",\n                query=u\"%E3%82%AD\",\n                fragment=u\"%E3%83%AF\",\n            ),\n        ),\n        # Injected headers (CVE-2016-5699, CVE-2019-9740, CVE-2019-9947)\n        (\n            \"10.251.0.83:7777?a=1 HTTP/1.1\\r\\nX-injected: header\",\n            Url(\n                host=\"10.251.0.83\",\n                port=7777,\n                path=\"\",\n                query=\"a=1%20HTTP/1.1%0D%0AX-injected:%20header\",\n            ),\n        ),\n        (\n            \"http://127.0.0.1:6379?\\r\\nSET test failure12\\r\\n:8080/test/?test=a\",\n            Url(\n                scheme=\"http\",\n                host=\"127.0.0.1\",\n                port=6379,\n                path=\"\",\n                query=\"%0D%0ASET%20test%20failure12%0D%0A:8080/test/?test=a\",\n            ),\n        ),\n        # See https://bugs.xdavidhu.me/google/2020/03/08/the-unexpected-google-wide-domain-check-bypass/\n        (\n            \"https://user:pass@xdavidhu.me\\\\test.corp.google.com:8080/path/to/something?param=value#hash\",\n            Url(\n                scheme=\"https\",\n                auth=\"user:pass\",\n                host=\"xdavidhu.me\",\n                path=\"/%5Ctest.corp.google.com:8080/path/to/something\",\n                query=\"param=value\",\n                fragment=\"hash\",\n            ),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_url\", url_vulnerabilities)\n    def test_url_vulnerabilities(self, url, expected_url):\n        if expected_url is False:\n            with pytest.raises(LocationParseError):\n                parse_url(url)\n        else:\n            assert parse_url(url) == expected_url\n\n    @onlyPy2\n    def test_parse_url_bytes_to_str_python_2(self):\n        url = parse_url(b\"https://www.google.com/\")\n        assert url == Url(\"https\", host=\"www.google.com\", path=\"/\")\n\n        assert isinstance(url.scheme, str)\n        assert isinstance(url.host, str)\n        assert isinstance(url.path, str)\n\n    @onlyPy2\n    def test_parse_url_unicode_python_2(self):\n        url = parse_url(u\"https://www.google.com/\")\n        assert url == Url(u\"https\", host=u\"www.google.com\", path=u\"/\")\n\n        assert isinstance(url.scheme, six.text_type)\n        assert isinstance(url.host, six.text_type)\n        assert isinstance(url.path, six.text_type)\n\n    @onlyPy3\n    def test_parse_url_bytes_type_error_python_3(self):\n        with pytest.raises(TypeError):\n            parse_url(b\"https://www.google.com/\")\n\n    @pytest.mark.parametrize(\n        \"kwargs, expected\",\n        [\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate,br\"},\n                marks=onlyBrotlipy(),\n            ),\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate\"},\n                marks=notBrotlipy(),\n            ),\n            ({\"accept_encoding\": \"foo,bar\"}, {\"accept-encoding\": \"foo,bar\"}),\n            ({\"accept_encoding\": [\"foo\", \"bar\"]}, {\"accept-encoding\": \"foo,bar\"}),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate,br\", \"user-agent\": \"banana\"},\n                marks=onlyBrotlipy(),\n            ),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate\", \"user-agent\": \"banana\"},\n                marks=notBrotlipy(),\n            ),\n            ({\"user_agent\": \"banana\"}, {\"user-agent\": \"banana\"}),\n            ({\"keep_alive\": True}, {\"connection\": \"keep-alive\"}),\n            ({\"basic_auth\": \"foo:bar\"}, {\"authorization\": \"Basic Zm9vOmJhcg==\"}),\n            (\n                {\"proxy_basic_auth\": \"foo:bar\"},\n                {\"proxy-authorization\": \"Basic Zm9vOmJhcg==\"},\n            ),\n            ({\"disable_cache\": True}, {\"cache-control\": \"no-cache\"}),\n        ],\n    )\n    def test_make_headers(self, kwargs, expected):\n        assert make_headers(**kwargs) == expected\n\n    def test_rewind_body(self):\n        body = io.BytesIO(b\"test data\")\n        assert body.read() == b\"test data\"\n\n        # Assert the file object has been consumed\n        assert body.read() == b\"\"\n\n        # Rewind it back to just be b'data'\n        rewind_body(body, 5)\n        assert body.read() == b\"data\"\n\n    def test_rewind_body_failed_tell(self):\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Simulate failed tell()\n        body_pos = _FAILEDTELL\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(body, body_pos)\n\n    def test_rewind_body_bad_position(self):\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Pass non-integer position\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=None)\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=object())\n\n    def test_rewind_body_failed_seek(self):\n        class BadSeek:\n            def seek(self, pos, offset=0):\n                raise IOError\n\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(BadSeek(), body_pos=2)\n\n    @pytest.mark.parametrize(\n        \"input, expected\",\n        [\n            ((\"abcd\", \"b\"), (\"a\", \"cd\", \"b\")),\n            ((\"abcd\", \"cb\"), (\"a\", \"cd\", \"b\")),\n            ((\"abcd\", \"\"), (\"abcd\", \"\", None)),\n            ((\"abcd\", \"a\"), (\"\", \"bcd\", \"a\")),\n            ((\"abcd\", \"ab\"), (\"\", \"bcd\", \"a\")),\n            ((\"abcd\", \"eb\"), (\"a\", \"cd\", \"b\")),\n        ],\n    )\n    def test_split_first(self, input, expected):\n        output = split_first(*input)\n        assert output == expected\n\n    def test_add_stderr_logger(self):\n        handler = add_stderr_logger(level=logging.INFO)  # Don't actually print debug\n        logger = logging.getLogger(\"urllib3\")\n        assert handler in logger.handlers\n\n        logger.debug(\"Testing add_stderr_logger\")\n        logger.removeHandler(handler)\n\n    def test_disable_warnings(self):\n        with warnings.catch_warnings(record=True) as w:\n            clear_warnings()\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n            disable_warnings()\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n\n    def _make_time_pass(self, seconds, timeout, time_mock):\n        \"\"\"Make some time pass for the timeout object\"\"\"\n        time_mock.return_value = TIMEOUT_EPOCH\n        timeout.start_connect()\n        time_mock.return_value = TIMEOUT_EPOCH + seconds\n        return timeout\n\n    @pytest.mark.parametrize(\n        \"kwargs, message\",\n        [\n            ({\"total\": -1}, \"less than\"),\n            ({\"connect\": 2, \"total\": -1}, \"less than\"),\n            ({\"read\": -1}, \"less than\"),\n            ({\"connect\": False}, \"cannot be a boolean\"),\n            ({\"read\": True}, \"cannot be a boolean\"),\n            ({\"connect\": 0}, \"less than or equal\"),\n            ({\"read\": \"foo\"}, \"int, float or None\"),\n        ],\n    )\n    def test_invalid_timeouts(self, kwargs, message):\n        with pytest.raises(ValueError) as e:\n            Timeout(**kwargs)\n        assert message in str(e.value)\n\n    @patch(\"urllib3.util.timeout.current_time\")\n    def test_timeout(self, current_time):\n        timeout = Timeout(total=3)\n\n        # make 'no time' elapse\n        timeout = self._make_time_pass(\n            seconds=0, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 3\n        assert timeout.connect_timeout == 3\n\n        timeout = Timeout(total=3, connect=2)\n        assert timeout.connect_timeout == 2\n\n        timeout = Timeout()\n        assert timeout.connect_timeout == Timeout.DEFAULT_TIMEOUT\n\n        # Connect takes 5 seconds, leaving 5 seconds for read\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=5, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 5\n\n        # Connect takes 2 seconds, read timeout still 7 seconds\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=2, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=10, read=7)\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=None, read=None, connect=None)\n        assert timeout.connect_timeout is None\n        assert timeout.read_timeout is None\n        assert timeout.total is None\n\n        timeout = Timeout(5)\n        assert timeout.total == 5\n\n    def test_timeout_str(self):\n        timeout = Timeout(connect=1, read=2, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=2, total=3)\"\n        timeout = Timeout(connect=1, read=None, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=None, total=3)\"\n\n    @patch(\"urllib3.util.timeout.current_time\")\n    def test_timeout_elapsed(self, current_time):\n        current_time.return_value = TIMEOUT_EPOCH\n        timeout = Timeout(total=3)\n        with pytest.raises(TimeoutStateError):\n            timeout.get_connect_duration()\n\n        timeout.start_connect()\n        with pytest.raises(TimeoutStateError):\n            timeout.start_connect()\n\n        current_time.return_value = TIMEOUT_EPOCH + 2\n        assert timeout.get_connect_duration() == 2\n        current_time.return_value = TIMEOUT_EPOCH + 37\n        assert timeout.get_connect_duration() == 37\n\n    def test_is_fp_closed_object_supports_closed(self):\n        class ClosedFile(object):\n            @property\n            def closed(self):\n                return True\n\n        assert is_fp_closed(ClosedFile())\n\n    def test_is_fp_closed_object_has_none_fp(self):\n        class NoneFpFile(object):\n            @property\n            def fp(self):\n                return None\n\n        assert is_fp_closed(NoneFpFile())\n\n    def test_is_fp_closed_object_has_fp(self):\n        class FpFile(object):\n            @property\n            def fp(self):\n                return True\n\n        assert not is_fp_closed(FpFile())\n\n    def test_is_fp_closed_object_has_neither_fp_nor_closed(self):\n        class NotReallyAFile(object):\n            pass\n\n        with pytest.raises(ValueError):\n            is_fp_closed(NotReallyAFile())\n\n    def test_const_compare_digest_fallback(self):\n        target = hashlib.sha256(b\"abcdef\").digest()\n        assert _const_compare_digest_backport(target, target)\n\n        prefix = target[:-1]\n        assert not _const_compare_digest_backport(target, prefix)\n\n        suffix = target + b\"0\"\n        assert not _const_compare_digest_backport(target, suffix)\n\n        incorrect = hashlib.sha256(b\"xyz\").digest()\n        assert not _const_compare_digest_backport(target, incorrect)\n\n    def test_has_ipv6_disabled_on_compile(self):\n        with patch(\"socket.has_ipv6\", False):\n            assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_but_fails(self):\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind = Mock(side_effect=Exception(\"No IPv6 here!\"))\n                assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_and_working(self):\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind.return_value = True\n                assert _has_ipv6(\"::1\")\n\n    def test_has_ipv6_disabled_on_appengine(self):\n        gae_patch = patch(\n            \"urllib3.contrib._appengine_environ.is_appengine_sandbox\", return_value=True\n        )\n        with gae_patch:\n            assert not _has_ipv6(\"::1\")\n\n    def test_ip_family_ipv6_enabled(self):\n        with patch(\"urllib3.util.connection.HAS_IPV6\", True):\n            assert allowed_gai_family() == socket.AF_UNSPEC\n\n    def test_ip_family_ipv6_disabled(self):\n        with patch(\"urllib3.util.connection.HAS_IPV6\", False):\n            assert allowed_gai_family() == socket.AF_INET\n\n    @pytest.mark.parametrize(\"headers\", [b\"foo\", None, object])\n    def test_assert_header_parsing_throws_typeerror_with_non_headers(self, headers):\n        with pytest.raises(TypeError):\n            assert_header_parsing(headers)\n\n    def test_connection_requires_http_tunnel_no_proxy(self):\n        assert not connection_requires_http_tunnel(\n            proxy_url=None, proxy_config=None, destination_scheme=None\n        )\n\n    def test_connection_requires_http_tunnel_http_proxy(self):\n        proxy = parse_url(\"http://proxy:8080\")\n        proxy_config = ProxyConfig(ssl_context=None, use_forwarding_for_https=False)\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n        destination_scheme = \"https\"\n        assert connection_requires_http_tunnel(proxy, proxy_config, destination_scheme)\n\n    def test_connection_requires_http_tunnel_https_proxy(self):\n        proxy = parse_url(\"https://proxy:8443\")\n        proxy_config = ProxyConfig(ssl_context=None, use_forwarding_for_https=False)\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n    def test_create_proxy_ssl_context(self):\n        ssl_context = create_proxy_ssl_context(ssl_version=None, cert_reqs=None)\n        ssl_context.verify_mode = ssl.CERT_REQUIRED\n\n    @onlyPy3\n    def test_assert_header_parsing_no_error_on_multipart(self):\n        from http import client\n\n        header_msg = io.BytesIO()\n        header_msg.write(\n            b'Content-Type: multipart/encrypted;protocol=\"application/'\n            b'HTTP-SPNEGO-session-encrypted\";boundary=\"Encrypted Boundary\"'\n            b\"\\nServer: Microsoft-HTTPAPI/2.0\\nDate: Fri, 16 Aug 2019 19:28:01 GMT\"\n            b\"\\nContent-Length: 1895\\n\\n\\n\"\n        )\n        header_msg.seek(0)\n        assert_header_parsing(client.parse_headers(header_msg))\n\n    @pytest.mark.parametrize(\"host\", [\".localhost\", \"...\", \"t\" * 64])\n    def test_create_connection_with_invalid_idna_labels(self, host):\n        with pytest.raises(LocationParseError) as ctx:\n            create_connection((host, 80))\n        assert str(ctx.value) == \"Failed to parse: '%s', label empty or too long\" % host\n\n    @pytest.mark.parametrize(\n        \"host\",\n        [\n            \"a.example.com\",\n            \"localhost.\",\n            \"[dead::beef]\",\n            \"[dead::beef%en5]\",\n            \"[dead::beef%en5.]\",\n        ],\n    )\n    @patch(\"socket.getaddrinfo\")\n    @patch(\"socket.socket\")\n    def test_create_connection_with_valid_idna_labels(self, socket, getaddrinfo, host):\n        getaddrinfo.return_value = [(None, None, None, None, None)]\n        socket.return_value = Mock()\n        create_connection((host, 80))\n\n\nclass TestUtilSSL(object):\n    \"\"\"Test utils that use an SSL backend.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"candidate, requirements\",\n        [\n            (None, ssl.CERT_REQUIRED),\n            (ssl.CERT_NONE, ssl.CERT_NONE),\n            (ssl.CERT_REQUIRED, ssl.CERT_REQUIRED),\n            (\"REQUIRED\", ssl.CERT_REQUIRED),\n            (\"CERT_REQUIRED\", ssl.CERT_REQUIRED),\n        ],\n    )\n    def test_resolve_cert_reqs(self, candidate, requirements):\n        assert resolve_cert_reqs(candidate) == requirements\n\n    @pytest.mark.parametrize(\n        \"candidate, version\",\n        [\n            (ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1),\n            (\"PROTOCOL_TLSv1\", ssl.PROTOCOL_TLSv1),\n            (\"TLSv1\", ssl.PROTOCOL_TLSv1),\n            (ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23),\n        ],\n    )\n    def test_resolve_ssl_version(self, candidate, version):\n        assert resolve_ssl_version(candidate) == version\n\n    def test_ssl_wrap_socket_loads_the_cert_chain(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, sock=socket, certfile=\"/path/to/certfile\"\n        )\n\n        mock_context.load_cert_chain.assert_called_once_with(\"/path/to/certfile\", None)\n\n    @patch(\"urllib3.util.ssl_.create_urllib3_context\")\n    def test_ssl_wrap_socket_creates_new_context(self, create_urllib3_context):\n        socket = object()\n        ssl_wrap_socket(sock=socket, cert_reqs=\"CERT_REQUIRED\")\n\n        create_urllib3_context.assert_called_once_with(\n            None, \"CERT_REQUIRED\", ciphers=None\n        )\n\n    def test_ssl_wrap_socket_loads_verify_locations(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(ssl_context=mock_context, ca_certs=\"/path/to/pem\", sock=socket)\n        mock_context.load_verify_locations.assert_called_once_with(\n            \"/path/to/pem\", None, None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_directories(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_dir=\"/path/to/pems\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, \"/path/to/pems\", None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_data(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_data=\"TOTALLY PEM DATA\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, None, \"TOTALLY PEM DATA\"\n        )\n\n    def _wrap_socket_and_mock_warn(self, sock, server_hostname):\n        mock_context = Mock()\n        with patch(\"warnings.warn\") as warn:\n            ssl_wrap_socket(\n                ssl_context=mock_context,\n                sock=sock,\n                server_hostname=server_hostname,\n            )\n        return mock_context, warn\n\n    def test_ssl_wrap_socket_sni_hostname_use_or_warn(self):\n        \"\"\"Test that either an SNI hostname is used or a warning is made.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, \"www.google.com\")\n        if util.HAS_SNI:\n            warn.assert_not_called()\n            context.wrap_socket.assert_called_once_with(\n                sock, server_hostname=\"www.google.com\"\n            )\n        else:\n            assert warn.call_count >= 1\n            warnings = [call[0][1] for call in warn.call_args_list]\n            assert SNIMissingWarning in warnings\n            context.wrap_socket.assert_called_once_with(sock)\n\n    def test_ssl_wrap_socket_sni_ip_address_no_warn(self):\n        \"\"\"Test that a warning is not made if server_hostname is an IP address.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, \"8.8.8.8\")\n        if util.IS_SECURETRANSPORT:\n            context.wrap_socket.assert_called_once_with(sock, server_hostname=\"8.8.8.8\")\n        else:\n            context.wrap_socket.assert_called_once_with(sock)\n        warn.assert_not_called()\n\n    def test_ssl_wrap_socket_sni_none_no_warn(self):\n        \"\"\"Test that a warning is not made if server_hostname is not given.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, None)\n        context.wrap_socket.assert_called_once_with(sock)\n        warn.assert_not_called()\n"], "fixing_code": ["from __future__ import absolute_import\n\nimport re\nfrom collections import namedtuple\n\nfrom ..exceptions import LocationParseError\nfrom ..packages import six\n\nurl_attrs = [\"scheme\", \"auth\", \"host\", \"port\", \"path\", \"query\", \"fragment\"]\n\n# We only want to normalize urls with an HTTP(S) scheme.\n# urllib3 infers URLs without a scheme (None) to be http.\nNORMALIZABLE_SCHEMES = (\"http\", \"https\", None)\n\n# Almost all of these patterns were derived from the\n# 'rfc3986' module: https://github.com/python-hyper/rfc3986\nPERCENT_RE = re.compile(r\"%[a-fA-F0-9]{2}\")\nSCHEME_RE = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)\")\nURI_RE = re.compile(\n    r\"^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?\"\n    r\"(?://([^\\\\/?#]*))?\"\n    r\"([^?#]*)\"\n    r\"(?:\\?([^#]*))?\"\n    r\"(?:#(.*))?$\",\n    re.UNICODE | re.DOTALL,\n)\n\nIPV4_PAT = r\"(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\"\nHEX_PAT = \"[0-9A-Fa-f]{1,4}\"\nLS32_PAT = \"(?:{hex}:{hex}|{ipv4})\".format(hex=HEX_PAT, ipv4=IPV4_PAT)\n_subs = {\"hex\": HEX_PAT, \"ls32\": LS32_PAT}\n_variations = [\n    #                            6( h16 \":\" ) ls32\n    \"(?:%(hex)s:){6}%(ls32)s\",\n    #                       \"::\" 5( h16 \":\" ) ls32\n    \"::(?:%(hex)s:){5}%(ls32)s\",\n    # [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    \"(?:%(hex)s)?::(?:%(hex)s:){4}%(ls32)s\",\n    # [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:)?%(hex)s)?::(?:%(hex)s:){3}%(ls32)s\",\n    # [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    \"(?:(?:%(hex)s:){0,2}%(hex)s)?::(?:%(hex)s:){2}%(ls32)s\",\n    # [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    \"(?:(?:%(hex)s:){0,3}%(hex)s)?::%(hex)s:%(ls32)s\",\n    # [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    \"(?:(?:%(hex)s:){0,4}%(hex)s)?::%(ls32)s\",\n    # [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    \"(?:(?:%(hex)s:){0,5}%(hex)s)?::%(hex)s\",\n    # [ *6( h16 \":\" ) h16 ] \"::\"\n    \"(?:(?:%(hex)s:){0,6}%(hex)s)?::\",\n]\n\nUNRESERVED_PAT = r\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._!\\-~\"\nIPV6_PAT = \"(?:\" + \"|\".join([x % _subs for x in _variations]) + \")\"\nZONE_ID_PAT = \"(?:%25|%)(?:[\" + UNRESERVED_PAT + \"]|%[a-fA-F0-9]{2})+\"\nIPV6_ADDRZ_PAT = r\"\\[\" + IPV6_PAT + r\"(?:\" + ZONE_ID_PAT + r\")?\\]\"\nREG_NAME_PAT = r\"(?:[^\\[\\]%:/?#]|%[a-fA-F0-9]{2})*\"\nTARGET_RE = re.compile(r\"^(/[^?#]*)(?:\\?([^#]*))?(?:#.*)?$\")\n\nIPV4_RE = re.compile(\"^\" + IPV4_PAT + \"$\")\nIPV6_RE = re.compile(\"^\" + IPV6_PAT + \"$\")\nIPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT + \"$\")\nBRACELESS_IPV6_ADDRZ_RE = re.compile(\"^\" + IPV6_ADDRZ_PAT[2:-2] + \"$\")\nZONE_ID_RE = re.compile(\"(\" + ZONE_ID_PAT + r\")\\]$\")\n\n_HOST_PORT_PAT = (\"^(%s|%s|%s)(?::([0-9]{0,5}))?$\") % (\n    REG_NAME_PAT,\n    IPV4_PAT,\n    IPV6_ADDRZ_PAT,\n)\n_HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)\n\nUNRESERVED_CHARS = set(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-~\"\n)\nSUB_DELIM_CHARS = set(\"!$&'()*+,;=\")\nUSERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {\":\"}\nPATH_CHARS = USERINFO_CHARS | {\"@\", \"/\"}\nQUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {\"?\"}\n\n\nclass Url(namedtuple(\"Url\", url_attrs)):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls,\n        scheme=None,\n        auth=None,\n        host=None,\n        port=None,\n        path=None,\n        query=None,\n        fragment=None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super(Url, cls).__new__(\n            cls, scheme, auth, host, port, path, query, fragment\n        )\n\n    @property\n    def hostname(self):\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self):\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def netloc(self):\n        \"\"\"Network location including host and port\"\"\"\n        if self.port:\n            return \"%s:%d\" % (self.host, self.port)\n        return self.host\n\n    @property\n    def url(self):\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example: ::\n\n            >>> U = parse_url('http://google.com/mail/')\n            >>> U.url\n            'http://google.com/mail/'\n            >>> Url('http', 'username:password', 'host.com', 80,\n            ... '/path', 'query', 'fragment').url\n            'http://username:password@host.com:80/path?query#fragment'\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = u\"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + u\"://\"\n        if auth is not None:\n            url += auth + u\"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += u\":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += u\"?\" + query\n        if fragment is not None:\n            url += u\"#\" + fragment\n\n        return url\n\n    def __str__(self):\n        return self.url\n\n\ndef split_first(s, delims):\n    \"\"\"\n    .. deprecated:: 1.25\n\n    Given a string and an iterable of delimiters, split on the first found\n    delimiter. Return two split parts and the matched delimiter.\n\n    If not found, then the first part is the full input string.\n\n    Example::\n\n        >>> split_first('foo/bar?baz', '?/=')\n        ('foo', 'bar?baz', '/')\n        >>> split_first('foo/bar?baz', '123')\n        ('foo/bar?baz', '', None)\n\n    Scales linearly with number of delims. Not ideal for large number of delims.\n    \"\"\"\n    min_idx = None\n    min_delim = None\n    for d in delims:\n        idx = s.find(d)\n        if idx < 0:\n            continue\n\n        if min_idx is None or idx < min_idx:\n            min_idx = idx\n            min_delim = d\n\n    if min_idx is None or min_idx < 0:\n        return s, \"\", None\n\n    return s[:min_idx], s[min_idx + 1 :], min_delim\n\n\ndef _encode_invalid_chars(component, allowed_chars, encoding=\"utf-8\"):\n    \"\"\"Percent-encodes a URI component without reapplying\n    onto an already percent-encoded component.\n    \"\"\"\n    if component is None:\n        return component\n\n    component = six.ensure_text(component)\n\n    # Normalize existing percent-encoded bytes.\n    # Try to see if the component we're encoding is already percent-encoded\n    # so we can skip all '%' characters but still encode all others.\n    component, percent_encodings = PERCENT_RE.subn(\n        lambda match: match.group(0).upper(), component\n    )\n\n    uri_bytes = component.encode(\"utf-8\", \"surrogatepass\")\n    is_percent_encoded = percent_encodings == uri_bytes.count(b\"%\")\n    encoded_component = bytearray()\n\n    for i in range(0, len(uri_bytes)):\n        # Will return a single character bytestring on both Python 2 & 3\n        byte = uri_bytes[i : i + 1]\n        byte_ord = ord(byte)\n        if (is_percent_encoded and byte == b\"%\") or (\n            byte_ord < 128 and byte.decode() in allowed_chars\n        ):\n            encoded_component += byte\n            continue\n        encoded_component.extend(b\"%\" + (hex(byte_ord)[2:].encode().zfill(2).upper()))\n\n    return encoded_component.decode(encoding)\n\n\ndef _remove_path_dot_segments(path):\n    # See http://tools.ietf.org/html/rfc3986#section-5.2.4 for pseudo-code\n    segments = path.split(\"/\")  # Turn the path into a list of segments\n    output = []  # Initialize the variable to use to store output\n\n    for segment in segments:\n        # '.' is the current directory, so ignore it, it is superfluous\n        if segment == \".\":\n            continue\n        # Anything other than '..', should be appended to the output\n        elif segment != \"..\":\n            output.append(segment)\n        # In this case segment == '..', if we can, we should pop the last\n        # element\n        elif output:\n            output.pop()\n\n    # If the path starts with '/' and the output is empty or the first string\n    # is non-empty\n    if path.startswith(\"/\") and (not output or output[0]):\n        output.insert(0, \"\")\n\n    # If the path starts with '/.' or '/..' ensure we add one more empty\n    # string to add a trailing '/'\n    if path.endswith((\"/.\", \"/..\")):\n        output.append(\"\")\n\n    return \"/\".join(output)\n\n\ndef _normalize_host(host, scheme):\n    if host:\n        if isinstance(host, six.binary_type):\n            host = six.ensure_str(host)\n\n        if scheme in NORMALIZABLE_SCHEMES:\n            is_ipv6 = IPV6_ADDRZ_RE.match(host)\n            if is_ipv6:\n                match = ZONE_ID_RE.search(host)\n                if match:\n                    start, end = match.span(1)\n                    zone_id = host[start:end]\n\n                    if zone_id.startswith(\"%25\") and zone_id != \"%25\":\n                        zone_id = zone_id[3:]\n                    else:\n                        zone_id = zone_id[1:]\n                    zone_id = \"%\" + _encode_invalid_chars(zone_id, UNRESERVED_CHARS)\n                    return host[:start].lower() + zone_id + host[end:]\n                else:\n                    return host.lower()\n            elif not IPV4_RE.match(host):\n                return six.ensure_str(\n                    b\".\".join([_idna_encode(label) for label in host.split(\".\")])\n                )\n    return host\n\n\ndef _idna_encode(name):\n    if name and any([ord(x) > 128 for x in name]):\n        try:\n            import idna\n        except ImportError:\n            six.raise_from(\n                LocationParseError(\"Unable to parse URL without the 'idna' module\"),\n                None,\n            )\n        try:\n            return idna.encode(name.lower(), strict=True, std3_rules=True)\n        except idna.IDNAError:\n            six.raise_from(\n                LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name), None\n            )\n    return name.lower().encode(\"ascii\")\n\n\ndef _encode_target(target):\n    \"\"\"Percent-encodes a request target so that there are no invalid characters\"\"\"\n    path, query = TARGET_RE.match(target).groups()\n    target = _encode_invalid_chars(path, PATH_CHARS)\n    query = _encode_invalid_chars(query, QUERY_CHARS)\n    if query is not None:\n        target += \"?\" + query\n    return target\n\n\ndef parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        >>> parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        >>> parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        >>> parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    try:\n        scheme, authority, path, query, fragment = URI_RE.match(url).groups()\n        normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, _, host_port = authority.rpartition(\"@\")\n            auth = auth or None\n            host, port = _HOST_PORT_RE.match(host_port).groups()\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port = int(port)\n            if not (0 <= port <= 65535):\n                raise LocationParseError(url)\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError):\n        return six.raise_from(LocationParseError(source_url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    if isinstance(url, six.text_type):\n        ensure_func = six.ensure_text\n    else:\n        ensure_func = six.ensure_str\n\n    def ensure_type(x):\n        return x if x is None else ensure_func(x)\n\n    return Url(\n        scheme=ensure_type(scheme),\n        auth=ensure_type(auth),\n        host=ensure_type(host),\n        port=port,\n        path=ensure_type(path),\n        query=ensure_type(query),\n        fragment=ensure_type(fragment),\n    )\n\n\ndef get_host(url):\n    \"\"\"\n    Deprecated. Use :func:`parse_url` instead.\n    \"\"\"\n    p = parse_url(url)\n    return p.scheme or \"http\", p.hostname, p.port\n", "# coding: utf-8\nimport hashlib\nimport io\nimport logging\nimport socket\nimport ssl\nimport warnings\nfrom itertools import chain\nfrom test import notBrotlipy, onlyBrotlipy, onlyPy2, onlyPy3\n\nimport pytest\nfrom mock import Mock, patch\n\nfrom urllib3 import add_stderr_logger, disable_warnings, util\nfrom urllib3.exceptions import (\n    InsecureRequestWarning,\n    LocationParseError,\n    SNIMissingWarning,\n    TimeoutStateError,\n    UnrewindableBodyError,\n)\nfrom urllib3.packages import six\nfrom urllib3.poolmanager import ProxyConfig\nfrom urllib3.util import is_fp_closed\nfrom urllib3.util.connection import _has_ipv6, allowed_gai_family, create_connection\nfrom urllib3.util.proxy import connection_requires_http_tunnel, create_proxy_ssl_context\nfrom urllib3.util.request import _FAILEDTELL, make_headers, rewind_body\nfrom urllib3.util.response import assert_header_parsing\nfrom urllib3.util.ssl_ import (\n    _const_compare_digest_backport,\n    resolve_cert_reqs,\n    resolve_ssl_version,\n    ssl_wrap_socket,\n)\nfrom urllib3.util.timeout import Timeout\nfrom urllib3.util.url import Url, get_host, parse_url, split_first\n\nfrom . import clear_warnings\n\n# This number represents a time in seconds, it doesn't mean anything in\n# isolation. Setting to a high-ish value to avoid conflicts with the smaller\n# numbers used for timeouts\nTIMEOUT_EPOCH = 1000\n\n\nclass TestUtil(object):\n\n    url_host_map = [\n        # Hosts\n        (\"http://google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/mail/\", (\"http\", \"google.com\", None)),\n        (\"google.com/mail\", (\"http\", \"google.com\", None)),\n        (\"http://google.com/\", (\"http\", \"google.com\", None)),\n        (\"http://google.com\", (\"http\", \"google.com\", None)),\n        (\"http://www.google.com\", (\"http\", \"www.google.com\", None)),\n        (\"http://mail.google.com\", (\"http\", \"mail.google.com\", None)),\n        (\"http://google.com:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"http://google.com:8000\", (\"http\", \"google.com\", 8000)),\n        (\"https://google.com\", (\"https\", \"google.com\", None)),\n        (\"https://google.com:8000\", (\"https\", \"google.com\", 8000)),\n        (\"http://user:password@127.0.0.1:1234\", (\"http\", \"127.0.0.1\", 1234)),\n        (\"http://google.com/foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com?foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        (\"http://google.com#foo=http://bar:42/baz\", (\"http\", \"google.com\", None)),\n        # IPv4\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7/test\", (\"http\", \"173.194.35.7\", None)),\n        (\"http://173.194.35.7:80\", (\"http\", \"173.194.35.7\", 80)),\n        (\"http://173.194.35.7:80/test\", (\"http\", \"173.194.35.7\", 80)),\n        # IPv6\n        (\"[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\"http://[2a00:1450:4001:c01::67]\", (\"http\", \"[2a00:1450:4001:c01::67]\", None)),\n        (\n            \"http://[2a00:1450:4001:c01::67]/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", None),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"http://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        # More IPv6 from http://www.ietf.org/rfc/rfc2732.txt\n        (\n            \"http://[fedc:ba98:7654:3210:fedc:ba98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"http://[1080:0:0:0:8:800:200c:417a]/index.html\",\n            (\"http\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"http://[3ffe:2a00:100:7031::1]\", (\"http\", \"[3ffe:2a00:100:7031::1]\", None)),\n        (\n            \"http://[1080::8:800:200c:417a]/foo\",\n            (\"http\", \"[1080::8:800:200c:417a]\", None),\n        ),\n        (\"http://[::192.9.5.5]/ipng\", (\"http\", \"[::192.9.5.5]\", None)),\n        (\n            \"http://[::ffff:129.144.52.38]:42/index.html\",\n            (\"http\", \"[::ffff:129.144.52.38]\", 42),\n        ),\n        (\n            \"http://[2010:836b:4179::836b:4179]\",\n            (\"http\", \"[2010:836b:4179::836b:4179]\", None),\n        ),\n        # Hosts\n        (\"HTTP://GOOGLE.COM/mail/\", (\"http\", \"google.com\", None)),\n        (\"GOogle.COM/mail\", (\"http\", \"google.com\", None)),\n        (\"HTTP://GoOgLe.CoM:8000/mail/\", (\"http\", \"google.com\", 8000)),\n        (\"HTTP://user:password@EXAMPLE.COM:1234\", (\"http\", \"example.com\", 1234)),\n        (\"173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\"HTTP://173.194.35.7\", (\"http\", \"173.194.35.7\", None)),\n        (\n            \"HTTP://[2a00:1450:4001:c01::67]:80/test\",\n            (\"http\", \"[2a00:1450:4001:c01::67]\", 80),\n        ),\n        (\n            \"HTTP://[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:8000/index.html\",\n            (\"http\", \"[fedc:ba98:7654:3210:fedc:ba98:7654:3210]\", 8000),\n        ),\n        (\n            \"HTTPS://[1080:0:0:0:8:800:200c:417A]/index.html\",\n            (\"https\", \"[1080:0:0:0:8:800:200c:417a]\", None),\n        ),\n        (\"abOut://eXamPlE.com?info=1\", (\"about\", \"eXamPlE.com\", None)),\n        (\n            \"http+UNIX://%2fvar%2frun%2fSOCKET/path\",\n            (\"http+unix\", \"%2fvar%2frun%2fSOCKET\", None),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_host\", url_host_map)\n    def test_get_host(self, url, expected_host):\n        returned_host = get_host(url)\n        assert returned_host == expected_host\n\n    # TODO: Add more tests\n    @pytest.mark.parametrize(\n        \"location\",\n        [\n            \"http://google.com:foo\",\n            \"http://::1/\",\n            \"http://::1:80/\",\n            \"http://google.com:-80\",\n            six.u(\"http://google.com:\\xb2\\xb2\"),  # \\xb2 = ^2\n        ],\n    )\n    def test_invalid_host(self, location):\n        with pytest.raises(LocationParseError):\n            get_host(location)\n\n    @pytest.mark.parametrize(\n        \"url\",\n        [\n            # Invalid IDNA labels\n            u\"http://\\uD7FF.com\",\n            u\"http://\u2764\ufe0f\",\n            # Unicode surrogates\n            u\"http://\\uD800.com\",\n            u\"http://\\uDC00.com\",\n        ],\n    )\n    def test_invalid_url(self, url):\n        with pytest.raises(LocationParseError):\n            parse_url(url)\n\n    @pytest.mark.parametrize(\n        \"url, expected_normalized_url\",\n        [\n            (\"HTTP://GOOGLE.COM/MAIL/\", \"http://google.com/MAIL/\"),\n            (\n                \"http://user@domain.com:password@example.com/~tilde@?@\",\n                \"http://user%40domain.com:password@example.com/~tilde@?@\",\n            ),\n            (\n                \"HTTP://JeremyCline:Hunter2@Example.com:8080/\",\n                \"http://JeremyCline:Hunter2@example.com:8080/\",\n            ),\n            (\"HTTPS://Example.Com/?Key=Value\", \"https://example.com/?Key=Value\"),\n            (\"Https://Example.Com/#Fragment\", \"https://example.com/#Fragment\"),\n            (\"[::1%25]\", \"[::1%25]\"),\n            (\"[::Ff%etH0%Ff]/%ab%Af\", \"[::ff%etH0%FF]/%AB%AF\"),\n            (\n                \"http://user:pass@[AaAa::Ff%25etH0%Ff]/%ab%Af\",\n                \"http://user:pass@[aaaa::ff%etH0%FF]/%AB%AF\",\n            ),\n            # Invalid characters for the query/fragment getting encoded\n            (\n                'http://google.com/p[]?parameter[]=\"hello\"#fragment#',\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n            # Percent encoding isn't applied twice despite '%' being invalid\n            # but the percent encoding is still normalized.\n            (\n                \"http://google.com/p%5B%5d?parameter%5b%5D=%22hello%22#fragment%23\",\n                \"http://google.com/p%5B%5D?parameter%5B%5D=%22hello%22#fragment%23\",\n            ),\n        ],\n    )\n    def test_parse_url_normalization(self, url, expected_normalized_url):\n        \"\"\"Assert parse_url normalizes the scheme/host, and only the scheme/host\"\"\"\n        actual_normalized_url = parse_url(url).url\n        assert actual_normalized_url == expected_normalized_url\n\n    @pytest.mark.parametrize(\"char\", [chr(i) for i in range(0x00, 0x21)] + [\"\\x7F\"])\n    def test_control_characters_are_percent_encoded(self, char):\n        percent_char = \"%\" + (hex(ord(char))[2:].zfill(2).upper())\n        url = parse_url(\n            \"http://user{0}@example.com/path{0}?query{0}#fragment{0}\".format(char)\n        )\n\n        assert url == Url(\n            \"http\",\n            auth=\"user\" + percent_char,\n            host=\"example.com\",\n            path=\"/path\" + percent_char,\n            query=\"query\" + percent_char,\n            fragment=\"fragment\" + percent_char,\n        )\n\n    parse_url_host_map = [\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/mail/\", Url(\"http\", host=\"google.com\", path=\"/mail/\")),\n        (\"http://google.com/mail\", Url(\"http\", host=\"google.com\", path=\"mail\")),\n        (\"google.com/mail\", Url(host=\"google.com\", path=\"/mail\")),\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com?foo\", Url(\"http\", host=\"google.com\", path=\"\", query=\"foo\")),\n        # Path/query/fragment\n        (\"\", Url()),\n        (\"/\", Url(path=\"/\")),\n        (\"#?/!google.com/?foo\", Url(path=\"\", fragment=\"?/!google.com/?foo\")),\n        (\"/foo\", Url(path=\"/foo\")),\n        (\"/foo?bar=baz\", Url(path=\"/foo\", query=\"bar=baz\")),\n        (\n            \"/foo?bar=baz#banana?apple/orange\",\n            Url(path=\"/foo\", query=\"bar=baz\", fragment=\"banana?apple/orange\"),\n        ),\n        (\n            \"/redirect?target=http://localhost:61020/\",\n            Url(path=\"redirect\", query=\"target=http://localhost:61020/\"),\n        ),\n        # Port\n        (\"http://google.com/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        (\"http://google.com:80/\", Url(\"http\", host=\"google.com\", port=80, path=\"/\")),\n        (\"http://google.com:80\", Url(\"http\", host=\"google.com\", port=80)),\n        # Auth\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n        (\"http://foo@localhost/\", Url(\"http\", auth=\"foo\", host=\"localhost\", path=\"/\")),\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n        # Unicode type (Python 2.x)\n        (\n            u\"http://foo:bar@localhost/\",\n            Url(u\"http\", auth=u\"foo:bar\", host=u\"localhost\", path=u\"/\"),\n        ),\n        (\n            \"http://foo:bar@localhost/\",\n            Url(\"http\", auth=\"foo:bar\", host=\"localhost\", path=\"/\"),\n        ),\n    ]\n\n    non_round_tripping_parse_url_host_map = [\n        # Path/query/fragment\n        (\"?\", Url(path=\"\", query=\"\")),\n        (\"#\", Url(path=\"\", fragment=\"\")),\n        # Path normalization\n        (\"/abc/../def\", Url(path=\"/def\")),\n        # Empty Port\n        (\"http://google.com:\", Url(\"http\", host=\"google.com\")),\n        (\"http://google.com:/\", Url(\"http\", host=\"google.com\", path=\"/\")),\n        # Uppercase IRI\n        (\n            u\"http://K\u00f6nigsg\u00e4\u00dfchen.de/stra\u00dfe\",\n            Url(\"http\", host=\"xn--knigsgchen-b4a3dun.de\", path=\"/stra%C3%9Fe\"),\n        ),\n        # Percent-encode in userinfo\n        (\n            u\"http://user@email.com:password@example.com/\",\n            Url(\"http\", auth=\"user%40email.com:password\", host=\"example.com\", path=\"/\"),\n        ),\n        (\n            u'http://user\":quoted@example.com/',\n            Url(\"http\", auth=\"user%22:quoted\", host=\"example.com\", path=\"/\"),\n        ),\n        # Unicode Surrogates\n        (u\"http://google.com/\\uD800\", Url(\"http\", host=\"google.com\", path=\"%ED%A0%80\")),\n        (\n            u\"http://google.com?q=\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", query=\"q=%ED%B0%80\"),\n        ),\n        (\n            u\"http://google.com#\\uDC00\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"%ED%B0%80\"),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\n        \"url, expected_url\",\n        chain(parse_url_host_map, non_round_tripping_parse_url_host_map),\n    )\n    def test_parse_url(self, url, expected_url):\n        returned_url = parse_url(url)\n        assert returned_url == expected_url\n\n    @pytest.mark.parametrize(\"url, expected_url\", parse_url_host_map)\n    def test_unparse_url(self, url, expected_url):\n        assert url == expected_url.url\n\n    @pytest.mark.parametrize(\n        [\"url\", \"expected_url\"],\n        [\n            # RFC 3986 5.2.4\n            (\"/abc/../def\", Url(path=\"/def\")),\n            (\"/..\", Url(path=\"/\")),\n            (\"/./abc/./def/\", Url(path=\"/abc/def/\")),\n            (\"/.\", Url(path=\"/\")),\n            (\"/./\", Url(path=\"/\")),\n            (\"/abc/./.././d/././e/.././f/./../../ghi\", Url(path=\"/ghi\")),\n        ],\n    )\n    def test_parse_and_normalize_url_paths(self, url, expected_url):\n        actual_url = parse_url(url)\n        assert actual_url == expected_url\n        assert actual_url.url == expected_url.url\n\n    def test_parse_url_invalid_IPv6(self):\n        with pytest.raises(LocationParseError):\n            parse_url(\"[::1\")\n\n    def test_parse_url_negative_port(self):\n        with pytest.raises(LocationParseError):\n            parse_url(\"https://www.google.com:-80/\")\n\n    def test_Url_str(self):\n        U = Url(\"http\", host=\"google.com\")\n        assert str(U) == U.url\n\n    request_uri_map = [\n        (\"http://google.com/mail\", \"/mail\"),\n        (\"http://google.com/mail/\", \"/mail/\"),\n        (\"http://google.com/\", \"/\"),\n        (\"http://google.com\", \"/\"),\n        (\"\", \"/\"),\n        (\"/\", \"/\"),\n        (\"?\", \"/?\"),\n        (\"#\", \"/\"),\n        (\"/foo?bar=baz\", \"/foo?bar=baz\"),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_request_uri\", request_uri_map)\n    def test_request_uri(self, url, expected_request_uri):\n        returned_url = parse_url(url)\n        assert returned_url.request_uri == expected_request_uri\n\n    url_netloc_map = [\n        (\"http://google.com/mail\", \"google.com\"),\n        (\"http://google.com:80/mail\", \"google.com:80\"),\n        (\"google.com/foobar\", \"google.com\"),\n        (\"google.com:12345\", \"google.com:12345\"),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_netloc\", url_netloc_map)\n    def test_netloc(self, url, expected_netloc):\n        assert parse_url(url).netloc == expected_netloc\n\n    url_vulnerabilities = [\n        # urlparse doesn't follow RFC 3986 Section 3.2\n        (\n            \"http://google.com#@evil.com/\",\n            Url(\"http\", host=\"google.com\", path=\"\", fragment=\"@evil.com/\"),\n        ),\n        # CVE-2016-5699\n        (\n            \"http://127.0.0.1%0d%0aConnection%3a%20keep-alive\",\n            Url(\"http\", host=\"127.0.0.1%0d%0aconnection%3a%20keep-alive\"),\n        ),\n        # NodeJS unicode -> double dot\n        (\n            u\"http://google.com/\\uff2e\\uff2e/abc\",\n            Url(\"http\", host=\"google.com\", path=\"/%EF%BC%AE%EF%BC%AE/abc\"),\n        ),\n        # Scheme without ://\n        (\n            \"javascript:a='@google.com:12345/';alert(0)\",\n            Url(scheme=\"javascript\", path=\"a='@google.com:12345/';alert(0)\"),\n        ),\n        (\"//google.com/a/b/c\", Url(host=\"google.com\", path=\"/a/b/c\")),\n        # International URLs\n        (\n            u\"http://\u30d2:\u30ad@\u30d2.abc.\u30cb/\u30d2?\u30ad#\u30ef\",\n            Url(\n                u\"http\",\n                host=u\"xn--pdk.abc.xn--idk\",\n                auth=u\"%E3%83%92:%E3%82%AD\",\n                path=u\"/%E3%83%92\",\n                query=u\"%E3%82%AD\",\n                fragment=u\"%E3%83%AF\",\n            ),\n        ),\n        # Injected headers (CVE-2016-5699, CVE-2019-9740, CVE-2019-9947)\n        (\n            \"10.251.0.83:7777?a=1 HTTP/1.1\\r\\nX-injected: header\",\n            Url(\n                host=\"10.251.0.83\",\n                port=7777,\n                path=\"\",\n                query=\"a=1%20HTTP/1.1%0D%0AX-injected:%20header\",\n            ),\n        ),\n        (\n            \"http://127.0.0.1:6379?\\r\\nSET test failure12\\r\\n:8080/test/?test=a\",\n            Url(\n                scheme=\"http\",\n                host=\"127.0.0.1\",\n                port=6379,\n                path=\"\",\n                query=\"%0D%0ASET%20test%20failure12%0D%0A:8080/test/?test=a\",\n            ),\n        ),\n        # See https://bugs.xdavidhu.me/google/2020/03/08/the-unexpected-google-wide-domain-check-bypass/\n        (\n            \"https://user:pass@xdavidhu.me\\\\test.corp.google.com:8080/path/to/something?param=value#hash\",\n            Url(\n                scheme=\"https\",\n                auth=\"user:pass\",\n                host=\"xdavidhu.me\",\n                path=\"/%5Ctest.corp.google.com:8080/path/to/something\",\n                query=\"param=value\",\n                fragment=\"hash\",\n            ),\n        ),\n        # Tons of '@' causing backtracking\n        (\"https://\" + (\"@\" * 10000) + \"[\", False),\n        (\n            \"https://user:\" + (\"@\" * 10000) + \"example.com\",\n            Url(\n                scheme=\"https\",\n                auth=\"user:\" + (\"%40\" * 9999),\n                host=\"example.com\",\n            ),\n        ),\n    ]\n\n    @pytest.mark.parametrize(\"url, expected_url\", url_vulnerabilities)\n    def test_url_vulnerabilities(self, url, expected_url):\n        if expected_url is False:\n            with pytest.raises(LocationParseError):\n                parse_url(url)\n        else:\n            assert parse_url(url) == expected_url\n\n    @onlyPy2\n    def test_parse_url_bytes_to_str_python_2(self):\n        url = parse_url(b\"https://www.google.com/\")\n        assert url == Url(\"https\", host=\"www.google.com\", path=\"/\")\n\n        assert isinstance(url.scheme, str)\n        assert isinstance(url.host, str)\n        assert isinstance(url.path, str)\n\n    @onlyPy2\n    def test_parse_url_unicode_python_2(self):\n        url = parse_url(u\"https://www.google.com/\")\n        assert url == Url(u\"https\", host=u\"www.google.com\", path=u\"/\")\n\n        assert isinstance(url.scheme, six.text_type)\n        assert isinstance(url.host, six.text_type)\n        assert isinstance(url.path, six.text_type)\n\n    @onlyPy3\n    def test_parse_url_bytes_type_error_python_3(self):\n        with pytest.raises(TypeError):\n            parse_url(b\"https://www.google.com/\")\n\n    @pytest.mark.parametrize(\n        \"kwargs, expected\",\n        [\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate,br\"},\n                marks=onlyBrotlipy(),\n            ),\n            pytest.param(\n                {\"accept_encoding\": True},\n                {\"accept-encoding\": \"gzip,deflate\"},\n                marks=notBrotlipy(),\n            ),\n            ({\"accept_encoding\": \"foo,bar\"}, {\"accept-encoding\": \"foo,bar\"}),\n            ({\"accept_encoding\": [\"foo\", \"bar\"]}, {\"accept-encoding\": \"foo,bar\"}),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate,br\", \"user-agent\": \"banana\"},\n                marks=onlyBrotlipy(),\n            ),\n            pytest.param(\n                {\"accept_encoding\": True, \"user_agent\": \"banana\"},\n                {\"accept-encoding\": \"gzip,deflate\", \"user-agent\": \"banana\"},\n                marks=notBrotlipy(),\n            ),\n            ({\"user_agent\": \"banana\"}, {\"user-agent\": \"banana\"}),\n            ({\"keep_alive\": True}, {\"connection\": \"keep-alive\"}),\n            ({\"basic_auth\": \"foo:bar\"}, {\"authorization\": \"Basic Zm9vOmJhcg==\"}),\n            (\n                {\"proxy_basic_auth\": \"foo:bar\"},\n                {\"proxy-authorization\": \"Basic Zm9vOmJhcg==\"},\n            ),\n            ({\"disable_cache\": True}, {\"cache-control\": \"no-cache\"}),\n        ],\n    )\n    def test_make_headers(self, kwargs, expected):\n        assert make_headers(**kwargs) == expected\n\n    def test_rewind_body(self):\n        body = io.BytesIO(b\"test data\")\n        assert body.read() == b\"test data\"\n\n        # Assert the file object has been consumed\n        assert body.read() == b\"\"\n\n        # Rewind it back to just be b'data'\n        rewind_body(body, 5)\n        assert body.read() == b\"data\"\n\n    def test_rewind_body_failed_tell(self):\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Simulate failed tell()\n        body_pos = _FAILEDTELL\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(body, body_pos)\n\n    def test_rewind_body_bad_position(self):\n        body = io.BytesIO(b\"test data\")\n        body.read()  # Consume body\n\n        # Pass non-integer position\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=None)\n        with pytest.raises(ValueError):\n            rewind_body(body, body_pos=object())\n\n    def test_rewind_body_failed_seek(self):\n        class BadSeek:\n            def seek(self, pos, offset=0):\n                raise IOError\n\n        with pytest.raises(UnrewindableBodyError):\n            rewind_body(BadSeek(), body_pos=2)\n\n    @pytest.mark.parametrize(\n        \"input, expected\",\n        [\n            ((\"abcd\", \"b\"), (\"a\", \"cd\", \"b\")),\n            ((\"abcd\", \"cb\"), (\"a\", \"cd\", \"b\")),\n            ((\"abcd\", \"\"), (\"abcd\", \"\", None)),\n            ((\"abcd\", \"a\"), (\"\", \"bcd\", \"a\")),\n            ((\"abcd\", \"ab\"), (\"\", \"bcd\", \"a\")),\n            ((\"abcd\", \"eb\"), (\"a\", \"cd\", \"b\")),\n        ],\n    )\n    def test_split_first(self, input, expected):\n        output = split_first(*input)\n        assert output == expected\n\n    def test_add_stderr_logger(self):\n        handler = add_stderr_logger(level=logging.INFO)  # Don't actually print debug\n        logger = logging.getLogger(\"urllib3\")\n        assert handler in logger.handlers\n\n        logger.debug(\"Testing add_stderr_logger\")\n        logger.removeHandler(handler)\n\n    def test_disable_warnings(self):\n        with warnings.catch_warnings(record=True) as w:\n            clear_warnings()\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n            disable_warnings()\n            warnings.warn(\"This is a test.\", InsecureRequestWarning)\n            assert len(w) == 1\n\n    def _make_time_pass(self, seconds, timeout, time_mock):\n        \"\"\"Make some time pass for the timeout object\"\"\"\n        time_mock.return_value = TIMEOUT_EPOCH\n        timeout.start_connect()\n        time_mock.return_value = TIMEOUT_EPOCH + seconds\n        return timeout\n\n    @pytest.mark.parametrize(\n        \"kwargs, message\",\n        [\n            ({\"total\": -1}, \"less than\"),\n            ({\"connect\": 2, \"total\": -1}, \"less than\"),\n            ({\"read\": -1}, \"less than\"),\n            ({\"connect\": False}, \"cannot be a boolean\"),\n            ({\"read\": True}, \"cannot be a boolean\"),\n            ({\"connect\": 0}, \"less than or equal\"),\n            ({\"read\": \"foo\"}, \"int, float or None\"),\n        ],\n    )\n    def test_invalid_timeouts(self, kwargs, message):\n        with pytest.raises(ValueError) as e:\n            Timeout(**kwargs)\n        assert message in str(e.value)\n\n    @patch(\"urllib3.util.timeout.current_time\")\n    def test_timeout(self, current_time):\n        timeout = Timeout(total=3)\n\n        # make 'no time' elapse\n        timeout = self._make_time_pass(\n            seconds=0, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 3\n        assert timeout.connect_timeout == 3\n\n        timeout = Timeout(total=3, connect=2)\n        assert timeout.connect_timeout == 2\n\n        timeout = Timeout()\n        assert timeout.connect_timeout == Timeout.DEFAULT_TIMEOUT\n\n        # Connect takes 5 seconds, leaving 5 seconds for read\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=5, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 5\n\n        # Connect takes 2 seconds, read timeout still 7 seconds\n        timeout = Timeout(total=10, read=7)\n        timeout = self._make_time_pass(\n            seconds=2, timeout=timeout, time_mock=current_time\n        )\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=10, read=7)\n        assert timeout.read_timeout == 7\n\n        timeout = Timeout(total=None, read=None, connect=None)\n        assert timeout.connect_timeout is None\n        assert timeout.read_timeout is None\n        assert timeout.total is None\n\n        timeout = Timeout(5)\n        assert timeout.total == 5\n\n    def test_timeout_str(self):\n        timeout = Timeout(connect=1, read=2, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=2, total=3)\"\n        timeout = Timeout(connect=1, read=None, total=3)\n        assert str(timeout) == \"Timeout(connect=1, read=None, total=3)\"\n\n    @patch(\"urllib3.util.timeout.current_time\")\n    def test_timeout_elapsed(self, current_time):\n        current_time.return_value = TIMEOUT_EPOCH\n        timeout = Timeout(total=3)\n        with pytest.raises(TimeoutStateError):\n            timeout.get_connect_duration()\n\n        timeout.start_connect()\n        with pytest.raises(TimeoutStateError):\n            timeout.start_connect()\n\n        current_time.return_value = TIMEOUT_EPOCH + 2\n        assert timeout.get_connect_duration() == 2\n        current_time.return_value = TIMEOUT_EPOCH + 37\n        assert timeout.get_connect_duration() == 37\n\n    def test_is_fp_closed_object_supports_closed(self):\n        class ClosedFile(object):\n            @property\n            def closed(self):\n                return True\n\n        assert is_fp_closed(ClosedFile())\n\n    def test_is_fp_closed_object_has_none_fp(self):\n        class NoneFpFile(object):\n            @property\n            def fp(self):\n                return None\n\n        assert is_fp_closed(NoneFpFile())\n\n    def test_is_fp_closed_object_has_fp(self):\n        class FpFile(object):\n            @property\n            def fp(self):\n                return True\n\n        assert not is_fp_closed(FpFile())\n\n    def test_is_fp_closed_object_has_neither_fp_nor_closed(self):\n        class NotReallyAFile(object):\n            pass\n\n        with pytest.raises(ValueError):\n            is_fp_closed(NotReallyAFile())\n\n    def test_const_compare_digest_fallback(self):\n        target = hashlib.sha256(b\"abcdef\").digest()\n        assert _const_compare_digest_backport(target, target)\n\n        prefix = target[:-1]\n        assert not _const_compare_digest_backport(target, prefix)\n\n        suffix = target + b\"0\"\n        assert not _const_compare_digest_backport(target, suffix)\n\n        incorrect = hashlib.sha256(b\"xyz\").digest()\n        assert not _const_compare_digest_backport(target, incorrect)\n\n    def test_has_ipv6_disabled_on_compile(self):\n        with patch(\"socket.has_ipv6\", False):\n            assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_but_fails(self):\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind = Mock(side_effect=Exception(\"No IPv6 here!\"))\n                assert not _has_ipv6(\"::1\")\n\n    def test_has_ipv6_enabled_and_working(self):\n        with patch(\"socket.has_ipv6\", True):\n            with patch(\"socket.socket\") as mock:\n                instance = mock.return_value\n                instance.bind.return_value = True\n                assert _has_ipv6(\"::1\")\n\n    def test_has_ipv6_disabled_on_appengine(self):\n        gae_patch = patch(\n            \"urllib3.contrib._appengine_environ.is_appengine_sandbox\", return_value=True\n        )\n        with gae_patch:\n            assert not _has_ipv6(\"::1\")\n\n    def test_ip_family_ipv6_enabled(self):\n        with patch(\"urllib3.util.connection.HAS_IPV6\", True):\n            assert allowed_gai_family() == socket.AF_UNSPEC\n\n    def test_ip_family_ipv6_disabled(self):\n        with patch(\"urllib3.util.connection.HAS_IPV6\", False):\n            assert allowed_gai_family() == socket.AF_INET\n\n    @pytest.mark.parametrize(\"headers\", [b\"foo\", None, object])\n    def test_assert_header_parsing_throws_typeerror_with_non_headers(self, headers):\n        with pytest.raises(TypeError):\n            assert_header_parsing(headers)\n\n    def test_connection_requires_http_tunnel_no_proxy(self):\n        assert not connection_requires_http_tunnel(\n            proxy_url=None, proxy_config=None, destination_scheme=None\n        )\n\n    def test_connection_requires_http_tunnel_http_proxy(self):\n        proxy = parse_url(\"http://proxy:8080\")\n        proxy_config = ProxyConfig(ssl_context=None, use_forwarding_for_https=False)\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n        destination_scheme = \"https\"\n        assert connection_requires_http_tunnel(proxy, proxy_config, destination_scheme)\n\n    def test_connection_requires_http_tunnel_https_proxy(self):\n        proxy = parse_url(\"https://proxy:8443\")\n        proxy_config = ProxyConfig(ssl_context=None, use_forwarding_for_https=False)\n        destination_scheme = \"http\"\n        assert not connection_requires_http_tunnel(\n            proxy, proxy_config, destination_scheme\n        )\n\n    def test_create_proxy_ssl_context(self):\n        ssl_context = create_proxy_ssl_context(ssl_version=None, cert_reqs=None)\n        ssl_context.verify_mode = ssl.CERT_REQUIRED\n\n    @onlyPy3\n    def test_assert_header_parsing_no_error_on_multipart(self):\n        from http import client\n\n        header_msg = io.BytesIO()\n        header_msg.write(\n            b'Content-Type: multipart/encrypted;protocol=\"application/'\n            b'HTTP-SPNEGO-session-encrypted\";boundary=\"Encrypted Boundary\"'\n            b\"\\nServer: Microsoft-HTTPAPI/2.0\\nDate: Fri, 16 Aug 2019 19:28:01 GMT\"\n            b\"\\nContent-Length: 1895\\n\\n\\n\"\n        )\n        header_msg.seek(0)\n        assert_header_parsing(client.parse_headers(header_msg))\n\n    @pytest.mark.parametrize(\"host\", [\".localhost\", \"...\", \"t\" * 64])\n    def test_create_connection_with_invalid_idna_labels(self, host):\n        with pytest.raises(LocationParseError) as ctx:\n            create_connection((host, 80))\n        assert str(ctx.value) == \"Failed to parse: '%s', label empty or too long\" % host\n\n    @pytest.mark.parametrize(\n        \"host\",\n        [\n            \"a.example.com\",\n            \"localhost.\",\n            \"[dead::beef]\",\n            \"[dead::beef%en5]\",\n            \"[dead::beef%en5.]\",\n        ],\n    )\n    @patch(\"socket.getaddrinfo\")\n    @patch(\"socket.socket\")\n    def test_create_connection_with_valid_idna_labels(self, socket, getaddrinfo, host):\n        getaddrinfo.return_value = [(None, None, None, None, None)]\n        socket.return_value = Mock()\n        create_connection((host, 80))\n\n\nclass TestUtilSSL(object):\n    \"\"\"Test utils that use an SSL backend.\"\"\"\n\n    @pytest.mark.parametrize(\n        \"candidate, requirements\",\n        [\n            (None, ssl.CERT_REQUIRED),\n            (ssl.CERT_NONE, ssl.CERT_NONE),\n            (ssl.CERT_REQUIRED, ssl.CERT_REQUIRED),\n            (\"REQUIRED\", ssl.CERT_REQUIRED),\n            (\"CERT_REQUIRED\", ssl.CERT_REQUIRED),\n        ],\n    )\n    def test_resolve_cert_reqs(self, candidate, requirements):\n        assert resolve_cert_reqs(candidate) == requirements\n\n    @pytest.mark.parametrize(\n        \"candidate, version\",\n        [\n            (ssl.PROTOCOL_TLSv1, ssl.PROTOCOL_TLSv1),\n            (\"PROTOCOL_TLSv1\", ssl.PROTOCOL_TLSv1),\n            (\"TLSv1\", ssl.PROTOCOL_TLSv1),\n            (ssl.PROTOCOL_SSLv23, ssl.PROTOCOL_SSLv23),\n        ],\n    )\n    def test_resolve_ssl_version(self, candidate, version):\n        assert resolve_ssl_version(candidate) == version\n\n    def test_ssl_wrap_socket_loads_the_cert_chain(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, sock=socket, certfile=\"/path/to/certfile\"\n        )\n\n        mock_context.load_cert_chain.assert_called_once_with(\"/path/to/certfile\", None)\n\n    @patch(\"urllib3.util.ssl_.create_urllib3_context\")\n    def test_ssl_wrap_socket_creates_new_context(self, create_urllib3_context):\n        socket = object()\n        ssl_wrap_socket(sock=socket, cert_reqs=\"CERT_REQUIRED\")\n\n        create_urllib3_context.assert_called_once_with(\n            None, \"CERT_REQUIRED\", ciphers=None\n        )\n\n    def test_ssl_wrap_socket_loads_verify_locations(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(ssl_context=mock_context, ca_certs=\"/path/to/pem\", sock=socket)\n        mock_context.load_verify_locations.assert_called_once_with(\n            \"/path/to/pem\", None, None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_directories(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_dir=\"/path/to/pems\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, \"/path/to/pems\", None\n        )\n\n    def test_ssl_wrap_socket_loads_certificate_data(self):\n        socket = object()\n        mock_context = Mock()\n        ssl_wrap_socket(\n            ssl_context=mock_context, ca_cert_data=\"TOTALLY PEM DATA\", sock=socket\n        )\n        mock_context.load_verify_locations.assert_called_once_with(\n            None, None, \"TOTALLY PEM DATA\"\n        )\n\n    def _wrap_socket_and_mock_warn(self, sock, server_hostname):\n        mock_context = Mock()\n        with patch(\"warnings.warn\") as warn:\n            ssl_wrap_socket(\n                ssl_context=mock_context,\n                sock=sock,\n                server_hostname=server_hostname,\n            )\n        return mock_context, warn\n\n    def test_ssl_wrap_socket_sni_hostname_use_or_warn(self):\n        \"\"\"Test that either an SNI hostname is used or a warning is made.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, \"www.google.com\")\n        if util.HAS_SNI:\n            warn.assert_not_called()\n            context.wrap_socket.assert_called_once_with(\n                sock, server_hostname=\"www.google.com\"\n            )\n        else:\n            assert warn.call_count >= 1\n            warnings = [call[0][1] for call in warn.call_args_list]\n            assert SNIMissingWarning in warnings\n            context.wrap_socket.assert_called_once_with(sock)\n\n    def test_ssl_wrap_socket_sni_ip_address_no_warn(self):\n        \"\"\"Test that a warning is not made if server_hostname is an IP address.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, \"8.8.8.8\")\n        if util.IS_SECURETRANSPORT:\n            context.wrap_socket.assert_called_once_with(sock, server_hostname=\"8.8.8.8\")\n        else:\n            context.wrap_socket.assert_called_once_with(sock)\n        warn.assert_not_called()\n\n    def test_ssl_wrap_socket_sni_none_no_warn(self):\n        \"\"\"Test that a warning is not made if server_hostname is not given.\"\"\"\n        sock = object()\n        context, warn = self._wrap_socket_and_mock_warn(sock, None)\n        context.wrap_socket.assert_called_once_with(sock)\n        warn.assert_not_called()\n"], "filenames": ["src/urllib3/util/url.py", "test/test_util.py"], "buggy_code_start_loc": [66, 440], "buggy_code_end_loc": [369, 440], "fixing_code_start_loc": [66, 441], "fixing_code_end_loc": [371, 451], "type": "CWE-400", "message": "An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking, causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect.", "other": {"cve": {"id": "CVE-2021-33503", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-29T11:15:07.847", "lastModified": "2023-01-24T19:35:56.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking, causing a denial of service if a URL were passed as a parameter or redirected to via an HTTP redirect."}, {"lang": "es", "value": "Se ha detectado un problema en urllib3 versiones anteriores a 1.26.5. Cuando se proporciona una URL que contiene muchos caracteres @ en el componente authority, la expresi\u00f3n regular de autoridad muestra un retroceso catastr\u00f3fico, causando una denegaci\u00f3n de servicio si fue pasado una URL como par\u00e1metro o es redirigido a ella por medio de un redireccionamiento HTTP"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python:urllib3:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.25.4", "matchCriteriaId": "DE6ED8B6-5858-42F0-A646-503FAB8EE39C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:python:urllib3:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.26.0", "versionEndExcluding": "1.26.5", "matchCriteriaId": "F4967244-2BB6-4780-9FC3-00FD40248457"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_ops_center:12.4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "B095CC03-7077-4A58-AB25-CC5380CDCE5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:instantis_enterprisetrack:17.1:*:*:*:*:*:*:*", "matchCriteriaId": "82EA4BA7-C38B-4AF3-8914-9E3D089EBDD4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:instantis_enterprisetrack:17.2:*:*:*:*:*:*:*", "matchCriteriaId": "B9C9BC66-FA5F-4774-9BDA-7AB88E2839C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:instantis_enterprisetrack:17.3:*:*:*:*:*:*:*", "matchCriteriaId": "7F69B9A5-F21B-4904-9F27-95C0F7A628E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:zfs_storage_appliance_kit:8.8:*:*:*:*:*:*:*", "matchCriteriaId": "D3E503FB-6279-4D4A-91D8-E237ECF9D2B0"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-q2q7-5pp4-w6pg", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/urllib3/urllib3/commit/2d4a3fee6de2fa45eb82169361918f759269b4ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6SCV7ZNAHS3E6PBFLJGENCDRDRWRZZ6W/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FMUGWEAUYGGHTPPXT6YBD53WYXQGVV73/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-36", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/urllib3/urllib3/commit/2d4a3fee6de2fa45eb82169361918f759269b4ec"}}