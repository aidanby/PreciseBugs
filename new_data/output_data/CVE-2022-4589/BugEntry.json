{"buggy_code": ["\"\"\"Unit Tests for the termsandconditions module\"\"\"\n\n# pylint: disable=R0904, C0103\nimport time\nfrom importlib import import_module\nimport logging\n\nfrom django.core import mail\nfrom django.core.cache import cache\nfrom django.http import HttpResponseRedirect\nfrom django.conf import settings\nfrom django.test import TestCase, RequestFactory\nfrom django.contrib.auth.models import User, ContentType, Permission\nfrom django.template import Context, Template\n\nfrom .models import TermsAndConditions, UserTermsAndConditions, DEFAULT_TERMS_SLUG\nfrom .pipeline import user_accept_terms\nfrom .templatetags.terms_tags import show_terms_if_not_agreed\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\n\n\nclass TermsAndConditionsTests(TestCase):\n    \"\"\"Tests Terms and Conditions Module\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        LOGGER.debug(\"Test Setup\")\n\n        self.su = User.objects.create_superuser(\"su\", \"su@example.com\", \"superstrong\")\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.user2 = User.objects.create_user(\n            \"user2\", \"user2@user2.com\", \"user2password\"\n        )\n        self.user3 = User.objects.create_user(\n            \"user3\", \"user3@user3.com\", \"user3password\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        self.terms2 = TermsAndConditions.objects.create(\n            id=2,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2012-01-05\",\n        )\n        self.terms3 = TermsAndConditions.objects.create(\n            id=3,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 1.5\",\n            version_number=1.5,\n            date_active=\"2012-01-01\",\n        )\n        self.terms4 = TermsAndConditions.objects.create(\n            id=4,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2100-01-01\",\n        )\n\n        # give user3 permission to skip T&Cs\n        content_type = ContentType.objects.get_for_model(type(self.user3))\n        self.skip_perm = Permission.objects.create(\n            content_type=content_type, name=\"Can skip T&Cs\", codename=\"can_skip_t&c\"\n        )\n        self.user3.user_permissions.add(self.skip_perm)\n\n    def tearDown(self):\n        \"\"\"Teardown for each test\"\"\"\n        LOGGER.debug(\"Test TearDown\")\n        User.objects.all().delete()\n        TermsAndConditions.objects.all().delete()\n        UserTermsAndConditions.objects.all().delete()\n\n    def test_social_redirect(self):\n        \"\"\"Test the agreed_to_terms redirect from social pipeline\"\"\"\n        LOGGER.debug(\"Test the social pipeline\")\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, HttpResponseRedirect)\n\n        # Accept the terms and try again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, dict)\n\n    def test_get_active_terms_list(self):\n        \"\"\"Test get list of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_list()\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_get_active_terms_not_agreed_to(self):\n        \"\"\"Test get T&Cs not agreed to\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user1)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_user_is_excluded(self):\n        \"\"\"Test user3 has perm which excludes them from having to accept T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user3)\n        self.assertEqual([], active_list)\n\n    def test_superuser_is_not_implicitly_excluded(self):\n        \"\"\"Test su should have to accept T&Cs even if they are superuser but don't explicitly have the skip perm\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_cannot_skip(self):\n        \"\"\"Test su still has to accept even if they are explicitly given the skip perm\"\"\"\n        self.su.user_permissions.add(self.skip_perm)\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_excluded(self):\n        \"\"\"Test su doesn't have to accept with TERMS_EXCLUDE_SUPERUSERS set\"\"\"\n        with self.settings(TERMS_EXCLUDE_SUPERUSERS=True):\n            active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n            self.assertEqual([], active_list)\n\n    def test_get_active_terms_ids(self):\n        \"\"\"Test get ids of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_ids()\n        self.assertEqual(2, len(active_list))\n        self.assertEqual(active_list, [3, 2])\n\n    def test_terms_and_conditions_models(self):\n        \"\"\"Various tests of the TermsAndConditions Module\"\"\"\n\n        # Testing Direct Assignment of Acceptance\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms1)\n        UserTermsAndConditions.objects.create(user=self.user2, terms=self.terms3)\n\n        self.assertEquals(1.0, self.user1.userterms.get().terms.version_number)\n        self.assertEquals(1.5, self.user2.userterms.get().terms.version_number)\n\n        self.assertEquals(\"user1\", self.terms1.users.all()[0].get_username())\n\n        # Testing the get_active static method of TermsAndConditions\n        self.assertEquals(\n            2.0, TermsAndConditions.get_active(slug=\"site-terms\").version_number\n        )\n        self.assertEquals(\n            1.5, TermsAndConditions.get_active(slug=\"contrib-terms\").version_number\n        )\n\n        # Testing the unicode method of TermsAndConditions\n        self.assertEquals(\n            \"site-terms-2.00\", str(TermsAndConditions.get_active(slug=\"site-terms\"))\n        )\n        self.assertEquals(\n            \"contrib-terms-1.50\",\n            str(TermsAndConditions.get_active(slug=\"contrib-terms\")),\n        )\n\n    def test_middleware_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if they are logged in, and decorator is on method\"\"\"\n\n        UserTermsAndConditions.objects.all().delete()\n\n        LOGGER.debug(\"Test user1 login for middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /secure/ after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/contrib-terms/?returnTo=/secure/\"\n        )\n\n    def test_terms_required_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if logged in, and decorator is on method\"\"\"\n\n        LOGGER.debug(\"Test /termsrequired/ pre login\")\n        not_logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            not_logged_in_response, \"/accounts/login/?next=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test user1 login\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /termsrequired/ after login\")\n        logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/?returnTo=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test no redirect for /termsrequired/ after accept\")\n        accepted_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/termsrequired/\"}, follow=True\n        )\n        self.assertContains(accepted_response, \"Please Accept\")\n\n        LOGGER.debug(\"Test response after termsrequired accept\")\n        terms_required_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertContains(terms_required_response, \"Please Accept\")\n\n    def test_accept(self):\n        \"\"\"Validate that accepting terms works\"\"\"\n\n        LOGGER.debug(\"Test user1 login for accept\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/ get\")\n        accept_response = self.client.get(\"/terms/accept/\", follow=True)\n        self.assertContains(accept_response, \"Accept\")\n\n        LOGGER.debug(\"Test /terms/accept/ post\")\n        chained_terms_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(chained_terms_response, \"Contributor\")\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/1.5/ post\")\n        accept_version_response = self.client.get(\n            \"/terms/accept/contrib-terms/1.5/\", follow=True\n        )\n        self.assertContains(\n            accept_version_response, \"Contributor Terms and Conditions 1.5\"\n        )\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_version_post_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(accept_version_post_response, \"Secure\")\n\n    def test_accept_redirect_safe(self):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test user1 login for test_accept_redirect\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/site-terms/1/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertRedirects(accept_response, \"/secure/\")\n\n    def test_accept_redirect_unsafe(self):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"http://attacker/\"}, follow=False\n        )\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_store_ip_address(self):\n        \"\"\"Test with IP address storage setting true (default)\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_store_ip_address_multiple(self):\n        \"\"\"Test storing IP address when it is a list\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\",\n            {\"terms\": 2, \"returnTo\": \"/secure/\"},\n            follow=True,\n            REMOTE_ADDR=\"0.0.0.0, 1.1.1.1\",\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_no_ip_address(self):\n        \"\"\"Test with IP address storage setting false\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        with self.settings(TERMS_STORE_IP_ADDRESS=False):\n            self.client.post(\n                \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n            )\n            user_terms = UserTermsAndConditions.objects.all()[0]\n            self.assertFalse(user_terms.ip_address)\n\n    def test_terms_upgrade(self):\n        \"\"\"Validate a user is prompted to accept terms again when new version comes out\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login pre upgrade\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertContains(logged_in_response, \"Contributor\")\n\n        # First, Accept Contributor Terms\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n\n        LOGGER.debug(\"Test upgrade terms\")\n        self.terms5 = TermsAndConditions.objects.create(\n            id=5,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Terms and Conditions2\",\n            version_number=2.5,\n            date_active=\"2012-02-05\",\n        )\n\n        LOGGER.debug(\"Test user1 is redirected when changing pages\")\n        post_upgrade_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            post_upgrade_response, \"/terms/accept/site-terms/?returnTo=/secure/\"\n        )\n\n    def test_no_middleware(self):\n        \"\"\"Test a secure page with the middleware excepting it\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login no middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/securetoo/\", follow=True)\n        self.assertContains(logged_in_response, \"SECOND\")\n\n        LOGGER.debug(\"Test startswith '/admin' pages not redirecting\")\n        admin_response = self.client.get(\"/admin\", follow=True)\n        self.assertContains(admin_response, \"administration\")\n\n    def test_anonymous_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions for Anonymous User\"\"\"\n        active_terms = TermsAndConditions.get_active_terms_list()\n\n        LOGGER.debug(\"Test /terms/ with anon\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in active_terms:\n            self.assertContains(root_response, terms.name)\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms with anon\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/contributor-terms/1.5 with anon\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n\n    def test_user_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions Page for Logged In User\"\"\"\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 2)\n\n        LOGGER.debug(\"Test /terms/ with user1\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n        self.assertContains(root_response, \"Sign Out\")\n\n        # Accept terms and check again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 1)\n        LOGGER.debug(\"Test /terms/ with user1 after accept\")\n        post_accept_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(post_accept_response, terms.text)\n        self.assertNotContains(post_accept_response, self.terms3.name)\n        self.assertContains(post_accept_response, \"Terms and Conditions\")\n        self.assertContains(post_accept_response, \"Sign Out\")\n\n        # Check by slug and version while logged in\n        LOGGER.debug(\"Test /terms/view/site-terms as user1\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms/1.5 as user1\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n        self.assertContains(version_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n    def test_user_pipeline(self):\n        \"\"\"Test the case of a user being partially created via the django-socialauth pipeline\"\"\"\n\n        LOGGER.debug(\"Test /terms/accept/ post for no user\")\n        no_user_response = self.client.post(\"/terms/accept/\", {\"terms\": 2}, follow=True)\n        self.assertContains(no_user_response, \"Home\")\n\n        user = {\"pk\": self.user1.id}\n        kwa = {\"user\": user}\n        partial_pipeline = {\"kwargs\": kwa}\n\n        engine = import_module(settings.SESSION_ENGINE)\n        store = engine.SessionStore()\n        store.save()\n        self.client.cookies[settings.SESSION_COOKIE_NAME] = store.session_key\n\n        session = self.client.session\n        session[\"partial_pipeline\"] = partial_pipeline\n        session.save()\n\n        self.assertTrue(\"partial_pipeline\" in self.client.session)\n\n        LOGGER.debug(\"Test /terms/accept/ post for pipeline user\")\n        pipeline_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/anon\"}, follow=True\n        )\n        self.assertContains(pipeline_response, \"Anon\")\n\n    def test_email_terms(self):\n        \"\"\"Test emailing terms and conditions\"\"\"\n        LOGGER.debug(\"Test /terms/email/\")\n        email_form_response = self.client.get(\"/terms/email/\", follow=True)\n        self.assertContains(email_form_response, \"Email\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_send_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"foo@foo.com\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertEqual(\n            len(mail.outbox), 1\n        )  # Check that there is one email in the test outbox\n        self.assertContains(email_send_response, \"Sent\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_fail_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"INVALID EMAIL ADDRESS\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertContains(email_fail_response, \"Invalid\")\n\n\nclass TermsAndConditionsTemplateTagsTestCase(TestCase):\n    \"\"\"Tests Tags for T&C\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.template_string_1 = (\n            \"{% load terms_tags %}\" \"{% show_terms_if_not_agreed %}\"\n        )\n        self.template_string_2 = (\n            \"{% load terms_tags %}\"\n            '{% show_terms_if_not_agreed slug=\"specific-terms\" %}'\n        )\n        self.template_string_3 = (\n            \"{% load terms_tags %}\" \"{% include terms.text|as_template %}\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        cache.clear()\n\n    def _make_context(self, url):\n        \"\"\"Build Up Context - Used in many tests\"\"\"\n        context = dict()\n        context[\"request\"] = RequestFactory()\n        context[\"request\"].user = self.user1\n        context[\"request\"].META = {\"PATH_INFO\": url}\n        return context\n\n    def render_template(self, string, context=None):\n        \"\"\"a helper method to render simplistic test templates\"\"\"\n        request = RequestFactory().get(\"/test\")\n        request.user = self.user1\n        request.context = context or {}\n        return Template(string).render(Context({\"request\": request}))\n\n    def test_show_terms_if_not_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag renders html code\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms if not agreed to\")\n        rendered = self.render_template(self.template_string_1)\n        terms = TermsAndConditions.get_active()\n        self.assertIn(terms.slug, rendered)\n\n    def test_not_show_terms_if_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag does not load if user agreed terms\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms once agreed to\")\n        terms = TermsAndConditions.get_active()\n        UserTermsAndConditions.objects.create(terms=terms, user=self.user1)\n        rendered = self.render_template(self.template_string_1)\n        self.assertNotIn(terms.slug, rendered)\n\n    def test_show_terms_if_not_agreed_on_protected_url_not_agreed(self):\n        \"\"\"Check terms on protected url if not agreed\"\"\"\n        context = self._make_context(\"/test\")\n        result = show_terms_if_not_agreed(context)\n        terms = TermsAndConditions.get_active(slug=DEFAULT_TERMS_SLUG)\n        self.assertEqual(result.get(\"not_agreed_terms\")[0], terms)\n\n    def test_show_terms_if_not_agreed_on_unprotected_url_not_agreed(self):\n        \"\"\"Check terms on unprotected url if not agreed\"\"\"\n        context = self._make_context(\"/\")\n        result = show_terms_if_not_agreed(context)\n        self.assertDictEqual(result, {\"not_agreed_terms\": False})\n\n    def test_as_template(self):\n        \"\"\"Test as_template template tag\"\"\"\n        terms = TermsAndConditions.get_active()\n        rendered = Template(self.template_string_3).render(Context({\"terms\": terms}))\n        self.assertIn(terms.text, rendered)\n", "\"\"\"Django Views for the termsandconditions module\"\"\"\nfrom urllib.parse import urlparse\n\n# pylint: disable=E1120,R0901,R0904\nfrom django.contrib.auth.models import User\nfrom django.db import IntegrityError\n\nfrom .forms import UserTermsAndConditionsModelForm, EmailTermsForm\nfrom .models import TermsAndConditions, UserTermsAndConditions\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nfrom django.contrib import messages\nfrom django.http import HttpResponseRedirect, Http404\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import DetailView, CreateView, FormView\nfrom django.template.loader import get_template\nimport logging\nfrom smtplib import SMTPException\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\nDEFAULT_TERMS_BASE_TEMPLATE = \"base.html\"\nDEFAULT_TERMS_IP_HEADER_NAME = \"REMOTE_ADDR\"\n\n\nclass GetTermsViewMixin(object):\n    \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n    def get_terms(self, kwargs):\n        \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n        slug = kwargs.get(\"slug\")\n        version = kwargs.get(\"version\")\n\n        if slug and version:\n            terms = [\n                TermsAndConditions.objects.filter(\n                    slug=slug, version_number=version\n                ).latest(\"date_active\")\n            ]\n        elif slug:\n            terms = [TermsAndConditions.get_active(slug)]\n        else:\n            # Return a list of not agreed to terms for the current user for the list view\n            terms = TermsAndConditions.get_active_terms_not_agreed_to(self.request.user)\n        return terms\n\n\nclass AcceptTermsView(CreateView, GetTermsViewMixin):\n    \"\"\"\n    Terms and Conditions Acceptance view\n\n    url: /terms/accept\n    \"\"\"\n\n    model = UserTermsAndConditions\n    form_class = UserTermsAndConditionsModelForm\n    template_name = \"termsandconditions/tc_accept_terms.html\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C to accept and catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AcceptTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n        return_to = self.request.GET.get(\"returnTo\", \"/\")\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Handles POST request.\n        \"\"\"\n        return_url = request.POST.get(\"returnTo\", \"/\")\n        terms_ids = request.POST.getlist(\"terms\")\n\n        parsed = urlparse(return_url)\n        if parsed.hostname and parsed.hostname not in settings.ALLOWED_HOSTS:\n            # Make sure the return url is a relative path or a trusted hostname\n            return_url = '/'\n\n        if not terms_ids:  # pragma: nocover\n            return HttpResponseRedirect(return_url)\n\n        if request.user.is_authenticated:\n            user = request.user\n        else:\n            # Get user out of saved pipeline from django-socialauth\n            if \"partial_pipeline\" in request.session:\n                user_pk = request.session[\"partial_pipeline\"][\"kwargs\"][\"user\"][\"pk\"]\n                user = User.objects.get(id=user_pk)\n            else:\n                return HttpResponseRedirect(\"/\")\n\n        store_ip_address = getattr(settings, \"TERMS_STORE_IP_ADDRESS\", True)\n        if store_ip_address:\n            ip_address = request.META.get(\n                getattr(settings, \"TERMS_IP_HEADER_NAME\", DEFAULT_TERMS_IP_HEADER_NAME)\n            )\n            if \",\" in ip_address:\n                ip_address = ip_address.split(\",\")[0].strip()\n        else:\n            ip_address = \"\"\n\n        for terms_id in terms_ids:\n            try:\n                new_user_terms = UserTermsAndConditions(\n                    user=user,\n                    terms=TermsAndConditions.objects.get(pk=int(terms_id)),\n                    ip_address=ip_address,\n                )\n                new_user_terms.save()\n            except IntegrityError:  # pragma: nocover\n                pass\n\n        return HttpResponseRedirect(return_url)\n\n\nclass EmailTermsView(FormView, GetTermsViewMixin):\n    \"\"\"\n    Email Terms and Conditions View\n\n    url: /terms/email\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_email_terms_form.html\"\n\n    form_class = EmailTermsForm\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C send, catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n\n        return_to = self.request.GET.get(\"returnTo\", \"/\")\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def form_valid(self, form):\n        \"\"\"Override of CreateView method, sends the email.\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.form_valid\")\n\n        template = get_template(\"termsandconditions/tc_email_terms.html\")\n        template_rendered = template.render({\"terms\": form.cleaned_data.get(\"terms\")})\n\n        LOGGER.debug(\"Email Terms Body:\")\n        LOGGER.debug(template_rendered)\n\n        try:\n            send_mail(\n                form.cleaned_data.get(\"email_subject\", _(\"Terms\")),\n                template_rendered,\n                settings.DEFAULT_FROM_EMAIL,\n                [form.cleaned_data.get(\"email_address\")],\n                fail_silently=False,\n            )\n            messages.add_message(\n                self.request, messages.INFO, _(\"Terms and Conditions Sent.\")\n            )\n        except SMTPException:  # pragma: no cover\n            messages.add_message(\n                self.request,\n                messages.ERROR,\n                _(\"An Error Occurred Sending Your Message.\"),\n            )\n\n        self.success_url = form.cleaned_data.get(\"returnTo\", \"/\") or \"/\"\n\n        return super().form_valid(form)\n\n    def form_invalid(self, form):\n        \"\"\"Override of CreateView method, logs invalid email form submissions.\"\"\"\n        LOGGER.debug(\"Invalid Email Form Submitted\")\n        messages.add_message(self.request, messages.ERROR, _(\"Invalid Email Address.\"))\n        return super().form_invalid(form)\n\n\nclass TermsView(DetailView, GetTermsViewMixin):\n    \"\"\"\n    View Unaccepted Terms and Conditions View\n\n    url: /terms/\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_view_terms.html\"\n    context_object_name = \"terms_list\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.TermsView.get_object\")\n        return self.get_terms(self.kwargs)\n\n\nclass TermsActiveView(TermsView):\n    \"\"\"\n    View Active Terms and Conditions View\n\n    url: /terms/active/\n    \"\"\"\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AllTermsView.get_object\")\n        return TermsAndConditions.get_active_terms_list()\n"], "fixing_code": ["\"\"\"Unit Tests for the termsandconditions module\"\"\"\n\n# pylint: disable=R0904, C0103\nimport time\nfrom importlib import import_module\nimport logging\n\nfrom django.core import mail\nfrom django.core.cache import cache\nfrom django.http import HttpResponseRedirect\nfrom django.conf import settings\nfrom django.test import TestCase, RequestFactory\nfrom django.contrib.auth.models import User, ContentType, Permission\nfrom django.template import Context, Template\n\nfrom .models import TermsAndConditions, UserTermsAndConditions, DEFAULT_TERMS_SLUG\nfrom .pipeline import user_accept_terms\nfrom .templatetags.terms_tags import show_terms_if_not_agreed\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\n\n\nclass TermsAndConditionsTests(TestCase):\n    \"\"\"Tests Terms and Conditions Module\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        LOGGER.debug(\"Test Setup\")\n\n        self.su = User.objects.create_superuser(\"su\", \"su@example.com\", \"superstrong\")\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.user2 = User.objects.create_user(\n            \"user2\", \"user2@user2.com\", \"user2password\"\n        )\n        self.user3 = User.objects.create_user(\n            \"user3\", \"user3@user3.com\", \"user3password\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        self.terms2 = TermsAndConditions.objects.create(\n            id=2,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2012-01-05\",\n        )\n        self.terms3 = TermsAndConditions.objects.create(\n            id=3,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 1.5\",\n            version_number=1.5,\n            date_active=\"2012-01-01\",\n        )\n        self.terms4 = TermsAndConditions.objects.create(\n            id=4,\n            slug=\"contrib-terms\",\n            name=\"Contributor Terms\",\n            text=\"Contributor Terms and Conditions 2\",\n            version_number=2.0,\n            date_active=\"2100-01-01\",\n        )\n\n        # give user3 permission to skip T&Cs\n        content_type = ContentType.objects.get_for_model(type(self.user3))\n        self.skip_perm = Permission.objects.create(\n            content_type=content_type, name=\"Can skip T&Cs\", codename=\"can_skip_t&c\"\n        )\n        self.user3.user_permissions.add(self.skip_perm)\n\n    def tearDown(self):\n        \"\"\"Teardown for each test\"\"\"\n        LOGGER.debug(\"Test TearDown\")\n        User.objects.all().delete()\n        TermsAndConditions.objects.all().delete()\n        UserTermsAndConditions.objects.all().delete()\n\n    def test_social_redirect(self):\n        \"\"\"Test the agreed_to_terms redirect from social pipeline\"\"\"\n        LOGGER.debug(\"Test the social pipeline\")\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, HttpResponseRedirect)\n\n        # Accept the terms and try again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        response = user_accept_terms(\"backend\", self.user1, \"123\")\n        self.assertIsInstance(response, dict)\n\n    def test_get_active_terms_list(self):\n        \"\"\"Test get list of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_list()\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_get_active_terms_not_agreed_to(self):\n        \"\"\"Test get T&Cs not agreed to\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user1)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_user_is_excluded(self):\n        \"\"\"Test user3 has perm which excludes them from having to accept T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.user3)\n        self.assertEqual([], active_list)\n\n    def test_superuser_is_not_implicitly_excluded(self):\n        \"\"\"Test su should have to accept T&Cs even if they are superuser but don't explicitly have the skip perm\"\"\"\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_cannot_skip(self):\n        \"\"\"Test su still has to accept even if they are explicitly given the skip perm\"\"\"\n        self.su.user_permissions.add(self.skip_perm)\n        active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n        self.assertEqual(2, len(active_list))\n        self.assertQuerysetEqual(active_list, [repr(self.terms3), repr(self.terms2)])\n\n    def test_superuser_excluded(self):\n        \"\"\"Test su doesn't have to accept with TERMS_EXCLUDE_SUPERUSERS set\"\"\"\n        with self.settings(TERMS_EXCLUDE_SUPERUSERS=True):\n            active_list = TermsAndConditions.get_active_terms_not_agreed_to(self.su)\n            self.assertEqual([], active_list)\n\n    def test_get_active_terms_ids(self):\n        \"\"\"Test get ids of active T&Cs\"\"\"\n        active_list = TermsAndConditions.get_active_terms_ids()\n        self.assertEqual(2, len(active_list))\n        self.assertEqual(active_list, [3, 2])\n\n    def test_terms_and_conditions_models(self):\n        \"\"\"Various tests of the TermsAndConditions Module\"\"\"\n\n        # Testing Direct Assignment of Acceptance\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms1)\n        UserTermsAndConditions.objects.create(user=self.user2, terms=self.terms3)\n\n        self.assertEquals(1.0, self.user1.userterms.get().terms.version_number)\n        self.assertEquals(1.5, self.user2.userterms.get().terms.version_number)\n\n        self.assertEquals(\"user1\", self.terms1.users.all()[0].get_username())\n\n        # Testing the get_active static method of TermsAndConditions\n        self.assertEquals(\n            2.0, TermsAndConditions.get_active(slug=\"site-terms\").version_number\n        )\n        self.assertEquals(\n            1.5, TermsAndConditions.get_active(slug=\"contrib-terms\").version_number\n        )\n\n        # Testing the unicode method of TermsAndConditions\n        self.assertEquals(\n            \"site-terms-2.00\", str(TermsAndConditions.get_active(slug=\"site-terms\"))\n        )\n        self.assertEquals(\n            \"contrib-terms-1.50\",\n            str(TermsAndConditions.get_active(slug=\"contrib-terms\")),\n        )\n\n    def test_middleware_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if they are logged in, and decorator is on method\"\"\"\n\n        UserTermsAndConditions.objects.all().delete()\n\n        LOGGER.debug(\"Test user1 login for middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /secure/ after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/contrib-terms/?returnTo=/secure/\"\n        )\n\n    def test_terms_required_redirect(self):\n        \"\"\"Validate that a user is redirected to the terms accept page if logged in, and decorator is on method\"\"\"\n\n        LOGGER.debug(\"Test /termsrequired/ pre login\")\n        not_logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            not_logged_in_response, \"/accounts/login/?next=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test user1 login\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /termsrequired/ after login\")\n        logged_in_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertRedirects(\n            logged_in_response, \"/terms/accept/?returnTo=/termsrequired/\"\n        )\n\n        LOGGER.debug(\"Test no redirect for /termsrequired/ after accept\")\n        accepted_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/termsrequired/\"}, follow=True\n        )\n        self.assertContains(accepted_response, \"Please Accept\")\n\n        LOGGER.debug(\"Test response after termsrequired accept\")\n        terms_required_response = self.client.get(\"/termsrequired/\", follow=True)\n        self.assertContains(terms_required_response, \"Please Accept\")\n\n    def test_accept(self):\n        \"\"\"Validate that accepting terms works\"\"\"\n\n        LOGGER.debug(\"Test user1 login for accept\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/ get\")\n        accept_response = self.client.get(\"/terms/accept/\", follow=True)\n        self.assertContains(accept_response, \"Accept\")\n\n        LOGGER.debug(\"Test /terms/accept/ post\")\n        chained_terms_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(chained_terms_response, \"Contributor\")\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/1.5/ post\")\n        accept_version_response = self.client.get(\n            \"/terms/accept/contrib-terms/1.5/\", follow=True\n        )\n        self.assertContains(\n            accept_version_response, \"Contributor Terms and Conditions 1.5\"\n        )\n\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        accept_version_post_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        self.assertContains(accept_version_post_response, \"Secure\")\n\n    def _post_accept(self, return_to):\n        # Pre-accept terms 2 and 3\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n\n        LOGGER.debug(\"Test user1 login for test_accept_redirect\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test /terms/accept/site-terms/1/ post\")\n        accept_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 1, \"returnTo\": return_to}, follow=True\n        )\n        return accept_response\n\n    def test_accept_redirect_safe(self):\n        accept_response = self._post_accept(\"/secure/\")\n        self.assertRedirects(accept_response, \"/secure/\")\n\n    def test_accept_redirect_unsafe(self):\n        accept_response = self._post_accept(\"http://attacker/\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_2(self):\n        accept_response = self._post_accept(\"//attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_3(self):\n        accept_response = self._post_accept(\"///attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_redirect_unsafe_4(self):\n        accept_response = self._post_accept(\"////attacker.com\")\n        self.assertRedirects(accept_response, \"/\")\n\n    def test_accept_store_ip_address(self):\n        \"\"\"Test with IP address storage setting true (default)\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_store_ip_address_multiple(self):\n        \"\"\"Test storing IP address when it is a list\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        self.client.post(\n            \"/terms/accept/\",\n            {\"terms\": 2, \"returnTo\": \"/secure/\"},\n            follow=True,\n            REMOTE_ADDR=\"0.0.0.0, 1.1.1.1\",\n        )\n        user_terms = UserTermsAndConditions.objects.all()[0]\n        self.assertEqual(user_terms.user, self.user1)\n        self.assertEqual(user_terms.terms, self.terms2)\n        self.assertTrue(user_terms.ip_address)\n\n    def test_accept_no_ip_address(self):\n        \"\"\"Test with IP address storage setting false\"\"\"\n        self.client.login(username=\"user1\", password=\"user1password\")\n        with self.settings(TERMS_STORE_IP_ADDRESS=False):\n            self.client.post(\n                \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/secure/\"}, follow=True\n            )\n            user_terms = UserTermsAndConditions.objects.all()[0]\n            self.assertFalse(user_terms.ip_address)\n\n    def test_terms_upgrade(self):\n        \"\"\"Validate a user is prompted to accept terms again when new version comes out\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login pre upgrade\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/secure/\", follow=True)\n        self.assertContains(logged_in_response, \"Contributor\")\n\n        # First, Accept Contributor Terms\n        LOGGER.debug(\"Test /terms/accept/contrib-terms/3/ post\")\n        self.client.post(\n            \"/terms/accept/\", {\"terms\": 3, \"returnTo\": \"/secure/\"}, follow=True\n        )\n\n        LOGGER.debug(\"Test upgrade terms\")\n        self.terms5 = TermsAndConditions.objects.create(\n            id=5,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Terms and Conditions2\",\n            version_number=2.5,\n            date_active=\"2012-02-05\",\n        )\n\n        LOGGER.debug(\"Test user1 is redirected when changing pages\")\n        post_upgrade_response = self.client.get(\"/secure/\", follow=True)\n        self.assertRedirects(\n            post_upgrade_response, \"/terms/accept/site-terms/?returnTo=/secure/\"\n        )\n\n    def test_no_middleware(self):\n        \"\"\"Test a secure page with the middleware excepting it\"\"\"\n\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms2)\n\n        LOGGER.debug(\"Test user1 login no middleware\")\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        LOGGER.debug(\"Test user1 not redirected after login\")\n        logged_in_response = self.client.get(\"/securetoo/\", follow=True)\n        self.assertContains(logged_in_response, \"SECOND\")\n\n        LOGGER.debug(\"Test startswith '/admin' pages not redirecting\")\n        admin_response = self.client.get(\"/admin\", follow=True)\n        self.assertContains(admin_response, \"administration\")\n\n    def test_anonymous_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions for Anonymous User\"\"\"\n        active_terms = TermsAndConditions.get_active_terms_list()\n\n        LOGGER.debug(\"Test /terms/ with anon\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in active_terms:\n            self.assertContains(root_response, terms.name)\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms with anon\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n\n        LOGGER.debug(\"Test /terms/view/contributor-terms/1.5 with anon\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n\n    def test_user_terms_view(self):\n        \"\"\"Test Accessing the View Terms and Conditions Page for Logged In User\"\"\"\n        login_response = self.client.login(username=\"user1\", password=\"user1password\")\n        self.assertTrue(login_response)\n\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 2)\n\n        LOGGER.debug(\"Test /terms/ with user1\")\n        root_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(root_response, terms.text)\n        self.assertContains(root_response, \"Terms and Conditions\")\n        self.assertContains(root_response, \"Sign Out\")\n\n        # Accept terms and check again\n        UserTermsAndConditions.objects.create(user=self.user1, terms=self.terms3)\n        user1_not_agreed_terms = TermsAndConditions.get_active_terms_not_agreed_to(\n            self.user1\n        )\n        self.assertEqual(len(user1_not_agreed_terms), 1)\n        LOGGER.debug(\"Test /terms/ with user1 after accept\")\n        post_accept_response = self.client.get(\"/terms/\", follow=True)\n        for terms in user1_not_agreed_terms:\n            self.assertContains(post_accept_response, terms.text)\n        self.assertNotContains(post_accept_response, self.terms3.name)\n        self.assertContains(post_accept_response, \"Terms and Conditions\")\n        self.assertContains(post_accept_response, \"Sign Out\")\n\n        # Check by slug and version while logged in\n        LOGGER.debug(\"Test /terms/view/site-terms as user1\")\n        slug_response = self.client.get(self.terms2.get_absolute_url(), follow=True)\n        self.assertContains(slug_response, self.terms2.name)\n        self.assertContains(slug_response, self.terms2.text)\n        self.assertContains(slug_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n        LOGGER.debug(\"Test /terms/view/site-terms/1.5 as user1\")\n        version_response = self.client.get(self.terms3.get_absolute_url(), follow=True)\n        self.assertContains(version_response, self.terms3.name)\n        self.assertContains(version_response, self.terms3.text)\n        self.assertContains(version_response, \"Terms and Conditions\")\n        self.assertContains(slug_response, \"Sign Out\")\n\n    def test_user_pipeline(self):\n        \"\"\"Test the case of a user being partially created via the django-socialauth pipeline\"\"\"\n\n        LOGGER.debug(\"Test /terms/accept/ post for no user\")\n        no_user_response = self.client.post(\"/terms/accept/\", {\"terms\": 2}, follow=True)\n        self.assertContains(no_user_response, \"Home\")\n\n        user = {\"pk\": self.user1.id}\n        kwa = {\"user\": user}\n        partial_pipeline = {\"kwargs\": kwa}\n\n        engine = import_module(settings.SESSION_ENGINE)\n        store = engine.SessionStore()\n        store.save()\n        self.client.cookies[settings.SESSION_COOKIE_NAME] = store.session_key\n\n        session = self.client.session\n        session[\"partial_pipeline\"] = partial_pipeline\n        session.save()\n\n        self.assertTrue(\"partial_pipeline\" in self.client.session)\n\n        LOGGER.debug(\"Test /terms/accept/ post for pipeline user\")\n        pipeline_response = self.client.post(\n            \"/terms/accept/\", {\"terms\": 2, \"returnTo\": \"/anon\"}, follow=True\n        )\n        self.assertContains(pipeline_response, \"Anon\")\n\n    def test_email_terms(self):\n        \"\"\"Test emailing terms and conditions\"\"\"\n        LOGGER.debug(\"Test /terms/email/\")\n        email_form_response = self.client.get(\"/terms/email/\", follow=True)\n        self.assertContains(email_form_response, \"Email\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_send_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"foo@foo.com\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertEqual(\n            len(mail.outbox), 1\n        )  # Check that there is one email in the test outbox\n        self.assertContains(email_send_response, \"Sent\")\n\n        LOGGER.debug(\"Test /terms/email/ post, expecting email fail\")\n        email_fail_response = self.client.post(\n            \"/terms/email/\",\n            {\n                \"email_address\": \"INVALID EMAIL ADDRESS\",\n                \"email_subject\": \"Terms Email\",\n                \"terms\": 2,\n                \"returnTo\": \"/\",\n            },\n            follow=True,\n        )\n        self.assertContains(email_fail_response, \"Invalid\")\n\n\nclass TermsAndConditionsTemplateTagsTestCase(TestCase):\n    \"\"\"Tests Tags for T&C\"\"\"\n\n    def setUp(self):\n        \"\"\"Setup for each test\"\"\"\n        self.user1 = User.objects.create_user(\n            \"user1\", \"user1@user1.com\", \"user1password\"\n        )\n        self.template_string_1 = (\n            \"{% load terms_tags %}\" \"{% show_terms_if_not_agreed %}\"\n        )\n        self.template_string_2 = (\n            \"{% load terms_tags %}\"\n            '{% show_terms_if_not_agreed slug=\"specific-terms\" %}'\n        )\n        self.template_string_3 = (\n            \"{% load terms_tags %}\" \"{% include terms.text|as_template %}\"\n        )\n        self.terms1 = TermsAndConditions.objects.create(\n            id=1,\n            slug=\"site-terms\",\n            name=\"Site Terms\",\n            text=\"Site Terms and Conditions 1\",\n            version_number=1.0,\n            date_active=\"2012-01-01\",\n        )\n        cache.clear()\n\n    def _make_context(self, url):\n        \"\"\"Build Up Context - Used in many tests\"\"\"\n        context = dict()\n        context[\"request\"] = RequestFactory()\n        context[\"request\"].user = self.user1\n        context[\"request\"].META = {\"PATH_INFO\": url}\n        return context\n\n    def render_template(self, string, context=None):\n        \"\"\"a helper method to render simplistic test templates\"\"\"\n        request = RequestFactory().get(\"/test\")\n        request.user = self.user1\n        request.context = context or {}\n        return Template(string).render(Context({\"request\": request}))\n\n    def test_show_terms_if_not_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag renders html code\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms if not agreed to\")\n        rendered = self.render_template(self.template_string_1)\n        terms = TermsAndConditions.get_active()\n        self.assertIn(terms.slug, rendered)\n\n    def test_not_show_terms_if_agreed(self):\n        \"\"\"test if show_terms_if_not_agreed template tag does not load if user agreed terms\"\"\"\n        LOGGER.debug(\"Test template tag not showing terms once agreed to\")\n        terms = TermsAndConditions.get_active()\n        UserTermsAndConditions.objects.create(terms=terms, user=self.user1)\n        rendered = self.render_template(self.template_string_1)\n        self.assertNotIn(terms.slug, rendered)\n\n    def test_show_terms_if_not_agreed_on_protected_url_not_agreed(self):\n        \"\"\"Check terms on protected url if not agreed\"\"\"\n        context = self._make_context(\"/test\")\n        result = show_terms_if_not_agreed(context)\n        terms = TermsAndConditions.get_active(slug=DEFAULT_TERMS_SLUG)\n        self.assertEqual(result.get(\"not_agreed_terms\")[0], terms)\n\n    def test_show_terms_if_not_agreed_on_unprotected_url_not_agreed(self):\n        \"\"\"Check terms on unprotected url if not agreed\"\"\"\n        context = self._make_context(\"/\")\n        result = show_terms_if_not_agreed(context)\n        self.assertDictEqual(result, {\"not_agreed_terms\": False})\n\n    def test_as_template(self):\n        \"\"\"Test as_template template tag\"\"\"\n        terms = TermsAndConditions.get_active()\n        rendered = Template(self.template_string_3).render(Context({\"terms\": terms}))\n        self.assertIn(terms.text, rendered)\n", "\"\"\"Django Views for the termsandconditions module\"\"\"\nfrom urllib.parse import urlparse\n\n# pylint: disable=E1120,R0901,R0904\nfrom django.contrib.auth.models import User\nfrom django.db import IntegrityError\n\nfrom .forms import UserTermsAndConditionsModelForm, EmailTermsForm\nfrom .models import TermsAndConditions, UserTermsAndConditions\nfrom django.conf import settings\nfrom django.core.mail import send_mail\nfrom django.contrib import messages\nfrom django.http import HttpResponseRedirect, Http404\nfrom django.utils.translation import gettext as _\nfrom django.views.generic import DetailView, CreateView, FormView\nfrom django.template.loader import get_template\nfrom django.utils.encoding import iri_to_uri\nimport logging\nfrom smtplib import SMTPException\n\nLOGGER = logging.getLogger(name=\"termsandconditions\")\nDEFAULT_TERMS_BASE_TEMPLATE = \"base.html\"\nDEFAULT_TERMS_IP_HEADER_NAME = \"REMOTE_ADDR\"\n\n\nclass GetTermsViewMixin(object):\n    \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n    def get_terms(self, kwargs):\n        \"\"\"Checks URL parameters for slug and/or version to pull the right TermsAndConditions object\"\"\"\n\n        slug = kwargs.get(\"slug\")\n        version = kwargs.get(\"version\")\n\n        if slug and version:\n            terms = [\n                TermsAndConditions.objects.filter(\n                    slug=slug, version_number=version\n                ).latest(\"date_active\")\n            ]\n        elif slug:\n            terms = [TermsAndConditions.get_active(slug)]\n        else:\n            # Return a list of not agreed to terms for the current user for the list view\n            terms = TermsAndConditions.get_active_terms_not_agreed_to(self.request.user)\n        return terms\n\n    def get_return_to(self, from_dict):\n        return_to = from_dict.get(\"returnTo\", \"/\")\n\n        if self.is_safe_url(return_to):\n            # Django recommends to use this together with the helper above\n            return iri_to_uri(return_to)\n\n        LOGGER.debug(\"Unsafe URL found: {}\".format(return_to))\n        return \"/\"\n\n    def is_safe_url(self, url):\n        # In Django 3.0 is_safe_url is renamed, so we import conditionally:\n        # https://docs.djangoproject.com/en/3.2/releases/3.0/#id3\n        try:\n            from django.utils.http import url_has_allowed_host_and_scheme\n        except ImportError:\n            from django.utils.http import (\n                is_safe_url as url_has_allowed_host_and_scheme,\n            )\n\n        return url_has_allowed_host_and_scheme(url, settings.ALLOWED_HOSTS)\n\n\nclass AcceptTermsView(CreateView, GetTermsViewMixin):\n    \"\"\"\n    Terms and Conditions Acceptance view\n\n    url: /terms/accept\n    \"\"\"\n\n    model = UserTermsAndConditions\n    form_class = UserTermsAndConditionsModelForm\n    template_name = \"termsandconditions/tc_accept_terms.html\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C to accept and catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AcceptTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n        return_to = self.get_return_to(self.request.GET)\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"\n        Handles POST request.\n        \"\"\"\n        return_url = self.get_return_to(self.request.POST)\n        terms_ids = request.POST.getlist(\"terms\")\n\n        if not terms_ids:  # pragma: nocover\n            return HttpResponseRedirect(return_url)\n\n        if request.user.is_authenticated:\n            user = request.user\n        else:\n            # Get user out of saved pipeline from django-socialauth\n            if \"partial_pipeline\" in request.session:\n                user_pk = request.session[\"partial_pipeline\"][\"kwargs\"][\"user\"][\"pk\"]\n                user = User.objects.get(id=user_pk)\n            else:\n                return HttpResponseRedirect(\"/\")\n\n        store_ip_address = getattr(settings, \"TERMS_STORE_IP_ADDRESS\", True)\n        if store_ip_address:\n            ip_address = request.META.get(\n                getattr(settings, \"TERMS_IP_HEADER_NAME\", DEFAULT_TERMS_IP_HEADER_NAME)\n            )\n            if \",\" in ip_address:\n                ip_address = ip_address.split(\",\")[0].strip()\n        else:\n            ip_address = \"\"\n\n        for terms_id in terms_ids:\n            try:\n                new_user_terms = UserTermsAndConditions(\n                    user=user,\n                    terms=TermsAndConditions.objects.get(pk=int(terms_id)),\n                    ip_address=ip_address,\n                )\n                new_user_terms.save()\n            except IntegrityError:  # pragma: nocover\n                pass\n\n        return HttpResponseRedirect(return_url)\n\n\nclass EmailTermsView(FormView, GetTermsViewMixin):\n    \"\"\"\n    Email Terms and Conditions View\n\n    url: /terms/email\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_email_terms_form.html\"\n\n    form_class = EmailTermsForm\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_initial(self):\n        \"\"\"Override of CreateView method, queries for which T&C send, catches returnTo from URL\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.get_initial\")\n\n        terms = self.get_terms(self.kwargs)\n\n        return_to = self.get_return_to(self.request.GET)\n\n        return {\"terms\": terms, \"returnTo\": return_to}\n\n    def form_valid(self, form):\n        \"\"\"Override of CreateView method, sends the email.\"\"\"\n        LOGGER.debug(\"termsandconditions.views.EmailTermsView.form_valid\")\n\n        template = get_template(\"termsandconditions/tc_email_terms.html\")\n        template_rendered = template.render({\"terms\": form.cleaned_data.get(\"terms\")})\n\n        LOGGER.debug(\"Email Terms Body:\")\n        LOGGER.debug(template_rendered)\n\n        try:\n            send_mail(\n                form.cleaned_data.get(\"email_subject\", _(\"Terms\")),\n                template_rendered,\n                settings.DEFAULT_FROM_EMAIL,\n                [form.cleaned_data.get(\"email_address\")],\n                fail_silently=False,\n            )\n            messages.add_message(\n                self.request, messages.INFO, _(\"Terms and Conditions Sent.\")\n            )\n        except SMTPException:  # pragma: no cover\n            messages.add_message(\n                self.request,\n                messages.ERROR,\n                _(\"An Error Occurred Sending Your Message.\"),\n            )\n\n        self.success_url = self.get_return_to(form.cleaned_data)\n\n        return super().form_valid(form)\n\n    def form_invalid(self, form):\n        \"\"\"Override of CreateView method, logs invalid email form submissions.\"\"\"\n        LOGGER.debug(\"Invalid Email Form Submitted\")\n        messages.add_message(self.request, messages.ERROR, _(\"Invalid Email Address.\"))\n        return super().form_invalid(form)\n\n\nclass TermsView(DetailView, GetTermsViewMixin):\n    \"\"\"\n    View Unaccepted Terms and Conditions View\n\n    url: /terms/\n    \"\"\"\n\n    template_name = \"termsandconditions/tc_view_terms.html\"\n    context_object_name = \"terms_list\"\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Pass additional context data\"\"\"\n        context = super().get_context_data(**kwargs)\n        context[\"terms_base_template\"] = getattr(\n            settings, \"TERMS_BASE_TEMPLATE\", DEFAULT_TERMS_BASE_TEMPLATE\n        )\n        return context\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.TermsView.get_object\")\n        return self.get_terms(self.kwargs)\n\n\nclass TermsActiveView(TermsView):\n    \"\"\"\n    View Active Terms and Conditions View\n\n    url: /terms/active/\n    \"\"\"\n\n    def get_object(self, queryset=None):\n        \"\"\"Override of DetailView method, queries for which T&C to return\"\"\"\n        LOGGER.debug(\"termsandconditions.views.AllTermsView.get_object\")\n        return TermsAndConditions.get_active_terms_list()\n"], "filenames": ["termsandconditions/tests.py", "termsandconditions/views.py"], "buggy_code_start_loc": [245, 16], "buggy_code_end_loc": [269, 183], "fixing_code_start_loc": [245, 17], "fixing_code_end_loc": [278, 201], "type": "CWE-601", "message": "A vulnerability has been found in cyface Terms and Conditions Module up to 2.0.9 and classified as problematic. Affected by this vulnerability is the function returnTo of the file termsandconditions/views.py. The manipulation leads to open redirect. The attack can be launched remotely. Upgrading to version 2.0.10 is able to address this issue. The name of the patch is 03396a1c2e0af95e12a45c5faef7e47a4b513e1a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216175.", "other": {"cve": {"id": "CVE-2022-4589", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-17T13:15:09.883", "lastModified": "2023-01-06T13:52:10.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in cyface Terms and Conditions Module up to 2.0.9 and classified as problematic. Affected by this vulnerability is the function returnTo of the file termsandconditions/views.py. The manipulation leads to open redirect. The attack can be launched remotely. Upgrading to version 2.0.10 is able to address this issue. The name of the patch is 03396a1c2e0af95e12a45c5faef7e47a4b513e1a. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-216175."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:django_terms_and_conditions_project:django_terms_and_conditions:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.10", "matchCriteriaId": "F2C43DF4-BBD4-4D53-9F33-3F078DDD6C04"}]}]}], "references": [{"url": "https://github.com/cyface/django-termsandconditions/commit/03396a1c2e0af95e12a45c5faef7e47a4b513e1a", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cyface/django-termsandconditions/pull/239", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cyface/django-termsandconditions/releases/tag/v2.0.10", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216175", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cyface/django-termsandconditions/commit/03396a1c2e0af95e12a45c5faef7e47a4b513e1a"}}