{"buggy_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/* Copyright (C) 2018-2022 Hans Petter Jansson\n *\n * This file is part of Chafa, a program that turns images into character art.\n *\n * Chafa is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Chafa is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Chafa.  If not, see <http://www.gnu.org/licenses/>. */\n\n#include \"config.h\"\n#include <assert.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <chafa.h>\n#include \"xwd-loader.h\"\n\n#define DEBUG(x)\n\ntypedef struct\n{\n    guint32 header_size;          /* Size of the header in bytes */\n    guint32 file_version;         /* X11WD file version (always 07h) */\n    guint32 pixmap_format;        /* Pixmap format */\n    guint32 pixmap_depth;         /* Pixmap depth in pixels */\n    guint32 pixmap_width;         /* Pixmap width in pixels */\n    guint32 pixmap_height;        /* Pixmap height in pixels */\n    guint32 x_offset;             /* Bitmap X offset */\n    guint32 byte_order;           /* Byte order of image data */\n    guint32 bitmap_unit;          /* Bitmap base data size */\n    guint32 bitmap_bit_order;     /* Bit-order of image data */\n    guint32 bitmap_pad;           /* Bitmap scan-line pad*/\n    guint32 bits_per_pixel;       /* Bits per pixel */\n    guint32 bytes_per_line;       /* Bytes per scan-line */\n    guint32 visual_class;         /* Class of the image */\n    guint32 red_mask;             /* Red mask */\n    guint32 green_mask;           /* Green mask */\n    guint32 blue_mask;            /* Blue mask */\n    guint32 bits_per_rgb;         /* Size of each color mask in bits */\n    guint32 n_colors;             /* Number of colors in image */\n    guint32 color_map_entries;    /* Number of entries in color map */\n    guint32 window_width;         /* Window width */\n    guint32 window_height;        /* Window height */\n    gint32  window_x;             /* Window upper left X coordinate */\n    gint32  window_y;             /* Window upper left Y coordinate */\n    guint32 window_border_width;  /* Window border width */\n}\nXwdHeader;\n\ntypedef struct\n{\n    guint32 pixel;\n    guint16 red;\n    guint16 green;\n    guint16 blue;\n    guint8 flags;\n    guint8 pad;\n}\nXwdColor;\n\nstruct XwdLoader\n{\n    FileMapping *mapping;\n    gconstpointer file_data;\n    gconstpointer image_data;\n    gsize file_data_len;\n    XwdHeader header;\n};\n\nDEBUG (\nstatic void\ndump_header (XwdHeader *header)\n{\n    g_printerr (\"Header size: %u\\n\"\n                \"File version: %u\\n\"\n                \"Pixmap format: %u\\n\"\n                \"Pixmap depth: %u\\n\"\n                \"Pixmap width: %u\\n\"\n                \"Pixmap height: %u\\n\"\n                \"X offset: %u\\n\"\n                \"Byte order: %u\\n\"\n                \"Bitmap unit: %u\\n\"\n                \"Bitmap bit order: %u\\n\"\n                \"Bitmap pad: %u\\n\"\n                \"Bits per pixel: %u\\n\"\n                \"Bytes per line: %u\\n\"\n                \"Visual class: %u\\n\"\n                \"Red mask: %u\\n\"\n                \"Green mask: %u\\n\"\n                \"Blue mask: %u\\n\"\n                \"Bits per RGB: %u\\n\"\n                \"Number of colors: %u\\n\"\n                \"Color map entries: %u\\n\"\n                \"Window width: %u\\n\"\n                \"Window height: %u\\n\"\n                \"Window X: %d\\n\"\n                \"Window Y: %d\\n\"\n                \"Window border width: %u\\n---\\n\",\n                header->header_size,\n                header->file_version,\n                header->pixmap_format,\n                header->pixmap_depth,\n                header->pixmap_width,\n                header->pixmap_height,\n                header->x_offset,\n                header->byte_order,\n                header->bitmap_unit,\n                header->bitmap_bit_order,\n                header->bitmap_pad,\n                header->bits_per_pixel,\n                header->bytes_per_line,\n                header->visual_class,\n                header->red_mask,\n                header->green_mask,\n                header->blue_mask,\n                header->bits_per_rgb,\n                header->n_colors,\n                header->color_map_entries,\n                header->window_width,\n                header->window_height,\n                header->window_x,\n                header->window_y,\n                header->window_border_width);\n}\n)\n\nstatic ChafaPixelType\ncompute_pixel_type (XwdLoader *loader)\n{\n    XwdHeader *h = &loader->header;\n\n    if (h->bits_per_pixel == 24)\n    {\n        if (h->byte_order == 0)\n            return CHAFA_PIXEL_BGR8;\n        else\n            return CHAFA_PIXEL_RGB8;\n    }\n\n    if (h->bits_per_pixel == 32)\n    {\n        if (h->byte_order == 0)\n            return CHAFA_PIXEL_BGRA8_PREMULTIPLIED;\n        else\n            return CHAFA_PIXEL_ARGB8_PREMULTIPLIED;\n    }\n\n    return CHAFA_PIXEL_MAX;\n}\n\n#define ASSERT_HEADER(x) if (!(x)) return FALSE\n\nstatic gboolean\nload_header (XwdLoader *loader) // gconstpointer in, gsize in_max_len, XwdHeader *header_out)\n{\n    XwdHeader *h = &loader->header;\n    XwdHeader in;\n    const guint32 *p = (const guint32 *) &in;\n\n    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))\n        return FALSE;\n\n    h->header_size = g_ntohl (*(p++));\n    h->file_version = g_ntohl (*(p++));\n    h->pixmap_format = g_ntohl (*(p++));\n    h->pixmap_depth = g_ntohl (*(p++));\n    h->pixmap_width = g_ntohl (*(p++));\n    h->pixmap_height = g_ntohl (*(p++));\n    h->x_offset = g_ntohl (*(p++));\n    h->byte_order = g_ntohl (*(p++));\n    h->bitmap_unit = g_ntohl (*(p++));\n    h->bitmap_bit_order = g_ntohl (*(p++));\n    h->bitmap_pad = g_ntohl (*(p++));\n    h->bits_per_pixel = g_ntohl (*(p++));\n    h->bytes_per_line = g_ntohl (*(p++));\n    h->visual_class = g_ntohl (*(p++));\n    h->red_mask = g_ntohl (*(p++));\n    h->green_mask = g_ntohl (*(p++));\n    h->blue_mask = g_ntohl (*(p++));\n    h->bits_per_rgb = g_ntohl (*(p++));\n    h->color_map_entries = g_ntohl (*(p++));\n    h->n_colors = g_ntohl (*(p++));\n    h->window_width = g_ntohl (*(p++));\n    h->window_height = g_ntohl (*(p++));\n    h->window_x = g_ntohl (*(p++));\n    h->window_y = g_ntohl (*(p++));\n    h->window_border_width = g_ntohl (*(p++));\n\n    /* Only support the most common/useful subset of XWD files out there;\n     * namely, that corresponding to screen dumps from modern X.Org servers. */\n\n    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));\n    ASSERT_HEADER (h->file_version == 7);\n    ASSERT_HEADER (h->pixmap_depth == 24);\n\n    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One\n     * of them is likely misunderstanding. Let's be lenient and accept either. */\n    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);\n\n    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));\n    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);\n\n    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);\n    if (!loader->file_data)\n        return FALSE;\n\n    ASSERT_HEADER (loader->file_data_len >= h->header_size\n                   + h->n_colors * sizeof (XwdColor)\n                   + h->pixmap_height * h->bytes_per_line);\n\n    loader->image_data = (const guint8 *) loader->file_data\n        + h->header_size + h->n_colors * sizeof (XwdColor);\n\n    return TRUE;\n}\n\nstatic XwdLoader *\nxwd_loader_new (void)\n{\n    return g_new0 (XwdLoader, 1);\n}\n\nXwdLoader *\nxwd_loader_new_from_mapping (FileMapping *mapping)\n{\n    XwdLoader *loader = NULL;\n    gboolean success = FALSE;\n\n    g_return_val_if_fail (mapping != NULL, NULL);\n\n    loader = xwd_loader_new ();\n    loader->mapping = mapping;\n\n    if (!load_header (loader))\n    {\n        g_free (loader);\n        return NULL;\n    }\n\n    DEBUG (dump_header (&loader->header));\n\n    if (loader->header.pixmap_width < 1 || loader->header.pixmap_width >= (1 << 28)\n        || loader->header.pixmap_height < 1 || loader->header.pixmap_height >= (1 << 28)\n        || (loader->header.pixmap_width * (guint64) loader->header.pixmap_height >= (1 << 29)))\n        goto out;\n\n    success = TRUE;\n\nout:\n    if (!success)\n    {\n        g_free (loader);\n        loader = NULL;\n    }\n\n    return loader;\n}\n\nvoid\nxwd_loader_destroy (XwdLoader *loader)\n{\n    if (loader->mapping)\n        file_mapping_destroy (loader->mapping);\n\n    g_free (loader);\n}\n\ngboolean\nxwd_loader_get_is_animation (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return FALSE;\n}\n\ngconstpointer\nxwd_loader_get_frame_data (XwdLoader *loader, ChafaPixelType *pixel_type_out,\n                           gint *width_out, gint *height_out, gint *rowstride_out)\n{\n    g_return_val_if_fail (loader != NULL, NULL);\n\n    if (pixel_type_out)\n        *pixel_type_out = compute_pixel_type (loader);\n    if (width_out)\n        *width_out = loader->header.pixmap_width;\n    if (height_out)\n        *height_out = loader->header.pixmap_height;\n    if (rowstride_out)\n        *rowstride_out = loader->header.bytes_per_line;\n\n    return loader->image_data;\n}\n\ngint\nxwd_loader_get_frame_delay (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return 0;\n}\n\nvoid\nxwd_loader_goto_first_frame (G_GNUC_UNUSED XwdLoader *loader)\n{\n}\n\ngboolean\nxwd_loader_goto_next_frame (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return FALSE;\n}\n\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/* Copyright (C) 2018-2022 Hans Petter Jansson\n *\n * This file is part of Chafa, a program that turns images into character art.\n *\n * Chafa is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Chafa is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Chafa.  If not, see <http://www.gnu.org/licenses/>. */\n\n#include \"config.h\"\n#include <assert.h>\n#include <errno.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include <chafa.h>\n#include \"xwd-loader.h\"\n\n#define DEBUG(x)\n\ntypedef struct\n{\n    guint32 header_size;          /* Size of the header in bytes */\n    guint32 file_version;         /* X11WD file version (always 07h) */\n    guint32 pixmap_format;        /* Pixmap format */\n    guint32 pixmap_depth;         /* Pixmap depth in pixels */\n    guint32 pixmap_width;         /* Pixmap width in pixels */\n    guint32 pixmap_height;        /* Pixmap height in pixels */\n    guint32 x_offset;             /* Bitmap X offset */\n    guint32 byte_order;           /* Byte order of image data */\n    guint32 bitmap_unit;          /* Bitmap base data size */\n    guint32 bitmap_bit_order;     /* Bit-order of image data */\n    guint32 bitmap_pad;           /* Bitmap scan-line pad*/\n    guint32 bits_per_pixel;       /* Bits per pixel */\n    guint32 bytes_per_line;       /* Bytes per scan-line */\n    guint32 visual_class;         /* Class of the image */\n    guint32 red_mask;             /* Red mask */\n    guint32 green_mask;           /* Green mask */\n    guint32 blue_mask;            /* Blue mask */\n    guint32 bits_per_rgb;         /* Size of each color mask in bits */\n    guint32 n_colors;             /* Number of colors in image */\n    guint32 color_map_entries;    /* Number of entries in color map */\n    guint32 window_width;         /* Window width */\n    guint32 window_height;        /* Window height */\n    gint32  window_x;             /* Window upper left X coordinate */\n    gint32  window_y;             /* Window upper left Y coordinate */\n    guint32 window_border_width;  /* Window border width */\n}\nXwdHeader;\n\ntypedef struct\n{\n    guint32 pixel;\n    guint16 red;\n    guint16 green;\n    guint16 blue;\n    guint8 flags;\n    guint8 pad;\n}\nXwdColor;\n\nstruct XwdLoader\n{\n    FileMapping *mapping;\n    gconstpointer file_data;\n    gconstpointer image_data;\n    gsize file_data_len;\n    XwdHeader header;\n};\n\nDEBUG (\nstatic void\ndump_header (XwdHeader *header)\n{\n    g_printerr (\"Header size: %u\\n\"\n                \"File version: %u\\n\"\n                \"Pixmap format: %u\\n\"\n                \"Pixmap depth: %u\\n\"\n                \"Pixmap width: %u\\n\"\n                \"Pixmap height: %u\\n\"\n                \"X offset: %u\\n\"\n                \"Byte order: %u\\n\"\n                \"Bitmap unit: %u\\n\"\n                \"Bitmap bit order: %u\\n\"\n                \"Bitmap pad: %u\\n\"\n                \"Bits per pixel: %u\\n\"\n                \"Bytes per line: %u\\n\"\n                \"Visual class: %u\\n\"\n                \"Red mask: %u\\n\"\n                \"Green mask: %u\\n\"\n                \"Blue mask: %u\\n\"\n                \"Bits per RGB: %u\\n\"\n                \"Number of colors: %u\\n\"\n                \"Color map entries: %u\\n\"\n                \"Window width: %u\\n\"\n                \"Window height: %u\\n\"\n                \"Window X: %d\\n\"\n                \"Window Y: %d\\n\"\n                \"Window border width: %u\\n---\\n\",\n                header->header_size,\n                header->file_version,\n                header->pixmap_format,\n                header->pixmap_depth,\n                header->pixmap_width,\n                header->pixmap_height,\n                header->x_offset,\n                header->byte_order,\n                header->bitmap_unit,\n                header->bitmap_bit_order,\n                header->bitmap_pad,\n                header->bits_per_pixel,\n                header->bytes_per_line,\n                header->visual_class,\n                header->red_mask,\n                header->green_mask,\n                header->blue_mask,\n                header->bits_per_rgb,\n                header->n_colors,\n                header->color_map_entries,\n                header->window_width,\n                header->window_height,\n                header->window_x,\n                header->window_y,\n                header->window_border_width);\n}\n)\n\nstatic ChafaPixelType\ncompute_pixel_type (XwdLoader *loader)\n{\n    XwdHeader *h = &loader->header;\n\n    if (h->bits_per_pixel == 24)\n    {\n        if (h->byte_order == 0)\n            return CHAFA_PIXEL_BGR8;\n        else\n            return CHAFA_PIXEL_RGB8;\n    }\n\n    if (h->bits_per_pixel == 32)\n    {\n        if (h->byte_order == 0)\n            return CHAFA_PIXEL_BGRA8_PREMULTIPLIED;\n        else\n            return CHAFA_PIXEL_ARGB8_PREMULTIPLIED;\n    }\n\n    return CHAFA_PIXEL_MAX;\n}\n\n#define ASSERT_HEADER(x) if (!(x)) return FALSE\n#define UNPACK_FIELD_U32(dest, src, field) ((dest)->field = GUINT32_FROM_BE ((src)->field))\n#define UNPACK_FIELD_S32(dest, src, field) ((dest)->field = GINT32_FROM_BE ((src)->field))\n\nstatic gboolean\nload_header (XwdLoader *loader)\n{\n    XwdHeader *h = &loader->header;\n    XwdHeader in;\n    const XwdHeader *inp;\n\n    if (!file_mapping_taste (loader->mapping, &in, 0, sizeof (in)))\n        return FALSE;\n\n    inp = &in;\n\n    UNPACK_FIELD_U32 (h, inp, header_size);\n    UNPACK_FIELD_U32 (h, inp, file_version);\n    UNPACK_FIELD_U32 (h, inp, pixmap_format);\n    UNPACK_FIELD_U32 (h, inp, pixmap_depth);\n    UNPACK_FIELD_U32 (h, inp, pixmap_width);\n    UNPACK_FIELD_U32 (h, inp, pixmap_height);\n    UNPACK_FIELD_U32 (h, inp, x_offset);\n    UNPACK_FIELD_U32 (h, inp, byte_order);\n    UNPACK_FIELD_U32 (h, inp, bitmap_unit);\n    UNPACK_FIELD_U32 (h, inp, bitmap_bit_order);\n    UNPACK_FIELD_U32 (h, inp, bitmap_pad);\n    UNPACK_FIELD_U32 (h, inp, bits_per_pixel);\n    UNPACK_FIELD_U32 (h, inp, bytes_per_line);\n    UNPACK_FIELD_U32 (h, inp, visual_class);\n    UNPACK_FIELD_U32 (h, inp, red_mask);\n    UNPACK_FIELD_U32 (h, inp, green_mask);\n    UNPACK_FIELD_U32 (h, inp, blue_mask);\n    UNPACK_FIELD_U32 (h, inp, bits_per_rgb);\n    UNPACK_FIELD_U32 (h, inp, color_map_entries);\n    UNPACK_FIELD_U32 (h, inp, n_colors);\n    UNPACK_FIELD_U32 (h, inp, window_width);\n    UNPACK_FIELD_U32 (h, inp, window_height);\n    UNPACK_FIELD_S32 (h, inp, window_x);\n    UNPACK_FIELD_S32 (h, inp, window_y);\n    UNPACK_FIELD_U32 (h, inp, window_border_width);\n\n    /* Only support the most common/useful subset of XWD files out there;\n     * namely, that corresponding to screen dumps from modern X.Org servers.\n     * We could check visual_class == 5 too, but the other fields convey all\n     * the info we need. */\n\n    ASSERT_HEADER (h->header_size >= sizeof (XwdHeader));\n    ASSERT_HEADER (h->header_size <= 65535);\n    ASSERT_HEADER (h->file_version == 7);\n    ASSERT_HEADER (h->pixmap_depth == 24);\n\n    /* Should be zero for truecolor/directcolor. Cap it to prevent overflows. */\n    ASSERT_HEADER (h->color_map_entries <= 256);\n\n    /* Xvfb sets bits_per_rgb to 8, but 'convert' uses 24 for the same image data. One\n     * of them is likely misunderstanding. Let's be lenient and accept either. */\n    ASSERT_HEADER (h->bits_per_rgb == 8 || h->bits_per_rgb == 24);\n\n    /* These are the pixel formats we allow. */\n    ASSERT_HEADER (h->bits_per_pixel == 24 || h->bits_per_pixel == 32);\n\n    /* Enforce sane dimensions. */\n    ASSERT_HEADER (h->pixmap_width >= 1 && h->pixmap_width <= 65535);\n    ASSERT_HEADER (h->pixmap_height >= 1 && h->pixmap_height <= 65535);\n\n    /* Make sure rowstride can actually hold a row's worth of data but is not padded to\n     * something ridiculous. */\n    ASSERT_HEADER (h->bytes_per_line >= h->pixmap_width * (h->bits_per_pixel / 8));\n    ASSERT_HEADER (h->bytes_per_line <= h->pixmap_width * (h->bits_per_pixel / 8) + 1024);\n\n    /* Make sure the total allocation/map is not too big. */\n    ASSERT_HEADER (h->bytes_per_line * h->pixmap_height < (1UL << 31) - 65536 - 256 * 32);\n\n    ASSERT_HEADER (compute_pixel_type (loader) < CHAFA_PIXEL_MAX);\n\n    loader->file_data = file_mapping_get_data (loader->mapping, &loader->file_data_len);\n    if (!loader->file_data)\n        return FALSE;\n\n    ASSERT_HEADER (loader->file_data_len >= h->header_size\n                   + h->color_map_entries * sizeof (XwdColor)\n                   + h->pixmap_height * (gsize) h->bytes_per_line);\n\n    loader->image_data = (const guint8 *) loader->file_data\n        + h->header_size + h->color_map_entries * sizeof (XwdColor);\n\n    return TRUE;\n}\n\nstatic XwdLoader *\nxwd_loader_new (void)\n{\n    return g_new0 (XwdLoader, 1);\n}\n\nXwdLoader *\nxwd_loader_new_from_mapping (FileMapping *mapping)\n{\n    XwdLoader *loader = NULL;\n    gboolean success = FALSE;\n\n    g_return_val_if_fail (mapping != NULL, NULL);\n\n    loader = xwd_loader_new ();\n    loader->mapping = mapping;\n\n    if (!load_header (loader))\n    {\n        g_free (loader);\n        return NULL;\n    }\n\n    DEBUG (dump_header (&loader->header));\n\n    if (loader->header.pixmap_width < 1 || loader->header.pixmap_width >= (1 << 28)\n        || loader->header.pixmap_height < 1 || loader->header.pixmap_height >= (1 << 28)\n        || (loader->header.pixmap_width * (guint64) loader->header.pixmap_height >= (1 << 29)))\n        goto out;\n\n    success = TRUE;\n\nout:\n    if (!success)\n    {\n        g_free (loader);\n        loader = NULL;\n    }\n\n    return loader;\n}\n\nvoid\nxwd_loader_destroy (XwdLoader *loader)\n{\n    if (loader->mapping)\n        file_mapping_destroy (loader->mapping);\n\n    g_free (loader);\n}\n\ngboolean\nxwd_loader_get_is_animation (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return FALSE;\n}\n\ngconstpointer\nxwd_loader_get_frame_data (XwdLoader *loader, ChafaPixelType *pixel_type_out,\n                           gint *width_out, gint *height_out, gint *rowstride_out)\n{\n    g_return_val_if_fail (loader != NULL, NULL);\n\n    if (pixel_type_out)\n        *pixel_type_out = compute_pixel_type (loader);\n    if (width_out)\n        *width_out = loader->header.pixmap_width;\n    if (height_out)\n        *height_out = loader->header.pixmap_height;\n    if (rowstride_out)\n        *rowstride_out = loader->header.bytes_per_line;\n\n    return loader->image_data;\n}\n\ngint\nxwd_loader_get_frame_delay (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return 0;\n}\n\nvoid\nxwd_loader_goto_first_frame (G_GNUC_UNUSED XwdLoader *loader)\n{\n}\n\ngboolean\nxwd_loader_goto_next_frame (G_GNUC_UNUSED XwdLoader *loader)\n{\n    return FALSE;\n}\n\n"], "filenames": ["tools/chafa/xwd-loader.c"], "buggy_code_start_loc": [167], "buggy_code_end_loc": [229], "fixing_code_start_loc": [168], "fixing_code_end_loc": [253], "type": "CWE-125", "message": "Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3.", "other": {"cve": {"id": "CVE-2022-2301", "sourceIdentifier": "security@huntr.dev", "published": "2022-07-04T11:15:13.357", "lastModified": "2022-07-12T16:13:05.917", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer Over-read in GitHub repository hpjansson/chafa prior to 1.10.3."}, {"lang": "es", "value": "Una Lectura Excesiva del b\u00fafer en el repositorio de GitHub hpjansson/chafa versiones anteriores a 1.10.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-126"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chafa_project:chafa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.3", "matchCriteriaId": "4A004083-B486-4D70-B91C-599EACD977C5"}]}]}], "references": [{"url": "https://github.com/hpjansson/chafa/commit/56fabfa18a6880b4cb66047fa6557920078048d9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/f6b9114b-671d-4948-b946-ffe5c9aeb816", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hpjansson/chafa/commit/56fabfa18a6880b4cb66047fa6557920078048d9"}}