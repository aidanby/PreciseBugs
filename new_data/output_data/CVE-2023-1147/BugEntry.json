{"buggy_code": ["<?php\n\nclass comment_indexer extends fs_filelister {\n\n\tfunction __construct($id) {\n\t\t$f = bdb_idtofile($id, BDB_COMMENT); // todo change\n\t\t$this->_directory = $f;\n\t\tparent::__construct();\n\t\t// substr(bdb_idtofile($id), -strlen(EXT));\n\t}\n\n\tfunction _checkFile($directory, $file) {\n\t\t$f = \"$directory/$file\";\n\t\tif (fnmatch('comment*' . EXT, $file)) {\n\t\t\tarray_push($this->_list, basename($file, EXT));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// overrides parent method to return sorted results\n\tfunction getList() {\n\t\tsort($this->_list);\n\t\treturn parent::getList();\n\t}\n\n}\n\n/**\n * function bdb_get_comments\n *\n * <p>On success returns an array containing the comment <b>IDs</b>, associated to\n * the entry ID in $id</p>\n * <p>On failure returns false</p>\n *\n * @param string $id\n *        \tstring formatted like \"prefixYYMMDD-HHMMSS.EXT\"\n * @return mixed\n *\n * @see bdb_idtofile()\n */\nfunction comment_getlist($id) {\n\t$obj = new comment_indexer($id); // todo change syntax\n\treturn $obj->getList();\n}\n\nfunction comment_parse($entryid, $id) {\n\t$f = comment_exists($entryid, $id);\n\n\tif (!$f)\n\t\treturn false;\n\n\t$fc = io_load_file($f);\n\t$arr = utils_kexplode($fc);\n\n\t// $arr['EMAIL'] = apply_filters('comment_email', $arr['EMAIL']);\n\t// hackish: dash to underscore for ip-address :( todo: clean this up here or somewhere else\n\t// $arr['ip_address'] = $arr['ip-address'];\n\treturn array_change_key_case($arr, CASE_LOWER);\n}\n\nfunction comment_exists($entryid, $id) {\n\tif (!preg_match('|^comment[0-9]{6}-[0-9]{6}$|', $id))\n\t\treturn false;\n\t$f = entry_exists($entryid);\n\tif (!$f)\n\t\treturn false;\n\n\t$f2 = substr($f, 0, -strlen(EXT)) . '/comments/' . $id . EXT;\n\tif (!file_exists($f2))\n\t\treturn false;\n\n\treturn $f2;\n}\n\nfunction comment_clean(&$arr) {\n\t$arr ['name'] = apply_filters('pre_comment_author_name', stripslashes($arr ['name']));\n\tif (isset($arr ['email']))\n\t\t$arr ['email'] = apply_filters('pre_comment_author_email', $arr ['email']);\n\tif (isset($arr ['url']))\n\t\t$arr ['url'] = apply_filters('pre_comment_author_url', $arr ['url']);\n\t$arr ['content'] = apply_filters('pre_comment_content', $arr ['content']);\n\treturn $arr;\n}\n\n/**\n * function bdb_save_comment\n *\n * <p>Saves the content of the $comment array, associating it to the entry-ID $id.</p>\n * <p>$comment must be formatted as the one returned by {@link bdb_parse_entry()}.</p>\n * <p>Returns true on success, or false on failure</p>\n *\n * @param string $id\n *        \tstring formatted like \"prefixYYMMDD-HHMMSS\"\n * @param array $comment\n *        \tarray formatted as the one returned by {@link bdb_parse_entry()}\n * @return bool\n *\n * @see bdb_parse_entry()\n */\nfunction comment_save($id, $comment) {\n\tcomment_clean($comment);\n\n\t$comment = array_change_key_case($comment, CASE_UPPER);\n\n\t$comment_dir = bdb_idtofile($id, BDB_COMMENT);\n\n\tif (!isset($comment ['DATE']))\n\t\t$comment ['DATE'] = date_time();\n\t$id = bdb_idfromtime(BDB_COMMENT, $comment ['DATE']);\n\t$f = $comment_dir . $id . EXT;\n\t$str = utils_kimplode($comment);\n\tif (io_write_file($f, $str))\n\t\treturn $id;\n\n\treturn false;\n}\n\n/**\n * function comment_delete\n *\n * <p>Deletes the $id comment</p>\n * <p>Returns true on success, or false on failure</p>\n *\n * @param string $id\n *        \tstring formatted like \"entryYYMMDD-HHMMSS\"\n * @param string $comment_id\n *        \tstring representig comment id as in \"commentYYMMDD-HHMMSS\"\n * @return bool\n *\n * @see entry_delete()\n */\nfunction comment_delete($id, $comment_id) {\n\tdo_action('comment_delete', $id, $comment_id);\n\t$comment_dir = bdb_idtofile($id, BDB_COMMENT);\n\t$f = $comment_dir . $comment_id . EXT;\n\treturn fs_delete($f);\n}\n\nfunction dummy_comment($val) {\n\treturn $val;\n}\n\nadd_filter('comment_validate', 'dummy_comment');\n\n?>\n"], "fixing_code": ["<?php\n\nclass comment_indexer extends fs_filelister {\n\n\tfunction __construct($id) {\n\t\t$f = bdb_idtofile($id, BDB_COMMENT); // todo change\n\t\t$this->_directory = $f;\n\t\tparent::__construct();\n\t\t// substr(bdb_idtofile($id), -strlen(EXT));\n\t}\n\n\tfunction _checkFile($directory, $file) {\n\t\t$f = \"$directory/$file\";\n\t\tif (fnmatch('comment*' . EXT, $file)) {\n\t\t\tarray_push($this->_list, basename($file, EXT));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t// overrides parent method to return sorted results\n\tfunction getList() {\n\t\tsort($this->_list);\n\t\treturn parent::getList();\n\t}\n\n}\n\n/**\n * function bdb_get_comments\n *\n * <p>On success returns an array containing the comment <b>IDs</b>, associated to\n * the entry ID in $id</p>\n * <p>On failure returns false</p>\n *\n * @param string $id\n *        \tstring formatted like \"prefixYYMMDD-HHMMSS.EXT\"\n * @return mixed\n *\n * @see bdb_idtofile()\n */\nfunction comment_getlist($id) {\n\t$obj = new comment_indexer($id); // todo change syntax\n\treturn $obj->getList();\n}\n\nfunction comment_parse($entryid, $id) {\n\t$f = comment_exists($entryid, $id);\n\n\tif (!$f)\n\t\treturn false;\n\n\t$fc = io_load_file($f);\n\t$arr = utils_kexplode($fc);\n\n\t// $arr['EMAIL'] = apply_filters('comment_email', $arr['EMAIL']);\n\t// hackish: dash to underscore for ip-address :( todo: clean this up here or somewhere else\n\t// $arr['ip_address'] = $arr['ip-address'];\n\treturn array_change_key_case($arr, CASE_LOWER);\n}\n\nfunction comment_exists($entryid, $id) {\n\tif (!preg_match('|^comment[0-9]{6}-[0-9]{6}$|', $id))\n\t\treturn false;\n\t$f = entry_exists($entryid);\n\tif (!$f)\n\t\treturn false;\n\n\t$f2 = substr($f, 0, -strlen(EXT)) . '/comments/' . $id . EXT;\n\tif (!file_exists($f2))\n\t\treturn false;\n\n\treturn $f2;\n}\n\nfunction comment_clean(&$arr) {\n\t$arr ['name'] = strip_tags(apply_filters('pre_comment_author_name', stripslashes($arr ['name'])));\n\tif (isset($arr ['email'])) {\n\t\t$arr ['email'] = strip_tags(apply_filters('pre_comment_author_email', $arr ['email']));\n\t}\n\tif (isset($arr ['url'])) {\n\t\t$arr ['url'] = strip_tags(apply_filters('pre_comment_author_url', $arr ['url']));\n\t}\n\t$arr ['content'] = strip_tags(apply_filters('pre_comment_content', $arr ['content']));\n\treturn $arr;\n}\n\n/**\n * function bdb_save_comment\n *\n * <p>Saves the content of the $comment array, associating it to the entry-ID $id.</p>\n * <p>$comment must be formatted as the one returned by {@link bdb_parse_entry()}.</p>\n * <p>Returns true on success, or false on failure</p>\n *\n * @param string $id\n *        \tstring formatted like \"prefixYYMMDD-HHMMSS\"\n * @param array $comment\n *        \tarray formatted as the one returned by {@link bdb_parse_entry()}\n * @return bool\n *\n * @see bdb_parse_entry()\n */\nfunction comment_save($id, $comment) {\n\tcomment_clean($comment);\n\n\t$comment = array_change_key_case($comment, CASE_UPPER);\n\n\t$comment_dir = bdb_idtofile($id, BDB_COMMENT);\n\n\tif (!isset($comment ['DATE']))\n\t\t$comment ['DATE'] = date_time();\n\t$id = bdb_idfromtime(BDB_COMMENT, $comment ['DATE']);\n\t$f = $comment_dir . $id . EXT;\n\t$str = utils_kimplode($comment);\n\tif (io_write_file($f, $str))\n\t\treturn $id;\n\n\treturn false;\n}\n\n/**\n * function comment_delete\n *\n * <p>Deletes the $id comment</p>\n * <p>Returns true on success, or false on failure</p>\n *\n * @param string $id\n *        \tstring formatted like \"entryYYMMDD-HHMMSS\"\n * @param string $comment_id\n *        \tstring representig comment id as in \"commentYYMMDD-HHMMSS\"\n * @return bool\n *\n * @see entry_delete()\n */\nfunction comment_delete($id, $comment_id) {\n\tdo_action('comment_delete', $id, $comment_id);\n\t$comment_dir = bdb_idtofile($id, BDB_COMMENT);\n\t$f = $comment_dir . $comment_id . EXT;\n\treturn fs_delete($f);\n}\n\nfunction dummy_comment($val) {\n\treturn $val;\n}\n\nadd_filter('comment_validate', 'dummy_comment');\n\n?>\n"], "filenames": ["fp-includes/core/core.comment.php"], "buggy_code_start_loc": [76], "buggy_code_end_loc": [82], "fixing_code_start_loc": [76], "fixing_code_end_loc": [84], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository flatpressblog/flatpress prior to 1.3.", "other": {"cve": {"id": "CVE-2023-1147", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-02T03:15:09.790", "lastModified": "2023-03-03T18:57:03.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository flatpressblog/flatpress prior to 1.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flatpress:flatpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3", "matchCriteriaId": "2C1FD291-99DD-40F3-96DB-D79CA8279692"}]}]}], "references": [{"url": "https://github.com/flatpressblog/flatpress/commit/264217f318a8852c4f3e34350d4a0e1363cdd727", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/187f5353-f866-4d26-a5ba-fca378520020", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flatpressblog/flatpress/commit/264217f318a8852c4f3e34350d4a0e1363cdd727"}}