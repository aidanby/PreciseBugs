{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Cryptographic Abstraction Layer\n *\n * Copyright 2011-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n\n#include <freerdp/log.h>\n#include <freerdp/crypto/crypto.h>\n\n#define TAG FREERDP_TAG(\"crypto\")\n\nCryptoCert crypto_cert_read(BYTE* data, UINT32 length)\n{\n\tCryptoCert cert = malloc(sizeof(*cert));\n\n\tif (!cert)\n\t\treturn NULL;\n\n\t/* this will move the data pointer but we don't care, we don't use it again */\n\tcert->px509 = d2i_X509(NULL, (D2I_X509_CONST BYTE**)&data, length);\n\treturn cert;\n}\n\nvoid crypto_cert_free(CryptoCert cert)\n{\n\tif (cert == NULL)\n\t\treturn;\n\n\tX509_free(cert->px509);\n\tfree(cert);\n}\n\nBOOL crypto_cert_get_public_key(CryptoCert cert, BYTE** PublicKey, DWORD* PublicKeyLength)\n{\n\tBYTE* ptr;\n\tint length;\n\tBOOL status = TRUE;\n\tEVP_PKEY* pkey = NULL;\n\tpkey = X509_get_pubkey(cert->px509);\n\n\tif (!pkey)\n\t{\n\t\tWLog_ERR(TAG, \"X509_get_pubkey() failed\");\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\tlength = i2d_PublicKey(pkey, NULL);\n\n\tif (length < 1)\n\t{\n\t\tWLog_ERR(TAG, \"i2d_PublicKey() failed\");\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\t*PublicKeyLength = (DWORD)length;\n\t*PublicKey = (BYTE*)malloc(length);\n\tptr = (BYTE*)(*PublicKey);\n\n\tif (!ptr)\n\t{\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\ti2d_PublicKey(pkey, &ptr);\nexit:\n\n\tif (pkey)\n\t\tEVP_PKEY_free(pkey);\n\n\treturn status;\n}\n\nstatic int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\n\tif (!input_reverse)\n\t\treturn -1;\n\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}\n\nstatic int crypto_rsa_public(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, exponent, EXPONENT_MAX_SIZE,\n\t                         output);\n}\n\nstatic int crypto_rsa_private(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, private_exponent, key_length,\n\t                         output);\n}\n\nint crypto_rsa_public_encrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_public(input, length, key_length, modulus, exponent, output);\n}\n\nint crypto_rsa_public_decrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_public(input, length, key_length, modulus, exponent, output);\n}\n\nint crypto_rsa_private_encrypt(const BYTE* input, int length, UINT32 key_length,\n                               const BYTE* modulus, const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_private(input, length, key_length, modulus, private_exponent, output);\n}\n\nint crypto_rsa_private_decrypt(const BYTE* input, int length, UINT32 key_length,\n                               const BYTE* modulus, const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_private(input, length, key_length, modulus, private_exponent, output);\n}\n\nstatic int crypto_rsa_decrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, private_exponent, key_length,\n\t                         output);\n}\n\nvoid crypto_reverse(BYTE* data, int length)\n{\n\tint i, j;\n\tBYTE temp;\n\n\tfor (i = 0, j = length - 1; i < j; i++, j--)\n\t{\n\t\ttemp = data[i];\n\t\tdata[i] = data[j];\n\t\tdata[j] = temp;\n\t}\n}\n\nchar* crypto_cert_fingerprint(X509* xcert)\n{\n\treturn crypto_cert_fingerprint_by_hash(xcert, \"sha256\");\n}\n\nBYTE* crypto_cert_hash(X509* xcert, const char* hash, UINT32* length)\n{\n\tUINT32 fp_len = EVP_MAX_MD_SIZE;\n\tBYTE* fp;\n\tconst EVP_MD* md = EVP_get_digestbyname(hash);\n\tif (!md)\n\t\treturn NULL;\n\tif (!length)\n\t\treturn NULL;\n\tif (!xcert)\n\t\treturn NULL;\n\n\tfp = calloc(fp_len, sizeof(BYTE));\n\tif (!fp)\n\t\treturn NULL;\n\n\tif (X509_digest(xcert, md, fp, &fp_len) != 1)\n\t{\n\t\tfree(fp);\n\t\treturn NULL;\n\t}\n\n\t*length = fp_len;\n\treturn fp;\n}\n\nchar* crypto_cert_fingerprint_by_hash(X509* xcert, const char* hash)\n{\n\tUINT32 fp_len, i;\n\tBYTE* fp;\n\tchar* p;\n\tchar* fp_buffer;\n\n\tfp = crypto_cert_hash(xcert, hash, &fp_len);\n\tif (!fp)\n\t\treturn NULL;\n\n\tfp_buffer = calloc(fp_len * 3 + 1, sizeof(char));\n\tif (!fp_buffer)\n\t\tgoto fail;\n\n\tp = fp_buffer;\n\n\tfor (i = 0; i < (fp_len - 1); i++)\n\t{\n\t\tsprintf_s(p, (fp_len - i) * 3, \"%02\" PRIx8 \":\", fp[i]);\n\t\tp = &fp_buffer[(i + 1) * 3];\n\t}\n\n\tsprintf_s(p, (fp_len - i) * 3, \"%02\" PRIx8 \"\", fp[i]);\nfail:\n\tfree(fp);\n\n\treturn fp_buffer;\n}\n\nstatic char* crypto_print_name(X509_NAME* name)\n{\n\tchar* buffer = NULL;\n\tBIO* outBIO = BIO_new(BIO_s_mem());\n\n\tif (X509_NAME_print_ex(outBIO, name, 0, XN_FLAG_ONELINE) > 0)\n\t{\n\t\tunsigned long size = BIO_number_written(outBIO);\n\t\tbuffer = calloc(1, size + 1);\n\n\t\tif (!buffer)\n\t\t\treturn NULL;\n\n\t\tBIO_read(outBIO, buffer, size);\n\t}\n\n\tBIO_free_all(outBIO);\n\treturn buffer;\n}\n\nchar* crypto_cert_subject(X509* xcert)\n{\n\treturn crypto_print_name(X509_get_subject_name(xcert));\n}\n\nchar* crypto_cert_subject_common_name(X509* xcert, int* length)\n{\n\tint index;\n\tBYTE* common_name_raw;\n\tchar* common_name;\n\tX509_NAME* subject_name;\n\tX509_NAME_ENTRY* entry;\n\tASN1_STRING* entry_data;\n\tsubject_name = X509_get_subject_name(xcert);\n\n\tif (subject_name == NULL)\n\t\treturn NULL;\n\n\tindex = X509_NAME_get_index_by_NID(subject_name, NID_commonName, -1);\n\n\tif (index < 0)\n\t\treturn NULL;\n\n\tentry = X509_NAME_get_entry(subject_name, index);\n\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\tentry_data = X509_NAME_ENTRY_get_data(entry);\n\n\tif (entry_data == NULL)\n\t\treturn NULL;\n\n\t*length = ASN1_STRING_to_UTF8(&common_name_raw, entry_data);\n\n\tif (*length < 0)\n\t\treturn NULL;\n\n\tcommon_name = _strdup((char*)common_name_raw);\n\tOPENSSL_free(common_name_raw);\n\treturn (char*)common_name;\n}\n\n/* GENERAL_NAME type labels */\n\nstatic const char* general_name_type_labels[] = { \"OTHERNAME\", \"EMAIL    \", \"DNS      \",\n\t                                              \"X400     \", \"DIRNAME  \", \"EDIPARTY \",\n\t                                              \"URI      \", \"IPADD    \", \"RID      \" };\n\nstatic const char* general_name_type_label(int general_name_type)\n{\n\tif ((0 <= general_name_type) &&\n\t    ((size_t)general_name_type < ARRAYSIZE(general_name_type_labels)))\n\t{\n\t\treturn general_name_type_labels[general_name_type];\n\t}\n\telse\n\t{\n\t\tstatic char buffer[80];\n\t\tsprintf(buffer, \"Unknown general name type (%d)\", general_name_type);\n\t\treturn buffer;\n\t}\n}\n\n/*\n\nmap_subject_alt_name(x509,  general_name_type, mapper, data)\n\nCall the function mapper with subjectAltNames found in the x509\ncertificate and data.  if generate_name_type is GEN_ALL,  the the\nmapper is called for all the names,  else it's called only for names\nof the given type.\n\n\nWe implement two extractors:\n\n -  a string extractor that can be used to get the subjectAltNames of\n    the following types: GEN_URI,  GEN_DNS,  GEN_EMAIL\n\n - a ASN1_OBJECT filter/extractor that can be used to get the\n   subjectAltNames of OTHERNAME type.\n\n   Note: usually, it's a string, but some type of otherNames can be\n   associated with different classes of objects. eg. a KPN may be a\n   sequence of realm and principal name, instead of a single string\n   object.\n\nNot implemented yet: extractors for the types: GEN_X400, GEN_DIRNAME,\nGEN_EDIPARTY, GEN_RID, GEN_IPADD (the later can contain nul-bytes).\n\n\nmapper(name, data, index, count)\n\nThe mapper is passed:\n - the GENERAL_NAME selected,\n - the data,\n - the index of the general name in the subjectAltNames,\n - the total number of names in the subjectAltNames.\n\nThe last parameter let's the mapper allocate arrays to collect objects.\nNote: if names are filtered,  not all the indices from 0 to count-1 are\npassed to mapper,  only the indices selected.\n\nWhen the mapper returns 0, map_subject_alt_name stops the iteration immediately.\n\n*/\n\n#define GEN_ALL (-1)\n\ntypedef int (*general_name_mapper_pr)(GENERAL_NAME* name, void* data, int index, int count);\n\nstatic void map_subject_alt_name(X509* x509, int general_name_type, general_name_mapper_pr mapper,\n                                 void* data)\n{\n\tint i;\n\tint num;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(x509, NID_subject_alt_name, NULL, NULL);\n\n\tif (!gens)\n\t{\n\t\treturn;\n\t}\n\n\tnum = sk_GENERAL_NAME_num(gens);\n\n\tfor (i = 0; (i < num); i++)\n\t{\n\t\tGENERAL_NAME* name = sk_GENERAL_NAME_value(gens, i);\n\n\t\tif (name)\n\t\t{\n\t\t\tif ((general_name_type == GEN_ALL) || (general_name_type == name->type))\n\t\t\t{\n\t\t\t\tif (!mapper(name, data, i, num))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n}\n\n/*\nextract_string  --  string extractor\n\n- the strings array is allocated lazily, when we first have to store a\n  string.\n\n- allocated contains the size of the strings array, or -1 if\n  allocation failed.\n\n- count contains the actual count of strings in the strings array.\n\n- maximum limits the number of strings we can store in the strings\n  array: beyond, the extractor returns 0 to short-cut the search.\n\nextract_string stores in the string list OPENSSL strings,\nthat must be freed with OPENSSL_free.\n\n*/\n\ntypedef struct string_list\n{\n\tchar** strings;\n\tint allocated;\n\tint count;\n\tint maximum;\n} string_list;\n\nstatic void string_list_initialize(string_list* list)\n{\n\tlist->strings = 0;\n\tlist->allocated = 0;\n\tlist->count = 0;\n\tlist->maximum = INT_MAX;\n}\n\nstatic void string_list_allocate(string_list* list, int allocate_count)\n{\n\tif (!list->strings && list->allocated == 0)\n\t{\n\t\tlist->strings = calloc((size_t)allocate_count, sizeof(char*));\n\t\tlist->allocated = list->strings ? allocate_count : -1;\n\t\tlist->count = 0;\n\t}\n}\n\nstatic void string_list_free(string_list* list)\n{\n\t/* Note: we don't free the contents of the strings array: this */\n\t/* is handled by the caller,  either by returning this */\n\t/* content,  or freeing it itself. */\n\tfree(list->strings);\n}\n\nstatic int extract_string(GENERAL_NAME* name, void* data, int index, int count)\n{\n\tstring_list* list = data;\n\tunsigned char* cstring = 0;\n\tASN1_STRING* str;\n\n\tswitch (name->type)\n\t{\n\t\tcase GEN_URI:\n\t\t\tstr = name->d.uniformResourceIdentifier;\n\t\t\tbreak;\n\n\t\tcase GEN_DNS:\n\t\t\tstr = name->d.dNSName;\n\t\t\tbreak;\n\n\t\tcase GEN_EMAIL:\n\t\t\tstr = name->d.rfc822Name;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 1;\n\t}\n\n\tif ((ASN1_STRING_to_UTF8(&cstring, str)) < 0)\n\t{\n\t\tWLog_ERR(TAG, \"ASN1_STRING_to_UTF8() failed for %s: %s\",\n\t\t         general_name_type_label(name->type), ERR_error_string(ERR_get_error(), NULL));\n\t\treturn 1;\n\t}\n\n\tstring_list_allocate(list, count);\n\n\tif (list->allocated <= 0)\n\t{\n\t\tOPENSSL_free(cstring);\n\t\treturn 0;\n\t}\n\n\tlist->strings[list->count] = (char*)cstring;\n\tlist->count++;\n\n\tif (list->count >= list->maximum)\n\t{\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\nextract_othername_object --  object extractor.\n\n- the objects array is allocated lazily, when we first have to store a\n  string.\n\n- allocated contains the size of the objects array, or -1 if\n  allocation failed.\n\n- count contains the actual count of objects in the objects array.\n\n- maximum limits the number of objects we can store in the objects\n  array: beyond, the extractor returns 0 to short-cut the search.\n\nextract_othername_objects stores in the objects array ASN1_TYPE *\npointers directly obtained from the GENERAL_NAME.\n*/\n\ntypedef struct object_list\n{\n\tASN1_OBJECT* type_id;\n\tchar** strings;\n\tint allocated;\n\tint count;\n\tint maximum;\n} object_list;\n\nstatic void object_list_initialize(object_list* list)\n{\n\tlist->type_id = 0;\n\tlist->strings = 0;\n\tlist->allocated = 0;\n\tlist->count = 0;\n\tlist->maximum = INT_MAX;\n}\n\nstatic void object_list_allocate(object_list* list, int allocate_count)\n{\n\tif (!list->strings && list->allocated == 0)\n\t{\n\t\tlist->strings = calloc(allocate_count, sizeof(list->strings[0]));\n\t\tlist->allocated = list->strings ? allocate_count : -1;\n\t\tlist->count = 0;\n\t}\n}\n\nstatic char* object_string(ASN1_TYPE* object)\n{\n\tchar* result;\n\tunsigned char* utf8String;\n\tint length;\n\t/* TODO: check that object.type is a string type. */\n\tlength = ASN1_STRING_to_UTF8(&utf8String, object->value.asn1_string);\n\n\tif (length < 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tresult = (char*)_strdup((char*)utf8String);\n\tOPENSSL_free(utf8String);\n\treturn result;\n}\n\nstatic void object_list_free(object_list* list)\n{\n\tfree(list->strings);\n}\n\nstatic int extract_othername_object_as_string(GENERAL_NAME* name, void* data, int index, int count)\n{\n\tobject_list* list = data;\n\n\tif (name->type != GEN_OTHERNAME)\n\t{\n\t\treturn 1;\n\t}\n\n\tif (0 != OBJ_cmp(name->d.otherName->type_id, list->type_id))\n\t{\n\t\treturn 1;\n\t}\n\n\tobject_list_allocate(list, count);\n\n\tif (list->allocated <= 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tlist->strings[list->count] = object_string(name->d.otherName->value);\n\n\tif (list->strings[list->count])\n\t{\n\t\tlist->count++;\n\t}\n\n\tif (list->count >= list->maximum)\n\t{\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\ncrypto_cert_get_email returns a dynamically allocated copy of the\nfirst email found in the subjectAltNames (use free to free it).\n*/\n\nchar* crypto_cert_get_email(X509* x509)\n{\n\tchar* result = 0;\n\tstring_list list;\n\tstring_list_initialize(&list);\n\tlist.maximum = 1;\n\tmap_subject_alt_name(x509, GEN_EMAIL, extract_string, &list);\n\n\tif (list.count == 0)\n\t{\n\t\tstring_list_free(&list);\n\t\treturn 0;\n\t}\n\n\tresult = _strdup(list.strings[0]);\n\tOPENSSL_free(list.strings[0]);\n\tstring_list_free(&list);\n\treturn result;\n}\n\n/*\ncrypto_cert_get_upn returns a dynamically allocated copy of the\nfirst UPN otherNames in the subjectAltNames (use free to free it).\nNote: if this first UPN otherName is not a string, then 0 is returned,\ninstead of searching for another UPN that would be a string.\n*/\n\nchar* crypto_cert_get_upn(X509* x509)\n{\n\tchar* result = 0;\n\tobject_list list;\n\tobject_list_initialize(&list);\n\tlist.type_id = OBJ_nid2obj(NID_ms_upn);\n\tlist.maximum = 1;\n\tmap_subject_alt_name(x509, GEN_OTHERNAME, extract_othername_object_as_string, &list);\n\n\tif (list.count == 0)\n\t{\n\t\tobject_list_free(&list);\n\t\treturn 0;\n\t}\n\n\tresult = list.strings[0];\n\tobject_list_free(&list);\n\treturn result;\n}\n\n/* Deprecated name.*/\nvoid crypto_cert_subject_alt_name_free(int count, int* lengths, char** alt_names)\n{\n\tcrypto_cert_dns_names_free(count, lengths, alt_names);\n}\n\nvoid crypto_cert_dns_names_free(int count, int* lengths, char** dns_names)\n{\n\tfree(lengths);\n\n\tif (dns_names)\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tif (dns_names[i])\n\t\t\t{\n\t\t\t\tOPENSSL_free(dns_names[i]);\n\t\t\t}\n\t\t}\n\n\t\tfree(dns_names);\n\t}\n}\n\n/* Deprecated name.*/\nchar** crypto_cert_subject_alt_name(X509* xcert, int* count, int** lengths)\n{\n\treturn crypto_cert_get_dns_names(xcert, count, lengths);\n}\n\nchar** crypto_cert_get_dns_names(X509* x509, int* count, int** lengths)\n{\n\tint i;\n\tchar** result = 0;\n\tstring_list list;\n\tstring_list_initialize(&list);\n\tmap_subject_alt_name(x509, GEN_DNS, extract_string, &list);\n\t(*count) = list.count;\n\n\tif (list.count == 0)\n\t{\n\t\tstring_list_free(&list);\n\t\treturn NULL;\n\t}\n\n\t/* lengths are not useful,  since we converted the\n\t   strings to utf-8,  there cannot be nul-bytes in them. */\n\tresult = calloc(list.count, sizeof(*result));\n\t(*lengths) = calloc(list.count, sizeof(**lengths));\n\n\tif (!result || !(*lengths))\n\t{\n\t\tstring_list_free(&list);\n\t\tfree(result);\n\t\tfree(*lengths);\n\t\t(*lengths) = 0;\n\t\t(*count) = 0;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < list.count; i++)\n\t{\n\t\tresult[i] = list.strings[i];\n\t\t(*lengths)[i] = strlen(result[i]);\n\t}\n\n\tstring_list_free(&list);\n\treturn result;\n}\n\nchar* crypto_cert_issuer(X509* xcert)\n{\n\treturn crypto_print_name(X509_get_issuer_name(xcert));\n}\n\nstatic int verify_cb(int ok, X509_STORE_CTX* csc)\n{\n\tif (ok != 1)\n\t{\n\t\tint err = X509_STORE_CTX_get_error(csc);\n\t\tint derr = X509_STORE_CTX_get_error_depth(csc);\n\t\tX509* where = X509_STORE_CTX_get_current_cert(csc);\n\t\tconst char* what = X509_verify_cert_error_string(err);\n\t\tchar* name = crypto_cert_subject(where);\n\n\t\tWLog_WARN(TAG, \"Certificate verification failure '%s (%d)' at stack position %d\", what, err,\n\t\t          derr);\n\t\tWLog_WARN(TAG, \"%s\", name);\n\n\t\tfree(name);\n\t}\n\treturn ok;\n}\n\nBOOL x509_verify_certificate(CryptoCert cert, const char* certificate_store_path)\n{\n\tsize_t i;\n\tconst int purposes[3] = { X509_PURPOSE_SSL_SERVER, X509_PURPOSE_SSL_CLIENT, X509_PURPOSE_ANY };\n\tX509_STORE_CTX* csc;\n\tBOOL status = FALSE;\n\tX509_STORE* cert_ctx = NULL;\n\tX509_LOOKUP* lookup = NULL;\n\tcert_ctx = X509_STORE_new();\n\n\tif (cert_ctx == NULL)\n\t\tgoto end;\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)\n\tOpenSSL_add_all_algorithms();\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS |\n\t                        OPENSSL_INIT_LOAD_CONFIG,\n\t                    NULL);\n#endif\n\n\tlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());\n\n\tif (lookup == NULL)\n\t\tgoto end;\n\n\tlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());\n\n\tif (lookup == NULL)\n\t\tgoto end;\n\n\tX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\n\n\tif (certificate_store_path != NULL)\n\t{\n\t\tX509_LOOKUP_add_dir(lookup, certificate_store_path, X509_FILETYPE_PEM);\n\t}\n\n\tX509_STORE_set_flags(cert_ctx, 0);\n\n\tfor (i = 0; i < ARRAYSIZE(purposes); i++)\n\t{\n\t\tint rc = -1;\n\t\tint purpose = purposes[i];\n\t\tcsc = X509_STORE_CTX_new();\n\n\t\tif (csc == NULL)\n\t\t\tgoto skip;\n\t\tif (!X509_STORE_CTX_init(csc, cert_ctx, cert->px509, cert->px509chain))\n\t\t\tgoto skip;\n\n\t\tX509_STORE_CTX_set_purpose(csc, purpose);\n\t\tX509_STORE_CTX_set_verify_cb(csc, verify_cb);\n\n\t\trc = X509_verify_cert(csc);\n\tskip:\n\t\tX509_STORE_CTX_free(csc);\n\t\tif (rc == 1)\n\t\t{\n\t\t\tstatus = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX509_STORE_free(cert_ctx);\nend:\n\treturn status;\n}\n\nrdpCertificateData* crypto_get_certificate_data(X509* xcert, const char* hostname, UINT16 port)\n{\n\tchar* issuer;\n\tchar* subject;\n\tchar* fp;\n\trdpCertificateData* certdata;\n\tfp = crypto_cert_fingerprint(xcert);\n\n\tif (!fp)\n\t\treturn NULL;\n\n\tissuer = crypto_cert_issuer(xcert);\n\tsubject = crypto_cert_subject(xcert);\n\tcertdata = certificate_data_new(hostname, port, issuer, subject, fp);\n\tfree(subject);\n\tfree(issuer);\n\tfree(fp);\n\treturn certdata;\n}\n\nvoid crypto_cert_print_info(X509* xcert)\n{\n\tchar* fp;\n\tchar* issuer;\n\tchar* subject;\n\tsubject = crypto_cert_subject(xcert);\n\tissuer = crypto_cert_issuer(xcert);\n\tfp = crypto_cert_fingerprint(xcert);\n\n\tif (!fp)\n\t{\n\t\tWLog_ERR(TAG, \"error computing fingerprint\");\n\t\tgoto out_free_issuer;\n\t}\n\n\tWLog_INFO(TAG, \"Certificate details:\");\n\tWLog_INFO(TAG, \"\\tSubject: %s\", subject);\n\tWLog_INFO(TAG, \"\\tIssuer: %s\", issuer);\n\tWLog_INFO(TAG, \"\\tThumbprint: %s\", fp);\n\tWLog_INFO(TAG,\n\t          \"The above X.509 certificate could not be verified, possibly because you do not have \"\n\t          \"the CA certificate in your certificate store, or the certificate has expired. \"\n\t          \"Please look at the OpenSSL documentation on how to add a private CA to the store.\");\n\tfree(fp);\nout_free_issuer:\n\tfree(issuer);\n\tfree(subject);\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Cryptographic Abstraction Layer\n *\n * Copyright 2011-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/crypto.h>\n\n#include <freerdp/log.h>\n#include <freerdp/crypto/crypto.h>\n\n#define TAG FREERDP_TAG(\"crypto\")\n\nCryptoCert crypto_cert_read(BYTE* data, UINT32 length)\n{\n\tCryptoCert cert = malloc(sizeof(*cert));\n\n\tif (!cert)\n\t\treturn NULL;\n\n\t/* this will move the data pointer but we don't care, we don't use it again */\n\tcert->px509 = d2i_X509(NULL, (D2I_X509_CONST BYTE**)&data, length);\n\treturn cert;\n}\n\nvoid crypto_cert_free(CryptoCert cert)\n{\n\tif (cert == NULL)\n\t\treturn;\n\n\tX509_free(cert->px509);\n\tfree(cert);\n}\n\nBOOL crypto_cert_get_public_key(CryptoCert cert, BYTE** PublicKey, DWORD* PublicKeyLength)\n{\n\tBYTE* ptr;\n\tint length;\n\tBOOL status = TRUE;\n\tEVP_PKEY* pkey = NULL;\n\tpkey = X509_get_pubkey(cert->px509);\n\n\tif (!pkey)\n\t{\n\t\tWLog_ERR(TAG, \"X509_get_pubkey() failed\");\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\tlength = i2d_PublicKey(pkey, NULL);\n\n\tif (length < 1)\n\t{\n\t\tWLog_ERR(TAG, \"i2d_PublicKey() failed\");\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\t*PublicKeyLength = (DWORD)length;\n\t*PublicKey = (BYTE*)malloc(length);\n\tptr = (BYTE*)(*PublicKey);\n\n\tif (!ptr)\n\t{\n\t\tstatus = FALSE;\n\t\tgoto exit;\n\t}\n\n\ti2d_PublicKey(pkey, &ptr);\nexit:\n\n\tif (pkey)\n\t\tEVP_PKEY_free(pkey);\n\n\treturn status;\n}\n\nstatic int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx = NULL;\n\tint output_length = -1;\n\tBYTE* input_reverse = NULL;\n\tBYTE* modulus_reverse = NULL;\n\tBYTE* exponent_reverse = NULL;\n\tBIGNUM* mod = NULL;\n\tBIGNUM* exp = NULL;\n\tBIGNUM* x = NULL;\n\tBIGNUM* y = NULL;\n\tsize_t bufferSize = 2 * key_length + exponent_size;\n\n\tif (!input || (length < 0) || (exponent_size < 0) || !modulus || !exponent || !output)\n\t\treturn -1;\n\n\tif (length > bufferSize)\n\t\tbufferSize = length;\n\n\tinput_reverse = (BYTE*)calloc(bufferSize, 1);\n\n\tif (!input_reverse)\n\t\treturn -1;\n\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\n\tif (!BN_bin2bn(modulus_reverse, key_length, mod))\n\t\tgoto fail;\n\n\tif (!BN_bin2bn(exponent_reverse, exponent_size, exp))\n\t\tgoto fail;\n\tif (!BN_bin2bn(input_reverse, length, x))\n\t\tgoto fail;\n\tif (BN_mod_exp(y, x, exp, mod, ctx) != 1)\n\t\tgoto fail;\n\toutput_length = BN_bn2bin(y, output);\n\tif (output_length < 0)\n\t\tgoto fail;\n\tcrypto_reverse(output, output_length);\n\n\tif (output_length < key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\nfail:\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}\n\nstatic int crypto_rsa_public(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, exponent, EXPONENT_MAX_SIZE,\n\t                         output);\n}\n\nstatic int crypto_rsa_private(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, private_exponent, key_length,\n\t                         output);\n}\n\nint crypto_rsa_public_encrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_public(input, length, key_length, modulus, exponent, output);\n}\n\nint crypto_rsa_public_decrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* exponent, BYTE* output)\n{\n\treturn crypto_rsa_public(input, length, key_length, modulus, exponent, output);\n}\n\nint crypto_rsa_private_encrypt(const BYTE* input, int length, UINT32 key_length,\n                               const BYTE* modulus, const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_private(input, length, key_length, modulus, private_exponent, output);\n}\n\nint crypto_rsa_private_decrypt(const BYTE* input, int length, UINT32 key_length,\n                               const BYTE* modulus, const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_private(input, length, key_length, modulus, private_exponent, output);\n}\n\nstatic int crypto_rsa_decrypt(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                              const BYTE* private_exponent, BYTE* output)\n{\n\treturn crypto_rsa_common(input, length, key_length, modulus, private_exponent, key_length,\n\t                         output);\n}\n\nvoid crypto_reverse(BYTE* data, int length)\n{\n\tint i, j;\n\tBYTE temp;\n\n\tfor (i = 0, j = length - 1; i < j; i++, j--)\n\t{\n\t\ttemp = data[i];\n\t\tdata[i] = data[j];\n\t\tdata[j] = temp;\n\t}\n}\n\nchar* crypto_cert_fingerprint(X509* xcert)\n{\n\treturn crypto_cert_fingerprint_by_hash(xcert, \"sha256\");\n}\n\nBYTE* crypto_cert_hash(X509* xcert, const char* hash, UINT32* length)\n{\n\tUINT32 fp_len = EVP_MAX_MD_SIZE;\n\tBYTE* fp;\n\tconst EVP_MD* md = EVP_get_digestbyname(hash);\n\tif (!md)\n\t\treturn NULL;\n\tif (!length)\n\t\treturn NULL;\n\tif (!xcert)\n\t\treturn NULL;\n\n\tfp = calloc(fp_len, sizeof(BYTE));\n\tif (!fp)\n\t\treturn NULL;\n\n\tif (X509_digest(xcert, md, fp, &fp_len) != 1)\n\t{\n\t\tfree(fp);\n\t\treturn NULL;\n\t}\n\n\t*length = fp_len;\n\treturn fp;\n}\n\nchar* crypto_cert_fingerprint_by_hash(X509* xcert, const char* hash)\n{\n\tUINT32 fp_len, i;\n\tBYTE* fp;\n\tchar* p;\n\tchar* fp_buffer;\n\n\tfp = crypto_cert_hash(xcert, hash, &fp_len);\n\tif (!fp)\n\t\treturn NULL;\n\n\tfp_buffer = calloc(fp_len * 3 + 1, sizeof(char));\n\tif (!fp_buffer)\n\t\tgoto fail;\n\n\tp = fp_buffer;\n\n\tfor (i = 0; i < (fp_len - 1); i++)\n\t{\n\t\tsprintf_s(p, (fp_len - i) * 3, \"%02\" PRIx8 \":\", fp[i]);\n\t\tp = &fp_buffer[(i + 1) * 3];\n\t}\n\n\tsprintf_s(p, (fp_len - i) * 3, \"%02\" PRIx8 \"\", fp[i]);\nfail:\n\tfree(fp);\n\n\treturn fp_buffer;\n}\n\nstatic char* crypto_print_name(X509_NAME* name)\n{\n\tchar* buffer = NULL;\n\tBIO* outBIO = BIO_new(BIO_s_mem());\n\n\tif (X509_NAME_print_ex(outBIO, name, 0, XN_FLAG_ONELINE) > 0)\n\t{\n\t\tunsigned long size = BIO_number_written(outBIO);\n\t\tbuffer = calloc(1, size + 1);\n\n\t\tif (!buffer)\n\t\t\treturn NULL;\n\n\t\tBIO_read(outBIO, buffer, size);\n\t}\n\n\tBIO_free_all(outBIO);\n\treturn buffer;\n}\n\nchar* crypto_cert_subject(X509* xcert)\n{\n\treturn crypto_print_name(X509_get_subject_name(xcert));\n}\n\nchar* crypto_cert_subject_common_name(X509* xcert, int* length)\n{\n\tint index;\n\tBYTE* common_name_raw;\n\tchar* common_name;\n\tX509_NAME* subject_name;\n\tX509_NAME_ENTRY* entry;\n\tASN1_STRING* entry_data;\n\tsubject_name = X509_get_subject_name(xcert);\n\n\tif (subject_name == NULL)\n\t\treturn NULL;\n\n\tindex = X509_NAME_get_index_by_NID(subject_name, NID_commonName, -1);\n\n\tif (index < 0)\n\t\treturn NULL;\n\n\tentry = X509_NAME_get_entry(subject_name, index);\n\n\tif (entry == NULL)\n\t\treturn NULL;\n\n\tentry_data = X509_NAME_ENTRY_get_data(entry);\n\n\tif (entry_data == NULL)\n\t\treturn NULL;\n\n\t*length = ASN1_STRING_to_UTF8(&common_name_raw, entry_data);\n\n\tif (*length < 0)\n\t\treturn NULL;\n\n\tcommon_name = _strdup((char*)common_name_raw);\n\tOPENSSL_free(common_name_raw);\n\treturn (char*)common_name;\n}\n\n/* GENERAL_NAME type labels */\n\nstatic const char* general_name_type_labels[] = { \"OTHERNAME\", \"EMAIL    \", \"DNS      \",\n\t                                              \"X400     \", \"DIRNAME  \", \"EDIPARTY \",\n\t                                              \"URI      \", \"IPADD    \", \"RID      \" };\n\nstatic const char* general_name_type_label(int general_name_type)\n{\n\tif ((0 <= general_name_type) &&\n\t    ((size_t)general_name_type < ARRAYSIZE(general_name_type_labels)))\n\t{\n\t\treturn general_name_type_labels[general_name_type];\n\t}\n\telse\n\t{\n\t\tstatic char buffer[80];\n\t\tsprintf(buffer, \"Unknown general name type (%d)\", general_name_type);\n\t\treturn buffer;\n\t}\n}\n\n/*\n\nmap_subject_alt_name(x509,  general_name_type, mapper, data)\n\nCall the function mapper with subjectAltNames found in the x509\ncertificate and data.  if generate_name_type is GEN_ALL,  the the\nmapper is called for all the names,  else it's called only for names\nof the given type.\n\n\nWe implement two extractors:\n\n -  a string extractor that can be used to get the subjectAltNames of\n    the following types: GEN_URI,  GEN_DNS,  GEN_EMAIL\n\n - a ASN1_OBJECT filter/extractor that can be used to get the\n   subjectAltNames of OTHERNAME type.\n\n   Note: usually, it's a string, but some type of otherNames can be\n   associated with different classes of objects. eg. a KPN may be a\n   sequence of realm and principal name, instead of a single string\n   object.\n\nNot implemented yet: extractors for the types: GEN_X400, GEN_DIRNAME,\nGEN_EDIPARTY, GEN_RID, GEN_IPADD (the later can contain nul-bytes).\n\n\nmapper(name, data, index, count)\n\nThe mapper is passed:\n - the GENERAL_NAME selected,\n - the data,\n - the index of the general name in the subjectAltNames,\n - the total number of names in the subjectAltNames.\n\nThe last parameter let's the mapper allocate arrays to collect objects.\nNote: if names are filtered,  not all the indices from 0 to count-1 are\npassed to mapper,  only the indices selected.\n\nWhen the mapper returns 0, map_subject_alt_name stops the iteration immediately.\n\n*/\n\n#define GEN_ALL (-1)\n\ntypedef int (*general_name_mapper_pr)(GENERAL_NAME* name, void* data, int index, int count);\n\nstatic void map_subject_alt_name(X509* x509, int general_name_type, general_name_mapper_pr mapper,\n                                 void* data)\n{\n\tint i;\n\tint num;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(x509, NID_subject_alt_name, NULL, NULL);\n\n\tif (!gens)\n\t{\n\t\treturn;\n\t}\n\n\tnum = sk_GENERAL_NAME_num(gens);\n\n\tfor (i = 0; (i < num); i++)\n\t{\n\t\tGENERAL_NAME* name = sk_GENERAL_NAME_value(gens, i);\n\n\t\tif (name)\n\t\t{\n\t\t\tif ((general_name_type == GEN_ALL) || (general_name_type == name->type))\n\t\t\t{\n\t\t\t\tif (!mapper(name, data, i, num))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n}\n\n/*\nextract_string  --  string extractor\n\n- the strings array is allocated lazily, when we first have to store a\n  string.\n\n- allocated contains the size of the strings array, or -1 if\n  allocation failed.\n\n- count contains the actual count of strings in the strings array.\n\n- maximum limits the number of strings we can store in the strings\n  array: beyond, the extractor returns 0 to short-cut the search.\n\nextract_string stores in the string list OPENSSL strings,\nthat must be freed with OPENSSL_free.\n\n*/\n\ntypedef struct string_list\n{\n\tchar** strings;\n\tint allocated;\n\tint count;\n\tint maximum;\n} string_list;\n\nstatic void string_list_initialize(string_list* list)\n{\n\tlist->strings = 0;\n\tlist->allocated = 0;\n\tlist->count = 0;\n\tlist->maximum = INT_MAX;\n}\n\nstatic void string_list_allocate(string_list* list, int allocate_count)\n{\n\tif (!list->strings && list->allocated == 0)\n\t{\n\t\tlist->strings = calloc((size_t)allocate_count, sizeof(char*));\n\t\tlist->allocated = list->strings ? allocate_count : -1;\n\t\tlist->count = 0;\n\t}\n}\n\nstatic void string_list_free(string_list* list)\n{\n\t/* Note: we don't free the contents of the strings array: this */\n\t/* is handled by the caller,  either by returning this */\n\t/* content,  or freeing it itself. */\n\tfree(list->strings);\n}\n\nstatic int extract_string(GENERAL_NAME* name, void* data, int index, int count)\n{\n\tstring_list* list = data;\n\tunsigned char* cstring = 0;\n\tASN1_STRING* str;\n\n\tswitch (name->type)\n\t{\n\t\tcase GEN_URI:\n\t\t\tstr = name->d.uniformResourceIdentifier;\n\t\t\tbreak;\n\n\t\tcase GEN_DNS:\n\t\t\tstr = name->d.dNSName;\n\t\t\tbreak;\n\n\t\tcase GEN_EMAIL:\n\t\t\tstr = name->d.rfc822Name;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn 1;\n\t}\n\n\tif ((ASN1_STRING_to_UTF8(&cstring, str)) < 0)\n\t{\n\t\tWLog_ERR(TAG, \"ASN1_STRING_to_UTF8() failed for %s: %s\",\n\t\t         general_name_type_label(name->type), ERR_error_string(ERR_get_error(), NULL));\n\t\treturn 1;\n\t}\n\n\tstring_list_allocate(list, count);\n\n\tif (list->allocated <= 0)\n\t{\n\t\tOPENSSL_free(cstring);\n\t\treturn 0;\n\t}\n\n\tlist->strings[list->count] = (char*)cstring;\n\tlist->count++;\n\n\tif (list->count >= list->maximum)\n\t{\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\nextract_othername_object --  object extractor.\n\n- the objects array is allocated lazily, when we first have to store a\n  string.\n\n- allocated contains the size of the objects array, or -1 if\n  allocation failed.\n\n- count contains the actual count of objects in the objects array.\n\n- maximum limits the number of objects we can store in the objects\n  array: beyond, the extractor returns 0 to short-cut the search.\n\nextract_othername_objects stores in the objects array ASN1_TYPE *\npointers directly obtained from the GENERAL_NAME.\n*/\n\ntypedef struct object_list\n{\n\tASN1_OBJECT* type_id;\n\tchar** strings;\n\tint allocated;\n\tint count;\n\tint maximum;\n} object_list;\n\nstatic void object_list_initialize(object_list* list)\n{\n\tlist->type_id = 0;\n\tlist->strings = 0;\n\tlist->allocated = 0;\n\tlist->count = 0;\n\tlist->maximum = INT_MAX;\n}\n\nstatic void object_list_allocate(object_list* list, int allocate_count)\n{\n\tif (!list->strings && list->allocated == 0)\n\t{\n\t\tlist->strings = calloc(allocate_count, sizeof(list->strings[0]));\n\t\tlist->allocated = list->strings ? allocate_count : -1;\n\t\tlist->count = 0;\n\t}\n}\n\nstatic char* object_string(ASN1_TYPE* object)\n{\n\tchar* result;\n\tunsigned char* utf8String;\n\tint length;\n\t/* TODO: check that object.type is a string type. */\n\tlength = ASN1_STRING_to_UTF8(&utf8String, object->value.asn1_string);\n\n\tif (length < 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tresult = (char*)_strdup((char*)utf8String);\n\tOPENSSL_free(utf8String);\n\treturn result;\n}\n\nstatic void object_list_free(object_list* list)\n{\n\tfree(list->strings);\n}\n\nstatic int extract_othername_object_as_string(GENERAL_NAME* name, void* data, int index, int count)\n{\n\tobject_list* list = data;\n\n\tif (name->type != GEN_OTHERNAME)\n\t{\n\t\treturn 1;\n\t}\n\n\tif (0 != OBJ_cmp(name->d.otherName->type_id, list->type_id))\n\t{\n\t\treturn 1;\n\t}\n\n\tobject_list_allocate(list, count);\n\n\tif (list->allocated <= 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tlist->strings[list->count] = object_string(name->d.otherName->value);\n\n\tif (list->strings[list->count])\n\t{\n\t\tlist->count++;\n\t}\n\n\tif (list->count >= list->maximum)\n\t{\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/*\ncrypto_cert_get_email returns a dynamically allocated copy of the\nfirst email found in the subjectAltNames (use free to free it).\n*/\n\nchar* crypto_cert_get_email(X509* x509)\n{\n\tchar* result = 0;\n\tstring_list list;\n\tstring_list_initialize(&list);\n\tlist.maximum = 1;\n\tmap_subject_alt_name(x509, GEN_EMAIL, extract_string, &list);\n\n\tif (list.count == 0)\n\t{\n\t\tstring_list_free(&list);\n\t\treturn 0;\n\t}\n\n\tresult = _strdup(list.strings[0]);\n\tOPENSSL_free(list.strings[0]);\n\tstring_list_free(&list);\n\treturn result;\n}\n\n/*\ncrypto_cert_get_upn returns a dynamically allocated copy of the\nfirst UPN otherNames in the subjectAltNames (use free to free it).\nNote: if this first UPN otherName is not a string, then 0 is returned,\ninstead of searching for another UPN that would be a string.\n*/\n\nchar* crypto_cert_get_upn(X509* x509)\n{\n\tchar* result = 0;\n\tobject_list list;\n\tobject_list_initialize(&list);\n\tlist.type_id = OBJ_nid2obj(NID_ms_upn);\n\tlist.maximum = 1;\n\tmap_subject_alt_name(x509, GEN_OTHERNAME, extract_othername_object_as_string, &list);\n\n\tif (list.count == 0)\n\t{\n\t\tobject_list_free(&list);\n\t\treturn 0;\n\t}\n\n\tresult = list.strings[0];\n\tobject_list_free(&list);\n\treturn result;\n}\n\n/* Deprecated name.*/\nvoid crypto_cert_subject_alt_name_free(int count, int* lengths, char** alt_names)\n{\n\tcrypto_cert_dns_names_free(count, lengths, alt_names);\n}\n\nvoid crypto_cert_dns_names_free(int count, int* lengths, char** dns_names)\n{\n\tfree(lengths);\n\n\tif (dns_names)\n\t{\n\t\tint i;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tif (dns_names[i])\n\t\t\t{\n\t\t\t\tOPENSSL_free(dns_names[i]);\n\t\t\t}\n\t\t}\n\n\t\tfree(dns_names);\n\t}\n}\n\n/* Deprecated name.*/\nchar** crypto_cert_subject_alt_name(X509* xcert, int* count, int** lengths)\n{\n\treturn crypto_cert_get_dns_names(xcert, count, lengths);\n}\n\nchar** crypto_cert_get_dns_names(X509* x509, int* count, int** lengths)\n{\n\tint i;\n\tchar** result = 0;\n\tstring_list list;\n\tstring_list_initialize(&list);\n\tmap_subject_alt_name(x509, GEN_DNS, extract_string, &list);\n\t(*count) = list.count;\n\n\tif (list.count == 0)\n\t{\n\t\tstring_list_free(&list);\n\t\treturn NULL;\n\t}\n\n\t/* lengths are not useful,  since we converted the\n\t   strings to utf-8,  there cannot be nul-bytes in them. */\n\tresult = calloc(list.count, sizeof(*result));\n\t(*lengths) = calloc(list.count, sizeof(**lengths));\n\n\tif (!result || !(*lengths))\n\t{\n\t\tstring_list_free(&list);\n\t\tfree(result);\n\t\tfree(*lengths);\n\t\t(*lengths) = 0;\n\t\t(*count) = 0;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < list.count; i++)\n\t{\n\t\tresult[i] = list.strings[i];\n\t\t(*lengths)[i] = strlen(result[i]);\n\t}\n\n\tstring_list_free(&list);\n\treturn result;\n}\n\nchar* crypto_cert_issuer(X509* xcert)\n{\n\treturn crypto_print_name(X509_get_issuer_name(xcert));\n}\n\nstatic int verify_cb(int ok, X509_STORE_CTX* csc)\n{\n\tif (ok != 1)\n\t{\n\t\tint err = X509_STORE_CTX_get_error(csc);\n\t\tint derr = X509_STORE_CTX_get_error_depth(csc);\n\t\tX509* where = X509_STORE_CTX_get_current_cert(csc);\n\t\tconst char* what = X509_verify_cert_error_string(err);\n\t\tchar* name = crypto_cert_subject(where);\n\n\t\tWLog_WARN(TAG, \"Certificate verification failure '%s (%d)' at stack position %d\", what, err,\n\t\t          derr);\n\t\tWLog_WARN(TAG, \"%s\", name);\n\n\t\tfree(name);\n\t}\n\treturn ok;\n}\n\nBOOL x509_verify_certificate(CryptoCert cert, const char* certificate_store_path)\n{\n\tsize_t i;\n\tconst int purposes[3] = { X509_PURPOSE_SSL_SERVER, X509_PURPOSE_SSL_CLIENT, X509_PURPOSE_ANY };\n\tX509_STORE_CTX* csc;\n\tBOOL status = FALSE;\n\tX509_STORE* cert_ctx = NULL;\n\tX509_LOOKUP* lookup = NULL;\n\tcert_ctx = X509_STORE_new();\n\n\tif (cert_ctx == NULL)\n\t\tgoto end;\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)\n\tOpenSSL_add_all_algorithms();\n#else\n\tOPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS |\n\t                        OPENSSL_INIT_LOAD_CONFIG,\n\t                    NULL);\n#endif\n\n\tlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_file());\n\n\tif (lookup == NULL)\n\t\tgoto end;\n\n\tlookup = X509_STORE_add_lookup(cert_ctx, X509_LOOKUP_hash_dir());\n\n\tif (lookup == NULL)\n\t\tgoto end;\n\n\tX509_LOOKUP_add_dir(lookup, NULL, X509_FILETYPE_DEFAULT);\n\n\tif (certificate_store_path != NULL)\n\t{\n\t\tX509_LOOKUP_add_dir(lookup, certificate_store_path, X509_FILETYPE_PEM);\n\t}\n\n\tX509_STORE_set_flags(cert_ctx, 0);\n\n\tfor (i = 0; i < ARRAYSIZE(purposes); i++)\n\t{\n\t\tint rc = -1;\n\t\tint purpose = purposes[i];\n\t\tcsc = X509_STORE_CTX_new();\n\n\t\tif (csc == NULL)\n\t\t\tgoto skip;\n\t\tif (!X509_STORE_CTX_init(csc, cert_ctx, cert->px509, cert->px509chain))\n\t\t\tgoto skip;\n\n\t\tX509_STORE_CTX_set_purpose(csc, purpose);\n\t\tX509_STORE_CTX_set_verify_cb(csc, verify_cb);\n\n\t\trc = X509_verify_cert(csc);\n\tskip:\n\t\tX509_STORE_CTX_free(csc);\n\t\tif (rc == 1)\n\t\t{\n\t\t\tstatus = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tX509_STORE_free(cert_ctx);\nend:\n\treturn status;\n}\n\nrdpCertificateData* crypto_get_certificate_data(X509* xcert, const char* hostname, UINT16 port)\n{\n\tchar* issuer;\n\tchar* subject;\n\tchar* fp;\n\trdpCertificateData* certdata;\n\tfp = crypto_cert_fingerprint(xcert);\n\n\tif (!fp)\n\t\treturn NULL;\n\n\tissuer = crypto_cert_issuer(xcert);\n\tsubject = crypto_cert_subject(xcert);\n\tcertdata = certificate_data_new(hostname, port, issuer, subject, fp);\n\tfree(subject);\n\tfree(issuer);\n\tfree(fp);\n\treturn certdata;\n}\n\nvoid crypto_cert_print_info(X509* xcert)\n{\n\tchar* fp;\n\tchar* issuer;\n\tchar* subject;\n\tsubject = crypto_cert_subject(xcert);\n\tissuer = crypto_cert_issuer(xcert);\n\tfp = crypto_cert_fingerprint(xcert);\n\n\tif (!fp)\n\t{\n\t\tWLog_ERR(TAG, \"error computing fingerprint\");\n\t\tgoto out_free_issuer;\n\t}\n\n\tWLog_INFO(TAG, \"Certificate details:\");\n\tWLog_INFO(TAG, \"\\tSubject: %s\", subject);\n\tWLog_INFO(TAG, \"\\tIssuer: %s\", issuer);\n\tWLog_INFO(TAG, \"\\tThumbprint: %s\", fp);\n\tWLog_INFO(TAG,\n\t          \"The above X.509 certificate could not be verified, possibly because you do not have \"\n\t          \"the CA certificate in your certificate store, or the certificate has expired. \"\n\t          \"Please look at the OpenSSL documentation on how to add a private CA to the store.\");\n\tfree(fp);\nout_free_issuer:\n\tfree(issuer);\n\tfree(subject);\n}\n"], "filenames": ["libfreerdp/crypto/crypto.c"], "buggy_code_start_loc": [99], "buggy_code_end_loc": [143], "fixing_code_start_loc": [99], "fixing_code_end_loc": [163], "type": "CWE-787", "message": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) write vulnerability has been detected in crypto_rsa_common in libfreerdp/crypto/crypto.c.", "other": {"cve": {"id": "CVE-2020-13398", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-22T18:15:11.833", "lastModified": "2020-11-09T21:46:19.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) write vulnerability has been detected in crypto_rsa_common in libfreerdp/crypto/crypto.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en FreeRDP versiones anteriores a 2.1.1. Ha sido detectada una vulnerabilidad de escritura fuera de l\u00edmites (OOB) en la funci\u00f3n crypto_rsa_common en el archivo libfreerdp/crypto/crypto.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.1", "matchCriteriaId": "123B2084-A9AE-4FD2-A64B-F78F1D7BC337"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/8305349a943c68b1bc8c158f431dc607655aadea", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/8fb6336a4072abcee8ce5bd6ae91104628c7bb69", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/compare/2.1.0...2.1.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00054.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4382-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/8305349a943c68b1bc8c158f431dc607655aadea"}}