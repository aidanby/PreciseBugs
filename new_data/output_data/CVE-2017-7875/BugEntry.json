{"buggy_code": ["/* wallpaper.c\n\nCopyright (C) 1999-2003 Tom Gilbert.\nCopyright (C) 2010-2011 Daniel Friesel.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies of the Software and its documentation and acknowledgment shall be\ngiven in the documentation and software packages that this Software was\nused.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#include \"feh.h\"\n#include \"filelist.h\"\n#include \"options.h\"\n#include \"wallpaper.h\"\n#include <limits.h>\n#include <sys/stat.h>\nWindow ipc_win = None;\nWindow my_ipc_win = None;\nAtom ipc_atom = None;\nstatic unsigned char timeout = 0;\n\n/*\n * This is a boolean indicating\n * That while we seem to see E16 IPC\n * it's actually E17 faking it\n * -- richlowe 2005-06-22\n */\nstatic char e17_fake_ipc = 0;\n\nvoid feh_wm_set_bg_filelist(unsigned char bgmode)\n{\n\tif (filelist_len == 0)\n\t\teprintf(\"No files specified for background setting\");\n\n\tswitch (bgmode) {\n\t\tcase BG_MODE_TILE:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_SCALE:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 1, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_FILL:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 1, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_MAX:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 2, 0, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 1, 0, 0, 0, 1);\n\t\t\tbreak;\n\t}\n}\n\nstatic void feh_wm_load_next(Imlib_Image *im)\n{\n\tstatic gib_list *wpfile = NULL;\n\n\tif (wpfile == NULL)\n\t\twpfile = filelist;\n\n\tif (feh_load_image(im, FEH_FILE(wpfile->data)) == 0)\n\t\teprintf(\"Unable to load image %s\", FEH_FILE(wpfile->data)->filename);\n\tif (wpfile->next)\n\t\twpfile = wpfile->next;\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_scaled(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\tgib_imlib_render_image_on_drawable_at_size(pmap, im, x, y, w, h,\n\t\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_centered(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint offset_x, offset_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\tif(opt.geom_flags & XValue)\n\t\tif(opt.geom_flags & XNegative)\n\t\t\toffset_x = (w - gib_imlib_image_get_width(im)) + opt.geom_x;\n\t\telse\n\t\t\toffset_x = opt.geom_x;\n\telse\n\t\toffset_x = (w - gib_imlib_image_get_width(im)) >> 1;\n\n\tif(opt.geom_flags & YValue)\n\t\tif(opt.geom_flags & YNegative)\n\t\t\toffset_y = (h - gib_imlib_image_get_height(im)) + opt.geom_y;\n\t\telse\n\t\t\toffset_y = opt.geom_y;\n\telse\n\t\toffset_y = (h - gib_imlib_image_get_height(im)) >> 1;\n\n\tgib_imlib_render_image_part_on_drawable_at_size(pmap, im,\n\t\t((offset_x < 0) ? -offset_x : 0),\n\t\t((offset_y < 0) ? -offset_y : 0),\n\t\tw,\n\t\th,\n\t\tx + ((offset_x > 0) ? offset_x : 0),\n\t\ty + ((offset_y > 0) ? offset_y : 0),\n\t\tw,\n\t\th,\n\t\t1, 0, 0);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_filled(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint img_w, img_h, cut_x;\n\tint render_w, render_h, render_x, render_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\timg_w = gib_imlib_image_get_width(im);\n\timg_h = gib_imlib_image_get_height(im);\n\n\tcut_x = (((img_w * h) > (img_h * w)) ? 1 : 0);\n\n\trender_w = (  cut_x ? ((img_h * w) / h) : img_w);\n\trender_h = ( !cut_x ? ((img_w * h) / w) : img_h);\n\n\trender_x = (  cut_x ? ((img_w - render_w) >> 1) : 0);\n\trender_y = ( !cut_x ? ((img_h - render_h) >> 1) : 0);\n\n\tgib_imlib_render_image_part_on_drawable_at_size(pmap, im,\n\t\trender_x, render_y,\n\t\trender_w, render_h,\n\t\tx, y, w, h,\n\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_maxed(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint img_w, img_h, border_x;\n\tint render_w, render_h, render_x, render_y;\n\tint margin_x, margin_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\timg_w = gib_imlib_image_get_width(im);\n\timg_h = gib_imlib_image_get_height(im);\n\n\tborder_x = (((img_w * h) > (img_h * w)) ? 0 : 1);\n\n\trender_w = (  border_x ? ((img_w * h) / img_h) : w);\n\trender_h = ( !border_x ? ((img_h * w) / img_w) : h);\n\n\tif(opt.geom_flags & XValue)\n\t\tif(opt.geom_flags & XNegative)\n\t\t\tmargin_x = (w - render_w) + opt.geom_x;\n\t\telse\n\t\t\tmargin_x = opt.geom_x;\n\telse\n\t\tmargin_x = (w - render_w) >> 1;\n\n\tif(opt.geom_flags & YValue)\n\t\tif(opt.geom_flags & YNegative)\n\t\t\tmargin_y = (h - render_h) + opt.geom_y;\n\t\telse\n\t\t\tmargin_y = opt.geom_y;\n\telse\n\t\tmargin_y = (h - render_h) >> 1;\n\n\trender_x = x + (  border_x ? margin_x : 0);\n\trender_y = y + ( !border_x ? margin_y : 0);\n\n\tgib_imlib_render_image_on_drawable_at_size(pmap, im,\n\t\trender_x, render_y,\n\t\trender_w, render_h,\n\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nvoid feh_wm_set_bg(char *fil, Imlib_Image im, int centered, int scaled,\n\t\tint filled, int desktop, int use_filelist)\n{\n\tXGCValues gcvalues;\n\tXGCValues gcval;\n\tGC gc;\n\tchar bgname[20];\n\tint num = (int) rand();\n\tchar bgfil[4096];\n\tchar sendbuf[4096];\n\n\t/*\n\t * TODO this re-implements mkstemp (badly). However, it is only needed\n\t * for non-file images and enlightenment. Might be easier to just remove\n\t * it.\n\t */\n\n\tsnprintf(bgname, sizeof(bgname), \"FEHBG_%d\", num);\n\n\tif (!fil && im) {\n\t\tif (getenv(\"HOME\") == NULL) {\n\t\t\tweprintf(\"Cannot save wallpaper to temporary file: You have no HOME\");\n\t\t\treturn;\n\t\t}\n\t\tsnprintf(bgfil, sizeof(bgfil), \"%s/.%s.png\", getenv(\"HOME\"), bgname);\n\t\timlib_context_set_image(im);\n\t\timlib_image_set_format(\"png\");\n\t\tgib_imlib_save_image(im, bgfil);\n\t\tD((\"bg saved as %s\\n\", bgfil));\n\t\tfil = bgfil;\n\t}\n\n\tif (feh_wm_get_wm_is_e() && (enl_ipc_get_win() != None)) {\n\t\tif (use_filelist) {\n\t\t\tfeh_wm_load_next(&im);\n\t\t\tfil = FEH_FILE(filelist->data)->filename;\n\t\t}\n\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.file %s\", bgname, fil);\n\t\tenl_ipc_send(sendbuf);\n\n\t\tif (scaled) {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.solid 0 0 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xperc 1024\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yperc 1024\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t} else if (centered) {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.solid 0 0 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t} else {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 1\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t}\n\n\t\tsnprintf(sendbuf, sizeof(sendbuf), \"use_bg %s %d\", bgname, desktop);\n\t\tenl_ipc_send(sendbuf);\n\t\tenl_ipc_sync();\n\t} else {\n\t\tAtom prop_root, prop_esetroot, type;\n\t\tint format, i;\n\t\tunsigned long length, after;\n\t\tunsigned char *data_root = NULL, *data_esetroot = NULL;\n\t\tPixmap pmap_d1, pmap_d2;\n\t\tgib_list *l;\n\n\t\t/* string for sticking in ~/.fehbg */\n\t\tchar *fehbg = NULL;\n\t\tchar fehbg_args[512];\n\t\tfehbg_args[0] = '\\0';\n\t\tchar *home;\n\t\tchar filbuf[4096];\n\t\tchar *bgfill = NULL;\n\t\tbgfill = opt.image_bg == IMAGE_BG_WHITE ?  \"--image-bg white\" : \"--image-bg black\" ;\n\n#ifdef HAVE_LIBXINERAMA\n\t\tif (opt.xinerama) {\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tsnprintf(fehbg_args, sizeof(fehbg_args),\n\t\t\t\t\t\"--xinerama-index %d\", opt.xinerama_index);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tsnprintf(fehbg_args, sizeof(fehbg_args), \"--no-xinerama\");\n#endif\t\t\t/* HAVE_LIBXINERAMA */\n\n\t\t/* local display to set closedownmode on */\n\t\tDisplay *disp2;\n\t\tWindow root2;\n\t\tint depth2;\n\t\tint in, out, w, h;\n\n\t\tD((\"Falling back to XSetRootWindowPixmap\\n\"));\n\n\t\t/* Put the filename in filbuf between ' and escape ' in the filename */\n\t\tout = 0;\n\n\t\tif (fil && !use_filelist) {\n\t\t\tfilbuf[out++] = '\\'';\n\n\t\t\tfil = feh_absolute_path(fil);\n\n\t\t\tfor (in = 0; fil[in] && out < 4092; in++) {\n\n\t\t\t\tif (fil[in] == '\\'')\n\t\t\t\t\tfilbuf[out++] = '\\\\';\n\t\t\t\tfilbuf[out++] = fil[in];\n\t\t\t}\n\t\t\tfilbuf[out++] = '\\'';\n\t\t\tfree(fil);\n\n\t\t} else {\n\t\t\tfor (l = filelist; l && out < 4092; l = l->next) {\n\t\t\t\tfilbuf[out++] = '\\'';\n\n\t\t\t\tfil = feh_absolute_path(FEH_FILE(l->data)->filename);\n\n\t\t\t\tfor (in = 0; fil[in] && out < 4092; in++) {\n\n\t\t\t\t\tif (fil[in] == '\\'')\n\t\t\t\t\t\tfilbuf[out++] = '\\\\';\n\t\t\t\t\tfilbuf[out++] = fil[in];\n\t\t\t\t}\n\t\t\t\tfilbuf[out++] = '\\'';\n\t\t\t\tfilbuf[out++] = ' ';\n\t\t\t\tfree(fil);\n\t\t\t}\n\t\t}\n\n\n\t\tfilbuf[out++] = 0;\n\n\t\tif (scaled) {\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\t\telse\n\t\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\t\t\t\tXFreeGC(disp, gc);\n\t\t\t}\n\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_scaled(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_scaled(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, \"--bg-scale\", filbuf, NULL);\n\t\t} else if (centered) {\n\n\t\t\tD((\"centering\\n\"));\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\telse\n\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_centered(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_centered(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\n\t\t\tXFreeGC(disp, gc);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, bgfill, \"--bg-center\", filbuf, NULL);\n\n\t\t} else if (filled == 1) {\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\t\telse\n\t\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\t\t\t\tXFreeGC(disp, gc);\n\t\t\t}\n\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_filled(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_filled(pmap_d1, im, use_filelist\n\t\t\t\t\t, 0, 0, scr->width, scr->height);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, \"--bg-fill\", filbuf, NULL);\n\n\t\t} else if (filled == 2) {\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\telse\n\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_maxed(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_maxed(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\n\t\t\tXFreeGC(disp, gc);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, bgfill, \"--bg-max\", filbuf, NULL);\n\n\t\t} else {\n\t\t\tif (use_filelist)\n\t\t\t\tfeh_wm_load_next(&im);\n\t\t\tw = gib_imlib_image_get_width(im);\n\t\t\th = gib_imlib_image_get_height(im);\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, w, h, depth);\n\t\t\tgib_imlib_render_image_on_drawable(pmap_d1, im, 0, 0, 1, 0, 0);\n\t\t\tfehbg = estrjoin(\" \", \"feh --bg-tile\", filbuf, NULL);\n\t\t}\n\n\t\tif (fehbg && !opt.no_fehbg) {\n\t\t\thome = getenv(\"HOME\");\n\t\t\tif (home) {\n\t\t\t\tFILE *fp;\n\t\t\t\tchar *path;\n\t\t\t\tstruct stat s;\n\t\t\t\tpath = estrjoin(\"/\", home, \".fehbg\", NULL);\n\t\t\t\tif ((fp = fopen(path, \"w\")) == NULL) {\n\t\t\t\t\tweprintf(\"Can't write to %s\", path);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(fp, \"#!/bin/sh\\n%s\\n\", fehbg);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tstat(path, &s);\n\t\t\t\t\tif (chmod(path, s.st_mode | S_IXUSR | S_IXGRP) != 0) {\n\t\t\t\t\t\tweprintf(\"Can't set %s as executable\", path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfree(fehbg);\n\n\t\t/* create new display, copy pixmap to new display */\n\t\tdisp2 = XOpenDisplay(NULL);\n\t\tif (!disp2)\n\t\t\teprintf(\"Can't reopen X display.\");\n\t\troot2 = RootWindow(disp2, DefaultScreen(disp2));\n\t\tdepth2 = DefaultDepth(disp2, DefaultScreen(disp2));\n\t\tXSync(disp, False);\n\t\tpmap_d2 = XCreatePixmap(disp2, root2, scr->width, scr->height, depth2);\n\t\tgcvalues.fill_style = FillTiled;\n\t\tgcvalues.tile = pmap_d1;\n\t\tgc = XCreateGC(disp2, pmap_d2, GCFillStyle | GCTile, &gcvalues);\n\t\tXFillRectangle(disp2, pmap_d2, gc, 0, 0, scr->width, scr->height);\n\t\tXFreeGC(disp2, gc);\n\t\tXSync(disp2, False);\n\t\tXSync(disp, False);\n\t\tXFreePixmap(disp, pmap_d1);\n\n\t\tprop_root = XInternAtom(disp2, \"_XROOTPMAP_ID\", True);\n\t\tprop_esetroot = XInternAtom(disp2, \"ESETROOT_PMAP_ID\", True);\n\n\t\tif (prop_root != None && prop_esetroot != None) {\n\t\t\tXGetWindowProperty(disp2, root2, prop_root, 0L, 1L,\n\t\t\t\t\t   False, AnyPropertyType, &type, &format, &length, &after, &data_root);\n\t\t\tif (type == XA_PIXMAP) {\n\t\t\t\tXGetWindowProperty(disp2, root2,\n\t\t\t\t\t\t   prop_esetroot, 0L, 1L,\n\t\t\t\t\t\t   False, AnyPropertyType,\n\t\t\t\t\t\t   &type, &format, &length, &after, &data_esetroot);\n\t\t\t\tif (data_root && data_esetroot) {\n\t\t\t\t\tif (type == XA_PIXMAP && *((Pixmap *) data_root) == *((Pixmap *) data_esetroot)) {\n\t\t\t\t\t\tXKillClient(disp2, *((Pixmap *)\n\t\t\t\t\t\t\t\t     data_root));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data_root)\n\t\t\tXFree(data_root);\n\t\n\t\tif (data_esetroot)\n\t\t\tXFree(data_esetroot);\n\n\t\t/* This will locate the property, creating it if it doesn't exist */\n\t\tprop_root = XInternAtom(disp2, \"_XROOTPMAP_ID\", False);\n\t\tprop_esetroot = XInternAtom(disp2, \"ESETROOT_PMAP_ID\", False);\n\n\t\tif (prop_root == None || prop_esetroot == None)\n\t\t\teprintf(\"creation of pixmap property failed.\");\n\n\t\tXChangeProperty(disp2, root2, prop_root, XA_PIXMAP, 32, PropModeReplace, (unsigned char *) &pmap_d2, 1);\n\t\tXChangeProperty(disp2, root2, prop_esetroot, XA_PIXMAP, 32,\n\t\t\t\tPropModeReplace, (unsigned char *) &pmap_d2, 1);\n\n\t\tXSetWindowBackgroundPixmap(disp2, root2, pmap_d2);\n\t\tXClearWindow(disp2, root2);\n\t\tXFlush(disp2);\n\t\tXSetCloseDownMode(disp2, RetainPermanent);\n\t\tXCloseDisplay(disp2);\n\t}\n\treturn;\n}\n\nsigned char feh_wm_get_wm_is_e(void)\n{\n\tstatic signed char e = -1;\n\n\t/* check if E is actually running */\n\tif (e == -1) {\n\t\t/* XXX: This only covers E17 prior to 6/22/05 */\n\t\tif ((XInternAtom(disp, \"ENLIGHTENMENT_COMMS\", True) != None)\n\t\t    && (XInternAtom(disp, \"ENLIGHTENMENT_VERSION\", True) != None)) {\n\t\t\tD((\"Enlightenment detected.\\n\"));\n\t\t\te = 1;\n\t\t} else {\n\t\t\tD((\"Enlightenment not detected.\\n\"));\n\t\t\te = 0;\n\t\t}\n\t}\n\treturn(e);\n}\n\nint feh_wm_get_num_desks(void)\n{\n\tchar *buf, *ptr;\n\tint desks;\n\n\tif (!feh_wm_get_wm_is_e())\n\t\treturn(-1);\n\n\tbuf = enl_send_and_wait(\"num_desks ?\");\n\tif (buf == IPC_FAKE)\t/* Fake E17 IPC */\n\t\treturn(-1);\n\tD((\"Got from E IPC: %s\\n\", buf));\n\tptr = buf;\n\twhile (ptr && !isdigit(*ptr))\n\t\tptr++;\n\tdesks = atoi(ptr);\n\n\treturn(desks);\n}\n\nWindow enl_ipc_get_win(void)\n{\n\n\tunsigned char *str = NULL;\n\tAtom prop, prop2, ever;\n\tunsigned long num, after;\n\tint format;\n\tWindow dummy_win;\n\tint dummy_int;\n\tunsigned int dummy_uint;\n\n\tD((\"Searching for IPC window.\\n\"));\n\n\t/*\n\t * Shortcircuit this entire func\n\t * if we already know it's an e17 fake\n\t */\n\tif (e17_fake_ipc)\n\t\treturn(ipc_win);\n\n\t\t    prop = XInternAtom(disp, \"ENLIGHTENMENT_COMMS\", True);\n\tif (prop == None) {\n\t\tD((\"Enlightenment is not running.\\n\"));\n\t\treturn(None);\n\t} else {\n\t\t/* XXX: This will only work with E17 prior to 6/22/2005 */\n\t\tever = XInternAtom(disp, \"ENLIGHTENMENT_VERSION\", True);\n\t\tif (ever == None) {\n\t\t\t/* This is an E without ENLIGHTENMENT_VERSION */\n\t\t\tD((\"E16 IPC Protocol not supported\"));\n\t\t\treturn(None);\n\t\t}\n\t}\n\tXGetWindowProperty(disp, root, prop, 0, 14, False, AnyPropertyType, &prop2, &format, &num, &after, &str);\n\tif (str) {\n\t\tsscanf((char *) str, \"%*s %x\", (unsigned int *) &ipc_win);\n\t\tXFree(str);\n\t}\n\tif (ipc_win != None) {\n\t\tif (!XGetGeometry\n\t\t    (disp, ipc_win, &dummy_win, &dummy_int, &dummy_int,\n\t\t     &dummy_uint, &dummy_uint, &dummy_uint, &dummy_uint)) {\n\t\t\tD((\" -> IPC Window property is valid, but the window doesn't exist.\\n\"));\n\t\t\tipc_win = None;\n\t\t}\n\t\tstr = NULL;\n\t\tif (ipc_win != None) {\n\t\t\tXGetWindowProperty(disp, ipc_win, prop, 0, 14,\n\t\t\t\t\t   False, AnyPropertyType, &prop2, &format, &num, &after, &str);\n\t\t\tif (str) {\n\t\t\t\tXFree(str);\n\t\t\t} else {\n\t\t\t\tD((\" -> IPC Window lacks the proper atom.  I can't talk to fake IPC windows....\\n\"));\n\t\t\t\tipc_win = None;\n\t\t\t}\n\t\t}\n\t}\n\tif (ipc_win != None) {\n\n\t\tXGetWindowProperty(disp, ipc_win, ever, 0, 14, False,\n\t\t\t\t   AnyPropertyType, &prop2, &format, &num, &after, &str);\n\t\tif (str) {\n\t\t\t/*\n\t\t\t * This is E17's way of telling us it's only pretending\n\t\t\t * as a workaround for a bug related to the way java handles\n\t\t\t * Window Managers.\n\t\t\t * (Only valid after date of this comment)\n\t\t\t * -- richlowe 2005-06-22\n\t\t\t */\n\t\t\tXFree(str);\n\t\t\tD((\" -> Found a fake E17 IPC window, ignoring\"));\n\t\t\tipc_win = None;\n\t\t\te17_fake_ipc = 1;\n\t\t\treturn(ipc_win);\n\t\t}\n\n\t\tD((\" -> IPC Window found and verified as 0x%08x.  Registering feh as an IPC client.\\n\", (int) ipc_win));\n\t\tXSelectInput(disp, ipc_win, StructureNotifyMask | SubstructureNotifyMask);\n\t\tenl_ipc_send(\"set clientname \" PACKAGE);\n\t\tenl_ipc_send(\"set version \" VERSION);\n\t\tenl_ipc_send(\"set email tom@linuxbrit.co.uk\");\n\t\tenl_ipc_send(\"set web http://www.linuxbrit.co.uk\");\n\t\tenl_ipc_send(\"set info Feh - be pr0n or be dead\");\n\t}\n\tif (my_ipc_win == None) {\n\t\tmy_ipc_win = XCreateSimpleWindow(disp, root, -2, -2, 1, 1, 0, 0, 0);\n\t}\n\treturn(ipc_win);\n}\n\nvoid enl_ipc_send(char *str)\n{\n\n\tstatic char *last_msg = NULL;\n\tchar buff[21];\n\tregister unsigned short i;\n\tregister unsigned char j;\n\tunsigned short len;\n\tXEvent ev;\n\n\tif (str == NULL) {\n\t\tif (last_msg == NULL)\n\t\t\teprintf(\"eeek\");\n\t\tstr = last_msg;\n\t\tD((\"Resending last message \\\"%s\\\" to Enlightenment.\\n\", str));\n\t} else {\n\t\tif (last_msg != NULL) {\n\t\t\tfree(last_msg);\n\t\t}\n\t\tlast_msg = estrdup(str);\n\t\tD((\"Sending \\\"%s\\\" to Enlightenment.\\n\", str));\n\t}\n\tif (ipc_win == None) {\n\t\tif ((ipc_win = enl_ipc_get_win()) == None) {\n\t\t\tD((\"Hrm. Enlightenment doesn't seem to be running. No IPC window, no IPC.\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\tlen = strlen(str);\n\tipc_atom = XInternAtom(disp, \"ENL_MSG\", False);\n\tif (ipc_atom == None) {\n\t\tD((\"IPC error:  Unable to find/create ENL_MSG atom.\\n\"));\n\t\treturn;\n\t}\n\tfor (; XCheckTypedWindowEvent(disp, my_ipc_win, ClientMessage, &ev););\t/* Discard any out-of-sync messages */\n\tev.xclient.type = ClientMessage;\n\tev.xclient.serial = 0;\n\tev.xclient.send_event = True;\n\tev.xclient.window = ipc_win;\n\tev.xclient.message_type = ipc_atom;\n\tev.xclient.format = 8;\n\n\tfor (i = 0; i < len + 1; i += 12) {\n\t\tsprintf(buff, \"%8x\", (int) my_ipc_win);\n\t\tfor (j = 0; j < 12; j++) {\n\t\t\tbuff[8 + j] = str[i + j];\n\t\t\tif (!str[i + j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuff[20] = 0;\n\t\tfor (j = 0; j < 20; j++) {\n\t\t\tev.xclient.data.b[j] = buff[j];\n\t\t}\n\t\tXSendEvent(disp, ipc_win, False, 0, (XEvent *) & ev);\n\t}\n\treturn;\n}\n\nstatic sighandler_t *enl_ipc_timeout(int sig)\n{\n\ttimeout = 1;\n\treturn((sighandler_t *) sig);\n}\n\nchar *enl_wait_for_reply(void)\n{\n\n\tXEvent ev;\n\tstatic char msg_buffer[20];\n\tregister unsigned char i;\n\n\talarm(2);\n\tfor (; !XCheckTypedWindowEvent(disp, my_ipc_win, ClientMessage, &ev)\n\t     && !timeout;);\n\talarm(0);\n\tif (ev.xany.type != ClientMessage) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 20; i++) {\n\t\tmsg_buffer[i] = ev.xclient.data.b[i];\n\t}\n\treturn(msg_buffer + 8);\n}\n\nchar *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}\n\nchar *enl_send_and_wait(char *msg)\n{\n\tchar *reply = IPC_TIMEOUT;\n\tsighandler_t old_alrm;\n\n\t/*\n\t * Shortcut this func and return IPC_FAKE\n\t * If the IPC Window is the E17 fake\n\t */\n\tif (e17_fake_ipc)\n\t\treturn IPC_FAKE;\n\n\tif (ipc_win == None) {\n\t\t/* The IPC window is missing.  Wait for it to return or feh to be killed. */\n\t\t/* Only called once in the E17 case */\n\t\tfor (; enl_ipc_get_win() == None;) {\n\t\t\tif (e17_fake_ipc)\n\t\t\t\treturn IPC_FAKE;\n\t\t\telse\n\t\t\t\tsleep(1);\n\t\t}\n\t}\n\told_alrm = (sighandler_t) signal(SIGALRM, (sighandler_t) enl_ipc_timeout);\n\tfor (; reply == IPC_TIMEOUT;) {\n\t\ttimeout = 0;\n\t\tenl_ipc_send(msg);\n\t\tfor (; !(reply = enl_ipc_get(enl_wait_for_reply())););\n\t\tif (reply == IPC_TIMEOUT) {\n\t\t\t/* We timed out.  The IPC window must be AWOL.  Reset and resend message. */\n\t\t\tD((\"IPC timed out.  IPC window has gone. Clearing ipc_win.\\n\"));\n\t\t\tXSelectInput(disp, ipc_win, None);\n\t\t\tipc_win = None;\n\t\t}\n\t}\n\tsignal(SIGALRM, old_alrm);\n\treturn(reply);\n}\n"], "fixing_code": ["/* wallpaper.c\n\nCopyright (C) 1999-2003 Tom Gilbert.\nCopyright (C) 2010-2011 Daniel Friesel.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to\ndeal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\nsell copies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies of the Software and its documentation and acknowledgment shall be\ngiven in the documentation and software packages that this Software was\nused.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n#include \"feh.h\"\n#include \"filelist.h\"\n#include \"options.h\"\n#include \"wallpaper.h\"\n#include <limits.h>\n#include <sys/stat.h>\nWindow ipc_win = None;\nWindow my_ipc_win = None;\nAtom ipc_atom = None;\nstatic unsigned char timeout = 0;\n\n/*\n * This is a boolean indicating\n * That while we seem to see E16 IPC\n * it's actually E17 faking it\n * -- richlowe 2005-06-22\n */\nstatic char e17_fake_ipc = 0;\n\nvoid feh_wm_set_bg_filelist(unsigned char bgmode)\n{\n\tif (filelist_len == 0)\n\t\teprintf(\"No files specified for background setting\");\n\n\tswitch (bgmode) {\n\t\tcase BG_MODE_TILE:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_SCALE:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 1, 0, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_FILL:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 1, 0, 1);\n\t\t\tbreak;\n\t\tcase BG_MODE_MAX:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 0, 0, 2, 0, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfeh_wm_set_bg(NULL, NULL, 1, 0, 0, 0, 1);\n\t\t\tbreak;\n\t}\n}\n\nstatic void feh_wm_load_next(Imlib_Image *im)\n{\n\tstatic gib_list *wpfile = NULL;\n\n\tif (wpfile == NULL)\n\t\twpfile = filelist;\n\n\tif (feh_load_image(im, FEH_FILE(wpfile->data)) == 0)\n\t\teprintf(\"Unable to load image %s\", FEH_FILE(wpfile->data)->filename);\n\tif (wpfile->next)\n\t\twpfile = wpfile->next;\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_scaled(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\tgib_imlib_render_image_on_drawable_at_size(pmap, im, x, y, w, h,\n\t\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_centered(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint offset_x, offset_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\tif(opt.geom_flags & XValue)\n\t\tif(opt.geom_flags & XNegative)\n\t\t\toffset_x = (w - gib_imlib_image_get_width(im)) + opt.geom_x;\n\t\telse\n\t\t\toffset_x = opt.geom_x;\n\telse\n\t\toffset_x = (w - gib_imlib_image_get_width(im)) >> 1;\n\n\tif(opt.geom_flags & YValue)\n\t\tif(opt.geom_flags & YNegative)\n\t\t\toffset_y = (h - gib_imlib_image_get_height(im)) + opt.geom_y;\n\t\telse\n\t\t\toffset_y = opt.geom_y;\n\telse\n\t\toffset_y = (h - gib_imlib_image_get_height(im)) >> 1;\n\n\tgib_imlib_render_image_part_on_drawable_at_size(pmap, im,\n\t\t((offset_x < 0) ? -offset_x : 0),\n\t\t((offset_y < 0) ? -offset_y : 0),\n\t\tw,\n\t\th,\n\t\tx + ((offset_x > 0) ? offset_x : 0),\n\t\ty + ((offset_y > 0) ? offset_y : 0),\n\t\tw,\n\t\th,\n\t\t1, 0, 0);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_filled(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint img_w, img_h, cut_x;\n\tint render_w, render_h, render_x, render_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\timg_w = gib_imlib_image_get_width(im);\n\timg_h = gib_imlib_image_get_height(im);\n\n\tcut_x = (((img_w * h) > (img_h * w)) ? 1 : 0);\n\n\trender_w = (  cut_x ? ((img_h * w) / h) : img_w);\n\trender_h = ( !cut_x ? ((img_w * h) / w) : img_h);\n\n\trender_x = (  cut_x ? ((img_w - render_w) >> 1) : 0);\n\trender_y = ( !cut_x ? ((img_h - render_h) >> 1) : 0);\n\n\tgib_imlib_render_image_part_on_drawable_at_size(pmap, im,\n\t\trender_x, render_y,\n\t\trender_w, render_h,\n\t\tx, y, w, h,\n\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nstatic void feh_wm_set_bg_maxed(Pixmap pmap, Imlib_Image im, int use_filelist,\n\t\tint x, int y, int w, int h)\n{\n\tint img_w, img_h, border_x;\n\tint render_w, render_h, render_x, render_y;\n\tint margin_x, margin_y;\n\n\tif (use_filelist)\n\t\tfeh_wm_load_next(&im);\n\n\timg_w = gib_imlib_image_get_width(im);\n\timg_h = gib_imlib_image_get_height(im);\n\n\tborder_x = (((img_w * h) > (img_h * w)) ? 0 : 1);\n\n\trender_w = (  border_x ? ((img_w * h) / img_h) : w);\n\trender_h = ( !border_x ? ((img_h * w) / img_w) : h);\n\n\tif(opt.geom_flags & XValue)\n\t\tif(opt.geom_flags & XNegative)\n\t\t\tmargin_x = (w - render_w) + opt.geom_x;\n\t\telse\n\t\t\tmargin_x = opt.geom_x;\n\telse\n\t\tmargin_x = (w - render_w) >> 1;\n\n\tif(opt.geom_flags & YValue)\n\t\tif(opt.geom_flags & YNegative)\n\t\t\tmargin_y = (h - render_h) + opt.geom_y;\n\t\telse\n\t\t\tmargin_y = opt.geom_y;\n\telse\n\t\tmargin_y = (h - render_h) >> 1;\n\n\trender_x = x + (  border_x ? margin_x : 0);\n\trender_y = y + ( !border_x ? margin_y : 0);\n\n\tgib_imlib_render_image_on_drawable_at_size(pmap, im,\n\t\trender_x, render_y,\n\t\trender_w, render_h,\n\t\t1, 0, !opt.force_aliasing);\n\n\tif (use_filelist)\n\t\tgib_imlib_free_image_and_decache(im);\n\n\treturn;\n}\n\nvoid feh_wm_set_bg(char *fil, Imlib_Image im, int centered, int scaled,\n\t\tint filled, int desktop, int use_filelist)\n{\n\tXGCValues gcvalues;\n\tXGCValues gcval;\n\tGC gc;\n\tchar bgname[20];\n\tint num = (int) rand();\n\tchar bgfil[4096];\n\tchar sendbuf[4096];\n\n\t/*\n\t * TODO this re-implements mkstemp (badly). However, it is only needed\n\t * for non-file images and enlightenment. Might be easier to just remove\n\t * it.\n\t */\n\n\tsnprintf(bgname, sizeof(bgname), \"FEHBG_%d\", num);\n\n\tif (!fil && im) {\n\t\tif (getenv(\"HOME\") == NULL) {\n\t\t\tweprintf(\"Cannot save wallpaper to temporary file: You have no HOME\");\n\t\t\treturn;\n\t\t}\n\t\tsnprintf(bgfil, sizeof(bgfil), \"%s/.%s.png\", getenv(\"HOME\"), bgname);\n\t\timlib_context_set_image(im);\n\t\timlib_image_set_format(\"png\");\n\t\tgib_imlib_save_image(im, bgfil);\n\t\tD((\"bg saved as %s\\n\", bgfil));\n\t\tfil = bgfil;\n\t}\n\n\tif (feh_wm_get_wm_is_e() && (enl_ipc_get_win() != None)) {\n\t\tif (use_filelist) {\n\t\t\tfeh_wm_load_next(&im);\n\t\t\tfil = FEH_FILE(filelist->data)->filename;\n\t\t}\n\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.file %s\", bgname, fil);\n\t\tenl_ipc_send(sendbuf);\n\n\t\tif (scaled) {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.solid 0 0 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xperc 1024\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yperc 1024\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t} else if (centered) {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.solid 0 0 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 0\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.xjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.yjust 512\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t} else {\n\t\t\tsnprintf(sendbuf, sizeof(sendbuf), \"background %s bg.tile 1\", bgname);\n\t\t\tenl_ipc_send(sendbuf);\n\t\t}\n\n\t\tsnprintf(sendbuf, sizeof(sendbuf), \"use_bg %s %d\", bgname, desktop);\n\t\tenl_ipc_send(sendbuf);\n\t\tenl_ipc_sync();\n\t} else {\n\t\tAtom prop_root, prop_esetroot, type;\n\t\tint format, i;\n\t\tunsigned long length, after;\n\t\tunsigned char *data_root = NULL, *data_esetroot = NULL;\n\t\tPixmap pmap_d1, pmap_d2;\n\t\tgib_list *l;\n\n\t\t/* string for sticking in ~/.fehbg */\n\t\tchar *fehbg = NULL;\n\t\tchar fehbg_args[512];\n\t\tfehbg_args[0] = '\\0';\n\t\tchar *home;\n\t\tchar filbuf[4096];\n\t\tchar *bgfill = NULL;\n\t\tbgfill = opt.image_bg == IMAGE_BG_WHITE ?  \"--image-bg white\" : \"--image-bg black\" ;\n\n#ifdef HAVE_LIBXINERAMA\n\t\tif (opt.xinerama) {\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tsnprintf(fehbg_args, sizeof(fehbg_args),\n\t\t\t\t\t\"--xinerama-index %d\", opt.xinerama_index);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tsnprintf(fehbg_args, sizeof(fehbg_args), \"--no-xinerama\");\n#endif\t\t\t/* HAVE_LIBXINERAMA */\n\n\t\t/* local display to set closedownmode on */\n\t\tDisplay *disp2;\n\t\tWindow root2;\n\t\tint depth2;\n\t\tint in, out, w, h;\n\n\t\tD((\"Falling back to XSetRootWindowPixmap\\n\"));\n\n\t\t/* Put the filename in filbuf between ' and escape ' in the filename */\n\t\tout = 0;\n\n\t\tif (fil && !use_filelist) {\n\t\t\tfilbuf[out++] = '\\'';\n\n\t\t\tfil = feh_absolute_path(fil);\n\n\t\t\tfor (in = 0; fil[in] && out < 4092; in++) {\n\n\t\t\t\tif (fil[in] == '\\'')\n\t\t\t\t\tfilbuf[out++] = '\\\\';\n\t\t\t\tfilbuf[out++] = fil[in];\n\t\t\t}\n\t\t\tfilbuf[out++] = '\\'';\n\t\t\tfree(fil);\n\n\t\t} else {\n\t\t\tfor (l = filelist; l && out < 4092; l = l->next) {\n\t\t\t\tfilbuf[out++] = '\\'';\n\n\t\t\t\tfil = feh_absolute_path(FEH_FILE(l->data)->filename);\n\n\t\t\t\tfor (in = 0; fil[in] && out < 4092; in++) {\n\n\t\t\t\t\tif (fil[in] == '\\'')\n\t\t\t\t\t\tfilbuf[out++] = '\\\\';\n\t\t\t\t\tfilbuf[out++] = fil[in];\n\t\t\t\t}\n\t\t\t\tfilbuf[out++] = '\\'';\n\t\t\t\tfilbuf[out++] = ' ';\n\t\t\t\tfree(fil);\n\t\t\t}\n\t\t}\n\n\n\t\tfilbuf[out++] = 0;\n\n\t\tif (scaled) {\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\t\telse\n\t\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\t\t\t\tXFreeGC(disp, gc);\n\t\t\t}\n\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_scaled(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_scaled(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, \"--bg-scale\", filbuf, NULL);\n\t\t} else if (centered) {\n\n\t\t\tD((\"centering\\n\"));\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\telse\n\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_centered(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_centered(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\n\t\t\tXFreeGC(disp, gc);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, bgfill, \"--bg-center\", filbuf, NULL);\n\n\t\t} else if (filled == 1) {\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama_index >= 0) {\n\t\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\t\telse\n\t\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\t\t\t\tXFreeGC(disp, gc);\n\t\t\t}\n\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_filled(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_filled(pmap_d1, im, use_filelist\n\t\t\t\t\t, 0, 0, scr->width, scr->height);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, \"--bg-fill\", filbuf, NULL);\n\n\t\t} else if (filled == 2) {\n\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, scr->width, scr->height, depth);\n\t\t\tif (opt.image_bg == IMAGE_BG_WHITE)\n\t\t\t\tgcval.foreground = WhitePixel(disp, DefaultScreen(disp));\n\t\t\telse\n\t\t\t\tgcval.foreground = BlackPixel(disp, DefaultScreen(disp));\n\t\t\tgc = XCreateGC(disp, root, GCForeground, &gcval);\n\t\t\tXFillRectangle(disp, pmap_d1, gc, 0, 0, scr->width, scr->height);\n\n#ifdef HAVE_LIBXINERAMA\n\t\t\tif (opt.xinerama && xinerama_screens) {\n\t\t\t\tfor (i = 0; i < num_xinerama_screens; i++) {\n\t\t\t\t\tif (opt.xinerama_index < 0 || opt.xinerama_index == i) {\n\t\t\t\t\t\tfeh_wm_set_bg_maxed(pmap_d1, im, use_filelist,\n\t\t\t\t\t\t\txinerama_screens[i].x_org, xinerama_screens[i].y_org,\n\t\t\t\t\t\t\txinerama_screens[i].width, xinerama_screens[i].height);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n#endif\t\t\t\t/* HAVE_LIBXINERAMA */\n\t\t\t\tfeh_wm_set_bg_maxed(pmap_d1, im, use_filelist,\n\t\t\t\t\t0, 0, scr->width, scr->height);\n\n\t\t\tXFreeGC(disp, gc);\n\n\t\t\tfehbg = estrjoin(\" \", \"feh\", fehbg_args, bgfill, \"--bg-max\", filbuf, NULL);\n\n\t\t} else {\n\t\t\tif (use_filelist)\n\t\t\t\tfeh_wm_load_next(&im);\n\t\t\tw = gib_imlib_image_get_width(im);\n\t\t\th = gib_imlib_image_get_height(im);\n\t\t\tpmap_d1 = XCreatePixmap(disp, root, w, h, depth);\n\t\t\tgib_imlib_render_image_on_drawable(pmap_d1, im, 0, 0, 1, 0, 0);\n\t\t\tfehbg = estrjoin(\" \", \"feh --bg-tile\", filbuf, NULL);\n\t\t}\n\n\t\tif (fehbg && !opt.no_fehbg) {\n\t\t\thome = getenv(\"HOME\");\n\t\t\tif (home) {\n\t\t\t\tFILE *fp;\n\t\t\t\tchar *path;\n\t\t\t\tstruct stat s;\n\t\t\t\tpath = estrjoin(\"/\", home, \".fehbg\", NULL);\n\t\t\t\tif ((fp = fopen(path, \"w\")) == NULL) {\n\t\t\t\t\tweprintf(\"Can't write to %s\", path);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(fp, \"#!/bin/sh\\n%s\\n\", fehbg);\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\tstat(path, &s);\n\t\t\t\t\tif (chmod(path, s.st_mode | S_IXUSR | S_IXGRP) != 0) {\n\t\t\t\t\t\tweprintf(\"Can't set %s as executable\", path);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(path);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfree(fehbg);\n\n\t\t/* create new display, copy pixmap to new display */\n\t\tdisp2 = XOpenDisplay(NULL);\n\t\tif (!disp2)\n\t\t\teprintf(\"Can't reopen X display.\");\n\t\troot2 = RootWindow(disp2, DefaultScreen(disp2));\n\t\tdepth2 = DefaultDepth(disp2, DefaultScreen(disp2));\n\t\tXSync(disp, False);\n\t\tpmap_d2 = XCreatePixmap(disp2, root2, scr->width, scr->height, depth2);\n\t\tgcvalues.fill_style = FillTiled;\n\t\tgcvalues.tile = pmap_d1;\n\t\tgc = XCreateGC(disp2, pmap_d2, GCFillStyle | GCTile, &gcvalues);\n\t\tXFillRectangle(disp2, pmap_d2, gc, 0, 0, scr->width, scr->height);\n\t\tXFreeGC(disp2, gc);\n\t\tXSync(disp2, False);\n\t\tXSync(disp, False);\n\t\tXFreePixmap(disp, pmap_d1);\n\n\t\tprop_root = XInternAtom(disp2, \"_XROOTPMAP_ID\", True);\n\t\tprop_esetroot = XInternAtom(disp2, \"ESETROOT_PMAP_ID\", True);\n\n\t\tif (prop_root != None && prop_esetroot != None) {\n\t\t\tXGetWindowProperty(disp2, root2, prop_root, 0L, 1L,\n\t\t\t\t\t   False, AnyPropertyType, &type, &format, &length, &after, &data_root);\n\t\t\tif (type == XA_PIXMAP) {\n\t\t\t\tXGetWindowProperty(disp2, root2,\n\t\t\t\t\t\t   prop_esetroot, 0L, 1L,\n\t\t\t\t\t\t   False, AnyPropertyType,\n\t\t\t\t\t\t   &type, &format, &length, &after, &data_esetroot);\n\t\t\t\tif (data_root && data_esetroot) {\n\t\t\t\t\tif (type == XA_PIXMAP && *((Pixmap *) data_root) == *((Pixmap *) data_esetroot)) {\n\t\t\t\t\t\tXKillClient(disp2, *((Pixmap *)\n\t\t\t\t\t\t\t\t     data_root));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data_root)\n\t\t\tXFree(data_root);\n\t\n\t\tif (data_esetroot)\n\t\t\tXFree(data_esetroot);\n\n\t\t/* This will locate the property, creating it if it doesn't exist */\n\t\tprop_root = XInternAtom(disp2, \"_XROOTPMAP_ID\", False);\n\t\tprop_esetroot = XInternAtom(disp2, \"ESETROOT_PMAP_ID\", False);\n\n\t\tif (prop_root == None || prop_esetroot == None)\n\t\t\teprintf(\"creation of pixmap property failed.\");\n\n\t\tXChangeProperty(disp2, root2, prop_root, XA_PIXMAP, 32, PropModeReplace, (unsigned char *) &pmap_d2, 1);\n\t\tXChangeProperty(disp2, root2, prop_esetroot, XA_PIXMAP, 32,\n\t\t\t\tPropModeReplace, (unsigned char *) &pmap_d2, 1);\n\n\t\tXSetWindowBackgroundPixmap(disp2, root2, pmap_d2);\n\t\tXClearWindow(disp2, root2);\n\t\tXFlush(disp2);\n\t\tXSetCloseDownMode(disp2, RetainPermanent);\n\t\tXCloseDisplay(disp2);\n\t}\n\treturn;\n}\n\nsigned char feh_wm_get_wm_is_e(void)\n{\n\tstatic signed char e = -1;\n\n\t/* check if E is actually running */\n\tif (e == -1) {\n\t\t/* XXX: This only covers E17 prior to 6/22/05 */\n\t\tif ((XInternAtom(disp, \"ENLIGHTENMENT_COMMS\", True) != None)\n\t\t    && (XInternAtom(disp, \"ENLIGHTENMENT_VERSION\", True) != None)) {\n\t\t\tD((\"Enlightenment detected.\\n\"));\n\t\t\te = 1;\n\t\t} else {\n\t\t\tD((\"Enlightenment not detected.\\n\"));\n\t\t\te = 0;\n\t\t}\n\t}\n\treturn(e);\n}\n\nint feh_wm_get_num_desks(void)\n{\n\tchar *buf, *ptr;\n\tint desks;\n\n\tif (!feh_wm_get_wm_is_e())\n\t\treturn(-1);\n\n\tbuf = enl_send_and_wait(\"num_desks ?\");\n\tif (buf == IPC_FAKE)\t/* Fake E17 IPC */\n\t\treturn(-1);\n\tD((\"Got from E IPC: %s\\n\", buf));\n\tptr = buf;\n\twhile (ptr && !isdigit(*ptr))\n\t\tptr++;\n\tdesks = atoi(ptr);\n\n\treturn(desks);\n}\n\nWindow enl_ipc_get_win(void)\n{\n\n\tunsigned char *str = NULL;\n\tAtom prop, prop2, ever;\n\tunsigned long num, after;\n\tint format;\n\tWindow dummy_win;\n\tint dummy_int;\n\tunsigned int dummy_uint;\n\n\tD((\"Searching for IPC window.\\n\"));\n\n\t/*\n\t * Shortcircuit this entire func\n\t * if we already know it's an e17 fake\n\t */\n\tif (e17_fake_ipc)\n\t\treturn(ipc_win);\n\n\t\t    prop = XInternAtom(disp, \"ENLIGHTENMENT_COMMS\", True);\n\tif (prop == None) {\n\t\tD((\"Enlightenment is not running.\\n\"));\n\t\treturn(None);\n\t} else {\n\t\t/* XXX: This will only work with E17 prior to 6/22/2005 */\n\t\tever = XInternAtom(disp, \"ENLIGHTENMENT_VERSION\", True);\n\t\tif (ever == None) {\n\t\t\t/* This is an E without ENLIGHTENMENT_VERSION */\n\t\t\tD((\"E16 IPC Protocol not supported\"));\n\t\t\treturn(None);\n\t\t}\n\t}\n\tXGetWindowProperty(disp, root, prop, 0, 14, False, AnyPropertyType, &prop2, &format, &num, &after, &str);\n\tif (str) {\n\t\tsscanf((char *) str, \"%*s %x\", (unsigned int *) &ipc_win);\n\t\tXFree(str);\n\t}\n\tif (ipc_win != None) {\n\t\tif (!XGetGeometry\n\t\t    (disp, ipc_win, &dummy_win, &dummy_int, &dummy_int,\n\t\t     &dummy_uint, &dummy_uint, &dummy_uint, &dummy_uint)) {\n\t\t\tD((\" -> IPC Window property is valid, but the window doesn't exist.\\n\"));\n\t\t\tipc_win = None;\n\t\t}\n\t\tstr = NULL;\n\t\tif (ipc_win != None) {\n\t\t\tXGetWindowProperty(disp, ipc_win, prop, 0, 14,\n\t\t\t\t\t   False, AnyPropertyType, &prop2, &format, &num, &after, &str);\n\t\t\tif (str) {\n\t\t\t\tXFree(str);\n\t\t\t} else {\n\t\t\t\tD((\" -> IPC Window lacks the proper atom.  I can't talk to fake IPC windows....\\n\"));\n\t\t\t\tipc_win = None;\n\t\t\t}\n\t\t}\n\t}\n\tif (ipc_win != None) {\n\n\t\tXGetWindowProperty(disp, ipc_win, ever, 0, 14, False,\n\t\t\t\t   AnyPropertyType, &prop2, &format, &num, &after, &str);\n\t\tif (str) {\n\t\t\t/*\n\t\t\t * This is E17's way of telling us it's only pretending\n\t\t\t * as a workaround for a bug related to the way java handles\n\t\t\t * Window Managers.\n\t\t\t * (Only valid after date of this comment)\n\t\t\t * -- richlowe 2005-06-22\n\t\t\t */\n\t\t\tXFree(str);\n\t\t\tD((\" -> Found a fake E17 IPC window, ignoring\"));\n\t\t\tipc_win = None;\n\t\t\te17_fake_ipc = 1;\n\t\t\treturn(ipc_win);\n\t\t}\n\n\t\tD((\" -> IPC Window found and verified as 0x%08x.  Registering feh as an IPC client.\\n\", (int) ipc_win));\n\t\tXSelectInput(disp, ipc_win, StructureNotifyMask | SubstructureNotifyMask);\n\t\tenl_ipc_send(\"set clientname \" PACKAGE);\n\t\tenl_ipc_send(\"set version \" VERSION);\n\t\tenl_ipc_send(\"set email tom@linuxbrit.co.uk\");\n\t\tenl_ipc_send(\"set web http://www.linuxbrit.co.uk\");\n\t\tenl_ipc_send(\"set info Feh - be pr0n or be dead\");\n\t}\n\tif (my_ipc_win == None) {\n\t\tmy_ipc_win = XCreateSimpleWindow(disp, root, -2, -2, 1, 1, 0, 0, 0);\n\t}\n\treturn(ipc_win);\n}\n\nvoid enl_ipc_send(char *str)\n{\n\n\tstatic char *last_msg = NULL;\n\tchar buff[21];\n\tregister unsigned short i;\n\tregister unsigned char j;\n\tunsigned short len;\n\tXEvent ev;\n\n\tif (str == NULL) {\n\t\tif (last_msg == NULL)\n\t\t\teprintf(\"eeek\");\n\t\tstr = last_msg;\n\t\tD((\"Resending last message \\\"%s\\\" to Enlightenment.\\n\", str));\n\t} else {\n\t\tif (last_msg != NULL) {\n\t\t\tfree(last_msg);\n\t\t}\n\t\tlast_msg = estrdup(str);\n\t\tD((\"Sending \\\"%s\\\" to Enlightenment.\\n\", str));\n\t}\n\tif (ipc_win == None) {\n\t\tif ((ipc_win = enl_ipc_get_win()) == None) {\n\t\t\tD((\"Hrm. Enlightenment doesn't seem to be running. No IPC window, no IPC.\\n\"));\n\t\t\treturn;\n\t\t}\n\t}\n\tlen = strlen(str);\n\tipc_atom = XInternAtom(disp, \"ENL_MSG\", False);\n\tif (ipc_atom == None) {\n\t\tD((\"IPC error:  Unable to find/create ENL_MSG atom.\\n\"));\n\t\treturn;\n\t}\n\tfor (; XCheckTypedWindowEvent(disp, my_ipc_win, ClientMessage, &ev););\t/* Discard any out-of-sync messages */\n\tev.xclient.type = ClientMessage;\n\tev.xclient.serial = 0;\n\tev.xclient.send_event = True;\n\tev.xclient.window = ipc_win;\n\tev.xclient.message_type = ipc_atom;\n\tev.xclient.format = 8;\n\n\tfor (i = 0; i < len + 1; i += 12) {\n\t\tsprintf(buff, \"%8x\", (int) my_ipc_win);\n\t\tfor (j = 0; j < 12; j++) {\n\t\t\tbuff[8 + j] = str[i + j];\n\t\t\tif (!str[i + j]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbuff[20] = 0;\n\t\tfor (j = 0; j < 20; j++) {\n\t\t\tev.xclient.data.b[j] = buff[j];\n\t\t}\n\t\tXSendEvent(disp, ipc_win, False, 0, (XEvent *) & ev);\n\t}\n\treturn;\n}\n\nstatic sighandler_t *enl_ipc_timeout(int sig)\n{\n\ttimeout = 1;\n\treturn((sighandler_t *) sig);\n}\n\nchar *enl_wait_for_reply(void)\n{\n\n\tXEvent ev;\n\tstatic char msg_buffer[20];\n\tregister unsigned char i;\n\n\talarm(2);\n\tfor (; !XCheckTypedWindowEvent(disp, my_ipc_win, ClientMessage, &ev)\n\t     && !timeout;);\n\talarm(0);\n\tif (ev.xany.type != ClientMessage) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 20; i++) {\n\t\tmsg_buffer[i] = ev.xclient.data.b[i];\n\t}\n\treturn(msg_buffer + 8);\n}\n\nchar *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic size_t len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}\n\nchar *enl_send_and_wait(char *msg)\n{\n\tchar *reply = IPC_TIMEOUT;\n\tsighandler_t old_alrm;\n\n\t/*\n\t * Shortcut this func and return IPC_FAKE\n\t * If the IPC Window is the E17 fake\n\t */\n\tif (e17_fake_ipc)\n\t\treturn IPC_FAKE;\n\n\tif (ipc_win == None) {\n\t\t/* The IPC window is missing.  Wait for it to return or feh to be killed. */\n\t\t/* Only called once in the E17 case */\n\t\tfor (; enl_ipc_get_win() == None;) {\n\t\t\tif (e17_fake_ipc)\n\t\t\t\treturn IPC_FAKE;\n\t\t\telse\n\t\t\t\tsleep(1);\n\t\t}\n\t}\n\told_alrm = (sighandler_t) signal(SIGALRM, (sighandler_t) enl_ipc_timeout);\n\tfor (; reply == IPC_TIMEOUT;) {\n\t\ttimeout = 0;\n\t\tenl_ipc_send(msg);\n\t\tfor (; !(reply = enl_ipc_get(enl_wait_for_reply())););\n\t\tif (reply == IPC_TIMEOUT) {\n\t\t\t/* We timed out.  The IPC window must be AWOL.  Reset and resend message. */\n\t\t\tD((\"IPC timed out.  IPC window has gone. Clearing ipc_win.\\n\"));\n\t\t\tXSelectInput(disp, ipc_win, None);\n\t\t\tipc_win = None;\n\t\t}\n\t}\n\tsignal(SIGALRM, old_alrm);\n\treturn(reply);\n}\n"], "filenames": ["src/wallpaper.c"], "buggy_code_start_loc": [798], "buggy_code_end_loc": [799], "fixing_code_start_loc": [798], "fixing_code_end_loc": [799], "type": "CWE-787", "message": "In wallpaper.c in feh before v2.18.3, if a malicious client pretends to be the E17 window manager, it is possible to trigger an out-of-boundary heap write while receiving an IPC message. An integer overflow leads to a buffer overflow and/or a double free.", "other": {"cve": {"id": "CVE-2017-7875", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T18:59:01.173", "lastModified": "2020-05-24T20:15:09.950", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In wallpaper.c in feh before v2.18.3, if a malicious client pretends to be the E17 window manager, it is possible to trigger an out-of-boundary heap write while receiving an IPC message. An integer overflow leads to a buffer overflow and/or a double free."}, {"lang": "es", "value": "En wallpaper.c en feh en versiones anteriores a v2.18.3, si un cliente malintencionado pretende ser el gestor de ventanas E17, es posible desencadenar una escritura memoria din\u00e1mica fuera de l\u00edmite mientras recibe un mensaje IPC. Un desbordamiento de n\u00famero entero conduce a un desbordamiento del b\u00fafer y/o un doble libre."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:feh_project:feh:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.18.2", "matchCriteriaId": "27B005AA-B8B8-4CD8-8F04-BF2348556CD9"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97689", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://feh.finalrewind.org/", "source": "cve@mitre.org", "tags": ["Patch", "Product"]}, {"url": "https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/05/msg00021.html", "source": "cve@mitre.org"}, {"url": "https://security.gentoo.org/glsa/201707-08", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/derf/feh/commit/f7a547b7ef8fc8ebdeaa4c28515c9d72e592fb6d"}}