{"buggy_code": ["#ifndef UTIL_LINUX_FILEUTILS\n#define UTIL_LINUX_FILEUTILS\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"c.h\"\n\nextern int xmkstemp(char **tmpname, char *dir);\n\nstatic inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nextern int dup_fd_cloexec(int oldfd, int lowfd);\nextern int get_fd_tabsize(void);\n\nextern int mkdir_p(const char *path, mode_t mode);\nextern char *stripoff_last_component(char *path);\n\n#endif /* UTIL_LINUX_FILEUTILS */\n", "/*\n * Copyright (C) 2012 Sami Kerola <kerolasa@iki.fi>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"pathnames.h\"\n\n/* Create open temporary file in safe way.  Please notice that the\n * file permissions are -rw------- by default. */\nint xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}\n\nint dup_fd_cloexec(int oldfd, int lowfd)\n{\n\tint fd, flags, errno_save;\n\n#ifdef F_DUPFD_CLOEXEC\n\tfd = fcntl(oldfd, F_DUPFD_CLOEXEC, lowfd);\n\tif (fd >= 0)\n\t\treturn fd;\n#endif\n\n\tfd = dup(oldfd);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags < 0)\n\t\tgoto unwind;\n\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)\n\t\tgoto unwind;\n\n\treturn fd;\n\nunwind:\n\terrno_save = errno;\n\tclose(fd);\n\terrno = errno_save;\n\n\treturn -1;\n}\n\n/*\n * portable getdtablesize()\n */\nint get_fd_tabsize(void)\n{\n\tint m;\n\n#if defined(HAVE_GETDTABLESIZE)\n\tm = getdtablesize();\n#elif defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE)\n\tstruct rlimit rl;\n\n\tgetrlimit(RLIMIT_NOFILE, &rl);\n\tm = rl.rlim_cur;\n#elif defined(HAVE_SYSCONF) && defined(_SC_OPEN_MAX)\n\tm = sysconf(_SC_OPEN_MAX);\n#else\n\tm = OPEN_MAX;\n#endif\n\treturn m;\n}\n\n#ifdef TEST_PROGRAM\nint main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}\n#endif\n\n\nint mkdir_p(const char *path, mode_t mode)\n{\n\tchar *p, *dir;\n\tint rc = 0;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\tdir = p = strdup(path);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (*p == '/')\n\t\tp++;\n\n\twhile (p && *p) {\n\t\tchar *e = strchr(p, '/');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\t\tif (*p) {\n\t\t\trc = mkdir(dir, mode);\n\t\t\tif (rc && errno != EEXIST)\n\t\t\t\tbreak;\n\t\t\trc = 0;\n\t\t}\n\t\tif (!e)\n\t\t\tbreak;\n\t\t*e = '/';\n\t\tp = e + 1;\n\t}\n\n\tfree(dir);\n\treturn rc;\n}\n\n/* returns basename and keeps dirname in the @path, if @path is \"/\" (root)\n * then returns empty string */\nchar *stripoff_last_component(char *path)\n{\n\tchar *p = path ? strrchr(path, '/') : NULL;\n\n\tif (!p)\n\t\treturn NULL;\n\t*p = '\\0';\n\treturn p + 1;\n}\n", "/*\n *   chfn.c -- change your finger information\n *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>\n *   (c) 2012 by Cody Maloney <cmaloney@theoreticalchaos.com>\n *\n *   this program is free software.  you can redistribute it and\n *   modify it under the terms of the gnu general public license.\n *   there is no warranty.\n *\n *   $Author: aebr $\n *   $Revision: 1.18 $\n *   $Date: 1998/06/11 22:30:11 $\n *\n * Updated Thu Oct 12 09:19:26 1995 by faith@cs.unc.edu with security\n * patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Hacked by Peter Breitenlohner, peb@mppmu.mpg.de,\n * to remove trailing empty fields.  Oct 5, 96.\n *\n *  1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n *  - added Native Language Support\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"islocal.h\"\n#include \"nls.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"logindefs.h\"\n\n#include \"ch-common.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n# include <selinux/av_permissions.h>\n# include \"selinux_utils.h\"\n#endif\n\n#ifdef HAVE_LIBUSER\n# include <libuser/user.h>\n# include \"libuser.h\"\n#elif CHFN_CHSH_PASSWORD\n# include \"auth.h\"\n#endif\n\nstruct finfo {\n\tchar *full_name;\n\tchar *office;\n\tchar *office_phone;\n\tchar *home_phone;\n\tchar *other;\n};\n\nstruct chfn_control {\n\tstruct passwd *pw;\n\tchar *username;\n\t/*  \"oldf\"  Contains the users original finger information.\n\t *  \"newf\"  Contains the changed finger information, and contains\n\t *          NULL in fields that haven't been changed.\n\t *  In the end, \"newf\" is folded into \"oldf\".  */\n\tstruct finfo oldf, newf;\n\tunsigned int\n\t\tallow_fullname:1,\t/* The login.defs restriction */\n\t\tallow_room:1,\t\t   /* see: man login.defs(5) */\n\t\tallow_work:1,\t\t   /* and look for CHFN_RESTRICT */\n\t\tallow_home:1,\t\t   /* keyword for these four. */\n\t\tchanged:1,\t\t/* is change requested */\n\t\tinteractive:1;\t\t/* whether to prompt for fields or not */\n};\n\n/* we do not accept gecos field sizes longer than MAX_FIELD_SIZE */\n#define MAX_FIELD_SIZE\t\t256\n\nstatic void __attribute__((__noreturn__)) usage(FILE *fp)\n{\n\tfputs(USAGE_HEADER, fp);\n\tfprintf(fp, _(\" %s [options] [<username>]\\n\"), program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\"Change your finger information.\\n\"), fp);\n\n\tfputs(USAGE_OPTIONS, fp);\n\tfputs(_(\" -f, --full-name <full-name>  real name\\n\"), fp);\n\tfputs(_(\" -o, --office <office>        office number\\n\"), fp);\n\tfputs(_(\" -p, --office-phone <phone>   office phone number\\n\"), fp);\n\tfputs(_(\" -h, --home-phone <phone>     home phone number\\n\"), fp);\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\" -u, --help     display this help and exit\\n\"), fp);\n\tfputs(_(\" -v, --version  output version information and exit\\n\"), fp);\n\tfprintf(fp, USAGE_MAN_TAIL(\"chfn(1)\"));\n\texit(fp == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n/*\n *  check_gecos_string () --\n *\tcheck that the given gecos string is legal.  if it's not legal,\n *\toutput \"msg\" followed by a description of the problem, and return (-1).\n */\nstatic int check_gecos_string(const char *msg, char *gecos)\n{\n\tconst size_t len = strlen(gecos);\n\n\tif (MAX_FIELD_SIZE < len) {\n\t\twarnx(_(\"field %s is too long\"), msg);\n\t\treturn -1;\n\t}\n\tif (illegal_passwd_chars(gecos)) {\n\t\twarnx(_(\"%s: has illegal characters\"), gecos);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n *  parse_argv () --\n *\tparse the command line arguments.\n *\treturns true if no information beyond the username was given.\n */\nstatic void parse_argv(struct chfn_control *ctl, int argc, char **argv)\n{\n\tint index, c, status = 0;\n\tstatic const struct option long_options[] = {\n\t\t{\"full-name\", required_argument, 0, 'f'},\n\t\t{\"office\", required_argument, 0, 'o'},\n\t\t{\"office-phone\", required_argument, 0, 'p'},\n\t\t{\"home-phone\", required_argument, 0, 'h'},\n\t\t{\"help\", no_argument, 0, 'u'},\n\t\t{\"version\", no_argument, 0, 'v'},\n\t\t{NULL, no_argument, 0, '0'},\n\t};\n\n\twhile ((c = getopt_long(argc, argv, \"f:r:p:h:o:uv\", long_options,\n\t\t\t\t&index)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tif (!ctl->allow_fullname)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Name\"));\n\t\t\tctl->newf.full_name = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Name\"), optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (!ctl->allow_room)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Office\"));\n\t\t\tctl->newf.office = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Office\"), optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (!ctl->allow_work)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Office Phone\"));\n\t\t\tctl->newf.office_phone = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Office Phone\"), optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif (!ctl->allow_home)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Home Phone\"));\n\t\t\tctl->newf.home_phone = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Home Phone\"), optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'u':\n\t\t\tusage(stdout);\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t}\n\t\tctl->changed = 1;\n\t\tctl->interactive = 0;\n\t}\n\tif (status != 0)\n\t\texit(EXIT_FAILURE);\n\t/* done parsing arguments.  check for a username. */\n\tif (optind < argc) {\n\t\tif (optind + 1 < argc)\n\t\t\tusage(stderr);\n\t\tctl->username = argv[optind];\n\t}\n\treturn;\n}\n\n/*\n *  parse_passwd () --\n *\ttake a struct password and fill in the fields of the struct finfo.\n */\nstatic void parse_passwd(struct chfn_control *ctl)\n{\n\tchar *gecos;\n\n\tif (!ctl->pw)\n\t\treturn;\n\t/* use pw_gecos - we take a copy since PAM destroys the original */\n\tgecos = xstrdup(ctl->pw->pw_gecos);\n\t/* extract known fields */\n\tctl->oldf.full_name = strsep(&gecos, \",\");\n\tctl->oldf.office = strsep(&gecos, \",\");\n\tctl->oldf.office_phone = strsep(&gecos, \",\");\n\tctl->oldf.home_phone = strsep(&gecos, \",\");\n\t/*  extra fields contain site-specific information, and can\n\t *  not be changed by this version of chfn.  */\n\tctl->oldf.other = strsep(&gecos, \",\");\n}\n\n/*\n *  ask_new_field () --\n *\task the user for a given field and check that the string is legal.\n */\nstatic char *ask_new_field(struct chfn_control *ctl, const char *question,\n\t\t\t   char *def_val)\n{\n\tint len;\n\tchar *ans;\n\tchar buf[MAX_FIELD_SIZE + 2];\n\n\tif (!def_val)\n\t\tdef_val = \"\";\n\twhile (true) {\n\t\tprintf(\"%s [%s]: \", question, def_val);\n\t\t__fpurge(stdin);\n\t\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\t\terrx(EXIT_FAILURE, _(\"Aborted.\"));\n\t\tans = buf;\n\t\t/* remove white spaces from string end */\n\t\tltrim_whitespace((unsigned char *) ans);\n\t\tlen = rtrim_whitespace((unsigned char *) ans);\n\t\tif (len == 0)\n\t\t\treturn xstrdup(def_val);\n\t\tif (!strcasecmp(ans, \"none\")) {\n\t\t\tctl->changed = 1;\n\t\t\treturn xstrdup(\"\");\n\t\t}\n\t\tif (check_gecos_string(question, ans) >= 0)\n\t\t\tbreak;\n\t}\n\tctl->changed = 1;\n\treturn xstrdup(ans);\n}\n\n/*\n *  get_login_defs()\n *\tfind /etc/login.defs CHFN_RESTRICT and save restrictions to run time\n */\nstatic void get_login_defs(struct chfn_control *ctl)\n{\n\tconst char *s;\n\tsize_t i;\n\tint broken = 0;\n\n\t/* real root does not have restrictions */\n\tif (geteuid() == getuid() && getuid() == 0) {\n\t\tctl->allow_fullname = ctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\ts = getlogindefs_str(\"CHFN_RESTRICT\", \"\");\n\tif (!strcmp(s, \"yes\")) {\n\t\tctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\tif (!strcmp(s, \"no\")) {\n\t\tctl->allow_fullname = ctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\tfor (i = 0; s[i]; i++) {\n\t\tswitch (s[i]) {\n\t\tcase 'f':\n\t\t\tctl->allow_fullname = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tctl->allow_room = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tctl->allow_work = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tctl->allow_home = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbroken = 1;\n\t\t}\n\t}\n\tif (broken)\n\t\twarnx(_(\"%s: CHFN_RESTRICT has unexpected value: %s\"), _PATH_LOGINDEFS, s);\n\tif (!ctl->allow_fullname && !ctl->allow_room && !ctl->allow_work && !ctl->allow_home)\n\t\terrx(EXIT_FAILURE, _(\"%s: CHFN_RESTRICT does not allow any changes\"), _PATH_LOGINDEFS);\n\treturn;\n}\n\n/*\n *  ask_info () --\n *\tprompt the user for the finger information and store it.\n */\nstatic void ask_info(struct chfn_control *ctl)\n{\n\tif (ctl->allow_fullname)\n\t\tctl->newf.full_name = ask_new_field(ctl, _(\"Name\"), ctl->oldf.full_name);\n\tif (ctl->allow_room)\n\t\tctl->newf.office = ask_new_field(ctl, _(\"Office\"), ctl->oldf.office);\n\tif (ctl->allow_work)\n\t\tctl->newf.office_phone = ask_new_field(ctl, _(\"Office Phone\"), ctl->oldf.office_phone);\n\tif (ctl->allow_home)\n\t\tctl->newf.home_phone = ask_new_field(ctl, _(\"Home Phone\"), ctl->oldf.home_phone);\n\tputchar('\\n');\n}\n\n/*\n *  find_field () --\n *\tfind field value in uninteractive mode; can be new, old, or blank\n */\nstatic char *find_field(char *nf, char *of)\n{\n\tif (nf)\n\t\treturn nf;\n\tif (of)\n\t\treturn of;\n\treturn xstrdup(\"\");\n}\n\n/*\n *  add_missing () --\n *\tadd not supplied field values when in uninteractive mode\n */\nstatic void add_missing(struct chfn_control *ctl)\n{\n\tctl->newf.full_name = find_field(ctl->newf.full_name, ctl->oldf.full_name);\n\tctl->newf.office = find_field(ctl->newf.office, ctl->oldf.office);\n\tctl->newf.office_phone = find_field(ctl->newf.office_phone, ctl->oldf.office_phone);\n\tctl->newf.home_phone = find_field(ctl->newf.home_phone, ctl->oldf.home_phone);\n\tctl->newf.other = find_field(ctl->newf.other, ctl->oldf.other);\n\tprintf(\"\\n\");\n}\n\n/*\n *  save_new_data () --\n *\tsave the given finger info in /etc/passwd.\n *\treturn zero on success.\n */\nstatic int save_new_data(struct chfn_control *ctl)\n{\n\tchar *gecos;\n\tint len;\n\n\t/* create the new gecos string */\n\tlen = xasprintf(&gecos, \"%s,%s,%s,%s,%s\",\n\t\t\tctl->newf.full_name,\n\t\t\tctl->newf.office,\n\t\t\tctl->newf.office_phone,\n\t\t\tctl->newf.home_phone,\n\t\t\tctl->newf.other);\n\n\t/* remove trailing empty fields (but not subfields of ctl->newf.other) */\n\tif (!ctl->newf.other) {\n\t\twhile (len > 0 && gecos[len - 1] == ',')\n\t\t\tlen--;\n\t\tgecos[len] = 0;\n\t}\n\n#ifdef HAVE_LIBUSER\n\tif (set_value_libuser(\"chfn\", ctl->username, ctl->pw->pw_uid,\n\t\t\tLU_GECOS, gecos) < 0) {\n#else /* HAVE_LIBUSER */\n\t/* write the new struct passwd to the passwd file. */\n\tctl->pw->pw_gecos = gecos;\n\tif (setpwnam(ctl->pw) < 0) {\n\t\twarn(\"setpwnam failed\");\n#endif\n\t\tprintf(_\n\t\t       (\"Finger information *NOT* changed.  Try again later.\\n\"));\n\t\treturn -1;\n\t}\n\tfree(gecos);\n\tprintf(_(\"Finger information changed.\\n\"));\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tuid_t uid;\n\tstruct chfn_control ctl = {\n\t\t.interactive = 1\n\t};\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\t/* both for messages and for iscntrl() below */\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tuid = getuid();\n\n\t/* check /etc/login.defs CHFN_RESTRICT */\n\tget_login_defs(&ctl);\n\n\tparse_argv(&ctl, argc, argv);\n\tif (!ctl.username) {\n\t\tctl.pw = getpwuid(uid);\n\t\tif (!ctl.pw)\n\t\t\terrx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),\n\t\t\t     uid);\n\t\tctl.username = ctl.pw->pw_name;\n\t} else {\n\t\tctl.pw = getpwnam(ctl.username);\n\t\tif (!ctl.pw)\n\t\t\terrx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),\n\t\t\t     ctl.username);\n\t}\n\tparse_passwd(&ctl);\n#ifndef HAVE_LIBUSER\n\tif (!(is_local(ctl.username)))\n\t\terrx(EXIT_FAILURE, _(\"can only change local entries\"));\n#endif\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tif (uid == 0) {\n\t\t\tif (checkAccess(ctl.username, PASSWD__CHFN) != 0) {\n\t\t\t\tsecurity_context_t user_context;\n\t\t\t\tif (getprevcon(&user_context) < 0)\n\t\t\t\t\tuser_context = NULL;\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t     _(\"%s is not authorized to change \"\n\t\t\t\t       \"the finger info of %s\"),\n\t\t\t\t     user_context ? : _(\"Unknown user context\"),\n\t\t\t\t     ctl.username);\n\t\t\t}\n\t\t}\n\t\tif (setupDefaultContext(_PATH_PASSWD))\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"can't set default context for %s\"), _PATH_PASSWD);\n\t}\n#endif\n\n#ifdef HAVE_LIBUSER\n\t/* If we're setuid and not really root, disallow the password change. */\n\tif (geteuid() != getuid() && uid != ctl.pw->pw_uid) {\n#else\n\tif (uid != 0 && uid != ctl.pw->pw_uid) {\n#endif\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE, _(\"running UID doesn't match UID of user we're \"\n\t\t      \"altering, change denied\"));\n\t}\n\n\tprintf(_(\"Changing finger information for %s.\\n\"), ctl.username);\n\n#if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)\n\tif (!auth_pam(\"chfn\", uid, ctl.username)) {\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\tif (ctl.interactive)\n\t\task_info(&ctl);\n\n\tadd_missing(&ctl);\n\n\tif (!ctl.changed) {\n\t\tprintf(_(\"Finger information not changed.\\n\"));\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\treturn save_new_data(&ctl) == 0 ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n", "/*\n *   chsh.c -- change your login shell\n *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>\n *   (c) 2012 by Cody Maloney <cmaloney@theoreticalchaos.com>\n *\n *   this program is free software.  you can redistribute it and\n *   modify it under the terms of the gnu general public license.\n *   there is no warranty.\n *\n *   $Author: aebr $\n *   $Revision: 1.19 $\n *   $Date: 1998/06/11 22:30:14 $\n *\n * Updated Thu Oct 12 09:33:15 1995 by faith@cs.unc.edu with security\n *   patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Updated Mon Jul  1 18:46:22 1996 by janl@math.uio.no with security\n *   suggestion from Zefram.  Disallowing users with shells not in /etc/shells\n *   from changing their shell.\n *\n *   1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n *   - added Native Language Support\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"islocal.h\"\n#include \"nls.h\"\n#include \"pathnames.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n\n#include \"ch-common.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n# include <selinux/av_permissions.h>\n# include \"selinux_utils.h\"\n#endif\n\n\n#ifdef HAVE_LIBUSER\n# include <libuser/user.h>\n# include \"libuser.h\"\n#elif CHFN_CHSH_PASSWORD\n# include \"auth.h\"\n#endif\n\nstruct sinfo {\n\tchar *username;\n\tchar *shell;\n};\n\n\nstatic void __attribute__((__noreturn__)) usage (FILE *fp)\n{\n\tfputs(USAGE_HEADER, fp);\n\tfprintf(fp, _(\" %s [options] [<username>]\\n\"), program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\"Change your login shell.\\n\"), fp);\n\n\tfputs(USAGE_OPTIONS, fp);\n\tfputs(_(\" -s, --shell <shell>  specify login shell\\n\"), fp);\n\tfputs(_(\" -l, --list-shells    print list of shells and exit\\n\"), fp);\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\" -u, --help     display this help and exit\\n\"), fp);\n\tfputs(_(\" -v, --version  output version information and exit\\n\"), fp);\n\tfprintf(fp, USAGE_MAN_TAIL(\"chsh(1)\"));\n\texit(fp == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n/*\n *  get_shell_list () -- if the given shell appears in /etc/shells,\n *\treturn true.  if not, return false.\n *\tif the given shell is NULL, /etc/shells is outputted to stdout.\n */\nstatic int get_shell_list(const char *shell_name)\n{\n\tFILE *fp;\n\tint found = 0;\n\tchar *buf = NULL;\n\tsize_t sz = 0;\n\tssize_t len;\n\n\tfp = fopen(_PATH_SHELLS, \"r\");\n\tif (!fp) {\n\t\tif (!shell_name)\n\t\t\twarnx(_(\"No known shells.\"));\n\t\treturn 0;\n\t}\n\twhile ((len = getline(&buf, &sz, fp)) != -1) {\n\t\t/* ignore comments and blank lines */\n\t\tif (*buf == '#' || len < 2)\n\t\t\tcontinue;\n\t\t/* strip the ending newline */\n\t\tif (buf[len - 1] == '\\n')\n\t\t\tbuf[len - 1] = 0;\n\t\t/* check or output the shell */\n\t\tif (shell_name) {\n\t\t\tif (!strcmp(shell_name, buf)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tprintf(\"%s\\n\", buf);\n\t}\n\tfclose(fp);\n\tfree(buf);\n\treturn found;\n}\n\n/*\n *  parse_argv () --\n *\tparse the command line arguments, and fill in \"pinfo\" with any\n *\tinformation from the command line.\n */\nstatic void parse_argv(int argc, char **argv, struct sinfo *pinfo)\n{\n\tstatic const struct option long_options[] = {\n\t\t{\"shell\", required_argument, 0, 's'},\n\t\t{\"list-shells\", no_argument, 0, 'l'},\n\t\t{\"help\", no_argument, 0, 'u'},\n\t\t{\"version\", no_argument, 0, 'v'},\n\t\t{NULL, no_argument, 0, '0'},\n\t};\n\tint c;\n\n\twhile ((c = getopt_long(argc, argv, \"s:luv\", long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'u':\n\t\t\tusage(stdout);\n\t\tcase 'l':\n\t\t\tget_shell_list(NULL);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 's':\n\t\t\tif (!optarg)\n\t\t\t\tusage(stderr);\n\t\t\tpinfo->shell = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t}\n\t}\n\t/* done parsing arguments.  check for a username. */\n\tif (optind < argc) {\n\t\tif (optind + 1 < argc)\n\t\t\tusage(stderr);\n\t\tpinfo->username = argv[optind];\n\t}\n}\n\n/*\n *  ask_new_shell () --\n *\task the user for a shell and return it.\n */\nstatic char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n\tsize_t dummy = 0;\n\tssize_t sz;\n\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"%s [%s]: \", question, oldshell);\n\tsz = getline(&ans, &dummy, stdin);\n\tif (sz == -1)\n\t\treturn NULL;\n\t/* remove the newline at the end of ans. */\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}\n\n/*\n *  check_shell () -- if the shell is completely invalid, print\n *\tan error and exit.\n */\nstatic void check_shell(const char *shell)\n{\n\tif (*shell != '/')\n\t\terrx(EXIT_FAILURE, _(\"shell must be a full path name\"));\n\tif (access(shell, F_OK) < 0)\n\t\terrx(EXIT_FAILURE, _(\"\\\"%s\\\" does not exist\"), shell);\n\tif (access(shell, X_OK) < 0)\n\t\terrx(EXIT_FAILURE, _(\"\\\"%s\\\" is not executable\"), shell);\n\tif (illegal_passwd_chars(shell))\n\t\terrx(EXIT_FAILURE, _(\"%s: has illegal characters\"), shell);\n\tif (!get_shell_list(shell)) {\n#ifdef ONLY_LISTED_SHELLS\n\t\tif (!getuid())\n\t\t\twarnx(_(\"Warning: \\\"%s\\\" is not listed in %s.\"), shell,\n\t\t\t      _PATH_SHELLS);\n\t\telse\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"\\\"%s\\\" is not listed in %s.\\n\"\n\t\t\t       \"Use %s -l to see list.\"), shell, _PATH_SHELLS,\n\t\t\t     program_invocation_short_name);\n#else\n\t\twarnx(_(\"\\\"%s\\\" is not listed in %s.\\n\"\n\t\t\t\"Use %s -l to see list.\"), shell, _PATH_SHELLS,\n\t\t       program_invocation_short_name);\n#endif\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tchar *oldshell;\n\tint nullshell = 0;\n\tconst uid_t uid = getuid();\n\tstruct sinfo info = { 0 };\n\tstruct passwd *pw;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tparse_argv(argc, argv, &info);\n\tif (!info.username) {\n\t\tpw = getpwuid(uid);\n\t\tif (!pw)\n\t\t\terrx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),\n\t\t\t     uid);\n\t} else {\n\t\tpw = getpwnam(info.username);\n\t\tif (!pw)\n\t\t\terrx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),\n\t\t\t     info.username);\n\t}\n\n#ifndef HAVE_LIBUSER\n\tif (!(is_local(pw->pw_name)))\n\t\terrx(EXIT_FAILURE, _(\"can only change local entries\"));\n#endif\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tif (uid == 0) {\n\t\t\tif (checkAccess(pw->pw_name, PASSWD__CHSH) != 0) {\n\t\t\t\tsecurity_context_t user_context;\n\t\t\t\tif (getprevcon(&user_context) < 0)\n\t\t\t\t\tuser_context =\n\t\t\t\t\t    (security_context_t) NULL;\n\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t     _(\"%s is not authorized to change the shell of %s\"),\n\t\t\t\t     user_context ? : _(\"Unknown user context\"),\n\t\t\t\t     pw->pw_name);\n\t\t\t}\n\t\t}\n\t\tif (setupDefaultContext(_PATH_PASSWD) != 0)\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"can't set default context for %s\"), _PATH_PASSWD);\n\t}\n#endif\n\n\toldshell = pw->pw_shell;\n\tif (oldshell == NULL || *oldshell == '\\0') {\n\t\toldshell = _PATH_BSHELL;\t/* default */\n\t\tnullshell = 1;\n\t}\n\n\t/* reality check */\n#ifdef HAVE_LIBUSER\n\t/* If we're setuid and not really root, disallow the password change. */\n\tif (geteuid() != getuid() && uid != pw->pw_uid) {\n#else\n\tif (uid != 0 && uid != pw->pw_uid) {\n#endif\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE,\n\t\t    _(\"running UID doesn't match UID of user we're \"\n\t\t      \"altering, shell change denied\"));\n\t}\n\tif (uid != 0 && !get_shell_list(oldshell)) {\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE, _(\"your shell is not in %s, \"\n\t\t\t\t    \"shell change denied\"), _PATH_SHELLS);\n\t}\n\n\tprintf(_(\"Changing shell for %s.\\n\"), pw->pw_name);\n\n#if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)\n\tif (!auth_pam(\"chsh\", uid, pw->pw_name)) {\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\tif (!info.shell) {\n\t\tinfo.shell = ask_new_shell(_(\"New shell\"), oldshell);\n\t\tif (!info.shell)\n\t\t\treturn EXIT_SUCCESS;\n\t}\n\n\tcheck_shell(info.shell);\n\n\tif (!nullshell && strcmp(oldshell, info.shell) == 0)\n\t\terrx(EXIT_SUCCESS, _(\"Shell not changed.\"));\n\n#ifdef HAVE_LIBUSER\n\tif (set_value_libuser(\"chsh\", pw->pw_name, uid,\n\t    LU_LOGINSHELL, info.shell) < 0)\n\t\terrx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));\n#else\n\tpw->pw_shell = info.shell;\n\tif (setpwnam(pw) < 0)\n\t\terr(EXIT_FAILURE, _(\"setpwnam failed\\n\"\n\t\t\t\"Shell *NOT* changed.  Try again later.\"));\n#endif\n\n\tprintf(_(\"Shell changed.\\n\"));\n\treturn EXIT_SUCCESS;\n}\n", "/*\n *  setpwnam.c -- edit an entry in a password database.\n *\n *  (c) 1994 Salvatore Valente <svalente@mit.edu>\n *  This file is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  Edited 11/10/96 (DD/MM/YY ;-) by Nicolai Langfeldt (janl@math.uio.no)\n *  to read /etc/passwd directly so that passwd, chsh and chfn can work on\n *  machines that run NIS (previously YP).  Changes will not be made to\n *  usernames starting with +.\n *\n *  This file is distributed with no warranty.\n *\n *  Usage:\n *  1) get a struct passwd * from getpwnam().\n *     You should assume a struct passwd has an infinite number of fields, so\n *     you should not try to create one from scratch.\n *  2) edit the fields you want to edit.\n *  3) call setpwnam() with the edited struct passwd.\n *\n *  A _normal user_ program should never directly manipulate etc/passwd but\n *  /use getpwnam() and (family, as well as) setpwnam().\n *\n *  But, setpwnam was made to _edit_ the password file.  For use by chfn,\n *  chsh and passwd.  _I_ _HAVE_ to read and write /etc/passwd directly.  Let\n *  those who say nay be forever silent and think about how getpwnam (and\n *  family) works on a machine running YP.\n *\n *  Added checks for failure of malloc() and removed error reporting to\n *  stderr, this is a library function and should not print on the screen,\n *  but return appropriate error codes.\n *  27-Jan-97  - poe@daimi.aau.dk\n *\n *  Thanks to \"two guys named Ian\".\n *\n *   $Author: poer $\n *   $Revision: 1.13 $\n *   $Date: 1997/06/23 08:26:29 $\n */\n\n#undef DEBUG\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <shadow.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"closestream.h\"\n#include \"setpwnam.h\"\n\nstatic void pw_init(void);\n\n/*\n *  setpwnam () --\n *\ttakes a struct passwd in which every field is filled in and valid.\n *\tIf the given username exists in the passwd file, the entry is\n *\treplaced with the given entry.\n */\nint setpwnam(struct passwd *pwd)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\tchar *atomic_dir = \"/etc\";\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");\n\tif (!pwf)\n\t\tgoto fail;\n\n\tnamelen = strlen(pwd->pw_name);\n\n\tlinebuf = malloc(buflen);\n\tif (!linebuf)\n\t\tgoto fail;\n\n\t/* parse the passwd file */\n\tfound = false;\n\n\t/* Do you wonder why I don't use getpwent? Read comments at top of\n\t * file */\n\twhile (fgets(linebuf, buflen, pwf) != NULL) {\n\t\tcontlen = strlen(linebuf);\n\t\twhile (linebuf[contlen - 1] != '\\n' && !feof(pwf)) {\n\t\t\tchar *tmp;\n\t\t\t/* Extend input buffer if it failed getting the whole line,\n\t\t\t * so now we double the buffer size */\n\t\t\tbuflen *= 2;\n\t\t\ttmp = realloc(linebuf, buflen);\n\t\t\tif (tmp == NULL)\n\t\t\t\tgoto fail;\n\t\t\tlinebuf = tmp;\n\t\t\t/* And fill the rest of the buffer */\n\t\t\tif (fgets(&linebuf[contlen], buflen / 2, pwf) == NULL)\n\t\t\t\tbreak;\n\t\t\tcontlen = strlen(linebuf);\n\t\t\t/* That was a lot of work for nothing. Gimme perl! */\n\t\t}\n\n\t\t/* Is this the username we were sent to change? */\n\t\tif (!found && linebuf[namelen] == ':' &&\n\t\t    !strncmp(linebuf, pwd->pw_name, namelen)) {\n\t\t\t/* Yes! So go forth in the name of the Lord and\n\t\t\t * change it!  */\n\t\t\tif (putpwent(pwd, fp) < 0)\n\t\t\t\tgoto fail;\n\t\t\tfound = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Nothing in particular happened, copy input to output */\n\t\tfputs(linebuf, fp);\n\t}\n\n\t/* xfmkstemp is too restrictive by default for passwd file */\n\tif (fchmod(fileno(fp), 0644) < 0)\n\t\tgoto fail;\n\trc = close_stream(fp);\n\tfp = NULL;\n\tif (rc != 0)\n\t\tgoto fail;\n\n\tfclose(pwf);\t/* I don't think I want to know if this failed */\n\tpwf = NULL;\n\n\tif (!found) {\n\t\terrno = ENOENT;\t/* give me something better */\n\t\tgoto fail;\n\t}\n\n\t/* we don't care if we can't remove the backup file */\n\tunlink(PASSWD_FILE \".OLD\");\n\t/* we don't care if we can't create the backup file */\n\tignore_result(link(PASSWD_FILE, PASSWD_FILE \".OLD\"));\n\t/* we DO care if we can't rename to the passwd file */\n\tif (rename(tmpname, PASSWD_FILE) < 0)\n\t\tgoto fail;\n\t/* finally:  success */\n\tulckpwdf();\n\treturn 0;\n\n fail:\n\tsave_errno = errno;\n\tulckpwdf();\n\tif (fp != NULL)\n\t\tfclose(fp);\n\tif (tmpname != NULL)\n\t\tunlink(tmpname);\n\tfree(tmpname);\n\tif (pwf != NULL)\n\t\tfclose(pwf);\n\tfree(linebuf);\n\terrno = save_errno;\n\treturn -1;\n}\n\n/* Set up the limits so that we're not foiled */\nstatic void pw_init(void)\n{\n\tstruct rlimit rlim;\n\n\t/* Unlimited resource limits. */\n\trlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;\n\tsetrlimit(RLIMIT_CPU, &rlim);\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\tsetrlimit(RLIMIT_DATA, &rlim);\n\tsetrlimit(RLIMIT_RSS, &rlim);\n\n#ifndef DEBUG\n\t/* Don't drop core (not really necessary, but GP's). */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n#endif\n\n\t/* Turn off signals. */\n\tsignal(SIGALRM, SIG_IGN);\n\tsignal(SIGHUP, SIG_IGN);\n\tsignal(SIGINT, SIG_IGN);\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGQUIT, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGTSTP, SIG_IGN);\n\tsignal(SIGTTOU, SIG_IGN);\n\n\t/* Create with exact permissions. */\n\tumask(0);\n}\n", "/*\n *  setpwnam.h --\n *  define several paths\n *\n *  (c) 1994 Martin Schulze <joey@infodrom.north.de>\n *  This file is based on setpwnam.c which is\n *  (c) 1994 Salvatore Valente <svalente@mit.edu>\n *\n *  This file is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n */\n\n#include \"pathnames.h\"\n\n#ifndef DEBUG\n# define PASSWD_FILE\t_PATH_PASSWD\n# define GROUP_FILE\t_PATH_GROUP\n# define SHADOW_FILE\t_PATH_SHADOW_PASSWD\n# define SGROUP_FILE\t_PATH_GSHADOW\n#else\n# define PASSWD_FILE\t\"/tmp/passwd\"\n# define GROUP_FILE\t\"/tmp/group\"\n# define SHADOW_FILE\t\"/tmp/shadow\"\n# define SGROUP_FILE\t\"/tmp/gshadow\"\n#endif\n\nextern int setpwnam (struct passwd *pwd);\n", "/*\n * Copyright (c) 1987 Regents of the University of California.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Updated Thu Oct 12 09:56:55 1995 by faith@cs.unc.edu with security\n * patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Updated Thu Nov  9 21:58:53 1995 by Martin Schulze\n * <joey@finlandia.infodrom.north.de>.  Support for vigr.\n *\n * Martin Schulze's patches adapted to Util-Linux by Nicolai Langfeldt.\n *\n * 1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n * - added Native Language Support\n * Sun Mar 21 1999 - Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - fixed strerr(errno) in gettext calls\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <shadow.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"closestream.h\"\n#include \"nls.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"rpmatch.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n#endif\n\n#define FILENAMELEN 67\n\nenum {\n\tVIPW,\n\tVIGR\n};\nint program;\nchar orig_file[FILENAMELEN];\t/* original file /etc/passwd or /etc/group */\nchar *tmp_file;\t\t\t/* tmp file */\n\nvoid pw_error __P((char *, int, int));\n\nstatic void copyfile(int from, int to)\n{\n\tint nr, nw, off;\n\tchar buf[8 * 1024];\n\n\twhile ((nr = read(from, buf, sizeof(buf))) > 0)\n\t\tfor (off = 0; off < nr; nr -= nw, off += nw)\n\t\t\tif ((nw = write(to, buf + off, nr)) < 0)\n\t\t\t\tpw_error(tmp_file, 1, 1);\n\n\tif (nr < 0)\n\t\tpw_error(orig_file, 1, 1);\n}\n\nstatic void pw_init(void)\n{\n\tstruct rlimit rlim;\n\n\t/* Unlimited resource limits. */\n\trlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;\n\t(void)setrlimit(RLIMIT_CPU, &rlim);\n\t(void)setrlimit(RLIMIT_FSIZE, &rlim);\n\t(void)setrlimit(RLIMIT_STACK, &rlim);\n\t(void)setrlimit(RLIMIT_DATA, &rlim);\n\t(void)setrlimit(RLIMIT_RSS, &rlim);\n\n\t/* Don't drop core (not really necessary, but GP's). */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\t(void)setrlimit(RLIMIT_CORE, &rlim);\n\n\t/* Turn off signals. */\n\t(void)signal(SIGALRM, SIG_IGN);\n\t(void)signal(SIGHUP, SIG_IGN);\n\t(void)signal(SIGINT, SIG_IGN);\n\t(void)signal(SIGPIPE, SIG_IGN);\n\t(void)signal(SIGQUIT, SIG_IGN);\n\t(void)signal(SIGTERM, SIG_IGN);\n\t(void)signal(SIGTSTP, SIG_IGN);\n\t(void)signal(SIGTTOU, SIG_IGN);\n\n\t/* Create with exact permissions. */\n\t(void)umask(0);\n}\n\nstatic FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}\n\nstatic void pw_write(void)\n{\n\tchar tmp[FILENAMELEN + 4];\n\n\tsprintf(tmp, \"%s%s\", orig_file, \".OLD\");\n\tunlink(tmp);\n\n\tif (link(orig_file, tmp))\n\t\twarn(_(\"%s: create a link to %s failed\"), orig_file, tmp);\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tsecurity_context_t passwd_context = NULL;\n\t\tint ret = 0;\n\t\tif (getfilecon(orig_file, &passwd_context) < 0) {\n\t\t\twarnx(_(\"Can't get context for %s\"), orig_file);\n\t\t\tpw_error(orig_file, 1, 1);\n\t\t}\n\t\tret = setfilecon(tmp_file, passwd_context);\n\t\tfreecon(passwd_context);\n\t\tif (ret != 0) {\n\t\t\twarnx(_(\"Can't set context for %s\"), tmp_file);\n\t\t\tpw_error(tmp_file, 1, 1);\n\t\t}\n\t}\n#endif\n\n\tif (rename(tmp_file, orig_file) == -1) {\n\t\tint errsv = errno;\n\t\terrx(EXIT_FAILURE,\n\t\t     (\"cannot write %s: %s (your changes are still in %s)\"),\n\t\t     orig_file, strerror(errsv), tmp_file);\n\t}\n\tunlink(tmp_file);\n\tfree(tmp_file);\n}\n\nstatic void pw_edit(void)\n{\n\tint pstat;\n\tpid_t pid;\n\tchar *p, *editor, *tk;\n\n\teditor = getenv(\"EDITOR\");\n\teditor = xstrdup(editor ? editor : _PATH_VI);\n\n\ttk = strtok(editor, \" \\t\");\n\tif (tk && (p = strrchr(tk, '/')) != NULL)\n\t\t++p;\n\telse\n\t\tp = editor;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\terr(EXIT_FAILURE, _(\"fork failed\"));\n\n\tif (!pid) {\n\t\texeclp(editor, p, tmp_file, NULL);\n\t\t/* Shouldn't get here */\n\t\t_exit(EXIT_FAILURE);\n\t}\n\tfor (;;) {\n\t\tpid = waitpid(pid, &pstat, WUNTRACED);\n\t\tif (WIFSTOPPED(pstat)) {\n\t\t\t/* the editor suspended, so suspend us as well */\n\t\t\tkill(getpid(), SIGSTOP);\n\t\t\tkill(pid, SIGCONT);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pid == -1 || !WIFEXITED(pstat) || WEXITSTATUS(pstat) != 0)\n\t\tpw_error(editor, 1, 1);\n\n\tfree(editor);\n}\n\nvoid __attribute__((__noreturn__))\npw_error(char *name, int err, int eval)\n{\n\tif (err) {\n\t\tif (name)\n\t\t\twarn(\"%s: \", name);\n\t\telse\n\t\t\twarn(NULL);\n\t}\n\twarnx(_(\"%s unchanged\"), orig_file);\n\tunlink(tmp_file);\n\tulckpwdf();\n\texit(eval);\n}\n\nstatic void edit_file(int is_shadow)\n{\n\tstruct stat begin, end;\n\tint passwd_file, ch_ret;\n\tFILE *tmp_fd;\n\n\tpw_init();\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\terr(EXIT_FAILURE, _(\"cannot get lock\"));\n\n\tpasswd_file = open(orig_file, O_RDONLY, 0);\n\tif (passwd_file < 0)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), orig_file);\n\ttmp_fd = pw_tmpfile(passwd_file);\n\n\tif (fstat(fileno(tmp_fd), &begin))\n\t\tpw_error(tmp_file, 1, 1);\n\n\tpw_edit();\n\n\tif (fstat(fileno(tmp_fd), &end))\n\t\tpw_error(tmp_file, 1, 1);\n\t/* Some editors, such as Vim with 'writebackup' mode enabled,\n\t * use \"atomic save\" in which the old file is deleted and a new\n\t * one with the same name created in its place.  */\n\tif (end.st_nlink == 0) {\n\t\tif (close_stream(tmp_fd) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"write error\"));\n\t\ttmp_fd = fopen(tmp_file, \"r\");\n\t\tif (!tmp_file)\n\t\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), tmp_file);\n\t\tif (fstat(fileno(tmp_fd), &end))\n\t\t\tpw_error(tmp_file, 1, 1);\n\t}\n\tif (begin.st_mtime == end.st_mtime) {\n\t\twarnx(_(\"no changes made\"));\n\t\tpw_error((char *)NULL, 0, 0);\n\t}\n\t/* pw_tmpfile() will create the file with mode 600 */\n\tif (!is_shadow)\n\t\tch_ret = fchmod(fileno(tmp_fd), 0644);\n\telse\n\t\tch_ret = fchmod(fileno(tmp_fd), 0400);\n\tif (ch_ret < 0)\n\t\terr(EXIT_FAILURE, \"%s: %s\", _(\"cannot chmod file\"), orig_file);\n\tif (close_stream(tmp_fd) != 0)\n\t\terr(EXIT_FAILURE, _(\"write error\"));\n\tpw_write();\n\tclose(passwd_file);\n\tulckpwdf();\n}\n\nstatic void __attribute__((__noreturn__)) usage(FILE *out)\n{\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, \" %s\\n\", program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Edit the password or group file.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(USAGE_HELP, out);\n\tfputs(USAGE_VERSION, out);\n\tfprintf(out, USAGE_MAN_TAIL(\"vipw(8)\"));\n\texit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\nint main(int argc, char *argv[])\n{\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tif (!strcmp(program_invocation_short_name, \"vigr\")) {\n\t\tprogram = VIGR;\n\t\txstrncpy(orig_file, GROUP_FILE, sizeof(orig_file));\n\t} else {\n\t\tprogram = VIPW;\n\t\txstrncpy(orig_file, PASSWD_FILE, sizeof(orig_file));\n\t}\n\n\tif (1 < argc) {\n\t\tif (!strcmp(argv[1], \"-V\") || !strcmp(argv[1], \"--version\")) {\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t\tif (!strcmp(argv[1], \"-h\") || !strcmp(argv[1], \"--help\"))\n\t\t\tusage(stdout);\n\t\tusage(stderr);\n\t}\n\n\tedit_file(0);\n\n\tif (program == VIGR) {\n\t\tstrncpy(orig_file, SGROUP_FILE, FILENAMELEN - 1);\n\t} else {\n\t\tstrncpy(orig_file, SHADOW_FILE, FILENAMELEN - 1);\n\t}\n\n\tif (access(orig_file, F_OK) == 0) {\n\t\tchar response[80];\n\n\t\tprintf((program == VIGR)\n\t\t       ? _(\"You are using shadow groups on this system.\\n\")\n\t\t       : _(\"You are using shadow passwords on this system.\\n\"));\n\t\t/* TRANSLATORS: this program uses for y and n rpmatch(3),\n\t\t * which means they can be translated. */\n\t\tprintf(_(\"Would you like to edit %s now [y/n]? \"), orig_file);\n\n\t\tif (fgets(response, sizeof(response), stdin)) {\n\t\t\tif (rpmatch(response) == RPMATCH_YES)\n\t\t\t\tedit_file(1);\n\t\t}\n\t}\n\texit(EXIT_SUCCESS);\n}\n"], "fixing_code": ["#ifndef UTIL_LINUX_FILEUTILS\n#define UTIL_LINUX_FILEUTILS\n\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"c.h\"\n\nextern int xmkstemp(char **tmpname, const char *dir, const char *prefix);\n\nstatic inline FILE *xfmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tint fd;\n\tFILE *ret;\n\n\tfd = xmkstemp(tmpname, dir, prefix);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nextern int dup_fd_cloexec(int oldfd, int lowfd);\nextern int get_fd_tabsize(void);\n\nextern int mkdir_p(const char *path, mode_t mode);\nextern char *stripoff_last_component(char *path);\n\n#endif /* UTIL_LINUX_FILEUTILS */\n", "/*\n * Copyright (C) 2012 Sami Kerola <kerolasa@iki.fi>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"pathnames.h\"\n\n/* Create open temporary file in safe way.  Please notice that the\n * file permissions are -rw------- by default. */\nint xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}\n\nint dup_fd_cloexec(int oldfd, int lowfd)\n{\n\tint fd, flags, errno_save;\n\n#ifdef F_DUPFD_CLOEXEC\n\tfd = fcntl(oldfd, F_DUPFD_CLOEXEC, lowfd);\n\tif (fd >= 0)\n\t\treturn fd;\n#endif\n\n\tfd = dup(oldfd);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags < 0)\n\t\tgoto unwind;\n\tif (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0)\n\t\tgoto unwind;\n\n\treturn fd;\n\nunwind:\n\terrno_save = errno;\n\tclose(fd);\n\terrno = errno_save;\n\n\treturn -1;\n}\n\n/*\n * portable getdtablesize()\n */\nint get_fd_tabsize(void)\n{\n\tint m;\n\n#if defined(HAVE_GETDTABLESIZE)\n\tm = getdtablesize();\n#elif defined(HAVE_GETRLIMIT) && defined(RLIMIT_NOFILE)\n\tstruct rlimit rl;\n\n\tgetrlimit(RLIMIT_NOFILE, &rl);\n\tm = rl.rlim_cur;\n#elif defined(HAVE_SYSCONF) && defined(_SC_OPEN_MAX)\n\tm = sysconf(_SC_OPEN_MAX);\n#else\n\tm = OPEN_MAX;\n#endif\n\treturn m;\n}\n\n#ifdef TEST_PROGRAM\nint main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL, \"test\");\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}\n#endif\n\n\nint mkdir_p(const char *path, mode_t mode)\n{\n\tchar *p, *dir;\n\tint rc = 0;\n\n\tif (!path || !*path)\n\t\treturn -EINVAL;\n\n\tdir = p = strdup(path);\n\tif (!dir)\n\t\treturn -ENOMEM;\n\n\tif (*p == '/')\n\t\tp++;\n\n\twhile (p && *p) {\n\t\tchar *e = strchr(p, '/');\n\t\tif (e)\n\t\t\t*e = '\\0';\n\t\tif (*p) {\n\t\t\trc = mkdir(dir, mode);\n\t\t\tif (rc && errno != EEXIST)\n\t\t\t\tbreak;\n\t\t\trc = 0;\n\t\t}\n\t\tif (!e)\n\t\t\tbreak;\n\t\t*e = '/';\n\t\tp = e + 1;\n\t}\n\n\tfree(dir);\n\treturn rc;\n}\n\n/* returns basename and keeps dirname in the @path, if @path is \"/\" (root)\n * then returns empty string */\nchar *stripoff_last_component(char *path)\n{\n\tchar *p = path ? strrchr(path, '/') : NULL;\n\n\tif (!p)\n\t\treturn NULL;\n\t*p = '\\0';\n\treturn p + 1;\n}\n", "/*\n *   chfn.c -- change your finger information\n *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>\n *   (c) 2012 by Cody Maloney <cmaloney@theoreticalchaos.com>\n *\n *   this program is free software.  you can redistribute it and\n *   modify it under the terms of the gnu general public license.\n *   there is no warranty.\n *\n *   $Author: aebr $\n *   $Revision: 1.18 $\n *   $Date: 1998/06/11 22:30:11 $\n *\n * Updated Thu Oct 12 09:19:26 1995 by faith@cs.unc.edu with security\n * patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Hacked by Peter Breitenlohner, peb@mppmu.mpg.de,\n * to remove trailing empty fields.  Oct 5, 96.\n *\n *  1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n *  - added Native Language Support\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"islocal.h\"\n#include \"nls.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"logindefs.h\"\n\n#include \"ch-common.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n# include <selinux/av_permissions.h>\n# include \"selinux_utils.h\"\n#endif\n\n#ifdef HAVE_LIBUSER\n# include <libuser/user.h>\n# include \"libuser.h\"\n#elif CHFN_CHSH_PASSWORD\n# include \"auth.h\"\n#endif\n\nstruct finfo {\n\tchar *full_name;\n\tchar *office;\n\tchar *office_phone;\n\tchar *home_phone;\n\tchar *other;\n};\n\nstruct chfn_control {\n\tstruct passwd *pw;\n\tchar *username;\n\t/*  \"oldf\"  Contains the users original finger information.\n\t *  \"newf\"  Contains the changed finger information, and contains\n\t *          NULL in fields that haven't been changed.\n\t *  In the end, \"newf\" is folded into \"oldf\".  */\n\tstruct finfo oldf, newf;\n\tunsigned int\n\t\tallow_fullname:1,\t/* The login.defs restriction */\n\t\tallow_room:1,\t\t   /* see: man login.defs(5) */\n\t\tallow_work:1,\t\t   /* and look for CHFN_RESTRICT */\n\t\tallow_home:1,\t\t   /* keyword for these four. */\n\t\tchanged:1,\t\t/* is change requested */\n\t\tinteractive:1;\t\t/* whether to prompt for fields or not */\n};\n\n/* we do not accept gecos field sizes longer than MAX_FIELD_SIZE */\n#define MAX_FIELD_SIZE\t\t256\n\nstatic void __attribute__((__noreturn__)) usage(FILE *fp)\n{\n\tfputs(USAGE_HEADER, fp);\n\tfprintf(fp, _(\" %s [options] [<username>]\\n\"), program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\"Change your finger information.\\n\"), fp);\n\n\tfputs(USAGE_OPTIONS, fp);\n\tfputs(_(\" -f, --full-name <full-name>  real name\\n\"), fp);\n\tfputs(_(\" -o, --office <office>        office number\\n\"), fp);\n\tfputs(_(\" -p, --office-phone <phone>   office phone number\\n\"), fp);\n\tfputs(_(\" -h, --home-phone <phone>     home phone number\\n\"), fp);\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\" -u, --help     display this help and exit\\n\"), fp);\n\tfputs(_(\" -v, --version  output version information and exit\\n\"), fp);\n\tfprintf(fp, USAGE_MAN_TAIL(\"chfn(1)\"));\n\texit(fp == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n/*\n *  check_gecos_string () --\n *\tcheck that the given gecos string is legal.  if it's not legal,\n *\toutput \"msg\" followed by a description of the problem, and return (-1).\n */\nstatic int check_gecos_string(const char *msg, char *gecos)\n{\n\tconst size_t len = strlen(gecos);\n\n\tif (MAX_FIELD_SIZE < len) {\n\t\twarnx(_(\"field %s is too long\"), msg);\n\t\treturn -1;\n\t}\n\tif (illegal_passwd_chars(gecos)) {\n\t\twarnx(_(\"%s: has illegal characters\"), gecos);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n *  parse_argv () --\n *\tparse the command line arguments.\n *\treturns true if no information beyond the username was given.\n */\nstatic void parse_argv(struct chfn_control *ctl, int argc, char **argv)\n{\n\tint index, c, status = 0;\n\tstatic const struct option long_options[] = {\n\t\t{\"full-name\", required_argument, 0, 'f'},\n\t\t{\"office\", required_argument, 0, 'o'},\n\t\t{\"office-phone\", required_argument, 0, 'p'},\n\t\t{\"home-phone\", required_argument, 0, 'h'},\n\t\t{\"help\", no_argument, 0, 'u'},\n\t\t{\"version\", no_argument, 0, 'v'},\n\t\t{NULL, no_argument, 0, '0'},\n\t};\n\n\twhile ((c = getopt_long(argc, argv, \"f:r:p:h:o:uv\", long_options,\n\t\t\t\t&index)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'f':\n\t\t\tif (!ctl->allow_fullname)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Name\"));\n\t\t\tctl->newf.full_name = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Name\"), optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tif (!ctl->allow_room)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Office\"));\n\t\t\tctl->newf.office = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Office\"), optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tif (!ctl->allow_work)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Office Phone\"));\n\t\t\tctl->newf.office_phone = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Office Phone\"), optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tif (!ctl->allow_home)\n\t\t\t\terrx(EXIT_FAILURE, _(\"login.defs forbids setting %s\"), _(\"Home Phone\"));\n\t\t\tctl->newf.home_phone = optarg;\n\t\t\tstatus += check_gecos_string(_(\"Home Phone\"), optarg);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'u':\n\t\t\tusage(stdout);\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t}\n\t\tctl->changed = 1;\n\t\tctl->interactive = 0;\n\t}\n\tif (status != 0)\n\t\texit(EXIT_FAILURE);\n\t/* done parsing arguments.  check for a username. */\n\tif (optind < argc) {\n\t\tif (optind + 1 < argc)\n\t\t\tusage(stderr);\n\t\tctl->username = argv[optind];\n\t}\n\treturn;\n}\n\n/*\n *  parse_passwd () --\n *\ttake a struct password and fill in the fields of the struct finfo.\n */\nstatic void parse_passwd(struct chfn_control *ctl)\n{\n\tchar *gecos;\n\n\tif (!ctl->pw)\n\t\treturn;\n\t/* use pw_gecos - we take a copy since PAM destroys the original */\n\tgecos = xstrdup(ctl->pw->pw_gecos);\n\t/* extract known fields */\n\tctl->oldf.full_name = strsep(&gecos, \",\");\n\tctl->oldf.office = strsep(&gecos, \",\");\n\tctl->oldf.office_phone = strsep(&gecos, \",\");\n\tctl->oldf.home_phone = strsep(&gecos, \",\");\n\t/*  extra fields contain site-specific information, and can\n\t *  not be changed by this version of chfn.  */\n\tctl->oldf.other = strsep(&gecos, \",\");\n}\n\n/*\n *  ask_new_field () --\n *\task the user for a given field and check that the string is legal.\n */\nstatic char *ask_new_field(struct chfn_control *ctl, const char *question,\n\t\t\t   char *def_val)\n{\n\tint len;\n\tchar *ans;\n\tchar buf[MAX_FIELD_SIZE + 2];\n\n\tif (!def_val)\n\t\tdef_val = \"\";\n\twhile (true) {\n\t\tprintf(\"%s [%s]: \", question, def_val);\n\t\t__fpurge(stdin);\n\t\tif (fgets(buf, sizeof(buf), stdin) == NULL)\n\t\t\terrx(EXIT_FAILURE, _(\"Aborted.\"));\n\t\tans = buf;\n\t\t/* remove white spaces from string end */\n\t\tltrim_whitespace((unsigned char *) ans);\n\t\tlen = rtrim_whitespace((unsigned char *) ans);\n\t\tif (len == 0)\n\t\t\treturn xstrdup(def_val);\n\t\tif (!strcasecmp(ans, \"none\")) {\n\t\t\tctl->changed = 1;\n\t\t\treturn xstrdup(\"\");\n\t\t}\n\t\tif (check_gecos_string(question, ans) >= 0)\n\t\t\tbreak;\n\t}\n\tctl->changed = 1;\n\treturn xstrdup(ans);\n}\n\n/*\n *  get_login_defs()\n *\tfind /etc/login.defs CHFN_RESTRICT and save restrictions to run time\n */\nstatic void get_login_defs(struct chfn_control *ctl)\n{\n\tconst char *s;\n\tsize_t i;\n\tint broken = 0;\n\n\t/* real root does not have restrictions */\n\tif (geteuid() == getuid() && getuid() == 0) {\n\t\tctl->allow_fullname = ctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\ts = getlogindefs_str(\"CHFN_RESTRICT\", \"\");\n\tif (!strcmp(s, \"yes\")) {\n\t\tctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\tif (!strcmp(s, \"no\")) {\n\t\tctl->allow_fullname = ctl->allow_room = ctl->allow_work = ctl->allow_home = 1;\n\t\treturn;\n\t}\n\tfor (i = 0; s[i]; i++) {\n\t\tswitch (s[i]) {\n\t\tcase 'f':\n\t\t\tctl->allow_fullname = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tctl->allow_room = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tctl->allow_work = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tctl->allow_home = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbroken = 1;\n\t\t}\n\t}\n\tif (broken)\n\t\twarnx(_(\"%s: CHFN_RESTRICT has unexpected value: %s\"), _PATH_LOGINDEFS, s);\n\tif (!ctl->allow_fullname && !ctl->allow_room && !ctl->allow_work && !ctl->allow_home)\n\t\terrx(EXIT_FAILURE, _(\"%s: CHFN_RESTRICT does not allow any changes\"), _PATH_LOGINDEFS);\n\treturn;\n}\n\n/*\n *  ask_info () --\n *\tprompt the user for the finger information and store it.\n */\nstatic void ask_info(struct chfn_control *ctl)\n{\n\tif (ctl->allow_fullname)\n\t\tctl->newf.full_name = ask_new_field(ctl, _(\"Name\"), ctl->oldf.full_name);\n\tif (ctl->allow_room)\n\t\tctl->newf.office = ask_new_field(ctl, _(\"Office\"), ctl->oldf.office);\n\tif (ctl->allow_work)\n\t\tctl->newf.office_phone = ask_new_field(ctl, _(\"Office Phone\"), ctl->oldf.office_phone);\n\tif (ctl->allow_home)\n\t\tctl->newf.home_phone = ask_new_field(ctl, _(\"Home Phone\"), ctl->oldf.home_phone);\n\tputchar('\\n');\n}\n\n/*\n *  find_field () --\n *\tfind field value in uninteractive mode; can be new, old, or blank\n */\nstatic char *find_field(char *nf, char *of)\n{\n\tif (nf)\n\t\treturn nf;\n\tif (of)\n\t\treturn of;\n\treturn xstrdup(\"\");\n}\n\n/*\n *  add_missing () --\n *\tadd not supplied field values when in uninteractive mode\n */\nstatic void add_missing(struct chfn_control *ctl)\n{\n\tctl->newf.full_name = find_field(ctl->newf.full_name, ctl->oldf.full_name);\n\tctl->newf.office = find_field(ctl->newf.office, ctl->oldf.office);\n\tctl->newf.office_phone = find_field(ctl->newf.office_phone, ctl->oldf.office_phone);\n\tctl->newf.home_phone = find_field(ctl->newf.home_phone, ctl->oldf.home_phone);\n\tctl->newf.other = find_field(ctl->newf.other, ctl->oldf.other);\n\tprintf(\"\\n\");\n}\n\n/*\n *  save_new_data () --\n *\tsave the given finger info in /etc/passwd.\n *\treturn zero on success.\n */\nstatic int save_new_data(struct chfn_control *ctl)\n{\n\tchar *gecos;\n\tint len;\n\n\t/* create the new gecos string */\n\tlen = xasprintf(&gecos, \"%s,%s,%s,%s,%s\",\n\t\t\tctl->newf.full_name,\n\t\t\tctl->newf.office,\n\t\t\tctl->newf.office_phone,\n\t\t\tctl->newf.home_phone,\n\t\t\tctl->newf.other);\n\n\t/* remove trailing empty fields (but not subfields of ctl->newf.other) */\n\tif (!ctl->newf.other) {\n\t\twhile (len > 0 && gecos[len - 1] == ',')\n\t\t\tlen--;\n\t\tgecos[len] = 0;\n\t}\n\n#ifdef HAVE_LIBUSER\n\tif (set_value_libuser(\"chfn\", ctl->username, ctl->pw->pw_uid,\n\t\t\tLU_GECOS, gecos) < 0) {\n#else /* HAVE_LIBUSER */\n\t/* write the new struct passwd to the passwd file. */\n\tctl->pw->pw_gecos = gecos;\n\tif (setpwnam(ctl->pw, \".chfn\") < 0) {\n\t\twarn(\"setpwnam failed\");\n#endif\n\t\tprintf(_\n\t\t       (\"Finger information *NOT* changed.  Try again later.\\n\"));\n\t\treturn -1;\n\t}\n\tfree(gecos);\n\tprintf(_(\"Finger information changed.\\n\"));\n\treturn 0;\n}\n\nint main(int argc, char **argv)\n{\n\tuid_t uid;\n\tstruct chfn_control ctl = {\n\t\t.interactive = 1\n\t};\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\t/* both for messages and for iscntrl() below */\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\tuid = getuid();\n\n\t/* check /etc/login.defs CHFN_RESTRICT */\n\tget_login_defs(&ctl);\n\n\tparse_argv(&ctl, argc, argv);\n\tif (!ctl.username) {\n\t\tctl.pw = getpwuid(uid);\n\t\tif (!ctl.pw)\n\t\t\terrx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),\n\t\t\t     uid);\n\t\tctl.username = ctl.pw->pw_name;\n\t} else {\n\t\tctl.pw = getpwnam(ctl.username);\n\t\tif (!ctl.pw)\n\t\t\terrx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),\n\t\t\t     ctl.username);\n\t}\n\tparse_passwd(&ctl);\n#ifndef HAVE_LIBUSER\n\tif (!(is_local(ctl.username)))\n\t\terrx(EXIT_FAILURE, _(\"can only change local entries\"));\n#endif\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tif (uid == 0) {\n\t\t\tif (checkAccess(ctl.username, PASSWD__CHFN) != 0) {\n\t\t\t\tsecurity_context_t user_context;\n\t\t\t\tif (getprevcon(&user_context) < 0)\n\t\t\t\t\tuser_context = NULL;\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t     _(\"%s is not authorized to change \"\n\t\t\t\t       \"the finger info of %s\"),\n\t\t\t\t     user_context ? : _(\"Unknown user context\"),\n\t\t\t\t     ctl.username);\n\t\t\t}\n\t\t}\n\t\tif (setupDefaultContext(_PATH_PASSWD))\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"can't set default context for %s\"), _PATH_PASSWD);\n\t}\n#endif\n\n#ifdef HAVE_LIBUSER\n\t/* If we're setuid and not really root, disallow the password change. */\n\tif (geteuid() != getuid() && uid != ctl.pw->pw_uid) {\n#else\n\tif (uid != 0 && uid != ctl.pw->pw_uid) {\n#endif\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE, _(\"running UID doesn't match UID of user we're \"\n\t\t      \"altering, change denied\"));\n\t}\n\n\tprintf(_(\"Changing finger information for %s.\\n\"), ctl.username);\n\n#if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)\n\tif (!auth_pam(\"chfn\", uid, ctl.username)) {\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\n\tif (ctl.interactive)\n\t\task_info(&ctl);\n\n\tadd_missing(&ctl);\n\n\tif (!ctl.changed) {\n\t\tprintf(_(\"Finger information not changed.\\n\"));\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\treturn save_new_data(&ctl) == 0 ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n", "/*\n *   chsh.c -- change your login shell\n *   (c) 1994 by salvatore valente <svalente@athena.mit.edu>\n *   (c) 2012 by Cody Maloney <cmaloney@theoreticalchaos.com>\n *\n *   this program is free software.  you can redistribute it and\n *   modify it under the terms of the gnu general public license.\n *   there is no warranty.\n *\n *   $Author: aebr $\n *   $Revision: 1.19 $\n *   $Date: 1998/06/11 22:30:14 $\n *\n * Updated Thu Oct 12 09:33:15 1995 by faith@cs.unc.edu with security\n *   patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Updated Mon Jul  1 18:46:22 1996 by janl@math.uio.no with security\n *   suggestion from Zefram.  Disallowing users with shells not in /etc/shells\n *   from changing their shell.\n *\n *   1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n *   - added Native Language Support\n */\n\n#include <ctype.h>\n#include <errno.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"islocal.h\"\n#include \"nls.h\"\n#include \"pathnames.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n\n#include \"ch-common.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n# include <selinux/av_permissions.h>\n# include \"selinux_utils.h\"\n#endif\n\n\n#ifdef HAVE_LIBUSER\n# include <libuser/user.h>\n# include \"libuser.h\"\n#elif CHFN_CHSH_PASSWORD\n# include \"auth.h\"\n#endif\n\nstruct sinfo {\n\tchar *username;\n\tchar *shell;\n};\n\n\nstatic void __attribute__((__noreturn__)) usage (FILE *fp)\n{\n\tfputs(USAGE_HEADER, fp);\n\tfprintf(fp, _(\" %s [options] [<username>]\\n\"), program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\"Change your login shell.\\n\"), fp);\n\n\tfputs(USAGE_OPTIONS, fp);\n\tfputs(_(\" -s, --shell <shell>  specify login shell\\n\"), fp);\n\tfputs(_(\" -l, --list-shells    print list of shells and exit\\n\"), fp);\n\tfputs(USAGE_SEPARATOR, fp);\n\tfputs(_(\" -u, --help     display this help and exit\\n\"), fp);\n\tfputs(_(\" -v, --version  output version information and exit\\n\"), fp);\n\tfprintf(fp, USAGE_MAN_TAIL(\"chsh(1)\"));\n\texit(fp == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\n/*\n *  get_shell_list () -- if the given shell appears in /etc/shells,\n *\treturn true.  if not, return false.\n *\tif the given shell is NULL, /etc/shells is outputted to stdout.\n */\nstatic int get_shell_list(const char *shell_name)\n{\n\tFILE *fp;\n\tint found = 0;\n\tchar *buf = NULL;\n\tsize_t sz = 0;\n\tssize_t len;\n\n\tfp = fopen(_PATH_SHELLS, \"r\");\n\tif (!fp) {\n\t\tif (!shell_name)\n\t\t\twarnx(_(\"No known shells.\"));\n\t\treturn 0;\n\t}\n\twhile ((len = getline(&buf, &sz, fp)) != -1) {\n\t\t/* ignore comments and blank lines */\n\t\tif (*buf == '#' || len < 2)\n\t\t\tcontinue;\n\t\t/* strip the ending newline */\n\t\tif (buf[len - 1] == '\\n')\n\t\t\tbuf[len - 1] = 0;\n\t\t/* check or output the shell */\n\t\tif (shell_name) {\n\t\t\tif (!strcmp(shell_name, buf)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tprintf(\"%s\\n\", buf);\n\t}\n\tfclose(fp);\n\tfree(buf);\n\treturn found;\n}\n\n/*\n *  parse_argv () --\n *\tparse the command line arguments, and fill in \"pinfo\" with any\n *\tinformation from the command line.\n */\nstatic void parse_argv(int argc, char **argv, struct sinfo *pinfo)\n{\n\tstatic const struct option long_options[] = {\n\t\t{\"shell\", required_argument, 0, 's'},\n\t\t{\"list-shells\", no_argument, 0, 'l'},\n\t\t{\"help\", no_argument, 0, 'u'},\n\t\t{\"version\", no_argument, 0, 'v'},\n\t\t{NULL, no_argument, 0, '0'},\n\t};\n\tint c;\n\n\twhile ((c = getopt_long(argc, argv, \"s:luv\", long_options, NULL)) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 'u':\n\t\t\tusage(stdout);\n\t\tcase 'l':\n\t\t\tget_shell_list(NULL);\n\t\t\texit(EXIT_SUCCESS);\n\t\tcase 's':\n\t\t\tif (!optarg)\n\t\t\t\tusage(stderr);\n\t\t\tpinfo->shell = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(stderr);\n\t\t}\n\t}\n\t/* done parsing arguments.  check for a username. */\n\tif (optind < argc) {\n\t\tif (optind + 1 < argc)\n\t\t\tusage(stderr);\n\t\tpinfo->username = argv[optind];\n\t}\n}\n\n/*\n *  ask_new_shell () --\n *\task the user for a shell and return it.\n */\nstatic char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n\tsize_t dummy = 0;\n\tssize_t sz;\n\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"%s [%s]: \", question, oldshell);\n\tsz = getline(&ans, &dummy, stdin);\n\tif (sz == -1)\n\t\treturn NULL;\n\t/* remove the newline at the end of ans. */\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}\n\n/*\n *  check_shell () -- if the shell is completely invalid, print\n *\tan error and exit.\n */\nstatic void check_shell(const char *shell)\n{\n\tif (*shell != '/')\n\t\terrx(EXIT_FAILURE, _(\"shell must be a full path name\"));\n\tif (access(shell, F_OK) < 0)\n\t\terrx(EXIT_FAILURE, _(\"\\\"%s\\\" does not exist\"), shell);\n\tif (access(shell, X_OK) < 0)\n\t\terrx(EXIT_FAILURE, _(\"\\\"%s\\\" is not executable\"), shell);\n\tif (illegal_passwd_chars(shell))\n\t\terrx(EXIT_FAILURE, _(\"%s: has illegal characters\"), shell);\n\tif (!get_shell_list(shell)) {\n#ifdef ONLY_LISTED_SHELLS\n\t\tif (!getuid())\n\t\t\twarnx(_(\"Warning: \\\"%s\\\" is not listed in %s.\"), shell,\n\t\t\t      _PATH_SHELLS);\n\t\telse\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"\\\"%s\\\" is not listed in %s.\\n\"\n\t\t\t       \"Use %s -l to see list.\"), shell, _PATH_SHELLS,\n\t\t\t     program_invocation_short_name);\n#else\n\t\twarnx(_(\"\\\"%s\\\" is not listed in %s.\\n\"\n\t\t\t\"Use %s -l to see list.\"), shell, _PATH_SHELLS,\n\t\t       program_invocation_short_name);\n#endif\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tchar *oldshell;\n\tint nullshell = 0;\n\tconst uid_t uid = getuid();\n\tstruct sinfo info = { 0 };\n\tstruct passwd *pw;\n\n\tsanitize_env();\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tparse_argv(argc, argv, &info);\n\tif (!info.username) {\n\t\tpw = getpwuid(uid);\n\t\tif (!pw)\n\t\t\terrx(EXIT_FAILURE, _(\"you (user %d) don't exist.\"),\n\t\t\t     uid);\n\t} else {\n\t\tpw = getpwnam(info.username);\n\t\tif (!pw)\n\t\t\terrx(EXIT_FAILURE, _(\"user \\\"%s\\\" does not exist.\"),\n\t\t\t     info.username);\n\t}\n\n#ifndef HAVE_LIBUSER\n\tif (!(is_local(pw->pw_name)))\n\t\terrx(EXIT_FAILURE, _(\"can only change local entries\"));\n#endif\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tif (uid == 0) {\n\t\t\tif (checkAccess(pw->pw_name, PASSWD__CHSH) != 0) {\n\t\t\t\tsecurity_context_t user_context;\n\t\t\t\tif (getprevcon(&user_context) < 0)\n\t\t\t\t\tuser_context =\n\t\t\t\t\t    (security_context_t) NULL;\n\n\t\t\t\terrx(EXIT_FAILURE,\n\t\t\t\t     _(\"%s is not authorized to change the shell of %s\"),\n\t\t\t\t     user_context ? : _(\"Unknown user context\"),\n\t\t\t\t     pw->pw_name);\n\t\t\t}\n\t\t}\n\t\tif (setupDefaultContext(_PATH_PASSWD) != 0)\n\t\t\terrx(EXIT_FAILURE,\n\t\t\t     _(\"can't set default context for %s\"), _PATH_PASSWD);\n\t}\n#endif\n\n\toldshell = pw->pw_shell;\n\tif (oldshell == NULL || *oldshell == '\\0') {\n\t\toldshell = _PATH_BSHELL;\t/* default */\n\t\tnullshell = 1;\n\t}\n\n\t/* reality check */\n#ifdef HAVE_LIBUSER\n\t/* If we're setuid and not really root, disallow the password change. */\n\tif (geteuid() != getuid() && uid != pw->pw_uid) {\n#else\n\tif (uid != 0 && uid != pw->pw_uid) {\n#endif\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE,\n\t\t    _(\"running UID doesn't match UID of user we're \"\n\t\t      \"altering, shell change denied\"));\n\t}\n\tif (uid != 0 && !get_shell_list(oldshell)) {\n\t\terrno = EACCES;\n\t\terr(EXIT_FAILURE, _(\"your shell is not in %s, \"\n\t\t\t\t    \"shell change denied\"), _PATH_SHELLS);\n\t}\n\n\tprintf(_(\"Changing shell for %s.\\n\"), pw->pw_name);\n\n#if !defined(HAVE_LIBUSER) && defined(CHFN_CHSH_PASSWORD)\n\tif (!auth_pam(\"chsh\", uid, pw->pw_name)) {\n\t\treturn EXIT_FAILURE;\n\t}\n#endif\n\tif (!info.shell) {\n\t\tinfo.shell = ask_new_shell(_(\"New shell\"), oldshell);\n\t\tif (!info.shell)\n\t\t\treturn EXIT_SUCCESS;\n\t}\n\n\tcheck_shell(info.shell);\n\n\tif (!nullshell && strcmp(oldshell, info.shell) == 0)\n\t\terrx(EXIT_SUCCESS, _(\"Shell not changed.\"));\n\n#ifdef HAVE_LIBUSER\n\tif (set_value_libuser(\"chsh\", pw->pw_name, uid,\n\t    LU_LOGINSHELL, info.shell) < 0)\n\t\terrx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));\n#else\n\tpw->pw_shell = info.shell;\n\tif (setpwnam(pw, \".chsh\") < 0)\n\t\terr(EXIT_FAILURE, _(\"setpwnam failed\\n\"\n\t\t\t\"Shell *NOT* changed.  Try again later.\"));\n#endif\n\n\tprintf(_(\"Shell changed.\\n\"));\n\treturn EXIT_SUCCESS;\n}\n", "/*\n *  setpwnam.c -- edit an entry in a password database.\n *\n *  (c) 1994 Salvatore Valente <svalente@mit.edu>\n *  This file is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  Edited 11/10/96 (DD/MM/YY ;-) by Nicolai Langfeldt (janl@math.uio.no)\n *  to read /etc/passwd directly so that passwd, chsh and chfn can work on\n *  machines that run NIS (previously YP).  Changes will not be made to\n *  usernames starting with +.\n *\n *  This file is distributed with no warranty.\n *\n *  Usage:\n *  1) get a struct passwd * from getpwnam().\n *     You should assume a struct passwd has an infinite number of fields, so\n *     you should not try to create one from scratch.\n *  2) edit the fields you want to edit.\n *  3) call setpwnam() with the edited struct passwd.\n *\n *  A _normal user_ program should never directly manipulate etc/passwd but\n *  /use getpwnam() and (family, as well as) setpwnam().\n *\n *  But, setpwnam was made to _edit_ the password file.  For use by chfn,\n *  chsh and passwd.  _I_ _HAVE_ to read and write /etc/passwd directly.  Let\n *  those who say nay be forever silent and think about how getpwnam (and\n *  family) works on a machine running YP.\n *\n *  Added checks for failure of malloc() and removed error reporting to\n *  stderr, this is a library function and should not print on the screen,\n *  but return appropriate error codes.\n *  27-Jan-97  - poe@daimi.aau.dk\n *\n *  Thanks to \"two guys named Ian\".\n *\n *   $Author: poer $\n *   $Revision: 1.13 $\n *   $Date: 1997/06/23 08:26:29 $\n */\n\n#undef DEBUG\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <shadow.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"closestream.h\"\n#include \"setpwnam.h\"\n\nstatic void pw_init(void);\n\n/*\n *  setpwnam () --\n *\ttakes a struct passwd in which every field is filled in and valid.\n *\tIf the given username exists in the passwd file, the entry is\n *\treplaced with the given entry.\n */\nint setpwnam(struct passwd *pwd, const char *prefix)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, \"/etc\", prefix)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");\n\tif (!pwf)\n\t\tgoto fail;\n\n\tnamelen = strlen(pwd->pw_name);\n\n\tlinebuf = malloc(buflen);\n\tif (!linebuf)\n\t\tgoto fail;\n\n\t/* parse the passwd file */\n\tfound = false;\n\n\t/* Do you wonder why I don't use getpwent? Read comments at top of\n\t * file */\n\twhile (fgets(linebuf, buflen, pwf) != NULL) {\n\t\tcontlen = strlen(linebuf);\n\t\twhile (linebuf[contlen - 1] != '\\n' && !feof(pwf)) {\n\t\t\tchar *tmp;\n\t\t\t/* Extend input buffer if it failed getting the whole line,\n\t\t\t * so now we double the buffer size */\n\t\t\tbuflen *= 2;\n\t\t\ttmp = realloc(linebuf, buflen);\n\t\t\tif (tmp == NULL)\n\t\t\t\tgoto fail;\n\t\t\tlinebuf = tmp;\n\t\t\t/* And fill the rest of the buffer */\n\t\t\tif (fgets(&linebuf[contlen], buflen / 2, pwf) == NULL)\n\t\t\t\tbreak;\n\t\t\tcontlen = strlen(linebuf);\n\t\t\t/* That was a lot of work for nothing. Gimme perl! */\n\t\t}\n\n\t\t/* Is this the username we were sent to change? */\n\t\tif (!found && linebuf[namelen] == ':' &&\n\t\t    !strncmp(linebuf, pwd->pw_name, namelen)) {\n\t\t\t/* Yes! So go forth in the name of the Lord and\n\t\t\t * change it!  */\n\t\t\tif (putpwent(pwd, fp) < 0)\n\t\t\t\tgoto fail;\n\t\t\tfound = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Nothing in particular happened, copy input to output */\n\t\tfputs(linebuf, fp);\n\t}\n\n\t/* xfmkstemp is too restrictive by default for passwd file */\n\tif (fchmod(fileno(fp), 0644) < 0)\n\t\tgoto fail;\n\trc = close_stream(fp);\n\tfp = NULL;\n\tif (rc != 0)\n\t\tgoto fail;\n\n\tfclose(pwf);\t/* I don't think I want to know if this failed */\n\tpwf = NULL;\n\n\tif (!found) {\n\t\terrno = ENOENT;\t/* give me something better */\n\t\tgoto fail;\n\t}\n\n\t/* we don't care if we can't remove the backup file */\n\tunlink(PASSWD_FILE \".OLD\");\n\t/* we don't care if we can't create the backup file */\n\tignore_result(link(PASSWD_FILE, PASSWD_FILE \".OLD\"));\n\t/* we DO care if we can't rename to the passwd file */\n\tif (rename(tmpname, PASSWD_FILE) < 0)\n\t\tgoto fail;\n\t/* finally:  success */\n\tulckpwdf();\n\treturn 0;\n\n fail:\n\tsave_errno = errno;\n\tulckpwdf();\n\tif (fp != NULL)\n\t\tfclose(fp);\n\tif (tmpname != NULL)\n\t\tunlink(tmpname);\n\tfree(tmpname);\n\tif (pwf != NULL)\n\t\tfclose(pwf);\n\tfree(linebuf);\n\terrno = save_errno;\n\treturn -1;\n}\n\n/* Set up the limits so that we're not foiled */\nstatic void pw_init(void)\n{\n\tstruct rlimit rlim;\n\n\t/* Unlimited resource limits. */\n\trlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;\n\tsetrlimit(RLIMIT_CPU, &rlim);\n\tsetrlimit(RLIMIT_FSIZE, &rlim);\n\tsetrlimit(RLIMIT_STACK, &rlim);\n\tsetrlimit(RLIMIT_DATA, &rlim);\n\tsetrlimit(RLIMIT_RSS, &rlim);\n\n#ifndef DEBUG\n\t/* Don't drop core (not really necessary, but GP's). */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tsetrlimit(RLIMIT_CORE, &rlim);\n#endif\n\n\t/* Turn off signals. */\n\tsignal(SIGALRM, SIG_IGN);\n\tsignal(SIGHUP, SIG_IGN);\n\tsignal(SIGINT, SIG_IGN);\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGQUIT, SIG_IGN);\n\tsignal(SIGTERM, SIG_IGN);\n\tsignal(SIGTSTP, SIG_IGN);\n\tsignal(SIGTTOU, SIG_IGN);\n\n\t/* Create with exact permissions. */\n\tumask(0);\n}\n", "/*\n *  setpwnam.h --\n *  define several paths\n *\n *  (c) 1994 Martin Schulze <joey@infodrom.north.de>\n *  This file is based on setpwnam.c which is\n *  (c) 1994 Salvatore Valente <svalente@mit.edu>\n *\n *  This file is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Library General Public License as\n *  published by the Free Software Foundation; either version 2 of the\n *  License, or (at your option) any later version.\n */\n#ifndef UTIL_LINUX_SETPWNAM_H\n#define UTIL_LINUX_SETPWNAM_H\n\n#include \"pathnames.h\"\n\n#ifndef DEBUG\n# define PASSWD_FILE\t_PATH_PASSWD\n# define GROUP_FILE\t_PATH_GROUP\n# define SHADOW_FILE\t_PATH_SHADOW_PASSWD\n# define SGROUP_FILE\t_PATH_GSHADOW\n#else\n# define PASSWD_FILE\t\"/tmp/passwd\"\n# define GROUP_FILE\t\"/tmp/group\"\n# define SHADOW_FILE\t\"/tmp/shadow\"\n# define SGROUP_FILE\t\"/tmp/gshadow\"\n#endif\n\nextern int setpwnam (struct passwd *pwd, const char *prefix);\n\n#endif /* UTIL_LINUX_SETPWNAM_H */\n", "/*\n * Copyright (c) 1987 Regents of the University of California.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Updated Thu Oct 12 09:56:55 1995 by faith@cs.unc.edu with security\n * patches from Zefram <A.Main@dcs.warwick.ac.uk>\n *\n * Updated Thu Nov  9 21:58:53 1995 by Martin Schulze\n * <joey@finlandia.infodrom.north.de>.  Support for vigr.\n *\n * Martin Schulze's patches adapted to Util-Linux by Nicolai Langfeldt.\n *\n * 1999-02-22 Arkadiusz Mi\u015bkiewicz <misiek@pld.ORG.PL>\n * - added Native Language Support\n * Sun Mar 21 1999 - Arnaldo Carvalho de Melo <acme@conectiva.com.br>\n * - fixed strerr(errno) in gettext calls\n */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <paths.h>\n#include <pwd.h>\n#include <shadow.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/file.h>\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#include \"c.h\"\n#include \"fileutils.h\"\n#include \"closestream.h\"\n#include \"nls.h\"\n#include \"setpwnam.h\"\n#include \"strutils.h\"\n#include \"xalloc.h\"\n#include \"rpmatch.h\"\n\n#ifdef HAVE_LIBSELINUX\n# include <selinux/selinux.h>\n#endif\n\n#define FILENAMELEN 67\n\nenum {\n\tVIPW,\n\tVIGR\n};\nint program;\nchar orig_file[FILENAMELEN];\t/* original file /etc/passwd or /etc/group */\nchar *tmp_file;\t\t\t/* tmp file */\n\nvoid pw_error __P((char *, int, int));\n\nstatic void copyfile(int from, int to)\n{\n\tint nr, nw, off;\n\tchar buf[8 * 1024];\n\n\twhile ((nr = read(from, buf, sizeof(buf))) > 0)\n\t\tfor (off = 0; off < nr; nr -= nw, off += nw)\n\t\t\tif ((nw = write(to, buf + off, nr)) < 0)\n\t\t\t\tpw_error(tmp_file, 1, 1);\n\n\tif (nr < 0)\n\t\tpw_error(orig_file, 1, 1);\n}\n\nstatic void pw_init(void)\n{\n\tstruct rlimit rlim;\n\n\t/* Unlimited resource limits. */\n\trlim.rlim_cur = rlim.rlim_max = RLIM_INFINITY;\n\t(void)setrlimit(RLIMIT_CPU, &rlim);\n\t(void)setrlimit(RLIMIT_FSIZE, &rlim);\n\t(void)setrlimit(RLIMIT_STACK, &rlim);\n\t(void)setrlimit(RLIMIT_DATA, &rlim);\n\t(void)setrlimit(RLIMIT_RSS, &rlim);\n\n\t/* Don't drop core (not really necessary, but GP's). */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\t(void)setrlimit(RLIMIT_CORE, &rlim);\n\n\t/* Turn off signals. */\n\t(void)signal(SIGALRM, SIG_IGN);\n\t(void)signal(SIGHUP, SIG_IGN);\n\t(void)signal(SIGINT, SIG_IGN);\n\t(void)signal(SIGPIPE, SIG_IGN);\n\t(void)signal(SIGQUIT, SIG_IGN);\n\t(void)signal(SIGTERM, SIG_IGN);\n\t(void)signal(SIGTSTP, SIG_IGN);\n\t(void)signal(SIGTTOU, SIG_IGN);\n\n\t/* Create with exact permissions. */\n\t(void)umask(0);\n}\n\nstatic FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\n\tif ((fd = xfmkstemp(&tmpname, \"/etc\", \".vipw\")) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}\n\nstatic void pw_write(void)\n{\n\tchar tmp[FILENAMELEN + 4];\n\n\tsprintf(tmp, \"%s%s\", orig_file, \".OLD\");\n\tunlink(tmp);\n\n\tif (link(orig_file, tmp))\n\t\twarn(_(\"%s: create a link to %s failed\"), orig_file, tmp);\n\n#ifdef HAVE_LIBSELINUX\n\tif (is_selinux_enabled() > 0) {\n\t\tsecurity_context_t passwd_context = NULL;\n\t\tint ret = 0;\n\t\tif (getfilecon(orig_file, &passwd_context) < 0) {\n\t\t\twarnx(_(\"Can't get context for %s\"), orig_file);\n\t\t\tpw_error(orig_file, 1, 1);\n\t\t}\n\t\tret = setfilecon(tmp_file, passwd_context);\n\t\tfreecon(passwd_context);\n\t\tif (ret != 0) {\n\t\t\twarnx(_(\"Can't set context for %s\"), tmp_file);\n\t\t\tpw_error(tmp_file, 1, 1);\n\t\t}\n\t}\n#endif\n\n\tif (rename(tmp_file, orig_file) == -1) {\n\t\tint errsv = errno;\n\t\terrx(EXIT_FAILURE,\n\t\t     (\"cannot write %s: %s (your changes are still in %s)\"),\n\t\t     orig_file, strerror(errsv), tmp_file);\n\t}\n\tunlink(tmp_file);\n\tfree(tmp_file);\n}\n\nstatic void pw_edit(void)\n{\n\tint pstat;\n\tpid_t pid;\n\tchar *p, *editor, *tk;\n\n\teditor = getenv(\"EDITOR\");\n\teditor = xstrdup(editor ? editor : _PATH_VI);\n\n\ttk = strtok(editor, \" \\t\");\n\tif (tk && (p = strrchr(tk, '/')) != NULL)\n\t\t++p;\n\telse\n\t\tp = editor;\n\n\tpid = fork();\n\tif (pid < 0)\n\t\terr(EXIT_FAILURE, _(\"fork failed\"));\n\n\tif (!pid) {\n\t\texeclp(editor, p, tmp_file, NULL);\n\t\t/* Shouldn't get here */\n\t\t_exit(EXIT_FAILURE);\n\t}\n\tfor (;;) {\n\t\tpid = waitpid(pid, &pstat, WUNTRACED);\n\t\tif (WIFSTOPPED(pstat)) {\n\t\t\t/* the editor suspended, so suspend us as well */\n\t\t\tkill(getpid(), SIGSTOP);\n\t\t\tkill(pid, SIGCONT);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (pid == -1 || !WIFEXITED(pstat) || WEXITSTATUS(pstat) != 0)\n\t\tpw_error(editor, 1, 1);\n\n\tfree(editor);\n}\n\nvoid __attribute__((__noreturn__))\npw_error(char *name, int err, int eval)\n{\n\tif (err) {\n\t\tif (name)\n\t\t\twarn(\"%s: \", name);\n\t\telse\n\t\t\twarn(NULL);\n\t}\n\twarnx(_(\"%s unchanged\"), orig_file);\n\tunlink(tmp_file);\n\tulckpwdf();\n\texit(eval);\n}\n\nstatic void edit_file(int is_shadow)\n{\n\tstruct stat begin, end;\n\tint passwd_file, ch_ret;\n\tFILE *tmp_fd;\n\n\tpw_init();\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\terr(EXIT_FAILURE, _(\"cannot get lock\"));\n\n\tpasswd_file = open(orig_file, O_RDONLY, 0);\n\tif (passwd_file < 0)\n\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), orig_file);\n\ttmp_fd = pw_tmpfile(passwd_file);\n\n\tif (fstat(fileno(tmp_fd), &begin))\n\t\tpw_error(tmp_file, 1, 1);\n\n\tpw_edit();\n\n\tif (fstat(fileno(tmp_fd), &end))\n\t\tpw_error(tmp_file, 1, 1);\n\t/* Some editors, such as Vim with 'writebackup' mode enabled,\n\t * use \"atomic save\" in which the old file is deleted and a new\n\t * one with the same name created in its place.  */\n\tif (end.st_nlink == 0) {\n\t\tif (close_stream(tmp_fd) != 0)\n\t\t\terr(EXIT_FAILURE, _(\"write error\"));\n\t\ttmp_fd = fopen(tmp_file, \"r\");\n\t\tif (!tmp_file)\n\t\t\terr(EXIT_FAILURE, _(\"cannot open %s\"), tmp_file);\n\t\tif (fstat(fileno(tmp_fd), &end))\n\t\t\tpw_error(tmp_file, 1, 1);\n\t}\n\tif (begin.st_mtime == end.st_mtime) {\n\t\twarnx(_(\"no changes made\"));\n\t\tpw_error((char *)NULL, 0, 0);\n\t}\n\t/* pw_tmpfile() will create the file with mode 600 */\n\tif (!is_shadow)\n\t\tch_ret = fchmod(fileno(tmp_fd), 0644);\n\telse\n\t\tch_ret = fchmod(fileno(tmp_fd), 0400);\n\tif (ch_ret < 0)\n\t\terr(EXIT_FAILURE, \"%s: %s\", _(\"cannot chmod file\"), orig_file);\n\tif (close_stream(tmp_fd) != 0)\n\t\terr(EXIT_FAILURE, _(\"write error\"));\n\tpw_write();\n\tclose(passwd_file);\n\tulckpwdf();\n}\n\nstatic void __attribute__((__noreturn__)) usage(FILE *out)\n{\n\tfputs(USAGE_HEADER, out);\n\tfprintf(out, \" %s\\n\", program_invocation_short_name);\n\n\tfputs(USAGE_SEPARATOR, out);\n\tfputs(_(\"Edit the password or group file.\\n\"), out);\n\n\tfputs(USAGE_OPTIONS, out);\n\tfputs(USAGE_HELP, out);\n\tfputs(USAGE_VERSION, out);\n\tfprintf(out, USAGE_MAN_TAIL(\"vipw(8)\"));\n\texit(out == stderr ? EXIT_FAILURE : EXIT_SUCCESS);\n}\n\nint main(int argc, char *argv[])\n{\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n\tatexit(close_stdout);\n\n\tif (!strcmp(program_invocation_short_name, \"vigr\")) {\n\t\tprogram = VIGR;\n\t\txstrncpy(orig_file, GROUP_FILE, sizeof(orig_file));\n\t} else {\n\t\tprogram = VIPW;\n\t\txstrncpy(orig_file, PASSWD_FILE, sizeof(orig_file));\n\t}\n\n\tif (1 < argc) {\n\t\tif (!strcmp(argv[1], \"-V\") || !strcmp(argv[1], \"--version\")) {\n\t\t\tprintf(UTIL_LINUX_VERSION);\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\t\tif (!strcmp(argv[1], \"-h\") || !strcmp(argv[1], \"--help\"))\n\t\t\tusage(stdout);\n\t\tusage(stderr);\n\t}\n\n\tedit_file(0);\n\n\tif (program == VIGR) {\n\t\tstrncpy(orig_file, SGROUP_FILE, FILENAMELEN - 1);\n\t} else {\n\t\tstrncpy(orig_file, SHADOW_FILE, FILENAMELEN - 1);\n\t}\n\n\tif (access(orig_file, F_OK) == 0) {\n\t\tchar response[80];\n\n\t\tprintf((program == VIGR)\n\t\t       ? _(\"You are using shadow groups on this system.\\n\")\n\t\t       : _(\"You are using shadow passwords on this system.\\n\"));\n\t\t/* TRANSLATORS: this program uses for y and n rpmatch(3),\n\t\t * which means they can be translated. */\n\t\tprintf(_(\"Would you like to edit %s now [y/n]? \"), orig_file);\n\n\t\tif (fgets(response, sizeof(response), stdin)) {\n\t\t\tif (rpmatch(response) == RPMATCH_YES)\n\t\t\t\tedit_file(1);\n\t\t}\n\t}\n\texit(EXIT_SUCCESS);\n}\n"], "filenames": ["include/fileutils.h", "lib/fileutils.c", "login-utils/chfn.c", "login-utils/chsh.c", "login-utils/setpwnam.c", "login-utils/setpwnam.h", "login-utils/vipw.c"], "buggy_code_start_loc": [10, 18, 376, 326, 74, 13, 138], "buggy_code_end_loc": [18, 111, 377, 327, 89, 30, 141], "fixing_code_start_loc": [10, 18, 376, 326, 74, 14, 138], "fixing_code_end_loc": [18, 104, 377, 327, 88, 34, 140], "type": "NVD-CWE-noinfo", "message": "The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.", "other": {"cve": {"id": "CVE-2015-5224", "sourceIdentifier": "secalert@redhat.com", "published": "2017-08-23T15:29:00.207", "lastModified": "2020-09-11T15:20:04.030", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks."}, {"lang": "es", "value": "La funci\u00f3n mkostemp en login-utils en util-linux, al usarse de forma incorrecta, permite que atacantes remotos provoquen una colisi\u00f3n de nombre de archivo y, posiblemente, otros ataques."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.26.2", "matchCriteriaId": "412ADB70-A241-4CD3-8422-259745C5D89D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:kernel:util-linux:2.27:rc1:*:*:*:*:*:*", "matchCriteriaId": "5FA4F6A3-BF6B-4422-BD9F-614F4332B651"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/08/24/3", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/76467", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1256686", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/karelzak/util-linux/commit/bde91c85bdc77975155058276f99d2e0f5eab5a9"}}