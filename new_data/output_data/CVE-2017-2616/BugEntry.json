{"buggy_code": ["/* su for Linux.  Run a shell with substitute user and group IDs.\n   Copyright (C) 1992-2006 Free Software Foundation, Inc.\n   Copyright (C) 2012 SUSE Linux Products GmbH, Nuernberg\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n\n/* Run a shell with the real and effective UID and GID and groups\n   of USER, default `root'.\n\n   The shell run is taken from USER's password entry, /bin/sh if\n   none is specified there.  If the account has a password, su\n   prompts for a password unless run by a user with real UID 0.\n\n   Does not change the current directory.\n   Sets `HOME' and `SHELL' from the password entry for USER, and if\n   USER is not root, sets `USER' and `LOGNAME' to USER.\n   The subshell is not a login shell.\n\n   If one or more ARGs are given, they are passed as additional\n   arguments to the subshell.\n\n   Does not handle /bin/sh or other shells specially\n   (setting argv[0] to \"-su\", passing -c only to certain shells, etc.).\n   I don't see the point in doing that, and it's ugly.\n\n   Based on an implementation by David MacKenzie <djm@gnu.ai.mit.edu>.  */\n\nenum\n{\n  EXIT_CANNOT_INVOKE = 126,\n  EXIT_ENOENT = 127\n};\n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <security/pam_appl.h>\n#ifdef HAVE_SECURITY_PAM_MISC_H\n# include <security/pam_misc.h>\n#elif defined(HAVE_SECURITY_OPENPAM_H)\n# include <security/openpam.h>\n#endif\n#include <signal.h>\n#include <sys/wait.h>\n#include <syslog.h>\n#include <utmpx.h>\n\n#include \"err.h\"\n\n#include <stdbool.h>\n#include \"c.h\"\n#include \"xalloc.h\"\n#include \"nls.h\"\n#include \"pathnames.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"strutils.h\"\n#include \"ttyutils.h\"\n\n/* name of the pam configuration files. separate configs for su and su -  */\n#define PAM_SRVNAME_SU \"su\"\n#define PAM_SRVNAME_SU_L \"su-l\"\n\n#define PAM_SRVNAME_RUNUSER \"runuser\"\n#define PAM_SRVNAME_RUNUSER_L \"runuser-l\"\n\n#define _PATH_LOGINDEFS_SU\t\"/etc/default/su\"\n#define _PATH_LOGINDEFS_RUNUSER \"/etc/default/runuser\"\n\n#define is_pam_failure(_rc)\t((_rc) != PAM_SUCCESS)\n\n#include \"logindefs.h\"\n#include \"su-common.h\"\n\n/* The shell to run if none is given in the user's passwd entry.  */\n#define DEFAULT_SHELL \"/bin/sh\"\n\n/* The user to become if none is specified.  */\n#define DEFAULT_USER \"root\"\n\n#ifndef HAVE_ENVIRON_DECL\nextern char **environ;\n#endif\n\nstatic void run_shell (char const *, char const *, char **, size_t)\n     __attribute__ ((__noreturn__));\n\n/* If true, pass the `-f' option to the subshell.  */\nstatic bool fast_startup;\n\n/* If true, simulate a login instead of just starting a shell.  */\nstatic bool simulate_login;\n\n/* If true, change some environment vars to indicate the user su'd to.  */\nstatic bool change_environment;\n\n/* If true, then don't call setsid() with a command. */\nstatic int same_session = 0;\n\n/* SU_MODE_{RUNUSER,SU} */\nstatic int su_mode;\n\n/* Don't print PAM info messages (Last login, etc.). */\nstatic int suppress_pam_info;\n\nstatic bool _pam_session_opened;\nstatic bool _pam_cred_established;\nstatic sig_atomic_t volatile caught_signal = false;\nstatic pam_handle_t *pamh = NULL;\n\nstatic int restricted = 1;\t/* zero for root user */\n\n\nstatic struct passwd *\ncurrent_getpwuid(void)\n{\n  uid_t ruid;\n\n  /* GNU Hurd implementation has an extension where a process can exist in a\n   * non-conforming environment, and thus be outside the realms of POSIX\n   * process identifiers; on this platform, getuid() fails with a status of\n   * (uid_t)(-1) and sets errno if a program is run from a non-conforming\n   * environment.\n   *\n   * http://austingroupbugs.net/view.php?id=511\n   */\n  errno = 0;\n  ruid = getuid ();\n\n  return errno == 0 ? getpwuid (ruid) : NULL;\n}\n\n/* Log the fact that someone has run su to the user given by PW;\n   if SUCCESSFUL is true, they gave the correct password, etc.  */\n\nstatic void\nlog_syslog(struct passwd const *pw, bool successful)\n{\n  const char *new_user, *old_user, *tty;\n\n  new_user = pw->pw_name;\n  /* The utmp entry (via getlogin) is probably the best way to identify\n     the user, especially if someone su's from a su-shell.  */\n  old_user = getlogin ();\n  if (!old_user)\n    {\n      /* getlogin can fail -- usually due to lack of utmp entry.\n\t Resort to getpwuid.  */\n      struct passwd *pwd = current_getpwuid();\n      old_user = pwd ? pwd->pw_name : \"\";\n    }\n\n  if (get_terminal_name(NULL, &tty, NULL) != 0 || !tty)\n    tty = \"none\";\n\n  openlog (program_invocation_short_name, 0 , LOG_AUTH);\n  syslog (LOG_NOTICE, \"%s(to %s) %s on %s\",\n\t  successful ? \"\" :\n\t  su_mode == RUNUSER_MODE ? \"FAILED RUNUSER \" : \"FAILED SU \",\n\t  new_user, old_user, tty);\n  closelog ();\n}\n\n\n/*\n * Log failed login attempts in _PATH_BTMP if that exists.\n */\nstatic void log_btmp(struct passwd const *pw)\n{\n\tstruct utmpx ut;\n\tstruct timeval tv;\n\tconst char *tty_name, *tty_num;\n\n\tmemset(&ut, 0, sizeof(ut));\n\n\tstrncpy(ut.ut_user,\n\t\tpw && pw->pw_name ? pw->pw_name : \"(unknown)\",\n\t\tsizeof(ut.ut_user));\n\n\tget_terminal_name(NULL, &tty_name, &tty_num);\n\tif (tty_num)\n\t\txstrncpy(ut.ut_id, tty_num, sizeof(ut.ut_id));\n\tif (tty_name)\n\t\txstrncpy(ut.ut_line, tty_name, sizeof(ut.ut_line));\n\n\tgettimeofday(&tv, NULL);\n\tut.ut_tv.tv_sec = tv.tv_sec;\n\tut.ut_tv.tv_usec = tv.tv_usec;\n\tut.ut_type = LOGIN_PROCESS;\t/* XXX doesn't matter */\n\tut.ut_pid = getpid();\n\n\tupdwtmpx(_PATH_BTMP, &ut);\n}\n\n\nstatic int su_pam_conv(int num_msg, const struct pam_message **msg,\n                       struct pam_response **resp, void *appdata_ptr)\n{\n\tif (suppress_pam_info\n\t    && num_msg == 1\n\t    && msg\n\t    && msg[0]->msg_style == PAM_TEXT_INFO)\n\t\treturn PAM_SUCCESS;\n#ifdef HAVE_SECURITY_PAM_MISC_H\n\treturn misc_conv(num_msg, msg, resp, appdata_ptr);\n#elif defined(HAVE_SECURITY_OPENPAM_H)\n\treturn openpam_ttyconv(num_msg, msg, resp, appdata_ptr);\n#endif\n}\n\nstatic struct pam_conv conv =\n{\n\tsu_pam_conv,\n\tNULL\n};\n\nstatic void\ncleanup_pam (int retcode)\n{\n  int saved_errno = errno;\n\n  if (_pam_session_opened)\n    pam_close_session (pamh, 0);\n\n  if (_pam_cred_established)\n    pam_setcred (pamh, PAM_DELETE_CRED | PAM_SILENT);\n\n  pam_end(pamh, retcode);\n\n  errno = saved_errno;\n}\n\n/* Signal handler for parent process.  */\nstatic void\nsu_catch_sig (int sig)\n{\n  caught_signal = sig;\n}\n\n/* Export env variables declared by PAM modules.  */\nstatic void\nexport_pamenv (void)\n{\n  char **env;\n\n  /* This is a copy but don't care to free as we exec later anyways.  */\n  env = pam_getenvlist (pamh);\n  while (env && *env)\n    {\n      if (putenv (*env) != 0)\n\terr (EXIT_FAILURE, NULL);\n      env++;\n    }\n}\n\nstatic void\ncreate_watching_parent (void)\n{\n  pid_t child;\n  sigset_t ourset;\n  struct sigaction oldact[3];\n  int status = 0;\n  int retval;\n\n  retval = pam_open_session (pamh, 0);\n  if (is_pam_failure(retval))\n    {\n      cleanup_pam (retval);\n      errx (EXIT_FAILURE, _(\"cannot open session: %s\"),\n\t     pam_strerror (pamh, retval));\n    }\n  else\n    _pam_session_opened = 1;\n\n  memset(oldact, 0, sizeof(oldact));\n\n  child = fork ();\n  if (child == (pid_t) -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot create child process\"));\n    }\n\n  /* the child proceeds to run the shell */\n  if (child == 0)\n    return;\n\n  /* In the parent watch the child.  */\n\n  /* su without pam support does not have a helper that keeps\n     sitting on any directory so let's go to /.  */\n  if (chdir (\"/\") != 0)\n    warn (_(\"cannot change directory to %s\"), \"/\");\n\n  sigfillset (&ourset);\n  if (sigprocmask (SIG_BLOCK, &ourset, NULL))\n    {\n      warn (_(\"cannot block signals\"));\n      caught_signal = true;\n    }\n  if (!caught_signal)\n    {\n      struct sigaction action;\n      action.sa_handler = su_catch_sig;\n      sigemptyset (&action.sa_mask);\n      action.sa_flags = 0;\n      sigemptyset (&ourset);\n    if (!same_session)\n      {\n        if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))\n          {\n            warn (_(\"cannot set signal handler\"));\n            caught_signal = true;\n          }\n      }\n    if (!caught_signal && (sigaddset(&ourset, SIGTERM)\n                    || sigaddset(&ourset, SIGALRM)\n                    || sigaction(SIGTERM, &action, &oldact[0])\n                    || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {\n\t  warn (_(\"cannot set signal handler\"));\n\t  caught_signal = true;\n\t}\n    if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])\n                                     || sigaction(SIGQUIT, &action, &oldact[2])))\n      {\n        warn (_(\"cannot set signal handler\"));\n        caught_signal = true;\n      }\n    }\n  if (!caught_signal)\n    {\n      pid_t pid;\n      for (;;)\n\t{\n\t  pid = waitpid (child, &status, WUNTRACED);\n\n\t  if (pid != (pid_t)-1 && WIFSTOPPED (status))\n\t    {\n\t      kill (getpid (), SIGSTOP);\n\t      /* once we get here, we must have resumed */\n\t      kill (pid, SIGCONT);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);\n          break;\n        case SIGINT:\n          sigaction(SIGINT, &oldact[1], NULL);\n          break;\n        case SIGQUIT:\n          sigaction(SIGQUIT, &oldact[2], NULL);\n          break;\n        default:\n\t  /* just in case that signal stuff initialization failed and\n\t   * caught_signal = true */\n          caught_signal = SIGKILL;\n          break;\n      }\n      kill(getpid(), caught_signal);\n    }\n  exit (status);\n}\n\nstatic void\nauthenticate (const struct passwd *pw)\n{\n  const struct passwd *lpw = NULL;\n  const char *cp, *srvname = NULL;\n  int retval;\n\n  switch (su_mode) {\n  case SU_MODE:\n    srvname = simulate_login ? PAM_SRVNAME_SU_L : PAM_SRVNAME_SU;\n    break;\n  case RUNUSER_MODE:\n    srvname = simulate_login ? PAM_SRVNAME_RUNUSER_L : PAM_SRVNAME_RUNUSER;\n    break;\n  default:\n    abort();\n    break;\n  }\n\n  retval = pam_start (srvname, pw->pw_name, &conv, &pamh);\n  if (is_pam_failure(retval))\n    goto done;\n\n  if (isatty (0) && (cp = ttyname (0)) != NULL)\n    {\n      const char *tty;\n\n      if (strncmp (cp, \"/dev/\", 5) == 0)\n\ttty = cp + 5;\n      else\n\ttty = cp;\n      retval = pam_set_item (pamh, PAM_TTY, tty);\n      if (is_pam_failure(retval))\n\tgoto done;\n    }\n\n  lpw = current_getpwuid ();\n  if (lpw && lpw->pw_name)\n    {\n      retval = pam_set_item (pamh, PAM_RUSER, (const void *) lpw->pw_name);\n      if (is_pam_failure(retval))\n\tgoto done;\n    }\n\n  if (su_mode == RUNUSER_MODE)\n    {\n      /*\n       * This is the only difference between runuser(1) and su(1). The command\n       * runuser(1) does not required authentication, because user is root.\n       */\n      if (restricted)\n\terrx(EXIT_FAILURE, _(\"may not be used by non-root users\"));\n      return;\n    }\n\n  retval = pam_authenticate (pamh, 0);\n  if (is_pam_failure(retval))\n    goto done;\n\n  retval = pam_acct_mgmt (pamh, 0);\n  if (retval == PAM_NEW_AUTHTOK_REQD)\n    {\n      /* Password has expired.  Offer option to change it.  */\n      retval = pam_chauthtok (pamh, PAM_CHANGE_EXPIRED_AUTHTOK);\n    }\n\ndone:\n\n  log_syslog(pw, !is_pam_failure(retval));\n\n  if (is_pam_failure(retval))\n    {\n      const char *msg;\n\n      log_btmp(pw);\n\n      msg  = pam_strerror(pamh, retval);\n      pam_end(pamh, retval);\n      sleep (getlogindefs_num (\"FAIL_DELAY\", 1));\n      errx (EXIT_FAILURE, \"%s\", msg?msg:_(\"incorrect password\"));\n    }\n}\n\nstatic void\nset_path(const struct passwd* pw)\n{\n  int r;\n  if (pw->pw_uid)\n    r = logindefs_setenv(\"PATH\", \"ENV_PATH\", _PATH_DEFPATH);\n\n  else if ((r = logindefs_setenv(\"PATH\", \"ENV_ROOTPATH\", NULL)) != 0)\n    r = logindefs_setenv(\"PATH\", \"ENV_SUPATH\", _PATH_DEFPATH_ROOT);\n\n  if (r != 0)\n    err (EXIT_FAILURE,  _(\"failed to set the %s environment variable\"), \"PATH\");\n}\n\n/* Update `environ' for the new shell based on PW, with SHELL being\n   the value for the SHELL environment variable.  */\n\nstatic void\nmodify_environment (const struct passwd *pw, const char *shell)\n{\n  if (simulate_login)\n    {\n      /* Leave TERM unchanged.  Set HOME, SHELL, USER, LOGNAME, PATH.\n         Unset all other environment variables.  */\n      char *term = getenv (\"TERM\");\n      if (term)\n\tterm = xstrdup (term);\n      environ = xmalloc ((6 + !!term) * sizeof (char *));\n      environ[0] = NULL;\n      if (term) {\n\txsetenv (\"TERM\", term, 1);\n\tfree(term);\n      }\n      xsetenv (\"HOME\", pw->pw_dir, 1);\n      if (shell)\n\txsetenv (\"SHELL\", shell, 1);\n      xsetenv (\"USER\", pw->pw_name, 1);\n      xsetenv (\"LOGNAME\", pw->pw_name, 1);\n      set_path(pw);\n    }\n  else\n    {\n      /* Set HOME, SHELL, and (if not becoming a superuser)\n\t USER and LOGNAME.  */\n      if (change_environment)\n        {\n          xsetenv (\"HOME\", pw->pw_dir, 1);\n\t  if (shell)\n            xsetenv (\"SHELL\", shell, 1);\n\t  if (getlogindefs_bool (\"ALWAYS_SET_PATH\", 0))\n\t    set_path(pw);\n\n          if (pw->pw_uid)\n            {\n              xsetenv (\"USER\", pw->pw_name, 1);\n              xsetenv (\"LOGNAME\", pw->pw_name, 1);\n            }\n        }\n    }\n\n  export_pamenv ();\n}\n\n/* Become the user and group(s) specified by PW.  */\n\nstatic void\ninit_groups (const struct passwd *pw, gid_t *groups, size_t num_groups)\n{\n  int retval;\n\n  errno = 0;\n\n  if (num_groups)\n    retval = setgroups (num_groups, groups);\n  else\n    retval = initgroups (pw->pw_name, pw->pw_gid);\n\n  if (retval == -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot set groups\"));\n    }\n  endgrent ();\n\n  retval = pam_setcred (pamh, PAM_ESTABLISH_CRED);\n  if (is_pam_failure(retval))\n    errx (EXIT_FAILURE, \"%s\", pam_strerror (pamh, retval));\n  else\n    _pam_cred_established = 1;\n}\n\nstatic void\nchange_identity (const struct passwd *pw)\n{\n  if (setgid (pw->pw_gid))\n    err (EXIT_FAILURE,  _(\"cannot set group id\"));\n  if (setuid (pw->pw_uid))\n    err (EXIT_FAILURE,  _(\"cannot set user id\"));\n}\n\n/* Run SHELL, or DEFAULT_SHELL if SHELL is empty.\n   If COMMAND is nonzero, pass it to the shell with the -c option.\n   Pass ADDITIONAL_ARGS to the shell as more arguments; there\n   are N_ADDITIONAL_ARGS extra arguments.  */\n\nstatic void\nrun_shell (char const *shell, char const *command, char **additional_args,\n\t   size_t n_additional_args)\n{\n  size_t n_args = 1 + fast_startup + 2 * !!command + n_additional_args + 1;\n  char const **args = xcalloc (n_args, sizeof *args);\n  size_t argno = 1;\n\n  if (simulate_login)\n    {\n      char *arg0;\n      char *shell_basename;\n\n      shell_basename = basename (shell);\n      arg0 = xmalloc (strlen (shell_basename) + 2);\n      arg0[0] = '-';\n      strcpy (arg0 + 1, shell_basename);\n      args[0] = arg0;\n    }\n  else\n    args[0] = basename (shell);\n  if (fast_startup)\n    args[argno++] = \"-f\";\n  if (command)\n    {\n      args[argno++] = \"-c\";\n      args[argno++] = command;\n    }\n  memcpy (args + argno, additional_args, n_additional_args * sizeof *args);\n  args[argno + n_additional_args] = NULL;\n  execv (shell, (char **) args);\n\n  {\n    int exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);\n    warn (_(\"failed to execute %s\"), shell);\n    exit (exit_status);\n  }\n}\n\n/* Return true if SHELL is a restricted shell (one not returned by\n   getusershell), else false, meaning it is a standard shell.  */\n\nstatic bool\nrestricted_shell (const char *shell)\n{\n  char *line;\n\n  setusershell ();\n  while ((line = getusershell ()) != NULL)\n    {\n      if (*line != '#' && !strcmp (line, shell))\n\t{\n\t  endusershell ();\n\t  return false;\n\t}\n    }\n  endusershell ();\n  return true;\n}\n\nstatic void __attribute__((__noreturn__))\nusage (int status)\n{\n  if (su_mode == RUNUSER_MODE) {\n    fputs(USAGE_HEADER, stdout);\n    printf (_(\" %s [options] -u <user> [[--] <command>]\\n\"), program_invocation_short_name);\n    printf (_(\" %s [options] [-] [<user> [<argument>...]]\\n\"), program_invocation_short_name);\n    fputs (_(\"\\n\"\n    \"Run <command> with the effective user ID and group ID of <user>.  If -u is\\n\"\n    \"not given, fall back to su(1)-compatible semantics and execute standard shell.\\n\"\n    \"The options -c, -f, -l, and -s are mutually exclusive with -u.\\n\"), stdout);\n\n    fputs(USAGE_OPTIONS, stdout);\n\n    fputs (_(\" -u, --user <user>             username\\n\"), stdout);\n\n  } else {\n    fputs(USAGE_HEADER, stdout);\n    printf (_(\" %s [options] [-] [<user> [<argument>...]]\\n\"), program_invocation_short_name);\n    fputs (_(\"\\n\"\n    \"Change the effective user ID and group ID to that of <user>.\\n\"\n    \"A mere - implies -l.  If <user> is not given, root is assumed.\\n\"), stdout);\n\n    fputs(USAGE_OPTIONS, stdout);\n  }\n\n  fputs (_(\" -m, -p, --preserve-environment  do not reset environment variables\\n\"), stdout);\n  fputs (_(\" -g, --group <group>             specify the primary group\\n\"), stdout);\n  fputs (_(\" -G, --supp-group <group>        specify a supplemental group\\n\\n\"), stdout);\n\n  fputs (_(\" -, -l, --login                  make the shell a login shell\\n\"), stdout);\n  fputs (_(\" -c, --command <command>         pass a single command to the shell with -c\\n\"), stdout);\n  fputs (_(\" --session-command <command>     pass a single command to the shell with -c\\n\"\n           \"                                   and do not create a new session\\n\"), stdout);\n  fputs (_(\" -f, --fast                      pass -f to the shell (for csh or tcsh)\\n\"), stdout);\n  fputs (_(\" -s, --shell <shell>             run <shell> if /etc/shells allows it\\n\"), stdout);\n\n  fputs(USAGE_SEPARATOR, stdout);\n  fputs(USAGE_HELP, stdout);\n  fputs(USAGE_VERSION, stdout);\n  printf(USAGE_MAN_TAIL(su_mode == SU_MODE ? \"su(1)\" : \"runuser(1)\"));\n  exit (status);\n}\n\nstatic\nvoid load_config(void)\n{\n  switch (su_mode) {\n  case SU_MODE:\n    logindefs_load_file(_PATH_LOGINDEFS_SU);\n    break;\n  case RUNUSER_MODE:\n    logindefs_load_file(_PATH_LOGINDEFS_RUNUSER);\n    break;\n  }\n\n  logindefs_load_file(_PATH_LOGINDEFS);\n}\n\n/*\n * Returns 1 if the current user is not root\n */\nstatic int\nevaluate_uid(void)\n{\n  uid_t ruid = getuid();\n  uid_t euid = geteuid();\n\n  /* if we're really root and aren't running setuid */\n  return (uid_t) 0 == ruid && ruid == euid ? 0 : 1;\n}\n\nstatic gid_t\nadd_supp_group(const char *name, gid_t **groups, size_t *ngroups)\n{\n  struct group *gr;\n\n  if (*ngroups >= NGROUPS_MAX)\n    errx(EXIT_FAILURE,\n\tP_(\"specifying more than %d supplemental group is not possible\",\n\t   \"specifying more than %d supplemental groups is not possible\",\n\t     NGROUPS_MAX - 1), NGROUPS_MAX - 1);\n\n  gr = getgrnam(name);\n  if (!gr)\n    errx(EXIT_FAILURE, _(\"group %s does not exist\"), name);\n\n  *groups = xrealloc(*groups, sizeof(gid_t) * (*ngroups + 1));\n  (*groups)[*ngroups] = gr->gr_gid;\n  (*ngroups)++;\n\n  return gr->gr_gid;\n}\n\nint\nsu_main (int argc, char **argv, int mode)\n{\n  int optc;\n  const char *new_user = DEFAULT_USER, *runuser_user = NULL;\n  char *command = NULL;\n  int request_same_session = 0;\n  char *shell = NULL;\n  struct passwd *pw;\n  struct passwd pw_copy;\n\n  gid_t *groups = NULL;\n  size_t ngroups = 0;\n  bool use_supp = false;\n  bool use_gid = false;\n  gid_t gid = 0;\n\n  static const struct option longopts[] = {\n    {\"command\", required_argument, NULL, 'c'},\n    {\"session-command\", required_argument, NULL, 'C'},\n    {\"fast\", no_argument, NULL, 'f'},\n    {\"login\", no_argument, NULL, 'l'},\n    {\"preserve-environment\", no_argument, NULL, 'p'},\n    {\"shell\", required_argument, NULL, 's'},\n    {\"group\", required_argument, NULL, 'g'},\n    {\"supp-group\", required_argument, NULL, 'G'},\n    {\"user\", required_argument, NULL, 'u'},\t\t/* runuser only */\n    {\"help\", no_argument, 0, 'h'},\n    {\"version\", no_argument, 0, 'V'},\n    {NULL, 0, NULL, 0}\n  };\n\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  atexit(close_stdout);\n\n  su_mode = mode;\n  fast_startup = false;\n  simulate_login = false;\n  change_environment = true;\n\n  while ((optc = getopt_long (argc, argv, \"c:fg:G:lmps:u:hV\", longopts, NULL)) != -1)\n    {\n      switch (optc)\n\t{\n\tcase 'c':\n\t  command = optarg;\n\t  break;\n\n        case 'C':\n          command = optarg;\n          request_same_session = 1;\n          break;\n\n\tcase 'f':\n\t  fast_startup = true;\n\t  break;\n\n\tcase 'g':\n\t  use_gid = true;\n\t  gid = add_supp_group(optarg, &groups, &ngroups);\n\t  break;\n\n\tcase 'G':\n\t  use_supp = true;\n\t  add_supp_group(optarg, &groups, &ngroups);\n\t  break;\n\n\tcase 'l':\n\t  simulate_login = true;\n\t  break;\n\n\tcase 'm':\n\tcase 'p':\n\t  change_environment = false;\n\t  break;\n\n\tcase 's':\n\t  shell = optarg;\n\t  break;\n\n\tcase 'u':\n\t  if (su_mode != RUNUSER_MODE)\n\t    usage (EXIT_FAILURE);\n\t  runuser_user = optarg;\n\t  break;\n\n\tcase 'h':\n\t  usage(0);\n\n\tcase 'V':\n\t  printf(UTIL_LINUX_VERSION);\n\t  exit(EXIT_SUCCESS);\n\n\tdefault:\n\t  errtryhelp(EXIT_FAILURE);\n\t}\n    }\n\n  restricted = evaluate_uid ();\n\n  if (optind < argc && !strcmp (argv[optind], \"-\"))\n    {\n      simulate_login = true;\n      ++optind;\n    }\n\n  if (simulate_login && !change_environment) {\n    warnx(_(\"ignoring --preserve-environment, it's mutually exclusive with --login\"));\n    change_environment = true;\n  }\n\n  switch (su_mode) {\n  case RUNUSER_MODE:\n    if (runuser_user) {\n      /* runuser -u <user> <command> */\n      new_user = runuser_user;\n      if (shell || fast_startup || command || simulate_login) {\n        errx(EXIT_FAILURE,\n\t   _(\"options --{shell,fast,command,session-command,login} and \"\n\t     \"--user are mutually exclusive\"));\n      }\n      if (optind == argc)\n        errx(EXIT_FAILURE, _(\"no command was specified\"));\n\n      break;\n    }\n    /* fallthrough if -u <user> is not specified, then follow\n     * traditional su(1) behavior\n     */\n  case SU_MODE:\n    if (optind < argc)\n      new_user = argv[optind++];\n    break;\n  }\n\n  if ((use_supp || use_gid) && restricted)\n    errx(EXIT_FAILURE, _(\"only root can specify alternative groups\"));\n\n  logindefs_load_defaults = load_config;\n\n  pw = getpwnam (new_user);\n  if (! (pw && pw->pw_name && pw->pw_name[0] && pw->pw_dir && pw->pw_dir[0]\n\t && pw->pw_passwd))\n    errx (EXIT_FAILURE, _(\"user %s does not exist\"), new_user);\n\n  /* Make a copy of the password information and point pw at the local\n     copy instead.  Otherwise, some systems (e.g. Linux) would clobber\n     the static data through the getlogin call from log_su.\n     Also, make sure pw->pw_shell is a nonempty string.\n     It may be NULL when NEW_USER is a username that is retrieved via NIS (YP),\n     but that doesn't have a default shell listed.  */\n  pw_copy = *pw;\n  pw = &pw_copy;\n  pw->pw_name = xstrdup (pw->pw_name);\n  pw->pw_passwd = xstrdup (pw->pw_passwd);\n  pw->pw_dir = xstrdup (pw->pw_dir);\n  pw->pw_shell = xstrdup (pw->pw_shell && pw->pw_shell[0]\n\t\t\t  ? pw->pw_shell\n\t\t\t  : DEFAULT_SHELL);\n  endpwent ();\n\n  if (use_supp && !use_gid)\n    pw->pw_gid = groups[0];\n  else if (use_gid)\n    pw->pw_gid = gid;\n\n  authenticate (pw);\n\n  if (request_same_session || !command || !pw->pw_uid)\n    same_session = 1;\n\n  /* initialize shell variable only if \"-u <user>\" not specified */\n  if (runuser_user) {\n    shell = NULL;\n  } else {\n    if (!shell && !change_environment)\n      shell = getenv (\"SHELL\");\n    if (shell && getuid () != 0 && restricted_shell (pw->pw_shell))\n      {\n\t/* The user being su'd to has a nonstandard shell, and so is\n\t   probably a uucp account or has restricted access.  Don't\n\t   compromise the account by allowing access with a standard\n\t   shell.  */\n\twarnx (_(\"using restricted shell %s\"), pw->pw_shell);\n\tshell = NULL;\n      }\n    shell = xstrdup (shell ? shell : pw->pw_shell);\n  }\n\n  init_groups (pw, groups, ngroups);\n\n  if (!simulate_login || command)\n    suppress_pam_info = 1;\t\t/* don't print PAM info messages */\n\n  create_watching_parent ();\n  /* Now we're in the child.  */\n\n  change_identity (pw);\n  if (!same_session)\n    setsid ();\n\n  /* Set environment after pam_open_session, which may put KRB5CCNAME\n     into the pam_env, etc.  */\n\n  modify_environment (pw, shell);\n\n  if (simulate_login && chdir (pw->pw_dir) != 0)\n    warn (_(\"warning: cannot change directory to %s\"), pw->pw_dir);\n\n  if (shell)\n    run_shell (shell, command, argv + optind, max (0, argc - optind));\n  else {\n    execvp(argv[optind], &argv[optind]);\n    err(EXIT_FAILURE, _(\"failed to execute %s\"), argv[optind]);\n  }\n}\n\n// vim: sw=2 cinoptions=>4,n-2,{2,^-2,\\:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1\n"], "fixing_code": ["/* su for Linux.  Run a shell with substitute user and group IDs.\n   Copyright (C) 1992-2006 Free Software Foundation, Inc.\n   Copyright (C) 2012 SUSE Linux Products GmbH, Nuernberg\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 2, or (at your option)\n   any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software Foundation,\n   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */\n\n/* Run a shell with the real and effective UID and GID and groups\n   of USER, default `root'.\n\n   The shell run is taken from USER's password entry, /bin/sh if\n   none is specified there.  If the account has a password, su\n   prompts for a password unless run by a user with real UID 0.\n\n   Does not change the current directory.\n   Sets `HOME' and `SHELL' from the password entry for USER, and if\n   USER is not root, sets `USER' and `LOGNAME' to USER.\n   The subshell is not a login shell.\n\n   If one or more ARGs are given, they are passed as additional\n   arguments to the subshell.\n\n   Does not handle /bin/sh or other shells specially\n   (setting argv[0] to \"-su\", passing -c only to certain shells, etc.).\n   I don't see the point in doing that, and it's ugly.\n\n   Based on an implementation by David MacKenzie <djm@gnu.ai.mit.edu>.  */\n\nenum\n{\n  EXIT_CANNOT_INVOKE = 126,\n  EXIT_ENOENT = 127\n};\n\n#include <config.h>\n#include <stdio.h>\n#include <getopt.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <security/pam_appl.h>\n#ifdef HAVE_SECURITY_PAM_MISC_H\n# include <security/pam_misc.h>\n#elif defined(HAVE_SECURITY_OPENPAM_H)\n# include <security/openpam.h>\n#endif\n#include <signal.h>\n#include <sys/wait.h>\n#include <syslog.h>\n#include <utmpx.h>\n\n#include \"err.h\"\n\n#include <stdbool.h>\n#include \"c.h\"\n#include \"xalloc.h\"\n#include \"nls.h\"\n#include \"pathnames.h\"\n#include \"env.h\"\n#include \"closestream.h\"\n#include \"strutils.h\"\n#include \"ttyutils.h\"\n\n/* name of the pam configuration files. separate configs for su and su -  */\n#define PAM_SRVNAME_SU \"su\"\n#define PAM_SRVNAME_SU_L \"su-l\"\n\n#define PAM_SRVNAME_RUNUSER \"runuser\"\n#define PAM_SRVNAME_RUNUSER_L \"runuser-l\"\n\n#define _PATH_LOGINDEFS_SU\t\"/etc/default/su\"\n#define _PATH_LOGINDEFS_RUNUSER \"/etc/default/runuser\"\n\n#define is_pam_failure(_rc)\t((_rc) != PAM_SUCCESS)\n\n#include \"logindefs.h\"\n#include \"su-common.h\"\n\n/* The shell to run if none is given in the user's passwd entry.  */\n#define DEFAULT_SHELL \"/bin/sh\"\n\n/* The user to become if none is specified.  */\n#define DEFAULT_USER \"root\"\n\n#ifndef HAVE_ENVIRON_DECL\nextern char **environ;\n#endif\n\nstatic void run_shell (char const *, char const *, char **, size_t)\n     __attribute__ ((__noreturn__));\n\n/* If true, pass the `-f' option to the subshell.  */\nstatic bool fast_startup;\n\n/* If true, simulate a login instead of just starting a shell.  */\nstatic bool simulate_login;\n\n/* If true, change some environment vars to indicate the user su'd to.  */\nstatic bool change_environment;\n\n/* If true, then don't call setsid() with a command. */\nstatic int same_session = 0;\n\n/* SU_MODE_{RUNUSER,SU} */\nstatic int su_mode;\n\n/* Don't print PAM info messages (Last login, etc.). */\nstatic int suppress_pam_info;\n\nstatic bool _pam_session_opened;\nstatic bool _pam_cred_established;\nstatic sig_atomic_t volatile caught_signal = false;\nstatic pam_handle_t *pamh = NULL;\n\nstatic int restricted = 1;\t/* zero for root user */\n\n\nstatic struct passwd *\ncurrent_getpwuid(void)\n{\n  uid_t ruid;\n\n  /* GNU Hurd implementation has an extension where a process can exist in a\n   * non-conforming environment, and thus be outside the realms of POSIX\n   * process identifiers; on this platform, getuid() fails with a status of\n   * (uid_t)(-1) and sets errno if a program is run from a non-conforming\n   * environment.\n   *\n   * http://austingroupbugs.net/view.php?id=511\n   */\n  errno = 0;\n  ruid = getuid ();\n\n  return errno == 0 ? getpwuid (ruid) : NULL;\n}\n\n/* Log the fact that someone has run su to the user given by PW;\n   if SUCCESSFUL is true, they gave the correct password, etc.  */\n\nstatic void\nlog_syslog(struct passwd const *pw, bool successful)\n{\n  const char *new_user, *old_user, *tty;\n\n  new_user = pw->pw_name;\n  /* The utmp entry (via getlogin) is probably the best way to identify\n     the user, especially if someone su's from a su-shell.  */\n  old_user = getlogin ();\n  if (!old_user)\n    {\n      /* getlogin can fail -- usually due to lack of utmp entry.\n\t Resort to getpwuid.  */\n      struct passwd *pwd = current_getpwuid();\n      old_user = pwd ? pwd->pw_name : \"\";\n    }\n\n  if (get_terminal_name(NULL, &tty, NULL) != 0 || !tty)\n    tty = \"none\";\n\n  openlog (program_invocation_short_name, 0 , LOG_AUTH);\n  syslog (LOG_NOTICE, \"%s(to %s) %s on %s\",\n\t  successful ? \"\" :\n\t  su_mode == RUNUSER_MODE ? \"FAILED RUNUSER \" : \"FAILED SU \",\n\t  new_user, old_user, tty);\n  closelog ();\n}\n\n\n/*\n * Log failed login attempts in _PATH_BTMP if that exists.\n */\nstatic void log_btmp(struct passwd const *pw)\n{\n\tstruct utmpx ut;\n\tstruct timeval tv;\n\tconst char *tty_name, *tty_num;\n\n\tmemset(&ut, 0, sizeof(ut));\n\n\tstrncpy(ut.ut_user,\n\t\tpw && pw->pw_name ? pw->pw_name : \"(unknown)\",\n\t\tsizeof(ut.ut_user));\n\n\tget_terminal_name(NULL, &tty_name, &tty_num);\n\tif (tty_num)\n\t\txstrncpy(ut.ut_id, tty_num, sizeof(ut.ut_id));\n\tif (tty_name)\n\t\txstrncpy(ut.ut_line, tty_name, sizeof(ut.ut_line));\n\n\tgettimeofday(&tv, NULL);\n\tut.ut_tv.tv_sec = tv.tv_sec;\n\tut.ut_tv.tv_usec = tv.tv_usec;\n\tut.ut_type = LOGIN_PROCESS;\t/* XXX doesn't matter */\n\tut.ut_pid = getpid();\n\n\tupdwtmpx(_PATH_BTMP, &ut);\n}\n\n\nstatic int su_pam_conv(int num_msg, const struct pam_message **msg,\n                       struct pam_response **resp, void *appdata_ptr)\n{\n\tif (suppress_pam_info\n\t    && num_msg == 1\n\t    && msg\n\t    && msg[0]->msg_style == PAM_TEXT_INFO)\n\t\treturn PAM_SUCCESS;\n#ifdef HAVE_SECURITY_PAM_MISC_H\n\treturn misc_conv(num_msg, msg, resp, appdata_ptr);\n#elif defined(HAVE_SECURITY_OPENPAM_H)\n\treturn openpam_ttyconv(num_msg, msg, resp, appdata_ptr);\n#endif\n}\n\nstatic struct pam_conv conv =\n{\n\tsu_pam_conv,\n\tNULL\n};\n\nstatic void\ncleanup_pam (int retcode)\n{\n  int saved_errno = errno;\n\n  if (_pam_session_opened)\n    pam_close_session (pamh, 0);\n\n  if (_pam_cred_established)\n    pam_setcred (pamh, PAM_DELETE_CRED | PAM_SILENT);\n\n  pam_end(pamh, retcode);\n\n  errno = saved_errno;\n}\n\n/* Signal handler for parent process.  */\nstatic void\nsu_catch_sig (int sig)\n{\n  caught_signal = sig;\n}\n\n/* Export env variables declared by PAM modules.  */\nstatic void\nexport_pamenv (void)\n{\n  char **env;\n\n  /* This is a copy but don't care to free as we exec later anyways.  */\n  env = pam_getenvlist (pamh);\n  while (env && *env)\n    {\n      if (putenv (*env) != 0)\n\terr (EXIT_FAILURE, NULL);\n      env++;\n    }\n}\n\nstatic void\ncreate_watching_parent (void)\n{\n  pid_t child;\n  sigset_t ourset;\n  struct sigaction oldact[3];\n  int status = 0;\n  int retval;\n\n  retval = pam_open_session (pamh, 0);\n  if (is_pam_failure(retval))\n    {\n      cleanup_pam (retval);\n      errx (EXIT_FAILURE, _(\"cannot open session: %s\"),\n\t     pam_strerror (pamh, retval));\n    }\n  else\n    _pam_session_opened = 1;\n\n  memset(oldact, 0, sizeof(oldact));\n\n  child = fork ();\n  if (child == (pid_t) -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot create child process\"));\n    }\n\n  /* the child proceeds to run the shell */\n  if (child == 0)\n    return;\n\n  /* In the parent watch the child.  */\n\n  /* su without pam support does not have a helper that keeps\n     sitting on any directory so let's go to /.  */\n  if (chdir (\"/\") != 0)\n    warn (_(\"cannot change directory to %s\"), \"/\");\n\n  sigfillset (&ourset);\n  if (sigprocmask (SIG_BLOCK, &ourset, NULL))\n    {\n      warn (_(\"cannot block signals\"));\n      caught_signal = true;\n    }\n  if (!caught_signal)\n    {\n      struct sigaction action;\n      action.sa_handler = su_catch_sig;\n      sigemptyset (&action.sa_mask);\n      action.sa_flags = 0;\n      sigemptyset (&ourset);\n    if (!same_session)\n      {\n        if (sigaddset(&ourset, SIGINT) || sigaddset(&ourset, SIGQUIT))\n          {\n            warn (_(\"cannot set signal handler\"));\n            caught_signal = true;\n          }\n      }\n    if (!caught_signal && (sigaddset(&ourset, SIGTERM)\n                    || sigaddset(&ourset, SIGALRM)\n                    || sigaction(SIGTERM, &action, &oldact[0])\n                    || sigprocmask(SIG_UNBLOCK, &ourset, NULL))) {\n\t  warn (_(\"cannot set signal handler\"));\n\t  caught_signal = true;\n\t}\n    if (!caught_signal && !same_session && (sigaction(SIGINT, &action, &oldact[1])\n                                     || sigaction(SIGQUIT, &action, &oldact[2])))\n      {\n        warn (_(\"cannot set signal handler\"));\n        caught_signal = true;\n      }\n    }\n  if (!caught_signal)\n    {\n      pid_t pid;\n      for (;;)\n\t{\n\t  pid = waitpid (child, &status, WUNTRACED);\n\n\t  if (pid != (pid_t)-1 && WIFSTOPPED (status))\n\t    {\n\t      kill (getpid (), SIGSTOP);\n\t      /* once we get here, we must have resumed */\n\t      kill (pid, SIGCONT);\n\t    }\n\t  else\n\t    break;\n\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n\n\t  /* child is gone, don't use the PID anymore */\n\t  child = (pid_t) -1;\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal && child != (pid_t)-1)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      if (child != (pid_t)-1)\n\t{\n\t  sleep (2);\n\t  kill (child, SIGKILL);\n\t  fprintf (stderr, _(\" ...killed.\\n\"));\n\t}\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);\n          break;\n        case SIGINT:\n          sigaction(SIGINT, &oldact[1], NULL);\n          break;\n        case SIGQUIT:\n          sigaction(SIGQUIT, &oldact[2], NULL);\n          break;\n        default:\n\t  /* just in case that signal stuff initialization failed and\n\t   * caught_signal = true */\n          caught_signal = SIGKILL;\n          break;\n      }\n      kill(getpid(), caught_signal);\n    }\n  exit (status);\n}\n\nstatic void\nauthenticate (const struct passwd *pw)\n{\n  const struct passwd *lpw = NULL;\n  const char *cp, *srvname = NULL;\n  int retval;\n\n  switch (su_mode) {\n  case SU_MODE:\n    srvname = simulate_login ? PAM_SRVNAME_SU_L : PAM_SRVNAME_SU;\n    break;\n  case RUNUSER_MODE:\n    srvname = simulate_login ? PAM_SRVNAME_RUNUSER_L : PAM_SRVNAME_RUNUSER;\n    break;\n  default:\n    abort();\n    break;\n  }\n\n  retval = pam_start (srvname, pw->pw_name, &conv, &pamh);\n  if (is_pam_failure(retval))\n    goto done;\n\n  if (isatty (0) && (cp = ttyname (0)) != NULL)\n    {\n      const char *tty;\n\n      if (strncmp (cp, \"/dev/\", 5) == 0)\n\ttty = cp + 5;\n      else\n\ttty = cp;\n      retval = pam_set_item (pamh, PAM_TTY, tty);\n      if (is_pam_failure(retval))\n\tgoto done;\n    }\n\n  lpw = current_getpwuid ();\n  if (lpw && lpw->pw_name)\n    {\n      retval = pam_set_item (pamh, PAM_RUSER, (const void *) lpw->pw_name);\n      if (is_pam_failure(retval))\n\tgoto done;\n    }\n\n  if (su_mode == RUNUSER_MODE)\n    {\n      /*\n       * This is the only difference between runuser(1) and su(1). The command\n       * runuser(1) does not required authentication, because user is root.\n       */\n      if (restricted)\n\terrx(EXIT_FAILURE, _(\"may not be used by non-root users\"));\n      return;\n    }\n\n  retval = pam_authenticate (pamh, 0);\n  if (is_pam_failure(retval))\n    goto done;\n\n  retval = pam_acct_mgmt (pamh, 0);\n  if (retval == PAM_NEW_AUTHTOK_REQD)\n    {\n      /* Password has expired.  Offer option to change it.  */\n      retval = pam_chauthtok (pamh, PAM_CHANGE_EXPIRED_AUTHTOK);\n    }\n\ndone:\n\n  log_syslog(pw, !is_pam_failure(retval));\n\n  if (is_pam_failure(retval))\n    {\n      const char *msg;\n\n      log_btmp(pw);\n\n      msg  = pam_strerror(pamh, retval);\n      pam_end(pamh, retval);\n      sleep (getlogindefs_num (\"FAIL_DELAY\", 1));\n      errx (EXIT_FAILURE, \"%s\", msg?msg:_(\"incorrect password\"));\n    }\n}\n\nstatic void\nset_path(const struct passwd* pw)\n{\n  int r;\n  if (pw->pw_uid)\n    r = logindefs_setenv(\"PATH\", \"ENV_PATH\", _PATH_DEFPATH);\n\n  else if ((r = logindefs_setenv(\"PATH\", \"ENV_ROOTPATH\", NULL)) != 0)\n    r = logindefs_setenv(\"PATH\", \"ENV_SUPATH\", _PATH_DEFPATH_ROOT);\n\n  if (r != 0)\n    err (EXIT_FAILURE,  _(\"failed to set the %s environment variable\"), \"PATH\");\n}\n\n/* Update `environ' for the new shell based on PW, with SHELL being\n   the value for the SHELL environment variable.  */\n\nstatic void\nmodify_environment (const struct passwd *pw, const char *shell)\n{\n  if (simulate_login)\n    {\n      /* Leave TERM unchanged.  Set HOME, SHELL, USER, LOGNAME, PATH.\n         Unset all other environment variables.  */\n      char *term = getenv (\"TERM\");\n      if (term)\n\tterm = xstrdup (term);\n      environ = xmalloc ((6 + !!term) * sizeof (char *));\n      environ[0] = NULL;\n      if (term) {\n\txsetenv (\"TERM\", term, 1);\n\tfree(term);\n      }\n      xsetenv (\"HOME\", pw->pw_dir, 1);\n      if (shell)\n\txsetenv (\"SHELL\", shell, 1);\n      xsetenv (\"USER\", pw->pw_name, 1);\n      xsetenv (\"LOGNAME\", pw->pw_name, 1);\n      set_path(pw);\n    }\n  else\n    {\n      /* Set HOME, SHELL, and (if not becoming a superuser)\n\t USER and LOGNAME.  */\n      if (change_environment)\n        {\n          xsetenv (\"HOME\", pw->pw_dir, 1);\n\t  if (shell)\n            xsetenv (\"SHELL\", shell, 1);\n\t  if (getlogindefs_bool (\"ALWAYS_SET_PATH\", 0))\n\t    set_path(pw);\n\n          if (pw->pw_uid)\n            {\n              xsetenv (\"USER\", pw->pw_name, 1);\n              xsetenv (\"LOGNAME\", pw->pw_name, 1);\n            }\n        }\n    }\n\n  export_pamenv ();\n}\n\n/* Become the user and group(s) specified by PW.  */\n\nstatic void\ninit_groups (const struct passwd *pw, gid_t *groups, size_t num_groups)\n{\n  int retval;\n\n  errno = 0;\n\n  if (num_groups)\n    retval = setgroups (num_groups, groups);\n  else\n    retval = initgroups (pw->pw_name, pw->pw_gid);\n\n  if (retval == -1)\n    {\n      cleanup_pam (PAM_ABORT);\n      err (EXIT_FAILURE, _(\"cannot set groups\"));\n    }\n  endgrent ();\n\n  retval = pam_setcred (pamh, PAM_ESTABLISH_CRED);\n  if (is_pam_failure(retval))\n    errx (EXIT_FAILURE, \"%s\", pam_strerror (pamh, retval));\n  else\n    _pam_cred_established = 1;\n}\n\nstatic void\nchange_identity (const struct passwd *pw)\n{\n  if (setgid (pw->pw_gid))\n    err (EXIT_FAILURE,  _(\"cannot set group id\"));\n  if (setuid (pw->pw_uid))\n    err (EXIT_FAILURE,  _(\"cannot set user id\"));\n}\n\n/* Run SHELL, or DEFAULT_SHELL if SHELL is empty.\n   If COMMAND is nonzero, pass it to the shell with the -c option.\n   Pass ADDITIONAL_ARGS to the shell as more arguments; there\n   are N_ADDITIONAL_ARGS extra arguments.  */\n\nstatic void\nrun_shell (char const *shell, char const *command, char **additional_args,\n\t   size_t n_additional_args)\n{\n  size_t n_args = 1 + fast_startup + 2 * !!command + n_additional_args + 1;\n  char const **args = xcalloc (n_args, sizeof *args);\n  size_t argno = 1;\n\n  if (simulate_login)\n    {\n      char *arg0;\n      char *shell_basename;\n\n      shell_basename = basename (shell);\n      arg0 = xmalloc (strlen (shell_basename) + 2);\n      arg0[0] = '-';\n      strcpy (arg0 + 1, shell_basename);\n      args[0] = arg0;\n    }\n  else\n    args[0] = basename (shell);\n  if (fast_startup)\n    args[argno++] = \"-f\";\n  if (command)\n    {\n      args[argno++] = \"-c\";\n      args[argno++] = command;\n    }\n  memcpy (args + argno, additional_args, n_additional_args * sizeof *args);\n  args[argno + n_additional_args] = NULL;\n  execv (shell, (char **) args);\n\n  {\n    int exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);\n    warn (_(\"failed to execute %s\"), shell);\n    exit (exit_status);\n  }\n}\n\n/* Return true if SHELL is a restricted shell (one not returned by\n   getusershell), else false, meaning it is a standard shell.  */\n\nstatic bool\nrestricted_shell (const char *shell)\n{\n  char *line;\n\n  setusershell ();\n  while ((line = getusershell ()) != NULL)\n    {\n      if (*line != '#' && !strcmp (line, shell))\n\t{\n\t  endusershell ();\n\t  return false;\n\t}\n    }\n  endusershell ();\n  return true;\n}\n\nstatic void __attribute__((__noreturn__))\nusage (int status)\n{\n  if (su_mode == RUNUSER_MODE) {\n    fputs(USAGE_HEADER, stdout);\n    printf (_(\" %s [options] -u <user> [[--] <command>]\\n\"), program_invocation_short_name);\n    printf (_(\" %s [options] [-] [<user> [<argument>...]]\\n\"), program_invocation_short_name);\n    fputs (_(\"\\n\"\n    \"Run <command> with the effective user ID and group ID of <user>.  If -u is\\n\"\n    \"not given, fall back to su(1)-compatible semantics and execute standard shell.\\n\"\n    \"The options -c, -f, -l, and -s are mutually exclusive with -u.\\n\"), stdout);\n\n    fputs(USAGE_OPTIONS, stdout);\n\n    fputs (_(\" -u, --user <user>             username\\n\"), stdout);\n\n  } else {\n    fputs(USAGE_HEADER, stdout);\n    printf (_(\" %s [options] [-] [<user> [<argument>...]]\\n\"), program_invocation_short_name);\n    fputs (_(\"\\n\"\n    \"Change the effective user ID and group ID to that of <user>.\\n\"\n    \"A mere - implies -l.  If <user> is not given, root is assumed.\\n\"), stdout);\n\n    fputs(USAGE_OPTIONS, stdout);\n  }\n\n  fputs (_(\" -m, -p, --preserve-environment  do not reset environment variables\\n\"), stdout);\n  fputs (_(\" -g, --group <group>             specify the primary group\\n\"), stdout);\n  fputs (_(\" -G, --supp-group <group>        specify a supplemental group\\n\\n\"), stdout);\n\n  fputs (_(\" -, -l, --login                  make the shell a login shell\\n\"), stdout);\n  fputs (_(\" -c, --command <command>         pass a single command to the shell with -c\\n\"), stdout);\n  fputs (_(\" --session-command <command>     pass a single command to the shell with -c\\n\"\n           \"                                   and do not create a new session\\n\"), stdout);\n  fputs (_(\" -f, --fast                      pass -f to the shell (for csh or tcsh)\\n\"), stdout);\n  fputs (_(\" -s, --shell <shell>             run <shell> if /etc/shells allows it\\n\"), stdout);\n\n  fputs(USAGE_SEPARATOR, stdout);\n  fputs(USAGE_HELP, stdout);\n  fputs(USAGE_VERSION, stdout);\n  printf(USAGE_MAN_TAIL(su_mode == SU_MODE ? \"su(1)\" : \"runuser(1)\"));\n  exit (status);\n}\n\nstatic\nvoid load_config(void)\n{\n  switch (su_mode) {\n  case SU_MODE:\n    logindefs_load_file(_PATH_LOGINDEFS_SU);\n    break;\n  case RUNUSER_MODE:\n    logindefs_load_file(_PATH_LOGINDEFS_RUNUSER);\n    break;\n  }\n\n  logindefs_load_file(_PATH_LOGINDEFS);\n}\n\n/*\n * Returns 1 if the current user is not root\n */\nstatic int\nevaluate_uid(void)\n{\n  uid_t ruid = getuid();\n  uid_t euid = geteuid();\n\n  /* if we're really root and aren't running setuid */\n  return (uid_t) 0 == ruid && ruid == euid ? 0 : 1;\n}\n\nstatic gid_t\nadd_supp_group(const char *name, gid_t **groups, size_t *ngroups)\n{\n  struct group *gr;\n\n  if (*ngroups >= NGROUPS_MAX)\n    errx(EXIT_FAILURE,\n\tP_(\"specifying more than %d supplemental group is not possible\",\n\t   \"specifying more than %d supplemental groups is not possible\",\n\t     NGROUPS_MAX - 1), NGROUPS_MAX - 1);\n\n  gr = getgrnam(name);\n  if (!gr)\n    errx(EXIT_FAILURE, _(\"group %s does not exist\"), name);\n\n  *groups = xrealloc(*groups, sizeof(gid_t) * (*ngroups + 1));\n  (*groups)[*ngroups] = gr->gr_gid;\n  (*ngroups)++;\n\n  return gr->gr_gid;\n}\n\nint\nsu_main (int argc, char **argv, int mode)\n{\n  int optc;\n  const char *new_user = DEFAULT_USER, *runuser_user = NULL;\n  char *command = NULL;\n  int request_same_session = 0;\n  char *shell = NULL;\n  struct passwd *pw;\n  struct passwd pw_copy;\n\n  gid_t *groups = NULL;\n  size_t ngroups = 0;\n  bool use_supp = false;\n  bool use_gid = false;\n  gid_t gid = 0;\n\n  static const struct option longopts[] = {\n    {\"command\", required_argument, NULL, 'c'},\n    {\"session-command\", required_argument, NULL, 'C'},\n    {\"fast\", no_argument, NULL, 'f'},\n    {\"login\", no_argument, NULL, 'l'},\n    {\"preserve-environment\", no_argument, NULL, 'p'},\n    {\"shell\", required_argument, NULL, 's'},\n    {\"group\", required_argument, NULL, 'g'},\n    {\"supp-group\", required_argument, NULL, 'G'},\n    {\"user\", required_argument, NULL, 'u'},\t\t/* runuser only */\n    {\"help\", no_argument, 0, 'h'},\n    {\"version\", no_argument, 0, 'V'},\n    {NULL, 0, NULL, 0}\n  };\n\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n  atexit(close_stdout);\n\n  su_mode = mode;\n  fast_startup = false;\n  simulate_login = false;\n  change_environment = true;\n\n  while ((optc = getopt_long (argc, argv, \"c:fg:G:lmps:u:hV\", longopts, NULL)) != -1)\n    {\n      switch (optc)\n\t{\n\tcase 'c':\n\t  command = optarg;\n\t  break;\n\n        case 'C':\n          command = optarg;\n          request_same_session = 1;\n          break;\n\n\tcase 'f':\n\t  fast_startup = true;\n\t  break;\n\n\tcase 'g':\n\t  use_gid = true;\n\t  gid = add_supp_group(optarg, &groups, &ngroups);\n\t  break;\n\n\tcase 'G':\n\t  use_supp = true;\n\t  add_supp_group(optarg, &groups, &ngroups);\n\t  break;\n\n\tcase 'l':\n\t  simulate_login = true;\n\t  break;\n\n\tcase 'm':\n\tcase 'p':\n\t  change_environment = false;\n\t  break;\n\n\tcase 's':\n\t  shell = optarg;\n\t  break;\n\n\tcase 'u':\n\t  if (su_mode != RUNUSER_MODE)\n\t    usage (EXIT_FAILURE);\n\t  runuser_user = optarg;\n\t  break;\n\n\tcase 'h':\n\t  usage(0);\n\n\tcase 'V':\n\t  printf(UTIL_LINUX_VERSION);\n\t  exit(EXIT_SUCCESS);\n\n\tdefault:\n\t  errtryhelp(EXIT_FAILURE);\n\t}\n    }\n\n  restricted = evaluate_uid ();\n\n  if (optind < argc && !strcmp (argv[optind], \"-\"))\n    {\n      simulate_login = true;\n      ++optind;\n    }\n\n  if (simulate_login && !change_environment) {\n    warnx(_(\"ignoring --preserve-environment, it's mutually exclusive with --login\"));\n    change_environment = true;\n  }\n\n  switch (su_mode) {\n  case RUNUSER_MODE:\n    if (runuser_user) {\n      /* runuser -u <user> <command> */\n      new_user = runuser_user;\n      if (shell || fast_startup || command || simulate_login) {\n        errx(EXIT_FAILURE,\n\t   _(\"options --{shell,fast,command,session-command,login} and \"\n\t     \"--user are mutually exclusive\"));\n      }\n      if (optind == argc)\n        errx(EXIT_FAILURE, _(\"no command was specified\"));\n\n      break;\n    }\n    /* fallthrough if -u <user> is not specified, then follow\n     * traditional su(1) behavior\n     */\n  case SU_MODE:\n    if (optind < argc)\n      new_user = argv[optind++];\n    break;\n  }\n\n  if ((use_supp || use_gid) && restricted)\n    errx(EXIT_FAILURE, _(\"only root can specify alternative groups\"));\n\n  logindefs_load_defaults = load_config;\n\n  pw = getpwnam (new_user);\n  if (! (pw && pw->pw_name && pw->pw_name[0] && pw->pw_dir && pw->pw_dir[0]\n\t && pw->pw_passwd))\n    errx (EXIT_FAILURE, _(\"user %s does not exist\"), new_user);\n\n  /* Make a copy of the password information and point pw at the local\n     copy instead.  Otherwise, some systems (e.g. Linux) would clobber\n     the static data through the getlogin call from log_su.\n     Also, make sure pw->pw_shell is a nonempty string.\n     It may be NULL when NEW_USER is a username that is retrieved via NIS (YP),\n     but that doesn't have a default shell listed.  */\n  pw_copy = *pw;\n  pw = &pw_copy;\n  pw->pw_name = xstrdup (pw->pw_name);\n  pw->pw_passwd = xstrdup (pw->pw_passwd);\n  pw->pw_dir = xstrdup (pw->pw_dir);\n  pw->pw_shell = xstrdup (pw->pw_shell && pw->pw_shell[0]\n\t\t\t  ? pw->pw_shell\n\t\t\t  : DEFAULT_SHELL);\n  endpwent ();\n\n  if (use_supp && !use_gid)\n    pw->pw_gid = groups[0];\n  else if (use_gid)\n    pw->pw_gid = gid;\n\n  authenticate (pw);\n\n  if (request_same_session || !command || !pw->pw_uid)\n    same_session = 1;\n\n  /* initialize shell variable only if \"-u <user>\" not specified */\n  if (runuser_user) {\n    shell = NULL;\n  } else {\n    if (!shell && !change_environment)\n      shell = getenv (\"SHELL\");\n    if (shell && getuid () != 0 && restricted_shell (pw->pw_shell))\n      {\n\t/* The user being su'd to has a nonstandard shell, and so is\n\t   probably a uucp account or has restricted access.  Don't\n\t   compromise the account by allowing access with a standard\n\t   shell.  */\n\twarnx (_(\"using restricted shell %s\"), pw->pw_shell);\n\tshell = NULL;\n      }\n    shell = xstrdup (shell ? shell : pw->pw_shell);\n  }\n\n  init_groups (pw, groups, ngroups);\n\n  if (!simulate_login || command)\n    suppress_pam_info = 1;\t\t/* don't print PAM info messages */\n\n  create_watching_parent ();\n  /* Now we're in the child.  */\n\n  change_identity (pw);\n  if (!same_session)\n    setsid ();\n\n  /* Set environment after pam_open_session, which may put KRB5CCNAME\n     into the pam_env, etc.  */\n\n  modify_environment (pw, shell);\n\n  if (simulate_login && chdir (pw->pw_dir) != 0)\n    warn (_(\"warning: cannot change directory to %s\"), pw->pw_dir);\n\n  if (shell)\n    run_shell (shell, command, argv + optind, max (0, argc - optind));\n  else {\n    execvp(argv[optind], &argv[optind]);\n    err(EXIT_FAILURE, _(\"failed to execute %s\"), argv[optind]);\n  }\n}\n\n// vim: sw=2 cinoptions=>4,n-2,{2,^-2,\\:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1\n"], "filenames": ["login-utils/su-common.c"], "buggy_code_start_loc": [370], "buggy_code_end_loc": [393], "fixing_code_start_loc": [371], "fixing_code_end_loc": [399], "type": "CWE-362", "message": "A race condition was found in util-linux before 2.32.1 in the way su handled the management of child processes. A local authenticated attacker could use this flaw to kill other processes with root privileges under specific conditions.", "other": {"cve": {"id": "CVE-2017-2616", "sourceIdentifier": "secalert@redhat.com", "published": "2018-07-27T19:29:00.207", "lastModified": "2019-10-09T23:26:56.930", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A race condition was found in util-linux before 2.32.1 in the way su handled the management of child processes. A local authenticated attacker could use this flaw to kill other processes with root privileges under specific conditions."}, {"lang": "es", "value": "Se ha encontrado una condici\u00f3n de carrera en util-linux en versiones anteriores a la 2.32.1 en la forma en la que \"su\" manejaba los procesos hijo. Un atacante local autenticado podr\u00eda usar este defecto para matar otros procesos con privilegios de root bajo condiciones espec\u00edficas."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-267"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:util-linux_project:util-linux:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.32.1", "matchCriteriaId": "2681A35D-0016-4E9D-8448-58B6B3200D34"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "A8442C20-41F9-47FD-9A12-E724D3A31FD7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://rhn.redhat.com/errata/RHSA-2017-0654.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96404", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1038271", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:0907", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2616", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/karelzak/util-linux/commit/dffab154d29a288aa171ff50263ecc8f2e14a891", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-02", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2017/dsa-3793", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/karelzak/util-linux/commit/dffab154d29a288aa171ff50263ecc8f2e14a891"}}