{"buggy_code": ["\nconst {Parser: AcornParser, isNewLine: acornIsNewLine, getLineInfo: acornGetLineInfo} = require('acorn');\nconst {full: acornWalkFull} = require('acorn-walk');\n\nconst INTERNAL_STATE_NAME = 'VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL';\n\nfunction assertType(node, type) {\n\tif (!node) throw new Error(`None existent node expected '${type}'`);\n\tif (node.type !== type) throw new Error(`Invalid node type '${node.type}' expected '${type}'`);\n\treturn node;\n}\n\nfunction makeNiceSyntaxError(message, code, filename, location, tokenizer) {\n\tconst loc = acornGetLineInfo(code, location);\n\tlet end = location;\n\twhile (end < code.length && !acornIsNewLine(code.charCodeAt(end))) {\n\t\tend++;\n\t}\n\tlet markerEnd = tokenizer.start === location ? tokenizer.end : location + 1;\n\tif (!markerEnd || markerEnd > end) markerEnd = end;\n\tlet markerLen = markerEnd - location;\n\tif (markerLen <= 0) markerLen = 1;\n\tif (message === 'Unexpected token') {\n\t\tconst type = tokenizer.type;\n\t\tif (type.label === 'name' || type.label === 'privateId') {\n\t\t\tmessage = 'Unexpected identifier';\n\t\t} else if (type.label === 'eof') {\n\t\t\tmessage = 'Unexpected end of input';\n\t\t} else if (type.label === 'num') {\n\t\t\tmessage = 'Unexpected number';\n\t\t} else if (type.label === 'string') {\n\t\t\tmessage = 'Unexpected string';\n\t\t} else if (type.label === 'regexp') {\n\t\t\tmessage = 'Unexpected token \\'/\\'';\n\t\t\tmarkerLen = 1;\n\t\t} else {\n\t\t\tconst token = tokenizer.value || type.label;\n\t\t\tmessage = `Unexpected token '${token}'`;\n\t\t}\n\t}\n\tconst error = new SyntaxError(message);\n\tif (!filename) return error;\n\tconst line = code.slice(location - loc.column, end);\n\tconst marker = line.slice(0, loc.column).replace(/\\S/g, ' ') + '^'.repeat(markerLen);\n\terror.stack = `${filename}:${loc.line}\\n${line}\\n${marker}\\n\\n${error.stack}`;\n\treturn error;\n}\n\nfunction transformer(args, body, isAsync, isGenerator, filename) {\n\tlet code;\n\tlet argsOffset;\n\tif (args === null) {\n\t\tcode = body;\n\t\t// Note: Keywords are not allows to contain u escapes\n\t\tif (!/\\b(?:catch|import|async)\\b/.test(code)) {\n\t\t\treturn {__proto__: null, code, hasAsync: false};\n\t\t}\n\t} else {\n\t\tcode = isAsync ? '(async function' : '(function';\n\t\tif (isGenerator) code += '*';\n\t\tcode += ' anonymous(';\n\t\tcode += args;\n\t\targsOffset = code.length;\n\t\tcode += '\\n) {\\n';\n\t\tcode += body;\n\t\tcode += '\\n})';\n\t}\n\n\tconst parser = new AcornParser({\n\t\t__proto__: null,\n\t\tecmaVersion: 2022,\n\t\tallowAwaitOutsideFunction: args === null && isAsync,\n\t\tallowReturnOutsideFunction: args === null\n\t}, code);\n\tlet ast;\n\ttry {\n\t\tast = parser.parse();\n\t} catch (e) {\n\t\t// Try to generate a nicer error message.\n\t\tif (e instanceof SyntaxError && e.pos !== undefined) {\n\t\t\tlet message = e.message;\n\t\t\tconst match = message.match(/^(.*) \\(\\d+:\\d+\\)$/);\n\t\t\tif (match) message = match[1];\n\t\t\te = makeNiceSyntaxError(message, code, filename, e.pos, parser);\n\t\t}\n\t\tthrow e;\n\t}\n\n\tif (args !== null) {\n\t\tconst pBody = assertType(ast, 'Program').body;\n\t\tif (pBody.length !== 1) throw new SyntaxError('Single function literal required');\n\t\tconst expr = pBody[0];\n\t\tif (expr.type !== 'ExpressionStatement') throw new SyntaxError('Single function literal required');\n\t\tconst func = expr.expression;\n\t\tif (func.type !== 'FunctionExpression') throw new SyntaxError('Single function literal required');\n\t\tif (func.body.start !== argsOffset + 3) throw new SyntaxError('Unexpected end of arg string');\n\t}\n\n\tconst insertions = [];\n\tlet hasAsync = false;\n\n\tconst TO_LEFT = -100;\n\tconst TO_RIGHT = 100;\n\n\tlet internStateValiable = undefined;\n\tlet tmpname = 'VM2_INTERNAL_TMPNAME';\n\n\tacornWalkFull(ast, (node, state, type) => {\n\t\tif (type === 'Function') {\n\t\t\tif (node.async) hasAsync = true;\n\t\t}\n\t\tconst nodeType = node.type;\n\t\tif (nodeType === 'CatchClause') {\n\t\t\tconst param = node.param;\n\t\t\tif (param) {\n\t\t\t\tif (param.type === 'ObjectPattern') {\n\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tpos: node.start,\n\t\t\t\t\t\torder: TO_RIGHT,\n\t\t\t\t\t\tcoder: () => `catch(${tmpname}){try{throw(${tmpname}=${INTERNAL_STATE_NAME}.handleException(${tmpname}));}`\n\t\t\t\t\t});\n\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tpos: node.body.end,\n\t\t\t\t\t\torder: TO_LEFT,\n\t\t\t\t\t\tcoder: () => `}`\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconst name = assertType(param, 'Identifier').name;\n\t\t\t\t\tconst cBody = assertType(node.body, 'BlockStatement');\n\t\t\t\t\tif (cBody.body.length > 0) {\n\t\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\tpos: cBody.body[0].start,\n\t\t\t\t\t\t\torder: TO_LEFT,\n\t\t\t\t\t\t\tcoder: () => `${name}=${INTERNAL_STATE_NAME}.handleException(${name});`\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 'WithStatement') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.start,\n\t\t\t\torder: TO_LEFT,\n\t\t\t\tcoder: () => INTERNAL_STATE_NAME + '.wrapWith('\n\t\t\t});\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.end,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcoder: () => ')'\n\t\t\t});\n\t\t} else if (nodeType === 'Identifier') {\n\t\t\tif (node.name === INTERNAL_STATE_NAME) {\n\t\t\t\tif (internStateValiable === undefined || internStateValiable.start > node.start) {\n\t\t\t\t\tinternStateValiable = node;\n\t\t\t\t}\n\t\t\t} else if (node.name.startsWith(tmpname)) {\n\t\t\t\ttmpname = node.name + '_UNIQUE';\n\t\t\t}\n\t\t} else if (nodeType === 'ImportExpression') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.start,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcoder: () => INTERNAL_STATE_NAME + '.'\n\t\t\t});\n\t\t}\n\t});\n\n\tif (internStateValiable) {\n\t\tthrow makeNiceSyntaxError('Use of internal vm2 state variable', code, filename, internStateValiable.start, {\n\t\t\t__proto__: null,\n\t\t\tstart: internStateValiable.start,\n\t\t\tend: internStateValiable.end\n\t\t});\n\t}\n\n\tif (insertions.length === 0) return {__proto__: null, code, hasAsync};\n\n\tinsertions.sort((a, b) => (a.pos == b.pos ? a.order - b.order : a.pos - b.pos));\n\n\tlet ncode = '';\n\tlet curr = 0;\n\tfor (let i = 0; i < insertions.length; i++) {\n\t\tconst change = insertions[i];\n\t\tncode += code.substring(curr, change.pos) + change.coder();\n\t\tcurr = change.pos;\n\t}\n\tncode += code.substring(curr);\n\n\treturn {__proto__: null, code: ncode, hasAsync};\n}\n\nexports.INTERNAL_STATE_NAME = INTERNAL_STATE_NAME;\nexports.transformer = transformer;\n"], "fixing_code": ["\nconst {Parser: AcornParser, isNewLine: acornIsNewLine, getLineInfo: acornGetLineInfo} = require('acorn');\nconst {full: acornWalkFull} = require('acorn-walk');\n\nconst INTERNAL_STATE_NAME = 'VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL';\n\nfunction assertType(node, type) {\n\tif (!node) throw new Error(`None existent node expected '${type}'`);\n\tif (node.type !== type) throw new Error(`Invalid node type '${node.type}' expected '${type}'`);\n\treturn node;\n}\n\nfunction makeNiceSyntaxError(message, code, filename, location, tokenizer) {\n\tconst loc = acornGetLineInfo(code, location);\n\tlet end = location;\n\twhile (end < code.length && !acornIsNewLine(code.charCodeAt(end))) {\n\t\tend++;\n\t}\n\tlet markerEnd = tokenizer.start === location ? tokenizer.end : location + 1;\n\tif (!markerEnd || markerEnd > end) markerEnd = end;\n\tlet markerLen = markerEnd - location;\n\tif (markerLen <= 0) markerLen = 1;\n\tif (message === 'Unexpected token') {\n\t\tconst type = tokenizer.type;\n\t\tif (type.label === 'name' || type.label === 'privateId') {\n\t\t\tmessage = 'Unexpected identifier';\n\t\t} else if (type.label === 'eof') {\n\t\t\tmessage = 'Unexpected end of input';\n\t\t} else if (type.label === 'num') {\n\t\t\tmessage = 'Unexpected number';\n\t\t} else if (type.label === 'string') {\n\t\t\tmessage = 'Unexpected string';\n\t\t} else if (type.label === 'regexp') {\n\t\t\tmessage = 'Unexpected token \\'/\\'';\n\t\t\tmarkerLen = 1;\n\t\t} else {\n\t\t\tconst token = tokenizer.value || type.label;\n\t\t\tmessage = `Unexpected token '${token}'`;\n\t\t}\n\t}\n\tconst error = new SyntaxError(message);\n\tif (!filename) return error;\n\tconst line = code.slice(location - loc.column, end);\n\tconst marker = line.slice(0, loc.column).replace(/\\S/g, ' ') + '^'.repeat(markerLen);\n\terror.stack = `${filename}:${loc.line}\\n${line}\\n${marker}\\n\\n${error.stack}`;\n\treturn error;\n}\n\nfunction transformer(args, body, isAsync, isGenerator, filename) {\n\tlet code;\n\tlet argsOffset;\n\tif (args === null) {\n\t\tcode = body;\n\t\t// Note: Keywords are not allows to contain u escapes\n\t\tif (!/\\b(?:catch|import|async)\\b/.test(code)) {\n\t\t\treturn {__proto__: null, code, hasAsync: false};\n\t\t}\n\t} else {\n\t\tcode = isAsync ? '(async function' : '(function';\n\t\tif (isGenerator) code += '*';\n\t\tcode += ' anonymous(';\n\t\tcode += args;\n\t\targsOffset = code.length;\n\t\tcode += '\\n) {\\n';\n\t\tcode += body;\n\t\tcode += '\\n})';\n\t}\n\n\tconst parser = new AcornParser({\n\t\t__proto__: null,\n\t\tecmaVersion: 2022,\n\t\tallowAwaitOutsideFunction: args === null && isAsync,\n\t\tallowReturnOutsideFunction: args === null\n\t}, code);\n\tlet ast;\n\ttry {\n\t\tast = parser.parse();\n\t} catch (e) {\n\t\t// Try to generate a nicer error message.\n\t\tif (e instanceof SyntaxError && e.pos !== undefined) {\n\t\t\tlet message = e.message;\n\t\t\tconst match = message.match(/^(.*) \\(\\d+:\\d+\\)$/);\n\t\t\tif (match) message = match[1];\n\t\t\te = makeNiceSyntaxError(message, code, filename, e.pos, parser);\n\t\t}\n\t\tthrow e;\n\t}\n\n\tif (args !== null) {\n\t\tconst pBody = assertType(ast, 'Program').body;\n\t\tif (pBody.length !== 1) throw new SyntaxError('Single function literal required');\n\t\tconst expr = pBody[0];\n\t\tif (expr.type !== 'ExpressionStatement') throw new SyntaxError('Single function literal required');\n\t\tconst func = expr.expression;\n\t\tif (func.type !== 'FunctionExpression') throw new SyntaxError('Single function literal required');\n\t\tif (func.body.start !== argsOffset + 3) throw new SyntaxError('Unexpected end of arg string');\n\t}\n\n\tconst insertions = [];\n\tlet hasAsync = false;\n\n\tconst TO_LEFT = -100;\n\tconst TO_RIGHT = 100;\n\n\tlet internStateValiable = undefined;\n\tlet tmpname = 'VM2_INTERNAL_TMPNAME';\n\n\tacornWalkFull(ast, (node, state, type) => {\n\t\tif (type === 'Function') {\n\t\t\tif (node.async) hasAsync = true;\n\t\t}\n\t\tconst nodeType = node.type;\n\t\tif (nodeType === 'CatchClause') {\n\t\t\tconst param = node.param;\n\t\t\tif (param) {\n\t\t\t\tif (param.type === 'Identifier') {\n\t\t\t\t\tconst name = assertType(param, 'Identifier').name;\n\t\t\t\t\tconst cBody = assertType(node.body, 'BlockStatement');\n\t\t\t\t\tif (cBody.body.length > 0) {\n\t\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\tpos: cBody.body[0].start,\n\t\t\t\t\t\t\torder: TO_LEFT,\n\t\t\t\t\t\t\tcoder: () => `${name}=${INTERNAL_STATE_NAME}.handleException(${name});`\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tpos: node.start,\n\t\t\t\t\t\torder: TO_RIGHT,\n\t\t\t\t\t\tcoder: () => `catch(${tmpname}){${tmpname}=${INTERNAL_STATE_NAME}.handleException(${tmpname});try{throw ${tmpname};}`\n\t\t\t\t\t});\n\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tpos: node.body.end,\n\t\t\t\t\t\torder: TO_LEFT,\n\t\t\t\t\t\tcoder: () => `}`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 'WithStatement') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.start,\n\t\t\t\torder: TO_LEFT,\n\t\t\t\tcoder: () => INTERNAL_STATE_NAME + '.wrapWith('\n\t\t\t});\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.end,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcoder: () => ')'\n\t\t\t});\n\t\t} else if (nodeType === 'Identifier') {\n\t\t\tif (node.name === INTERNAL_STATE_NAME) {\n\t\t\t\tif (internStateValiable === undefined || internStateValiable.start > node.start) {\n\t\t\t\t\tinternStateValiable = node;\n\t\t\t\t}\n\t\t\t} else if (node.name.startsWith(tmpname)) {\n\t\t\t\ttmpname = node.name + '_UNIQUE';\n\t\t\t}\n\t\t} else if (nodeType === 'ImportExpression') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.start,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcoder: () => INTERNAL_STATE_NAME + '.'\n\t\t\t});\n\t\t}\n\t});\n\n\tif (internStateValiable) {\n\t\tthrow makeNiceSyntaxError('Use of internal vm2 state variable', code, filename, internStateValiable.start, {\n\t\t\t__proto__: null,\n\t\t\tstart: internStateValiable.start,\n\t\t\tend: internStateValiable.end\n\t\t});\n\t}\n\n\tif (insertions.length === 0) return {__proto__: null, code, hasAsync};\n\n\tinsertions.sort((a, b) => (a.pos == b.pos ? a.order - b.order : a.pos - b.pos));\n\n\tlet ncode = '';\n\tlet curr = 0;\n\tfor (let i = 0; i < insertions.length; i++) {\n\t\tconst change = insertions[i];\n\t\tncode += code.substring(curr, change.pos) + change.coder();\n\t\tcurr = change.pos;\n\t}\n\tncode += code.substring(curr);\n\n\treturn {__proto__: null, code: ncode, hasAsync};\n}\n\nexports.INTERNAL_STATE_NAME = INTERNAL_STATE_NAME;\nexports.transformer = transformer;\n"], "filenames": ["lib/transformer.js"], "buggy_code_start_loc": [116], "buggy_code_end_loc": [139], "fixing_code_start_loc": [116], "fixing_code_end_loc": [140], "type": "NVD-CWE-noinfo", "message": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. There exists a vulnerability in exception sanitization of vm2 for versions up to 3.9.16, allowing attackers to raise an unsanitized host exception inside `handleException()` which can be used to escape the sandbox and run arbitrary code in host context. This vulnerability was patched in the release of version `3.9.17` of `vm2`. There are no known workarounds for this vulnerability. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-30547", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-17T22:15:10.487", "lastModified": "2023-04-28T01:13:44.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. There exists a vulnerability in exception sanitization of vm2 for versions up to 3.9.16, allowing attackers to raise an unsanitized host exception inside `handleException()` which can be used to escape the sandbox and run arbitrary code in host context. This vulnerability was patched in the release of version `3.9.17` of `vm2`. There are no known workarounds for this vulnerability. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "3.9.16", "matchCriteriaId": "6D85218D-E019-4345-8171-42A65FFA75AB"}]}]}], "references": [{"url": "https://gist.github.com/leesh3288/381b230b04936dd4d74aaf90cc8bb244", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/commit/4b22e87b102d97d45d112a0931dba1aef7eea049", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/patriksimek/vm2/commit/f3db4dee4d76b19869df05ba7880d638a880edd5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/patriksimek/vm2/security/advisories/GHSA-ch3r-j5x3-6q2m", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/4b22e87b102d97d45d112a0931dba1aef7eea049"}}