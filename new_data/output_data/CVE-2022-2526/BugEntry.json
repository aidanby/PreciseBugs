{"buggy_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <netinet/tcp.h>\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"io-util.h\"\n#include \"missing.h\"\n#include \"resolved-dns-stream.h\"\n\n#define DNS_STREAM_TIMEOUT_USEC (10 * USEC_PER_SEC)\n#define DNS_STREAMS_MAX 128\n\nstatic void dns_stream_stop(DnsStream *s) {\n        assert(s);\n\n        s->io_event_source = sd_event_source_unref(s->io_event_source);\n        s->timeout_event_source = sd_event_source_unref(s->timeout_event_source);\n        s->fd = safe_close(s->fd);\n}\n\nstatic int dns_stream_update_io(DnsStream *s) {\n        int f = 0;\n\n        assert(s);\n\n        if (s->write_packet && s->n_written < sizeof(s->write_size) + s->write_packet->size)\n                f |= EPOLLOUT;\n        else if (!ordered_set_isempty(s->write_queue)) {\n                dns_packet_unref(s->write_packet);\n                s->write_packet = ordered_set_steal_first(s->write_queue);\n                s->write_size = htobe16(s->write_packet->size);\n                s->n_written = 0;\n                f |= EPOLLOUT;\n        }\n        if (!s->read_packet || s->n_read < sizeof(s->read_size) + s->read_packet->size)\n                f |= EPOLLIN;\n\n#if ENABLE_DNS_OVER_TLS\n        /* For handshake and clean closing purposes, TLS can override requested events */\n        if (s->dnstls_events)\n                f = s->dnstls_events;\n#endif\n\n        return sd_event_source_set_io_events(s->io_event_source, f);\n}\n\nstatic int dns_stream_complete(DnsStream *s, int error) {\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n\n        if (s->complete)\n                s->complete(s, error);\n        else /* the default action if no completion function is set is to close the stream */\n                dns_stream_unref(s);\n\n        return 0;\n}\n\nstatic int dns_stream_identify(DnsStream *s) {\n        union {\n                struct cmsghdr header; /* For alignment */\n                uint8_t buffer[CMSG_SPACE(MAXSIZE(struct in_pktinfo, struct in6_pktinfo))\n                               + EXTRA_CMSG_SPACE /* kernel appears to require extra space */];\n        } control;\n        struct msghdr mh = {};\n        struct cmsghdr *cmsg;\n        socklen_t sl;\n        int r;\n\n        assert(s);\n\n        if (s->identified)\n                return 0;\n\n        /* Query the local side */\n        s->local_salen = sizeof(s->local);\n        r = getsockname(s->fd, &s->local.sa, &s->local_salen);\n        if (r < 0)\n                return -errno;\n        if (s->local.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->local.in6.sin6_scope_id;\n\n        /* Query the remote side */\n        s->peer_salen = sizeof(s->peer);\n        r = getpeername(s->fd, &s->peer.sa, &s->peer_salen);\n        if (r < 0)\n                return -errno;\n        if (s->peer.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->peer.in6.sin6_scope_id;\n\n        /* Check consistency */\n        assert(s->peer.sa.sa_family == s->local.sa.sa_family);\n        assert(IN_SET(s->peer.sa.sa_family, AF_INET, AF_INET6));\n\n        /* Query connection meta information */\n        sl = sizeof(control);\n        if (s->peer.sa.sa_family == AF_INET) {\n                r = getsockopt(s->fd, IPPROTO_IP, IP_PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else if (s->peer.sa.sa_family == AF_INET6) {\n\n                r = getsockopt(s->fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else\n                return -EAFNOSUPPORT;\n\n        mh.msg_control = &control;\n        mh.msg_controllen = sl;\n\n        CMSG_FOREACH(cmsg, &mh) {\n\n                if (cmsg->cmsg_level == IPPROTO_IPV6) {\n                        assert(s->peer.sa.sa_family == AF_INET6);\n\n                        switch (cmsg->cmsg_type) {\n\n                        case IPV6_PKTINFO: {\n                                struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi6_ifindex;\n                                break;\n                        }\n\n                        case IPV6_HOPLIMIT:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n\n                } else if (cmsg->cmsg_level == IPPROTO_IP) {\n                        assert(s->peer.sa.sa_family == AF_INET);\n\n                        switch (cmsg->cmsg_type) {\n\n                        case IP_PKTINFO: {\n                                struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi_ifindex;\n                                break;\n                        }\n\n                        case IP_TTL:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n                }\n        }\n\n        /* The Linux kernel sets the interface index to the loopback\n         * device if the connection came from the local host since it\n         * avoids the routing table in such a case. Let's unset the\n         * interface index in such a case. */\n        if (s->ifindex == LOOPBACK_IFINDEX)\n                s->ifindex = 0;\n\n        /* If we don't know the interface index still, we look for the\n         * first local interface with a matching address. Yuck! */\n        if (s->ifindex <= 0)\n                s->ifindex = manager_find_ifindex(s->manager, s->local.sa.sa_family, s->local.sa.sa_family == AF_INET ? (union in_addr_union*) &s->local.in.sin_addr : (union in_addr_union*)  &s->local.in6.sin6_addr);\n\n        if (s->protocol == DNS_PROTOCOL_LLMNR && s->ifindex > 0) {\n                uint32_t ifindex = htobe32(s->ifindex);\n\n                /* Make sure all packets for this connection are sent on the same interface */\n                if (s->local.sa.sa_family == AF_INET) {\n                        r = setsockopt(s->fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IP_UNICAST_IF: %m\");\n                } else if (s->local.sa.sa_family == AF_INET6) {\n                        r = setsockopt(s->fd, IPPROTO_IPV6, IPV6_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IPV6_UNICAST_IF: %m\");\n                }\n        }\n\n        s->identified = true;\n\n        return 0;\n}\n\nssize_t dns_stream_writev(DnsStream *s, const struct iovec *iov, size_t iovcnt, int flags) {\n        ssize_t m;\n\n        assert(s);\n        assert(iov);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted && !(flags & DNS_STREAM_WRITE_TLS_DATA)) {\n                ssize_t ss;\n                size_t i;\n\n                m = 0;\n                for (i = 0; i < iovcnt; i++) {\n                        ss = dnstls_stream_write(s, iov[i].iov_base, iov[i].iov_len);\n                        if (ss < 0)\n                                return ss;\n\n                        m += ss;\n                        if (ss != (ssize_t) iov[i].iov_len)\n                                continue;\n                }\n        } else\n#endif\n        if (s->tfo_salen > 0) {\n                struct msghdr hdr = {\n                        .msg_iov = (struct iovec*) iov,\n                        .msg_iovlen = iovcnt,\n                        .msg_name = &s->tfo_address.sa,\n                        .msg_namelen = s->tfo_salen\n                };\n\n                m = sendmsg(s->fd, &hdr, MSG_FASTOPEN);\n                if (m < 0) {\n                        if (errno == EOPNOTSUPP) {\n                                s->tfo_salen = 0;\n                                if (connect(s->fd, &s->tfo_address.sa, s->tfo_salen) < 0)\n                                        return -errno;\n\n                                return -EAGAIN;\n                        }\n                        if (errno == EINPROGRESS)\n                                return -EAGAIN;\n\n                        return -errno;\n                } else\n                        s->tfo_salen = 0; /* connection is made */\n        } else {\n                m = writev(s->fd, iov, iovcnt);\n                if (m < 0)\n                        return -errno;\n        }\n\n        return m;\n}\n\nstatic ssize_t dns_stream_read(DnsStream *s, void *buf, size_t count) {\n        ssize_t ss;\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted)\n                ss = dnstls_stream_read(s, buf, count);\n        else\n#endif\n        {\n                ss = read(s->fd, buf, count);\n                if (ss < 0)\n                        return -errno;\n        }\n\n        return ss;\n}\n\nstatic int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata) {\n        DnsStream *s = userdata;\n\n        assert(s);\n\n        return dns_stream_complete(s, ETIMEDOUT);\n}\n\nstatic int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        DnsStream *s = userdata;\n        int r;\n\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                r = dnstls_stream_on_io(s, revents);\n                if (r == DNSTLS_STREAM_CLOSED)\n                        return 0;\n                if (r == -EAGAIN)\n                        return dns_stream_update_io(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n\n                r = dns_stream_update_io(s);\n                if (r < 0)\n                        return r;\n        }\n#endif\n\n        /* only identify after connecting */\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n        }\n\n        if ((revents & EPOLLOUT) &&\n            s->write_packet &&\n            s->n_written < sizeof(s->write_size) + s->write_packet->size) {\n\n                struct iovec iov[2];\n                ssize_t ss;\n\n                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));\n                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);\n\n                IOVEC_INCREMENT(iov, 2, s->n_written);\n\n                ss = dns_stream_writev(s, iov, 2, 0);\n                if (ss < 0) {\n                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                return dns_stream_complete(s, -ss);\n                } else\n                        s->n_written += ss;\n\n                /* Are we done? If so, disable the event source for EPOLLOUT */\n                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {\n                        r = dns_stream_update_io(s);\n                        if (r < 0)\n                                return dns_stream_complete(s, -r);\n                }\n        }\n\n        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&\n            (!s->read_packet ||\n             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {\n\n                if (s->n_read < sizeof(s->read_size)) {\n                        ssize_t ss;\n\n                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);\n                        if (ss < 0) {\n                                if (!IN_SET(-ss, EINTR, EAGAIN))\n                                        return dns_stream_complete(s, -ss);\n                        } else if (ss == 0)\n                                return dns_stream_complete(s, ECONNRESET);\n                        else\n                                s->n_read += ss;\n                }\n\n                if (s->n_read >= sizeof(s->read_size)) {\n\n                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)\n                                return dns_stream_complete(s, EBADMSG);\n\n                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {\n                                ssize_t ss;\n\n                                if (!s->read_packet) {\n                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);\n                                        if (r < 0)\n                                                return dns_stream_complete(s, -r);\n\n                                        s->read_packet->size = be16toh(s->read_size);\n                                        s->read_packet->ipproto = IPPROTO_TCP;\n                                        s->read_packet->family = s->peer.sa.sa_family;\n                                        s->read_packet->ttl = s->ttl;\n                                        s->read_packet->ifindex = s->ifindex;\n\n                                        if (s->read_packet->family == AF_INET) {\n                                                s->read_packet->sender.in = s->peer.in.sin_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);\n                                                s->read_packet->destination.in = s->local.in.sin_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);\n                                        } else {\n                                                assert(s->read_packet->family == AF_INET6);\n                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);\n                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);\n\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                ss = dns_stream_read(s,\n                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),\n                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);\n                                if (ss < 0) {\n                                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                                return dns_stream_complete(s, -ss);\n                                } else if (ss == 0)\n                                        return dns_stream_complete(s, ECONNRESET);\n                                else\n                                        s->n_read += ss;\n                        }\n\n                        /* Are we done? If so, disable the event source for EPOLLIN */\n                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {\n                                /* If there's a packet handler\n                                 * installed, call that. Note that\n                                 * this is optional... */\n                                if (s->on_packet) {\n                                        r = s->on_packet(s);\n                                        if (r < 0)\n                                                return r;\n                                }\n\n                                r = dns_stream_update_io(s);\n                                if (r < 0)\n                                        return dns_stream_complete(s, -r);\n                        }\n                }\n        }\n\n        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&\n            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))\n                return dns_stream_complete(s, 0);\n\n        return 0;\n}\n\nstatic DnsStream *dns_stream_free(DnsStream *s) {\n        DnsPacket *p;\n        Iterator i;\n\n        assert(s);\n\n        dns_stream_stop(s);\n\n        if (s->server && s->server->stream == s)\n                s->server->stream = NULL;\n\n        if (s->manager) {\n                LIST_REMOVE(streams, s->manager->dns_streams, s);\n                s->manager->n_dns_streams--;\n        }\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted)\n                dnstls_stream_free(s);\n#endif\n\n        ORDERED_SET_FOREACH(p, s->write_queue, i)\n                dns_packet_unref(ordered_set_remove(s->write_queue, p));\n\n        dns_packet_unref(s->write_packet);\n        dns_packet_unref(s->read_packet);\n        dns_server_unref(s->server);\n\n        ordered_set_free(s->write_queue);\n\n        return mfree(s);\n}\n\nDEFINE_TRIVIAL_REF_UNREF_FUNC(DnsStream, dns_stream, dns_stream_free);\n\nint dns_stream_new(\n                Manager *m,\n                DnsStream **ret,\n                DnsProtocol protocol,\n                int fd,\n                const union sockaddr_union *tfo_address) {\n\n        _cleanup_(dns_stream_unrefp) DnsStream *s = NULL;\n        int r;\n\n        assert(m);\n        assert(ret);\n        assert(fd >= 0);\n\n        if (m->n_dns_streams > DNS_STREAMS_MAX)\n                return -EBUSY;\n\n        s = new(DnsStream, 1);\n        if (!s)\n                return -ENOMEM;\n\n        *s = (DnsStream) {\n                .n_ref = 1,\n                .fd = -1,\n                .protocol = protocol,\n        };\n\n        r = ordered_set_ensure_allocated(&s->write_queue, &dns_packet_hash_ops);\n        if (r < 0)\n                return r;\n\n        r = sd_event_add_io(m->event, &s->io_event_source, fd, EPOLLIN, on_stream_io, s);\n        if (r < 0)\n                return r;\n\n        (void) sd_event_source_set_description(s->io_event_source, \"dns-stream-io\");\n\n        r = sd_event_add_time(\n                        m->event,\n                        &s->timeout_event_source,\n                        clock_boottime_or_monotonic(),\n                        now(clock_boottime_or_monotonic()) + DNS_STREAM_TIMEOUT_USEC, 0,\n                        on_stream_timeout, s);\n        if (r < 0)\n                return r;\n\n        (void) sd_event_source_set_description(s->timeout_event_source, \"dns-stream-timeout\");\n\n        LIST_PREPEND(streams, m->dns_streams, s);\n        m->n_dns_streams++;\n        s->manager = m;\n\n        s->fd = fd;\n\n        if (tfo_address) {\n                s->tfo_address = *tfo_address;\n                s->tfo_salen = tfo_address->sa.sa_family == AF_INET6 ? sizeof(tfo_address->in6) : sizeof(tfo_address->in);\n        }\n\n        *ret = TAKE_PTR(s);\n\n        return 0;\n}\n\nint dns_stream_write_packet(DnsStream *s, DnsPacket *p) {\n        int r;\n\n        assert(s);\n        assert(p);\n\n        r = ordered_set_put(s->write_queue, p);\n        if (r < 0)\n                return r;\n\n        dns_packet_ref(p);\n\n        return dns_stream_update_io(s);\n}\n\nDnsPacket *dns_stream_take_read_packet(DnsStream *s) {\n        assert(s);\n\n        if (!s->read_packet)\n                return NULL;\n\n        if (s->n_read < sizeof(s->read_size))\n                return NULL;\n\n        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size))\n                return NULL;\n\n        s->n_read = 0;\n        return TAKE_PTR(s->read_packet);\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: LGPL-2.1+ */\n\n#include <netinet/tcp.h>\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"io-util.h\"\n#include \"missing.h\"\n#include \"resolved-dns-stream.h\"\n\n#define DNS_STREAM_TIMEOUT_USEC (10 * USEC_PER_SEC)\n#define DNS_STREAMS_MAX 128\n\nstatic void dns_stream_stop(DnsStream *s) {\n        assert(s);\n\n        s->io_event_source = sd_event_source_unref(s->io_event_source);\n        s->timeout_event_source = sd_event_source_unref(s->timeout_event_source);\n        s->fd = safe_close(s->fd);\n}\n\nstatic int dns_stream_update_io(DnsStream *s) {\n        int f = 0;\n\n        assert(s);\n\n        if (s->write_packet && s->n_written < sizeof(s->write_size) + s->write_packet->size)\n                f |= EPOLLOUT;\n        else if (!ordered_set_isempty(s->write_queue)) {\n                dns_packet_unref(s->write_packet);\n                s->write_packet = ordered_set_steal_first(s->write_queue);\n                s->write_size = htobe16(s->write_packet->size);\n                s->n_written = 0;\n                f |= EPOLLOUT;\n        }\n        if (!s->read_packet || s->n_read < sizeof(s->read_size) + s->read_packet->size)\n                f |= EPOLLIN;\n\n#if ENABLE_DNS_OVER_TLS\n        /* For handshake and clean closing purposes, TLS can override requested events */\n        if (s->dnstls_events)\n                f = s->dnstls_events;\n#endif\n\n        return sd_event_source_set_io_events(s->io_event_source, f);\n}\n\nstatic int dns_stream_complete(DnsStream *s, int error) {\n        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); /* Protect stream while we process it */\n\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n\n        if (s->complete)\n                s->complete(s, error);\n        else /* the default action if no completion function is set is to close the stream */\n                dns_stream_unref(s);\n\n        return 0;\n}\n\nstatic int dns_stream_identify(DnsStream *s) {\n        union {\n                struct cmsghdr header; /* For alignment */\n                uint8_t buffer[CMSG_SPACE(MAXSIZE(struct in_pktinfo, struct in6_pktinfo))\n                               + EXTRA_CMSG_SPACE /* kernel appears to require extra space */];\n        } control;\n        struct msghdr mh = {};\n        struct cmsghdr *cmsg;\n        socklen_t sl;\n        int r;\n\n        assert(s);\n\n        if (s->identified)\n                return 0;\n\n        /* Query the local side */\n        s->local_salen = sizeof(s->local);\n        r = getsockname(s->fd, &s->local.sa, &s->local_salen);\n        if (r < 0)\n                return -errno;\n        if (s->local.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->local.in6.sin6_scope_id;\n\n        /* Query the remote side */\n        s->peer_salen = sizeof(s->peer);\n        r = getpeername(s->fd, &s->peer.sa, &s->peer_salen);\n        if (r < 0)\n                return -errno;\n        if (s->peer.sa.sa_family == AF_INET6 && s->ifindex <= 0)\n                s->ifindex = s->peer.in6.sin6_scope_id;\n\n        /* Check consistency */\n        assert(s->peer.sa.sa_family == s->local.sa.sa_family);\n        assert(IN_SET(s->peer.sa.sa_family, AF_INET, AF_INET6));\n\n        /* Query connection meta information */\n        sl = sizeof(control);\n        if (s->peer.sa.sa_family == AF_INET) {\n                r = getsockopt(s->fd, IPPROTO_IP, IP_PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else if (s->peer.sa.sa_family == AF_INET6) {\n\n                r = getsockopt(s->fd, IPPROTO_IPV6, IPV6_2292PKTOPTIONS, &control, &sl);\n                if (r < 0)\n                        return -errno;\n        } else\n                return -EAFNOSUPPORT;\n\n        mh.msg_control = &control;\n        mh.msg_controllen = sl;\n\n        CMSG_FOREACH(cmsg, &mh) {\n\n                if (cmsg->cmsg_level == IPPROTO_IPV6) {\n                        assert(s->peer.sa.sa_family == AF_INET6);\n\n                        switch (cmsg->cmsg_type) {\n\n                        case IPV6_PKTINFO: {\n                                struct in6_pktinfo *i = (struct in6_pktinfo*) CMSG_DATA(cmsg);\n\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi6_ifindex;\n                                break;\n                        }\n\n                        case IPV6_HOPLIMIT:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n\n                } else if (cmsg->cmsg_level == IPPROTO_IP) {\n                        assert(s->peer.sa.sa_family == AF_INET);\n\n                        switch (cmsg->cmsg_type) {\n\n                        case IP_PKTINFO: {\n                                struct in_pktinfo *i = (struct in_pktinfo*) CMSG_DATA(cmsg);\n\n                                if (s->ifindex <= 0)\n                                        s->ifindex = i->ipi_ifindex;\n                                break;\n                        }\n\n                        case IP_TTL:\n                                s->ttl = *(int *) CMSG_DATA(cmsg);\n                                break;\n                        }\n                }\n        }\n\n        /* The Linux kernel sets the interface index to the loopback\n         * device if the connection came from the local host since it\n         * avoids the routing table in such a case. Let's unset the\n         * interface index in such a case. */\n        if (s->ifindex == LOOPBACK_IFINDEX)\n                s->ifindex = 0;\n\n        /* If we don't know the interface index still, we look for the\n         * first local interface with a matching address. Yuck! */\n        if (s->ifindex <= 0)\n                s->ifindex = manager_find_ifindex(s->manager, s->local.sa.sa_family, s->local.sa.sa_family == AF_INET ? (union in_addr_union*) &s->local.in.sin_addr : (union in_addr_union*)  &s->local.in6.sin6_addr);\n\n        if (s->protocol == DNS_PROTOCOL_LLMNR && s->ifindex > 0) {\n                uint32_t ifindex = htobe32(s->ifindex);\n\n                /* Make sure all packets for this connection are sent on the same interface */\n                if (s->local.sa.sa_family == AF_INET) {\n                        r = setsockopt(s->fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IP_UNICAST_IF: %m\");\n                } else if (s->local.sa.sa_family == AF_INET6) {\n                        r = setsockopt(s->fd, IPPROTO_IPV6, IPV6_UNICAST_IF, &ifindex, sizeof(ifindex));\n                        if (r < 0)\n                                log_debug_errno(errno, \"Failed to invoke IPV6_UNICAST_IF: %m\");\n                }\n        }\n\n        s->identified = true;\n\n        return 0;\n}\n\nssize_t dns_stream_writev(DnsStream *s, const struct iovec *iov, size_t iovcnt, int flags) {\n        ssize_t m;\n\n        assert(s);\n        assert(iov);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted && !(flags & DNS_STREAM_WRITE_TLS_DATA)) {\n                ssize_t ss;\n                size_t i;\n\n                m = 0;\n                for (i = 0; i < iovcnt; i++) {\n                        ss = dnstls_stream_write(s, iov[i].iov_base, iov[i].iov_len);\n                        if (ss < 0)\n                                return ss;\n\n                        m += ss;\n                        if (ss != (ssize_t) iov[i].iov_len)\n                                continue;\n                }\n        } else\n#endif\n        if (s->tfo_salen > 0) {\n                struct msghdr hdr = {\n                        .msg_iov = (struct iovec*) iov,\n                        .msg_iovlen = iovcnt,\n                        .msg_name = &s->tfo_address.sa,\n                        .msg_namelen = s->tfo_salen\n                };\n\n                m = sendmsg(s->fd, &hdr, MSG_FASTOPEN);\n                if (m < 0) {\n                        if (errno == EOPNOTSUPP) {\n                                s->tfo_salen = 0;\n                                if (connect(s->fd, &s->tfo_address.sa, s->tfo_salen) < 0)\n                                        return -errno;\n\n                                return -EAGAIN;\n                        }\n                        if (errno == EINPROGRESS)\n                                return -EAGAIN;\n\n                        return -errno;\n                } else\n                        s->tfo_salen = 0; /* connection is made */\n        } else {\n                m = writev(s->fd, iov, iovcnt);\n                if (m < 0)\n                        return -errno;\n        }\n\n        return m;\n}\n\nstatic ssize_t dns_stream_read(DnsStream *s, void *buf, size_t count) {\n        ssize_t ss;\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted)\n                ss = dnstls_stream_read(s, buf, count);\n        else\n#endif\n        {\n                ss = read(s->fd, buf, count);\n                if (ss < 0)\n                        return -errno;\n        }\n\n        return ss;\n}\n\nstatic int on_stream_timeout(sd_event_source *es, usec_t usec, void *userdata) {\n        DnsStream *s = userdata;\n\n        assert(s);\n\n        return dns_stream_complete(s, ETIMEDOUT);\n}\n\nstatic int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {\n        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); /* Protect stream while we process it */\n        int r;\n\n        assert(s);\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                r = dnstls_stream_on_io(s, revents);\n                if (r == DNSTLS_STREAM_CLOSED)\n                        return 0;\n                if (r == -EAGAIN)\n                        return dns_stream_update_io(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n\n                r = dns_stream_update_io(s);\n                if (r < 0)\n                        return r;\n        }\n#endif\n\n        /* only identify after connecting */\n        if (s->tfo_salen == 0) {\n                r = dns_stream_identify(s);\n                if (r < 0)\n                        return dns_stream_complete(s, -r);\n        }\n\n        if ((revents & EPOLLOUT) &&\n            s->write_packet &&\n            s->n_written < sizeof(s->write_size) + s->write_packet->size) {\n\n                struct iovec iov[2];\n                ssize_t ss;\n\n                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));\n                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);\n\n                IOVEC_INCREMENT(iov, 2, s->n_written);\n\n                ss = dns_stream_writev(s, iov, 2, 0);\n                if (ss < 0) {\n                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                return dns_stream_complete(s, -ss);\n                } else\n                        s->n_written += ss;\n\n                /* Are we done? If so, disable the event source for EPOLLOUT */\n                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {\n                        r = dns_stream_update_io(s);\n                        if (r < 0)\n                                return dns_stream_complete(s, -r);\n                }\n        }\n\n        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&\n            (!s->read_packet ||\n             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {\n\n                if (s->n_read < sizeof(s->read_size)) {\n                        ssize_t ss;\n\n                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);\n                        if (ss < 0) {\n                                if (!IN_SET(-ss, EINTR, EAGAIN))\n                                        return dns_stream_complete(s, -ss);\n                        } else if (ss == 0)\n                                return dns_stream_complete(s, ECONNRESET);\n                        else\n                                s->n_read += ss;\n                }\n\n                if (s->n_read >= sizeof(s->read_size)) {\n\n                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)\n                                return dns_stream_complete(s, EBADMSG);\n\n                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {\n                                ssize_t ss;\n\n                                if (!s->read_packet) {\n                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);\n                                        if (r < 0)\n                                                return dns_stream_complete(s, -r);\n\n                                        s->read_packet->size = be16toh(s->read_size);\n                                        s->read_packet->ipproto = IPPROTO_TCP;\n                                        s->read_packet->family = s->peer.sa.sa_family;\n                                        s->read_packet->ttl = s->ttl;\n                                        s->read_packet->ifindex = s->ifindex;\n\n                                        if (s->read_packet->family == AF_INET) {\n                                                s->read_packet->sender.in = s->peer.in.sin_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);\n                                                s->read_packet->destination.in = s->local.in.sin_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);\n                                        } else {\n                                                assert(s->read_packet->family == AF_INET6);\n                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;\n                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);\n                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;\n                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);\n\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;\n                                                if (s->read_packet->ifindex == 0)\n                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;\n                                        }\n                                }\n\n                                ss = dns_stream_read(s,\n                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),\n                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);\n                                if (ss < 0) {\n                                        if (!IN_SET(-ss, EINTR, EAGAIN))\n                                                return dns_stream_complete(s, -ss);\n                                } else if (ss == 0)\n                                        return dns_stream_complete(s, ECONNRESET);\n                                else\n                                        s->n_read += ss;\n                        }\n\n                        /* Are we done? If so, disable the event source for EPOLLIN */\n                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {\n                                /* If there's a packet handler\n                                 * installed, call that. Note that\n                                 * this is optional... */\n                                if (s->on_packet) {\n                                        r = s->on_packet(s);\n                                        if (r < 0)\n                                                return r;\n                                }\n\n                                r = dns_stream_update_io(s);\n                                if (r < 0)\n                                        return dns_stream_complete(s, -r);\n                        }\n                }\n        }\n\n        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&\n            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))\n                return dns_stream_complete(s, 0);\n\n        return 0;\n}\n\nstatic DnsStream *dns_stream_free(DnsStream *s) {\n        DnsPacket *p;\n        Iterator i;\n\n        assert(s);\n\n        dns_stream_stop(s);\n\n        if (s->server && s->server->stream == s)\n                s->server->stream = NULL;\n\n        if (s->manager) {\n                LIST_REMOVE(streams, s->manager->dns_streams, s);\n                s->manager->n_dns_streams--;\n        }\n\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted)\n                dnstls_stream_free(s);\n#endif\n\n        ORDERED_SET_FOREACH(p, s->write_queue, i)\n                dns_packet_unref(ordered_set_remove(s->write_queue, p));\n\n        dns_packet_unref(s->write_packet);\n        dns_packet_unref(s->read_packet);\n        dns_server_unref(s->server);\n\n        ordered_set_free(s->write_queue);\n\n        return mfree(s);\n}\n\nDEFINE_TRIVIAL_REF_UNREF_FUNC(DnsStream, dns_stream, dns_stream_free);\n\nint dns_stream_new(\n                Manager *m,\n                DnsStream **ret,\n                DnsProtocol protocol,\n                int fd,\n                const union sockaddr_union *tfo_address) {\n\n        _cleanup_(dns_stream_unrefp) DnsStream *s = NULL;\n        int r;\n\n        assert(m);\n        assert(ret);\n        assert(fd >= 0);\n\n        if (m->n_dns_streams > DNS_STREAMS_MAX)\n                return -EBUSY;\n\n        s = new(DnsStream, 1);\n        if (!s)\n                return -ENOMEM;\n\n        *s = (DnsStream) {\n                .n_ref = 1,\n                .fd = -1,\n                .protocol = protocol,\n        };\n\n        r = ordered_set_ensure_allocated(&s->write_queue, &dns_packet_hash_ops);\n        if (r < 0)\n                return r;\n\n        r = sd_event_add_io(m->event, &s->io_event_source, fd, EPOLLIN, on_stream_io, s);\n        if (r < 0)\n                return r;\n\n        (void) sd_event_source_set_description(s->io_event_source, \"dns-stream-io\");\n\n        r = sd_event_add_time(\n                        m->event,\n                        &s->timeout_event_source,\n                        clock_boottime_or_monotonic(),\n                        now(clock_boottime_or_monotonic()) + DNS_STREAM_TIMEOUT_USEC, 0,\n                        on_stream_timeout, s);\n        if (r < 0)\n                return r;\n\n        (void) sd_event_source_set_description(s->timeout_event_source, \"dns-stream-timeout\");\n\n        LIST_PREPEND(streams, m->dns_streams, s);\n        m->n_dns_streams++;\n        s->manager = m;\n\n        s->fd = fd;\n\n        if (tfo_address) {\n                s->tfo_address = *tfo_address;\n                s->tfo_salen = tfo_address->sa.sa_family == AF_INET6 ? sizeof(tfo_address->in6) : sizeof(tfo_address->in);\n        }\n\n        *ret = TAKE_PTR(s);\n\n        return 0;\n}\n\nint dns_stream_write_packet(DnsStream *s, DnsPacket *p) {\n        int r;\n\n        assert(s);\n        assert(p);\n\n        r = ordered_set_put(s->write_queue, p);\n        if (r < 0)\n                return r;\n\n        dns_packet_ref(p);\n\n        return dns_stream_update_io(s);\n}\n\nDnsPacket *dns_stream_take_read_packet(DnsStream *s) {\n        assert(s);\n\n        if (!s->read_packet)\n                return NULL;\n\n        if (s->n_read < sizeof(s->read_size))\n                return NULL;\n\n        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size))\n                return NULL;\n\n        s->n_read = 0;\n        return TAKE_PTR(s->read_packet);\n}\n"], "filenames": ["src/resolve/resolved-dns-stream.c"], "buggy_code_start_loc": [48], "buggy_code_end_loc": [277], "fixing_code_start_loc": [49], "fixing_code_end_loc": [279], "type": "CWE-416", "message": "A use-after-free vulnerability was found in systemd. This issue occurs due to the on_stream_io() function and dns_stream_complete() function in 'resolved-dns-stream.c' not incrementing the reference counting for the DnsStream object. Therefore, other functions and callbacks called can dereference the DNSStream object, causing the use-after-free when the reference is still used later.", "other": {"cve": {"id": "CVE-2022-2526", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-09T15:15:10.107", "lastModified": "2023-01-20T03:17:34.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free vulnerability was found in systemd. This issue occurs due to the on_stream_io() function and dns_stream_complete() function in 'resolved-dns-stream.c' not incrementing the reference counting for the DnsStream object. Therefore, other functions and callbacks called can dereference the DNSStream object, causing the use-after-free when the reference is still used later."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad de uso de memoria previamente liberada en systemd. Este problema ocurre debido a que las funciones on_stream_io() y dns_stream_complete() en \"resolved-dns-stream.c\" no incrementan el conteo de referencias para el objeto DnsStream. Por lo tanto, otras funciones y callbacks llamados pueden hacer referencia al objeto DNSStream, causando un uso de memoria previamente liberada cuando la referencia sigue us\u00e1ndose m\u00e1s tarde"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systemd_project:systemd:240:*:*:*:*:*:*:*", "matchCriteriaId": "161BE658-86CC-4F76-8F55-7371B1CE551F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}], "references": [{"url": "https://github.com/systemd/systemd/commit/d973d94dec349fb676fdd844f6fe2ada3538f27c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221111-0005/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/systemd/systemd/commit/d973d94dec349fb676fdd844f6fe2ada3538f27c"}}