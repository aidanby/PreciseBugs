{"buggy_code": ["require \"i18n\"\nrequire \"active_support/core_ext/string/output_safety\"\nrequire \"redcarpet\"\n\nmodule TextHelpers\n\n  class ExternalLinks < Redcarpet::Render::HTML\n\n    PROTOCOL_MATCHER = /\\Ahttp/.freeze\n\n    def link(link, title, content)\n      attributes = [\n        (\"href=\\\"#{link}\\\"\" if link),\n        (\"title=\\\"#{title}\\\"\" if title),\n        (\"target=\\\"_blank\\\"\" if link =~ PROTOCOL_MATCHER),\n      ]\n\n      \"<a #{attributes.compact.join(\" \")}>#{content}</a>\"\n    end\n\n  end\n\n  module Translation\n\n    ORPHAN_MATCHER = /(\\w+)[ \\t](?![^<]*>)(\\S+\\s*<\\/(?:p|li)>)/.freeze\n    KEYPATH_MATCHER = /!([\\w.\\/]+)!/.freeze\n\n    # Public: Get the I18n localized text for the passed key.\n    #\n    # key     - The desired I18n lookup key.\n    # options - A Hash of options to forward to the `I18n.t` lookup.\n    #           :smart - Whether or not to apply smart quoting to the output.\n    #                    Defaults to true.\n    #\n    # Returns a String resulting from the I18n lookup.\n    def text(key, options = {})\n      options = html_safe_options(options)\n      text = I18n.t(key, **{\n        scope: self.translation_scope,\n        default: \"!#{key}!\",\n        cascade: true,\n      }.merge(options)).strip\n\n      interpolation_options = { cascade: true }.merge(options)\n\n      # Interpolate any keypaths (e.g., `!some.lookup.path/key!`) found in the text.\n      while text =~ KEYPATH_MATCHER do\n        text = text.gsub(KEYPATH_MATCHER) { |match| I18n.t($1, **interpolation_options) }\n      end\n\n      text = smartify(text) if options.fetch(:smart, true)\n      text.html_safe\n    end\n\n    # Public: Get an HTML representation of the rendered markdown for the passed I18n key.\n    #\n    # key     - The desired I18n lookup key.\n    # options - A Hash of options to pass through to the lookup.\n    #           :inline  - A special option that will remove the enclosing <p>\n    #                      tags when set to true.\n    #           :orphans - A special option that will prevent the insertion of\n    #                      non-breaking space characters at the end of each\n    #                      paragraph when set to true.\n    #\n    # Returns a String containing the localized text rendered via Markdown\n    def html(key, options = {})\n      rendered = markdown(text(key, options.merge(smart: false)))\n\n      rendered = options[:orphans] ? rendered : rendered.gsub(ORPHAN_MATCHER, '\\1&nbsp;\\2')\n      rendered = rendered.gsub(/<\\/?p>/, '') if options[:inline]\n      rendered.html_safe\n    end\n\n    protected\n\n    # Protected: Render the passed text as HTML via Markdown.\n    #\n    # text - A String representing the text which should be rendered to HTML.\n    #\n    # Returns a String.\n    def markdown(text)\n      @renderer ||= Redcarpet::Markdown.new(ExternalLinks, no_intra_emphasis: true)\n      smartify(@renderer.render(text))\n    end\n\n    # Internal: Auto-apply smart quotes to the passed text.\n    #\n    # text - A String which should be passed through the SmartyPants renderer.\n    #\n    # Returns a String.\n    def smartify(text)\n      Redcarpet::Render::SmartyPants.render(text)\n    end\n\n    # Internal: The proper scope for I18n translation.\n    #\n    # Must be implemented by any classes which include this module.\n    #\n    # Raises NotImplementedError.\n    def translation_scope\n      raise NotImplementedError, \"must implement a public method `translation_scope` to determine I18n scope\"\n    end\n\n    # Internal: Convert all passed in arguments into html-safe strings\n    #\n    # hash - a set of key-value pairs, which converts the second argument into an html-safe string\n    #\n    # Returns a hash\n    def html_safe_options(hash)\n      hash.inject({}) do |result, (key, value)|\n        result[key] = case value\n          when String\n            ERB::Util.h(value)\n          else\n            value\n          end\n\n        result\n      end\n    end\n  end\nend\n", "require_relative \"../../test_helper\"\n\ndescribe TextHelpers::Translation do\n  before do\n    @helper = Object.send(:include, TextHelpers::Translation).new\n  end\n\n  describe \"given a stored I18n lookup\" do\n    before do\n      @scoped_text = \"Scoped lookup\"\n      @global_text = \"Global lookup\"\n      @single_word_text = \"Single\"\n      @email_address = \"user@example.org\"\n      @multiline_text = <<-MULTI.gsub(/^[ \\t]+/, '')\n        This is some multiline text.\n\n        It should include multiple paragraphs.\n      MULTI\n\n      @nb_scoped_text = \"Scoped&nbsp;lookup\"\n\n      I18n.exception_handler = nil\n\n      I18n.backend.store_translations :en, {\n        test_key: @global_text,\n        multiline_key: @multiline_text,\n        interpolated_key: \"%{interpolate_with}\",\n        internal_link: \"[Internal link](/internal/path)\",\n        external_link: \"[External link](http://external.com)\",\n        test: {\n          email_key:               \"<#{@email_address}>\",\n          test_key:                \"*#{@scoped_text}*\",\n          list_key:                \"* #{@scoped_text}\",\n          single_word_list_key:    \"* #{@single_word_text}\",\n          prerendered_html_key:    \"<ul>\\n <li> Get everything you ever wanted</li>\\n <li> Practically-guaranteed</li>\\n </ul>\",\n          interpolated_key:        \"Global? (!test_key!)\",\n          interpolated_scoped_key: \"Global? (!test_scoped_key!)\",\n          interpol_arg_key:        \"Interpolate global? (!interpolated_key!)\",\n          recursive_key:           \"Recursively !test.interpolated_key!\",\n          quoted_key:              \"They're looking for \\\"#{@global_text}\\\"--#{@scoped_text}\",\n          argument_key:            \"This is what %{user} said\",\n          number_key:              \"120\\\"\",\n          pluralized_key: {\n            one:            \"A single piece of text\",\n            other:          \"%{count} pieces of text\"\n          }\n        }\n      }\n    end\n\n    after do\n      I18n.backend.reload!\n    end\n\n    describe \"for a specified scope\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'test'\n        end\n      end\n\n      it \"looks up the text for the key in a scope derived from the call stack\" do\n        assert_equal \"*#{@scoped_text}*\", @helper.text(:test_key)\n      end\n\n      it \"converts the text to HTML via Markdown\" do\n        assert_equal \"<p><em>#{@nb_scoped_text}</em></p>\\n\", @helper.html(:test_key)\n      end\n\n      it \"handles orphans within HTML list items\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n        <ul>\n        <li>#{@nb_scoped_text}</li>\n        </ul>\n        EXPECTED\n\n        assert_equal expected, @helper.html(:list_key)\n      end\n\n      it \"does not inject `&nbsp;` entities in HTML list items unnecessarily\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n        <ul>\n        <li>#{@single_word_text}</li>\n        </ul>\n        EXPECTED\n\n        assert_equal expected, @helper.html(:single_word_list_key)\n      end\n\n      it \"correctly handles orphans in HTML with erratic whitespace\" do\n        expected = \"<ul>\\n <li> Get everything you ever&nbsp;wanted</li>\\n <li> Practically-guaranteed</li>\\n </ul>\\n\"\n\n        assert_equal expected, @helper.html(:prerendered_html_key)\n      end\n\n      it \"does not modify HTML tags\" do\n        expected = \"<p><a href=\\\"mailto:#{@email_address}\\\">#{@email_address}</a></p>\\n\"\n        assert_equal expected, @helper.html(:email_key)\n      end\n\n      it \"allows orphaned text with :orphans\" do\n        assert_equal \"<p><em>#{@scoped_text}</em></p>\\n\", @helper.html(:test_key, orphans: true)\n      end\n\n      it \"correctly eliminates orphans across multiple paragraphs\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n          <p>This is some multiline&nbsp;text.</p>\n\n          <p>It should include multiple&nbsp;paragraphs.</p>\n        EXPECTED\n        assert_equal expected, @helper.html(:multiline_key)\n      end\n\n      it \"removes the enclosing paragraph with :inline\" do\n        assert_equal \"<em>#{@nb_scoped_text}</em>\\n\", @helper.html(:test_key, inline: true)\n      end\n\n      it \"correctly combines :orphans and :inline options\" do\n        assert_equal \"<em>#{@scoped_text}</em>\\n\", @helper.html(:test_key, inline: true, orphans: true)\n      end\n\n      it \"renders internal links without a target\" do\n        assert_equal \"<a href=\\\"/internal/path\\\">Internal&nbsp;link</a>\\n\", @helper.html(:internal_link, inline: true)\n      end\n\n      it \"renders external links with target='_blank'\" do\n        assert_equal \"<a href=\\\"http://external.com\\\" target=\\\"_blank\\\">External&nbsp;link</a>\\n\", @helper.html(:external_link, inline: true)\n      end\n\n      it \"interpolates values wrapped in !!\" do\n        assert_equal \"Global? (#{@global_text})\", @helper.text(:interpolated_key)\n      end\n\n      it \"interpolates contents of scopes wrapped in !!\" do\n        assert_equal \"Interpolate global? (My interpolated text)\", @helper.text(:interpol_arg_key, interpolate_with: \"My interpolated text\")\n      end\n\n      it \"handles recursive interpolation\" do\n        assert_equal \"Recursively Global? (#{@global_text})\", @helper.text(:recursive_key)\n      end\n\n      it \"applies smart quotes to text by default\" do\n        assert_equal \"They&rsquo;re looking for &ldquo;#{@global_text}&rdquo;&ndash;#{@scoped_text}\", @helper.text(:quoted_key)\n      end\n\n      it \"allows smart quoting to be disabled\" do\n        assert_equal \"They're looking for \\\"#{@global_text}\\\"--#{@scoped_text}\", @helper.text(:quoted_key, smart: false)\n      end\n\n      it \"automatically converts quotes and dashes to clean HTML replacements\" do\n        assert_equal \"<p>They&rsquo;re looking for &ldquo;#{@global_text}&rdquo;&ndash;#{@nb_scoped_text}</p>\\n\", @helper.html(:quoted_key)\n      end\n\n      it \"converts to straight quotes in the general case\" do\n        assert_equal \"120&quot;\", @helper.text(:number_key) # 120\"\n      end\n\n      it \"handles i18n arguments\" do\n        assert_equal \"This is what Han Solo said\", @helper.text(:argument_key, user: \"Han Solo\")\n      end\n\n      it \"handles i18n arguments which are not strings\" do\n        assert_equal \"This is what 1234 said\", @helper.text(:argument_key, user: 1234)\n      end\n\n      it \"handles i18n arguments which are not html-safe\" do\n        assert_equal \"This is what &lt;b&gt;Han&lt;/b&gt; Solo said\", @helper.text(:argument_key, user: \"<b>Han</b> Solo\")\n      end\n\n      it \"handles i18n arguments which are html-safe\" do\n        assert_equal \"This is what <b>Han</b> Solo said\", @helper.text(:argument_key, user: \"<b>Han</b> Solo\".html_safe)\n      end\n\n      it \"correctly handles pluralized keys\" do\n        assert_equal \"A single piece of text\", @helper.text(:pluralized_key, count: 1)\n        assert_equal \"2 pieces of text\", @helper.text(:pluralized_key, count: 2)\n      end\n\n      describe \"when the pluralization backend is configured and the exception handler is enabled\" do\n        before do\n          @original_backend = I18n.backend\n          new_backend = @original_backend.dup\n          new_backend.extend(I18n::Backend::Pluralization)\n          I18n.backend = new_backend\n\n          @original_exception_handler = I18n.exception_handler\n          I18n.exception_handler = TextHelpers::RaiseExceptionHandler.new\n        end\n\n        after do\n          I18n.backend = @original_backend\n          I18n.exception_handler = @original_exception_handler\n        end\n\n        it \"correctly handles pluralized keys\" do\n          assert_equal \"A single piece of text\", @helper.text(:pluralized_key, count: 1)\n          assert_equal \"2 pieces of text\", @helper.text(:pluralized_key, count: 2)\n        end\n      end\n    end\n\n    describe \"when no valid scope is provided\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'nonexistent'\n        end\n      end\n\n      it \"defaults to a globally-defined value for the key\" do\n        assert_equal @global_text, @helper.text(:test_key)\n      end\n    end\n\n    describe \"when a scope is given as an option\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'test'\n        end\n      end\n\n      it \"shows translation missing if an interpolated key isn't found at the same scope\" do\n        expected = \"Global? (translation missing: en.test.test_scoped_key)\"\n        assert_equal expected, @helper.text(:interpolated_scoped_key, scope: \"test\")\n      end\n\n      it \"interpolates the key if one is found at the same scope\" do\n        I18n.backend.store_translations(:en, {\n          test: {test_scoped_key: \"a translation\"}})\n\n        assert_equal \"Global? (a translation)\", @helper.text(:interpolated_scoped_key, scope: \"test\")\n      end\n\n      describe \"with the Cascade backend in place\" do\n        before do\n          @original_backend = I18n.backend\n          new_backend = @original_backend.dup\n          new_backend.extend(I18n::Backend::Cascade)\n          I18n.backend = new_backend\n        end\n\n        after do\n          I18n.backend = @original_backend\n        end\n\n        it \"cascades the requested key by default\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n          assert_equal \"a translation\", @helper.text(:test_scoped_key, scope: \"some.unnecessary.scope\")\n\n          I18n.backend.store_translations(:en, {some: {test_scoped_key: \"a scoped translation\"}})\n          assert_equal \"a scoped translation\", @helper.text(:test_scoped_key, scope: \"some.unnecessary.scope\")\n        end\n\n        it \"cascades the interpolated key by default\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n\n          assert_equal \"Global? (a translation)\", @helper.text(:interpolated_scoped_key, scope: \"test\")\n        end\n\n        it \"doesn't cascade if cascade: false is passed\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n\n          expected = \"Global? (translation missing: en.test.test_scoped_key)\"\n          assert_equal expected, @helper.text(:interpolated_scoped_key, scope: \"test\", cascade: false)\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["require \"i18n\"\nrequire \"active_support/core_ext/string/output_safety\"\nrequire \"redcarpet\"\n\nmodule TextHelpers\n\n  class ExternalLinks < Redcarpet::Render::HTML\n\n    PROTOCOL_MATCHER = /\\Ahttp/.freeze\n\n    def link(link, title, content)\n      attributes = [\n        (\"href=\\\"#{link}\\\"\" if link),\n        (\"title=\\\"#{title}\\\"\" if title),\n        (\"target=\\\"_blank\\\" rel=\\\"noopener\\\"\" if link.match?(PROTOCOL_MATCHER)),\n      ]\n\n      \"<a #{attributes.compact.join(\" \")}>#{content}</a>\"\n    end\n\n  end\n\n  module Translation\n\n    ORPHAN_MATCHER = /(\\w+)[ \\t](?![^<]*>)(\\S+\\s*<\\/(?:p|li)>)/.freeze\n    KEYPATH_MATCHER = /!([\\w.\\/]+)!/.freeze\n\n    # Public: Get the I18n localized text for the passed key.\n    #\n    # key     - The desired I18n lookup key.\n    # options - A Hash of options to forward to the `I18n.t` lookup.\n    #           :smart - Whether or not to apply smart quoting to the output.\n    #                    Defaults to true.\n    #\n    # Returns a String resulting from the I18n lookup.\n    def text(key, options = {})\n      options = html_safe_options(options)\n      text = I18n.t(key, **{\n        scope: self.translation_scope,\n        default: \"!#{key}!\",\n        cascade: true,\n      }.merge(options)).strip\n\n      interpolation_options = { cascade: true }.merge(options)\n\n      # Interpolate any keypaths (e.g., `!some.lookup.path/key!`) found in the text.\n      while text.match?(KEYPATH_MATCHER) do\n        text = text.gsub(KEYPATH_MATCHER) { |match| I18n.t($1, **interpolation_options) }\n      end\n\n      text = smartify(text) if options.fetch(:smart, true)\n      text.html_safe\n    end\n\n    # Public: Get an HTML representation of the rendered markdown for the passed I18n key.\n    #\n    # key     - The desired I18n lookup key.\n    # options - A Hash of options to pass through to the lookup.\n    #           :inline  - A special option that will remove the enclosing <p>\n    #                      tags when set to true.\n    #           :orphans - A special option that will prevent the insertion of\n    #                      non-breaking space characters at the end of each\n    #                      paragraph when set to true.\n    #\n    # Returns a String containing the localized text rendered via Markdown\n    def html(key, options = {})\n      rendered = markdown(text(key, options.merge(smart: false)))\n\n      rendered = options[:orphans] ? rendered : rendered.gsub(ORPHAN_MATCHER, '\\1&nbsp;\\2')\n      rendered = rendered.gsub(/<\\/?p>/, '') if options[:inline]\n      rendered.html_safe\n    end\n\n    protected\n\n    # Protected: Render the passed text as HTML via Markdown.\n    #\n    # text - A String representing the text which should be rendered to HTML.\n    #\n    # Returns a String.\n    def markdown(text)\n      @renderer ||= Redcarpet::Markdown.new(ExternalLinks, no_intra_emphasis: true)\n      smartify(@renderer.render(text))\n    end\n\n    # Internal: Auto-apply smart quotes to the passed text.\n    #\n    # text - A String which should be passed through the SmartyPants renderer.\n    #\n    # Returns a String.\n    def smartify(text)\n      Redcarpet::Render::SmartyPants.render(text)\n    end\n\n    # Internal: The proper scope for I18n translation.\n    #\n    # Must be implemented by any classes which include this module.\n    #\n    # Raises NotImplementedError.\n    def translation_scope\n      raise NotImplementedError, \"must implement a public method `translation_scope` to determine I18n scope\"\n    end\n\n    # Internal: Convert all passed in arguments into html-safe strings\n    #\n    # hash - a set of key-value pairs, which converts the second argument into an html-safe string\n    #\n    # Returns a hash\n    def html_safe_options(hash)\n      hash.inject({}) do |result, (key, value)|\n        result[key] = case value\n          when String\n            ERB::Util.h(value)\n          else\n            value\n          end\n\n        result\n      end\n    end\n  end\nend\n", "require_relative \"../../test_helper\"\n\ndescribe TextHelpers::Translation do\n  before do\n    @helper = Object.send(:include, TextHelpers::Translation).new\n  end\n\n  describe \"given a stored I18n lookup\" do\n    before do\n      @scoped_text = \"Scoped lookup\"\n      @global_text = \"Global lookup\"\n      @single_word_text = \"Single\"\n      @email_address = \"user@example.org\"\n      @multiline_text = <<-MULTI.gsub(/^[ \\t]+/, '')\n        This is some multiline text.\n\n        It should include multiple paragraphs.\n      MULTI\n\n      @nb_scoped_text = \"Scoped&nbsp;lookup\"\n\n      I18n.exception_handler = nil\n\n      I18n.backend.store_translations :en, {\n        test_key: @global_text,\n        multiline_key: @multiline_text,\n        interpolated_key: \"%{interpolate_with}\",\n        internal_link: \"[Internal link](/internal/path)\",\n        external_link: \"[External link](http://external.com)\",\n        test: {\n          email_key:               \"<#{@email_address}>\",\n          test_key:                \"*#{@scoped_text}*\",\n          list_key:                \"* #{@scoped_text}\",\n          single_word_list_key:    \"* #{@single_word_text}\",\n          prerendered_html_key:    \"<ul>\\n <li> Get everything you ever wanted</li>\\n <li> Practically-guaranteed</li>\\n </ul>\",\n          interpolated_key:        \"Global? (!test_key!)\",\n          interpolated_scoped_key: \"Global? (!test_scoped_key!)\",\n          interpol_arg_key:        \"Interpolate global? (!interpolated_key!)\",\n          recursive_key:           \"Recursively !test.interpolated_key!\",\n          quoted_key:              \"They're looking for \\\"#{@global_text}\\\"--#{@scoped_text}\",\n          argument_key:            \"This is what %{user} said\",\n          number_key:              \"120\\\"\",\n          pluralized_key: {\n            one:            \"A single piece of text\",\n            other:          \"%{count} pieces of text\"\n          }\n        }\n      }\n    end\n\n    after do\n      I18n.backend.reload!\n    end\n\n    describe \"for a specified scope\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'test'\n        end\n      end\n\n      it \"looks up the text for the key in a scope derived from the call stack\" do\n        assert_equal \"*#{@scoped_text}*\", @helper.text(:test_key)\n      end\n\n      it \"converts the text to HTML via Markdown\" do\n        assert_equal \"<p><em>#{@nb_scoped_text}</em></p>\\n\", @helper.html(:test_key)\n      end\n\n      it \"handles orphans within HTML list items\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n        <ul>\n        <li>#{@nb_scoped_text}</li>\n        </ul>\n        EXPECTED\n\n        assert_equal expected, @helper.html(:list_key)\n      end\n\n      it \"does not inject `&nbsp;` entities in HTML list items unnecessarily\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n        <ul>\n        <li>#{@single_word_text}</li>\n        </ul>\n        EXPECTED\n\n        assert_equal expected, @helper.html(:single_word_list_key)\n      end\n\n      it \"correctly handles orphans in HTML with erratic whitespace\" do\n        expected = \"<ul>\\n <li> Get everything you ever&nbsp;wanted</li>\\n <li> Practically-guaranteed</li>\\n </ul>\\n\"\n\n        assert_equal expected, @helper.html(:prerendered_html_key)\n      end\n\n      it \"does not modify HTML tags\" do\n        expected = \"<p><a href=\\\"mailto:#{@email_address}\\\">#{@email_address}</a></p>\\n\"\n        assert_equal expected, @helper.html(:email_key)\n      end\n\n      it \"allows orphaned text with :orphans\" do\n        assert_equal \"<p><em>#{@scoped_text}</em></p>\\n\", @helper.html(:test_key, orphans: true)\n      end\n\n      it \"correctly eliminates orphans across multiple paragraphs\" do\n        expected = <<-EXPECTED.gsub(/^[ \\t]+/, '')\n          <p>This is some multiline&nbsp;text.</p>\n\n          <p>It should include multiple&nbsp;paragraphs.</p>\n        EXPECTED\n        assert_equal expected, @helper.html(:multiline_key)\n      end\n\n      it \"removes the enclosing paragraph with :inline\" do\n        assert_equal \"<em>#{@nb_scoped_text}</em>\\n\", @helper.html(:test_key, inline: true)\n      end\n\n      it \"correctly combines :orphans and :inline options\" do\n        assert_equal \"<em>#{@scoped_text}</em>\\n\", @helper.html(:test_key, inline: true, orphans: true)\n      end\n\n      it \"renders internal links without a target or rel\" do\n        assert_equal \"<a href=\\\"/internal/path\\\">Internal&nbsp;link</a>\\n\", @helper.html(:internal_link, inline: true)\n      end\n\n      it \"renders external links with target='_blank' and rel='noopener'\" do\n        assert_equal \"<a href=\\\"http://external.com\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">External&nbsp;link</a>\\n\", @helper.html(:external_link, inline: true)\n      end\n\n      it \"interpolates values wrapped in !!\" do\n        assert_equal \"Global? (#{@global_text})\", @helper.text(:interpolated_key)\n      end\n\n      it \"interpolates contents of scopes wrapped in !!\" do\n        assert_equal \"Interpolate global? (My interpolated text)\", @helper.text(:interpol_arg_key, interpolate_with: \"My interpolated text\")\n      end\n\n      it \"handles recursive interpolation\" do\n        assert_equal \"Recursively Global? (#{@global_text})\", @helper.text(:recursive_key)\n      end\n\n      it \"applies smart quotes to text by default\" do\n        assert_equal \"They&rsquo;re looking for &ldquo;#{@global_text}&rdquo;&ndash;#{@scoped_text}\", @helper.text(:quoted_key)\n      end\n\n      it \"allows smart quoting to be disabled\" do\n        assert_equal \"They're looking for \\\"#{@global_text}\\\"--#{@scoped_text}\", @helper.text(:quoted_key, smart: false)\n      end\n\n      it \"automatically converts quotes and dashes to clean HTML replacements\" do\n        assert_equal \"<p>They&rsquo;re looking for &ldquo;#{@global_text}&rdquo;&ndash;#{@nb_scoped_text}</p>\\n\", @helper.html(:quoted_key)\n      end\n\n      it \"converts to straight quotes in the general case\" do\n        assert_equal \"120&quot;\", @helper.text(:number_key) # 120\"\n      end\n\n      it \"handles i18n arguments\" do\n        assert_equal \"This is what Han Solo said\", @helper.text(:argument_key, user: \"Han Solo\")\n      end\n\n      it \"handles i18n arguments which are not strings\" do\n        assert_equal \"This is what 1234 said\", @helper.text(:argument_key, user: 1234)\n      end\n\n      it \"handles i18n arguments which are not html-safe\" do\n        assert_equal \"This is what &lt;b&gt;Han&lt;/b&gt; Solo said\", @helper.text(:argument_key, user: \"<b>Han</b> Solo\")\n      end\n\n      it \"handles i18n arguments which are html-safe\" do\n        assert_equal \"This is what <b>Han</b> Solo said\", @helper.text(:argument_key, user: \"<b>Han</b> Solo\".html_safe)\n      end\n\n      it \"correctly handles pluralized keys\" do\n        assert_equal \"A single piece of text\", @helper.text(:pluralized_key, count: 1)\n        assert_equal \"2 pieces of text\", @helper.text(:pluralized_key, count: 2)\n      end\n\n      describe \"when the pluralization backend is configured and the exception handler is enabled\" do\n        before do\n          @original_backend = I18n.backend\n          new_backend = @original_backend.dup\n          new_backend.extend(I18n::Backend::Pluralization)\n          I18n.backend = new_backend\n\n          @original_exception_handler = I18n.exception_handler\n          I18n.exception_handler = TextHelpers::RaiseExceptionHandler.new\n        end\n\n        after do\n          I18n.backend = @original_backend\n          I18n.exception_handler = @original_exception_handler\n        end\n\n        it \"correctly handles pluralized keys\" do\n          assert_equal \"A single piece of text\", @helper.text(:pluralized_key, count: 1)\n          assert_equal \"2 pieces of text\", @helper.text(:pluralized_key, count: 2)\n        end\n      end\n    end\n\n    describe \"when no valid scope is provided\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'nonexistent'\n        end\n      end\n\n      it \"defaults to a globally-defined value for the key\" do\n        assert_equal @global_text, @helper.text(:test_key)\n      end\n    end\n\n    describe \"when a scope is given as an option\" do\n      before do\n        @helper.define_singleton_method :translation_scope do\n          'test'\n        end\n      end\n\n      it \"shows translation missing if an interpolated key isn't found at the same scope\" do\n        expected = \"Global? (translation missing: en.test.test_scoped_key)\"\n        assert_equal expected, @helper.text(:interpolated_scoped_key, scope: \"test\")\n      end\n\n      it \"interpolates the key if one is found at the same scope\" do\n        I18n.backend.store_translations(:en, {\n          test: {test_scoped_key: \"a translation\"}})\n\n        assert_equal \"Global? (a translation)\", @helper.text(:interpolated_scoped_key, scope: \"test\")\n      end\n\n      describe \"with the Cascade backend in place\" do\n        before do\n          @original_backend = I18n.backend\n          new_backend = @original_backend.dup\n          new_backend.extend(I18n::Backend::Cascade)\n          I18n.backend = new_backend\n        end\n\n        after do\n          I18n.backend = @original_backend\n        end\n\n        it \"cascades the requested key by default\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n          assert_equal \"a translation\", @helper.text(:test_scoped_key, scope: \"some.unnecessary.scope\")\n\n          I18n.backend.store_translations(:en, {some: {test_scoped_key: \"a scoped translation\"}})\n          assert_equal \"a scoped translation\", @helper.text(:test_scoped_key, scope: \"some.unnecessary.scope\")\n        end\n\n        it \"cascades the interpolated key by default\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n\n          assert_equal \"Global? (a translation)\", @helper.text(:interpolated_scoped_key, scope: \"test\")\n        end\n\n        it \"doesn't cascade if cascade: false is passed\" do\n          I18n.backend.store_translations(:en, {test_scoped_key: \"a translation\"})\n\n          expected = \"Global? (translation missing: en.test.test_scoped_key)\"\n          assert_equal expected, @helper.text(:interpolated_scoped_key, scope: \"test\", cascade: false)\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/text_helpers/translation.rb", "test/lib/text_helpers/translation_test.rb"], "buggy_code_start_loc": [15, 122], "buggy_code_end_loc": [48, 128], "fixing_code_start_loc": [15, 122], "fixing_code_end_loc": [48, 128], "type": "CWE-1022", "message": "A vulnerability was found in ahorner text-helpers up to 1.0.x. It has been declared as critical. This vulnerability affects unknown code of the file lib/text_helpers/translation.rb. The manipulation of the argument link leads to use of web link to untrusted target with window.opener access. The attack can be initiated remotely. Upgrading to version 1.1.0 is able to address this issue. The name of the patch is 184b60ded0e43c985788582aca2d1e746f9405a3. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216520.", "other": {"cve": {"id": "CVE-2020-36624", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-22T10:15:08.853", "lastModified": "2022-12-29T16:06:41.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ahorner text-helpers up to 1.0.x. It has been declared as critical. This vulnerability affects unknown code of the file lib/text_helpers/translation.rb. The manipulation of the argument link leads to use of web link to untrusted target with window.opener access. The attack can be initiated remotely. Upgrading to version 1.1.0 is able to address this issue. The name of the patch is 184b60ded0e43c985788582aca2d1e746f9405a3. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216520."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1022"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:texthelpers_project:texthelpers:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "70E1AB99-F46B-4D63-B5DF-78E026B59BCD"}]}]}], "references": [{"url": "https://github.com/ahorner/text-helpers/commit/184b60ded0e43c985788582aca2d1e746f9405a3", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ahorner/text-helpers/pull/19", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ahorner/text-helpers/releases/tag/v1.1.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216520", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ahorner/text-helpers/commit/184b60ded0e43c985788582aca2d1e746f9405a3"}}