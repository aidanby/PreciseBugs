{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\tLinux INET6 implementation\n *\tForwarding Information Database\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tChanges:\n *\tYuji SEKIYA @USAGI:\tSupport default route on router node;\n *\t\t\t\tremove ip6_null_entry from the top of\n *\t\t\t\trouting table.\n *\tVille Nuorvala:\t\tFixed routing subtrees.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/lwtunnel.h>\n#include <net/fib_notifier.h>\n\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\nstatic struct kmem_cache *fib6_node_kmem __read_mostly;\n\nstruct fib6_cleaner {\n\tstruct fib6_walker w;\n\tstruct net *net;\n\tint (*func)(struct fib6_info *, void *arg);\n\tint sernum;\n\tvoid *arg;\n\tbool skip_notify;\n};\n\n#ifdef CONFIG_IPV6_SUBTREES\n#define FWS_INIT FWS_S\n#else\n#define FWS_INIT FWS_L\n#endif\n\nstatic struct fib6_info *fib6_find_prefix(struct net *net,\n\t\t\t\t\t struct fib6_table *table,\n\t\t\t\t\t struct fib6_node *fn);\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t  struct fib6_table *table,\n\t\t\t\t\t  struct fib6_node *fn);\nstatic int fib6_walk(struct net *net, struct fib6_walker *w);\nstatic int fib6_walk_continue(struct fib6_walker *w);\n\n/*\n *\tA routing update causes an increase of the serial number on the\n *\taffected subtree. This allows for cached routes to be asynchronously\n *\ttested when modifications are made to the destination cache as a\n *\tresult of redirects, path MTU changes, etc.\n */\n\nstatic void fib6_gc_timer_cb(struct timer_list *t);\n\n#define FOR_WALKERS(net, w) \\\n\tlist_for_each_entry(w, &(net)->ipv6.fib6_walkers, lh)\n\nstatic void fib6_walker_link(struct net *net, struct fib6_walker *w)\n{\n\twrite_lock_bh(&net->ipv6.fib6_walker_lock);\n\tlist_add(&w->lh, &net->ipv6.fib6_walkers);\n\twrite_unlock_bh(&net->ipv6.fib6_walker_lock);\n}\n\nstatic void fib6_walker_unlink(struct net *net, struct fib6_walker *w)\n{\n\twrite_lock_bh(&net->ipv6.fib6_walker_lock);\n\tlist_del(&w->lh);\n\twrite_unlock_bh(&net->ipv6.fib6_walker_lock);\n}\n\nstatic int fib6_new_sernum(struct net *net)\n{\n\tint new, old;\n\n\tdo {\n\t\told = atomic_read(&net->ipv6.fib6_sernum);\n\t\tnew = old < INT_MAX ? old + 1 : 1;\n\t} while (atomic_cmpxchg(&net->ipv6.fib6_sernum,\n\t\t\t\told, new) != old);\n\treturn new;\n}\n\nenum {\n\tFIB6_NO_SERNUM_CHANGE = 0,\n};\n\nvoid fib6_update_sernum(struct net *net, struct fib6_info *f6i)\n{\n\tstruct fib6_node *fn;\n\n\tfn = rcu_dereference_protected(f6i->fib6_node,\n\t\t\tlockdep_is_held(&f6i->fib6_table->tb6_lock));\n\tif (fn)\n\t\tfn->fn_sernum = fib6_new_sernum(net);\n}\n\n/*\n *\tAuxiliary address test functions for the radix tree.\n *\n *\tThese assume a 32bit processor (although it will work on\n *\t64bit processors)\n */\n\n/*\n *\ttest bit\n */\n#if defined(__LITTLE_ENDIAN)\n# define BITOP_BE32_SWIZZLE\t(0x1F & ~7)\n#else\n# define BITOP_BE32_SWIZZLE\t0\n#endif\n\nstatic __be32 addr_bit_set(const void *token, int fn_bit)\n{\n\tconst __be32 *addr = token;\n\t/*\n\t * Here,\n\t *\t1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)\n\t * is optimized version of\n\t *\thtonl(1 << ((~fn_bit)&0x1F))\n\t * See include/asm-generic/bitops/le.h.\n\t */\n\treturn (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &\n\t       addr[fn_bit >> 5];\n}\n\nstruct fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh)\n{\n\tstruct fib6_info *f6i;\n\tsize_t sz = sizeof(*f6i);\n\n\tif (with_fib6_nh)\n\t\tsz += sizeof(struct fib6_nh);\n\n\tf6i = kzalloc(sz, gfp_flags);\n\tif (!f6i)\n\t\treturn NULL;\n\n\t/* fib6_siblings is a union with nh_list, so this initializes both */\n\tINIT_LIST_HEAD(&f6i->fib6_siblings);\n\trefcount_set(&f6i->fib6_ref, 1);\n\n\treturn f6i;\n}\n\nvoid fib6_info_destroy_rcu(struct rcu_head *head)\n{\n\tstruct fib6_info *f6i = container_of(head, struct fib6_info, rcu);\n\n\tWARN_ON(f6i->fib6_node);\n\n\tif (f6i->nh)\n\t\tnexthop_put(f6i->nh);\n\telse\n\t\tfib6_nh_release(f6i->fib6_nh);\n\n\tip_fib_metrics_put(f6i->fib6_metrics);\n\tkfree(f6i);\n}\nEXPORT_SYMBOL_GPL(fib6_info_destroy_rcu);\n\nstatic struct fib6_node *node_alloc(struct net *net)\n{\n\tstruct fib6_node *fn;\n\n\tfn = kmem_cache_zalloc(fib6_node_kmem, GFP_ATOMIC);\n\tif (fn)\n\t\tnet->ipv6.rt6_stats->fib_nodes++;\n\n\treturn fn;\n}\n\nstatic void node_free_immediate(struct net *net, struct fib6_node *fn)\n{\n\tkmem_cache_free(fib6_node_kmem, fn);\n\tnet->ipv6.rt6_stats->fib_nodes--;\n}\n\nstatic void node_free_rcu(struct rcu_head *head)\n{\n\tstruct fib6_node *fn = container_of(head, struct fib6_node, rcu);\n\n\tkmem_cache_free(fib6_node_kmem, fn);\n}\n\nstatic void node_free(struct net *net, struct fib6_node *fn)\n{\n\tcall_rcu(&fn->rcu, node_free_rcu);\n\tnet->ipv6.rt6_stats->fib_nodes--;\n}\n\nstatic void fib6_free_table(struct fib6_table *table)\n{\n\tinetpeer_invalidate_tree(&table->tb6_peers);\n\tkfree(table);\n}\n\nstatic void fib6_link_table(struct net *net, struct fib6_table *tb)\n{\n\tunsigned int h;\n\n\t/*\n\t * Initialize table lock at a single place to give lockdep a key,\n\t * tables aren't visible prior to being linked to the list.\n\t */\n\tspin_lock_init(&tb->tb6_lock);\n\th = tb->tb6_id & (FIB6_TABLE_HASHSZ - 1);\n\n\t/*\n\t * No protection necessary, this is the only list mutatation\n\t * operation, tables never disappear once they exist.\n\t */\n\thlist_add_head_rcu(&tb->tb6_hlist, &net->ipv6.fib_table_hash[h]);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic struct fib6_table *fib6_alloc_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *table;\n\n\ttable = kzalloc(sizeof(*table), GFP_ATOMIC);\n\tif (table) {\n\t\ttable->tb6_id = id;\n\t\trcu_assign_pointer(table->tb6_root.leaf,\n\t\t\t\t   net->ipv6.fib6_null_entry);\n\t\ttable->tb6_root.fn_flags = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\t\tinet_peer_base_init(&table->tb6_peers);\n\t}\n\n\treturn table;\n}\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\ttb = fib6_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\ttb = fib6_alloc_table(net, id);\n\tif (tb)\n\t\tfib6_link_table(net, tb);\n\n\treturn tb;\n}\nEXPORT_SYMBOL_GPL(fib6_new_table);\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\th = id & (FIB6_TABLE_HASHSZ - 1);\n\trcu_read_lock();\n\thead = &net->ipv6.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\tif (tb->tb6_id == id) {\n\t\t\trcu_read_unlock();\n\t\t\treturn tb;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fib6_get_table);\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n\tfib6_link_table(net, net->ipv6.fib6_local_tbl);\n}\n#else\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\treturn fib6_get_table(net, id);\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\t  return net->ipv6.fib6_main_tbl;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}\n\n/* called with rcu lock held; no reference taken on fib6_info */\nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags)\n{\n\treturn fib6_table_lookup(net, net->ipv6.fib6_main_tbl, oif, fl6,\n\t\t\t\t res, flags);\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n}\n\n#endif\n\nunsigned int fib6_tables_seq_read(struct net *net)\n{\n\tunsigned int h, fib_seq = 0;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[h];\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist)\n\t\t\tfib_seq += tb->fib_seq;\n\t}\n\trcu_read_unlock();\n\n\treturn fib_seq;\n}\n\nstatic int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,\n\t\t\t\t    enum fib_event_type event_type,\n\t\t\t\t    struct fib6_info *rt)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.rt = rt,\n\t};\n\n\treturn call_fib6_notifier(nb, net, event_type, &info.info);\n}\n\nint call_fib6_entry_notifiers(struct net *net,\n\t\t\t      enum fib_event_type event_type,\n\t\t\t      struct fib6_info *rt,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.rt = rt,\n\t};\n\n\trt->fib6_table->fib_seq++;\n\treturn call_fib6_notifiers(net, event_type, &info.info);\n}\n\nint call_fib6_multipath_entry_notifiers(struct net *net,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct fib6_info *rt,\n\t\t\t\t\tunsigned int nsiblings,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.rt = rt,\n\t\t.nsiblings = nsiblings,\n\t};\n\n\trt->fib6_table->fib_seq++;\n\treturn call_fib6_notifiers(net, event_type, &info.info);\n}\n\nstruct fib6_dump_arg {\n\tstruct net *net;\n\tstruct notifier_block *nb;\n};\n\nstatic void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)\n{\n\tif (rt == arg->net->ipv6.fib6_null_entry)\n\t\treturn;\n\tcall_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);\n}\n\nstatic int fib6_node_dump(struct fib6_walker *w)\n{\n\tstruct fib6_info *rt;\n\n\tfor_each_fib6_walker_rt(w)\n\t\tfib6_rt_dump(rt, w->args);\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_table_dump(struct net *net, struct fib6_table *tb,\n\t\t\t    struct fib6_walker *w)\n{\n\tw->root = &tb->tb6_root;\n\tspin_lock_bh(&tb->tb6_lock);\n\tfib6_walk(net, w);\n\tspin_unlock_bh(&tb->tb6_lock);\n}\n\n/* Called with rcu_read_lock() */\nint fib6_tables_dump(struct net *net, struct notifier_block *nb)\n{\n\tstruct fib6_dump_arg arg;\n\tstruct fib6_walker *w;\n\tunsigned int h;\n\n\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\tif (!w)\n\t\treturn -ENOMEM;\n\n\tw->func = fib6_node_dump;\n\targ.net = net;\n\targ.nb = nb;\n\tw->args = &arg;\n\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[h];\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist)\n\t\t\tfib6_table_dump(net, tb, w);\n\t}\n\n\tkfree(w);\n\n\treturn 0;\n}\n\nstatic int fib6_dump_node(struct fib6_walker *w)\n{\n\tint res;\n\tstruct fib6_info *rt;\n\n\tfor_each_fib6_walker_rt(w) {\n\t\tres = rt6_dump_route(rt, w->args, w->skip_in_node);\n\t\tif (res >= 0) {\n\t\t\t/* Frame is full, suspend walking */\n\t\t\tw->leaf = rt;\n\n\t\t\t/* We'll restart from this node, so if some routes were\n\t\t\t * already dumped, skip them next time.\n\t\t\t */\n\t\t\tw->skip_in_node += res;\n\n\t\t\treturn 1;\n\t\t}\n\t\tw->skip_in_node = 0;\n\n\t\t/* Multipath routes are dumped in one route with the\n\t\t * RTA_MULTIPATH attribute. Jump 'rt' to point to the\n\t\t * last sibling of this route (no need to dump the\n\t\t * sibling routes again)\n\t\t */\n\t\tif (rt->fib6_nsiblings)\n\t\t\trt = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t     struct fib6_info,\n\t\t\t\t\t     fib6_siblings);\n\t}\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_dump_end(struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct fib6_walker *w = (void *)cb->args[2];\n\n\tif (w) {\n\t\tif (cb->args[4]) {\n\t\t\tcb->args[4] = 0;\n\t\t\tfib6_walker_unlink(net, w);\n\t\t}\n\t\tcb->args[2] = 0;\n\t\tkfree(w);\n\t}\n\tcb->done = (void *)cb->args[3];\n\tcb->args[1] = 3;\n}\n\nstatic int fib6_dump_done(struct netlink_callback *cb)\n{\n\tfib6_dump_end(cb);\n\treturn cb->done ? cb->done(cb) : 0;\n}\n\nstatic int fib6_dump_table(struct fib6_table *table, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib6_walker *w;\n\tint res;\n\n\tw = (void *)cb->args[2];\n\tw->root = &table->tb6_root;\n\n\tif (cb->args[4] == 0) {\n\t\tw->count = 0;\n\t\tw->skip = 0;\n\t\tw->skip_in_node = 0;\n\n\t\tspin_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk(net, w);\n\t\tspin_unlock_bh(&table->tb6_lock);\n\t\tif (res > 0) {\n\t\t\tcb->args[4] = 1;\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t}\n\t} else {\n\t\tif (cb->args[5] != w->root->fn_sernum) {\n\t\t\t/* Begin at the root if the tree changed */\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t\tw->state = FWS_INIT;\n\t\t\tw->node = w->root;\n\t\t\tw->skip = w->count;\n\t\t\tw->skip_in_node = 0;\n\t\t} else\n\t\t\tw->skip = 0;\n\n\t\tspin_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk_continue(w);\n\t\tspin_unlock_bh(&table->tb6_lock);\n\t\tif (res <= 0) {\n\t\t\tfib6_walker_unlink(net, w);\n\t\t\tcb->args[4] = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rt6_rtnl_dump_arg arg = { .filter.dump_exceptions = true,\n\t\t\t\t\t .filter.dump_routes = true };\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct fib6_walker *w;\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tint res = 0;\n\n\tif (cb->strict_check) {\n\t\tint err;\n\n\t\terr = ip_valid_fib_dump_req(net, nlh, &arg.filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (nlmsg_len(nlh) >= sizeof(struct rtmsg)) {\n\t\tstruct rtmsg *rtm = nlmsg_data(nlh);\n\n\t\tif (rtm->rtm_flags & RTM_F_PREFIX)\n\t\t\targ.filter.flags = RTM_F_PREFIX;\n\t}\n\n\tw = (void *)cb->args[2];\n\tif (!w) {\n\t\t/* New dump:\n\t\t *\n\t\t * 1. hook callback destructor.\n\t\t */\n\t\tcb->args[3] = (long)cb->done;\n\t\tcb->done = fib6_dump_done;\n\n\t\t/*\n\t\t * 2. allocate and initialize walker.\n\t\t */\n\t\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\t\tif (!w)\n\t\t\treturn -ENOMEM;\n\t\tw->func = fib6_dump_node;\n\t\tcb->args[2] = (long)w;\n\t}\n\n\targ.skb = skb;\n\targ.cb = cb;\n\targ.net = net;\n\tw->args = &arg;\n\n\tif (arg.filter.table_id) {\n\t\ttb = fib6_get_table(net, arg.filter.table_id);\n\t\tif (!tb) {\n\t\t\tif (arg.filter.dump_all_families)\n\t\t\t\tgoto out;\n\n\t\t\tNL_SET_ERR_MSG_MOD(cb->extack, \"FIB table does not exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!cb->args[0]) {\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (!res)\n\t\t\t\tcb->args[0] = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\trcu_read_lock();\n\tfor (h = s_h; h < FIB6_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (res != 0)\n\t\t\t\tgoto out_unlock;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout_unlock:\n\trcu_read_unlock();\n\tcb->args[1] = e;\n\tcb->args[0] = h;\nout:\n\tres = res < 0 ? res : skb->len;\n\tif (res <= 0)\n\t\tfib6_dump_end(cb);\n\treturn res;\n}\n\nvoid fib6_metric_set(struct fib6_info *f6i, int metric, u32 val)\n{\n\tif (!f6i)\n\t\treturn;\n\n\tif (f6i->fib6_metrics == &dst_default_metrics) {\n\t\tstruct dst_metrics *p = kzalloc(sizeof(*p), GFP_ATOMIC);\n\n\t\tif (!p)\n\t\t\treturn;\n\n\t\trefcount_set(&p->refcnt, 1);\n\t\tf6i->fib6_metrics = p;\n\t}\n\n\tf6i->fib6_metrics->metrics[metric - 1] = val;\n}\n\n/*\n *\tRouting Table\n *\n *\treturn the appropriate node for a routing tree \"add\" operation\n *\tby either creating and inserting or by returning an existing\n *\tnode.\n */\n\nstatic struct fib6_node *fib6_add_1(struct net *net,\n\t\t\t\t    struct fib6_table *table,\n\t\t\t\t    struct fib6_node *root,\n\t\t\t\t    struct in6_addr *addr, int plen,\n\t\t\t\t    int offset, int allow_create,\n\t\t\t\t    int replace_required,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_node *fn, *in, *ln;\n\tstruct fib6_node *pn = NULL;\n\tstruct rt6key *key;\n\tint\tbit;\n\t__be32\tdir = 0;\n\n\tRT6_TRACE(\"fib6_add_1\\n\");\n\n\t/* insert node in tree */\n\n\tfn = root;\n\n\tdo {\n\t\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tkey = (struct rt6key *)((u8 *)leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit)) {\n\t\t\tif (!allow_create) {\n\t\t\t\tif (replace_required) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t\t       \"Can not replace route - no match found\");\n\t\t\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\t\t}\n\t\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t\t\t}\n\t\t\tgoto insert_above;\n\t\t}\n\n\t\t/*\n\t\t *\tExact match ?\n\t\t */\n\n\t\tif (plen == fn->fn_bit) {\n\t\t\t/* clean up an intermediate node */\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\t\tRCU_INIT_POINTER(fn->leaf, NULL);\n\t\t\t\tfib6_info_release(leaf);\n\t\t\t/* remove null_entry in the root node */\n\t\t\t} else if (fn->fn_flags & RTN_TL_ROOT &&\n\t\t\t\t   rcu_access_pointer(fn->leaf) ==\n\t\t\t\t   net->ipv6.fib6_null_entry) {\n\t\t\t\tRCU_INIT_POINTER(fn->leaf, NULL);\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\n\t\t/* Try to walk down on tree. */\n\t\tdir = addr_bit_set(addr, fn->fn_bit);\n\t\tpn = fn;\n\t\tfn = dir ?\n\t\t     rcu_dereference_protected(fn->right,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock)) :\n\t\t     rcu_dereference_protected(fn->left,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t} while (fn);\n\n\tif (!allow_create) {\n\t\t/* We should not create new node because\n\t\t * NLM_F_REPLACE was specified without NLM_F_CREATE\n\t\t * I assume it is safe to require NLM_F_CREATE when\n\t\t * REPLACE flag is used! Later we may want to remove the\n\t\t * check for replace_required, because according\n\t\t * to netlink specification, NLM_F_CREATE\n\t\t * MUST be specified if new route is created.\n\t\t * That would keep IPv6 consistent with IPv4\n\t\t */\n\t\tif (replace_required) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Can not replace route - no match found\");\n\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t}\n\t/*\n\t *\tWe walked to the bottom of tree.\n\t *\tCreate new leaf node without children.\n\t */\n\n\tln = node_alloc(net);\n\n\tif (!ln)\n\t\treturn ERR_PTR(-ENOMEM);\n\tln->fn_bit = plen;\n\tRCU_INIT_POINTER(ln->parent, pn);\n\n\tif (dir)\n\t\trcu_assign_pointer(pn->right, ln);\n\telse\n\t\trcu_assign_pointer(pn->left, ln);\n\n\treturn ln;\n\n\ninsert_above:\n\t/*\n\t * split since we don't have a common prefix anymore or\n\t * we have a less significant route.\n\t * we've to insert an intermediate node on the list\n\t * this new node will point to the one we need to create\n\t * and the current\n\t */\n\n\tpn = rcu_dereference_protected(fn->parent,\n\t\t\t\t       lockdep_is_held(&table->tb6_lock));\n\n\t/* find 1st bit in difference between the 2 addrs.\n\n\t   See comment in __ipv6_addr_diff: bit may be an invalid value,\n\t   but if it is >= plen, the value is ignored in any case.\n\t */\n\n\tbit = __ipv6_addr_diff(addr, &key->addr, sizeof(*addr));\n\n\t/*\n\t *\t\t(intermediate)[in]\n\t *\t          /\t   \\\n\t *\t(new leaf node)[ln] (old node)[fn]\n\t */\n\tif (plen > bit) {\n\t\tin = node_alloc(net);\n\t\tln = node_alloc(net);\n\n\t\tif (!in || !ln) {\n\t\t\tif (in)\n\t\t\t\tnode_free_immediate(net, in);\n\t\t\tif (ln)\n\t\t\t\tnode_free_immediate(net, ln);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\t/*\n\t\t * new intermediate node.\n\t\t * RTN_RTINFO will\n\t\t * be off since that an address that chooses one of\n\t\t * the branches would not match less specific routes\n\t\t * in the other branch\n\t\t */\n\n\t\tin->fn_bit = bit;\n\n\t\tRCU_INIT_POINTER(in->parent, pn);\n\t\tin->leaf = fn->leaf;\n\t\tfib6_info_hold(rcu_dereference_protected(in->leaf,\n\t\t\t\tlockdep_is_held(&table->tb6_lock)));\n\n\t\t/* update parent pointer */\n\t\tif (dir)\n\t\t\trcu_assign_pointer(pn->right, in);\n\t\telse\n\t\t\trcu_assign_pointer(pn->left, in);\n\n\t\tln->fn_bit = plen;\n\n\t\tRCU_INIT_POINTER(ln->parent, in);\n\t\trcu_assign_pointer(fn->parent, in);\n\n\t\tif (addr_bit_set(addr, bit)) {\n\t\t\trcu_assign_pointer(in->right, ln);\n\t\t\trcu_assign_pointer(in->left, fn);\n\t\t} else {\n\t\t\trcu_assign_pointer(in->left, ln);\n\t\t\trcu_assign_pointer(in->right, fn);\n\t\t}\n\t} else { /* plen <= bit */\n\n\t\t/*\n\t\t *\t\t(new leaf node)[ln]\n\t\t *\t          /\t   \\\n\t\t *\t     (old node)[fn] NULL\n\t\t */\n\n\t\tln = node_alloc(net);\n\n\t\tif (!ln)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tln->fn_bit = plen;\n\n\t\tRCU_INIT_POINTER(ln->parent, pn);\n\n\t\tif (addr_bit_set(&key->addr, plen))\n\t\t\tRCU_INIT_POINTER(ln->right, fn);\n\t\telse\n\t\t\tRCU_INIT_POINTER(ln->left, fn);\n\n\t\trcu_assign_pointer(fn->parent, ln);\n\n\t\tif (dir)\n\t\t\trcu_assign_pointer(pn->right, ln);\n\t\telse\n\t\t\trcu_assign_pointer(pn->left, ln);\n\t}\n\treturn ln;\n}\n\nstatic void __fib6_drop_pcpu_from(struct fib6_nh *fib6_nh,\n\t\t\t\t  const struct fib6_info *match,\n\t\t\t\t  const struct fib6_table *table)\n{\n\tint cpu;\n\n\tif (!fib6_nh->rt6i_pcpu)\n\t\treturn;\n\n\t/* release the reference to this fib entry from\n\t * all of its cached pcpu routes\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct rt6_info **ppcpu_rt;\n\t\tstruct rt6_info *pcpu_rt;\n\n\t\tppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);\n\t\tpcpu_rt = *ppcpu_rt;\n\n\t\t/* only dropping the 'from' reference if the cached route\n\t\t * is using 'match'. The cached pcpu_rt->from only changes\n\t\t * from a fib6_info to NULL (ip6_dst_destroy); it can never\n\t\t * change from one fib6_info reference to another\n\t\t */\n\t\tif (pcpu_rt && rcu_access_pointer(pcpu_rt->from) == match) {\n\t\t\tstruct fib6_info *from;\n\n\t\t\tfrom = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);\n\t\t\tfib6_info_release(from);\n\t\t}\n\t}\n}\n\nstruct fib6_nh_pcpu_arg {\n\tstruct fib6_info\t*from;\n\tconst struct fib6_table *table;\n};\n\nstatic int fib6_nh_drop_pcpu_from(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_pcpu_arg *arg = _arg;\n\n\t__fib6_drop_pcpu_from(nh, arg->from, arg->table);\n\treturn 0;\n}\n\nstatic void fib6_drop_pcpu_from(struct fib6_info *f6i,\n\t\t\t\tconst struct fib6_table *table)\n{\n\t/* Make sure rt6_make_pcpu_route() wont add other percpu routes\n\t * while we are cleaning them here.\n\t */\n\tf6i->fib6_destroying = 1;\n\tmb(); /* paired with the cmpxchg() in rt6_make_pcpu_route() */\n\n\tif (f6i->nh) {\n\t\tstruct fib6_nh_pcpu_arg arg = {\n\t\t\t.from = f6i,\n\t\t\t.table = table\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(f6i->nh, fib6_nh_drop_pcpu_from,\n\t\t\t\t\t &arg);\n\t} else {\n\t\tstruct fib6_nh *fib6_nh;\n\n\t\tfib6_nh = f6i->fib6_nh;\n\t\t__fib6_drop_pcpu_from(fib6_nh, f6i, table);\n\t}\n}\n\nstatic void fib6_purge_rt(struct fib6_info *rt, struct fib6_node *fn,\n\t\t\t  struct net *net)\n{\n\tstruct fib6_table *table = rt->fib6_table;\n\n\tfib6_drop_pcpu_from(rt, table);\n\n\tif (rt->nh && !list_empty(&rt->nh_list))\n\t\tlist_del_init(&rt->nh_list);\n\n\tif (refcount_read(&rt->fib6_ref) != 1) {\n\t\t/* This route is used as dummy address holder in some split\n\t\t * nodes. It is not leaked, but it still holds other resources,\n\t\t * which must be released in time. So, scan ascendant nodes\n\t\t * and replace dummy references to this route with references\n\t\t * to still alive ones.\n\t\t */\n\t\twhile (fn) {\n\t\t\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tstruct fib6_info *new_leaf;\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO) && leaf == rt) {\n\t\t\t\tnew_leaf = fib6_find_prefix(net, table, fn);\n\t\t\t\tfib6_info_hold(new_leaf);\n\n\t\t\t\trcu_assign_pointer(fn->leaf, new_leaf);\n\t\t\t\tfib6_info_release(rt);\n\t\t\t}\n\t\t\tfn = rcu_dereference_protected(fn->parent,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t}\n\t}\n}\n\n/*\n *\tInsert routing information in a node.\n */\n\nstatic int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (rt_can_ecmp)\n\t\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No ECMP-able route found, replace first non-ECMP one */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\tif (!info->skip_notify_kernel) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_ADD,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fib6_start_gc(struct net *net, struct fib6_info *rt)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer) &&\n\t    (rt->fib6_flags & RTF_EXPIRES))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nvoid fib6_force_start_gc(struct net *net)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nstatic void __fib6_update_sernum_upto_root(struct fib6_info *rt,\n\t\t\t\t\t   int sernum)\n{\n\tstruct fib6_node *fn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\n\t/* paired with smp_rmb() in rt6_get_cookie_safe() */\n\tsmp_wmb();\n\twhile (fn) {\n\t\tfn->fn_sernum = sernum;\n\t\tfn = rcu_dereference_protected(fn->parent,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t}\n}\n\nvoid fib6_update_sernum_upto_root(struct net *net, struct fib6_info *rt)\n{\n\t__fib6_update_sernum_upto_root(rt, fib6_new_sernum(net));\n}\n\n/* allow ipv4 to update sernum via ipv6_stub */\nvoid fib6_update_sernum_stub(struct net *net, struct fib6_info *f6i)\n{\n\tspin_lock_bh(&f6i->fib6_table->tb6_lock);\n\tfib6_update_sernum_upto_root(net, f6i);\n\tspin_unlock_bh(&f6i->fib6_table->tb6_lock);\n}\n\n/*\n *\tAdd routing information to the routing tree.\n *\t<destination addr>/<source addr>\n *\twith source addr info in sub-trees\n *\tNeed to own table->tb6_lock\n */\n\nint fib6_add(struct fib6_node *root, struct fib6_info *rt,\n\t     struct nl_info *info, struct netlink_ext_ack *extack)\n{\n\tstruct fib6_table *table = rt->fib6_table;\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\tint sernum = fib6_new_sernum(info->nl_net);\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n\tfn = fib6_add_1(info->nl_net, table, root,\n\t\t\t&rt->fib6_dst.addr, rt->fib6_dst.plen,\n\t\t\toffsetof(struct fib6_info, fib6_dst), allow_create,\n\t\t\treplace_required, extack);\n\tif (IS_ERR(fn)) {\n\t\terr = PTR_ERR(fn);\n\t\tfn = NULL;\n\t\tgoto out;\n\t}\n\n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->fib6_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!rcu_access_pointer(fn->subtree)) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc(info->nl_net);\n\t\t\tif (!sfn)\n\t\t\t\tgoto failure;\n\n\t\t\tfib6_info_hold(info->nl_net->ipv6.fib6_null_entry);\n\t\t\trcu_assign_pointer(sfn->leaf,\n\t\t\t\t\t   info->nl_net->ipv6.fib6_null_entry);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(info->nl_net, table, sfn,\n\t\t\t\t\t&rt->fib6_src.addr, rt->fib6_src.plen,\n\t\t\t\t\toffsetof(struct fib6_info, fib6_src),\n\t\t\t\t\tallow_create, replace_required, extack);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free_immediate(info->nl_net, sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\trcu_assign_pointer(sfn->parent, fn);\n\t\t\trcu_assign_pointer(fn->subtree, sfn);\n\t\t} else {\n\t\t\tsn = fib6_add_1(info->nl_net, table, FIB6_SUBTREE(fn),\n\t\t\t\t\t&rt->fib6_src.addr, rt->fib6_src.plen,\n\t\t\t\t\toffsetof(struct fib6_info, fib6_src),\n\t\t\t\t\tallow_create, replace_required, extack);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!rcu_access_pointer(fn->leaf)) {\n\t\t\tif (fn->fn_flags & RTN_TL_ROOT) {\n\t\t\t\t/* put back null_entry for root node */\n\t\t\t\trcu_assign_pointer(fn->leaf,\n\t\t\t\t\t    info->nl_net->ipv6.fib6_null_entry);\n\t\t\t} else {\n\t\t\t\tfib6_info_hold(rt);\n\t\t\t\trcu_assign_pointer(fn->leaf, rt);\n\t\t\t}\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info, extack);\n\tif (!err) {\n\t\tif (rt->nh)\n\t\t\tlist_add(&rt->nh_list, &rt->nh->f6i_list);\n\t\t__fib6_update_sernum_upto_root(rt, sernum);\n\t\tfib6_start_gc(info->nl_net, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn) {\n\t\t\tstruct fib6_info *pn_leaf =\n\t\t\t\trcu_dereference_protected(pn->leaf,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (pn_leaf == rt) {\n\t\t\t\tpn_leaf = NULL;\n\t\t\t\tRCU_INIT_POINTER(pn->leaf, NULL);\n\t\t\t\tfib6_info_release(rt);\n\t\t\t}\n\t\t\tif (!pn_leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\t\tpn_leaf = fib6_find_prefix(info->nl_net, table,\n\t\t\t\t\t\t\t   pn);\n#if RT6_DEBUG >= 2\n\t\t\t\tif (!pn_leaf) {\n\t\t\t\t\tWARN_ON(!pn_leaf);\n\t\t\t\t\tpn_leaf =\n\t\t\t\t\t    info->nl_net->ipv6.fib6_null_entry;\n\t\t\t\t}\n#endif\n\t\t\t\tfib6_info_hold(pn_leaf);\n\t\t\t\trcu_assign_pointer(pn->leaf, pn_leaf);\n\t\t\t}\n\t\t}\n#endif\n\t\tgoto failure;\n\t}\n\treturn err;\n\nfailure:\n\t/* fn->leaf could be NULL and fib6_repair_tree() needs to be called if:\n\t * 1. fn is an intermediate node and we failed to add the new\n\t * route to it in both subtree creation failure and fib6_add_rt2node()\n\t * failure case.\n\t * 2. fn is the root node in the table and we fail to add the first\n\t * default route to it.\n\t */\n\tif (fn &&\n\t    (!(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)) ||\n\t     (fn->fn_flags & RTN_TL_ROOT &&\n\t      !rcu_access_pointer(fn->leaf))))\n\t\tfib6_repair_tree(info->nl_net, table, fn);\n\treturn err;\n}\n\n/*\n *\tRouting tree lookup\n *\n */\n\nstruct lookup_args {\n\tint\t\t\toffset;\t\t/* key offset on fib6_info */\n\tconst struct in6_addr\t*addr;\t\t/* search key\t\t\t*/\n};\n\nstatic struct fib6_node *fib6_node_lookup_1(struct fib6_node *root,\n\t\t\t\t\t    struct lookup_args *args)\n{\n\tstruct fib6_node *fn;\n\t__be32 dir;\n\n\tif (unlikely(args->offset == 0))\n\t\treturn NULL;\n\n\t/*\n\t *\tDescend on a tree\n\t */\n\n\tfn = root;\n\n\tfor (;;) {\n\t\tstruct fib6_node *next;\n\n\t\tdir = addr_bit_set(args->addr, fn->fn_bit);\n\n\t\tnext = dir ? rcu_dereference(fn->right) :\n\t\t\t     rcu_dereference(fn->left);\n\n\t\tif (next) {\n\t\t\tfn = next;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\twhile (fn) {\n\t\tstruct fib6_node *subtree = FIB6_SUBTREE(fn);\n\n\t\tif (subtree || fn->fn_flags & RTN_RTINFO) {\n\t\t\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\t\t\tstruct rt6key *key;\n\n\t\t\tif (!leaf)\n\t\t\t\tgoto backtrack;\n\n\t\t\tkey = (struct rt6key *) ((u8 *)leaf + args->offset);\n\n\t\t\tif (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\tif (subtree) {\n\t\t\t\t\tstruct fib6_node *sfn;\n\t\t\t\t\tsfn = fib6_node_lookup_1(subtree,\n\t\t\t\t\t\t\t\t args + 1);\n\t\t\t\t\tif (!sfn)\n\t\t\t\t\t\tgoto backtrack;\n\t\t\t\t\tfn = sfn;\n\t\t\t\t}\n#endif\n\t\t\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\t\t\treturn fn;\n\t\t\t}\n\t\t}\nbacktrack:\n\t\tif (fn->fn_flags & RTN_ROOT)\n\t\t\tbreak;\n\n\t\tfn = rcu_dereference(fn->parent);\n\t}\n\n\treturn NULL;\n}\n\n/* called with rcu_read_lock() held\n */\nstruct fib6_node *fib6_node_lookup(struct fib6_node *root,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct fib6_node *fn;\n\tstruct lookup_args args[] = {\n\t\t{\n\t\t\t.offset = offsetof(struct fib6_info, fib6_dst),\n\t\t\t.addr = daddr,\n\t\t},\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t{\n\t\t\t.offset = offsetof(struct fib6_info, fib6_src),\n\t\t\t.addr = saddr,\n\t\t},\n#endif\n\t\t{\n\t\t\t.offset = 0,\t/* sentinel */\n\t\t}\n\t};\n\n\tfn = fib6_node_lookup_1(root, daddr ? args : args + 1);\n\tif (!fn || fn->fn_flags & RTN_TL_ROOT)\n\t\tfn = root;\n\n\treturn fn;\n}\n\n/*\n *\tGet node with specified destination prefix (and source prefix,\n *\tif subtrees are used)\n *\texact_match == true means we try to find fn with exact match of\n *\tthe passed in prefix addr\n *\texact_match == false means we try to find fn with longest prefix\n *\tmatch of the passed in prefix addr. This is useful for finding fn\n *\tfor cached route as it will be stored in the exception table under\n *\tthe node with longest prefix length.\n */\n\n\nstatic struct fib6_node *fib6_locate_1(struct fib6_node *root,\n\t\t\t\t       const struct in6_addr *addr,\n\t\t\t\t       int plen, int offset,\n\t\t\t\t       bool exact_match)\n{\n\tstruct fib6_node *fn, *prev = NULL;\n\n\tfor (fn = root; fn ; ) {\n\t\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\t\tstruct rt6key *key;\n\n\t\t/* This node is being deleted */\n\t\tif (!leaf) {\n\t\t\tif (plen <= fn->fn_bit)\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tkey = (struct rt6key *)((u8 *)leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit))\n\t\t\tgoto out;\n\n\t\tif (plen == fn->fn_bit)\n\t\t\treturn fn;\n\n\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\tprev = fn;\n\nnext:\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\t\tif (addr_bit_set(addr, fn->fn_bit))\n\t\t\tfn = rcu_dereference(fn->right);\n\t\telse\n\t\t\tfn = rcu_dereference(fn->left);\n\t}\nout:\n\tif (exact_match)\n\t\treturn NULL;\n\telse\n\t\treturn prev;\n}\n\nstruct fib6_node *fib6_locate(struct fib6_node *root,\n\t\t\t      const struct in6_addr *daddr, int dst_len,\n\t\t\t      const struct in6_addr *saddr, int src_len,\n\t\t\t      bool exact_match)\n{\n\tstruct fib6_node *fn;\n\n\tfn = fib6_locate_1(root, daddr, dst_len,\n\t\t\t   offsetof(struct fib6_info, fib6_dst),\n\t\t\t   exact_match);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src_len) {\n\t\tWARN_ON(saddr == NULL);\n\t\tif (fn) {\n\t\t\tstruct fib6_node *subtree = FIB6_SUBTREE(fn);\n\n\t\t\tif (subtree) {\n\t\t\t\tfn = fib6_locate_1(subtree, saddr, src_len,\n\t\t\t\t\t   offsetof(struct fib6_info, fib6_src),\n\t\t\t\t\t   exact_match);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fn && fn->fn_flags & RTN_RTINFO)\n\t\treturn fn;\n\n\treturn NULL;\n}\n\n\n/*\n *\tDeletion\n *\n */\n\nstatic struct fib6_info *fib6_find_prefix(struct net *net,\n\t\t\t\t\t struct fib6_table *table,\n\t\t\t\t\t struct fib6_node *fn)\n{\n\tstruct fib6_node *child_left, *child_right;\n\n\tif (fn->fn_flags & RTN_ROOT)\n\t\treturn net->ipv6.fib6_null_entry;\n\n\twhile (fn) {\n\t\tchild_left = rcu_dereference_protected(fn->left,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tchild_right = rcu_dereference_protected(fn->right,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tif (child_left)\n\t\t\treturn rcu_dereference_protected(child_left->leaf,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t\tif (child_right)\n\t\t\treturn rcu_dereference_protected(child_right->leaf,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\n\t\tfn = FIB6_SUBTREE(fn);\n\t}\n\treturn NULL;\n}\n\n/*\n *\tCalled to trim the tree of intermediate nodes when possible. \"fn\"\n *\tis the node we want to try and remove.\n *\tNeed to own table->tb6_lock\n */\n\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t  struct fib6_table *table,\n\t\t\t\t\t  struct fib6_node *fn)\n{\n\tint children;\n\tint nstate;\n\tstruct fib6_node *child;\n\tstruct fib6_walker *w;\n\tint iter = 0;\n\n\t/* Set fn->leaf to null_entry for root node. */\n\tif (fn->fn_flags & RTN_TL_ROOT) {\n\t\trcu_assign_pointer(fn->leaf, net->ipv6.fib6_null_entry);\n\t\treturn fn;\n\t}\n\n\tfor (;;) {\n\t\tstruct fib6_node *fn_r = rcu_dereference_protected(fn->right,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *fn_l = rcu_dereference_protected(fn->left,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn = rcu_dereference_protected(fn->parent,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn_r = rcu_dereference_protected(pn->right,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn_l = rcu_dereference_protected(pn->left,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *fn_leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *pn_leaf = rcu_dereference_protected(pn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *new_fn_leaf;\n\n\t\tRT6_TRACE(\"fixing tree: plen=%d iter=%d\\n\", fn->fn_bit, iter);\n\t\titer++;\n\n\t\tWARN_ON(fn->fn_flags & RTN_RTINFO);\n\t\tWARN_ON(fn->fn_flags & RTN_TL_ROOT);\n\t\tWARN_ON(fn_leaf);\n\n\t\tchildren = 0;\n\t\tchild = NULL;\n\t\tif (fn_r)\n\t\t\tchild = fn_r, children |= 1;\n\t\tif (fn_l)\n\t\t\tchild = fn_l, children |= 2;\n\n\t\tif (children == 3 || FIB6_SUBTREE(fn)\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t    /* Subtree root (i.e. fn) may have one child */\n\t\t    || (children && fn->fn_flags & RTN_ROOT)\n#endif\n\t\t    ) {\n\t\t\tnew_fn_leaf = fib6_find_prefix(net, table, fn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!new_fn_leaf) {\n\t\t\t\tWARN_ON(!new_fn_leaf);\n\t\t\t\tnew_fn_leaf = net->ipv6.fib6_null_entry;\n\t\t\t}\n#endif\n\t\t\tfib6_info_hold(new_fn_leaf);\n\t\t\trcu_assign_pointer(fn->leaf, new_fn_leaf);\n\t\t\treturn pn;\n\t\t}\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\tRCU_INIT_POINTER(pn->subtree, NULL);\n\t\t\tnstate = FWS_L;\n\t\t} else {\n\t\t\tWARN_ON(fn->fn_flags & RTN_ROOT);\n#endif\n\t\t\tif (pn_r == fn)\n\t\t\t\trcu_assign_pointer(pn->right, child);\n\t\t\telse if (pn_l == fn)\n\t\t\t\trcu_assign_pointer(pn->left, child);\n#if RT6_DEBUG >= 2\n\t\t\telse\n\t\t\t\tWARN_ON(1);\n#endif\n\t\t\tif (child)\n\t\t\t\trcu_assign_pointer(child->parent, pn);\n\t\t\tnstate = FWS_R;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t}\n#endif\n\n\t\tread_lock(&net->ipv6.fib6_walker_lock);\n\t\tFOR_WALKERS(net, w) {\n\t\t\tif (!child) {\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 1, s=%d/%d\\n\", w, w->state, nstate);\n\t\t\t\t\tw->node = pn;\n\t\t\t\t\tw->state = nstate;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tw->node = child;\n\t\t\t\t\tif (children&2) {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state >= FWS_R ? FWS_U : FWS_INIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state >= FWS_C ? FWS_U : FWS_INIT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tread_unlock(&net->ipv6.fib6_walker_lock);\n\n\t\tnode_free(net, fn);\n\t\tif (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))\n\t\t\treturn pn;\n\n\t\tRCU_INIT_POINTER(pn->leaf, NULL);\n\t\tfib6_info_release(pn_leaf);\n\t\tfn = pn;\n\t}\n}\n\nstatic void fib6_del_route(struct fib6_table *table, struct fib6_node *fn,\n\t\t\t   struct fib6_info __rcu **rtp, struct nl_info *info)\n{\n\tstruct fib6_walker *w;\n\tstruct fib6_info *rt = rcu_dereference_protected(*rtp,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\tstruct net *net = info->nl_net;\n\n\tRT6_TRACE(\"fib6_del_route\\n\");\n\n\t/* Unlink it */\n\t*rtp = rt->fib6_next;\n\trt->fib6_node = NULL;\n\tnet->ipv6.rt6_stats->fib_rt_entries--;\n\tnet->ipv6.rt6_stats->fib_discarded_routes++;\n\n\t/* Flush all cached dst in exception table */\n\trt6_flush_exceptions(rt);\n\n\t/* Reset round-robin state, if necessary */\n\tif (rcu_access_pointer(fn->rr_ptr) == rt)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Remove this entry from other siblings */\n\tif (rt->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings)\n\t\t\tsibling->fib6_nsiblings--;\n\t\trt->fib6_nsiblings = 0;\n\t\tlist_del_init(&rt->fib6_siblings);\n\t\trt6_multipath_rebalance(next_sibling);\n\t}\n\n\t/* Adjust walkers */\n\tread_lock(&net->ipv6.fib6_walker_lock);\n\tFOR_WALKERS(net, w) {\n\t\tif (w->state == FWS_C && w->leaf == rt) {\n\t\t\tRT6_TRACE(\"walker %p adjusted by delroute\\n\", w);\n\t\t\tw->leaf = rcu_dereference_protected(rt->fib6_next,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (!w->leaf)\n\t\t\t\tw->state = FWS_U;\n\t\t}\n\t}\n\tread_unlock(&net->ipv6.fib6_walker_lock);\n\n\t/* If it was last route, call fib6_repair_tree() to:\n\t * 1. For root node, put back null_entry as how the table was created.\n\t * 2. For other nodes, expunge its radix tree node.\n\t */\n\tif (!rcu_access_pointer(fn->leaf)) {\n\t\tif (!(fn->fn_flags & RTN_TL_ROOT)) {\n\t\t\tfn->fn_flags &= ~RTN_RTINFO;\n\t\t\tnet->ipv6.rt6_stats->fib_route_nodes--;\n\t\t}\n\t\tfn = fib6_repair_tree(net, table, fn);\n\t}\n\n\tfib6_purge_rt(rt, fn, net);\n\n\tif (!info->skip_notify_kernel)\n\t\tcall_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, rt, NULL);\n\tif (!info->skip_notify)\n\t\tinet6_rt_notify(RTM_DELROUTE, rt, info, 0);\n\n\tfib6_info_release(rt);\n}\n\n/* Need to own table->tb6_lock */\nint fib6_del(struct fib6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_table *table = rt->fib6_table;\n\tstruct net *net = info->nl_net;\n\tstruct fib6_info __rcu **rtp;\n\tstruct fib6_info __rcu **rtp_next;\n\n\tif (!fn || rt == net->ipv6.fib6_null_entry)\n\t\treturn -ENOENT;\n\n\tWARN_ON(!(fn->fn_flags & RTN_RTINFO));\n\n\t/*\n\t *\tWalk the leaf entries looking for ourself\n\t */\n\n\tfor (rtp = &fn->leaf; *rtp; rtp = rtp_next) {\n\t\tstruct fib6_info *cur = rcu_dereference_protected(*rtp,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t\tif (rt == cur) {\n\t\t\tfib6_del_route(table, fn, rtp, info);\n\t\t\treturn 0;\n\t\t}\n\t\trtp_next = &cur->fib6_next;\n\t}\n\treturn -ENOENT;\n}\n\n/*\n *\tTree traversal function.\n *\n *\tCertainly, it is not interrupt safe.\n *\tHowever, it is internally reenterable wrt itself and fib6_add/fib6_del.\n *\tIt means, that we can modify tree during walking\n *\tand use this function for garbage collection, clone pruning,\n *\tcleaning tree when a device goes down etc. etc.\n *\n *\tIt guarantees that every node will be traversed,\n *\tand that it will be traversed only once.\n *\n *\tCallback function w->func may return:\n *\t0 -> continue walking.\n *\tpositive value -> walking is suspended (used by tree dumps,\n *\tand probably by gc, if it will be split to several slices)\n *\tnegative value -> terminate walking.\n *\n *\tThe function itself returns:\n *\t0   -> walk is complete.\n *\t>0  -> walk is incomplete (i.e. suspended)\n *\t<0  -> walk is terminated by an error.\n *\n *\tThis function is called with tb6_lock held.\n */\n\nstatic int fib6_walk_continue(struct fib6_walker *w)\n{\n\tstruct fib6_node *fn, *pn, *left, *right;\n\n\t/* w->root should always be table->tb6_root */\n\tWARN_ON_ONCE(!(w->root->fn_flags & RTN_TL_ROOT));\n\n\tfor (;;) {\n\t\tfn = w->node;\n\t\tif (!fn)\n\t\t\treturn 0;\n\n\t\tswitch (w->state) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tcase FWS_S:\n\t\t\tif (FIB6_SUBTREE(fn)) {\n\t\t\t\tw->node = FIB6_SUBTREE(fn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_L;\n#endif\n\t\t\t/* fall through */\n\t\tcase FWS_L:\n\t\t\tleft = rcu_dereference_protected(fn->left, 1);\n\t\t\tif (left) {\n\t\t\t\tw->node = left;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_R;\n\t\t\t/* fall through */\n\t\tcase FWS_R:\n\t\t\tright = rcu_dereference_protected(fn->right, 1);\n\t\t\tif (right) {\n\t\t\t\tw->node = right;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = rcu_dereference_protected(fn->leaf, 1);\n\t\t\t/* fall through */\n\t\tcase FWS_C:\n\t\t\tif (w->leaf && fn->fn_flags & RTN_RTINFO) {\n\t\t\t\tint err;\n\n\t\t\t\tif (w->skip) {\n\t\t\t\t\tw->skip--;\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\n\t\t\t\terr = w->func(w);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\nskip:\n\t\t\tw->state = FWS_U;\n\t\t\t/* fall through */\n\t\tcase FWS_U:\n\t\t\tif (fn == w->root)\n\t\t\t\treturn 0;\n\t\t\tpn = rcu_dereference_protected(fn->parent, 1);\n\t\t\tleft = rcu_dereference_protected(pn->left, 1);\n\t\t\tright = rcu_dereference_protected(pn->right, 1);\n\t\t\tw->node = pn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\t\tw->state = FWS_L;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (left == fn) {\n\t\t\t\tw->state = FWS_R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (right == fn) {\n\t\t\t\tw->state = FWS_C;\n\t\t\t\tw->leaf = rcu_dereference_protected(w->node->leaf, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n#if RT6_DEBUG >= 2\n\t\t\tWARN_ON(1);\n#endif\n\t\t}\n\t}\n}\n\nstatic int fib6_walk(struct net *net, struct fib6_walker *w)\n{\n\tint res;\n\n\tw->state = FWS_INIT;\n\tw->node = w->root;\n\n\tfib6_walker_link(net, w);\n\tres = fib6_walk_continue(w);\n\tif (res <= 0)\n\t\tfib6_walker_unlink(net, w);\n\treturn res;\n}\n\nstatic int fib6_clean_node(struct fib6_walker *w)\n{\n\tint res;\n\tstruct fib6_info *rt;\n\tstruct fib6_cleaner *c = container_of(w, struct fib6_cleaner, w);\n\tstruct nl_info info = {\n\t\t.nl_net = c->net,\n\t\t.skip_notify = c->skip_notify,\n\t};\n\n\tif (c->sernum != FIB6_NO_SERNUM_CHANGE &&\n\t    w->node->fn_sernum != c->sernum)\n\t\tw->node->fn_sernum = c->sernum;\n\n\tif (!c->func) {\n\t\tWARN_ON_ONCE(c->sernum == FIB6_NO_SERNUM_CHANGE);\n\t\tw->leaf = NULL;\n\t\treturn 0;\n\t}\n\n\tfor_each_fib6_walker_rt(w) {\n\t\tres = c->func(rt, c->arg);\n\t\tif (res == -1) {\n\t\t\tw->leaf = rt;\n\t\t\tres = fib6_del(rt, &info);\n\t\t\tif (res) {\n#if RT6_DEBUG >= 2\n\t\t\t\tpr_debug(\"%s: del failed: rt=%p@%p err=%d\\n\",\n\t\t\t\t\t __func__, rt,\n\t\t\t\t\t rcu_access_pointer(rt->fib6_node),\n\t\t\t\t\t res);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (res == -2) {\n\t\t\tif (WARN_ON(!rt->fib6_nsiblings))\n\t\t\t\tcontinue;\n\t\t\trt = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t     struct fib6_info, fib6_siblings);\n\t\t\tcontinue;\n\t\t}\n\t\tWARN_ON(res != 0);\n\t}\n\tw->leaf = rt;\n\treturn 0;\n}\n\n/*\n *\tConvenient frontend to tree walker.\n *\n *\tfunc is called on each route.\n *\t\tIt may return -2 -> skip multipath route.\n *\t\t\t      -1 -> delete this route.\n *\t\t              0  -> continue walking\n */\n\nstatic void fib6_clean_tree(struct net *net, struct fib6_node *root,\n\t\t\t    int (*func)(struct fib6_info *, void *arg),\n\t\t\t    int sernum, void *arg, bool skip_notify)\n{\n\tstruct fib6_cleaner c;\n\n\tc.w.root = root;\n\tc.w.func = fib6_clean_node;\n\tc.w.count = 0;\n\tc.w.skip = 0;\n\tc.w.skip_in_node = 0;\n\tc.func = func;\n\tc.sernum = sernum;\n\tc.arg = arg;\n\tc.net = net;\n\tc.skip_notify = skip_notify;\n\n\tfib6_walk(net, &c.w);\n}\n\nstatic void __fib6_clean_all(struct net *net,\n\t\t\t     int (*func)(struct fib6_info *, void *),\n\t\t\t     int sernum, void *arg, bool skip_notify)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tspin_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, sernum, arg, skip_notify);\n\t\t\tspin_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nvoid fib6_clean_all(struct net *net, int (*func)(struct fib6_info *, void *),\n\t\t    void *arg)\n{\n\t__fib6_clean_all(net, func, FIB6_NO_SERNUM_CHANGE, arg, false);\n}\n\nvoid fib6_clean_all_skip_notify(struct net *net,\n\t\t\t\tint (*func)(struct fib6_info *, void *),\n\t\t\t\tvoid *arg)\n{\n\t__fib6_clean_all(net, func, FIB6_NO_SERNUM_CHANGE, arg, true);\n}\n\nstatic void fib6_flush_trees(struct net *net)\n{\n\tint new_sernum = fib6_new_sernum(net);\n\n\t__fib6_clean_all(net, NULL, new_sernum, NULL, false);\n}\n\n/*\n *\tGarbage collection\n */\n\nstatic int fib6_age(struct fib6_info *rt, void *arg)\n{\n\tstruct fib6_gc_args *gc_args = arg;\n\tunsigned long now = jiffies;\n\n\t/*\n\t *\tcheck addrconf expiration here.\n\t *\tRoutes are expired even if they are in use.\n\t */\n\n\tif (rt->fib6_flags & RTF_EXPIRES && rt->expires) {\n\t\tif (time_after(now, rt->expires)) {\n\t\t\tRT6_TRACE(\"expiring %p\\n\", rt);\n\t\t\treturn -1;\n\t\t}\n\t\tgc_args->more++;\n\t}\n\n\t/*\tAlso age clones in the exception table.\n\t *\tNote, that clones are aged out\n\t *\tonly if they are not in use now.\n\t */\n\trt6_age_exceptions(rt, gc_args, now);\n\n\treturn 0;\n}\n\nvoid fib6_run_gc(unsigned long expires, struct net *net, bool force)\n{\n\tstruct fib6_gc_args gc_args;\n\tunsigned long now;\n\n\tif (force) {\n\t\tspin_lock_bh(&net->ipv6.fib6_gc_lock);\n\t} else if (!spin_trylock_bh(&net->ipv6.fib6_gc_lock)) {\n\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\treturn;\n\t}\n\tgc_args.timeout = expires ? (int)expires :\n\t\t\t  net->ipv6.sysctl.ip6_rt_gc_interval;\n\tgc_args.more = 0;\n\n\tfib6_clean_all(net, fib6_age, &gc_args);\n\tnow = jiffies;\n\tnet->ipv6.ip6_rt_last_gc = now;\n\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(now\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&net->ipv6.fib6_gc_lock);\n}\n\nstatic void fib6_gc_timer_cb(struct timer_list *t)\n{\n\tstruct net *arg = from_timer(arg, t, ipv6.ip6_fib_timer);\n\n\tfib6_run_gc(0, arg, true);\n}\n\nstatic int __net_init fib6_net_init(struct net *net)\n{\n\tsize_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;\n\tint err;\n\n\terr = fib6_notifier_init(net);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_init(&net->ipv6.fib6_gc_lock);\n\trwlock_init(&net->ipv6.fib6_walker_lock);\n\tINIT_LIST_HEAD(&net->ipv6.fib6_walkers);\n\ttimer_setup(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, 0);\n\n\tnet->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);\n\tif (!net->ipv6.rt6_stats)\n\t\tgoto out_timer;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv6.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv6.fib_table_hash)\n\t\tgoto out_rt6_stats;\n\n\tnet->ipv6.fib6_main_tbl = kzalloc(sizeof(*net->ipv6.fib6_main_tbl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!net->ipv6.fib6_main_tbl)\n\t\tgoto out_fib_table_hash;\n\n\tnet->ipv6.fib6_main_tbl->tb6_id = RT6_TABLE_MAIN;\n\trcu_assign_pointer(net->ipv6.fib6_main_tbl->tb6_root.leaf,\n\t\t\t   net->ipv6.fib6_null_entry);\n\tnet->ipv6.fib6_main_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_main_tbl->tb6_peers);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_local_tbl = kzalloc(sizeof(*net->ipv6.fib6_local_tbl),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.fib6_local_tbl)\n\t\tgoto out_fib6_main_tbl;\n\tnet->ipv6.fib6_local_tbl->tb6_id = RT6_TABLE_LOCAL;\n\trcu_assign_pointer(net->ipv6.fib6_local_tbl->tb6_root.leaf,\n\t\t\t   net->ipv6.fib6_null_entry);\n\tnet->ipv6.fib6_local_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_local_tbl->tb6_peers);\n#endif\n\tfib6_tables_init(net);\n\n\treturn 0;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_fib6_main_tbl:\n\tkfree(net->ipv6.fib6_main_tbl);\n#endif\nout_fib_table_hash:\n\tkfree(net->ipv6.fib_table_hash);\nout_rt6_stats:\n\tkfree(net->ipv6.rt6_stats);\nout_timer:\n\tfib6_notifier_exit(net);\n\treturn -ENOMEM;\n}\n\nstatic void fib6_net_exit(struct net *net)\n{\n\tunsigned int i;\n\n\tdel_timer_sync(&net->ipv6.ip6_fib_timer);\n\n\tfor (i = 0; i < FIB6_TABLE_HASHSZ; i++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb6_hlist) {\n\t\t\thlist_del(&tb->tb6_hlist);\n\t\t\tfib6_free_table(tb);\n\t\t}\n\t}\n\n\tkfree(net->ipv6.fib_table_hash);\n\tkfree(net->ipv6.rt6_stats);\n\tfib6_notifier_exit(net);\n}\n\nstatic struct pernet_operations fib6_net_ops = {\n\t.init = fib6_net_init,\n\t.exit = fib6_net_exit,\n};\n\nint __init fib6_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tfib6_node_kmem = kmem_cache_create(\"fib6_nodes\",\n\t\t\t\t\t   sizeof(struct fib6_node),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t   NULL);\n\tif (!fib6_node_kmem)\n\t\tgoto out;\n\n\tret = register_pernet_subsys(&fib6_net_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache_create;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETROUTE, NULL,\n\t\t\t\t   inet6_dump_fib, 0);\n\tif (ret)\n\t\tgoto out_unregister_subsys;\n\n\t__fib6_flush_trees = fib6_flush_trees;\nout:\n\treturn ret;\n\nout_unregister_subsys:\n\tunregister_pernet_subsys(&fib6_net_ops);\nout_kmem_cache_create:\n\tkmem_cache_destroy(fib6_node_kmem);\n\tgoto out;\n}\n\nvoid fib6_gc_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_net_ops);\n\tkmem_cache_destroy(fib6_node_kmem);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int ipv6_route_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct fib6_info *rt = v;\n\tstruct ipv6_route_iter *iter = seq->private;\n\tstruct fib6_nh *fib6_nh = rt->fib6_nh;\n\tunsigned int flags = rt->fib6_flags;\n\tconst struct net_device *dev;\n\n\tif (rt->nh)\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_dst.addr, rt->fib6_dst.plen);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_src.addr, rt->fib6_src.plen);\n#else\n\tseq_puts(seq, \"00000000000000000000000000000000 00 \");\n#endif\n\tif (fib6_nh->fib_nh_gw_family) {\n\t\tflags |= RTF_GATEWAY;\n\t\tseq_printf(seq, \"%pi6\", &fib6_nh->fib_nh_gw6);\n\t} else {\n\t\tseq_puts(seq, \"00000000000000000000000000000000\");\n\t}\n\n\tdev = fib6_nh->fib_nh_dev;\n\tseq_printf(seq, \" %08x %08x %08x %08x %8s\\n\",\n\t\t   rt->fib6_metric, refcount_read(&rt->fib6_ref), 0,\n\t\t   flags, dev ? dev->name : \"\");\n\titer->w.leaf = NULL;\n\treturn 0;\n}\n\nstatic int ipv6_route_yield(struct fib6_walker *w)\n{\n\tstruct ipv6_route_iter *iter = w->args;\n\n\tif (!iter->skip)\n\t\treturn 1;\n\n\tdo {\n\t\titer->w.leaf = rcu_dereference_protected(\n\t\t\t\titer->w.leaf->fib6_next,\n\t\t\t\tlockdep_is_held(&iter->tbl->tb6_lock));\n\t\titer->skip--;\n\t\tif (!iter->skip && iter->w.leaf)\n\t\t\treturn 1;\n\t} while (iter->w.leaf);\n\n\treturn 0;\n}\n\nstatic void ipv6_route_seq_setup_walk(struct ipv6_route_iter *iter,\n\t\t\t\t      struct net *net)\n{\n\tmemset(&iter->w, 0, sizeof(iter->w));\n\titer->w.func = ipv6_route_yield;\n\titer->w.root = &iter->tbl->tb6_root;\n\titer->w.state = FWS_INIT;\n\titer->w.node = iter->w.root;\n\titer->w.args = iter;\n\titer->sernum = iter->w.root->fn_sernum;\n\tINIT_LIST_HEAD(&iter->w.lh);\n\tfib6_walker_link(net, &iter->w);\n}\n\nstatic struct fib6_table *ipv6_route_seq_next_table(struct fib6_table *tbl,\n\t\t\t\t\t\t    struct net *net)\n{\n\tunsigned int h;\n\tstruct hlist_node *node;\n\n\tif (tbl) {\n\t\th = (tbl->tb6_id & (FIB6_TABLE_HASHSZ - 1)) + 1;\n\t\tnode = rcu_dereference_bh(hlist_next_rcu(&tbl->tb6_hlist));\n\t} else {\n\t\th = 0;\n\t\tnode = NULL;\n\t}\n\n\twhile (!node && h < FIB6_TABLE_HASHSZ) {\n\t\tnode = rcu_dereference_bh(\n\t\t\thlist_first_rcu(&net->ipv6.fib_table_hash[h++]));\n\t}\n\treturn hlist_entry_safe(node, struct fib6_table, tb6_hlist);\n}\n\nstatic void ipv6_route_check_sernum(struct ipv6_route_iter *iter)\n{\n\tif (iter->sernum != iter->w.root->fn_sernum) {\n\t\titer->sernum = iter->w.root->fn_sernum;\n\t\titer->w.state = FWS_INIT;\n\t\titer->w.node = iter->w.root;\n\t\tWARN_ON(iter->w.skip);\n\t\titer->w.skip = iter->w.count;\n\t}\n}\n\nstatic void *ipv6_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tint r;\n\tstruct fib6_info *n;\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\tif (!v)\n\t\tgoto iter_table;\n\n\tn = rcu_dereference_bh(((struct fib6_info *)v)->fib6_next);\n\tif (n) {\n\t\t++*pos;\n\t\treturn n;\n\t}\n\niter_table:\n\tipv6_route_check_sernum(iter);\n\tspin_lock_bh(&iter->tbl->tb6_lock);\n\tr = fib6_walk_continue(&iter->w);\n\tspin_unlock_bh(&iter->tbl->tb6_lock);\n\tif (r > 0) {\n\t\tif (v)\n\t\t\t++*pos;\n\t\treturn iter->w.leaf;\n\t} else if (r < 0) {\n\t\tfib6_walker_unlink(net, &iter->w);\n\t\treturn NULL;\n\t}\n\tfib6_walker_unlink(net, &iter->w);\n\n\titer->tbl = ipv6_route_seq_next_table(iter->tbl, net);\n\tif (!iter->tbl)\n\t\treturn NULL;\n\n\tipv6_route_seq_setup_walk(iter, net);\n\tgoto iter_table;\n}\n\nstatic void *ipv6_route_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU_BH)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\trcu_read_lock_bh();\n\titer->tbl = ipv6_route_seq_next_table(NULL, net);\n\titer->skip = *pos;\n\n\tif (iter->tbl) {\n\t\tipv6_route_seq_setup_walk(iter, net);\n\t\treturn ipv6_route_seq_next(seq, NULL, pos);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic bool ipv6_route_iter_active(struct ipv6_route_iter *iter)\n{\n\tstruct fib6_walker *w = &iter->w;\n\treturn w->node && !(w->state == FWS_U && w->node == w->root);\n}\n\nstatic void ipv6_route_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU_BH)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\tif (ipv6_route_iter_active(iter))\n\t\tfib6_walker_unlink(net, &iter->w);\n\n\trcu_read_unlock_bh();\n}\n\nconst struct seq_operations ipv6_route_seq_ops = {\n\t.start\t= ipv6_route_seq_start,\n\t.next\t= ipv6_route_seq_next,\n\t.stop\t= ipv6_route_seq_stop,\n\t.show\t= ipv6_route_seq_show\n};\n#endif /* CONFIG_PROC_FS */\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\tLinux INET6 implementation\n *\tForwarding Information Database\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tChanges:\n *\tYuji SEKIYA @USAGI:\tSupport default route on router node;\n *\t\t\t\tremove ip6_null_entry from the top of\n *\t\t\t\trouting table.\n *\tVille Nuorvala:\t\tFixed routing subtrees.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/lwtunnel.h>\n#include <net/fib_notifier.h>\n\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n\nstatic struct kmem_cache *fib6_node_kmem __read_mostly;\n\nstruct fib6_cleaner {\n\tstruct fib6_walker w;\n\tstruct net *net;\n\tint (*func)(struct fib6_info *, void *arg);\n\tint sernum;\n\tvoid *arg;\n\tbool skip_notify;\n};\n\n#ifdef CONFIG_IPV6_SUBTREES\n#define FWS_INIT FWS_S\n#else\n#define FWS_INIT FWS_L\n#endif\n\nstatic struct fib6_info *fib6_find_prefix(struct net *net,\n\t\t\t\t\t struct fib6_table *table,\n\t\t\t\t\t struct fib6_node *fn);\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t  struct fib6_table *table,\n\t\t\t\t\t  struct fib6_node *fn);\nstatic int fib6_walk(struct net *net, struct fib6_walker *w);\nstatic int fib6_walk_continue(struct fib6_walker *w);\n\n/*\n *\tA routing update causes an increase of the serial number on the\n *\taffected subtree. This allows for cached routes to be asynchronously\n *\ttested when modifications are made to the destination cache as a\n *\tresult of redirects, path MTU changes, etc.\n */\n\nstatic void fib6_gc_timer_cb(struct timer_list *t);\n\n#define FOR_WALKERS(net, w) \\\n\tlist_for_each_entry(w, &(net)->ipv6.fib6_walkers, lh)\n\nstatic void fib6_walker_link(struct net *net, struct fib6_walker *w)\n{\n\twrite_lock_bh(&net->ipv6.fib6_walker_lock);\n\tlist_add(&w->lh, &net->ipv6.fib6_walkers);\n\twrite_unlock_bh(&net->ipv6.fib6_walker_lock);\n}\n\nstatic void fib6_walker_unlink(struct net *net, struct fib6_walker *w)\n{\n\twrite_lock_bh(&net->ipv6.fib6_walker_lock);\n\tlist_del(&w->lh);\n\twrite_unlock_bh(&net->ipv6.fib6_walker_lock);\n}\n\nstatic int fib6_new_sernum(struct net *net)\n{\n\tint new, old;\n\n\tdo {\n\t\told = atomic_read(&net->ipv6.fib6_sernum);\n\t\tnew = old < INT_MAX ? old + 1 : 1;\n\t} while (atomic_cmpxchg(&net->ipv6.fib6_sernum,\n\t\t\t\told, new) != old);\n\treturn new;\n}\n\nenum {\n\tFIB6_NO_SERNUM_CHANGE = 0,\n};\n\nvoid fib6_update_sernum(struct net *net, struct fib6_info *f6i)\n{\n\tstruct fib6_node *fn;\n\n\tfn = rcu_dereference_protected(f6i->fib6_node,\n\t\t\tlockdep_is_held(&f6i->fib6_table->tb6_lock));\n\tif (fn)\n\t\tfn->fn_sernum = fib6_new_sernum(net);\n}\n\n/*\n *\tAuxiliary address test functions for the radix tree.\n *\n *\tThese assume a 32bit processor (although it will work on\n *\t64bit processors)\n */\n\n/*\n *\ttest bit\n */\n#if defined(__LITTLE_ENDIAN)\n# define BITOP_BE32_SWIZZLE\t(0x1F & ~7)\n#else\n# define BITOP_BE32_SWIZZLE\t0\n#endif\n\nstatic __be32 addr_bit_set(const void *token, int fn_bit)\n{\n\tconst __be32 *addr = token;\n\t/*\n\t * Here,\n\t *\t1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)\n\t * is optimized version of\n\t *\thtonl(1 << ((~fn_bit)&0x1F))\n\t * See include/asm-generic/bitops/le.h.\n\t */\n\treturn (__force __be32)(1 << ((~fn_bit ^ BITOP_BE32_SWIZZLE) & 0x1f)) &\n\t       addr[fn_bit >> 5];\n}\n\nstruct fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh)\n{\n\tstruct fib6_info *f6i;\n\tsize_t sz = sizeof(*f6i);\n\n\tif (with_fib6_nh)\n\t\tsz += sizeof(struct fib6_nh);\n\n\tf6i = kzalloc(sz, gfp_flags);\n\tif (!f6i)\n\t\treturn NULL;\n\n\t/* fib6_siblings is a union with nh_list, so this initializes both */\n\tINIT_LIST_HEAD(&f6i->fib6_siblings);\n\trefcount_set(&f6i->fib6_ref, 1);\n\n\treturn f6i;\n}\n\nvoid fib6_info_destroy_rcu(struct rcu_head *head)\n{\n\tstruct fib6_info *f6i = container_of(head, struct fib6_info, rcu);\n\n\tWARN_ON(f6i->fib6_node);\n\n\tif (f6i->nh)\n\t\tnexthop_put(f6i->nh);\n\telse\n\t\tfib6_nh_release(f6i->fib6_nh);\n\n\tip_fib_metrics_put(f6i->fib6_metrics);\n\tkfree(f6i);\n}\nEXPORT_SYMBOL_GPL(fib6_info_destroy_rcu);\n\nstatic struct fib6_node *node_alloc(struct net *net)\n{\n\tstruct fib6_node *fn;\n\n\tfn = kmem_cache_zalloc(fib6_node_kmem, GFP_ATOMIC);\n\tif (fn)\n\t\tnet->ipv6.rt6_stats->fib_nodes++;\n\n\treturn fn;\n}\n\nstatic void node_free_immediate(struct net *net, struct fib6_node *fn)\n{\n\tkmem_cache_free(fib6_node_kmem, fn);\n\tnet->ipv6.rt6_stats->fib_nodes--;\n}\n\nstatic void node_free_rcu(struct rcu_head *head)\n{\n\tstruct fib6_node *fn = container_of(head, struct fib6_node, rcu);\n\n\tkmem_cache_free(fib6_node_kmem, fn);\n}\n\nstatic void node_free(struct net *net, struct fib6_node *fn)\n{\n\tcall_rcu(&fn->rcu, node_free_rcu);\n\tnet->ipv6.rt6_stats->fib_nodes--;\n}\n\nstatic void fib6_free_table(struct fib6_table *table)\n{\n\tinetpeer_invalidate_tree(&table->tb6_peers);\n\tkfree(table);\n}\n\nstatic void fib6_link_table(struct net *net, struct fib6_table *tb)\n{\n\tunsigned int h;\n\n\t/*\n\t * Initialize table lock at a single place to give lockdep a key,\n\t * tables aren't visible prior to being linked to the list.\n\t */\n\tspin_lock_init(&tb->tb6_lock);\n\th = tb->tb6_id & (FIB6_TABLE_HASHSZ - 1);\n\n\t/*\n\t * No protection necessary, this is the only list mutatation\n\t * operation, tables never disappear once they exist.\n\t */\n\thlist_add_head_rcu(&tb->tb6_hlist, &net->ipv6.fib_table_hash[h]);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic struct fib6_table *fib6_alloc_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *table;\n\n\ttable = kzalloc(sizeof(*table), GFP_ATOMIC);\n\tif (table) {\n\t\ttable->tb6_id = id;\n\t\trcu_assign_pointer(table->tb6_root.leaf,\n\t\t\t\t   net->ipv6.fib6_null_entry);\n\t\ttable->tb6_root.fn_flags = RTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\t\tinet_peer_base_init(&table->tb6_peers);\n\t}\n\n\treturn table;\n}\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\ttb = fib6_get_table(net, id);\n\tif (tb)\n\t\treturn tb;\n\n\ttb = fib6_alloc_table(net, id);\n\tif (tb)\n\t\tfib6_link_table(net, tb);\n\n\treturn tb;\n}\nEXPORT_SYMBOL_GPL(fib6_new_table);\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\tif (id == 0)\n\t\tid = RT6_TABLE_MAIN;\n\th = id & (FIB6_TABLE_HASHSZ - 1);\n\trcu_read_lock();\n\thead = &net->ipv6.fib_table_hash[h];\n\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\tif (tb->tb6_id == id) {\n\t\t\trcu_read_unlock();\n\t\t\treturn tb;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(fib6_get_table);\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n\tfib6_link_table(net, net->ipv6.fib6_local_tbl);\n}\n#else\n\nstruct fib6_table *fib6_new_table(struct net *net, u32 id)\n{\n\treturn fib6_get_table(net, id);\n}\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id)\n{\n\t  return net->ipv6.fib6_main_tbl;\n}\n\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}\n\n/* called with rcu lock held; no reference taken on fib6_info */\nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags)\n{\n\treturn fib6_table_lookup(net, net->ipv6.fib6_main_tbl, oif, fl6,\n\t\t\t\t res, flags);\n}\n\nstatic void __net_init fib6_tables_init(struct net *net)\n{\n\tfib6_link_table(net, net->ipv6.fib6_main_tbl);\n}\n\n#endif\n\nunsigned int fib6_tables_seq_read(struct net *net)\n{\n\tunsigned int h, fib_seq = 0;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[h];\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist)\n\t\t\tfib_seq += tb->fib_seq;\n\t}\n\trcu_read_unlock();\n\n\treturn fib_seq;\n}\n\nstatic int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,\n\t\t\t\t    enum fib_event_type event_type,\n\t\t\t\t    struct fib6_info *rt)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.rt = rt,\n\t};\n\n\treturn call_fib6_notifier(nb, net, event_type, &info.info);\n}\n\nint call_fib6_entry_notifiers(struct net *net,\n\t\t\t      enum fib_event_type event_type,\n\t\t\t      struct fib6_info *rt,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.rt = rt,\n\t};\n\n\trt->fib6_table->fib_seq++;\n\treturn call_fib6_notifiers(net, event_type, &info.info);\n}\n\nint call_fib6_multipath_entry_notifiers(struct net *net,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct fib6_info *rt,\n\t\t\t\t\tunsigned int nsiblings,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct fib6_entry_notifier_info info = {\n\t\t.info.extack = extack,\n\t\t.rt = rt,\n\t\t.nsiblings = nsiblings,\n\t};\n\n\trt->fib6_table->fib_seq++;\n\treturn call_fib6_notifiers(net, event_type, &info.info);\n}\n\nstruct fib6_dump_arg {\n\tstruct net *net;\n\tstruct notifier_block *nb;\n};\n\nstatic void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)\n{\n\tif (rt == arg->net->ipv6.fib6_null_entry)\n\t\treturn;\n\tcall_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);\n}\n\nstatic int fib6_node_dump(struct fib6_walker *w)\n{\n\tstruct fib6_info *rt;\n\n\tfor_each_fib6_walker_rt(w)\n\t\tfib6_rt_dump(rt, w->args);\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_table_dump(struct net *net, struct fib6_table *tb,\n\t\t\t    struct fib6_walker *w)\n{\n\tw->root = &tb->tb6_root;\n\tspin_lock_bh(&tb->tb6_lock);\n\tfib6_walk(net, w);\n\tspin_unlock_bh(&tb->tb6_lock);\n}\n\n/* Called with rcu_read_lock() */\nint fib6_tables_dump(struct net *net, struct notifier_block *nb)\n{\n\tstruct fib6_dump_arg arg;\n\tstruct fib6_walker *w;\n\tunsigned int h;\n\n\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\tif (!w)\n\t\treturn -ENOMEM;\n\n\tw->func = fib6_node_dump;\n\targ.net = net;\n\targ.nb = nb;\n\tw->args = &arg;\n\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[h];\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist)\n\t\t\tfib6_table_dump(net, tb, w);\n\t}\n\n\tkfree(w);\n\n\treturn 0;\n}\n\nstatic int fib6_dump_node(struct fib6_walker *w)\n{\n\tint res;\n\tstruct fib6_info *rt;\n\n\tfor_each_fib6_walker_rt(w) {\n\t\tres = rt6_dump_route(rt, w->args, w->skip_in_node);\n\t\tif (res >= 0) {\n\t\t\t/* Frame is full, suspend walking */\n\t\t\tw->leaf = rt;\n\n\t\t\t/* We'll restart from this node, so if some routes were\n\t\t\t * already dumped, skip them next time.\n\t\t\t */\n\t\t\tw->skip_in_node += res;\n\n\t\t\treturn 1;\n\t\t}\n\t\tw->skip_in_node = 0;\n\n\t\t/* Multipath routes are dumped in one route with the\n\t\t * RTA_MULTIPATH attribute. Jump 'rt' to point to the\n\t\t * last sibling of this route (no need to dump the\n\t\t * sibling routes again)\n\t\t */\n\t\tif (rt->fib6_nsiblings)\n\t\t\trt = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t     struct fib6_info,\n\t\t\t\t\t     fib6_siblings);\n\t}\n\tw->leaf = NULL;\n\treturn 0;\n}\n\nstatic void fib6_dump_end(struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(cb->skb->sk);\n\tstruct fib6_walker *w = (void *)cb->args[2];\n\n\tif (w) {\n\t\tif (cb->args[4]) {\n\t\t\tcb->args[4] = 0;\n\t\t\tfib6_walker_unlink(net, w);\n\t\t}\n\t\tcb->args[2] = 0;\n\t\tkfree(w);\n\t}\n\tcb->done = (void *)cb->args[3];\n\tcb->args[1] = 3;\n}\n\nstatic int fib6_dump_done(struct netlink_callback *cb)\n{\n\tfib6_dump_end(cb);\n\treturn cb->done ? cb->done(cb) : 0;\n}\n\nstatic int fib6_dump_table(struct fib6_table *table, struct sk_buff *skb,\n\t\t\t   struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct fib6_walker *w;\n\tint res;\n\n\tw = (void *)cb->args[2];\n\tw->root = &table->tb6_root;\n\n\tif (cb->args[4] == 0) {\n\t\tw->count = 0;\n\t\tw->skip = 0;\n\t\tw->skip_in_node = 0;\n\n\t\tspin_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk(net, w);\n\t\tspin_unlock_bh(&table->tb6_lock);\n\t\tif (res > 0) {\n\t\t\tcb->args[4] = 1;\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t}\n\t} else {\n\t\tif (cb->args[5] != w->root->fn_sernum) {\n\t\t\t/* Begin at the root if the tree changed */\n\t\t\tcb->args[5] = w->root->fn_sernum;\n\t\t\tw->state = FWS_INIT;\n\t\t\tw->node = w->root;\n\t\t\tw->skip = w->count;\n\t\t\tw->skip_in_node = 0;\n\t\t} else\n\t\t\tw->skip = 0;\n\n\t\tspin_lock_bh(&table->tb6_lock);\n\t\tres = fib6_walk_continue(w);\n\t\tspin_unlock_bh(&table->tb6_lock);\n\t\tif (res <= 0) {\n\t\t\tfib6_walker_unlink(net, w);\n\t\t\tcb->args[4] = 0;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int inet6_dump_fib(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct rt6_rtnl_dump_arg arg = { .filter.dump_exceptions = true,\n\t\t\t\t\t .filter.dump_routes = true };\n\tconst struct nlmsghdr *nlh = cb->nlh;\n\tstruct net *net = sock_net(skb->sk);\n\tunsigned int h, s_h;\n\tunsigned int e = 0, s_e;\n\tstruct fib6_walker *w;\n\tstruct fib6_table *tb;\n\tstruct hlist_head *head;\n\tint res = 0;\n\n\tif (cb->strict_check) {\n\t\tint err;\n\n\t\terr = ip_valid_fib_dump_req(net, nlh, &arg.filter, cb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else if (nlmsg_len(nlh) >= sizeof(struct rtmsg)) {\n\t\tstruct rtmsg *rtm = nlmsg_data(nlh);\n\n\t\tif (rtm->rtm_flags & RTM_F_PREFIX)\n\t\t\targ.filter.flags = RTM_F_PREFIX;\n\t}\n\n\tw = (void *)cb->args[2];\n\tif (!w) {\n\t\t/* New dump:\n\t\t *\n\t\t * 1. hook callback destructor.\n\t\t */\n\t\tcb->args[3] = (long)cb->done;\n\t\tcb->done = fib6_dump_done;\n\n\t\t/*\n\t\t * 2. allocate and initialize walker.\n\t\t */\n\t\tw = kzalloc(sizeof(*w), GFP_ATOMIC);\n\t\tif (!w)\n\t\t\treturn -ENOMEM;\n\t\tw->func = fib6_dump_node;\n\t\tcb->args[2] = (long)w;\n\t}\n\n\targ.skb = skb;\n\targ.cb = cb;\n\targ.net = net;\n\tw->args = &arg;\n\n\tif (arg.filter.table_id) {\n\t\ttb = fib6_get_table(net, arg.filter.table_id);\n\t\tif (!tb) {\n\t\t\tif (arg.filter.dump_all_families)\n\t\t\t\tgoto out;\n\n\t\t\tNL_SET_ERR_MSG_MOD(cb->extack, \"FIB table does not exist\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!cb->args[0]) {\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (!res)\n\t\t\t\tcb->args[0] = 1;\n\t\t}\n\t\tgoto out;\n\t}\n\n\ts_h = cb->args[0];\n\ts_e = cb->args[1];\n\n\trcu_read_lock();\n\tfor (h = s_h; h < FIB6_TABLE_HASHSZ; h++, s_e = 0) {\n\t\te = 0;\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(tb, head, tb6_hlist) {\n\t\t\tif (e < s_e)\n\t\t\t\tgoto next;\n\t\t\tres = fib6_dump_table(tb, skb, cb);\n\t\t\tif (res != 0)\n\t\t\t\tgoto out_unlock;\nnext:\n\t\t\te++;\n\t\t}\n\t}\nout_unlock:\n\trcu_read_unlock();\n\tcb->args[1] = e;\n\tcb->args[0] = h;\nout:\n\tres = res < 0 ? res : skb->len;\n\tif (res <= 0)\n\t\tfib6_dump_end(cb);\n\treturn res;\n}\n\nvoid fib6_metric_set(struct fib6_info *f6i, int metric, u32 val)\n{\n\tif (!f6i)\n\t\treturn;\n\n\tif (f6i->fib6_metrics == &dst_default_metrics) {\n\t\tstruct dst_metrics *p = kzalloc(sizeof(*p), GFP_ATOMIC);\n\n\t\tif (!p)\n\t\t\treturn;\n\n\t\trefcount_set(&p->refcnt, 1);\n\t\tf6i->fib6_metrics = p;\n\t}\n\n\tf6i->fib6_metrics->metrics[metric - 1] = val;\n}\n\n/*\n *\tRouting Table\n *\n *\treturn the appropriate node for a routing tree \"add\" operation\n *\tby either creating and inserting or by returning an existing\n *\tnode.\n */\n\nstatic struct fib6_node *fib6_add_1(struct net *net,\n\t\t\t\t    struct fib6_table *table,\n\t\t\t\t    struct fib6_node *root,\n\t\t\t\t    struct in6_addr *addr, int plen,\n\t\t\t\t    int offset, int allow_create,\n\t\t\t\t    int replace_required,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_node *fn, *in, *ln;\n\tstruct fib6_node *pn = NULL;\n\tstruct rt6key *key;\n\tint\tbit;\n\t__be32\tdir = 0;\n\n\tRT6_TRACE(\"fib6_add_1\\n\");\n\n\t/* insert node in tree */\n\n\tfn = root;\n\n\tdo {\n\t\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tkey = (struct rt6key *)((u8 *)leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit)) {\n\t\t\tif (!allow_create) {\n\t\t\t\tif (replace_required) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t\t       \"Can not replace route - no match found\");\n\t\t\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\t\t\treturn ERR_PTR(-ENOENT);\n\t\t\t\t}\n\t\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t\t\t}\n\t\t\tgoto insert_above;\n\t\t}\n\n\t\t/*\n\t\t *\tExact match ?\n\t\t */\n\n\t\tif (plen == fn->fn_bit) {\n\t\t\t/* clean up an intermediate node */\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\t\tRCU_INIT_POINTER(fn->leaf, NULL);\n\t\t\t\tfib6_info_release(leaf);\n\t\t\t/* remove null_entry in the root node */\n\t\t\t} else if (fn->fn_flags & RTN_TL_ROOT &&\n\t\t\t\t   rcu_access_pointer(fn->leaf) ==\n\t\t\t\t   net->ipv6.fib6_null_entry) {\n\t\t\t\tRCU_INIT_POINTER(fn->leaf, NULL);\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\n\t\t/* Try to walk down on tree. */\n\t\tdir = addr_bit_set(addr, fn->fn_bit);\n\t\tpn = fn;\n\t\tfn = dir ?\n\t\t     rcu_dereference_protected(fn->right,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock)) :\n\t\t     rcu_dereference_protected(fn->left,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t} while (fn);\n\n\tif (!allow_create) {\n\t\t/* We should not create new node because\n\t\t * NLM_F_REPLACE was specified without NLM_F_CREATE\n\t\t * I assume it is safe to require NLM_F_CREATE when\n\t\t * REPLACE flag is used! Later we may want to remove the\n\t\t * check for replace_required, because according\n\t\t * to netlink specification, NLM_F_CREATE\n\t\t * MUST be specified if new route is created.\n\t\t * That would keep IPv6 consistent with IPv4\n\t\t */\n\t\tif (replace_required) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Can not replace route - no match found\");\n\t\t\tpr_warn(\"Can't replace route, no match found\\n\");\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\t}\n\t/*\n\t *\tWe walked to the bottom of tree.\n\t *\tCreate new leaf node without children.\n\t */\n\n\tln = node_alloc(net);\n\n\tif (!ln)\n\t\treturn ERR_PTR(-ENOMEM);\n\tln->fn_bit = plen;\n\tRCU_INIT_POINTER(ln->parent, pn);\n\n\tif (dir)\n\t\trcu_assign_pointer(pn->right, ln);\n\telse\n\t\trcu_assign_pointer(pn->left, ln);\n\n\treturn ln;\n\n\ninsert_above:\n\t/*\n\t * split since we don't have a common prefix anymore or\n\t * we have a less significant route.\n\t * we've to insert an intermediate node on the list\n\t * this new node will point to the one we need to create\n\t * and the current\n\t */\n\n\tpn = rcu_dereference_protected(fn->parent,\n\t\t\t\t       lockdep_is_held(&table->tb6_lock));\n\n\t/* find 1st bit in difference between the 2 addrs.\n\n\t   See comment in __ipv6_addr_diff: bit may be an invalid value,\n\t   but if it is >= plen, the value is ignored in any case.\n\t */\n\n\tbit = __ipv6_addr_diff(addr, &key->addr, sizeof(*addr));\n\n\t/*\n\t *\t\t(intermediate)[in]\n\t *\t          /\t   \\\n\t *\t(new leaf node)[ln] (old node)[fn]\n\t */\n\tif (plen > bit) {\n\t\tin = node_alloc(net);\n\t\tln = node_alloc(net);\n\n\t\tif (!in || !ln) {\n\t\t\tif (in)\n\t\t\t\tnode_free_immediate(net, in);\n\t\t\tif (ln)\n\t\t\t\tnode_free_immediate(net, ln);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\t/*\n\t\t * new intermediate node.\n\t\t * RTN_RTINFO will\n\t\t * be off since that an address that chooses one of\n\t\t * the branches would not match less specific routes\n\t\t * in the other branch\n\t\t */\n\n\t\tin->fn_bit = bit;\n\n\t\tRCU_INIT_POINTER(in->parent, pn);\n\t\tin->leaf = fn->leaf;\n\t\tfib6_info_hold(rcu_dereference_protected(in->leaf,\n\t\t\t\tlockdep_is_held(&table->tb6_lock)));\n\n\t\t/* update parent pointer */\n\t\tif (dir)\n\t\t\trcu_assign_pointer(pn->right, in);\n\t\telse\n\t\t\trcu_assign_pointer(pn->left, in);\n\n\t\tln->fn_bit = plen;\n\n\t\tRCU_INIT_POINTER(ln->parent, in);\n\t\trcu_assign_pointer(fn->parent, in);\n\n\t\tif (addr_bit_set(addr, bit)) {\n\t\t\trcu_assign_pointer(in->right, ln);\n\t\t\trcu_assign_pointer(in->left, fn);\n\t\t} else {\n\t\t\trcu_assign_pointer(in->left, ln);\n\t\t\trcu_assign_pointer(in->right, fn);\n\t\t}\n\t} else { /* plen <= bit */\n\n\t\t/*\n\t\t *\t\t(new leaf node)[ln]\n\t\t *\t          /\t   \\\n\t\t *\t     (old node)[fn] NULL\n\t\t */\n\n\t\tln = node_alloc(net);\n\n\t\tif (!ln)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tln->fn_bit = plen;\n\n\t\tRCU_INIT_POINTER(ln->parent, pn);\n\n\t\tif (addr_bit_set(&key->addr, plen))\n\t\t\tRCU_INIT_POINTER(ln->right, fn);\n\t\telse\n\t\t\tRCU_INIT_POINTER(ln->left, fn);\n\n\t\trcu_assign_pointer(fn->parent, ln);\n\n\t\tif (dir)\n\t\t\trcu_assign_pointer(pn->right, ln);\n\t\telse\n\t\t\trcu_assign_pointer(pn->left, ln);\n\t}\n\treturn ln;\n}\n\nstatic void __fib6_drop_pcpu_from(struct fib6_nh *fib6_nh,\n\t\t\t\t  const struct fib6_info *match,\n\t\t\t\t  const struct fib6_table *table)\n{\n\tint cpu;\n\n\tif (!fib6_nh->rt6i_pcpu)\n\t\treturn;\n\n\t/* release the reference to this fib entry from\n\t * all of its cached pcpu routes\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct rt6_info **ppcpu_rt;\n\t\tstruct rt6_info *pcpu_rt;\n\n\t\tppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);\n\t\tpcpu_rt = *ppcpu_rt;\n\n\t\t/* only dropping the 'from' reference if the cached route\n\t\t * is using 'match'. The cached pcpu_rt->from only changes\n\t\t * from a fib6_info to NULL (ip6_dst_destroy); it can never\n\t\t * change from one fib6_info reference to another\n\t\t */\n\t\tif (pcpu_rt && rcu_access_pointer(pcpu_rt->from) == match) {\n\t\t\tstruct fib6_info *from;\n\n\t\t\tfrom = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);\n\t\t\tfib6_info_release(from);\n\t\t}\n\t}\n}\n\nstruct fib6_nh_pcpu_arg {\n\tstruct fib6_info\t*from;\n\tconst struct fib6_table *table;\n};\n\nstatic int fib6_nh_drop_pcpu_from(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_pcpu_arg *arg = _arg;\n\n\t__fib6_drop_pcpu_from(nh, arg->from, arg->table);\n\treturn 0;\n}\n\nstatic void fib6_drop_pcpu_from(struct fib6_info *f6i,\n\t\t\t\tconst struct fib6_table *table)\n{\n\t/* Make sure rt6_make_pcpu_route() wont add other percpu routes\n\t * while we are cleaning them here.\n\t */\n\tf6i->fib6_destroying = 1;\n\tmb(); /* paired with the cmpxchg() in rt6_make_pcpu_route() */\n\n\tif (f6i->nh) {\n\t\tstruct fib6_nh_pcpu_arg arg = {\n\t\t\t.from = f6i,\n\t\t\t.table = table\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(f6i->nh, fib6_nh_drop_pcpu_from,\n\t\t\t\t\t &arg);\n\t} else {\n\t\tstruct fib6_nh *fib6_nh;\n\n\t\tfib6_nh = f6i->fib6_nh;\n\t\t__fib6_drop_pcpu_from(fib6_nh, f6i, table);\n\t}\n}\n\nstatic void fib6_purge_rt(struct fib6_info *rt, struct fib6_node *fn,\n\t\t\t  struct net *net)\n{\n\tstruct fib6_table *table = rt->fib6_table;\n\n\tfib6_drop_pcpu_from(rt, table);\n\n\tif (rt->nh && !list_empty(&rt->nh_list))\n\t\tlist_del_init(&rt->nh_list);\n\n\tif (refcount_read(&rt->fib6_ref) != 1) {\n\t\t/* This route is used as dummy address holder in some split\n\t\t * nodes. It is not leaked, but it still holds other resources,\n\t\t * which must be released in time. So, scan ascendant nodes\n\t\t * and replace dummy references to this route with references\n\t\t * to still alive ones.\n\t\t */\n\t\twhile (fn) {\n\t\t\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tstruct fib6_info *new_leaf;\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO) && leaf == rt) {\n\t\t\t\tnew_leaf = fib6_find_prefix(net, table, fn);\n\t\t\t\tfib6_info_hold(new_leaf);\n\n\t\t\t\trcu_assign_pointer(fn->leaf, new_leaf);\n\t\t\t\tfib6_info_release(rt);\n\t\t\t}\n\t\t\tfn = rcu_dereference_protected(fn->parent,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t}\n\t}\n}\n\n/*\n *\tInsert routing information in a node.\n */\n\nstatic int fib6_add_rt2node(struct fib6_node *fn, struct fib6_info *rt,\n\t\t\t    struct nl_info *info,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_info *iter = NULL;\n\tstruct fib6_info __rcu **ins;\n\tstruct fib6_info __rcu **fallback_ins = NULL;\n\tint replace = (info->nlh &&\n\t\t       (info->nlh->nlmsg_flags & NLM_F_REPLACE));\n\tint add = (!info->nlh ||\n\t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n\tint found = 0;\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tu16 nlflags = NLM_F_EXCL;\n\tint err;\n\n\tif (info->nlh && (info->nlh->nlmsg_flags & NLM_F_APPEND))\n\t\tnlflags |= NLM_F_APPEND;\n\n\tins = &fn->leaf;\n\n\tfor (iter = leaf; iter;\n\t     iter = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock))) {\n\t\t/*\n\t\t *\tSearch for duplicates\n\t\t */\n\n\t\tif (iter->fib6_metric == rt->fib6_metric) {\n\t\t\t/*\n\t\t\t *\tSame priority level\n\t\t\t */\n\t\t\tif (info->nlh &&\n\t\t\t    (info->nlh->nlmsg_flags & NLM_F_EXCL))\n\t\t\t\treturn -EEXIST;\n\n\t\t\tnlflags &= ~NLM_F_EXCL;\n\t\t\tif (replace) {\n\t\t\t\tif (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\tfound++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (rt_can_ecmp)\n\t\t\t\t\tfallback_ins = fallback_ins ?: ins;\n\t\t\t\tgoto next_iter;\n\t\t\t}\n\n\t\t\tif (rt6_duplicate_nexthop(iter, rt)) {\n\t\t\t\tif (rt->fib6_nsiblings)\n\t\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tif (!(iter->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\treturn -EEXIST;\n\t\t\t\tif (!(rt->fib6_flags & RTF_EXPIRES))\n\t\t\t\t\tfib6_clean_expires(iter);\n\t\t\t\telse\n\t\t\t\t\tfib6_set_expires(iter, rt->expires);\n\n\t\t\t\tif (rt->fib6_pmtu)\n\t\t\t\t\tfib6_metric_set(iter, RTAX_MTU,\n\t\t\t\t\t\t\trt->fib6_pmtu);\n\t\t\t\treturn -EEXIST;\n\t\t\t}\n\t\t\t/* If we have the same destination and the same metric,\n\t\t\t * but not the same gateway, then the route we try to\n\t\t\t * add is sibling to this route, increment our counter\n\t\t\t * of siblings, and later we will add our route to the\n\t\t\t * list.\n\t\t\t * Only static routes (which don't have flag\n\t\t\t * RTF_EXPIRES) are used for ECMPv6.\n\t\t\t *\n\t\t\t * To avoid long list, we only had siblings if the\n\t\t\t * route have a gateway.\n\t\t\t */\n\t\t\tif (rt_can_ecmp &&\n\t\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\t\trt->fib6_nsiblings++;\n\t\t}\n\n\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\tbreak;\n\nnext_iter:\n\t\tins = &iter->fib6_next;\n\t}\n\n\tif (fallback_ins && !found) {\n\t\t/* No ECMP-able route found, replace first non-ECMP one */\n\t\tins = fallback_ins;\n\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\tfound++;\n\t}\n\n\t/* Reset round-robin state, if necessary */\n\tif (ins == &fn->leaf)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Link this route to others same route. */\n\tif (rt->fib6_nsiblings) {\n\t\tunsigned int fib6_nsiblings;\n\t\tstruct fib6_info *sibling, *temp_sibling;\n\n\t\t/* Find the first route that have the same metric */\n\t\tsibling = leaf;\n\t\twhile (sibling) {\n\t\t\tif (sibling->fib6_metric == rt->fib6_metric &&\n\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n\t\t\t\tlist_add_tail(&rt->fib6_siblings,\n\t\t\t\t\t      &sibling->fib6_siblings);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsibling = rcu_dereference_protected(sibling->fib6_next,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t}\n\t\t/* For each sibling in the list, increment the counter of\n\t\t * siblings. BUG() if counters does not match, list of siblings\n\t\t * is broken!\n\t\t */\n\t\tfib6_nsiblings = 0;\n\t\tlist_for_each_entry_safe(sibling, temp_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tsibling->fib6_nsiblings++;\n\t\t\tBUG_ON(sibling->fib6_nsiblings != rt->fib6_nsiblings);\n\t\t\tfib6_nsiblings++;\n\t\t}\n\t\tBUG_ON(fib6_nsiblings != rt->fib6_nsiblings);\n\t\trt6_multipath_rebalance(temp_sibling);\n\t}\n\n\t/*\n\t *\tinsert node\n\t */\n\tif (!replace) {\n\t\tif (!add)\n\t\t\tpr_warn(\"NLM_F_CREATE should be set when creating new route\\n\");\n\nadd:\n\t\tnlflags |= NLM_F_CREATE;\n\n\t\tif (!info->skip_notify_kernel) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_ADD,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err) {\n\t\t\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\t\t\t/* If the route has siblings, then it first\n\t\t\t\t * needs to be unlinked from them.\n\t\t\t\t */\n\t\t\t\tif (!rt->fib6_nsiblings)\n\t\t\t\t\treturn err;\n\n\t\t\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t\t\t fib6_siblings)\n\t\t\t\t\tsibling->fib6_nsiblings--;\n\t\t\t\trt->fib6_nsiblings = 0;\n\t\t\t\tlist_del_init(&rt->fib6_siblings);\n\t\t\t\trt6_multipath_rebalance(next_sibling);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\trcu_assign_pointer(rt->fib6_next, iter);\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries++;\n\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\n\t} else {\n\t\tint nsiblings;\n\n\t\tif (!found) {\n\t\t\tif (add)\n\t\t\t\tgoto add;\n\t\t\tpr_warn(\"NLM_F_REPLACE set, but no existing node found!\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (!info->skip_notify_kernel) {\n\t\t\terr = call_fib6_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\tFIB_EVENT_ENTRY_REPLACE,\n\t\t\t\t\t\t\trt, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfib6_info_hold(rt);\n\t\trcu_assign_pointer(rt->fib6_node, fn);\n\t\trt->fib6_next = iter->fib6_next;\n\t\trcu_assign_pointer(*ins, rt);\n\t\tif (!info->skip_notify)\n\t\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);\n\t\tif (!(fn->fn_flags & RTN_RTINFO)) {\n\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_route_nodes++;\n\t\t\tfn->fn_flags |= RTN_RTINFO;\n\t\t}\n\t\tnsiblings = iter->fib6_nsiblings;\n\t\titer->fib6_node = NULL;\n\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\tfn->rr_ptr = NULL;\n\t\tfib6_info_release(iter);\n\n\t\tif (nsiblings) {\n\t\t\t/* Replacing an ECMP route, remove all siblings */\n\t\t\tins = &rt->fib6_next;\n\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\twhile (iter) {\n\t\t\t\tif (iter->fib6_metric > rt->fib6_metric)\n\t\t\t\t\tbreak;\n\t\t\t\tif (rt6_qualify_for_ecmp(iter)) {\n\t\t\t\t\t*ins = iter->fib6_next;\n\t\t\t\t\titer->fib6_node = NULL;\n\t\t\t\t\tfib6_purge_rt(iter, fn, info->nl_net);\n\t\t\t\t\tif (rcu_access_pointer(fn->rr_ptr) == iter)\n\t\t\t\t\t\tfn->rr_ptr = NULL;\n\t\t\t\t\tfib6_info_release(iter);\n\t\t\t\t\tnsiblings--;\n\t\t\t\t\tinfo->nl_net->ipv6.rt6_stats->fib_rt_entries--;\n\t\t\t\t} else {\n\t\t\t\t\tins = &iter->fib6_next;\n\t\t\t\t}\n\t\t\t\titer = rcu_dereference_protected(*ins,\n\t\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t\t\t}\n\t\t\tWARN_ON(nsiblings != 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fib6_start_gc(struct net *net, struct fib6_info *rt)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer) &&\n\t    (rt->fib6_flags & RTF_EXPIRES))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nvoid fib6_force_start_gc(struct net *net)\n{\n\tif (!timer_pending(&net->ipv6.ip6_fib_timer))\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);\n}\n\nstatic void __fib6_update_sernum_upto_root(struct fib6_info *rt,\n\t\t\t\t\t   int sernum)\n{\n\tstruct fib6_node *fn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\n\t/* paired with smp_rmb() in rt6_get_cookie_safe() */\n\tsmp_wmb();\n\twhile (fn) {\n\t\tfn->fn_sernum = sernum;\n\t\tfn = rcu_dereference_protected(fn->parent,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t}\n}\n\nvoid fib6_update_sernum_upto_root(struct net *net, struct fib6_info *rt)\n{\n\t__fib6_update_sernum_upto_root(rt, fib6_new_sernum(net));\n}\n\n/* allow ipv4 to update sernum via ipv6_stub */\nvoid fib6_update_sernum_stub(struct net *net, struct fib6_info *f6i)\n{\n\tspin_lock_bh(&f6i->fib6_table->tb6_lock);\n\tfib6_update_sernum_upto_root(net, f6i);\n\tspin_unlock_bh(&f6i->fib6_table->tb6_lock);\n}\n\n/*\n *\tAdd routing information to the routing tree.\n *\t<destination addr>/<source addr>\n *\twith source addr info in sub-trees\n *\tNeed to own table->tb6_lock\n */\n\nint fib6_add(struct fib6_node *root, struct fib6_info *rt,\n\t     struct nl_info *info, struct netlink_ext_ack *extack)\n{\n\tstruct fib6_table *table = rt->fib6_table;\n\tstruct fib6_node *fn, *pn = NULL;\n\tint err = -ENOMEM;\n\tint allow_create = 1;\n\tint replace_required = 0;\n\tint sernum = fib6_new_sernum(info->nl_net);\n\n\tif (info->nlh) {\n\t\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\t\tallow_create = 0;\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treplace_required = 1;\n\t}\n\tif (!allow_create && !replace_required)\n\t\tpr_warn(\"RTM_NEWROUTE with no NLM_F_CREATE or NLM_F_REPLACE\\n\");\n\n\tfn = fib6_add_1(info->nl_net, table, root,\n\t\t\t&rt->fib6_dst.addr, rt->fib6_dst.plen,\n\t\t\toffsetof(struct fib6_info, fib6_dst), allow_create,\n\t\t\treplace_required, extack);\n\tif (IS_ERR(fn)) {\n\t\terr = PTR_ERR(fn);\n\t\tfn = NULL;\n\t\tgoto out;\n\t}\n\n\tpn = fn;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt->fib6_src.plen) {\n\t\tstruct fib6_node *sn;\n\n\t\tif (!rcu_access_pointer(fn->subtree)) {\n\t\t\tstruct fib6_node *sfn;\n\n\t\t\t/*\n\t\t\t * Create subtree.\n\t\t\t *\n\t\t\t *\t\tfn[main tree]\n\t\t\t *\t\t|\n\t\t\t *\t\tsfn[subtree root]\n\t\t\t *\t\t   \\\n\t\t\t *\t\t    sn[new leaf node]\n\t\t\t */\n\n\t\t\t/* Create subtree root node */\n\t\t\tsfn = node_alloc(info->nl_net);\n\t\t\tif (!sfn)\n\t\t\t\tgoto failure;\n\n\t\t\tfib6_info_hold(info->nl_net->ipv6.fib6_null_entry);\n\t\t\trcu_assign_pointer(sfn->leaf,\n\t\t\t\t\t   info->nl_net->ipv6.fib6_null_entry);\n\t\t\tsfn->fn_flags = RTN_ROOT;\n\n\t\t\t/* Now add the first leaf node to new subtree */\n\n\t\t\tsn = fib6_add_1(info->nl_net, table, sfn,\n\t\t\t\t\t&rt->fib6_src.addr, rt->fib6_src.plen,\n\t\t\t\t\toffsetof(struct fib6_info, fib6_src),\n\t\t\t\t\tallow_create, replace_required, extack);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\t/* If it is failed, discard just allocated\n\t\t\t\t   root, and then (in failure) stale node\n\t\t\t\t   in main tree.\n\t\t\t\t */\n\t\t\t\tnode_free_immediate(info->nl_net, sfn);\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto failure;\n\t\t\t}\n\n\t\t\t/* Now link new subtree to main tree */\n\t\t\trcu_assign_pointer(sfn->parent, fn);\n\t\t\trcu_assign_pointer(fn->subtree, sfn);\n\t\t} else {\n\t\t\tsn = fib6_add_1(info->nl_net, table, FIB6_SUBTREE(fn),\n\t\t\t\t\t&rt->fib6_src.addr, rt->fib6_src.plen,\n\t\t\t\t\toffsetof(struct fib6_info, fib6_src),\n\t\t\t\t\tallow_create, replace_required, extack);\n\n\t\t\tif (IS_ERR(sn)) {\n\t\t\t\terr = PTR_ERR(sn);\n\t\t\t\tgoto failure;\n\t\t\t}\n\t\t}\n\n\t\tif (!rcu_access_pointer(fn->leaf)) {\n\t\t\tif (fn->fn_flags & RTN_TL_ROOT) {\n\t\t\t\t/* put back null_entry for root node */\n\t\t\t\trcu_assign_pointer(fn->leaf,\n\t\t\t\t\t    info->nl_net->ipv6.fib6_null_entry);\n\t\t\t} else {\n\t\t\t\tfib6_info_hold(rt);\n\t\t\t\trcu_assign_pointer(fn->leaf, rt);\n\t\t\t}\n\t\t}\n\t\tfn = sn;\n\t}\n#endif\n\n\terr = fib6_add_rt2node(fn, rt, info, extack);\n\tif (!err) {\n\t\tif (rt->nh)\n\t\t\tlist_add(&rt->nh_list, &rt->nh->f6i_list);\n\t\t__fib6_update_sernum_upto_root(rt, sernum);\n\t\tfib6_start_gc(info->nl_net, rt);\n\t}\n\nout:\n\tif (err) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t/*\n\t\t * If fib6_add_1 has cleared the old leaf pointer in the\n\t\t * super-tree leaf node we have to find a new one for it.\n\t\t */\n\t\tif (pn != fn) {\n\t\t\tstruct fib6_info *pn_leaf =\n\t\t\t\trcu_dereference_protected(pn->leaf,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (pn_leaf == rt) {\n\t\t\t\tpn_leaf = NULL;\n\t\t\t\tRCU_INIT_POINTER(pn->leaf, NULL);\n\t\t\t\tfib6_info_release(rt);\n\t\t\t}\n\t\t\tif (!pn_leaf && !(pn->fn_flags & RTN_RTINFO)) {\n\t\t\t\tpn_leaf = fib6_find_prefix(info->nl_net, table,\n\t\t\t\t\t\t\t   pn);\n#if RT6_DEBUG >= 2\n\t\t\t\tif (!pn_leaf) {\n\t\t\t\t\tWARN_ON(!pn_leaf);\n\t\t\t\t\tpn_leaf =\n\t\t\t\t\t    info->nl_net->ipv6.fib6_null_entry;\n\t\t\t\t}\n#endif\n\t\t\t\tfib6_info_hold(pn_leaf);\n\t\t\t\trcu_assign_pointer(pn->leaf, pn_leaf);\n\t\t\t}\n\t\t}\n#endif\n\t\tgoto failure;\n\t}\n\treturn err;\n\nfailure:\n\t/* fn->leaf could be NULL and fib6_repair_tree() needs to be called if:\n\t * 1. fn is an intermediate node and we failed to add the new\n\t * route to it in both subtree creation failure and fib6_add_rt2node()\n\t * failure case.\n\t * 2. fn is the root node in the table and we fail to add the first\n\t * default route to it.\n\t */\n\tif (fn &&\n\t    (!(fn->fn_flags & (RTN_RTINFO|RTN_ROOT)) ||\n\t     (fn->fn_flags & RTN_TL_ROOT &&\n\t      !rcu_access_pointer(fn->leaf))))\n\t\tfib6_repair_tree(info->nl_net, table, fn);\n\treturn err;\n}\n\n/*\n *\tRouting tree lookup\n *\n */\n\nstruct lookup_args {\n\tint\t\t\toffset;\t\t/* key offset on fib6_info */\n\tconst struct in6_addr\t*addr;\t\t/* search key\t\t\t*/\n};\n\nstatic struct fib6_node *fib6_node_lookup_1(struct fib6_node *root,\n\t\t\t\t\t    struct lookup_args *args)\n{\n\tstruct fib6_node *fn;\n\t__be32 dir;\n\n\tif (unlikely(args->offset == 0))\n\t\treturn NULL;\n\n\t/*\n\t *\tDescend on a tree\n\t */\n\n\tfn = root;\n\n\tfor (;;) {\n\t\tstruct fib6_node *next;\n\n\t\tdir = addr_bit_set(args->addr, fn->fn_bit);\n\n\t\tnext = dir ? rcu_dereference(fn->right) :\n\t\t\t     rcu_dereference(fn->left);\n\n\t\tif (next) {\n\t\t\tfn = next;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\twhile (fn) {\n\t\tstruct fib6_node *subtree = FIB6_SUBTREE(fn);\n\n\t\tif (subtree || fn->fn_flags & RTN_RTINFO) {\n\t\t\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\t\t\tstruct rt6key *key;\n\n\t\t\tif (!leaf)\n\t\t\t\tgoto backtrack;\n\n\t\t\tkey = (struct rt6key *) ((u8 *)leaf + args->offset);\n\n\t\t\tif (ipv6_prefix_equal(&key->addr, args->addr, key->plen)) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\tif (subtree) {\n\t\t\t\t\tstruct fib6_node *sfn;\n\t\t\t\t\tsfn = fib6_node_lookup_1(subtree,\n\t\t\t\t\t\t\t\t args + 1);\n\t\t\t\t\tif (!sfn)\n\t\t\t\t\t\tgoto backtrack;\n\t\t\t\t\tfn = sfn;\n\t\t\t\t}\n#endif\n\t\t\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\t\t\treturn fn;\n\t\t\t}\n\t\t}\nbacktrack:\n\t\tif (fn->fn_flags & RTN_ROOT)\n\t\t\tbreak;\n\n\t\tfn = rcu_dereference(fn->parent);\n\t}\n\n\treturn NULL;\n}\n\n/* called with rcu_read_lock() held\n */\nstruct fib6_node *fib6_node_lookup(struct fib6_node *root,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct fib6_node *fn;\n\tstruct lookup_args args[] = {\n\t\t{\n\t\t\t.offset = offsetof(struct fib6_info, fib6_dst),\n\t\t\t.addr = daddr,\n\t\t},\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t{\n\t\t\t.offset = offsetof(struct fib6_info, fib6_src),\n\t\t\t.addr = saddr,\n\t\t},\n#endif\n\t\t{\n\t\t\t.offset = 0,\t/* sentinel */\n\t\t}\n\t};\n\n\tfn = fib6_node_lookup_1(root, daddr ? args : args + 1);\n\tif (!fn || fn->fn_flags & RTN_TL_ROOT)\n\t\tfn = root;\n\n\treturn fn;\n}\n\n/*\n *\tGet node with specified destination prefix (and source prefix,\n *\tif subtrees are used)\n *\texact_match == true means we try to find fn with exact match of\n *\tthe passed in prefix addr\n *\texact_match == false means we try to find fn with longest prefix\n *\tmatch of the passed in prefix addr. This is useful for finding fn\n *\tfor cached route as it will be stored in the exception table under\n *\tthe node with longest prefix length.\n */\n\n\nstatic struct fib6_node *fib6_locate_1(struct fib6_node *root,\n\t\t\t\t       const struct in6_addr *addr,\n\t\t\t\t       int plen, int offset,\n\t\t\t\t       bool exact_match)\n{\n\tstruct fib6_node *fn, *prev = NULL;\n\n\tfor (fn = root; fn ; ) {\n\t\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\t\tstruct rt6key *key;\n\n\t\t/* This node is being deleted */\n\t\tif (!leaf) {\n\t\t\tif (plen <= fn->fn_bit)\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tkey = (struct rt6key *)((u8 *)leaf + offset);\n\n\t\t/*\n\t\t *\tPrefix match\n\t\t */\n\t\tif (plen < fn->fn_bit ||\n\t\t    !ipv6_prefix_equal(&key->addr, addr, fn->fn_bit))\n\t\t\tgoto out;\n\n\t\tif (plen == fn->fn_bit)\n\t\t\treturn fn;\n\n\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\tprev = fn;\n\nnext:\n\t\t/*\n\t\t *\tWe have more bits to go\n\t\t */\n\t\tif (addr_bit_set(addr, fn->fn_bit))\n\t\t\tfn = rcu_dereference(fn->right);\n\t\telse\n\t\t\tfn = rcu_dereference(fn->left);\n\t}\nout:\n\tif (exact_match)\n\t\treturn NULL;\n\telse\n\t\treturn prev;\n}\n\nstruct fib6_node *fib6_locate(struct fib6_node *root,\n\t\t\t      const struct in6_addr *daddr, int dst_len,\n\t\t\t      const struct in6_addr *saddr, int src_len,\n\t\t\t      bool exact_match)\n{\n\tstruct fib6_node *fn;\n\n\tfn = fib6_locate_1(root, daddr, dst_len,\n\t\t\t   offsetof(struct fib6_info, fib6_dst),\n\t\t\t   exact_match);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src_len) {\n\t\tWARN_ON(saddr == NULL);\n\t\tif (fn) {\n\t\t\tstruct fib6_node *subtree = FIB6_SUBTREE(fn);\n\n\t\t\tif (subtree) {\n\t\t\t\tfn = fib6_locate_1(subtree, saddr, src_len,\n\t\t\t\t\t   offsetof(struct fib6_info, fib6_src),\n\t\t\t\t\t   exact_match);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tif (fn && fn->fn_flags & RTN_RTINFO)\n\t\treturn fn;\n\n\treturn NULL;\n}\n\n\n/*\n *\tDeletion\n *\n */\n\nstatic struct fib6_info *fib6_find_prefix(struct net *net,\n\t\t\t\t\t struct fib6_table *table,\n\t\t\t\t\t struct fib6_node *fn)\n{\n\tstruct fib6_node *child_left, *child_right;\n\n\tif (fn->fn_flags & RTN_ROOT)\n\t\treturn net->ipv6.fib6_null_entry;\n\n\twhile (fn) {\n\t\tchild_left = rcu_dereference_protected(fn->left,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tchild_right = rcu_dereference_protected(fn->right,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tif (child_left)\n\t\t\treturn rcu_dereference_protected(child_left->leaf,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t\tif (child_right)\n\t\t\treturn rcu_dereference_protected(child_right->leaf,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\n\t\tfn = FIB6_SUBTREE(fn);\n\t}\n\treturn NULL;\n}\n\n/*\n *\tCalled to trim the tree of intermediate nodes when possible. \"fn\"\n *\tis the node we want to try and remove.\n *\tNeed to own table->tb6_lock\n */\n\nstatic struct fib6_node *fib6_repair_tree(struct net *net,\n\t\t\t\t\t  struct fib6_table *table,\n\t\t\t\t\t  struct fib6_node *fn)\n{\n\tint children;\n\tint nstate;\n\tstruct fib6_node *child;\n\tstruct fib6_walker *w;\n\tint iter = 0;\n\n\t/* Set fn->leaf to null_entry for root node. */\n\tif (fn->fn_flags & RTN_TL_ROOT) {\n\t\trcu_assign_pointer(fn->leaf, net->ipv6.fib6_null_entry);\n\t\treturn fn;\n\t}\n\n\tfor (;;) {\n\t\tstruct fib6_node *fn_r = rcu_dereference_protected(fn->right,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *fn_l = rcu_dereference_protected(fn->left,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn = rcu_dereference_protected(fn->parent,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn_r = rcu_dereference_protected(pn->right,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_node *pn_l = rcu_dereference_protected(pn->left,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *fn_leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *pn_leaf = rcu_dereference_protected(pn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tstruct fib6_info *new_fn_leaf;\n\n\t\tRT6_TRACE(\"fixing tree: plen=%d iter=%d\\n\", fn->fn_bit, iter);\n\t\titer++;\n\n\t\tWARN_ON(fn->fn_flags & RTN_RTINFO);\n\t\tWARN_ON(fn->fn_flags & RTN_TL_ROOT);\n\t\tWARN_ON(fn_leaf);\n\n\t\tchildren = 0;\n\t\tchild = NULL;\n\t\tif (fn_r)\n\t\t\tchild = fn_r, children |= 1;\n\t\tif (fn_l)\n\t\t\tchild = fn_l, children |= 2;\n\n\t\tif (children == 3 || FIB6_SUBTREE(fn)\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t    /* Subtree root (i.e. fn) may have one child */\n\t\t    || (children && fn->fn_flags & RTN_ROOT)\n#endif\n\t\t    ) {\n\t\t\tnew_fn_leaf = fib6_find_prefix(net, table, fn);\n#if RT6_DEBUG >= 2\n\t\t\tif (!new_fn_leaf) {\n\t\t\t\tWARN_ON(!new_fn_leaf);\n\t\t\t\tnew_fn_leaf = net->ipv6.fib6_null_entry;\n\t\t\t}\n#endif\n\t\t\tfib6_info_hold(new_fn_leaf);\n\t\t\trcu_assign_pointer(fn->leaf, new_fn_leaf);\n\t\t\treturn pn;\n\t\t}\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\tRCU_INIT_POINTER(pn->subtree, NULL);\n\t\t\tnstate = FWS_L;\n\t\t} else {\n\t\t\tWARN_ON(fn->fn_flags & RTN_ROOT);\n#endif\n\t\t\tif (pn_r == fn)\n\t\t\t\trcu_assign_pointer(pn->right, child);\n\t\t\telse if (pn_l == fn)\n\t\t\t\trcu_assign_pointer(pn->left, child);\n#if RT6_DEBUG >= 2\n\t\t\telse\n\t\t\t\tWARN_ON(1);\n#endif\n\t\t\tif (child)\n\t\t\t\trcu_assign_pointer(child->parent, pn);\n\t\t\tnstate = FWS_R;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t}\n#endif\n\n\t\tread_lock(&net->ipv6.fib6_walker_lock);\n\t\tFOR_WALKERS(net, w) {\n\t\t\tif (!child) {\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 1, s=%d/%d\\n\", w, w->state, nstate);\n\t\t\t\t\tw->node = pn;\n\t\t\t\t\tw->state = nstate;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (w->node == fn) {\n\t\t\t\t\tw->node = child;\n\t\t\t\t\tif (children&2) {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state >= FWS_R ? FWS_U : FWS_INIT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tRT6_TRACE(\"W %p adjusted by delnode 2, s=%d\\n\", w, w->state);\n\t\t\t\t\t\tw->state = w->state >= FWS_C ? FWS_U : FWS_INIT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tread_unlock(&net->ipv6.fib6_walker_lock);\n\n\t\tnode_free(net, fn);\n\t\tif (pn->fn_flags & RTN_RTINFO || FIB6_SUBTREE(pn))\n\t\t\treturn pn;\n\n\t\tRCU_INIT_POINTER(pn->leaf, NULL);\n\t\tfib6_info_release(pn_leaf);\n\t\tfn = pn;\n\t}\n}\n\nstatic void fib6_del_route(struct fib6_table *table, struct fib6_node *fn,\n\t\t\t   struct fib6_info __rcu **rtp, struct nl_info *info)\n{\n\tstruct fib6_walker *w;\n\tstruct fib6_info *rt = rcu_dereference_protected(*rtp,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\tstruct net *net = info->nl_net;\n\n\tRT6_TRACE(\"fib6_del_route\\n\");\n\n\t/* Unlink it */\n\t*rtp = rt->fib6_next;\n\trt->fib6_node = NULL;\n\tnet->ipv6.rt6_stats->fib_rt_entries--;\n\tnet->ipv6.rt6_stats->fib_discarded_routes++;\n\n\t/* Flush all cached dst in exception table */\n\trt6_flush_exceptions(rt);\n\n\t/* Reset round-robin state, if necessary */\n\tif (rcu_access_pointer(fn->rr_ptr) == rt)\n\t\tfn->rr_ptr = NULL;\n\n\t/* Remove this entry from other siblings */\n\tif (rt->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings)\n\t\t\tsibling->fib6_nsiblings--;\n\t\trt->fib6_nsiblings = 0;\n\t\tlist_del_init(&rt->fib6_siblings);\n\t\trt6_multipath_rebalance(next_sibling);\n\t}\n\n\t/* Adjust walkers */\n\tread_lock(&net->ipv6.fib6_walker_lock);\n\tFOR_WALKERS(net, w) {\n\t\tif (w->state == FWS_C && w->leaf == rt) {\n\t\t\tRT6_TRACE(\"walker %p adjusted by delroute\\n\", w);\n\t\t\tw->leaf = rcu_dereference_protected(rt->fib6_next,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (!w->leaf)\n\t\t\t\tw->state = FWS_U;\n\t\t}\n\t}\n\tread_unlock(&net->ipv6.fib6_walker_lock);\n\n\t/* If it was last route, call fib6_repair_tree() to:\n\t * 1. For root node, put back null_entry as how the table was created.\n\t * 2. For other nodes, expunge its radix tree node.\n\t */\n\tif (!rcu_access_pointer(fn->leaf)) {\n\t\tif (!(fn->fn_flags & RTN_TL_ROOT)) {\n\t\t\tfn->fn_flags &= ~RTN_RTINFO;\n\t\t\tnet->ipv6.rt6_stats->fib_route_nodes--;\n\t\t}\n\t\tfn = fib6_repair_tree(net, table, fn);\n\t}\n\n\tfib6_purge_rt(rt, fn, net);\n\n\tif (!info->skip_notify_kernel)\n\t\tcall_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, rt, NULL);\n\tif (!info->skip_notify)\n\t\tinet6_rt_notify(RTM_DELROUTE, rt, info, 0);\n\n\tfib6_info_release(rt);\n}\n\n/* Need to own table->tb6_lock */\nint fib6_del(struct fib6_info *rt, struct nl_info *info)\n{\n\tstruct fib6_node *fn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\t    lockdep_is_held(&rt->fib6_table->tb6_lock));\n\tstruct fib6_table *table = rt->fib6_table;\n\tstruct net *net = info->nl_net;\n\tstruct fib6_info __rcu **rtp;\n\tstruct fib6_info __rcu **rtp_next;\n\n\tif (!fn || rt == net->ipv6.fib6_null_entry)\n\t\treturn -ENOENT;\n\n\tWARN_ON(!(fn->fn_flags & RTN_RTINFO));\n\n\t/*\n\t *\tWalk the leaf entries looking for ourself\n\t */\n\n\tfor (rtp = &fn->leaf; *rtp; rtp = rtp_next) {\n\t\tstruct fib6_info *cur = rcu_dereference_protected(*rtp,\n\t\t\t\t\tlockdep_is_held(&table->tb6_lock));\n\t\tif (rt == cur) {\n\t\t\tfib6_del_route(table, fn, rtp, info);\n\t\t\treturn 0;\n\t\t}\n\t\trtp_next = &cur->fib6_next;\n\t}\n\treturn -ENOENT;\n}\n\n/*\n *\tTree traversal function.\n *\n *\tCertainly, it is not interrupt safe.\n *\tHowever, it is internally reenterable wrt itself and fib6_add/fib6_del.\n *\tIt means, that we can modify tree during walking\n *\tand use this function for garbage collection, clone pruning,\n *\tcleaning tree when a device goes down etc. etc.\n *\n *\tIt guarantees that every node will be traversed,\n *\tand that it will be traversed only once.\n *\n *\tCallback function w->func may return:\n *\t0 -> continue walking.\n *\tpositive value -> walking is suspended (used by tree dumps,\n *\tand probably by gc, if it will be split to several slices)\n *\tnegative value -> terminate walking.\n *\n *\tThe function itself returns:\n *\t0   -> walk is complete.\n *\t>0  -> walk is incomplete (i.e. suspended)\n *\t<0  -> walk is terminated by an error.\n *\n *\tThis function is called with tb6_lock held.\n */\n\nstatic int fib6_walk_continue(struct fib6_walker *w)\n{\n\tstruct fib6_node *fn, *pn, *left, *right;\n\n\t/* w->root should always be table->tb6_root */\n\tWARN_ON_ONCE(!(w->root->fn_flags & RTN_TL_ROOT));\n\n\tfor (;;) {\n\t\tfn = w->node;\n\t\tif (!fn)\n\t\t\treturn 0;\n\n\t\tswitch (w->state) {\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tcase FWS_S:\n\t\t\tif (FIB6_SUBTREE(fn)) {\n\t\t\t\tw->node = FIB6_SUBTREE(fn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_L;\n#endif\n\t\t\t/* fall through */\n\t\tcase FWS_L:\n\t\t\tleft = rcu_dereference_protected(fn->left, 1);\n\t\t\tif (left) {\n\t\t\t\tw->node = left;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_R;\n\t\t\t/* fall through */\n\t\tcase FWS_R:\n\t\t\tright = rcu_dereference_protected(fn->right, 1);\n\t\t\tif (right) {\n\t\t\t\tw->node = right;\n\t\t\t\tw->state = FWS_INIT;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tw->state = FWS_C;\n\t\t\tw->leaf = rcu_dereference_protected(fn->leaf, 1);\n\t\t\t/* fall through */\n\t\tcase FWS_C:\n\t\t\tif (w->leaf && fn->fn_flags & RTN_RTINFO) {\n\t\t\t\tint err;\n\n\t\t\t\tif (w->skip) {\n\t\t\t\t\tw->skip--;\n\t\t\t\t\tgoto skip;\n\t\t\t\t}\n\n\t\t\t\terr = w->func(w);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\nskip:\n\t\t\tw->state = FWS_U;\n\t\t\t/* fall through */\n\t\tcase FWS_U:\n\t\t\tif (fn == w->root)\n\t\t\t\treturn 0;\n\t\t\tpn = rcu_dereference_protected(fn->parent, 1);\n\t\t\tleft = rcu_dereference_protected(pn->left, 1);\n\t\t\tright = rcu_dereference_protected(pn->right, 1);\n\t\t\tw->node = pn;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\tif (FIB6_SUBTREE(pn) == fn) {\n\t\t\t\tWARN_ON(!(fn->fn_flags & RTN_ROOT));\n\t\t\t\tw->state = FWS_L;\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tif (left == fn) {\n\t\t\t\tw->state = FWS_R;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (right == fn) {\n\t\t\t\tw->state = FWS_C;\n\t\t\t\tw->leaf = rcu_dereference_protected(w->node->leaf, 1);\n\t\t\t\tcontinue;\n\t\t\t}\n#if RT6_DEBUG >= 2\n\t\t\tWARN_ON(1);\n#endif\n\t\t}\n\t}\n}\n\nstatic int fib6_walk(struct net *net, struct fib6_walker *w)\n{\n\tint res;\n\n\tw->state = FWS_INIT;\n\tw->node = w->root;\n\n\tfib6_walker_link(net, w);\n\tres = fib6_walk_continue(w);\n\tif (res <= 0)\n\t\tfib6_walker_unlink(net, w);\n\treturn res;\n}\n\nstatic int fib6_clean_node(struct fib6_walker *w)\n{\n\tint res;\n\tstruct fib6_info *rt;\n\tstruct fib6_cleaner *c = container_of(w, struct fib6_cleaner, w);\n\tstruct nl_info info = {\n\t\t.nl_net = c->net,\n\t\t.skip_notify = c->skip_notify,\n\t};\n\n\tif (c->sernum != FIB6_NO_SERNUM_CHANGE &&\n\t    w->node->fn_sernum != c->sernum)\n\t\tw->node->fn_sernum = c->sernum;\n\n\tif (!c->func) {\n\t\tWARN_ON_ONCE(c->sernum == FIB6_NO_SERNUM_CHANGE);\n\t\tw->leaf = NULL;\n\t\treturn 0;\n\t}\n\n\tfor_each_fib6_walker_rt(w) {\n\t\tres = c->func(rt, c->arg);\n\t\tif (res == -1) {\n\t\t\tw->leaf = rt;\n\t\t\tres = fib6_del(rt, &info);\n\t\t\tif (res) {\n#if RT6_DEBUG >= 2\n\t\t\t\tpr_debug(\"%s: del failed: rt=%p@%p err=%d\\n\",\n\t\t\t\t\t __func__, rt,\n\t\t\t\t\t rcu_access_pointer(rt->fib6_node),\n\t\t\t\t\t res);\n#endif\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else if (res == -2) {\n\t\t\tif (WARN_ON(!rt->fib6_nsiblings))\n\t\t\t\tcontinue;\n\t\t\trt = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t     struct fib6_info, fib6_siblings);\n\t\t\tcontinue;\n\t\t}\n\t\tWARN_ON(res != 0);\n\t}\n\tw->leaf = rt;\n\treturn 0;\n}\n\n/*\n *\tConvenient frontend to tree walker.\n *\n *\tfunc is called on each route.\n *\t\tIt may return -2 -> skip multipath route.\n *\t\t\t      -1 -> delete this route.\n *\t\t              0  -> continue walking\n */\n\nstatic void fib6_clean_tree(struct net *net, struct fib6_node *root,\n\t\t\t    int (*func)(struct fib6_info *, void *arg),\n\t\t\t    int sernum, void *arg, bool skip_notify)\n{\n\tstruct fib6_cleaner c;\n\n\tc.w.root = root;\n\tc.w.func = fib6_clean_node;\n\tc.w.count = 0;\n\tc.w.skip = 0;\n\tc.w.skip_in_node = 0;\n\tc.func = func;\n\tc.sernum = sernum;\n\tc.arg = arg;\n\tc.net = net;\n\tc.skip_notify = skip_notify;\n\n\tfib6_walk(net, &c.w);\n}\n\nstatic void __fib6_clean_all(struct net *net,\n\t\t\t     int (*func)(struct fib6_info *, void *),\n\t\t\t     int sernum, void *arg, bool skip_notify)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tspin_lock_bh(&table->tb6_lock);\n\t\t\tfib6_clean_tree(net, &table->tb6_root,\n\t\t\t\t\tfunc, sernum, arg, skip_notify);\n\t\t\tspin_unlock_bh(&table->tb6_lock);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nvoid fib6_clean_all(struct net *net, int (*func)(struct fib6_info *, void *),\n\t\t    void *arg)\n{\n\t__fib6_clean_all(net, func, FIB6_NO_SERNUM_CHANGE, arg, false);\n}\n\nvoid fib6_clean_all_skip_notify(struct net *net,\n\t\t\t\tint (*func)(struct fib6_info *, void *),\n\t\t\t\tvoid *arg)\n{\n\t__fib6_clean_all(net, func, FIB6_NO_SERNUM_CHANGE, arg, true);\n}\n\nstatic void fib6_flush_trees(struct net *net)\n{\n\tint new_sernum = fib6_new_sernum(net);\n\n\t__fib6_clean_all(net, NULL, new_sernum, NULL, false);\n}\n\n/*\n *\tGarbage collection\n */\n\nstatic int fib6_age(struct fib6_info *rt, void *arg)\n{\n\tstruct fib6_gc_args *gc_args = arg;\n\tunsigned long now = jiffies;\n\n\t/*\n\t *\tcheck addrconf expiration here.\n\t *\tRoutes are expired even if they are in use.\n\t */\n\n\tif (rt->fib6_flags & RTF_EXPIRES && rt->expires) {\n\t\tif (time_after(now, rt->expires)) {\n\t\t\tRT6_TRACE(\"expiring %p\\n\", rt);\n\t\t\treturn -1;\n\t\t}\n\t\tgc_args->more++;\n\t}\n\n\t/*\tAlso age clones in the exception table.\n\t *\tNote, that clones are aged out\n\t *\tonly if they are not in use now.\n\t */\n\trt6_age_exceptions(rt, gc_args, now);\n\n\treturn 0;\n}\n\nvoid fib6_run_gc(unsigned long expires, struct net *net, bool force)\n{\n\tstruct fib6_gc_args gc_args;\n\tunsigned long now;\n\n\tif (force) {\n\t\tspin_lock_bh(&net->ipv6.fib6_gc_lock);\n\t} else if (!spin_trylock_bh(&net->ipv6.fib6_gc_lock)) {\n\t\tmod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);\n\t\treturn;\n\t}\n\tgc_args.timeout = expires ? (int)expires :\n\t\t\t  net->ipv6.sysctl.ip6_rt_gc_interval;\n\tgc_args.more = 0;\n\n\tfib6_clean_all(net, fib6_age, &gc_args);\n\tnow = jiffies;\n\tnet->ipv6.ip6_rt_last_gc = now;\n\n\tif (gc_args.more)\n\t\tmod_timer(&net->ipv6.ip6_fib_timer,\n\t\t\t  round_jiffies(now\n\t\t\t\t\t+ net->ipv6.sysctl.ip6_rt_gc_interval));\n\telse\n\t\tdel_timer(&net->ipv6.ip6_fib_timer);\n\tspin_unlock_bh(&net->ipv6.fib6_gc_lock);\n}\n\nstatic void fib6_gc_timer_cb(struct timer_list *t)\n{\n\tstruct net *arg = from_timer(arg, t, ipv6.ip6_fib_timer);\n\n\tfib6_run_gc(0, arg, true);\n}\n\nstatic int __net_init fib6_net_init(struct net *net)\n{\n\tsize_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;\n\tint err;\n\n\terr = fib6_notifier_init(net);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock_init(&net->ipv6.fib6_gc_lock);\n\trwlock_init(&net->ipv6.fib6_walker_lock);\n\tINIT_LIST_HEAD(&net->ipv6.fib6_walkers);\n\ttimer_setup(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, 0);\n\n\tnet->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);\n\tif (!net->ipv6.rt6_stats)\n\t\tgoto out_timer;\n\n\t/* Avoid false sharing : Use at least a full cache line */\n\tsize = max_t(size_t, size, L1_CACHE_BYTES);\n\n\tnet->ipv6.fib_table_hash = kzalloc(size, GFP_KERNEL);\n\tif (!net->ipv6.fib_table_hash)\n\t\tgoto out_rt6_stats;\n\n\tnet->ipv6.fib6_main_tbl = kzalloc(sizeof(*net->ipv6.fib6_main_tbl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!net->ipv6.fib6_main_tbl)\n\t\tgoto out_fib_table_hash;\n\n\tnet->ipv6.fib6_main_tbl->tb6_id = RT6_TABLE_MAIN;\n\trcu_assign_pointer(net->ipv6.fib6_main_tbl->tb6_root.leaf,\n\t\t\t   net->ipv6.fib6_null_entry);\n\tnet->ipv6.fib6_main_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_main_tbl->tb6_peers);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_local_tbl = kzalloc(sizeof(*net->ipv6.fib6_local_tbl),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.fib6_local_tbl)\n\t\tgoto out_fib6_main_tbl;\n\tnet->ipv6.fib6_local_tbl->tb6_id = RT6_TABLE_LOCAL;\n\trcu_assign_pointer(net->ipv6.fib6_local_tbl->tb6_root.leaf,\n\t\t\t   net->ipv6.fib6_null_entry);\n\tnet->ipv6.fib6_local_tbl->tb6_root.fn_flags =\n\t\tRTN_ROOT | RTN_TL_ROOT | RTN_RTINFO;\n\tinet_peer_base_init(&net->ipv6.fib6_local_tbl->tb6_peers);\n#endif\n\tfib6_tables_init(net);\n\n\treturn 0;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_fib6_main_tbl:\n\tkfree(net->ipv6.fib6_main_tbl);\n#endif\nout_fib_table_hash:\n\tkfree(net->ipv6.fib_table_hash);\nout_rt6_stats:\n\tkfree(net->ipv6.rt6_stats);\nout_timer:\n\tfib6_notifier_exit(net);\n\treturn -ENOMEM;\n}\n\nstatic void fib6_net_exit(struct net *net)\n{\n\tunsigned int i;\n\n\tdel_timer_sync(&net->ipv6.ip6_fib_timer);\n\n\tfor (i = 0; i < FIB6_TABLE_HASHSZ; i++) {\n\t\tstruct hlist_head *head = &net->ipv6.fib_table_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct fib6_table *tb;\n\n\t\thlist_for_each_entry_safe(tb, tmp, head, tb6_hlist) {\n\t\t\thlist_del(&tb->tb6_hlist);\n\t\t\tfib6_free_table(tb);\n\t\t}\n\t}\n\n\tkfree(net->ipv6.fib_table_hash);\n\tkfree(net->ipv6.rt6_stats);\n\tfib6_notifier_exit(net);\n}\n\nstatic struct pernet_operations fib6_net_ops = {\n\t.init = fib6_net_init,\n\t.exit = fib6_net_exit,\n};\n\nint __init fib6_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tfib6_node_kmem = kmem_cache_create(\"fib6_nodes\",\n\t\t\t\t\t   sizeof(struct fib6_node),\n\t\t\t\t\t   0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t   NULL);\n\tif (!fib6_node_kmem)\n\t\tgoto out;\n\n\tret = register_pernet_subsys(&fib6_net_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache_create;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETROUTE, NULL,\n\t\t\t\t   inet6_dump_fib, 0);\n\tif (ret)\n\t\tgoto out_unregister_subsys;\n\n\t__fib6_flush_trees = fib6_flush_trees;\nout:\n\treturn ret;\n\nout_unregister_subsys:\n\tunregister_pernet_subsys(&fib6_net_ops);\nout_kmem_cache_create:\n\tkmem_cache_destroy(fib6_node_kmem);\n\tgoto out;\n}\n\nvoid fib6_gc_cleanup(void)\n{\n\tunregister_pernet_subsys(&fib6_net_ops);\n\tkmem_cache_destroy(fib6_node_kmem);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic int ipv6_route_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct fib6_info *rt = v;\n\tstruct ipv6_route_iter *iter = seq->private;\n\tstruct fib6_nh *fib6_nh = rt->fib6_nh;\n\tunsigned int flags = rt->fib6_flags;\n\tconst struct net_device *dev;\n\n\tif (rt->nh)\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_dst.addr, rt->fib6_dst.plen);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_src.addr, rt->fib6_src.plen);\n#else\n\tseq_puts(seq, \"00000000000000000000000000000000 00 \");\n#endif\n\tif (fib6_nh->fib_nh_gw_family) {\n\t\tflags |= RTF_GATEWAY;\n\t\tseq_printf(seq, \"%pi6\", &fib6_nh->fib_nh_gw6);\n\t} else {\n\t\tseq_puts(seq, \"00000000000000000000000000000000\");\n\t}\n\n\tdev = fib6_nh->fib_nh_dev;\n\tseq_printf(seq, \" %08x %08x %08x %08x %8s\\n\",\n\t\t   rt->fib6_metric, refcount_read(&rt->fib6_ref), 0,\n\t\t   flags, dev ? dev->name : \"\");\n\titer->w.leaf = NULL;\n\treturn 0;\n}\n\nstatic int ipv6_route_yield(struct fib6_walker *w)\n{\n\tstruct ipv6_route_iter *iter = w->args;\n\n\tif (!iter->skip)\n\t\treturn 1;\n\n\tdo {\n\t\titer->w.leaf = rcu_dereference_protected(\n\t\t\t\titer->w.leaf->fib6_next,\n\t\t\t\tlockdep_is_held(&iter->tbl->tb6_lock));\n\t\titer->skip--;\n\t\tif (!iter->skip && iter->w.leaf)\n\t\t\treturn 1;\n\t} while (iter->w.leaf);\n\n\treturn 0;\n}\n\nstatic void ipv6_route_seq_setup_walk(struct ipv6_route_iter *iter,\n\t\t\t\t      struct net *net)\n{\n\tmemset(&iter->w, 0, sizeof(iter->w));\n\titer->w.func = ipv6_route_yield;\n\titer->w.root = &iter->tbl->tb6_root;\n\titer->w.state = FWS_INIT;\n\titer->w.node = iter->w.root;\n\titer->w.args = iter;\n\titer->sernum = iter->w.root->fn_sernum;\n\tINIT_LIST_HEAD(&iter->w.lh);\n\tfib6_walker_link(net, &iter->w);\n}\n\nstatic struct fib6_table *ipv6_route_seq_next_table(struct fib6_table *tbl,\n\t\t\t\t\t\t    struct net *net)\n{\n\tunsigned int h;\n\tstruct hlist_node *node;\n\n\tif (tbl) {\n\t\th = (tbl->tb6_id & (FIB6_TABLE_HASHSZ - 1)) + 1;\n\t\tnode = rcu_dereference_bh(hlist_next_rcu(&tbl->tb6_hlist));\n\t} else {\n\t\th = 0;\n\t\tnode = NULL;\n\t}\n\n\twhile (!node && h < FIB6_TABLE_HASHSZ) {\n\t\tnode = rcu_dereference_bh(\n\t\t\thlist_first_rcu(&net->ipv6.fib_table_hash[h++]));\n\t}\n\treturn hlist_entry_safe(node, struct fib6_table, tb6_hlist);\n}\n\nstatic void ipv6_route_check_sernum(struct ipv6_route_iter *iter)\n{\n\tif (iter->sernum != iter->w.root->fn_sernum) {\n\t\titer->sernum = iter->w.root->fn_sernum;\n\t\titer->w.state = FWS_INIT;\n\t\titer->w.node = iter->w.root;\n\t\tWARN_ON(iter->w.skip);\n\t\titer->w.skip = iter->w.count;\n\t}\n}\n\nstatic void *ipv6_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tint r;\n\tstruct fib6_info *n;\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\tif (!v)\n\t\tgoto iter_table;\n\n\tn = rcu_dereference_bh(((struct fib6_info *)v)->fib6_next);\n\tif (n) {\n\t\t++*pos;\n\t\treturn n;\n\t}\n\niter_table:\n\tipv6_route_check_sernum(iter);\n\tspin_lock_bh(&iter->tbl->tb6_lock);\n\tr = fib6_walk_continue(&iter->w);\n\tspin_unlock_bh(&iter->tbl->tb6_lock);\n\tif (r > 0) {\n\t\tif (v)\n\t\t\t++*pos;\n\t\treturn iter->w.leaf;\n\t} else if (r < 0) {\n\t\tfib6_walker_unlink(net, &iter->w);\n\t\treturn NULL;\n\t}\n\tfib6_walker_unlink(net, &iter->w);\n\n\titer->tbl = ipv6_route_seq_next_table(iter->tbl, net);\n\tif (!iter->tbl)\n\t\treturn NULL;\n\n\tipv6_route_seq_setup_walk(iter, net);\n\tgoto iter_table;\n}\n\nstatic void *ipv6_route_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU_BH)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\trcu_read_lock_bh();\n\titer->tbl = ipv6_route_seq_next_table(NULL, net);\n\titer->skip = *pos;\n\n\tif (iter->tbl) {\n\t\tipv6_route_seq_setup_walk(iter, net);\n\t\treturn ipv6_route_seq_next(seq, NULL, pos);\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic bool ipv6_route_iter_active(struct ipv6_route_iter *iter)\n{\n\tstruct fib6_walker *w = &iter->w;\n\treturn w->node && !(w->state == FWS_U && w->node == w->root);\n}\n\nstatic void ipv6_route_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU_BH)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ipv6_route_iter *iter = seq->private;\n\n\tif (ipv6_route_iter_active(iter))\n\t\tfib6_walker_unlink(net, &iter->w);\n\n\trcu_read_unlock_bh();\n}\n\nconst struct seq_operations ipv6_route_seq_ops = {\n\t.start\t= ipv6_route_seq_start,\n\t.next\t= ipv6_route_seq_next,\n\t.stop\t= ipv6_route_seq_stop,\n\t.show\t= ipv6_route_seq_show\n};\n#endif /* CONFIG_PROC_FS */\n"], "filenames": ["net/ipv6/ip6_fib.c"], "buggy_code_start_loc": [321], "buggy_code_end_loc": [322], "fixing_code_start_loc": [321], "fixing_code_end_loc": [322], "type": "CWE-755", "message": "In the Linux kernel before 5.3.4, fib6_rule_lookup in net/ipv6/ip6_fib.c mishandles the RT6_LOOKUP_F_DST_NOREF flag in a reference-count decision, leading to (for example) a crash that was identified by syzkaller, aka CID-7b09c2d052db.", "other": {"cve": {"id": "CVE-2019-20422", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-27T05:15:10.657", "lastModified": "2020-03-13T10:15:12.210", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.3.4, fib6_rule_lookup in net/ipv6/ip6_fib.c mishandles the RT6_LOOKUP_F_DST_NOREF flag in a reference-count decision, leading to (for example) a crash that was identified by syzkaller, aka CID-7b09c2d052db."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 5.3.4, la funci\u00f3n fib6_rule_lookup en el archivo net/ipv6/ip6_fib.c maneja inapropiadamente el flag RT6_LOOKUP_F_DST_NOREF en una decisi\u00f3n de conteo de referencias, lo que conlleva a (por ejemplo) un bloqueo que fue identificado por syzkaller, tambi\u00e9n se conoce como CID-7b09c2d052db."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.4", "matchCriteriaId": "3BDF8A74-23C2-4907-8FA4-001EE5D4BCE4"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/7b09c2d052db4b4ad0b27b97918b46a7746966fa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200313-0003/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/7b09c2d052db4b4ad0b27b97918b46a7746966fa"}}