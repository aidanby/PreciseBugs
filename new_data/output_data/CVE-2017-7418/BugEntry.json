{"buggy_code": ["/*\n * ProFTPD - FTP server daemon\n * Copyright (c) 1997, 1998 Public Flood Software\n * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n * Copyright (c) 2001-2016 The ProFTPD Project team\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA.\n *\n * As a special exemption, Public Flood Software/MacGyver aka Habeeb J. Dihu\n * and other respective copyright holders give permission to link this program\n * with OpenSSL, and distribute the resulting executable, without including\n * the source code for OpenSSL in the source distribution.\n */\n\n/* Authentication module for ProFTPD */\n\n#include \"conf.h\"\n#include \"privs.h\"\n\nextern pid_t mpid;\n\nmodule auth_module;\n\n#ifdef PR_USE_LASTLOG\nstatic unsigned char lastlog = FALSE;\n#endif /* PR_USE_LASTLOG */\n\nstatic unsigned char mkhome = FALSE;\nstatic unsigned char authenticated_without_pass = FALSE;\nstatic int TimeoutLogin = PR_TUNABLE_TIMEOUTLOGIN;\nstatic int logged_in = 0;\nstatic int auth_tries = 0;\nstatic char *auth_pass_resp_code = R_230;\nstatic pr_fh_t *displaylogin_fh = NULL;\nstatic int TimeoutSession = 0;\n\nstatic int auth_scan_scoreboard(void);\nstatic int auth_count_scoreboard(cmd_rec *, char *);\n\n/* auth_cmd_chk_cb() is hooked into the main server's auth_hook function,\n * so that we can deny all commands until authentication is complete.\n *\n * Note: Once this function returns true (i.e. client has authenticated),\n * it will ALWAYS return true.  At least until REIN is implemented.  Thus\n * we have a flag for such a situation, to save on redundant lookups for\n * the \"authenticated\" record.\n */\nstatic int auth_have_authenticated = FALSE;\n\nstatic int auth_cmd_chk_cb(cmd_rec *cmd) {\n  if (auth_have_authenticated == FALSE) {\n    unsigned char *authd;\n\n    authd = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n\n    if (authd == NULL ||\n        *authd == FALSE) {\n      pr_response_send(R_530, _(\"Please login with USER and PASS\"));\n      return FALSE;\n    }\n\n    auth_have_authenticated = TRUE;\n  }\n\n  return TRUE;\n}\n\nstatic int auth_login_timeout_cb(CALLBACK_FRAME) {\n  pr_response_send_async(R_421,\n    _(\"Login timeout (%d %s): closing control connection\"), TimeoutLogin,\n    TimeoutLogin != 1 ? \"seconds\" : \"second\");\n\n  /* It's possible that any listeners of this event might terminate the\n   * session process themselves (e.g. mod_ban).  So write out that the\n   * TimeoutLogin has been exceeded to the log here, in addition to the\n   * scheduled session exit message.\n   */\n  pr_log_pri(PR_LOG_NOTICE, \"%s\", \"Login timeout exceeded, disconnected\");\n  pr_event_generate(\"core.timeout-login\", NULL);\n\n  pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_TIMEOUT,\n    \"TimeoutLogin\");\n\n  /* Do not restart the timer (should never be reached). */\n  return 0;\n}\n\nstatic int auth_session_timeout_cb(CALLBACK_FRAME) {\n  pr_event_generate(\"core.timeout-session\", NULL);\n  pr_response_send_async(R_421,\n    _(\"Session Timeout (%d seconds): closing control connection\"),\n    TimeoutSession);\n\n  pr_log_pri(PR_LOG_NOTICE, \"%s\", \"FTP session timed out, disconnected\");\n  pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_TIMEOUT,\n    \"TimeoutSession\");\n\n  /* no need to restart the timer -- session's over */\n  return 0;\n}\n\n/* Event listeners\n */\n\nstatic void auth_exit_ev(const void *event_data, void *user_data) {\n  /* Close the scoreboard descriptor that we opened. */\n  (void) pr_close_scoreboard(FALSE);\n}\n\nstatic int auth_sess_init(void) {\n  config_rec *c = NULL;\n  unsigned char *tmp = NULL;\n  int res = 0;\n\n  /* Check for a server-specific TimeoutLogin */\n  c = find_config(main_server->conf, CONF_PARAM, \"TimeoutLogin\", FALSE);\n  if (c != NULL) {\n    TimeoutLogin = *((int *) c->argv[0]);\n  }\n\n  /* Start the login timer */\n  if (TimeoutLogin) {\n    pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n    pr_timer_add(TimeoutLogin, PR_TIMER_LOGIN, &auth_module,\n      auth_login_timeout_cb, \"TimeoutLogin\");\n  }\n\n  PRIVS_ROOT\n  res = pr_open_scoreboard(O_RDWR);\n  PRIVS_RELINQUISH\n\n  if (res < 0) {\n    switch (res) {\n      case PR_SCORE_ERR_BAD_MAGIC:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad/corrupted file\");\n        break;\n\n      case PR_SCORE_ERR_OLDER_VERSION:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad version (too old)\");\n        break;\n\n      case PR_SCORE_ERR_NEWER_VERSION:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad version (too new)\");\n        break;\n\n      default:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: %s\", strerror(errno));\n        break;\n    }\n  }\n\n  pr_event_register(&auth_module, \"core.exit\", auth_exit_ev, NULL);\n\n  /* Create an entry in the scoreboard for this session, if we don't already\n   * have one.\n   */\n  if (pr_scoreboard_entry_get(PR_SCORE_CLIENT_ADDR) == NULL) {\n    if (pr_scoreboard_entry_add() < 0) {\n      pr_log_pri(PR_LOG_NOTICE, \"notice: unable to add scoreboard entry: %s\",\n        strerror(errno));\n    }\n\n    pr_scoreboard_entry_update(session.pid,\n      PR_SCORE_USER, \"(none)\",\n      PR_SCORE_SERVER_PORT, main_server->ServerPort,\n      PR_SCORE_SERVER_ADDR, session.c->local_addr, session.c->local_port,\n      PR_SCORE_SERVER_LABEL, main_server->ServerName,\n      PR_SCORE_CLIENT_ADDR, session.c->remote_addr,\n      PR_SCORE_CLIENT_NAME, session.c->remote_name,\n      PR_SCORE_CLASS, session.conn_class ? session.conn_class->cls_name : \"\",\n      PR_SCORE_PROTOCOL, \"ftp\",\n      PR_SCORE_BEGIN_SESSION, time(NULL),\n      NULL);\n\n  } else {\n    /* We're probably handling a HOST comand, and the server changed; just\n     * update the SERVER_LABEL field.\n     */\n    pr_scoreboard_entry_update(session.pid,\n      PR_SCORE_SERVER_LABEL, main_server->ServerName,\n      NULL);\n  }\n\n  /* Should we create the home for a user, if they don't have one? */\n  tmp = get_param_ptr(main_server->conf, \"CreateHome\", FALSE);\n  if (tmp != NULL &&\n      *tmp == TRUE) {\n    mkhome = TRUE;\n\n  } else {\n    mkhome = FALSE;\n  }\n\n#ifdef PR_USE_LASTLOG\n  /* Use the lastlog file, if supported and requested. */\n  tmp = get_param_ptr(main_server->conf, \"UseLastlog\", FALSE);\n  if (tmp &&\n      *tmp == TRUE) {\n    lastlog = TRUE;\n\n  } else {\n    lastlog = FALSE;\n  }\n#endif /* PR_USE_LASTLOG */\n\n  /* Scan the scoreboard now, in order to tally up certain values for\n   * substituting in any of the Display* file variables.  This function\n   * also performs the MaxConnectionsPerHost enforcement.\n   */\n  auth_scan_scoreboard();\n\n  return 0;\n}\n\nstatic int auth_init(void) {\n\n  /* Add the commands handled by this module to the HELP list. */ \n  pr_help_add(C_USER, _(\"<sp> username\"), TRUE);\n  pr_help_add(C_PASS, _(\"<sp> password\"), TRUE);\n  pr_help_add(C_ACCT, _(\"is not implemented\"), FALSE);\n  pr_help_add(C_REIN, _(\"is not implemented\"), FALSE);\n\n  /* By default, enable auth checking */\n  set_auth_check(auth_cmd_chk_cb);\n\n  return 0;\n}\n\nstatic int _do_auth(pool *p, xaset_t *conf, char *u, char *pw) {\n  char *cpw = NULL;\n  config_rec *c;\n\n  if (conf) {\n    c = find_config(conf, CONF_PARAM, \"UserPassword\", FALSE);\n\n    while (c) {\n      if (strcmp(c->argv[0], u) == 0) {\n        cpw = (char *) c->argv[1];\n        break;\n      }\n\n      c = find_config_next(c, c->next, CONF_PARAM, \"UserPassword\", FALSE);\n    }\n  }\n\n  if (cpw) {\n    if (pr_auth_getpwnam(p, u) == NULL) {\n      int xerrno = errno;\n\n      if (xerrno == ENOENT) {\n        pr_log_pri(PR_LOG_NOTICE, \"no such user '%s'\", u);\n      }\n\n      errno = xerrno;\n      return PR_AUTH_NOPWD;\n    }\n\n    return pr_auth_check(p, cpw, u, pw);\n  }\n\n  return pr_auth_authenticate(p, u, pw);\n}\n\n/* Command handlers\n */\n\nMODRET auth_post_host(cmd_rec *cmd) {\n\n  /* If the HOST command changed the main_server pointer, reinitialize\n   * ourselves.\n   */\n  if (session.prev_server != NULL) {\n    int res;\n\n    /* Remove the TimeoutLogin timer. */\n    pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n\n    pr_event_unregister(&auth_module, \"core.exit\", auth_exit_ev);\n\n    /* Reset the CreateHome setting. */\n    mkhome = FALSE;\n\n#ifdef PR_USE_LASTLOG\n    /* Reset the UseLastLog setting. */\n    lastlog = FALSE;\n#endif /* PR_USE_LASTLOG */\n\n    res = auth_sess_init();\n    if (res < 0) {\n      pr_session_disconnect(&auth_module,\n        PR_SESS_DISCONNECT_SESSION_INIT_FAILED, NULL);\n    }\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_err_pass(cmd_rec *cmd) {\n\n  /* Remove the stashed original USER name here in a LOG_CMD_ERR handler, so\n   * that other modules, who may want to lookup the original USER parameter on\n   * a failed login in an earlier command handler phase, have a chance to do\n   * so.  This removal of the USER parameter on failure was happening directly\n   * in the CMD handler previously, thus preventing POST_CMD_ERR handlers from\n   * using USER.\n   */\n  pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_log_pass(cmd_rec *cmd) {\n  size_t passwd_len;\n\n  /* Only log, to the syslog, that the login has succeeded here, where we\n   * know that the login has definitely succeeded.\n   */\n  pr_log_auth(PR_LOG_INFO, \"%s %s: Login successful.\",\n    (session.anon_config != NULL) ? \"ANON\" : C_USER, session.user);\n\n  if (cmd->arg != NULL) {\n    /* And scrub the memory holding the password sent by the client, for\n     * safety/security.\n     */\n    passwd_len = strlen(cmd->arg);\n    pr_memscrub(cmd->arg, passwd_len);\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_post_pass(cmd_rec *cmd) {\n  config_rec *c = NULL;\n  char *grantmsg = NULL, *user;\n  unsigned int ctxt_precedence = 0;\n  unsigned char have_user_timeout, have_group_timeout, have_class_timeout,\n    have_all_timeout, *root_revoke = NULL, *authenticated;\n  struct stat st;\n\n  /* Was there a precending USER command? Was the client successfully\n   * authenticated?\n   */\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n\n  /* Clear the list of auth-only modules. */\n  pr_auth_clear_auth_only_modules();\n\n  if (authenticated != NULL &&\n      *authenticated == TRUE) {\n\n    /* At this point, we can look up the Protocols config if the client\n     * has been authenticated, which may have been tweaked via mod_ifsession's\n     * user/group/class-specific sections.\n     */\n    c = find_config(main_server->conf, CONF_PARAM, \"Protocols\", FALSE);\n    if (c) {\n      register unsigned int i;\n      array_header *protocols;\n      char **elts;\n      const char *protocol;\n\n      protocols = c->argv[0];\n      elts = protocols->elts;\n\n      protocol = pr_session_get_protocol(PR_SESS_PROTO_FL_LOGOUT);\n\n      /* We only want to check for 'ftp' in the configured Protocols list\n       * if a) a RFC2228 mechanism (e.g. SSL or GSS) is not in use, and\n       *    b) an SSH protocol is not in use.\n       */\n      if (session.rfc2228_mech == NULL &&\n          strncmp(protocol, \"SSH2\", 5) != 0) {\n        int allow_ftp = FALSE;\n\n        for (i = 0; i < protocols->nelts; i++) {\n          char *proto;\n\n          proto = elts[i];\n          if (proto != NULL) {\n            if (strncasecmp(proto, \"ftp\", 4) == 0) {\n              allow_ftp = TRUE;\n              break;\n            }\n          }\n        }\n\n        if (!allow_ftp) {\n          pr_log_debug(DEBUG0, \"%s\", \"ftp protocol denied by Protocols config\");\n          pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n          pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n            \"Denied by Protocols setting\");\n        }\n      }\n    }\n  }\n\n  user = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n\n  /* Count up various quantities in the scoreboard, checking them against\n   * the Max* limits to see if the session should be barred from going\n   * any further.\n   */\n  auth_count_scoreboard(cmd, session.user);\n\n  /* Check for dynamic configuration.  This check needs to be after the\n   * setting of any possible anon_config, as that context may be allowed\n   * or denied .ftpaccess-parsing separately from the containing server.\n   */\n  if (pr_fsio_stat(session.cwd, &st) != -1)\n    build_dyn_config(cmd->tmp_pool, session.cwd, &st, TRUE);\n\n  have_user_timeout = have_group_timeout = have_class_timeout =\n    have_all_timeout = FALSE;\n\n  c = find_config(TOPLEVEL_CONF, CONF_PARAM, \"TimeoutSession\", FALSE);\n  while (c != NULL) {\n    pr_signals_handle();\n\n    if (c->argc == 3) {\n      if (strncmp(c->argv[1], \"user\", 5) == 0) {\n        if (pr_expr_eval_user_or((char **) &c->argv[2]) == TRUE) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_group_timeout = have_class_timeout = have_all_timeout = FALSE;\n            have_user_timeout = TRUE;\n          }\n        }\n\n      } else if (strncmp(c->argv[1], \"group\", 6) == 0) {\n        if (pr_expr_eval_group_and((char **) &c->argv[2]) == TRUE) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_user_timeout = have_class_timeout = have_all_timeout = FALSE;\n            have_group_timeout = TRUE;\n          }\n        }\n\n      } else if (strncmp(c->argv[1], \"class\", 6) == 0) {\n        if (session.conn_class != NULL &&\n            strcmp(session.conn_class->cls_name, c->argv[2]) == 0) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_user_timeout = have_group_timeout = have_all_timeout = FALSE;\n            have_class_timeout = TRUE;\n          }\n        }\n      }\n\n    } else {\n\n      if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n        /* Set the context precedence. */\n        ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n        TimeoutSession = *((int *) c->argv[0]);\n\n        have_user_timeout = have_group_timeout = have_class_timeout = FALSE;\n        have_all_timeout = TRUE;\n      }\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"TimeoutSession\", FALSE);\n  }\n\n  /* If configured, start a session timer.  The timer ID value for\n   * session timers will not be #defined, as I think that is a bad approach.\n   * A better mechanism would be to use the random timer ID generation, and\n   * store the returned ID in order to later remove the timer.\n   */\n\n  if (have_user_timeout || have_group_timeout ||\n      have_class_timeout || have_all_timeout) {\n    pr_log_debug(DEBUG4, \"setting TimeoutSession of %d seconds for current %s\",\n      TimeoutSession,\n      have_user_timeout ? \"user\" : have_group_timeout ? \"group\" :\n      have_class_timeout ? \"class\" : \"all\");\n    pr_timer_add(TimeoutSession, PR_TIMER_SESSION, &auth_module,\n      auth_session_timeout_cb, \"TimeoutSession\");\n  }\n\n  /* Handle a DisplayLogin file. */\n  if (displaylogin_fh) {\n    if (!(session.sf_flags & SF_ANON)) {\n      if (pr_display_fh(displaylogin_fh, NULL, auth_pass_resp_code, 0) < 0) {\n        pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n          displaylogin_fh->fh_path, strerror(errno));\n      }\n\n      pr_fsio_close(displaylogin_fh);\n      displaylogin_fh = NULL;\n\n    } else {\n      /* We're an <Anonymous> login, but there was a previous DisplayLogin\n       * configured which was picked up earlier.  Close that filehandle,\n       * and look for a new one.\n       */\n      char *displaylogin;\n\n      pr_fsio_close(displaylogin_fh);\n      displaylogin_fh = NULL;\n\n      displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n      if (displaylogin) {\n        if (pr_display_file(displaylogin, NULL, auth_pass_resp_code, 0) < 0) {\n          pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n            displaylogin, strerror(errno));\n        }\n      }\n    }\n\n  } else {\n    char *displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n    if (displaylogin) {\n      if (pr_display_file(displaylogin, NULL, auth_pass_resp_code, 0) < 0) {\n        pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n          displaylogin, strerror(errno));\n      }\n    }\n  }\n\n  grantmsg = get_param_ptr(TOPLEVEL_CONF, \"AccessGrantMsg\", FALSE);\n  if (grantmsg == NULL) {\n    /* Append the final greeting lines. */\n    if (session.sf_flags & SF_ANON) {\n      pr_response_add(auth_pass_resp_code, \"%s\",\n        _(\"Anonymous access granted, restrictions apply\"));\n\n    } else {\n      pr_response_add(auth_pass_resp_code, _(\"User %s logged in\"), user);\n    }\n\n  } else {\n     /* Handle any AccessGrantMsg directive. */\n     grantmsg = sreplace(cmd->tmp_pool, grantmsg, \"%u\", user, NULL);\n     pr_response_add(auth_pass_resp_code, \"%s\", grantmsg);\n  }\n\n  /* A RootRevoke value of 0 indicates 'false', 1 indicates 'true', and\n   * 2 indicates 'NonCompliantActiveTransfer'.  We will drop root privs for any\n   * RootRevoke value greater than 0.\n   */\n  root_revoke = get_param_ptr(TOPLEVEL_CONF, \"RootRevoke\", FALSE);\n  if (root_revoke != NULL &&\n      *root_revoke > 0) {\n    pr_signals_block();\n    PRIVS_ROOT\n    PRIVS_REVOKE\n    pr_signals_unblock();\n\n    /* Disable future attempts at UID/GID manipulation. */\n    session.disable_id_switching = TRUE;\n\n    if (*root_revoke == 1) {\n      /* If the server's listening port is less than 1024, block PORT\n       * commands (effectively allowing only passive connections, which is\n       * not necessarily a Bad Thing).  Only log this here -- the blocking\n       * will need to occur in mod_core's handling of the PORT/EPRT commands.\n       */\n      if (session.c->local_port < 1024) {\n        pr_log_debug(DEBUG0,\n          \"RootRevoke in effect, active data transfers may not succeed\");\n      }\n    }\n\n    pr_log_debug(DEBUG0, \"RootRevoke in effect, dropped root privs\");\n  }\n\n  return PR_DECLINED(cmd);\n}\n\n/* Handle group based authentication, only checked if pw\n * based fails\n */\n\nstatic config_rec *_auth_group(pool *p, char *user, char **group,\n                               char **ournamep, char **anonnamep, char *pass)\n{\n  config_rec *c;\n  char *ourname = NULL,*anonname = NULL;\n  char **grmem;\n  struct group *grp;\n\n  ourname = (char*)get_param_ptr(main_server->conf,\"UserName\",FALSE);\n  if (ournamep && ourname)\n    *ournamep = ourname;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"GroupPassword\", TRUE);\n\n  if (c) do {\n    grp = pr_auth_getgrnam(p, c->argv[0]);\n\n    if (!grp)\n      continue;\n\n    for (grmem = grp->gr_mem; *grmem; grmem++)\n      if (strcmp(*grmem, user) == 0) {\n        if (pr_auth_check(p, c->argv[1], user, pass) == 0)\n          break;\n      }\n\n    if (*grmem) {\n      if (group)\n        *group = c->argv[0];\n\n      if (c->parent)\n        c = c->parent;\n\n      if (c->config_type == CONF_ANON)\n        anonname = (char*)get_param_ptr(c->subset,\"UserName\",FALSE);\n      if (anonnamep)\n        *anonnamep = anonname;\n      if (anonnamep && !anonname && ourname)\n        *anonnamep = ourname;\n\n      break;\n    }\n  } while((c = find_config_next(c,c->next,CONF_PARAM,\"GroupPassword\",TRUE)) != NULL);\n\n  return c;\n}\n\n/* Determine any applicable chdirs\n */\n\nstatic char *get_default_chdir(pool *p, xaset_t *conf) {\n  config_rec *c;\n  char *dir = NULL;\n  int ret;\n\n  c = find_config(conf, CONF_PARAM, \"DefaultChdir\", FALSE);\n\n  while (c) {\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    ret = pr_expr_eval_group_and(((char **) c->argv)+1);\n\n    if (ret) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultChdir\", FALSE);\n  }\n\n  /* If the directory is relative, concatenate w/ session.cwd. */\n  if (dir && *dir != '/' && *dir != '~')\n    dir = pdircat(p, session.cwd, dir, NULL);\n\n  /* Check for any expandable variables. */\n  if (dir)\n    dir = path_subst_uservar(p, &dir);\n\n  return dir;\n}\n\n/* Determine if the user (non-anon) needs a default root dir other than /.\n */\n\nstatic int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(path, &st);\n        if (res < 0) {\n          xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n\n          errno = xerrno;\n          return -1;\n        }\n\n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}\n\nstatic struct passwd *passwd_dup(pool *p, struct passwd *pw) {\n  struct passwd *npw;\n\n  npw = pcalloc(p, sizeof(struct passwd));\n\n  npw->pw_name = pstrdup(p, pw->pw_name);\n  npw->pw_passwd = pstrdup(p, pw->pw_passwd);\n  npw->pw_uid = pw->pw_uid;\n  npw->pw_gid = pw->pw_gid;\n  npw->pw_gecos = pstrdup(p, pw->pw_gecos);\n  npw->pw_dir = pstrdup(p, pw->pw_dir);\n  npw->pw_shell = pstrdup(p, pw->pw_shell);\n\n  return npw;\n}\n\nstatic void ensure_open_passwd(pool *p) {\n  /* Make sure pass/group is open.\n   */\n  pr_auth_setpwent(p);\n  pr_auth_setgrent(p);\n\n  /* On some unices the following is necessary to ensure the files\n   * are open.  (BSDI 3.1)\n   */\n  pr_auth_getpwent(p);\n  pr_auth_getgrent(p);\n}\n\n/* Next function (the biggie) handles all authentication, setting\n * up chroot() jail, etc.\n */\nstatic int setup_env(pool *p, cmd_rec *cmd, char *user, char *pass) {\n  struct passwd *pw;\n  config_rec *c, *tmpc;\n  char *origuser, *ourname = NULL, *anonname = NULL, *anongroup = NULL, *ugroup = NULL;\n  char *defaulttransfermode, *defroot = NULL,*defchdir = NULL,*xferlog = NULL;\n  const char *sess_ttyname;\n  int aclp, i, res = 0, allow_chroot_symlinks = TRUE, showsymlinks;\n  unsigned char *wtmp_log = NULL, *anon_require_passwd = NULL;\n\n  /********************* Authenticate the user here *********************/\n\n  session.hide_password = TRUE;\n\n  origuser = user;\n  c = pr_auth_get_anon_config(p, &user, &ourname, &anonname);\n\n  if (c)\n    session.anon_config = c;\n\n  if (!user) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s: user is not a UserAlias from %s [%s] \"\n      \"to %s:%i\", origuser, session.c->remote_name,\n      pr_netaddr_get_ipstr(session.c->remote_addr),\n      pr_netaddr_get_ipstr(session.c->local_addr), session.c->local_port);\n    goto auth_failure;\n  }\n\n  pw = pr_auth_getpwnam(p, user);\n  if (pw == NULL &&\n      c != NULL &&\n      ourname != NULL) {\n    /* If the client is authenticating using an alias (e.g. \"AuthAliasOnly on\"),\n     * then we need to try checking using the real username, too (Bug#4255).\n     */\n    pr_trace_msg(\"auth\", 16,\n      \"no user entry found for <Anonymous> alias '%s', using '%s'\", user,\n      ourname);\n    pw = pr_auth_getpwnam(p, ourname);\n  }\n\n  if (pw == NULL) {\n    int auth_code = PR_AUTH_NOPWD;\n\n    pr_log_auth(PR_LOG_NOTICE,\n      \"USER %s: no such user found from %s [%s] to %s:%i\",\n      user, session.c->remote_name,\n      pr_netaddr_get_ipstr(session.c->remote_addr),\n      pr_netaddr_get_ipstr(session.c->local_addr), session.c->local_port);\n    pr_event_generate(\"mod_auth.authentication-code\", &auth_code); \n\n    goto auth_failure;\n  }\n\n  /* Security: other functions perform pw lookups, thus we need to make\n   * a local copy of the user just looked up.\n   */\n  pw = passwd_dup(p, pw);\n\n  if (pw->pw_uid == PR_ROOT_UID) {\n    unsigned char *root_allow = NULL;\n\n    pr_event_generate(\"mod_auth.root-login\", NULL);\n\n    /* If RootLogin is set to true, we allow this... even though we\n     * still log a warning. :)\n     */\n    if ((root_allow = get_param_ptr(c ? c->subset : main_server->conf,\n        \"RootLogin\", FALSE)) == NULL || *root_allow != TRUE) {\n      if (pass) {\n        pr_memscrub(pass, strlen(pass));\n      }\n\n      pr_log_auth(PR_LOG_NOTICE, \"SECURITY VIOLATION: Root login attempted\");\n      return 0;\n    }\n  }\n\n  session.user = pstrdup(p, pw->pw_name);\n  session.group = pstrdup(p, pr_auth_gid2name(p, pw->pw_gid));\n\n  /* Set the login_uid and login_uid */\n  session.login_uid = pw->pw_uid;\n  session.login_gid = pw->pw_gid;\n\n  /* Check for any expandable variables in session.cwd. */\n  pw->pw_dir = path_subst_uservar(p, &pw->pw_dir);\n\n  /* Before we check for supplemental groups, check to see if the locally\n   * resolved name of the user, returned via auth_getpwnam(), is different\n   * from the USER argument sent by the client.  The name can change, since\n   * auth modules can play all sorts of neat tricks on us.\n   *\n   * If the names differ, assume that any cached data in the session.gids\n   * and session.groups lists are stale, and clear them out.\n   */\n  if (strcmp(pw->pw_name, user) != 0) {\n    pr_log_debug(DEBUG10, \"local user name '%s' differs from client-sent \"\n      \"user name '%s', clearing cached group data\", pw->pw_name, user);\n    session.gids = NULL;\n    session.groups = NULL;\n  }\n\n  if (!session.gids &&\n      !session.groups) {\n    /* Get the supplemental groups.  Note that we only look up the\n     * supplemental group credentials if we have not cached the group\n     * credentials before, in session.gids and session.groups.  \n     *\n     * Those credentials may have already been retrieved, as part of the\n     * pr_auth_get_anon_config() call.\n     */\n     res = pr_auth_getgroups(p, pw->pw_name, &session.gids, &session.groups);\n     if (res < 1) {\n       pr_log_debug(DEBUG2, \"no supplemental groups found for user '%s'\",\n         pw->pw_name);\n     }\n  }\n\n  tmpc = find_config(main_server->conf, CONF_PARAM, \"AllowChrootSymlinks\",\n    FALSE);\n  if (tmpc != NULL) {\n    allow_chroot_symlinks = *((int *) tmpc->argv[0]);\n  }\n\n  /* If c != NULL from this point on, we have an anonymous login */\n  aclp = login_check_limits(main_server->conf, FALSE, TRUE, &i);\n\n  if (c) {\n    anongroup = get_param_ptr(c->subset, \"GroupName\", FALSE);\n    if (!anongroup)\n      anongroup = get_param_ptr(main_server->conf, \"GroupName\",FALSE);\n\n    /* Check for configured AnonRejectPasswords regex here, and fail the login\n     * if the given password matches the regex.\n     */\n#ifdef PR_USE_REGEX\n    if ((tmpc = find_config(c->subset, CONF_PARAM, \"AnonRejectPasswords\",\n        FALSE)) != NULL) {\n      int re_res;\n      pr_regex_t *pw_regex = (pr_regex_t *) tmpc->argv[0];\n\n      if (pw_regex && pass &&\n          ((re_res = pr_regexp_exec(pw_regex, pass, 0, NULL, 0, 0, 0)) == 0)) {\n        char errstr[200] = {'\\0'};\n\n        pr_regexp_error(re_res, pw_regex, errstr, sizeof(errstr));\n        pr_log_auth(PR_LOG_NOTICE, \"ANON %s: AnonRejectPasswords denies login\",\n          origuser);\n \n        pr_event_generate(\"mod_auth.anon-reject-passwords\", session.c);\n        goto auth_failure;\n      }\n    }\n#endif\n\n    if (!login_check_limits(c->subset, FALSE, TRUE, &i) || (!aclp && !i) ){\n      pr_log_auth(PR_LOG_NOTICE, \"ANON %s (Login failed): Limit access denies \"\n        \"login\", origuser);\n      goto auth_failure;\n    }\n  }\n\n  if (c == NULL &&\n      aclp == 0) {\n    pr_log_auth(PR_LOG_NOTICE,\n      \"USER %s (Login failed): Limit access denies login\", origuser);\n    goto auth_failure;\n  }\n\n  if (c) {\n    anon_require_passwd = get_param_ptr(c->subset, \"AnonRequirePassword\",\n      FALSE);\n  }\n\n  if (!c ||\n      (anon_require_passwd && *anon_require_passwd == TRUE)) {\n    int auth_code;\n    char *user_name = user;\n\n    if (c &&\n        origuser &&\n        strcasecmp(user, origuser) != 0) {\n      unsigned char *auth_using_alias = get_param_ptr(c->subset,\n        \"AuthUsingAlias\", FALSE);\n\n      /* If 'AuthUsingAlias' set and we're logging in under an alias,\n       * then auth using that alias.\n       */\n      if (auth_using_alias &&\n          *auth_using_alias == TRUE) {\n        user_name = origuser;\n        pr_log_auth(PR_LOG_INFO,\n          \"ANON AUTH: User %s, authenticating using alias %s\", user,\n          user_name);\n      }\n    }\n\n    /* It is possible for the user to have already been authenticated during\n     * the handling of the USER command, as by an RFC2228 mechanism.  If\n     * that had happened, we won't need to call _do_auth() here.\n     */\n    if (!authenticated_without_pass) {\n      auth_code = _do_auth(p, c ? c->subset : main_server->conf, user_name,\n        pass);\n\n    } else {\n      auth_code = PR_AUTH_OK_NO_PASS;\n    }\n\n    pr_event_generate(\"mod_auth.authentication-code\", &auth_code);\n\n    if (auth_code < 0) {\n      /* Normal authentication has failed, see if group authentication\n       * passes\n       */\n\n      c = _auth_group(p, user, &anongroup, &ourname, &anonname, pass);\n      if (c != NULL) {\n        if (c->config_type != CONF_ANON) {\n          c = NULL;\n          ugroup = anongroup;\n          anongroup = NULL;\n        }\n\n        auth_code = PR_AUTH_OK;\n      }\n    }\n\n    if (pass)\n      pr_memscrub(pass, strlen(pass));\n\n    if (session.auth_mech)\n      pr_log_debug(DEBUG2, \"user '%s' authenticated by %s\", user,\n        session.auth_mech);\n\n    switch (auth_code) {\n      case PR_AUTH_OK_NO_PASS:\n        auth_pass_resp_code = R_232;\n        break;\n\n      case PR_AUTH_OK:\n        auth_pass_resp_code = R_230;\n        break;\n\n      case PR_AUTH_NOPWD:\n        pr_log_auth(PR_LOG_NOTICE,\n          \"USER %s (Login failed): No such user found\", user);\n        goto auth_failure;\n\n      case PR_AUTH_BADPWD:\n        pr_log_auth(PR_LOG_NOTICE,\n          \"USER %s (Login failed): Incorrect password\", origuser);\n        goto auth_failure;\n\n      case PR_AUTH_AGEPWD:\n        pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Password expired\",\n          user);\n        goto auth_failure;\n\n      case PR_AUTH_DISABLEDPWD:\n        pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Account disabled\",\n          user);\n        goto auth_failure;\n\n      default:\n        break;\n    };\n\n    /* Catch the case where we forgot to handle a bad auth code above. */\n    if (auth_code < 0)\n      goto auth_failure;\n\n    if (pw->pw_uid == PR_ROOT_UID) {\n      pr_log_auth(PR_LOG_WARNING, \"ROOT FTP login successful\");\n    }\n\n  } else if (c && (!anon_require_passwd || *anon_require_passwd == FALSE)) {\n    session.hide_password = FALSE;\n  }\n\n  pr_auth_setgrent(p);\n\n  res = pr_auth_is_valid_shell(c ? c->subset : main_server->conf,\n    pw->pw_shell);\n  if (res == FALSE) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Invalid shell: '%s'\",\n      user, pw->pw_shell);\n    goto auth_failure;\n  }\n\n  res = pr_auth_banned_by_ftpusers(c ? c->subset : main_server->conf,\n    pw->pw_name);\n  if (res == TRUE) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): User in \"\n      PR_FTPUSERS_PATH, user);\n    goto auth_failure;\n  }\n\n  if (c) {\n    struct group *grp = NULL;\n    unsigned char *add_userdir = NULL;\n    char *u, *chroot_dir;\n\n    u = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n    add_userdir = get_param_ptr(c->subset, \"UserDirRoot\", FALSE);\n\n    /* If resolving an <Anonymous> user, make sure that user's groups\n     * are set properly for the check of the home directory path (which\n     * depend on those supplemental group memberships).  Additionally,\n     * temporarily switch to the new user's uid.\n     */\n\n    pr_signals_block();\n\n    PRIVS_ROOT\n    res = set_groups(p, pw->pw_gid, session.gids);\n    if (res < 0) {\n      pr_log_pri(PR_LOG_WARNING, \"error: unable to set groups: %s\",\n        strerror(errno));\n    }\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n    PRIVS_SETUP(pw->pw_uid, pw->pw_gid)\n\n    if ((add_userdir && *add_userdir == TRUE) &&\n        strcmp(u, user) != 0) {\n      chroot_dir = pdircat(p, c->name, u, NULL);\n\n    } else {\n      chroot_dir = c->name;\n    }\n\n    if (allow_chroot_symlinks == FALSE) {\n      char *chroot_path, target_path[PR_TUNABLE_PATH_MAX+1];\n      struct stat st;\n\n      chroot_path = chroot_dir;\n      if (chroot_path[0] != '/') {\n        if (chroot_path[0] == '~') {\n          if (pr_fs_interpolate(chroot_path, target_path,\n              sizeof(target_path)-1) == 0) {\n            chroot_path = target_path;\n\n          } else {\n            chroot_path = NULL;\n          }\n        }\n      }\n\n      if (chroot_path != NULL) {\n        size_t chroot_pathlen;\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        chroot_pathlen = strlen(chroot_path);\n        if (chroot_pathlen > 1 &&\n            chroot_path[chroot_pathlen-1] == '/') {\n          chroot_path[chroot_pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(chroot_path, &st);\n        if (res < 0) {\n          int xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\",\n            chroot_path, strerror(xerrno));\n\n          errno = xerrno;\n          chroot_path = NULL;\n\n        } else {\n          if (S_ISLNK(st.st_mode)) {\n            pr_log_pri(PR_LOG_WARNING,\n              \"error: <Anonymous %s> is a symlink (denied by \"\n              \"AllowChrootSymlinks config)\", chroot_path);\n            errno = EPERM;\n            chroot_path = NULL;\n          }\n        }\n      }\n\n      if (chroot_path != NULL) {\n        session.chroot_path = dir_realpath(p, chroot_dir);\n\n      } else {\n        session.chroot_path = NULL;\n      }\n\n      if (session.chroot_path == NULL) {\n        pr_log_debug(DEBUG8, \"error resolving '%s': %s\", chroot_dir,\n          strerror(errno));\n      }\n\n    } else {\n      session.chroot_path = dir_realpath(p, chroot_dir);\n      if (session.chroot_path == NULL) {\n        pr_log_debug(DEBUG8, \"error resolving '%s': %s\", chroot_dir,\n          strerror(errno));\n      }\n    }\n\n    if (session.chroot_path &&\n        pr_fsio_access(session.chroot_path, X_OK, session.uid,\n          session.gid, session.gids) != 0) {\n      session.chroot_path = NULL;\n\n    } else {\n      session.chroot_path = pstrdup(session.pool, session.chroot_path);\n    }\n\n    /* Return all privileges back to that of the daemon, for now. */\n    PRIVS_ROOT\n    res = set_groups(p, daemon_gid, daemon_gids);\n    if (res < 0) {\n      pr_log_pri(PR_LOG_ERR, \"error: unable to set groups: %s\",\n        strerror(errno));\n    }\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n    PRIVS_SETUP(daemon_uid, daemon_gid)\n\n    pr_signals_unblock();\n\n    /* Sanity check, make sure we have daemon_uid and daemon_gid back */\n#ifdef HAVE_GETEUID\n    if (getegid() != daemon_gid ||\n        geteuid() != daemon_uid) {\n\n      PRIVS_RELINQUISH\n\n      pr_log_pri(PR_LOG_WARNING,\n        \"switching IDs from user %s back to daemon uid/gid failed: %s\",\n        session.user, strerror(errno));\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_BY_APPLICATION,\n        NULL);\n    }\n#endif /* HAVE_GETEUID */\n\n    if (anon_require_passwd &&\n        *anon_require_passwd == TRUE) {\n      session.anon_user = pstrdup(session.pool, origuser);\n\n    } else {\n      session.anon_user = pstrdup(session.pool, pass);\n    }\n\n    if (!session.chroot_path) {\n      pr_log_pri(PR_LOG_NOTICE, \"%s: Directory %s is not accessible\",\n        session.user, c->name);\n      pr_response_add_err(R_530, _(\"Unable to set anonymous privileges.\"));\n      goto auth_failure;\n    }\n\n    sstrncpy(session.cwd, \"/\", sizeof(session.cwd));\n    xferlog = get_param_ptr(c->subset, \"TransferLog\", FALSE);\n\n    if (anongroup) {\n      grp = pr_auth_getgrnam(p, anongroup);\n      if (grp) {\n        pw->pw_gid = grp->gr_gid;\n        session.group = pstrdup(p, grp->gr_name);\n      }\n    }\n\n  } else {\n    struct group *grp;\n    char *homedir;\n\n    if (ugroup) {\n      grp = pr_auth_getgrnam(p, ugroup);\n      if (grp) {\n        pw->pw_gid = grp->gr_gid;\n        session.group = pstrdup(p, grp->gr_name);\n      }\n    }\n\n    /* Attempt to resolve any possible symlinks. */\n    PRIVS_USER\n    homedir = dir_realpath(p, pw->pw_dir);\n    PRIVS_RELINQUISH\n\n    if (homedir)\n      sstrncpy(session.cwd, homedir, sizeof(session.cwd));\n    else\n      sstrncpy(session.cwd, pw->pw_dir, sizeof(session.cwd));\n  }\n\n  /* Create the home directory, if need be. */\n\n  if (!c && mkhome) {\n    if (create_home(p, session.cwd, origuser, pw->pw_uid, pw->pw_gid) < 0) {\n\n      /* NOTE: should this cause the login to fail? */\n      goto auth_failure;\n    }\n  }\n\n  /* Get default chdir (if any) */\n  defchdir = get_default_chdir(p, (c ? c->subset : main_server->conf));\n\n  if (defchdir)\n    sstrncpy(session.cwd, defchdir, sizeof(session.cwd));\n\n  /* Check limits again to make sure deny/allow directives still permit\n   * access.\n   */\n\n  if (!login_check_limits((c ? c->subset : main_server->conf), FALSE, TRUE,\n      &i)) {\n    pr_log_auth(PR_LOG_NOTICE, \"%s %s: Limit access denies login\",\n      (c != NULL) ? \"ANON\" : C_USER, origuser);\n    goto auth_failure;\n  }\n\n  /* Perform a directory fixup. */\n  resolve_deferred_dirs(main_server);\n  fixup_dirs(main_server, CF_DEFER);\n\n  /* If running under an anonymous context, resolve all <Directory>\n   * blocks inside it.\n   */\n  if (c && c->subset)\n    resolve_anonymous_dirs(c->subset);\n\n  /* Write the login to wtmp.  This must be done here because we won't\n   * have access after we give up root.  This can result in falsified\n   * wtmp entries if an error kicks the user out before we get\n   * through with the login process.  Oh well.\n   */\n\n  sess_ttyname = pr_session_get_ttyname(p);\n\n  /* Perform wtmp logging only if not turned off in <Anonymous>\n   * or the current server\n   */\n  if (c)\n    wtmp_log = get_param_ptr(c->subset, \"WtmpLog\", FALSE);\n\n  if (wtmp_log == NULL)\n    wtmp_log = get_param_ptr(main_server->conf, \"WtmpLog\", FALSE);\n\n  /* As per Bug#3482, we need to disable WtmpLog for FreeBSD 9.0, as\n   * an interim measure.\n   *\n   * The issue is that some platforms update multiple files for a single\n   * pututxline(3) call; proftpd tries to update those files manually,\n   * do to chroots (after which a pututxline(3) call will fail).  A proper\n   * solution requires a separate process, running with the correct\n   * privileges, which would handle wtmp logging. The proftpd session\n   * processes would send messages to this logging daemon (via Unix domain\n   * socket, or FIFO, or TCP socket).\n   *\n   * Also note that this hack to disable WtmpLog may need to be extended\n   * to other platforms in the future.\n   */\n#if defined(HAVE_UTMPX_H) && \\\n    defined(__FreeBSD_version) && __FreeBSD_version >= 900007\n  if (wtmp_log == NULL ||\n      *wtmp_log == TRUE) {\n    wtmp_log = pcalloc(p, sizeof(unsigned char));\n    *wtmp_log = FALSE;\n\n    pr_log_debug(DEBUG5,\n      \"WtpmLog automatically disabled; see Bug#3482 for details\");\n  }\n#endif\n\n  PRIVS_ROOT\n\n  if (wtmp_log == NULL ||\n      *wtmp_log == TRUE) {\n    log_wtmp(sess_ttyname, session.user, session.c->remote_name,\n      session.c->remote_addr);\n    session.wtmp_log = TRUE;\n  }\n\n#ifdef PR_USE_LASTLOG\n  if (lastlog) {\n    log_lastlog(pw->pw_uid, session.user, sess_ttyname, session.c->remote_addr);\n  }\n#endif /* PR_USE_LASTLOG */\n\n  /* Open any TransferLogs */\n  if (!xferlog) {\n    if (c)\n      xferlog = get_param_ptr(c->subset, \"TransferLog\", FALSE);\n\n    if (!xferlog)\n      xferlog = get_param_ptr(main_server->conf, \"TransferLog\", FALSE);\n\n    if (!xferlog)\n      xferlog = PR_XFERLOG_PATH;\n  }\n\n  if (strcasecmp(xferlog, \"NONE\") == 0) {\n    xferlog_open(NULL);\n\n  } else {\n    xferlog_open(xferlog);\n  }\n\n  res = set_groups(p, pw->pw_gid, session.gids);\n  if (res < 0) {\n    pr_log_pri(PR_LOG_ERR, \"error: unable to set groups: %s\",\n      strerror(errno));\n  }\n\n  PRIVS_RELINQUISH\n\n  /* Now check to see if the user has an applicable DefaultRoot */\n  if (c == NULL) {\n    if (get_default_root(session.pool, allow_chroot_symlinks, &defroot) < 0) {\n      pr_log_pri(PR_LOG_NOTICE,\n        \"error: unable to determine DefaultRoot directory\");\n      pr_response_send(R_530, _(\"Login incorrect.\"));\n      pr_session_end(0);\n    }\n\n    ensure_open_passwd(p);\n\n    if (defroot != NULL) {\n      if (pr_auth_chroot(defroot) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"error: unable to set DefaultRoot directory\");\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n      /* Re-calc the new cwd based on this root dir.  If not applicable\n       * place the user in / (of defroot)\n       */\n\n      if (strncmp(session.cwd, defroot, strlen(defroot)) == 0) {\n        char *newcwd = &session.cwd[strlen(defroot)];\n\n        if (*newcwd == '/')\n          newcwd++;\n        session.cwd[0] = '/';\n        sstrncpy(&session.cwd[1], newcwd, sizeof(session.cwd));\n      }\n    }\n  }\n\n  if (c)\n    ensure_open_passwd(p);\n\n  if (c &&\n      pr_auth_chroot(session.chroot_path) == -1) {\n    pr_log_pri(PR_LOG_NOTICE, \"error: unable to set anonymous privileges\");\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n\n  /* new in 1.1.x, I gave in and we don't give up root permanently..\n   * sigh.\n   */\n\n  PRIVS_ROOT\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n  PRIVS_SETUP(pw->pw_uid, pw->pw_gid)\n\n#ifdef HAVE_GETEUID\n  if (getegid() != pw->pw_gid ||\n     geteuid() != pw->pw_uid) {\n\n    PRIVS_RELINQUISH\n    pr_log_pri(PR_LOG_ERR, \"error: %s setregid() or setreuid(): %s\",\n      session.user, strerror(errno));\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n#endif\n\n  /* If the home directory is NULL or \"\", reject the login. */\n  if (pw->pw_dir == NULL ||\n      strncmp(pw->pw_dir, \"\", 1) == 0) {\n    pr_log_pri(PR_LOG_WARNING, \"error: user %s home directory is NULL or \\\"\\\"\",\n      session.user);\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n\n  {\n    unsigned char *show_symlinks = get_param_ptr(\n      c ? c->subset : main_server->conf, \"ShowSymlinks\", FALSE);\n\n    if (!show_symlinks || *show_symlinks == TRUE)\n      showsymlinks = TRUE;\n    else\n      showsymlinks = FALSE;\n  }\n\n  /* chdir to the proper directory, do this even if anonymous\n   * to make sure we aren't outside our chrooted space.\n   */\n\n  /* Attempt to change to the correct directory -- use session.cwd first.\n   * This will contain the DefaultChdir directory, if configured...\n   */\n  if (pr_fsio_chdir_canon(session.cwd, !showsymlinks) == -1) {\n\n    /* if we've got DefaultRoot or anonymous login, ignore this error\n     * and chdir to /\n     */\n\n    if (session.chroot_path != NULL || defroot) {\n\n      pr_log_debug(DEBUG2, \"unable to chdir to %s (%s), defaulting to chroot \"\n        \"directory %s\", session.cwd, strerror(errno),\n        (session.chroot_path ? session.chroot_path : defroot));\n\n      if (pr_fsio_chdir_canon(\"/\", !showsymlinks) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"/\\\") failed: %s\", session.user,\n          strerror(errno));\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n    } else if (defchdir) {\n\n      /* If we've got defchdir, failure is ok as well, simply switch to\n       * user's homedir.\n       */\n      pr_log_debug(DEBUG2, \"unable to chdir to %s (%s), defaulting to home \"\n        \"directory %s\", session.cwd, strerror(errno), pw->pw_dir);\n\n      if (pr_fsio_chdir_canon(pw->pw_dir, !showsymlinks) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"%s\\\") failed: %s\", session.user,\n          session.cwd, strerror(errno));\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n    } else {\n\n      /* Unable to switch to user's real home directory, which is not\n       * allowed.\n       */\n      pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"%s\\\") failed: %s\", session.user,\n        session.cwd, strerror(errno));\n      pr_response_send(R_530, _(\"Login incorrect.\"));\n      pr_session_end(0);\n    }\n  }\n\n  sstrncpy(session.cwd, pr_fs_getcwd(), sizeof(session.cwd));\n  sstrncpy(session.vwd, pr_fs_getvwd(), sizeof(session.vwd));\n\n  /* Make sure directory config pointers are set correctly */\n  dir_check_full(p, cmd, G_NONE, session.cwd, NULL);\n\n  if (c) {\n    if (!session.hide_password) {\n      session.proc_prefix = pstrcat(session.pool, session.c->remote_name,\n        \": anonymous/\", pass, NULL);\n\n    } else {\n      session.proc_prefix = pstrcat(session.pool, session.c->remote_name,\n        \": anonymous\", NULL);\n    }\n\n    session.sf_flags = SF_ANON;\n\n  } else {\n    session.proc_prefix = pstrdup(session.pool, session.c->remote_name);\n    session.sf_flags = 0;\n  }\n\n  /* While closing the pointer to the password database would avoid any\n   * potential attempt to hijack this information, it is unfortunately needed\n   * in a chroot()ed environment.  Otherwise, mappings from UIDs to names,\n   * among other things, would fail.\n   */\n  /* pr_auth_endpwent(p); */\n\n  /* Default transfer mode is ASCII */\n  defaulttransfermode = (char *) get_param_ptr(main_server->conf,\n    \"DefaultTransferMode\", FALSE);\n\n  if (defaulttransfermode &&\n      strcasecmp(defaulttransfermode, \"binary\") == 0) {\n    session.sf_flags &= (SF_ALL^SF_ASCII);\n\n  } else {\n    session.sf_flags |= SF_ASCII;\n  }\n\n  /* Authentication complete, user logged in, now kill the login\n   * timer.\n   */\n\n  /* Update the scoreboard entry */\n  pr_scoreboard_entry_update(session.pid,\n    PR_SCORE_USER, session.user,\n    PR_SCORE_CWD, session.cwd,\n    NULL);\n\n  pr_session_set_idle();\n\n  pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n\n  /* These copies are made from the session.pool, instead of the more\n   * volatile pool used originally, in order that the copied data maintain\n   * its integrity for the lifetime of the session.\n   */\n  session.user = pstrdup(session.pool, session.user);\n\n  if (session.group)\n    session.group = pstrdup(session.pool, session.group);\n\n  if (session.gids)\n    session.gids = copy_array(session.pool, session.gids);\n\n  /* session.groups is an array of strings, so we must copy the string data\n   * as well as the pointers.\n   */\n  session.groups = copy_array_str(session.pool, session.groups);\n\n  /* Resolve any deferred-resolution paths in the FS layer */\n  pr_resolve_fs_map();\n\n  return 1;\n\nauth_failure:\n  if (pass)\n    pr_memscrub(pass, strlen(pass));\n  session.user = session.group = NULL;\n  session.gids = session.groups = NULL;\n  session.wtmp_log = FALSE;\n  return 0;\n}\n\n/* This function counts the number of connected users. It only fills in the\n * Class-based counters and an estimate for the number of clients. The primary\n * purpose is to make it so that the %N/%y escapes work in a DisplayConnect\n * greeting.  A secondary purpose is to enforce any configured\n * MaxConnectionsPerHost limit.\n */\nstatic int auth_scan_scoreboard(void) {\n  char *key;\n  void *v;\n  config_rec *c = NULL;\n  pr_scoreboard_entry_t *score = NULL;\n  unsigned int cur = 0, ccur = 0, hcur = 0;\n  char curr_server_addr[80] = {'\\0'};\n  const char *client_addr = pr_netaddr_get_ipstr(session.c->remote_addr);\n\n  snprintf(curr_server_addr, sizeof(curr_server_addr), \"%s:%d\",\n    pr_netaddr_get_ipstr(session.c->local_addr), main_server->ServerPort);\n  curr_server_addr[sizeof(curr_server_addr)-1] = '\\0';\n\n  /* Determine how many users are currently connected */\n  if (pr_rewind_scoreboard() < 0) {\n    pr_log_pri(PR_LOG_NOTICE, \"error rewinding scoreboard: %s\",\n      strerror(errno));\n  }\n\n  while ((score = pr_scoreboard_entry_read()) != NULL) {\n    pr_signals_handle();\n\n    /* Make sure it matches our current server */\n    if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {\n      cur++;\n\n      if (strcmp(score->sce_client_addr, client_addr) == 0)\n        hcur++;\n\n      /* Only count up authenticated clients, as per the documentation. */\n      if (strncmp(score->sce_user, \"(none)\", 7) == 0)\n        continue;\n\n      /* Note: the class member of the scoreboard entry will never be\n       * NULL.  At most, it may be the empty string.\n       */\n      if (session.conn_class != NULL &&\n          strcasecmp(score->sce_class, session.conn_class->cls_name) == 0) {\n        ccur++;\n      }\n    }\n  }\n  pr_restore_scoreboard();\n\n  key = \"client-count\";\n  (void) pr_table_remove(session.notes, key, NULL);\n  v = palloc(session.pool, sizeof(unsigned int));\n  *((unsigned int *) v) = cur;\n\n  if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n    if (errno != EEXIST) {\n      pr_log_pri(PR_LOG_WARNING,\n        \"warning: error stashing '%s': %s\", key, strerror(errno));\n    }\n  }\n\n  if (session.conn_class != NULL) {\n    key = \"class-client-count\";\n    (void) pr_table_remove(session.notes, key, NULL);\n    v = palloc(session.pool, sizeof(unsigned int));\n    *((unsigned int *) v) = ccur;\n\n    if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n      if (errno != EEXIST) {\n        pr_log_pri(PR_LOG_WARNING,\n          \"warning: error stashing '%s': %s\", key, strerror(errno));\n      }\n    }\n  }\n\n  /* Lookup any configured MaxConnectionsPerHost. */\n  c = find_config(main_server->conf, CONF_PARAM, \"MaxConnectionsPerHost\",\n    FALSE);\n\n  if (c) {\n    unsigned int *max = c->argv[0];\n\n    if (*max &&\n        hcur > *max) {\n\n      char maxstr[20];\n      char *msg = \"Sorry, the maximum number of connections (%m) for your host \"\n        \"are already connected.\";\n\n      pr_event_generate(\"mod_auth.max-connections-per-host\", session.c);\n\n      if (c->argc == 2)\n        msg = c->argv[1];\n\n      memset(maxstr, '\\0', sizeof(maxstr));\n      snprintf(maxstr, sizeof(maxstr), \"%u\", *max);\n      maxstr[sizeof(maxstr)-1] = '\\0';\n\n      pr_response_send(R_530, \"%s\", sreplace(session.pool, msg,\n        \"%m\", maxstr, NULL));\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxConnectionsPerHost %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxConnectionsPerHost\");\n    }\n  }\n\n  return 0;\n}\n\nstatic int have_client_limits(cmd_rec *cmd) {\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerClass\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerHost\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerUser\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClients\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxHostsPerUser\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic int auth_count_scoreboard(cmd_rec *cmd, char *user) {\n  char *key;\n  void *v;\n  pr_scoreboard_entry_t *score = NULL;\n  long cur = 0, hcur = 0, ccur = 0, hostsperuser = 1, usersessions = 0;\n  config_rec *c = NULL, *maxc = NULL;\n\n  /* First, check to see which Max* directives are configured.  If none\n   * are configured, then there is no need for us to needlessly scan the\n   * ScoreboardFile.\n   */\n  if (have_client_limits(cmd) == FALSE) {\n    return 0;\n  }\n\n  /* Determine how many users are currently connected. */\n\n  /* We use this call to get the possibly-changed user name. */\n  (void) pr_auth_get_anon_config(cmd->tmp_pool, &user, NULL, NULL);\n\n  /* Gather our statistics. */\n  if (user) {\n    char curr_server_addr[80] = {'\\0'};\n\n    snprintf(curr_server_addr, sizeof(curr_server_addr), \"%s:%d\",\n      pr_netaddr_get_ipstr(session.c->local_addr), main_server->ServerPort);\n    curr_server_addr[sizeof(curr_server_addr)-1] = '\\0';\n\n    if (pr_rewind_scoreboard() < 0) {\n      pr_log_pri(PR_LOG_NOTICE, \"error rewinding scoreboard: %s\",\n        strerror(errno));\n    }\n\n    while ((score = pr_scoreboard_entry_read()) != NULL) {\n      unsigned char same_host = FALSE;\n\n      pr_signals_handle();\n\n      /* Make sure it matches our current server. */\n      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {\n\n        if ((c && c->config_type == CONF_ANON &&\n            !strcmp(score->sce_user, user)) || !c) {\n\n          /* This small hack makes sure that cur is incremented properly\n           * when dealing with anonymous logins (the timing of anonymous\n           * login updates to the scoreboard makes this...odd).\n           */\n          if (c && c->config_type == CONF_ANON && cur == 0)\n              cur = 1;\n\n          /* Only count authenticated clients, as per the documentation. */\n          if (strncmp(score->sce_user, \"(none)\", 7) == 0)\n            continue;\n\n          cur++;\n\n          /* Count up sessions on a per-host basis. */\n\n          if (!strcmp(score->sce_client_addr,\n              pr_netaddr_get_ipstr(session.c->remote_addr))) {\n            same_host = TRUE;\n\n            /* This small hack makes sure that hcur is incremented properly\n             * when dealing with anonymous logins (the timing of anonymous\n             * login updates to the scoreboard makes this...odd).\n             */\n            if (c && c->config_type == CONF_ANON && hcur == 0)\n              hcur = 1;\n\n            hcur++;\n          }\n\n          /* Take a per-user count of connections. */\n          if (strcmp(score->sce_user, user) == 0) {\n            usersessions++;\n\n            /* Count up unique hosts. */\n            if (!same_host)\n              hostsperuser++;\n          }\n        }\n\n        if (session.conn_class != NULL &&\n            strcasecmp(score->sce_class, session.conn_class->cls_name) == 0) {\n          ccur++;\n        }\n      }\n    }\n    pr_restore_scoreboard();\n    PRIVS_RELINQUISH\n  }\n\n  key = \"client-count\";\n  (void) pr_table_remove(session.notes, key, NULL);\n  v = palloc(session.pool, sizeof(unsigned int));\n  *((unsigned int *) v) = cur;\n\n  if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n    if (errno != EEXIST) {\n      pr_log_pri(PR_LOG_WARNING,\n        \"warning: error stashing '%s': %s\", key, strerror(errno));\n    }\n  }\n\n  if (session.conn_class != NULL) {\n    key = \"class-client-count\";\n    (void) pr_table_remove(session.notes, key, NULL);\n    v = palloc(session.pool, sizeof(unsigned int));\n    *((unsigned int *) v) = ccur;\n\n    if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n      if (errno != EEXIST) {\n        pr_log_pri(PR_LOG_WARNING,\n          \"warning: error stashing '%s': %s\", key, strerror(errno));\n      }\n    }\n  }\n\n  /* Try to determine what MaxClients/MaxHosts limits apply to this session\n   * (if any) and count through the runtime file to see if this limit would\n   * be exceeded.\n   */\n\n  maxc = find_config(cmd->server->conf, CONF_PARAM, \"MaxClientsPerClass\",\n    FALSE);\n  while (session.conn_class != NULL && maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your class \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[1];\n\n    if (strcmp(maxc->argv[0], session.conn_class->cls_name) != 0) {\n      maxc = find_config_next(maxc, maxc->next, CONF_PARAM,\n        \"MaxClientsPerClass\", FALSE);\n      continue;\n    }\n\n    if (maxc->argc > 2)\n      maxstr = maxc->argv[2];\n\n    if (*max &&\n        ccur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-class\",\n        session.conn_class->cls_name);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerClass %s %u)\",\n        session.conn_class->cls_name, *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerClass\");\n    }\n\n    break;\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerHost\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your host \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hcur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-host\", session.c);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerHost %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerHost\");\n    }\n  }\n\n  /* Check for any configured MaxClientsPerUser. */\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) for this user \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && usersessions > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerUser %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerUser\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClients\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of allowed clients (%m) are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && cur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients\", NULL);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxClients %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClients\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxHostsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of hosts (%m) for this user are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hostsperuser > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-hosts-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxHostsPerHost %u)\",\n        *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxHostsPerUser\");\n    }\n  }\n\n  return 0;\n}\n\nMODRET auth_pre_user(cmd_rec *cmd) {\n\n  if (logged_in)\n    return PR_DECLINED(cmd);\n\n  /* Close the passwd and group databases, because libc won't let us see new\n   * entries to these files without this (only in PersistentPasswd mode).\n   */\n  pr_auth_endpwent(cmd->tmp_pool);\n  pr_auth_endgrent(cmd->tmp_pool);\n\n  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */\n  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {\n    pr_log_pri(PR_LOG_NOTICE, \"USER %s (Login failed): \"\n      \"maximum USER length exceeded\", cmd->arg);\n    pr_response_add_err(R_501, _(\"Login incorrect.\"));\n    return PR_ERROR(cmd);\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_user(cmd_rec *cmd) {\n  int nopass = FALSE;\n  config_rec *c;\n  char *denymsg = NULL, *user, *origuser;\n  int failnopwprompt = 0, aclp, i;\n  unsigned char *anon_require_passwd = NULL, *login_passwd_prompt = NULL;\n\n  if (cmd->argc < 2) {\n    return PR_ERROR_MSG(cmd, R_500, _(\"USER: command requires a parameter\"));\n  }\n\n  if (logged_in) {\n    /* If the client has already authenticated, BUT the given USER command\n     * here is for the exact same user name, then allow the command to\n     * succeed (Bug#4217).\n     */\n    origuser = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n    if (origuser != NULL &&\n        strcmp(origuser, cmd->arg) == 0) {\n      pr_response_add(R_230, _(\"User %s logged in\"), origuser);\n      return PR_HANDLED(cmd);\n    }\n\n    pr_response_add_err(R_501, \"%s\", _(\"Reauthentication not supported\"));\n    return PR_ERROR(cmd);\n  }\n\n  user = cmd->arg;\n\n  (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n  (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n  if (pr_table_add_dup(session.notes, \"mod_auth.orig-user\", user, 0) < 0) {\n    pr_log_debug(DEBUG3, \"error stashing 'mod_auth.orig-user' in \"\n      \"session.notes: %s\", strerror(errno));\n  }\n\n  origuser = user;\n  c = pr_auth_get_anon_config(cmd->tmp_pool, &user, NULL, NULL);\n\n  /* Check for AccessDenyMsg */\n  denymsg = get_param_ptr((c ? c->subset : cmd->server->conf), \"AccessDenyMsg\",\n    FALSE);\n  if (denymsg != NULL) {\n    if (strstr(denymsg, \"%u\") != NULL) {\n      denymsg = sreplace(cmd->tmp_pool, denymsg, \"%u\", user, NULL);\n    }\n  }\n\n  login_passwd_prompt = get_param_ptr(\n    (c && c->config_type == CONF_ANON) ? c->subset : main_server->conf,\n    \"LoginPasswordPrompt\", FALSE);\n\n  if (login_passwd_prompt &&\n      *login_passwd_prompt == FALSE) {\n    failnopwprompt = TRUE;\n\n  } else {\n    failnopwprompt = FALSE;\n  }\n\n  if (failnopwprompt) {\n    if (!user) {\n      (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n      (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n      pr_log_pri(PR_LOG_NOTICE, \"USER %s (Login failed): Not a UserAlias\",\n        origuser);\n\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n      }\n\n      pr_session_end(0);\n    }\n\n    aclp = login_check_limits(main_server->conf, FALSE, TRUE, &i);\n\n    if (c && c->config_type != CONF_ANON) {\n      c = (config_rec *) pcalloc(session.pool, sizeof(config_rec));\n      c->config_type = CONF_ANON;\n      c->name = \"\";\t/* don't really need this yet */\n      c->subset = main_server->conf;\n    }\n\n    if (c) {\n      if (!login_check_limits(c->subset, FALSE, TRUE, &i) ||\n          (!aclp && !i) ) {\n        (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n        (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n        pr_log_auth(PR_LOG_NOTICE, \"ANON %s: Limit access denies login\",\n          origuser);\n\n        if (denymsg) {\n          pr_response_send(R_530, \"%s\", denymsg);\n\n        } else {\n          pr_response_send(R_530, _(\"Login incorrect.\"));\n        }\n\n        pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n          \"Denied by <Limit LOGIN>\");\n      }\n    }\n\n    if (c == NULL &&\n        aclp == 0) {\n      (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n      (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"USER %s: Limit access denies login\", origuser);\n\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n      }\n\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by <Limit LOGIN>\");\n    }\n  }\n\n  if (c)\n    anon_require_passwd = get_param_ptr(c->subset, \"AnonRequirePassword\",\n      FALSE);\n\n  if (c && user && (!anon_require_passwd || *anon_require_passwd == FALSE))\n    nopass = TRUE;\n\n  session.gids = NULL;\n  session.groups = NULL;\n  session.user = NULL;\n  session.group = NULL;\n\n  if (nopass) {\n    pr_response_add(R_331, _(\"Anonymous login ok, send your complete email \"\n      \"address as your password\"));\n\n  } else if (pr_auth_requires_pass(cmd->tmp_pool, user) == FALSE) {\n    /* Check to see if a password from the client is required.  In the\n     * vast majority of cases, a password will be required.\n     */\n\n    /* Act as if we received a PASS command from the client. */\n    cmd_rec *fakecmd = pr_cmd_alloc(cmd->pool, 2, NULL);\n\n    /* We use pstrdup() here, rather than assigning C_PASS directly, since\n     * code elsewhere will attempt to modify this buffer, and C_PASS is\n     * a string literal.\n     */\n    fakecmd->argv[0] = pstrdup(fakecmd->pool, C_PASS);\n    fakecmd->argv[1] = NULL;\n    fakecmd->arg = NULL;\n\n    c = add_config_param_set(&cmd->server->conf, \"authenticated\", 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = TRUE;\n\n    authenticated_without_pass = TRUE;\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s: Authenticated without password\", user);\n\n    pr_cmd_dispatch(fakecmd);\n\n  } else {\n    pr_response_add(R_331, _(\"Password required for %s\"), cmd->argv[1]);\n  }\n\n  return PR_HANDLED(cmd);\n}\n\n/* Close the passwd and group databases, similar to auth_pre_user(). */\nMODRET auth_pre_pass(cmd_rec *cmd) {\n  char *displaylogin;\n\n  pr_auth_endpwent(cmd->tmp_pool);\n  pr_auth_endgrent(cmd->tmp_pool);\n\n  /* Look for a DisplayLogin file which has an absolute path.  If we find one,\n   * open a filehandle, such that that file can be displayed even if the\n   * session is chrooted.  DisplayLogin files with relative paths will be\n   * handled after chroot, preserving the old behavior.\n   */\n\n  displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n  if (displaylogin &&\n      *displaylogin == '/') {\n    struct stat st;\n\n    displaylogin_fh = pr_fsio_open(displaylogin, O_RDONLY);\n    if (displaylogin_fh == NULL) {\n      pr_log_debug(DEBUG6, \"unable to open DisplayLogin file '%s': %s\",\n        displaylogin, strerror(errno));\n\n    } else {\n      if (pr_fsio_fstat(displaylogin_fh, &st) < 0) {\n        pr_log_debug(DEBUG6, \"unable to stat DisplayLogin file '%s': %s\",\n          displaylogin, strerror(errno));\n        pr_fsio_close(displaylogin_fh);\n        displaylogin_fh = NULL;\n\n      } else {\n        if (S_ISDIR(st.st_mode)) {\n          errno = EISDIR;\n          pr_log_debug(DEBUG6, \"unable to use DisplayLogin file '%s': %s\",\n            displaylogin, strerror(errno));\n          pr_fsio_close(displaylogin_fh);\n          displaylogin_fh = NULL;\n        }\n      }\n    }\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_pass(cmd_rec *cmd) {\n  char *user = NULL;\n  int res = 0;\n\n  if (logged_in)\n    return PR_ERROR_MSG(cmd, R_503, _(\"You are already logged in\"));\n\n  user = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n  if (!user) {\n    (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n    (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n    return PR_ERROR_MSG(cmd, R_503, _(\"Login with USER first\"));\n  }\n\n  /* Clear any potentially cached directory config */\n  session.anon_config = NULL;\n  session.dir_config = NULL;\n\n  res = setup_env(cmd->tmp_pool, cmd, user, cmd->arg);\n  if (res == 1) {\n    config_rec *c = NULL;\n\n    c = add_config_param_set(&cmd->server->conf, \"authenticated\", 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = TRUE;\n\n    set_auth_check(NULL);\n\n    (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n    if (session.sf_flags & SF_ANON) {\n      if (pr_table_add_dup(session.notes, \"mod_auth.anon-passwd\",\n          pr_fs_decode_path(cmd->server->pool, cmd->arg), 0) < 0) {\n        pr_log_debug(DEBUG3,\n          \"error stashing anonymous password in session.notes: %s\",\n          strerror(errno));\n      }\n    }\n\n    logged_in = 1;\n    return PR_HANDLED(cmd);\n  }\n\n  (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n  if (res == 0) {\n    unsigned int max_logins, *max = NULL;\n    char *denymsg = NULL;\n\n    /* check for AccessDenyMsg */\n    if ((denymsg = get_param_ptr((session.anon_config ?\n        session.anon_config->subset : cmd->server->conf),\n        \"AccessDenyMsg\", FALSE)) != NULL) {\n\n      if (strstr(denymsg, \"%u\") != NULL) {\n        denymsg = sreplace(cmd->tmp_pool, denymsg, \"%u\", user, NULL);\n      }\n    }\n\n    max = get_param_ptr(main_server->conf, \"MaxLoginAttempts\", FALSE);\n    if (max != NULL) {\n      max_logins = *max;\n\n    } else {\n      max_logins = 3;\n    }\n\n    if (max_logins > 0 &&\n        ++auth_tries >= max_logins) {\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n      }\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Maximum login attempts (%u) exceeded, connection refused\", max_logins);\n\n      /* Generate an event about this limit being exceeded. */\n      pr_event_generate(\"mod_auth.max-login-attempts\", session.c);\n\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxLoginAttempts\");\n    }\n\n    return PR_ERROR_MSG(cmd, R_530, denymsg ? denymsg : _(\"Login incorrect.\"));\n  }\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_acct(cmd_rec *cmd) {\n  pr_response_add(R_502, _(\"ACCT command not implemented\"));\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_rein(cmd_rec *cmd) {\n  pr_response_add(R_502, _(\"REIN command not implemented\"));\n  return PR_HANDLED(cmd);\n}\n\n/* Configuration handlers\n */\n\nMODRET set_accessdenymsg(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_accessgrantmsg(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: AllowChrootSymlinks on|off */\nMODRET set_allowchrootsymlinks(cmd_rec *cmd) {\n  int b = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  b = get_boolean(cmd, 1);\n  if (b == -1) {\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = b;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_anonrequirepassword(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_anonrejectpasswords(cmd_rec *cmd) {\n#ifdef PR_USE_REGEX\n  pr_regex_t *pre = NULL;\n  int res;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  pre = pr_regexp_alloc(&auth_module);\n\n  res = pr_regexp_compile(pre, cmd->argv[1], REG_EXTENDED|REG_NOSUB);\n  if (res != 0) {\n    char errstr[200] = {'\\0'};\n\n    pr_regexp_error(res, pre, errstr, 200);\n    pr_regexp_free(NULL, pre);\n\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"Unable to compile regex '\",\n      cmd->argv[1], \"': \", errstr, NULL));\n  }\n\n  (void) add_config_param(cmd->argv[0], 1, (void *) pre);\n  return PR_HANDLED(cmd);\n\n#else\n  CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"The \", cmd->argv[0], \" directive \"\n    \"cannot be used on this system, as you do not have POSIX compliant \"\n    \"regex support\", NULL));\n#endif\n}\n\nMODRET set_authaliasonly(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_authusingalias(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_createhome(cmd_rec *cmd) {\n  int bool = -1, start = 2;\n  mode_t mode = (mode_t) 0700, dirmode = (mode_t) 0711;\n  char *skel_path = NULL;\n  config_rec *c = NULL;\n  uid_t cuid = 0;\n  gid_t cgid = 0, hgid = -1;\n  unsigned long flags = 0UL;\n\n  if (cmd->argc-1 < 1) {\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n  }\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1) {\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n  }\n\n  /* No need to process the rest if bool is FALSE. */\n  if (bool == FALSE) {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = bool;\n\n    return PR_HANDLED(cmd);\n  }\n\n  /* Check the mode parameter, if present */\n  if (cmd->argc-1 >= 2 &&\n      strcasecmp(cmd->argv[2], \"dirmode\") != 0 &&\n      strcasecmp(cmd->argv[2], \"skel\") != 0) {\n    char *tmp = NULL;\n\n    mode = strtol(cmd->argv[2], &tmp, 8);\n\n    if (tmp && *tmp)\n      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \": bad mode parameter: '\",\n        cmd->argv[2], \"'\", NULL));\n\n    start = 3;\n  }\n\n  if (cmd->argc-1 > 2) {\n    register unsigned int i;\n\n    /* Cycle through the rest of the parameters */\n    for (i = start; i < cmd->argc;) {\n      if (strcasecmp(cmd->argv[i], \"skel\") == 0) {\n        struct stat st;\n\n        /* Check that the skel directory, if configured, meets the\n         * requirements.\n         */\n\n        skel_path = cmd->argv[++i];\n\n        if (*skel_path != '/') {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"skel path '\",\n            skel_path, \"' is not a full path\", NULL));\n        }\n\n        if (pr_fsio_stat(skel_path, &st) < 0) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"unable to stat '\",\n            skel_path, \"': \", strerror(errno), NULL));\n        }\n\n        if (!S_ISDIR(st.st_mode)) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"'\", skel_path,\n            \"' is not a directory\", NULL));\n        }\n\n        /* Must not be world-writable. */\n        if (st.st_mode & S_IWOTH) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"'\", skel_path,\n            \"' is world-writable\", NULL));\n        }\n\n        /* Move the index past the skel parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"dirmode\") == 0) {\n        char *tmp = NULL;\n\n        dirmode = strtol(cmd->argv[++i], &tmp, 8);\n \n        if (tmp && *tmp)\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad mode parameter: '\",\n            cmd->argv[i], \"'\", NULL));\n\n        /* Move the index past the dirmode parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"uid\") == 0) {\n\n        /* Check for a \"~\" parameter. */\n        if (strncmp(cmd->argv[i+1], \"~\", 2) != 0) {\n          char *tmp = NULL;\n          uid_t uid;\n\n          uid = strtol(cmd->argv[++i], &tmp, 10);\n\n          if (tmp && *tmp) {\n            CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad UID parameter: '\",\n              cmd->argv[i], \"'\", NULL));\n          }\n\n          cuid = uid;\n\n        } else {\n          cuid = (uid_t) -1;       \n          i++;\n        }\n\n        /* Move the index past the uid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"gid\") == 0) {\n\n        /* Check for a \"~\" parameter. */\n        if (strncmp(cmd->argv[i+1], \"~\", 2) != 0) {\n          char *tmp = NULL;\n          gid_t gid;\n\n          gid = strtol(cmd->argv[++i], &tmp, 10);\n\n          if (tmp && *tmp) {\n            CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad GID parameter: '\",\n              cmd->argv[i], \"'\", NULL));\n          }\n\n          cgid = gid;\n\n        } else {\n          cgid = (gid_t) -1;\n          i++;\n        }\n\n        /* Move the index past the gid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"homegid\") == 0) {\n        char *tmp = NULL;\n        gid_t gid;\n\n        gid = strtol(cmd->argv[++i], &tmp, 10);\n\n        if (tmp && *tmp) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad GID parameter: '\",\n            cmd->argv[i], \"'\", NULL));\n        }\n\n        hgid = gid;\n\n        /* Move the index past the homegid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"NoRootPrivs\") == 0) {\n        flags |= PR_MKHOME_FL_USE_USER_PRIVS;\n        i++;\n\n      } else {\n        CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"unknown parameter: '\",\n          cmd->argv[i], \"'\", NULL));\n      }\n    }\n  }\n\n  c = add_config_param(cmd->argv[0], 8, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL);\n\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->argv[1] = pcalloc(c->pool, sizeof(mode_t));\n  *((mode_t *) c->argv[1]) = mode;\n  c->argv[2] = pcalloc(c->pool, sizeof(mode_t));\n  *((mode_t *) c->argv[2]) = dirmode;\n\n  if (skel_path) {\n    c->argv[3] = pstrdup(c->pool, skel_path);\n  }\n\n  c->argv[4] = pcalloc(c->pool, sizeof(uid_t));\n  *((uid_t *) c->argv[4]) = cuid;\n  c->argv[5] = pcalloc(c->pool, sizeof(gid_t));\n  *((gid_t *) c->argv[5]) = cgid;\n  c->argv[6] = pcalloc(c->pool, sizeof(gid_t));\n  *((gid_t *) c->argv[6]) = hgid;\n  c->argv[7] = pcalloc(c->pool, sizeof(unsigned long));\n  *((unsigned long *) c->argv[7]) = flags;\n \n  return PR_HANDLED(cmd);\n}\n\nMODRET add_defaultroot(cmd_rec *cmd) {\n  config_rec *c;\n  char *dir,**argv;\n  int argc;\n  array_header *acl = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (cmd->argc < 2)\n    CONF_ERROR(cmd,\"syntax: DefaultRoot <directory> [<group-expression>]\");\n\n  argv = cmd->argv;\n  argc = cmd->argc - 2;\n\n  dir = *++argv;\n\n  /* dir must be / or ~. */\n  if (*dir != '/' &&\n      *dir != '~')\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") absolute pathname \"\n      \"required\", NULL));\n\n  if (strchr(dir, '*'))\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") wildcards not allowed \"\n      \"in pathname\", NULL));\n\n  if (*(dir + strlen(dir) - 1) != '/')\n    dir = pstrcat(cmd->tmp_pool, dir, \"/\", NULL);\n\n  acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n  c = add_config_param(cmd->argv[0], 0);\n\n  c->argc = argc + 1;\n  c->argv = pcalloc(c->pool, (argc + 2) * sizeof(char *));\n  argv = (char **) c->argv;\n  *argv++ = pstrdup(c->pool, dir);\n\n  if (argc && acl)\n    while(argc--) {\n      *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n      acl->elts = ((char **) acl->elts) + 1;\n    }\n\n  *argv = NULL;\n  return PR_HANDLED(cmd);\n}\n\nMODRET add_defaultchdir(cmd_rec *cmd) {\n  config_rec *c;\n  char *dir,**argv;\n  int argc;\n  array_header *acl = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (cmd->argc < 2)\n    CONF_ERROR(cmd, \"syntax: DefaultChdir <directory> [<group-expression>]\");\n\n  argv = cmd->argv;\n  argc = cmd->argc - 2;\n\n  dir = *++argv;\n\n  if (strchr(dir, '*'))\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") wildcards not allowed \"\n      \"in pathname\", NULL));\n\n  if (*(dir + strlen(dir) - 1) != '/')\n    dir = pstrcat(cmd->tmp_pool, dir, \"/\", NULL);\n\n  acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n  c = add_config_param(cmd->argv[0], 0);\n\n  c->argc = argc + 1;\n  c->argv = pcalloc(c->pool, (argc + 2) * sizeof(char *));\n  argv = (char **) c->argv;\n  *argv++ = pstrdup(c->pool, dir);\n\n  if (argc && acl)\n    while(argc--) {\n      *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n      acl->elts = ((char **) acl->elts) + 1;\n    }\n\n  *argv = NULL;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_displaylogin(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_grouppassword(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_loginpasswordprompt(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClientsPerClass class max|\"none\" [\"message\"] */\nMODRET set_maxclientsclass(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[2], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[2], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"max must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 4) {\n    c = add_config_param(cmd->argv[0], 3, NULL, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n    c->argv[2] = pstrdup(c->pool, cmd->argv[3]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n  }\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClients max|\"none\" [\"message\"] */\nMODRET set_maxclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClientsPerHost max|\"none\" [\"message\"] */\nMODRET set_maxhostclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n\n/* usage: MaxClientsPerUser max|\"none\" [\"message\"] */\nMODRET set_maxuserclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxConnectionsPerHost max|\"none\" [\"message\"] */\nMODRET set_maxconnectsperhost(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[1], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *tmp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &tmp, 10);\n\n    if ((tmp && *tmp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else\n    c = add_config_param(cmd->argv[0], 1, NULL);\n\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n  *((unsigned int *) c->argv[0]) = max;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxHostsPerUser max|\"none\" [\"message\"] */\nMODRET set_maxhostsperuser(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_maxloginattempts(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[1], \"none\") == 0) {\n    max = 0;\n\n  } else {\n    char *endp = NULL;\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n  *((unsigned int *) c->argv[0]) = max;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_requirevalidshell(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: RewriteHome on|off */\nMODRET set_rewritehome(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_rootlogin(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd,1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = (unsigned char) bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: RootRevoke on|off|UseNonCompliantActiveTransfer */\nMODRET set_rootrevoke(cmd_rec *cmd) {\n  int root_revoke = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* A RootRevoke value of 0 indicates 'false', 1 indicates 'true', and\n   * 2 indicates 'NonCompliantActiveTransfer'.\n   */\n  root_revoke = get_boolean(cmd, 1);\n  if (root_revoke == -1) {\n    if (strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfer\") != 0 &&\n        strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfers\") != 0) {\n      CONF_ERROR(cmd, \"expected Boolean parameter\");\n    }\n\n    root_revoke = 2;\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = (unsigned char) root_revoke;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_timeoutlogin(cmd_rec *cmd) {\n  int timeout = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = timeout;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_timeoutsession(cmd_rec *cmd) {\n  int timeout = 0, precedence = 0;\n  config_rec *c = NULL;\n\n  int ctxt = (cmd->config && cmd->config->config_type != CONF_PARAM ?\n     cmd->config->config_type : cmd->server->config_type ?\n     cmd->server->config_type : CONF_ROOT);\n\n  /* this directive must have either 1 or 3 arguments */\n  if (cmd->argc-1 != 1 && cmd->argc-1 != 3)\n    CONF_ERROR(cmd, \"missing arguments\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* Set the precedence for this config_rec based on its configuration\n   * context.\n   */\n  if (ctxt & CONF_GLOBAL) {\n    precedence = 1;\n\n  /* These will never appear simultaneously */\n  } else if ((ctxt & CONF_ROOT) ||\n             (ctxt & CONF_VIRTUAL)) {\n    precedence = 2;\n\n  } else if (ctxt & CONF_ANON) {\n    precedence = 3;\n  }\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  if (timeout == 0) {\n    /* do nothing */\n    return PR_HANDLED(cmd);\n  }\n\n  if (cmd->argc-1 == 3) {\n    if (strncmp(cmd->argv[2], \"user\", 5) == 0 ||\n        strncmp(cmd->argv[2], \"group\", 6) == 0 ||\n        strncmp(cmd->argv[2], \"class\", 6) == 0) {\n\n       /* no op */\n\n     } else {\n       CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],\n         \": unknown classifier used: '\", cmd->argv[2], \"'\", NULL));\n    }\n  }\n\n  if (cmd->argc-1 == 1) {\n    c = add_config_param(cmd->argv[0], 2, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(int));\n    *((int *) c->argv[0]) = timeout;\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = precedence;\n\n  } else if (cmd->argc-1 == 3) {\n    array_header *acl = NULL;\n    int argc = cmd->argc - 3;\n    char **argv = cmd->argv + 2;\n\n    acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n    c = add_config_param(cmd->argv[0], 0);\n    c->argc = argc + 2;\n\n    /* add 3 to argc for the argv of the config_rec: one for the\n     * seconds value, one for the precedence, one for the classifier,\n     * and one for the terminating NULL\n     */\n    c->argv = pcalloc(c->pool, ((argc + 4) * sizeof(char *)));\n\n    /* capture the config_rec's argv pointer for doing the by-hand\n     * population\n     */\n    argv = (char **) c->argv;\n\n    /* Copy in the seconds. */\n    *argv = pcalloc(c->pool, sizeof(int));\n    *((int *) *argv++) = timeout;\n\n    /* Copy in the precedence. */\n    *argv = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) *argv++) = precedence;\n\n    /* Copy in the classifier. */\n    *argv++ = pstrdup(c->pool, cmd->argv[2]);\n\n    /* now, copy in the expression arguments */\n    if (argc && acl) {\n      while (argc--) {\n        *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n        acl->elts = ((char **) acl->elts) + 1;\n      }\n    }\n\n    /* don't forget the terminating NULL */\n    *argv = NULL;\n\n  } else {\n    /* Should never reach here. */\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n  }\n\n  c->flags |= CF_MERGEDOWN_MULTI;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_useftpusers(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: UseLastlog on|off */\nMODRET set_uselastlog(cmd_rec *cmd) {\n#ifdef PR_USE_LASTLOG\n  int bool;\n  config_rec *c;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n#else\n  CONF_ERROR(cmd, \"requires lastlog support (--with-lastlog)\");\n#endif /* PR_USE_LASTLOG */\n}\n\n/* usage: UserAlias alias real-user */\nMODRET set_useralias(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* Make sure that the given names differ. */\n  if (strcmp(cmd->argv[1], cmd->argv[2]) == 0)\n    CONF_ERROR(cmd, \"alias and real user names must differ\");\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n\n  /* Note: only merge this directive down if it is not appearing in an\n   * <Anonymous> context.\n   */\n  if (!check_context(cmd, CONF_ANON)) {\n    c->flags |= CF_MERGEDOWN_MULTI;\n  }\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_userdirroot(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_userpassword(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* Module API tables\n */\n\nstatic conftable auth_conftab[] = {\n  { \"AccessDenyMsg\",\t\tset_accessdenymsg,\t\tNULL },\n  { \"AccessGrantMsg\",\t\tset_accessgrantmsg,\t\tNULL },\n  { \"AllowChrootSymlinks\",\tset_allowchrootsymlinks,\tNULL },\n  { \"AnonRequirePassword\",\tset_anonrequirepassword,\tNULL },\n  { \"AnonRejectPasswords\",\tset_anonrejectpasswords,\tNULL },\n  { \"AuthAliasOnly\",\t\tset_authaliasonly,\t\tNULL },\n  { \"AuthUsingAlias\",\t\tset_authusingalias,\t\tNULL },\n  { \"CreateHome\",\t\tset_createhome,\t\t\tNULL },\n  { \"DefaultChdir\",\t\tadd_defaultchdir,\t\tNULL },\n  { \"DefaultRoot\",\t\tadd_defaultroot,\t\tNULL },\n  { \"DisplayLogin\",\t\tset_displaylogin,\t\tNULL },\n  { \"GroupPassword\",\t\tset_grouppassword,\t\tNULL },\n  { \"LoginPasswordPrompt\",\tset_loginpasswordprompt,\tNULL },\n  { \"MaxClients\",\t\tset_maxclients,\t\t\tNULL },\n  { \"MaxClientsPerClass\",\tset_maxclientsclass,\t\tNULL },\n  { \"MaxClientsPerHost\",\tset_maxhostclients,\t\tNULL },\n  { \"MaxClientsPerUser\",\tset_maxuserclients,\t\tNULL },\n  { \"MaxConnectionsPerHost\",\tset_maxconnectsperhost,\t\tNULL },\n  { \"MaxHostsPerUser\",\t\tset_maxhostsperuser,\t\tNULL },\n  { \"MaxLoginAttempts\",\t\tset_maxloginattempts,\t\tNULL },\n  { \"RequireValidShell\",\tset_requirevalidshell,\t\tNULL },\n  { \"RewriteHome\",\t\tset_rewritehome,\t\tNULL },\n  { \"RootLogin\",\t\tset_rootlogin,\t\t\tNULL },\n  { \"RootRevoke\",\t\tset_rootrevoke,\t\t\tNULL },\n  { \"TimeoutLogin\",\t\tset_timeoutlogin,\t\tNULL },\n  { \"TimeoutSession\",\t\tset_timeoutsession,\t\tNULL },\n  { \"UseFtpUsers\",\t\tset_useftpusers,\t\tNULL },\n  { \"UseLastlog\",\t\tset_uselastlog,\t\t\tNULL },\n  { \"UserAlias\",\t\tset_useralias,\t\t\tNULL },\n  { \"UserDirRoot\",\t\tset_userdirroot,\t\tNULL },\n  { \"UserPassword\",\t\tset_userpassword,\t\tNULL },\n  { NULL,\t\t\tNULL,\t\t\t\tNULL }\n};\n\nstatic cmdtable auth_cmdtab[] = {\n  { PRE_CMD,\tC_USER,\tG_NONE,\tauth_pre_user,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_USER,\tG_NONE,\tauth_user,\tFALSE,\tFALSE,\tCL_AUTH },\n  { PRE_CMD,\tC_PASS,\tG_NONE,\tauth_pre_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_PASS,\tG_NONE,\tauth_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { POST_CMD,\tC_PASS,\tG_NONE,\tauth_post_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { LOG_CMD,\tC_PASS,\tG_NONE,\tauth_log_pass,  FALSE,  FALSE },\n  { LOG_CMD_ERR,C_PASS,\tG_NONE,\tauth_err_pass,  FALSE,  FALSE },\n  { CMD,\tC_ACCT,\tG_NONE,\tauth_acct,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_REIN,\tG_NONE,\tauth_rein,\tFALSE,\tFALSE,\tCL_AUTH },\n  { POST_CMD,\tC_HOST,\tG_NONE,\tauth_post_host,\tFALSE,\tFALSE },\n  { 0, NULL }\n};\n\n/* Module interface */\n\nmodule auth_module = {\n  NULL, NULL,\n\n  /* Module API version */\n  0x20,\n\n  /* Module name */\n  \"auth\",\n\n  /* Module configuration directive table */\n  auth_conftab,\t\n\n  /* Module command handler table */\n  auth_cmdtab,\n\n  /* Module authentication handler table */\n  NULL,\n\n  /* Module initialization function */\n  auth_init,\n\n  /* Session initialization function */\n  auth_sess_init\n};\n\n"], "fixing_code": ["/*\n * ProFTPD - FTP server daemon\n * Copyright (c) 1997, 1998 Public Flood Software\n * Copyright (c) 1999, 2000 MacGyver aka Habeeb J. Dihu <macgyver@tos.net>\n * Copyright (c) 2001-2017 The ProFTPD Project team\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA.\n *\n * As a special exemption, Public Flood Software/MacGyver aka Habeeb J. Dihu\n * and other respective copyright holders give permission to link this program\n * with OpenSSL, and distribute the resulting executable, without including\n * the source code for OpenSSL in the source distribution.\n */\n\n/* Authentication module for ProFTPD */\n\n#include \"conf.h\"\n#include \"privs.h\"\n\nextern pid_t mpid;\n\nmodule auth_module;\n\n#ifdef PR_USE_LASTLOG\nstatic unsigned char lastlog = FALSE;\n#endif /* PR_USE_LASTLOG */\n\nstatic unsigned char mkhome = FALSE;\nstatic unsigned char authenticated_without_pass = FALSE;\nstatic int TimeoutLogin = PR_TUNABLE_TIMEOUTLOGIN;\nstatic int logged_in = 0;\nstatic int auth_tries = 0;\nstatic char *auth_pass_resp_code = R_230;\nstatic pr_fh_t *displaylogin_fh = NULL;\nstatic int TimeoutSession = 0;\n\nstatic int auth_scan_scoreboard(void);\nstatic int auth_count_scoreboard(cmd_rec *, char *);\n\n/* auth_cmd_chk_cb() is hooked into the main server's auth_hook function,\n * so that we can deny all commands until authentication is complete.\n *\n * Note: Once this function returns true (i.e. client has authenticated),\n * it will ALWAYS return true.  At least until REIN is implemented.  Thus\n * we have a flag for such a situation, to save on redundant lookups for\n * the \"authenticated\" record.\n */\nstatic int auth_have_authenticated = FALSE;\n\nstatic int auth_cmd_chk_cb(cmd_rec *cmd) {\n  if (auth_have_authenticated == FALSE) {\n    unsigned char *authd;\n\n    authd = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n\n    if (authd == NULL ||\n        *authd == FALSE) {\n      pr_response_send(R_530, _(\"Please login with USER and PASS\"));\n      return FALSE;\n    }\n\n    auth_have_authenticated = TRUE;\n  }\n\n  return TRUE;\n}\n\nstatic int auth_login_timeout_cb(CALLBACK_FRAME) {\n  pr_response_send_async(R_421,\n    _(\"Login timeout (%d %s): closing control connection\"), TimeoutLogin,\n    TimeoutLogin != 1 ? \"seconds\" : \"second\");\n\n  /* It's possible that any listeners of this event might terminate the\n   * session process themselves (e.g. mod_ban).  So write out that the\n   * TimeoutLogin has been exceeded to the log here, in addition to the\n   * scheduled session exit message.\n   */\n  pr_log_pri(PR_LOG_NOTICE, \"%s\", \"Login timeout exceeded, disconnected\");\n  pr_event_generate(\"core.timeout-login\", NULL);\n\n  pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_TIMEOUT,\n    \"TimeoutLogin\");\n\n  /* Do not restart the timer (should never be reached). */\n  return 0;\n}\n\nstatic int auth_session_timeout_cb(CALLBACK_FRAME) {\n  pr_event_generate(\"core.timeout-session\", NULL);\n  pr_response_send_async(R_421,\n    _(\"Session Timeout (%d seconds): closing control connection\"),\n    TimeoutSession);\n\n  pr_log_pri(PR_LOG_NOTICE, \"%s\", \"FTP session timed out, disconnected\");\n  pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_TIMEOUT,\n    \"TimeoutSession\");\n\n  /* no need to restart the timer -- session's over */\n  return 0;\n}\n\n/* Event listeners\n */\n\nstatic void auth_exit_ev(const void *event_data, void *user_data) {\n  /* Close the scoreboard descriptor that we opened. */\n  (void) pr_close_scoreboard(FALSE);\n}\n\nstatic int auth_sess_init(void) {\n  config_rec *c = NULL;\n  unsigned char *tmp = NULL;\n  int res = 0;\n\n  /* Check for a server-specific TimeoutLogin */\n  c = find_config(main_server->conf, CONF_PARAM, \"TimeoutLogin\", FALSE);\n  if (c != NULL) {\n    TimeoutLogin = *((int *) c->argv[0]);\n  }\n\n  /* Start the login timer */\n  if (TimeoutLogin) {\n    pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n    pr_timer_add(TimeoutLogin, PR_TIMER_LOGIN, &auth_module,\n      auth_login_timeout_cb, \"TimeoutLogin\");\n  }\n\n  PRIVS_ROOT\n  res = pr_open_scoreboard(O_RDWR);\n  PRIVS_RELINQUISH\n\n  if (res < 0) {\n    switch (res) {\n      case PR_SCORE_ERR_BAD_MAGIC:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad/corrupted file\");\n        break;\n\n      case PR_SCORE_ERR_OLDER_VERSION:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad version (too old)\");\n        break;\n\n      case PR_SCORE_ERR_NEWER_VERSION:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: bad version (too new)\");\n        break;\n\n      default:\n        pr_log_debug(DEBUG0, \"error opening scoreboard: %s\", strerror(errno));\n        break;\n    }\n  }\n\n  pr_event_register(&auth_module, \"core.exit\", auth_exit_ev, NULL);\n\n  /* Create an entry in the scoreboard for this session, if we don't already\n   * have one.\n   */\n  if (pr_scoreboard_entry_get(PR_SCORE_CLIENT_ADDR) == NULL) {\n    if (pr_scoreboard_entry_add() < 0) {\n      pr_log_pri(PR_LOG_NOTICE, \"notice: unable to add scoreboard entry: %s\",\n        strerror(errno));\n    }\n\n    pr_scoreboard_entry_update(session.pid,\n      PR_SCORE_USER, \"(none)\",\n      PR_SCORE_SERVER_PORT, main_server->ServerPort,\n      PR_SCORE_SERVER_ADDR, session.c->local_addr, session.c->local_port,\n      PR_SCORE_SERVER_LABEL, main_server->ServerName,\n      PR_SCORE_CLIENT_ADDR, session.c->remote_addr,\n      PR_SCORE_CLIENT_NAME, session.c->remote_name,\n      PR_SCORE_CLASS, session.conn_class ? session.conn_class->cls_name : \"\",\n      PR_SCORE_PROTOCOL, \"ftp\",\n      PR_SCORE_BEGIN_SESSION, time(NULL),\n      NULL);\n\n  } else {\n    /* We're probably handling a HOST comand, and the server changed; just\n     * update the SERVER_LABEL field.\n     */\n    pr_scoreboard_entry_update(session.pid,\n      PR_SCORE_SERVER_LABEL, main_server->ServerName,\n      NULL);\n  }\n\n  /* Should we create the home for a user, if they don't have one? */\n  tmp = get_param_ptr(main_server->conf, \"CreateHome\", FALSE);\n  if (tmp != NULL &&\n      *tmp == TRUE) {\n    mkhome = TRUE;\n\n  } else {\n    mkhome = FALSE;\n  }\n\n#ifdef PR_USE_LASTLOG\n  /* Use the lastlog file, if supported and requested. */\n  tmp = get_param_ptr(main_server->conf, \"UseLastlog\", FALSE);\n  if (tmp &&\n      *tmp == TRUE) {\n    lastlog = TRUE;\n\n  } else {\n    lastlog = FALSE;\n  }\n#endif /* PR_USE_LASTLOG */\n\n  /* Scan the scoreboard now, in order to tally up certain values for\n   * substituting in any of the Display* file variables.  This function\n   * also performs the MaxConnectionsPerHost enforcement.\n   */\n  auth_scan_scoreboard();\n\n  return 0;\n}\n\nstatic int auth_init(void) {\n\n  /* Add the commands handled by this module to the HELP list. */ \n  pr_help_add(C_USER, _(\"<sp> username\"), TRUE);\n  pr_help_add(C_PASS, _(\"<sp> password\"), TRUE);\n  pr_help_add(C_ACCT, _(\"is not implemented\"), FALSE);\n  pr_help_add(C_REIN, _(\"is not implemented\"), FALSE);\n\n  /* By default, enable auth checking */\n  set_auth_check(auth_cmd_chk_cb);\n\n  return 0;\n}\n\nstatic int _do_auth(pool *p, xaset_t *conf, char *u, char *pw) {\n  char *cpw = NULL;\n  config_rec *c;\n\n  if (conf) {\n    c = find_config(conf, CONF_PARAM, \"UserPassword\", FALSE);\n\n    while (c) {\n      if (strcmp(c->argv[0], u) == 0) {\n        cpw = (char *) c->argv[1];\n        break;\n      }\n\n      c = find_config_next(c, c->next, CONF_PARAM, \"UserPassword\", FALSE);\n    }\n  }\n\n  if (cpw) {\n    if (pr_auth_getpwnam(p, u) == NULL) {\n      int xerrno = errno;\n\n      if (xerrno == ENOENT) {\n        pr_log_pri(PR_LOG_NOTICE, \"no such user '%s'\", u);\n      }\n\n      errno = xerrno;\n      return PR_AUTH_NOPWD;\n    }\n\n    return pr_auth_check(p, cpw, u, pw);\n  }\n\n  return pr_auth_authenticate(p, u, pw);\n}\n\n/* Command handlers\n */\n\nMODRET auth_post_host(cmd_rec *cmd) {\n\n  /* If the HOST command changed the main_server pointer, reinitialize\n   * ourselves.\n   */\n  if (session.prev_server != NULL) {\n    int res;\n\n    /* Remove the TimeoutLogin timer. */\n    pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n\n    pr_event_unregister(&auth_module, \"core.exit\", auth_exit_ev);\n\n    /* Reset the CreateHome setting. */\n    mkhome = FALSE;\n\n#ifdef PR_USE_LASTLOG\n    /* Reset the UseLastLog setting. */\n    lastlog = FALSE;\n#endif /* PR_USE_LASTLOG */\n\n    res = auth_sess_init();\n    if (res < 0) {\n      pr_session_disconnect(&auth_module,\n        PR_SESS_DISCONNECT_SESSION_INIT_FAILED, NULL);\n    }\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_err_pass(cmd_rec *cmd) {\n\n  /* Remove the stashed original USER name here in a LOG_CMD_ERR handler, so\n   * that other modules, who may want to lookup the original USER parameter on\n   * a failed login in an earlier command handler phase, have a chance to do\n   * so.  This removal of the USER parameter on failure was happening directly\n   * in the CMD handler previously, thus preventing POST_CMD_ERR handlers from\n   * using USER.\n   */\n  pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_log_pass(cmd_rec *cmd) {\n  size_t passwd_len;\n\n  /* Only log, to the syslog, that the login has succeeded here, where we\n   * know that the login has definitely succeeded.\n   */\n  pr_log_auth(PR_LOG_INFO, \"%s %s: Login successful.\",\n    (session.anon_config != NULL) ? \"ANON\" : C_USER, session.user);\n\n  if (cmd->arg != NULL) {\n    /* And scrub the memory holding the password sent by the client, for\n     * safety/security.\n     */\n    passwd_len = strlen(cmd->arg);\n    pr_memscrub(cmd->arg, passwd_len);\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_post_pass(cmd_rec *cmd) {\n  config_rec *c = NULL;\n  char *grantmsg = NULL, *user;\n  unsigned int ctxt_precedence = 0;\n  unsigned char have_user_timeout, have_group_timeout, have_class_timeout,\n    have_all_timeout, *root_revoke = NULL, *authenticated;\n  struct stat st;\n\n  /* Was there a precending USER command? Was the client successfully\n   * authenticated?\n   */\n  authenticated = get_param_ptr(cmd->server->conf, \"authenticated\", FALSE);\n\n  /* Clear the list of auth-only modules. */\n  pr_auth_clear_auth_only_modules();\n\n  if (authenticated != NULL &&\n      *authenticated == TRUE) {\n\n    /* At this point, we can look up the Protocols config if the client\n     * has been authenticated, which may have been tweaked via mod_ifsession's\n     * user/group/class-specific sections.\n     */\n    c = find_config(main_server->conf, CONF_PARAM, \"Protocols\", FALSE);\n    if (c) {\n      register unsigned int i;\n      array_header *protocols;\n      char **elts;\n      const char *protocol;\n\n      protocols = c->argv[0];\n      elts = protocols->elts;\n\n      protocol = pr_session_get_protocol(PR_SESS_PROTO_FL_LOGOUT);\n\n      /* We only want to check for 'ftp' in the configured Protocols list\n       * if a) a RFC2228 mechanism (e.g. SSL or GSS) is not in use, and\n       *    b) an SSH protocol is not in use.\n       */\n      if (session.rfc2228_mech == NULL &&\n          strncmp(protocol, \"SSH2\", 5) != 0) {\n        int allow_ftp = FALSE;\n\n        for (i = 0; i < protocols->nelts; i++) {\n          char *proto;\n\n          proto = elts[i];\n          if (proto != NULL) {\n            if (strncasecmp(proto, \"ftp\", 4) == 0) {\n              allow_ftp = TRUE;\n              break;\n            }\n          }\n        }\n\n        if (!allow_ftp) {\n          pr_log_debug(DEBUG0, \"%s\", \"ftp protocol denied by Protocols config\");\n          pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n          pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n            \"Denied by Protocols setting\");\n        }\n      }\n    }\n  }\n\n  user = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n\n  /* Count up various quantities in the scoreboard, checking them against\n   * the Max* limits to see if the session should be barred from going\n   * any further.\n   */\n  auth_count_scoreboard(cmd, session.user);\n\n  /* Check for dynamic configuration.  This check needs to be after the\n   * setting of any possible anon_config, as that context may be allowed\n   * or denied .ftpaccess-parsing separately from the containing server.\n   */\n  if (pr_fsio_stat(session.cwd, &st) != -1)\n    build_dyn_config(cmd->tmp_pool, session.cwd, &st, TRUE);\n\n  have_user_timeout = have_group_timeout = have_class_timeout =\n    have_all_timeout = FALSE;\n\n  c = find_config(TOPLEVEL_CONF, CONF_PARAM, \"TimeoutSession\", FALSE);\n  while (c != NULL) {\n    pr_signals_handle();\n\n    if (c->argc == 3) {\n      if (strncmp(c->argv[1], \"user\", 5) == 0) {\n        if (pr_expr_eval_user_or((char **) &c->argv[2]) == TRUE) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_group_timeout = have_class_timeout = have_all_timeout = FALSE;\n            have_user_timeout = TRUE;\n          }\n        }\n\n      } else if (strncmp(c->argv[1], \"group\", 6) == 0) {\n        if (pr_expr_eval_group_and((char **) &c->argv[2]) == TRUE) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_user_timeout = have_class_timeout = have_all_timeout = FALSE;\n            have_group_timeout = TRUE;\n          }\n        }\n\n      } else if (strncmp(c->argv[1], \"class\", 6) == 0) {\n        if (session.conn_class != NULL &&\n            strcmp(session.conn_class->cls_name, c->argv[2]) == 0) {\n\n          if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n            /* Set the context precedence. */\n            ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n            TimeoutSession = *((int *) c->argv[0]);\n\n            have_user_timeout = have_group_timeout = have_all_timeout = FALSE;\n            have_class_timeout = TRUE;\n          }\n        }\n      }\n\n    } else {\n\n      if (*((unsigned int *) c->argv[1]) > ctxt_precedence) {\n\n        /* Set the context precedence. */\n        ctxt_precedence = *((unsigned int *) c->argv[1]);\n\n        TimeoutSession = *((int *) c->argv[0]);\n\n        have_user_timeout = have_group_timeout = have_class_timeout = FALSE;\n        have_all_timeout = TRUE;\n      }\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"TimeoutSession\", FALSE);\n  }\n\n  /* If configured, start a session timer.  The timer ID value for\n   * session timers will not be #defined, as I think that is a bad approach.\n   * A better mechanism would be to use the random timer ID generation, and\n   * store the returned ID in order to later remove the timer.\n   */\n\n  if (have_user_timeout || have_group_timeout ||\n      have_class_timeout || have_all_timeout) {\n    pr_log_debug(DEBUG4, \"setting TimeoutSession of %d seconds for current %s\",\n      TimeoutSession,\n      have_user_timeout ? \"user\" : have_group_timeout ? \"group\" :\n      have_class_timeout ? \"class\" : \"all\");\n    pr_timer_add(TimeoutSession, PR_TIMER_SESSION, &auth_module,\n      auth_session_timeout_cb, \"TimeoutSession\");\n  }\n\n  /* Handle a DisplayLogin file. */\n  if (displaylogin_fh) {\n    if (!(session.sf_flags & SF_ANON)) {\n      if (pr_display_fh(displaylogin_fh, NULL, auth_pass_resp_code, 0) < 0) {\n        pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n          displaylogin_fh->fh_path, strerror(errno));\n      }\n\n      pr_fsio_close(displaylogin_fh);\n      displaylogin_fh = NULL;\n\n    } else {\n      /* We're an <Anonymous> login, but there was a previous DisplayLogin\n       * configured which was picked up earlier.  Close that filehandle,\n       * and look for a new one.\n       */\n      char *displaylogin;\n\n      pr_fsio_close(displaylogin_fh);\n      displaylogin_fh = NULL;\n\n      displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n      if (displaylogin) {\n        if (pr_display_file(displaylogin, NULL, auth_pass_resp_code, 0) < 0) {\n          pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n            displaylogin, strerror(errno));\n        }\n      }\n    }\n\n  } else {\n    char *displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n    if (displaylogin) {\n      if (pr_display_file(displaylogin, NULL, auth_pass_resp_code, 0) < 0) {\n        pr_log_debug(DEBUG6, \"unable to display DisplayLogin file '%s': %s\",\n          displaylogin, strerror(errno));\n      }\n    }\n  }\n\n  grantmsg = get_param_ptr(TOPLEVEL_CONF, \"AccessGrantMsg\", FALSE);\n  if (grantmsg == NULL) {\n    /* Append the final greeting lines. */\n    if (session.sf_flags & SF_ANON) {\n      pr_response_add(auth_pass_resp_code, \"%s\",\n        _(\"Anonymous access granted, restrictions apply\"));\n\n    } else {\n      pr_response_add(auth_pass_resp_code, _(\"User %s logged in\"), user);\n    }\n\n  } else {\n     /* Handle any AccessGrantMsg directive. */\n     grantmsg = sreplace(cmd->tmp_pool, grantmsg, \"%u\", user, NULL);\n     pr_response_add(auth_pass_resp_code, \"%s\", grantmsg);\n  }\n\n  /* A RootRevoke value of 0 indicates 'false', 1 indicates 'true', and\n   * 2 indicates 'NonCompliantActiveTransfer'.  We will drop root privs for any\n   * RootRevoke value greater than 0.\n   */\n  root_revoke = get_param_ptr(TOPLEVEL_CONF, \"RootRevoke\", FALSE);\n  if (root_revoke != NULL &&\n      *root_revoke > 0) {\n    pr_signals_block();\n    PRIVS_ROOT\n    PRIVS_REVOKE\n    pr_signals_unblock();\n\n    /* Disable future attempts at UID/GID manipulation. */\n    session.disable_id_switching = TRUE;\n\n    if (*root_revoke == 1) {\n      /* If the server's listening port is less than 1024, block PORT\n       * commands (effectively allowing only passive connections, which is\n       * not necessarily a Bad Thing).  Only log this here -- the blocking\n       * will need to occur in mod_core's handling of the PORT/EPRT commands.\n       */\n      if (session.c->local_port < 1024) {\n        pr_log_debug(DEBUG0,\n          \"RootRevoke in effect, active data transfers may not succeed\");\n      }\n    }\n\n    pr_log_debug(DEBUG0, \"RootRevoke in effect, dropped root privs\");\n  }\n\n  return PR_DECLINED(cmd);\n}\n\n/* Handle group based authentication, only checked if pw\n * based fails\n */\n\nstatic config_rec *_auth_group(pool *p, char *user, char **group,\n                               char **ournamep, char **anonnamep, char *pass)\n{\n  config_rec *c;\n  char *ourname = NULL,*anonname = NULL;\n  char **grmem;\n  struct group *grp;\n\n  ourname = (char*)get_param_ptr(main_server->conf,\"UserName\",FALSE);\n  if (ournamep && ourname)\n    *ournamep = ourname;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"GroupPassword\", TRUE);\n\n  if (c) do {\n    grp = pr_auth_getgrnam(p, c->argv[0]);\n\n    if (!grp)\n      continue;\n\n    for (grmem = grp->gr_mem; *grmem; grmem++)\n      if (strcmp(*grmem, user) == 0) {\n        if (pr_auth_check(p, c->argv[1], user, pass) == 0)\n          break;\n      }\n\n    if (*grmem) {\n      if (group)\n        *group = c->argv[0];\n\n      if (c->parent)\n        c = c->parent;\n\n      if (c->config_type == CONF_ANON)\n        anonname = (char*)get_param_ptr(c->subset,\"UserName\",FALSE);\n      if (anonnamep)\n        *anonnamep = anonname;\n      if (anonnamep && !anonname && ourname)\n        *anonnamep = ourname;\n\n      break;\n    }\n  } while((c = find_config_next(c,c->next,CONF_PARAM,\"GroupPassword\",TRUE)) != NULL);\n\n  return c;\n}\n\n/* Determine any applicable chdirs\n */\n\nstatic char *get_default_chdir(pool *p, xaset_t *conf) {\n  config_rec *c;\n  char *dir = NULL;\n  int ret;\n\n  c = find_config(conf, CONF_PARAM, \"DefaultChdir\", FALSE);\n\n  while (c) {\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    ret = pr_expr_eval_group_and(((char **) c->argv)+1);\n\n    if (ret) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultChdir\", FALSE);\n  }\n\n  /* If the directory is relative, concatenate w/ session.cwd. */\n  if (dir && *dir != '/' && *dir != '~')\n    dir = pdircat(p, session.cwd, dir, NULL);\n\n  /* Check for any expandable variables. */\n  if (dir)\n    dir = path_subst_uservar(p, &dir);\n\n  return dir;\n}\n\nstatic int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n  int res, xerrno = 0;\n  struct stat st;\n  char *ptr;\n\n  if (pathlen == 0) {\n    return 0;\n  }\n\n  pr_fs_clear_cache();\n  res = pr_fsio_lstat(path, &st);\n  if (res < 0) {\n    xerrno = errno;\n\n    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n      strerror(xerrno));\n\n    errno = xerrno;\n    return -1;\n  }\n\n  if (S_ISLNK(st.st_mode)) {\n    errno = EPERM;\n    return -1;\n  }\n\n  /* To handle the case where a component further up the path might be a\n   * symlink (which lstat(2) will NOT handle), we walk the path backwards,\n   * calling ourselves recursively.\n   */\n\n  ptr = strrchr(path, '/');\n  if (ptr != NULL) {\n    char *new_path;\n    size_t new_pathlen;\n\n    pr_signals_handle();\n\n    new_pathlen = ptr - path;\n\n    /* Make sure our pointer actually changed position. */\n    if (new_pathlen == pathlen) {\n      return 0;\n    }\n\n    new_path = pstrndup(p, path, new_pathlen);\n\n    pr_log_debug(DEBUG10,\n      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n      new_path);\n    res = is_symlink_path(p, new_path, new_pathlen);\n    if (res < 0) {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/* Determine if the user (non-anon) needs a default root dir other than /. */\nstatic int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        res = is_symlink_path(p, path, pathlen);\n        if (res < 0) {\n          if (errno == EPERM) {\n            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n              \"(denied by AllowChrootSymlinks config)\", path);\n          }\n\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}\n\nstatic struct passwd *passwd_dup(pool *p, struct passwd *pw) {\n  struct passwd *npw;\n\n  npw = pcalloc(p, sizeof(struct passwd));\n\n  npw->pw_name = pstrdup(p, pw->pw_name);\n  npw->pw_passwd = pstrdup(p, pw->pw_passwd);\n  npw->pw_uid = pw->pw_uid;\n  npw->pw_gid = pw->pw_gid;\n  npw->pw_gecos = pstrdup(p, pw->pw_gecos);\n  npw->pw_dir = pstrdup(p, pw->pw_dir);\n  npw->pw_shell = pstrdup(p, pw->pw_shell);\n\n  return npw;\n}\n\nstatic void ensure_open_passwd(pool *p) {\n  /* Make sure pass/group is open.\n   */\n  pr_auth_setpwent(p);\n  pr_auth_setgrent(p);\n\n  /* On some unices the following is necessary to ensure the files\n   * are open.  (BSDI 3.1)\n   */\n  pr_auth_getpwent(p);\n  pr_auth_getgrent(p);\n}\n\n/* Next function (the biggie) handles all authentication, setting\n * up chroot() jail, etc.\n */\nstatic int setup_env(pool *p, cmd_rec *cmd, char *user, char *pass) {\n  struct passwd *pw;\n  config_rec *c, *tmpc;\n  char *origuser, *ourname = NULL, *anonname = NULL, *anongroup = NULL, *ugroup = NULL;\n  char *defaulttransfermode, *defroot = NULL,*defchdir = NULL,*xferlog = NULL;\n  const char *sess_ttyname;\n  int aclp, i, res = 0, allow_chroot_symlinks = TRUE, showsymlinks;\n  unsigned char *wtmp_log = NULL, *anon_require_passwd = NULL;\n\n  /********************* Authenticate the user here *********************/\n\n  session.hide_password = TRUE;\n\n  origuser = user;\n  c = pr_auth_get_anon_config(p, &user, &ourname, &anonname);\n\n  if (c)\n    session.anon_config = c;\n\n  if (!user) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s: user is not a UserAlias from %s [%s] \"\n      \"to %s:%i\", origuser, session.c->remote_name,\n      pr_netaddr_get_ipstr(session.c->remote_addr),\n      pr_netaddr_get_ipstr(session.c->local_addr), session.c->local_port);\n    goto auth_failure;\n  }\n\n  pw = pr_auth_getpwnam(p, user);\n  if (pw == NULL &&\n      c != NULL &&\n      ourname != NULL) {\n    /* If the client is authenticating using an alias (e.g. \"AuthAliasOnly on\"),\n     * then we need to try checking using the real username, too (Bug#4255).\n     */\n    pr_trace_msg(\"auth\", 16,\n      \"no user entry found for <Anonymous> alias '%s', using '%s'\", user,\n      ourname);\n    pw = pr_auth_getpwnam(p, ourname);\n  }\n\n  if (pw == NULL) {\n    int auth_code = PR_AUTH_NOPWD;\n\n    pr_log_auth(PR_LOG_NOTICE,\n      \"USER %s: no such user found from %s [%s] to %s:%i\",\n      user, session.c->remote_name,\n      pr_netaddr_get_ipstr(session.c->remote_addr),\n      pr_netaddr_get_ipstr(session.c->local_addr), session.c->local_port);\n    pr_event_generate(\"mod_auth.authentication-code\", &auth_code); \n\n    goto auth_failure;\n  }\n\n  /* Security: other functions perform pw lookups, thus we need to make\n   * a local copy of the user just looked up.\n   */\n  pw = passwd_dup(p, pw);\n\n  if (pw->pw_uid == PR_ROOT_UID) {\n    unsigned char *root_allow = NULL;\n\n    pr_event_generate(\"mod_auth.root-login\", NULL);\n\n    /* If RootLogin is set to true, we allow this... even though we\n     * still log a warning. :)\n     */\n    if ((root_allow = get_param_ptr(c ? c->subset : main_server->conf,\n        \"RootLogin\", FALSE)) == NULL || *root_allow != TRUE) {\n      if (pass) {\n        pr_memscrub(pass, strlen(pass));\n      }\n\n      pr_log_auth(PR_LOG_NOTICE, \"SECURITY VIOLATION: Root login attempted\");\n      return 0;\n    }\n  }\n\n  session.user = pstrdup(p, pw->pw_name);\n  session.group = pstrdup(p, pr_auth_gid2name(p, pw->pw_gid));\n\n  /* Set the login_uid and login_uid */\n  session.login_uid = pw->pw_uid;\n  session.login_gid = pw->pw_gid;\n\n  /* Check for any expandable variables in session.cwd. */\n  pw->pw_dir = path_subst_uservar(p, &pw->pw_dir);\n\n  /* Before we check for supplemental groups, check to see if the locally\n   * resolved name of the user, returned via auth_getpwnam(), is different\n   * from the USER argument sent by the client.  The name can change, since\n   * auth modules can play all sorts of neat tricks on us.\n   *\n   * If the names differ, assume that any cached data in the session.gids\n   * and session.groups lists are stale, and clear them out.\n   */\n  if (strcmp(pw->pw_name, user) != 0) {\n    pr_log_debug(DEBUG10, \"local user name '%s' differs from client-sent \"\n      \"user name '%s', clearing cached group data\", pw->pw_name, user);\n    session.gids = NULL;\n    session.groups = NULL;\n  }\n\n  if (!session.gids &&\n      !session.groups) {\n    /* Get the supplemental groups.  Note that we only look up the\n     * supplemental group credentials if we have not cached the group\n     * credentials before, in session.gids and session.groups.  \n     *\n     * Those credentials may have already been retrieved, as part of the\n     * pr_auth_get_anon_config() call.\n     */\n     res = pr_auth_getgroups(p, pw->pw_name, &session.gids, &session.groups);\n     if (res < 1) {\n       pr_log_debug(DEBUG2, \"no supplemental groups found for user '%s'\",\n         pw->pw_name);\n     }\n  }\n\n  tmpc = find_config(main_server->conf, CONF_PARAM, \"AllowChrootSymlinks\",\n    FALSE);\n  if (tmpc != NULL) {\n    allow_chroot_symlinks = *((int *) tmpc->argv[0]);\n  }\n\n  /* If c != NULL from this point on, we have an anonymous login */\n  aclp = login_check_limits(main_server->conf, FALSE, TRUE, &i);\n\n  if (c) {\n    anongroup = get_param_ptr(c->subset, \"GroupName\", FALSE);\n    if (!anongroup)\n      anongroup = get_param_ptr(main_server->conf, \"GroupName\",FALSE);\n\n    /* Check for configured AnonRejectPasswords regex here, and fail the login\n     * if the given password matches the regex.\n     */\n#ifdef PR_USE_REGEX\n    if ((tmpc = find_config(c->subset, CONF_PARAM, \"AnonRejectPasswords\",\n        FALSE)) != NULL) {\n      int re_res;\n      pr_regex_t *pw_regex = (pr_regex_t *) tmpc->argv[0];\n\n      if (pw_regex && pass &&\n          ((re_res = pr_regexp_exec(pw_regex, pass, 0, NULL, 0, 0, 0)) == 0)) {\n        char errstr[200] = {'\\0'};\n\n        pr_regexp_error(re_res, pw_regex, errstr, sizeof(errstr));\n        pr_log_auth(PR_LOG_NOTICE, \"ANON %s: AnonRejectPasswords denies login\",\n          origuser);\n \n        pr_event_generate(\"mod_auth.anon-reject-passwords\", session.c);\n        goto auth_failure;\n      }\n    }\n#endif\n\n    if (!login_check_limits(c->subset, FALSE, TRUE, &i) || (!aclp && !i) ){\n      pr_log_auth(PR_LOG_NOTICE, \"ANON %s (Login failed): Limit access denies \"\n        \"login\", origuser);\n      goto auth_failure;\n    }\n  }\n\n  if (c == NULL &&\n      aclp == 0) {\n    pr_log_auth(PR_LOG_NOTICE,\n      \"USER %s (Login failed): Limit access denies login\", origuser);\n    goto auth_failure;\n  }\n\n  if (c) {\n    anon_require_passwd = get_param_ptr(c->subset, \"AnonRequirePassword\",\n      FALSE);\n  }\n\n  if (!c ||\n      (anon_require_passwd && *anon_require_passwd == TRUE)) {\n    int auth_code;\n    char *user_name = user;\n\n    if (c &&\n        origuser &&\n        strcasecmp(user, origuser) != 0) {\n      unsigned char *auth_using_alias = get_param_ptr(c->subset,\n        \"AuthUsingAlias\", FALSE);\n\n      /* If 'AuthUsingAlias' set and we're logging in under an alias,\n       * then auth using that alias.\n       */\n      if (auth_using_alias &&\n          *auth_using_alias == TRUE) {\n        user_name = origuser;\n        pr_log_auth(PR_LOG_INFO,\n          \"ANON AUTH: User %s, authenticating using alias %s\", user,\n          user_name);\n      }\n    }\n\n    /* It is possible for the user to have already been authenticated during\n     * the handling of the USER command, as by an RFC2228 mechanism.  If\n     * that had happened, we won't need to call _do_auth() here.\n     */\n    if (!authenticated_without_pass) {\n      auth_code = _do_auth(p, c ? c->subset : main_server->conf, user_name,\n        pass);\n\n    } else {\n      auth_code = PR_AUTH_OK_NO_PASS;\n    }\n\n    pr_event_generate(\"mod_auth.authentication-code\", &auth_code);\n\n    if (auth_code < 0) {\n      /* Normal authentication has failed, see if group authentication\n       * passes\n       */\n\n      c = _auth_group(p, user, &anongroup, &ourname, &anonname, pass);\n      if (c != NULL) {\n        if (c->config_type != CONF_ANON) {\n          c = NULL;\n          ugroup = anongroup;\n          anongroup = NULL;\n        }\n\n        auth_code = PR_AUTH_OK;\n      }\n    }\n\n    if (pass)\n      pr_memscrub(pass, strlen(pass));\n\n    if (session.auth_mech)\n      pr_log_debug(DEBUG2, \"user '%s' authenticated by %s\", user,\n        session.auth_mech);\n\n    switch (auth_code) {\n      case PR_AUTH_OK_NO_PASS:\n        auth_pass_resp_code = R_232;\n        break;\n\n      case PR_AUTH_OK:\n        auth_pass_resp_code = R_230;\n        break;\n\n      case PR_AUTH_NOPWD:\n        pr_log_auth(PR_LOG_NOTICE,\n          \"USER %s (Login failed): No such user found\", user);\n        goto auth_failure;\n\n      case PR_AUTH_BADPWD:\n        pr_log_auth(PR_LOG_NOTICE,\n          \"USER %s (Login failed): Incorrect password\", origuser);\n        goto auth_failure;\n\n      case PR_AUTH_AGEPWD:\n        pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Password expired\",\n          user);\n        goto auth_failure;\n\n      case PR_AUTH_DISABLEDPWD:\n        pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Account disabled\",\n          user);\n        goto auth_failure;\n\n      default:\n        break;\n    };\n\n    /* Catch the case where we forgot to handle a bad auth code above. */\n    if (auth_code < 0)\n      goto auth_failure;\n\n    if (pw->pw_uid == PR_ROOT_UID) {\n      pr_log_auth(PR_LOG_WARNING, \"ROOT FTP login successful\");\n    }\n\n  } else if (c && (!anon_require_passwd || *anon_require_passwd == FALSE)) {\n    session.hide_password = FALSE;\n  }\n\n  pr_auth_setgrent(p);\n\n  res = pr_auth_is_valid_shell(c ? c->subset : main_server->conf,\n    pw->pw_shell);\n  if (res == FALSE) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): Invalid shell: '%s'\",\n      user, pw->pw_shell);\n    goto auth_failure;\n  }\n\n  res = pr_auth_banned_by_ftpusers(c ? c->subset : main_server->conf,\n    pw->pw_name);\n  if (res == TRUE) {\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s (Login failed): User in \"\n      PR_FTPUSERS_PATH, user);\n    goto auth_failure;\n  }\n\n  if (c) {\n    struct group *grp = NULL;\n    unsigned char *add_userdir = NULL;\n    char *u, *chroot_dir;\n\n    u = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n    add_userdir = get_param_ptr(c->subset, \"UserDirRoot\", FALSE);\n\n    /* If resolving an <Anonymous> user, make sure that user's groups\n     * are set properly for the check of the home directory path (which\n     * depend on those supplemental group memberships).  Additionally,\n     * temporarily switch to the new user's uid.\n     */\n\n    pr_signals_block();\n\n    PRIVS_ROOT\n    res = set_groups(p, pw->pw_gid, session.gids);\n    if (res < 0) {\n      pr_log_pri(PR_LOG_WARNING, \"error: unable to set groups: %s\",\n        strerror(errno));\n    }\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n    PRIVS_SETUP(pw->pw_uid, pw->pw_gid)\n\n    if ((add_userdir && *add_userdir == TRUE) &&\n        strcmp(u, user) != 0) {\n      chroot_dir = pdircat(p, c->name, u, NULL);\n\n    } else {\n      chroot_dir = c->name;\n    }\n\n    if (allow_chroot_symlinks == FALSE) {\n      char *chroot_path, target_path[PR_TUNABLE_PATH_MAX+1];\n      struct stat st;\n\n      chroot_path = chroot_dir;\n      if (chroot_path[0] != '/') {\n        if (chroot_path[0] == '~') {\n          if (pr_fs_interpolate(chroot_path, target_path,\n              sizeof(target_path)-1) == 0) {\n            chroot_path = target_path;\n\n          } else {\n            chroot_path = NULL;\n          }\n        }\n      }\n\n      if (chroot_path != NULL) {\n        size_t chroot_pathlen;\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        chroot_pathlen = strlen(chroot_path);\n        if (chroot_pathlen > 1 &&\n            chroot_path[chroot_pathlen-1] == '/') {\n          chroot_path[chroot_pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(chroot_path, &st);\n        if (res < 0) {\n          int xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\",\n            chroot_path, strerror(xerrno));\n\n          errno = xerrno;\n          chroot_path = NULL;\n\n        } else {\n          if (S_ISLNK(st.st_mode)) {\n            pr_log_pri(PR_LOG_WARNING,\n              \"error: <Anonymous %s> is a symlink (denied by \"\n              \"AllowChrootSymlinks config)\", chroot_path);\n            errno = EPERM;\n            chroot_path = NULL;\n          }\n        }\n      }\n\n      if (chroot_path != NULL) {\n        session.chroot_path = dir_realpath(p, chroot_dir);\n\n      } else {\n        session.chroot_path = NULL;\n      }\n\n      if (session.chroot_path == NULL) {\n        pr_log_debug(DEBUG8, \"error resolving '%s': %s\", chroot_dir,\n          strerror(errno));\n      }\n\n    } else {\n      session.chroot_path = dir_realpath(p, chroot_dir);\n      if (session.chroot_path == NULL) {\n        pr_log_debug(DEBUG8, \"error resolving '%s': %s\", chroot_dir,\n          strerror(errno));\n      }\n    }\n\n    if (session.chroot_path &&\n        pr_fsio_access(session.chroot_path, X_OK, session.uid,\n          session.gid, session.gids) != 0) {\n      session.chroot_path = NULL;\n\n    } else {\n      session.chroot_path = pstrdup(session.pool, session.chroot_path);\n    }\n\n    /* Return all privileges back to that of the daemon, for now. */\n    PRIVS_ROOT\n    res = set_groups(p, daemon_gid, daemon_gids);\n    if (res < 0) {\n      pr_log_pri(PR_LOG_ERR, \"error: unable to set groups: %s\",\n        strerror(errno));\n    }\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n    PRIVS_SETUP(daemon_uid, daemon_gid)\n\n    pr_signals_unblock();\n\n    /* Sanity check, make sure we have daemon_uid and daemon_gid back */\n#ifdef HAVE_GETEUID\n    if (getegid() != daemon_gid ||\n        geteuid() != daemon_uid) {\n\n      PRIVS_RELINQUISH\n\n      pr_log_pri(PR_LOG_WARNING,\n        \"switching IDs from user %s back to daemon uid/gid failed: %s\",\n        session.user, strerror(errno));\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_BY_APPLICATION,\n        NULL);\n    }\n#endif /* HAVE_GETEUID */\n\n    if (anon_require_passwd &&\n        *anon_require_passwd == TRUE) {\n      session.anon_user = pstrdup(session.pool, origuser);\n\n    } else {\n      session.anon_user = pstrdup(session.pool, pass);\n    }\n\n    if (!session.chroot_path) {\n      pr_log_pri(PR_LOG_NOTICE, \"%s: Directory %s is not accessible\",\n        session.user, c->name);\n      pr_response_add_err(R_530, _(\"Unable to set anonymous privileges.\"));\n      goto auth_failure;\n    }\n\n    sstrncpy(session.cwd, \"/\", sizeof(session.cwd));\n    xferlog = get_param_ptr(c->subset, \"TransferLog\", FALSE);\n\n    if (anongroup) {\n      grp = pr_auth_getgrnam(p, anongroup);\n      if (grp) {\n        pw->pw_gid = grp->gr_gid;\n        session.group = pstrdup(p, grp->gr_name);\n      }\n    }\n\n  } else {\n    struct group *grp;\n    char *homedir;\n\n    if (ugroup) {\n      grp = pr_auth_getgrnam(p, ugroup);\n      if (grp) {\n        pw->pw_gid = grp->gr_gid;\n        session.group = pstrdup(p, grp->gr_name);\n      }\n    }\n\n    /* Attempt to resolve any possible symlinks. */\n    PRIVS_USER\n    homedir = dir_realpath(p, pw->pw_dir);\n    PRIVS_RELINQUISH\n\n    if (homedir)\n      sstrncpy(session.cwd, homedir, sizeof(session.cwd));\n    else\n      sstrncpy(session.cwd, pw->pw_dir, sizeof(session.cwd));\n  }\n\n  /* Create the home directory, if need be. */\n\n  if (!c && mkhome) {\n    if (create_home(p, session.cwd, origuser, pw->pw_uid, pw->pw_gid) < 0) {\n\n      /* NOTE: should this cause the login to fail? */\n      goto auth_failure;\n    }\n  }\n\n  /* Get default chdir (if any) */\n  defchdir = get_default_chdir(p, (c ? c->subset : main_server->conf));\n\n  if (defchdir)\n    sstrncpy(session.cwd, defchdir, sizeof(session.cwd));\n\n  /* Check limits again to make sure deny/allow directives still permit\n   * access.\n   */\n\n  if (!login_check_limits((c ? c->subset : main_server->conf), FALSE, TRUE,\n      &i)) {\n    pr_log_auth(PR_LOG_NOTICE, \"%s %s: Limit access denies login\",\n      (c != NULL) ? \"ANON\" : C_USER, origuser);\n    goto auth_failure;\n  }\n\n  /* Perform a directory fixup. */\n  resolve_deferred_dirs(main_server);\n  fixup_dirs(main_server, CF_DEFER);\n\n  /* If running under an anonymous context, resolve all <Directory>\n   * blocks inside it.\n   */\n  if (c && c->subset)\n    resolve_anonymous_dirs(c->subset);\n\n  /* Write the login to wtmp.  This must be done here because we won't\n   * have access after we give up root.  This can result in falsified\n   * wtmp entries if an error kicks the user out before we get\n   * through with the login process.  Oh well.\n   */\n\n  sess_ttyname = pr_session_get_ttyname(p);\n\n  /* Perform wtmp logging only if not turned off in <Anonymous>\n   * or the current server\n   */\n  if (c)\n    wtmp_log = get_param_ptr(c->subset, \"WtmpLog\", FALSE);\n\n  if (wtmp_log == NULL)\n    wtmp_log = get_param_ptr(main_server->conf, \"WtmpLog\", FALSE);\n\n  /* As per Bug#3482, we need to disable WtmpLog for FreeBSD 9.0, as\n   * an interim measure.\n   *\n   * The issue is that some platforms update multiple files for a single\n   * pututxline(3) call; proftpd tries to update those files manually,\n   * do to chroots (after which a pututxline(3) call will fail).  A proper\n   * solution requires a separate process, running with the correct\n   * privileges, which would handle wtmp logging. The proftpd session\n   * processes would send messages to this logging daemon (via Unix domain\n   * socket, or FIFO, or TCP socket).\n   *\n   * Also note that this hack to disable WtmpLog may need to be extended\n   * to other platforms in the future.\n   */\n#if defined(HAVE_UTMPX_H) && \\\n    defined(__FreeBSD_version) && __FreeBSD_version >= 900007\n  if (wtmp_log == NULL ||\n      *wtmp_log == TRUE) {\n    wtmp_log = pcalloc(p, sizeof(unsigned char));\n    *wtmp_log = FALSE;\n\n    pr_log_debug(DEBUG5,\n      \"WtpmLog automatically disabled; see Bug#3482 for details\");\n  }\n#endif\n\n  PRIVS_ROOT\n\n  if (wtmp_log == NULL ||\n      *wtmp_log == TRUE) {\n    log_wtmp(sess_ttyname, session.user, session.c->remote_name,\n      session.c->remote_addr);\n    session.wtmp_log = TRUE;\n  }\n\n#ifdef PR_USE_LASTLOG\n  if (lastlog) {\n    log_lastlog(pw->pw_uid, session.user, sess_ttyname, session.c->remote_addr);\n  }\n#endif /* PR_USE_LASTLOG */\n\n  /* Open any TransferLogs */\n  if (!xferlog) {\n    if (c)\n      xferlog = get_param_ptr(c->subset, \"TransferLog\", FALSE);\n\n    if (!xferlog)\n      xferlog = get_param_ptr(main_server->conf, \"TransferLog\", FALSE);\n\n    if (!xferlog)\n      xferlog = PR_XFERLOG_PATH;\n  }\n\n  if (strcasecmp(xferlog, \"NONE\") == 0) {\n    xferlog_open(NULL);\n\n  } else {\n    xferlog_open(xferlog);\n  }\n\n  res = set_groups(p, pw->pw_gid, session.gids);\n  if (res < 0) {\n    pr_log_pri(PR_LOG_ERR, \"error: unable to set groups: %s\",\n      strerror(errno));\n  }\n\n  PRIVS_RELINQUISH\n\n  /* Now check to see if the user has an applicable DefaultRoot */\n  if (c == NULL) {\n    if (get_default_root(session.pool, allow_chroot_symlinks, &defroot) < 0) {\n      pr_log_pri(PR_LOG_NOTICE,\n        \"error: unable to determine DefaultRoot directory\");\n      pr_response_send(R_530, _(\"Login incorrect.\"));\n      pr_session_end(0);\n    }\n\n    ensure_open_passwd(p);\n\n    if (defroot != NULL) {\n      if (pr_auth_chroot(defroot) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"error: unable to set DefaultRoot directory\");\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n      /* Re-calc the new cwd based on this root dir.  If not applicable\n       * place the user in / (of defroot)\n       */\n\n      if (strncmp(session.cwd, defroot, strlen(defroot)) == 0) {\n        char *newcwd = &session.cwd[strlen(defroot)];\n\n        if (*newcwd == '/')\n          newcwd++;\n        session.cwd[0] = '/';\n        sstrncpy(&session.cwd[1], newcwd, sizeof(session.cwd));\n      }\n    }\n  }\n\n  if (c)\n    ensure_open_passwd(p);\n\n  if (c &&\n      pr_auth_chroot(session.chroot_path) == -1) {\n    pr_log_pri(PR_LOG_NOTICE, \"error: unable to set anonymous privileges\");\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n\n  /* new in 1.1.x, I gave in and we don't give up root permanently..\n   * sigh.\n   */\n\n  PRIVS_ROOT\n\n#ifndef PR_DEVEL_COREDUMP\n# ifdef __hpux\n    if (setresuid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresuid(): %s\", strerror(errno));\n    }\n\n    if (setresgid(0, 0, 0) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setresgid(): %s\", strerror(errno));\n    }\n# else\n    if (setuid(PR_ROOT_UID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setuid(): %s\", strerror(errno));\n    }\n\n    if (setgid(PR_ROOT_GID) < 0) {\n      pr_log_pri(PR_LOG_ERR, \"unable to setgid(): %s\", strerror(errno));\n    }\n# endif /* __hpux */\n#endif /* PR_DEVEL_COREDUMP */\n\n  PRIVS_SETUP(pw->pw_uid, pw->pw_gid)\n\n#ifdef HAVE_GETEUID\n  if (getegid() != pw->pw_gid ||\n     geteuid() != pw->pw_uid) {\n\n    PRIVS_RELINQUISH\n    pr_log_pri(PR_LOG_ERR, \"error: %s setregid() or setreuid(): %s\",\n      session.user, strerror(errno));\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n#endif\n\n  /* If the home directory is NULL or \"\", reject the login. */\n  if (pw->pw_dir == NULL ||\n      strncmp(pw->pw_dir, \"\", 1) == 0) {\n    pr_log_pri(PR_LOG_WARNING, \"error: user %s home directory is NULL or \\\"\\\"\",\n      session.user);\n    pr_response_send(R_530, _(\"Login incorrect.\"));\n    pr_session_end(0);\n  }\n\n  {\n    unsigned char *show_symlinks = get_param_ptr(\n      c ? c->subset : main_server->conf, \"ShowSymlinks\", FALSE);\n\n    if (!show_symlinks || *show_symlinks == TRUE)\n      showsymlinks = TRUE;\n    else\n      showsymlinks = FALSE;\n  }\n\n  /* chdir to the proper directory, do this even if anonymous\n   * to make sure we aren't outside our chrooted space.\n   */\n\n  /* Attempt to change to the correct directory -- use session.cwd first.\n   * This will contain the DefaultChdir directory, if configured...\n   */\n  if (pr_fsio_chdir_canon(session.cwd, !showsymlinks) == -1) {\n\n    /* if we've got DefaultRoot or anonymous login, ignore this error\n     * and chdir to /\n     */\n\n    if (session.chroot_path != NULL || defroot) {\n\n      pr_log_debug(DEBUG2, \"unable to chdir to %s (%s), defaulting to chroot \"\n        \"directory %s\", session.cwd, strerror(errno),\n        (session.chroot_path ? session.chroot_path : defroot));\n\n      if (pr_fsio_chdir_canon(\"/\", !showsymlinks) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"/\\\") failed: %s\", session.user,\n          strerror(errno));\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n    } else if (defchdir) {\n\n      /* If we've got defchdir, failure is ok as well, simply switch to\n       * user's homedir.\n       */\n      pr_log_debug(DEBUG2, \"unable to chdir to %s (%s), defaulting to home \"\n        \"directory %s\", session.cwd, strerror(errno), pw->pw_dir);\n\n      if (pr_fsio_chdir_canon(pw->pw_dir, !showsymlinks) == -1) {\n        pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"%s\\\") failed: %s\", session.user,\n          session.cwd, strerror(errno));\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n        pr_session_end(0);\n      }\n\n    } else {\n\n      /* Unable to switch to user's real home directory, which is not\n       * allowed.\n       */\n      pr_log_pri(PR_LOG_NOTICE, \"%s chdir(\\\"%s\\\") failed: %s\", session.user,\n        session.cwd, strerror(errno));\n      pr_response_send(R_530, _(\"Login incorrect.\"));\n      pr_session_end(0);\n    }\n  }\n\n  sstrncpy(session.cwd, pr_fs_getcwd(), sizeof(session.cwd));\n  sstrncpy(session.vwd, pr_fs_getvwd(), sizeof(session.vwd));\n\n  /* Make sure directory config pointers are set correctly */\n  dir_check_full(p, cmd, G_NONE, session.cwd, NULL);\n\n  if (c) {\n    if (!session.hide_password) {\n      session.proc_prefix = pstrcat(session.pool, session.c->remote_name,\n        \": anonymous/\", pass, NULL);\n\n    } else {\n      session.proc_prefix = pstrcat(session.pool, session.c->remote_name,\n        \": anonymous\", NULL);\n    }\n\n    session.sf_flags = SF_ANON;\n\n  } else {\n    session.proc_prefix = pstrdup(session.pool, session.c->remote_name);\n    session.sf_flags = 0;\n  }\n\n  /* While closing the pointer to the password database would avoid any\n   * potential attempt to hijack this information, it is unfortunately needed\n   * in a chroot()ed environment.  Otherwise, mappings from UIDs to names,\n   * among other things, would fail.\n   */\n  /* pr_auth_endpwent(p); */\n\n  /* Default transfer mode is ASCII */\n  defaulttransfermode = (char *) get_param_ptr(main_server->conf,\n    \"DefaultTransferMode\", FALSE);\n\n  if (defaulttransfermode &&\n      strcasecmp(defaulttransfermode, \"binary\") == 0) {\n    session.sf_flags &= (SF_ALL^SF_ASCII);\n\n  } else {\n    session.sf_flags |= SF_ASCII;\n  }\n\n  /* Authentication complete, user logged in, now kill the login\n   * timer.\n   */\n\n  /* Update the scoreboard entry */\n  pr_scoreboard_entry_update(session.pid,\n    PR_SCORE_USER, session.user,\n    PR_SCORE_CWD, session.cwd,\n    NULL);\n\n  pr_session_set_idle();\n\n  pr_timer_remove(PR_TIMER_LOGIN, &auth_module);\n\n  /* These copies are made from the session.pool, instead of the more\n   * volatile pool used originally, in order that the copied data maintain\n   * its integrity for the lifetime of the session.\n   */\n  session.user = pstrdup(session.pool, session.user);\n\n  if (session.group)\n    session.group = pstrdup(session.pool, session.group);\n\n  if (session.gids)\n    session.gids = copy_array(session.pool, session.gids);\n\n  /* session.groups is an array of strings, so we must copy the string data\n   * as well as the pointers.\n   */\n  session.groups = copy_array_str(session.pool, session.groups);\n\n  /* Resolve any deferred-resolution paths in the FS layer */\n  pr_resolve_fs_map();\n\n  return 1;\n\nauth_failure:\n  if (pass)\n    pr_memscrub(pass, strlen(pass));\n  session.user = session.group = NULL;\n  session.gids = session.groups = NULL;\n  session.wtmp_log = FALSE;\n  return 0;\n}\n\n/* This function counts the number of connected users. It only fills in the\n * Class-based counters and an estimate for the number of clients. The primary\n * purpose is to make it so that the %N/%y escapes work in a DisplayConnect\n * greeting.  A secondary purpose is to enforce any configured\n * MaxConnectionsPerHost limit.\n */\nstatic int auth_scan_scoreboard(void) {\n  char *key;\n  void *v;\n  config_rec *c = NULL;\n  pr_scoreboard_entry_t *score = NULL;\n  unsigned int cur = 0, ccur = 0, hcur = 0;\n  char curr_server_addr[80] = {'\\0'};\n  const char *client_addr = pr_netaddr_get_ipstr(session.c->remote_addr);\n\n  snprintf(curr_server_addr, sizeof(curr_server_addr), \"%s:%d\",\n    pr_netaddr_get_ipstr(session.c->local_addr), main_server->ServerPort);\n  curr_server_addr[sizeof(curr_server_addr)-1] = '\\0';\n\n  /* Determine how many users are currently connected */\n  if (pr_rewind_scoreboard() < 0) {\n    pr_log_pri(PR_LOG_NOTICE, \"error rewinding scoreboard: %s\",\n      strerror(errno));\n  }\n\n  while ((score = pr_scoreboard_entry_read()) != NULL) {\n    pr_signals_handle();\n\n    /* Make sure it matches our current server */\n    if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {\n      cur++;\n\n      if (strcmp(score->sce_client_addr, client_addr) == 0)\n        hcur++;\n\n      /* Only count up authenticated clients, as per the documentation. */\n      if (strncmp(score->sce_user, \"(none)\", 7) == 0)\n        continue;\n\n      /* Note: the class member of the scoreboard entry will never be\n       * NULL.  At most, it may be the empty string.\n       */\n      if (session.conn_class != NULL &&\n          strcasecmp(score->sce_class, session.conn_class->cls_name) == 0) {\n        ccur++;\n      }\n    }\n  }\n  pr_restore_scoreboard();\n\n  key = \"client-count\";\n  (void) pr_table_remove(session.notes, key, NULL);\n  v = palloc(session.pool, sizeof(unsigned int));\n  *((unsigned int *) v) = cur;\n\n  if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n    if (errno != EEXIST) {\n      pr_log_pri(PR_LOG_WARNING,\n        \"warning: error stashing '%s': %s\", key, strerror(errno));\n    }\n  }\n\n  if (session.conn_class != NULL) {\n    key = \"class-client-count\";\n    (void) pr_table_remove(session.notes, key, NULL);\n    v = palloc(session.pool, sizeof(unsigned int));\n    *((unsigned int *) v) = ccur;\n\n    if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n      if (errno != EEXIST) {\n        pr_log_pri(PR_LOG_WARNING,\n          \"warning: error stashing '%s': %s\", key, strerror(errno));\n      }\n    }\n  }\n\n  /* Lookup any configured MaxConnectionsPerHost. */\n  c = find_config(main_server->conf, CONF_PARAM, \"MaxConnectionsPerHost\",\n    FALSE);\n\n  if (c) {\n    unsigned int *max = c->argv[0];\n\n    if (*max &&\n        hcur > *max) {\n\n      char maxstr[20];\n      char *msg = \"Sorry, the maximum number of connections (%m) for your host \"\n        \"are already connected.\";\n\n      pr_event_generate(\"mod_auth.max-connections-per-host\", session.c);\n\n      if (c->argc == 2)\n        msg = c->argv[1];\n\n      memset(maxstr, '\\0', sizeof(maxstr));\n      snprintf(maxstr, sizeof(maxstr), \"%u\", *max);\n      maxstr[sizeof(maxstr)-1] = '\\0';\n\n      pr_response_send(R_530, \"%s\", sreplace(session.pool, msg,\n        \"%m\", maxstr, NULL));\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxConnectionsPerHost %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxConnectionsPerHost\");\n    }\n  }\n\n  return 0;\n}\n\nstatic int have_client_limits(cmd_rec *cmd) {\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerClass\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerHost\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerUser\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClients\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  if (find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxHostsPerUser\", FALSE) != NULL) {\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\nstatic int auth_count_scoreboard(cmd_rec *cmd, char *user) {\n  char *key;\n  void *v;\n  pr_scoreboard_entry_t *score = NULL;\n  long cur = 0, hcur = 0, ccur = 0, hostsperuser = 1, usersessions = 0;\n  config_rec *c = NULL, *maxc = NULL;\n\n  /* First, check to see which Max* directives are configured.  If none\n   * are configured, then there is no need for us to needlessly scan the\n   * ScoreboardFile.\n   */\n  if (have_client_limits(cmd) == FALSE) {\n    return 0;\n  }\n\n  /* Determine how many users are currently connected. */\n\n  /* We use this call to get the possibly-changed user name. */\n  (void) pr_auth_get_anon_config(cmd->tmp_pool, &user, NULL, NULL);\n\n  /* Gather our statistics. */\n  if (user) {\n    char curr_server_addr[80] = {'\\0'};\n\n    snprintf(curr_server_addr, sizeof(curr_server_addr), \"%s:%d\",\n      pr_netaddr_get_ipstr(session.c->local_addr), main_server->ServerPort);\n    curr_server_addr[sizeof(curr_server_addr)-1] = '\\0';\n\n    if (pr_rewind_scoreboard() < 0) {\n      pr_log_pri(PR_LOG_NOTICE, \"error rewinding scoreboard: %s\",\n        strerror(errno));\n    }\n\n    while ((score = pr_scoreboard_entry_read()) != NULL) {\n      unsigned char same_host = FALSE;\n\n      pr_signals_handle();\n\n      /* Make sure it matches our current server. */\n      if (strcmp(score->sce_server_addr, curr_server_addr) == 0) {\n\n        if ((c && c->config_type == CONF_ANON &&\n            !strcmp(score->sce_user, user)) || !c) {\n\n          /* This small hack makes sure that cur is incremented properly\n           * when dealing with anonymous logins (the timing of anonymous\n           * login updates to the scoreboard makes this...odd).\n           */\n          if (c && c->config_type == CONF_ANON && cur == 0)\n              cur = 1;\n\n          /* Only count authenticated clients, as per the documentation. */\n          if (strncmp(score->sce_user, \"(none)\", 7) == 0)\n            continue;\n\n          cur++;\n\n          /* Count up sessions on a per-host basis. */\n\n          if (!strcmp(score->sce_client_addr,\n              pr_netaddr_get_ipstr(session.c->remote_addr))) {\n            same_host = TRUE;\n\n            /* This small hack makes sure that hcur is incremented properly\n             * when dealing with anonymous logins (the timing of anonymous\n             * login updates to the scoreboard makes this...odd).\n             */\n            if (c && c->config_type == CONF_ANON && hcur == 0)\n              hcur = 1;\n\n            hcur++;\n          }\n\n          /* Take a per-user count of connections. */\n          if (strcmp(score->sce_user, user) == 0) {\n            usersessions++;\n\n            /* Count up unique hosts. */\n            if (!same_host)\n              hostsperuser++;\n          }\n        }\n\n        if (session.conn_class != NULL &&\n            strcasecmp(score->sce_class, session.conn_class->cls_name) == 0) {\n          ccur++;\n        }\n      }\n    }\n    pr_restore_scoreboard();\n    PRIVS_RELINQUISH\n  }\n\n  key = \"client-count\";\n  (void) pr_table_remove(session.notes, key, NULL);\n  v = palloc(session.pool, sizeof(unsigned int));\n  *((unsigned int *) v) = cur;\n\n  if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n    if (errno != EEXIST) {\n      pr_log_pri(PR_LOG_WARNING,\n        \"warning: error stashing '%s': %s\", key, strerror(errno));\n    }\n  }\n\n  if (session.conn_class != NULL) {\n    key = \"class-client-count\";\n    (void) pr_table_remove(session.notes, key, NULL);\n    v = palloc(session.pool, sizeof(unsigned int));\n    *((unsigned int *) v) = ccur;\n\n    if (pr_table_add(session.notes, key, v, sizeof(unsigned int)) < 0) {\n      if (errno != EEXIST) {\n        pr_log_pri(PR_LOG_WARNING,\n          \"warning: error stashing '%s': %s\", key, strerror(errno));\n      }\n    }\n  }\n\n  /* Try to determine what MaxClients/MaxHosts limits apply to this session\n   * (if any) and count through the runtime file to see if this limit would\n   * be exceeded.\n   */\n\n  maxc = find_config(cmd->server->conf, CONF_PARAM, \"MaxClientsPerClass\",\n    FALSE);\n  while (session.conn_class != NULL && maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your class \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[1];\n\n    if (strcmp(maxc->argv[0], session.conn_class->cls_name) != 0) {\n      maxc = find_config_next(maxc, maxc->next, CONF_PARAM,\n        \"MaxClientsPerClass\", FALSE);\n      continue;\n    }\n\n    if (maxc->argc > 2)\n      maxstr = maxc->argv[2];\n\n    if (*max &&\n        ccur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-class\",\n        session.conn_class->cls_name);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerClass %s %u)\",\n        session.conn_class->cls_name, *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerClass\");\n    }\n\n    break;\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerHost\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) from your host \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hcur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-host\", session.c);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerHost %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerHost\");\n    }\n  }\n\n  /* Check for any configured MaxClientsPerUser. */\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClientsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of clients (%m) for this user \"\n      \"are already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && usersessions > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Connection refused (MaxClientsPerUser %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClientsPerUser\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxClients\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of allowed clients (%m) are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && cur > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-clients\", NULL);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxClients %u)\", *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxClients\");\n    }\n  }\n\n  maxc = find_config(TOPLEVEL_CONF, CONF_PARAM, \"MaxHostsPerUser\", FALSE);\n  if (maxc) {\n    char *maxstr = \"Sorry, the maximum number of hosts (%m) for this user are \"\n      \"already connected.\";\n    unsigned int *max = maxc->argv[0];\n\n    if (maxc->argc > 1)\n      maxstr = maxc->argv[1];\n\n    if (*max && hostsperuser > *max) {\n      char maxn[20] = {'\\0'};\n\n      pr_event_generate(\"mod_auth.max-hosts-per-user\", user);\n\n      snprintf(maxn, sizeof(maxn), \"%u\", *max);\n      pr_response_send(R_530, \"%s\", sreplace(cmd->tmp_pool, maxstr, \"%m\", maxn,\n        NULL));\n      (void) pr_cmd_dispatch_phase(cmd, LOG_CMD_ERR, 0);\n\n      pr_log_auth(PR_LOG_NOTICE, \"Connection refused (MaxHostsPerHost %u)\",\n        *max);\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxHostsPerUser\");\n    }\n  }\n\n  return 0;\n}\n\nMODRET auth_pre_user(cmd_rec *cmd) {\n\n  if (logged_in)\n    return PR_DECLINED(cmd);\n\n  /* Close the passwd and group databases, because libc won't let us see new\n   * entries to these files without this (only in PersistentPasswd mode).\n   */\n  pr_auth_endpwent(cmd->tmp_pool);\n  pr_auth_endgrent(cmd->tmp_pool);\n\n  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */\n  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {\n    pr_log_pri(PR_LOG_NOTICE, \"USER %s (Login failed): \"\n      \"maximum USER length exceeded\", cmd->arg);\n    pr_response_add_err(R_501, _(\"Login incorrect.\"));\n    return PR_ERROR(cmd);\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_user(cmd_rec *cmd) {\n  int nopass = FALSE;\n  config_rec *c;\n  char *denymsg = NULL, *user, *origuser;\n  int failnopwprompt = 0, aclp, i;\n  unsigned char *anon_require_passwd = NULL, *login_passwd_prompt = NULL;\n\n  if (cmd->argc < 2) {\n    return PR_ERROR_MSG(cmd, R_500, _(\"USER: command requires a parameter\"));\n  }\n\n  if (logged_in) {\n    /* If the client has already authenticated, BUT the given USER command\n     * here is for the exact same user name, then allow the command to\n     * succeed (Bug#4217).\n     */\n    origuser = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n    if (origuser != NULL &&\n        strcmp(origuser, cmd->arg) == 0) {\n      pr_response_add(R_230, _(\"User %s logged in\"), origuser);\n      return PR_HANDLED(cmd);\n    }\n\n    pr_response_add_err(R_501, \"%s\", _(\"Reauthentication not supported\"));\n    return PR_ERROR(cmd);\n  }\n\n  user = cmd->arg;\n\n  (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n  (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n  if (pr_table_add_dup(session.notes, \"mod_auth.orig-user\", user, 0) < 0) {\n    pr_log_debug(DEBUG3, \"error stashing 'mod_auth.orig-user' in \"\n      \"session.notes: %s\", strerror(errno));\n  }\n\n  origuser = user;\n  c = pr_auth_get_anon_config(cmd->tmp_pool, &user, NULL, NULL);\n\n  /* Check for AccessDenyMsg */\n  denymsg = get_param_ptr((c ? c->subset : cmd->server->conf), \"AccessDenyMsg\",\n    FALSE);\n  if (denymsg != NULL) {\n    if (strstr(denymsg, \"%u\") != NULL) {\n      denymsg = sreplace(cmd->tmp_pool, denymsg, \"%u\", user, NULL);\n    }\n  }\n\n  login_passwd_prompt = get_param_ptr(\n    (c && c->config_type == CONF_ANON) ? c->subset : main_server->conf,\n    \"LoginPasswordPrompt\", FALSE);\n\n  if (login_passwd_prompt &&\n      *login_passwd_prompt == FALSE) {\n    failnopwprompt = TRUE;\n\n  } else {\n    failnopwprompt = FALSE;\n  }\n\n  if (failnopwprompt) {\n    if (!user) {\n      (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n      (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n      pr_log_pri(PR_LOG_NOTICE, \"USER %s (Login failed): Not a UserAlias\",\n        origuser);\n\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, _(\"Login incorrect.\"));\n      }\n\n      pr_session_end(0);\n    }\n\n    aclp = login_check_limits(main_server->conf, FALSE, TRUE, &i);\n\n    if (c && c->config_type != CONF_ANON) {\n      c = (config_rec *) pcalloc(session.pool, sizeof(config_rec));\n      c->config_type = CONF_ANON;\n      c->name = \"\";\t/* don't really need this yet */\n      c->subset = main_server->conf;\n    }\n\n    if (c) {\n      if (!login_check_limits(c->subset, FALSE, TRUE, &i) ||\n          (!aclp && !i) ) {\n        (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n        (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n        pr_log_auth(PR_LOG_NOTICE, \"ANON %s: Limit access denies login\",\n          origuser);\n\n        if (denymsg) {\n          pr_response_send(R_530, \"%s\", denymsg);\n\n        } else {\n          pr_response_send(R_530, _(\"Login incorrect.\"));\n        }\n\n        pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n          \"Denied by <Limit LOGIN>\");\n      }\n    }\n\n    if (c == NULL &&\n        aclp == 0) {\n      (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n      (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"USER %s: Limit access denies login\", origuser);\n\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n      }\n\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by <Limit LOGIN>\");\n    }\n  }\n\n  if (c)\n    anon_require_passwd = get_param_ptr(c->subset, \"AnonRequirePassword\",\n      FALSE);\n\n  if (c && user && (!anon_require_passwd || *anon_require_passwd == FALSE))\n    nopass = TRUE;\n\n  session.gids = NULL;\n  session.groups = NULL;\n  session.user = NULL;\n  session.group = NULL;\n\n  if (nopass) {\n    pr_response_add(R_331, _(\"Anonymous login ok, send your complete email \"\n      \"address as your password\"));\n\n  } else if (pr_auth_requires_pass(cmd->tmp_pool, user) == FALSE) {\n    /* Check to see if a password from the client is required.  In the\n     * vast majority of cases, a password will be required.\n     */\n\n    /* Act as if we received a PASS command from the client. */\n    cmd_rec *fakecmd = pr_cmd_alloc(cmd->pool, 2, NULL);\n\n    /* We use pstrdup() here, rather than assigning C_PASS directly, since\n     * code elsewhere will attempt to modify this buffer, and C_PASS is\n     * a string literal.\n     */\n    fakecmd->argv[0] = pstrdup(fakecmd->pool, C_PASS);\n    fakecmd->argv[1] = NULL;\n    fakecmd->arg = NULL;\n\n    c = add_config_param_set(&cmd->server->conf, \"authenticated\", 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = TRUE;\n\n    authenticated_without_pass = TRUE;\n    pr_log_auth(PR_LOG_NOTICE, \"USER %s: Authenticated without password\", user);\n\n    pr_cmd_dispatch(fakecmd);\n\n  } else {\n    pr_response_add(R_331, _(\"Password required for %s\"), cmd->argv[1]);\n  }\n\n  return PR_HANDLED(cmd);\n}\n\n/* Close the passwd and group databases, similar to auth_pre_user(). */\nMODRET auth_pre_pass(cmd_rec *cmd) {\n  char *displaylogin;\n\n  pr_auth_endpwent(cmd->tmp_pool);\n  pr_auth_endgrent(cmd->tmp_pool);\n\n  /* Look for a DisplayLogin file which has an absolute path.  If we find one,\n   * open a filehandle, such that that file can be displayed even if the\n   * session is chrooted.  DisplayLogin files with relative paths will be\n   * handled after chroot, preserving the old behavior.\n   */\n\n  displaylogin = get_param_ptr(TOPLEVEL_CONF, \"DisplayLogin\", FALSE);\n  if (displaylogin &&\n      *displaylogin == '/') {\n    struct stat st;\n\n    displaylogin_fh = pr_fsio_open(displaylogin, O_RDONLY);\n    if (displaylogin_fh == NULL) {\n      pr_log_debug(DEBUG6, \"unable to open DisplayLogin file '%s': %s\",\n        displaylogin, strerror(errno));\n\n    } else {\n      if (pr_fsio_fstat(displaylogin_fh, &st) < 0) {\n        pr_log_debug(DEBUG6, \"unable to stat DisplayLogin file '%s': %s\",\n          displaylogin, strerror(errno));\n        pr_fsio_close(displaylogin_fh);\n        displaylogin_fh = NULL;\n\n      } else {\n        if (S_ISDIR(st.st_mode)) {\n          errno = EISDIR;\n          pr_log_debug(DEBUG6, \"unable to use DisplayLogin file '%s': %s\",\n            displaylogin, strerror(errno));\n          pr_fsio_close(displaylogin_fh);\n          displaylogin_fh = NULL;\n        }\n      }\n    }\n  }\n\n  return PR_DECLINED(cmd);\n}\n\nMODRET auth_pass(cmd_rec *cmd) {\n  char *user = NULL;\n  int res = 0;\n\n  if (logged_in)\n    return PR_ERROR_MSG(cmd, R_503, _(\"You are already logged in\"));\n\n  user = pr_table_get(session.notes, \"mod_auth.orig-user\", NULL);\n  if (!user) {\n    (void) pr_table_remove(session.notes, \"mod_auth.orig-user\", NULL);\n    (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n    return PR_ERROR_MSG(cmd, R_503, _(\"Login with USER first\"));\n  }\n\n  /* Clear any potentially cached directory config */\n  session.anon_config = NULL;\n  session.dir_config = NULL;\n\n  res = setup_env(cmd->tmp_pool, cmd, user, cmd->arg);\n  if (res == 1) {\n    config_rec *c = NULL;\n\n    c = add_config_param_set(&cmd->server->conf, \"authenticated\", 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = TRUE;\n\n    set_auth_check(NULL);\n\n    (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n    if (session.sf_flags & SF_ANON) {\n      if (pr_table_add_dup(session.notes, \"mod_auth.anon-passwd\",\n          pr_fs_decode_path(cmd->server->pool, cmd->arg), 0) < 0) {\n        pr_log_debug(DEBUG3,\n          \"error stashing anonymous password in session.notes: %s\",\n          strerror(errno));\n      }\n    }\n\n    logged_in = 1;\n    return PR_HANDLED(cmd);\n  }\n\n  (void) pr_table_remove(session.notes, \"mod_auth.anon-passwd\", NULL);\n\n  if (res == 0) {\n    unsigned int max_logins, *max = NULL;\n    char *denymsg = NULL;\n\n    /* check for AccessDenyMsg */\n    if ((denymsg = get_param_ptr((session.anon_config ?\n        session.anon_config->subset : cmd->server->conf),\n        \"AccessDenyMsg\", FALSE)) != NULL) {\n\n      if (strstr(denymsg, \"%u\") != NULL) {\n        denymsg = sreplace(cmd->tmp_pool, denymsg, \"%u\", user, NULL);\n      }\n    }\n\n    max = get_param_ptr(main_server->conf, \"MaxLoginAttempts\", FALSE);\n    if (max != NULL) {\n      max_logins = *max;\n\n    } else {\n      max_logins = 3;\n    }\n\n    if (max_logins > 0 &&\n        ++auth_tries >= max_logins) {\n      if (denymsg) {\n        pr_response_send(R_530, \"%s\", denymsg);\n\n      } else {\n        pr_response_send(R_530, \"%s\", _(\"Login incorrect.\"));\n      }\n\n      pr_log_auth(PR_LOG_NOTICE,\n        \"Maximum login attempts (%u) exceeded, connection refused\", max_logins);\n\n      /* Generate an event about this limit being exceeded. */\n      pr_event_generate(\"mod_auth.max-login-attempts\", session.c);\n\n      pr_session_disconnect(&auth_module, PR_SESS_DISCONNECT_CONFIG_ACL,\n        \"Denied by MaxLoginAttempts\");\n    }\n\n    return PR_ERROR_MSG(cmd, R_530, denymsg ? denymsg : _(\"Login incorrect.\"));\n  }\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_acct(cmd_rec *cmd) {\n  pr_response_add(R_502, _(\"ACCT command not implemented\"));\n  return PR_HANDLED(cmd);\n}\n\nMODRET auth_rein(cmd_rec *cmd) {\n  pr_response_add(R_502, _(\"REIN command not implemented\"));\n  return PR_HANDLED(cmd);\n}\n\n/* Configuration handlers\n */\n\nMODRET set_accessdenymsg(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_accessgrantmsg(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: AllowChrootSymlinks on|off */\nMODRET set_allowchrootsymlinks(cmd_rec *cmd) {\n  int b = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  b = get_boolean(cmd, 1);\n  if (b == -1) {\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = b;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_anonrequirepassword(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_anonrejectpasswords(cmd_rec *cmd) {\n#ifdef PR_USE_REGEX\n  pr_regex_t *pre = NULL;\n  int res;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  pre = pr_regexp_alloc(&auth_module);\n\n  res = pr_regexp_compile(pre, cmd->argv[1], REG_EXTENDED|REG_NOSUB);\n  if (res != 0) {\n    char errstr[200] = {'\\0'};\n\n    pr_regexp_error(res, pre, errstr, 200);\n    pr_regexp_free(NULL, pre);\n\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"Unable to compile regex '\",\n      cmd->argv[1], \"': \", errstr, NULL));\n  }\n\n  (void) add_config_param(cmd->argv[0], 1, (void *) pre);\n  return PR_HANDLED(cmd);\n\n#else\n  CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"The \", cmd->argv[0], \" directive \"\n    \"cannot be used on this system, as you do not have POSIX compliant \"\n    \"regex support\", NULL));\n#endif\n}\n\nMODRET set_authaliasonly(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_authusingalias(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_createhome(cmd_rec *cmd) {\n  int bool = -1, start = 2;\n  mode_t mode = (mode_t) 0700, dirmode = (mode_t) 0711;\n  char *skel_path = NULL;\n  config_rec *c = NULL;\n  uid_t cuid = 0;\n  gid_t cgid = 0, hgid = -1;\n  unsigned long flags = 0UL;\n\n  if (cmd->argc-1 < 1) {\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n  }\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1) {\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n  }\n\n  /* No need to process the rest if bool is FALSE. */\n  if (bool == FALSE) {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n    *((unsigned char *) c->argv[0]) = bool;\n\n    return PR_HANDLED(cmd);\n  }\n\n  /* Check the mode parameter, if present */\n  if (cmd->argc-1 >= 2 &&\n      strcasecmp(cmd->argv[2], \"dirmode\") != 0 &&\n      strcasecmp(cmd->argv[2], \"skel\") != 0) {\n    char *tmp = NULL;\n\n    mode = strtol(cmd->argv[2], &tmp, 8);\n\n    if (tmp && *tmp)\n      CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \": bad mode parameter: '\",\n        cmd->argv[2], \"'\", NULL));\n\n    start = 3;\n  }\n\n  if (cmd->argc-1 > 2) {\n    register unsigned int i;\n\n    /* Cycle through the rest of the parameters */\n    for (i = start; i < cmd->argc;) {\n      if (strcasecmp(cmd->argv[i], \"skel\") == 0) {\n        struct stat st;\n\n        /* Check that the skel directory, if configured, meets the\n         * requirements.\n         */\n\n        skel_path = cmd->argv[++i];\n\n        if (*skel_path != '/') {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"skel path '\",\n            skel_path, \"' is not a full path\", NULL));\n        }\n\n        if (pr_fsio_stat(skel_path, &st) < 0) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"unable to stat '\",\n            skel_path, \"': \", strerror(errno), NULL));\n        }\n\n        if (!S_ISDIR(st.st_mode)) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"'\", skel_path,\n            \"' is not a directory\", NULL));\n        }\n\n        /* Must not be world-writable. */\n        if (st.st_mode & S_IWOTH) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"'\", skel_path,\n            \"' is world-writable\", NULL));\n        }\n\n        /* Move the index past the skel parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"dirmode\") == 0) {\n        char *tmp = NULL;\n\n        dirmode = strtol(cmd->argv[++i], &tmp, 8);\n \n        if (tmp && *tmp)\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad mode parameter: '\",\n            cmd->argv[i], \"'\", NULL));\n\n        /* Move the index past the dirmode parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"uid\") == 0) {\n\n        /* Check for a \"~\" parameter. */\n        if (strncmp(cmd->argv[i+1], \"~\", 2) != 0) {\n          char *tmp = NULL;\n          uid_t uid;\n\n          uid = strtol(cmd->argv[++i], &tmp, 10);\n\n          if (tmp && *tmp) {\n            CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad UID parameter: '\",\n              cmd->argv[i], \"'\", NULL));\n          }\n\n          cuid = uid;\n\n        } else {\n          cuid = (uid_t) -1;       \n          i++;\n        }\n\n        /* Move the index past the uid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"gid\") == 0) {\n\n        /* Check for a \"~\" parameter. */\n        if (strncmp(cmd->argv[i+1], \"~\", 2) != 0) {\n          char *tmp = NULL;\n          gid_t gid;\n\n          gid = strtol(cmd->argv[++i], &tmp, 10);\n\n          if (tmp && *tmp) {\n            CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad GID parameter: '\",\n              cmd->argv[i], \"'\", NULL));\n          }\n\n          cgid = gid;\n\n        } else {\n          cgid = (gid_t) -1;\n          i++;\n        }\n\n        /* Move the index past the gid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"homegid\") == 0) {\n        char *tmp = NULL;\n        gid_t gid;\n\n        gid = strtol(cmd->argv[++i], &tmp, 10);\n\n        if (tmp && *tmp) {\n          CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"bad GID parameter: '\",\n            cmd->argv[i], \"'\", NULL));\n        }\n\n        hgid = gid;\n\n        /* Move the index past the homegid parameter */\n        i++;\n\n      } else if (strcasecmp(cmd->argv[i], \"NoRootPrivs\") == 0) {\n        flags |= PR_MKHOME_FL_USE_USER_PRIVS;\n        i++;\n\n      } else {\n        CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"unknown parameter: '\",\n          cmd->argv[i], \"'\", NULL));\n      }\n    }\n  }\n\n  c = add_config_param(cmd->argv[0], 8, NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL);\n\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->argv[1] = pcalloc(c->pool, sizeof(mode_t));\n  *((mode_t *) c->argv[1]) = mode;\n  c->argv[2] = pcalloc(c->pool, sizeof(mode_t));\n  *((mode_t *) c->argv[2]) = dirmode;\n\n  if (skel_path) {\n    c->argv[3] = pstrdup(c->pool, skel_path);\n  }\n\n  c->argv[4] = pcalloc(c->pool, sizeof(uid_t));\n  *((uid_t *) c->argv[4]) = cuid;\n  c->argv[5] = pcalloc(c->pool, sizeof(gid_t));\n  *((gid_t *) c->argv[5]) = cgid;\n  c->argv[6] = pcalloc(c->pool, sizeof(gid_t));\n  *((gid_t *) c->argv[6]) = hgid;\n  c->argv[7] = pcalloc(c->pool, sizeof(unsigned long));\n  *((unsigned long *) c->argv[7]) = flags;\n \n  return PR_HANDLED(cmd);\n}\n\nMODRET add_defaultroot(cmd_rec *cmd) {\n  config_rec *c;\n  char *dir,**argv;\n  int argc;\n  array_header *acl = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (cmd->argc < 2)\n    CONF_ERROR(cmd,\"syntax: DefaultRoot <directory> [<group-expression>]\");\n\n  argv = cmd->argv;\n  argc = cmd->argc - 2;\n\n  dir = *++argv;\n\n  /* dir must be / or ~. */\n  if (*dir != '/' &&\n      *dir != '~')\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") absolute pathname \"\n      \"required\", NULL));\n\n  if (strchr(dir, '*'))\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") wildcards not allowed \"\n      \"in pathname\", NULL));\n\n  if (*(dir + strlen(dir) - 1) != '/')\n    dir = pstrcat(cmd->tmp_pool, dir, \"/\", NULL);\n\n  acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n  c = add_config_param(cmd->argv[0], 0);\n\n  c->argc = argc + 1;\n  c->argv = pcalloc(c->pool, (argc + 2) * sizeof(char *));\n  argv = (char **) c->argv;\n  *argv++ = pstrdup(c->pool, dir);\n\n  if (argc && acl)\n    while(argc--) {\n      *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n      acl->elts = ((char **) acl->elts) + 1;\n    }\n\n  *argv = NULL;\n  return PR_HANDLED(cmd);\n}\n\nMODRET add_defaultchdir(cmd_rec *cmd) {\n  config_rec *c;\n  char *dir,**argv;\n  int argc;\n  array_header *acl = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (cmd->argc < 2)\n    CONF_ERROR(cmd, \"syntax: DefaultChdir <directory> [<group-expression>]\");\n\n  argv = cmd->argv;\n  argc = cmd->argc - 2;\n\n  dir = *++argv;\n\n  if (strchr(dir, '*'))\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"(\", dir, \") wildcards not allowed \"\n      \"in pathname\", NULL));\n\n  if (*(dir + strlen(dir) - 1) != '/')\n    dir = pstrcat(cmd->tmp_pool, dir, \"/\", NULL);\n\n  acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n  c = add_config_param(cmd->argv[0], 0);\n\n  c->argc = argc + 1;\n  c->argv = pcalloc(c->pool, (argc + 2) * sizeof(char *));\n  argv = (char **) c->argv;\n  *argv++ = pstrdup(c->pool, dir);\n\n  if (argc && acl)\n    while(argc--) {\n      *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n      acl->elts = ((char **) acl->elts) + 1;\n    }\n\n  *argv = NULL;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_displaylogin(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 1, cmd->argv[1]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_grouppassword(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_loginpasswordprompt(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClientsPerClass class max|\"none\" [\"message\"] */\nMODRET set_maxclientsclass(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[2], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[2], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"max must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 4) {\n    c = add_config_param(cmd->argv[0], 3, NULL, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n    c->argv[2] = pstrdup(c->pool, cmd->argv[3]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pstrdup(c->pool, cmd->argv[1]);\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = max;\n  }\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClients max|\"none\" [\"message\"] */\nMODRET set_maxclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxClientsPerHost max|\"none\" [\"message\"] */\nMODRET set_maxhostclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n\n/* usage: MaxClientsPerUser max|\"none\" [\"message\"] */\nMODRET set_maxuserclients(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxConnectionsPerHost max|\"none\" [\"message\"] */\nMODRET set_maxconnectsperhost(cmd_rec *cmd) {\n  int max;\n  config_rec *c;\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[1], \"none\") == 0)\n    max = 0;\n\n  else {\n    char *tmp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &tmp, 10);\n\n    if ((tmp && *tmp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else\n    c = add_config_param(cmd->argv[0], 1, NULL);\n\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n  *((unsigned int *) c->argv[0]) = max;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: MaxHostsPerUser max|\"none\" [\"message\"] */\nMODRET set_maxhostsperuser(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  if (cmd->argc < 2 || cmd->argc > 3)\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n\n  if (!strcasecmp(cmd->argv[1], \"none\"))\n    max = 0;\n\n  else {\n    char *endp = NULL;\n\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  if (cmd->argc == 3) {\n    c = add_config_param(cmd->argv[0], 2, NULL, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n    c->argv[1] = pstrdup(c->pool, cmd->argv[2]);\n\n  } else {\n    c = add_config_param(cmd->argv[0], 1, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[0]) = max;\n  }\n\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_maxloginattempts(cmd_rec *cmd) {\n  int max;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (strcasecmp(cmd->argv[1], \"none\") == 0) {\n    max = 0;\n\n  } else {\n    char *endp = NULL;\n    max = (int) strtol(cmd->argv[1], &endp, 10);\n\n    if ((endp && *endp) || max < 1)\n      CONF_ERROR(cmd, \"parameter must be 'none' or a number greater than 0\");\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned int));\n  *((unsigned int *) c->argv[0]) = max;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_requirevalidshell(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: RewriteHome on|off */\nMODRET set_rewritehome(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_rootlogin(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd,1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = (unsigned char) bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: RootRevoke on|off|UseNonCompliantActiveTransfer */\nMODRET set_rootrevoke(cmd_rec *cmd) {\n  int root_revoke = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* A RootRevoke value of 0 indicates 'false', 1 indicates 'true', and\n   * 2 indicates 'NonCompliantActiveTransfer'.\n   */\n  root_revoke = get_boolean(cmd, 1);\n  if (root_revoke == -1) {\n    if (strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfer\") != 0 &&\n        strcasecmp(cmd->argv[1], \"UseNonCompliantActiveTransfers\") != 0) {\n      CONF_ERROR(cmd, \"expected Boolean parameter\");\n    }\n\n    root_revoke = 2;\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = (unsigned char) root_revoke;\n\n  c->flags |= CF_MERGEDOWN;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_timeoutlogin(cmd_rec *cmd) {\n  int timeout = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(int));\n  *((int *) c->argv[0]) = timeout;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_timeoutsession(cmd_rec *cmd) {\n  int timeout = 0, precedence = 0;\n  config_rec *c = NULL;\n\n  int ctxt = (cmd->config && cmd->config->config_type != CONF_PARAM ?\n     cmd->config->config_type : cmd->server->config_type ?\n     cmd->server->config_type : CONF_ROOT);\n\n  /* this directive must have either 1 or 3 arguments */\n  if (cmd->argc-1 != 1 && cmd->argc-1 != 3)\n    CONF_ERROR(cmd, \"missing arguments\");\n\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* Set the precedence for this config_rec based on its configuration\n   * context.\n   */\n  if (ctxt & CONF_GLOBAL) {\n    precedence = 1;\n\n  /* These will never appear simultaneously */\n  } else if ((ctxt & CONF_ROOT) ||\n             (ctxt & CONF_VIRTUAL)) {\n    precedence = 2;\n\n  } else if (ctxt & CONF_ANON) {\n    precedence = 3;\n  }\n\n  if (pr_str_get_duration(cmd->argv[1], &timeout) < 0) {\n    CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, \"error parsing timeout value '\",\n      cmd->argv[1], \"': \", strerror(errno), NULL));\n  }\n\n  if (timeout == 0) {\n    /* do nothing */\n    return PR_HANDLED(cmd);\n  }\n\n  if (cmd->argc-1 == 3) {\n    if (strncmp(cmd->argv[2], \"user\", 5) == 0 ||\n        strncmp(cmd->argv[2], \"group\", 6) == 0 ||\n        strncmp(cmd->argv[2], \"class\", 6) == 0) {\n\n       /* no op */\n\n     } else {\n       CONF_ERROR(cmd, pstrcat(cmd->tmp_pool, cmd->argv[0],\n         \": unknown classifier used: '\", cmd->argv[2], \"'\", NULL));\n    }\n  }\n\n  if (cmd->argc-1 == 1) {\n    c = add_config_param(cmd->argv[0], 2, NULL);\n    c->argv[0] = pcalloc(c->pool, sizeof(int));\n    *((int *) c->argv[0]) = timeout;\n    c->argv[1] = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) c->argv[1]) = precedence;\n\n  } else if (cmd->argc-1 == 3) {\n    array_header *acl = NULL;\n    int argc = cmd->argc - 3;\n    char **argv = cmd->argv + 2;\n\n    acl = pr_expr_create(cmd->tmp_pool, &argc, argv);\n\n    c = add_config_param(cmd->argv[0], 0);\n    c->argc = argc + 2;\n\n    /* add 3 to argc for the argv of the config_rec: one for the\n     * seconds value, one for the precedence, one for the classifier,\n     * and one for the terminating NULL\n     */\n    c->argv = pcalloc(c->pool, ((argc + 4) * sizeof(char *)));\n\n    /* capture the config_rec's argv pointer for doing the by-hand\n     * population\n     */\n    argv = (char **) c->argv;\n\n    /* Copy in the seconds. */\n    *argv = pcalloc(c->pool, sizeof(int));\n    *((int *) *argv++) = timeout;\n\n    /* Copy in the precedence. */\n    *argv = pcalloc(c->pool, sizeof(unsigned int));\n    *((unsigned int *) *argv++) = precedence;\n\n    /* Copy in the classifier. */\n    *argv++ = pstrdup(c->pool, cmd->argv[2]);\n\n    /* now, copy in the expression arguments */\n    if (argc && acl) {\n      while (argc--) {\n        *argv++ = pstrdup(c->pool, *((char **) acl->elts));\n        acl->elts = ((char **) acl->elts) + 1;\n      }\n    }\n\n    /* don't forget the terminating NULL */\n    *argv = NULL;\n\n  } else {\n    /* Should never reach here. */\n    CONF_ERROR(cmd, \"wrong number of parameters\");\n  }\n\n  c->flags |= CF_MERGEDOWN_MULTI;\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_useftpusers(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* usage: UseLastlog on|off */\nMODRET set_uselastlog(cmd_rec *cmd) {\n#ifdef PR_USE_LASTLOG\n  int bool;\n  config_rec *c;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n#else\n  CONF_ERROR(cmd, \"requires lastlog support (--with-lastlog)\");\n#endif /* PR_USE_LASTLOG */\n}\n\n/* usage: UserAlias alias real-user */\nMODRET set_useralias(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  /* Make sure that the given names differ. */\n  if (strcmp(cmd->argv[1], cmd->argv[2]) == 0)\n    CONF_ERROR(cmd, \"alias and real user names must differ\");\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n\n  /* Note: only merge this directive down if it is not appearing in an\n   * <Anonymous> context.\n   */\n  if (!check_context(cmd, CONF_ANON)) {\n    c->flags |= CF_MERGEDOWN_MULTI;\n  }\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_userdirroot(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"expected Boolean parameter\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n\n  return PR_HANDLED(cmd);\n}\n\nMODRET set_userpassword(cmd_rec *cmd) {\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 2);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  c = add_config_param_str(cmd->argv[0], 2, cmd->argv[1], cmd->argv[2]);\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}\n\n/* Module API tables\n */\n\nstatic conftable auth_conftab[] = {\n  { \"AccessDenyMsg\",\t\tset_accessdenymsg,\t\tNULL },\n  { \"AccessGrantMsg\",\t\tset_accessgrantmsg,\t\tNULL },\n  { \"AllowChrootSymlinks\",\tset_allowchrootsymlinks,\tNULL },\n  { \"AnonRequirePassword\",\tset_anonrequirepassword,\tNULL },\n  { \"AnonRejectPasswords\",\tset_anonrejectpasswords,\tNULL },\n  { \"AuthAliasOnly\",\t\tset_authaliasonly,\t\tNULL },\n  { \"AuthUsingAlias\",\t\tset_authusingalias,\t\tNULL },\n  { \"CreateHome\",\t\tset_createhome,\t\t\tNULL },\n  { \"DefaultChdir\",\t\tadd_defaultchdir,\t\tNULL },\n  { \"DefaultRoot\",\t\tadd_defaultroot,\t\tNULL },\n  { \"DisplayLogin\",\t\tset_displaylogin,\t\tNULL },\n  { \"GroupPassword\",\t\tset_grouppassword,\t\tNULL },\n  { \"LoginPasswordPrompt\",\tset_loginpasswordprompt,\tNULL },\n  { \"MaxClients\",\t\tset_maxclients,\t\t\tNULL },\n  { \"MaxClientsPerClass\",\tset_maxclientsclass,\t\tNULL },\n  { \"MaxClientsPerHost\",\tset_maxhostclients,\t\tNULL },\n  { \"MaxClientsPerUser\",\tset_maxuserclients,\t\tNULL },\n  { \"MaxConnectionsPerHost\",\tset_maxconnectsperhost,\t\tNULL },\n  { \"MaxHostsPerUser\",\t\tset_maxhostsperuser,\t\tNULL },\n  { \"MaxLoginAttempts\",\t\tset_maxloginattempts,\t\tNULL },\n  { \"RequireValidShell\",\tset_requirevalidshell,\t\tNULL },\n  { \"RewriteHome\",\t\tset_rewritehome,\t\tNULL },\n  { \"RootLogin\",\t\tset_rootlogin,\t\t\tNULL },\n  { \"RootRevoke\",\t\tset_rootrevoke,\t\t\tNULL },\n  { \"TimeoutLogin\",\t\tset_timeoutlogin,\t\tNULL },\n  { \"TimeoutSession\",\t\tset_timeoutsession,\t\tNULL },\n  { \"UseFtpUsers\",\t\tset_useftpusers,\t\tNULL },\n  { \"UseLastlog\",\t\tset_uselastlog,\t\t\tNULL },\n  { \"UserAlias\",\t\tset_useralias,\t\t\tNULL },\n  { \"UserDirRoot\",\t\tset_userdirroot,\t\tNULL },\n  { \"UserPassword\",\t\tset_userpassword,\t\tNULL },\n  { NULL,\t\t\tNULL,\t\t\t\tNULL }\n};\n\nstatic cmdtable auth_cmdtab[] = {\n  { PRE_CMD,\tC_USER,\tG_NONE,\tauth_pre_user,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_USER,\tG_NONE,\tauth_user,\tFALSE,\tFALSE,\tCL_AUTH },\n  { PRE_CMD,\tC_PASS,\tG_NONE,\tauth_pre_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_PASS,\tG_NONE,\tauth_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { POST_CMD,\tC_PASS,\tG_NONE,\tauth_post_pass,\tFALSE,\tFALSE,\tCL_AUTH },\n  { LOG_CMD,\tC_PASS,\tG_NONE,\tauth_log_pass,  FALSE,  FALSE },\n  { LOG_CMD_ERR,C_PASS,\tG_NONE,\tauth_err_pass,  FALSE,  FALSE },\n  { CMD,\tC_ACCT,\tG_NONE,\tauth_acct,\tFALSE,\tFALSE,\tCL_AUTH },\n  { CMD,\tC_REIN,\tG_NONE,\tauth_rein,\tFALSE,\tFALSE,\tCL_AUTH },\n  { POST_CMD,\tC_HOST,\tG_NONE,\tauth_post_host,\tFALSE,\tFALSE },\n  { 0, NULL }\n};\n\n/* Module interface */\n\nmodule auth_module = {\n  NULL, NULL,\n\n  /* Module API version */\n  0x20,\n\n  /* Module name */\n  \"auth\",\n\n  /* Module configuration directive table */\n  auth_conftab,\t\n\n  /* Module command handler table */\n  auth_cmdtab,\n\n  /* Module authentication handler table */\n  NULL,\n\n  /* Module initialization function */\n  auth_init,\n\n  /* Session initialization function */\n  auth_sess_init\n};\n\n"], "filenames": ["modules/mod_auth.c"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [783], "fixing_code_start_loc": [5], "fixing_code_end_loc": [830], "type": "CWE-59", "message": "ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.", "other": {"cve": {"id": "CVE-2017-7418", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-04T17:59:00.337", "lastModified": "2019-08-08T15:15:11.483", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user."}, {"lang": "es", "value": "ProFTPD en versiones anteriores a 1.3.5e y 1.3.6 en versiones anteriores a 1.3.6rc5 controlan si el directorio de inicio de un usuario puede contener un enlace simb\u00f3lico hasta la versi\u00f3n de la opci\u00f3n de configuraci\u00f3n AllowChrootSymlinks, pero comprueba s\u00f3lo el \u00faltimo componente de ruta al aplicar AllowChrootSymlinks. Los atacantes con acceso local pueden omitir el control AllowChrootSymlinks reemplazando un componente de ruta (que no sea el \u00faltimo) con un enlace simb\u00f3lico. El modelo de amenaza incluye un atacante al que no se concede acceso completo al sistema de archivos por parte de un proveedor de alojamiento, pero puede reconfigurar el directorio de inicio de un usuario FTP."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:*:d:*:*:*:*:*:*", "versionEndIncluding": "1.3.5", "matchCriteriaId": "17E56F7D-3F37-44E2-9ADB-24F06125A5A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:1.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "40A2C657-27EB-475E-9591-99E03DBDA12B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:1.3.6:rc1:*:*:*:*:*:*", "matchCriteriaId": "B6475817-8CC7-4C0C-A9A6-E58189852DA2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:1.3.6:rc2:*:*:*:*:*:*", "matchCriteriaId": "84CB8C28-C432-4FD4-9B76-CA6C2C8824D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:1.3.6:rc3:*:*:*:*:*:*", "matchCriteriaId": "21D053B1-AFDE-4859-ACFB-C51DC28EAA04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:proftpd:proftpd:1.3.6:rc4:*:*:*:*:*:*", "matchCriteriaId": "AA9A0785-FF92-4AB0-8F42-9060FB24120E"}]}]}], "references": [{"url": "http://bugs.proftpd.org/show_bug.cgi?id=4295", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00004.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00022.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00009.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97409", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/proftpd/proftpd/commit/f59593e6ff730b832dbe8754916cb5c821db579f", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/proftpd/proftpd/pull/444/commits/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed"}}