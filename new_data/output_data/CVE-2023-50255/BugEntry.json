{"buggy_code": ["/*\n * Copyright (c) 2017 Ragnar Thomsen <rthomsen6@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ( INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"libzipplugin.h\"\n#include \"common.h\"\n#include \"queries.h\"\n#include \"datamanager.h\"\n\n#include <QDebug>\n#include <QFile>\n#include <QFileInfo>\n#include <QDir>\n#include <QThread>\n#include <qplatformdefs.h>\n#include <QDirIterator>\n#include <QTimer>\n#include <QDataStream>\n#include <QTextCodec>\n\n#include <utime.h>\n\n//#include <zlib.h>\n#define READBYTES 10240         // \u6bcf\u6b21\u8bfb\u53d6\u6587\u4ef6\u5927\u5c0f\n\nLibzipPluginFactory::LibzipPluginFactory()\n{\n    registerPlugin<LibzipPlugin>();\n}\n\nLibzipPluginFactory::~LibzipPluginFactory()\n{\n\n}\n\n\n\nLibzipPlugin::LibzipPlugin(QObject *parent, const QVariantList &args)\n    : ReadWriteArchiveInterface(parent, args)\n{\n    qInfo() << \"LibzipPlugin\";\n    m_ePlugintype = PT_Libzip;\n    m_listCodecs.clear();\n    m_listCodecs << \"UTF-8\" << \"GB18030\" << \"GBK\" << \"Big5\" << \"us-ascii\";  // \u521d\u59cb\u5316\u4e2d\u6587\u7f16\u7801\u683c\u5f0f\n}\n\nLibzipPlugin::~LibzipPlugin()\n{\n\n}\n\nPluginFinishType LibzipPlugin::list()\n{\n    qInfo() << \"LibzipPlugin\u63d2\u4ef6\u52a0\u8f7d\u538b\u7f29\u5305\u6570\u636e\";\n    setPassword(QString());\n    m_mapFileCode.clear();\n    m_setHasHandlesDirs.clear();\n    m_setHasRootDirs.clear();\n    DataManager::get_instance().resetArchiveData();\n\n    // \u5904\u7406\u52a0\u8f7d\u6d41\u7a0b\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_error_init_with_code(&err, errcode);\n\n    // \u82e5\u6253\u5f00\u5931\u8d25\uff0c\u8fd4\u56de\u9519\u8bef\n    if (nullptr == archive) {\n        m_eErrorType = ET_ArchiveDamaged;\n        return PFT_Error;\n    }\n\n    // \u83b7\u53d6\u6587\u4ef6\u538b\u7f29\u5305\u6587\u4ef6\u6570\u76ee\n    const auto nofEntries = zip_get_num_entries(archive, 0);\n\n    // \u83b7\u53d6\u538b\u7f29\u5305\u7684\u6ce8\u91ca\u5185\u5bb9\n    QByteArray strCode;\n    m_strComment = m_common->trans2uft8(zip_get_archive_comment(archive, nullptr, ZIP_FL_ENC_RAW), strCode);\n\n    // \u5faa\u73af\u6784\u5efa\u6570\u636e\n    for (zip_int64_t i = 0; i < nofEntries; i++) {\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        handleArchiveData(archive, i);  // \u6784\u5efa\u6570\u636e\n    }\n\n    zip_close(archive);\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::testArchive()\n{\n    m_workStatus = WT_Test;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::extractFiles(const QList<FileEntry> &files, const ExtractionOptions &options)\n{\n    qInfo() << \"\u89e3\u538b\u7f29\u6570\u636e\";\n\n    setPassword(QString());\n    m_workStatus = WT_Extract;\n    int errcode = 0;\n    m_bOverwriteAll = false;        //\u662f\u5426\u5168\u90e8\u8986\u76d6\n    m_bSkipAll = false;             // \u662f\u5426\u5168\u90e8\u8df3\u8fc7\n    m_mapLongName.clear();\n    m_setLongName.clear();\n    m_mapLongDirName.clear();\n    m_mapRealDirValue.clear();\n//    m_bHandleCurEntry = false; //false:\u63d0\u53d6\u4f7f\u7528\u9009\u4e2d\u6587\u4ef6\u53ca\u5b50\u6587\u4ef6 true:\u63d0\u53d6\u4f7f\u7528\u9009\u4e2d\u6587\u4ef6\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u7279\u6b8a\u5305\u64cd\u4f5c\n        // return minizip_extractFiles(files, options);\n        m_eErrorType = ET_ArchiveDamaged ;\n        return PFT_Error;\n    }\n\n    // \u53f3\u952e\u89e3\u538b\u65f6\u6309\u7167\u6309\u7167\u538b\u7f29\u5305\u5927\u5c0f\u8ba1\u7b97\n    if (!options.bExistList) {\n        m_dScaleSize = 100.0 / options.qComressSize;\n    } else {\n        m_dScaleSize = 100.0 / options.qSize;\n    }\n    m_bDlnfs = m_common->isSubpathOfDlnfs(options.strTargetPath);\n\n    // \u6267\u884c\u89e3\u538b\u64cd\u4f5c\n    bool bHandleLongName = false;\n    if (options.bAllExtract) {  // \u5168\u90e8\u89e3\u538b\n        qlonglong qExtractSize = 0;\n        zip_int64_t nofEntries = zip_get_num_entries(archive, 0);\n        for (zip_int64_t i = 0; i < nofEntries; ++i) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                m_bCancel = false;      // \u91cd\u7f6e\u6807\u5fd7\u4f4d\n                break;\n            }\n\n            QString strFileName;\n\n            // \u89e3\u538b\u5355\u4e2a\u6587\u4ef6\n            m_eErrorType = extractEntry(archive, i, options, qExtractSize, strFileName, bHandleLongName);\n\n            // \u65b9\u4fbf\u53f3\u952e\u89e3\u538b\u65f6\u63d0\u793a\u662f\u5426\u6709\u6570\u636e\u89e3\u538b\u51fa\u6765\n            if (!options.bExistList && 0 == i) {\n                FileEntry entry;\n                entry.strFullPath = strFileName;\n                DataManager::get_instance().archiveData().listRootEntry << entry;\n            }\n\n            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // \u65e0\u9519\u8bef\uff0c\u7ee7\u7eed\u89e3\u538b\u4e0b\u4e00\u4e2a\u6587\u4ef6\n                continue;\n            } else if (ET_UserCancelOpertion == m_eErrorType) {    // \u7528\u6237\u53d6\u6d88\uff0c\u7ed3\u675f\u89e3\u538b\uff0c\u8fd4\u56de\u7ed3\u675f\u6807\u5fd7\n                zip_close(archive);\n                return PFT_Cancel;\n            } else {    // \u5904\u7406\u9519\u8bef\n                // \u5224\u65ad\u662f\u5426\u9700\u8981\u5bc6\u7801\uff0c\u82e5\u9700\u8981\u5bc6\u7801\uff0c\u5f39\u51fa\u5bc6\u7801\u8f93\u5165\u5bf9\u8bdd\u6846\uff0c\u7528\u6237\u8f93\u5165\u5bc6\u7801\u4e4b\u540e\uff0c\u91cd\u65b0\u89e3\u538b\u5f53\u524d\u6587\u4ef6\n                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {\n                    PasswordNeededQuery query(strFileName);\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        setPassword(QString());\n                        zip_close(archive);\n                        return PFT_Cancel;\n                    } else {\n                        setPassword(query.password());\n                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());\n                        i--;\n                    }\n                }  else {\n                    zip_close(archive);\n                    return PFT_Error;\n                }\n\n            }\n        }\n    } else { // \u90e8\u5206\u63d0\u53d6\n        qlonglong qExtractSize = 0;\n        m_listCurIndex.clear();\n        getIndexBySelEntry(files);    // \u83b7\u53d6\u7d22\u5f15\u503c\n\n        // \u63d0\u53d6\u6307\u5b9a\u6587\u4ef6\n        for (int i = 0; i < m_listCurIndex.count(); ++i) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            QString strFileName;\n\n            // \u89e3\u538b\u5355\u4e2a\u6587\u4ef6\n            m_eErrorType = extractEntry(archive, m_listCurIndex[i], options, qExtractSize, strFileName, bHandleLongName);\n\n            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // \u65e0\u9519\u8bef\uff0c\u7ee7\u7eed\u89e3\u538b\u4e0b\u4e00\u4e2a\u6587\u4ef6\n                continue;\n            } else if (ET_UserCancelOpertion == m_eErrorType) {    // \u7528\u6237\u53d6\u6d88\uff0c\u7ed3\u675f\u89e3\u538b\uff0c\u8fd4\u56de\u7ed3\u675f\u6807\u5fd7\n                zip_close(archive);\n                return PFT_Cancel;\n            } else {    // \u5904\u7406\u9519\u8bef\n                // \u5224\u65ad\u662f\u5426\u9700\u8981\u5bc6\u7801\uff0c\u82e5\u9700\u8981\u5bc6\u7801\uff0c\u5f39\u51fa\u5bc6\u7801\u8f93\u5165\u5bf9\u8bdd\u6846\uff0c\u7528\u6237\u8f93\u5165\u5bc6\u7801\u4e4b\u540e\uff0c\u91cd\u65b0\u89e3\u538b\u5f53\u524d\u6587\u4ef6\n                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {\n\n                    PasswordNeededQuery query(strFileName);\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        setPassword(QString());\n                        zip_close(archive);\n                        return PFT_Cancel;\n                    } else {\n                        setPassword(query.password());\n                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());\n                        i--;\n                    }\n                } else {\n                    zip_close(archive);\n                    return PFT_Error;\n                }\n\n            }\n        }\n    }\n\n    if (bHandleLongName == true) {\n        m_eErrorType = ET_LongNameError;\n    }\n\n    zip_close(archive);\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::addFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    setPassword(QString());\n    m_workStatus = WT_Add;\n    qInfo() << \"\u6dfb\u52a0\u538b\u7f29\u5305\u6570\u636e\";\n    int errcode = 0;\n    zip_error_t err;\n\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); //filename()\u538b\u7f29\u5305\u540d\n    zip_error_init_with_code(&err, errcode);\n    if (!archive) {\n        emit error((\"Failed to open the archive: %1\")); //ReadOnlyArchiveInterface::error\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    for (const FileEntry &e : files) {\n        // \u8fc7\u6ee4\u4e0a\u7ea7\u76ee\u5f55\uff08\u4e0d\u5bf9\u5168\u8def\u5f84\u8fdb\u884c\u538b\u7f29\uff09\n        QString strPath = QFileInfo(e.strFullPath).absolutePath() + QDir::separator();\n\n        //\u53d6\u6d88\u6309\u94ae \u7ed3\u675f\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        // If entry is a directory, traverse and add all its files and subfolders.\n        QFileInfo info(e.strFullPath);\n        if (QFileInfo(e.strFullPath).isDir() && !info.isSymLink()) {\n            if (!writeEntry(archive, e.strFullPath, options, true, strPath)) {\n                if (zip_close(archive)) {\n                    emit error((\"Failed to write archive.\"));\n                    return PFT_Error;\n                }\n                return PFT_Error;\n            }\n\n            QDirIterator it(e.strFullPath,\n                            QDir::AllEntries | QDir::Readable |\n                            QDir::Hidden | QDir::NoDotAndDotDot,\n                            QDirIterator::Subdirectories);\n\n            while (!QThread::currentThread()->isInterruptionRequested() && it.hasNext()) {\n                const QString path = it.next();\n\n                if (QFileInfo(path).isDir()&&!QFileInfo(path).isSymLink()) {\n                    if (!writeEntry(archive, path, options, true, strPath)) {\n                        if (zip_close(archive)) {\n                            emit error((\"Failed to write archive.\"));\n                            return PFT_Error;\n                        }\n                        return PFT_Error;\n                    }\n                } else {\n                    if (!writeEntry(archive, path, options, false, strPath)) {\n                        if (zip_close(archive)) {\n                            emit error((\"Failed to write archive.\"));\n                            return PFT_Error;\n                        }\n                        return PFT_Error;\n                    }\n                }\n                ++m_curFileCount;\n            }\n        } else {\n            if (!writeEntry(archive, e.strFullPath, options, false, strPath)) {\n                if (zip_close(archive)) {\n                    emit error((\"Failed to write archive.\"));\n                    return PFT_Error;\n                }\n                return PFT_Error;\n            }\n        }\n        ++m_curFileCount;\n    }\n\n\n    m_pCurArchive = archive;\n    // TODO:Register the callback function to get progress feedback.\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);\n\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        // ZIP_ER_WRITE    /* S Write error */\n        // ENOSPC          /* No space left on device */\n        if (zip_error_code_zip(zip_get_error(archive)) == ZIP_ER_WRITE && zip_error_code_system(zip_get_error(archive)) == ENOSPC) {\n            m_eErrorType = ET_InsufficientDiskSpace;\n        }\n\n        return PFT_Error;\n    }\n\n    // We list the entire archive after adding files to ensure entry\n    // properties are up-to-date.\n\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::moveFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(options)\n    m_workStatus = WT_Move;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::copyFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(options)\n    m_workStatus = WT_Copy;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::deleteFiles(const QList<FileEntry> &files)\n{\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    setPassword(QString());\n    m_workStatus = WT_Delete;\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u6253\u5f00\u538b\u7f29\u5305\u5931\u8d25\n        emit error((\"Failed to open the archive: %1\"));\n        m_eErrorType = ET_FileOpenError;\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    m_pCurArchive = archive; // \u7f6e\u7a7a\uff0c\u9632\u6b62\u8fdb\u5ea6\u5904\u7406\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); // \u8fdb\u5ea6\u56de\u8c03\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        // \u53d6\u6d88\u56de\u8c03\n\n    m_listCurIndex.clear();\n    getIndexBySelEntry(files);    // \u83b7\u53d6\u7d22\u5f15\u503c\n\n    // \u5faa\u73af\u8c03\u7528\u5220\u9664\u64cd\u4f5c\n    for (int i = 0; i < m_listCurIndex.count(); i++) {\n        deleteEntry(m_listCurIndex[i], archive/*, i, count*/);        //delete from archive\n    }\n\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::renameFiles(const QList<FileEntry> &files)\n{\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    setPassword(QString());\n    m_workStatus = WT_Rename;\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u6253\u5f00\u538b\u7f29\u5305\u5931\u8d25\n        emit error((\"Failed to open the archive: %1\"));\n        m_eErrorType = ET_FileOpenError;\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    m_pCurArchive = archive; // \u7f6e\u7a7a\uff0c\u9632\u6b62\u8fdb\u5ea6\u5904\u7406\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); // \u8fdb\u5ea6\u56de\u8c03\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        // \u53d6\u6d88\u56de\u8c03\n\n    m_listCurIndex.clear();\n    getIndexBySelEntry(files, true);    // \u83b7\u53d6\u7d22\u5f15\u503c\uff0c\u53ea\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u6216\u6587\u4ef6\u5939\n\n    // \u5faa\u73af\u8c03\u7528\u91cd\u547d\u540d\u64cd\u4f5c,\u53ea\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u6216\u6587\u4ef6\u5939\n    for (int i = 0; i < m_listCurIndex.count(); i++) {\n        QString strAlias;\n        if (!files[0].strFullPath.endsWith(QDir::separator())) { //\u6587\u4ef6\u91cd\u547d\u540d\n            QString strPath = QFileInfo(files[0].strFullPath).path();\n            if(strPath == \".\" || strPath.isEmpty() || strPath.isNull()) {\n                strAlias = files[0].strAlias;\n            } else {\n                strAlias = strPath + QDir::separator() + files[0].strAlias;\n            }\n        } else { //\u6587\u4ef6\u5939\u91cd\u547d\u540d\n            QString strPath = QFileInfo(files[0].strFullPath.left(files[0].strFullPath.length() - 1)).path();\n            if(strPath == \".\"){\n                strAlias = files[0].strAlias + QDir::separator();\n            } else {\n                strAlias = strPath + QDir::separator() + files[0].strAlias + QDir::separator();\n            }\n            strAlias = strAlias + m_listCurName[i].right(m_listCurName[i].length()-files[0].strFullPath.length());\n        }\n        renameEntry(m_listCurIndex[i], archive,  strAlias);        //rename from archive\n    }\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::addComment(const QString &comment)\n{\n    setPassword(QString());\n    m_workStatus = WT_Comment;\n\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    int errcode = 0;\n    zip_error_t err;\n\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); //filename()\u538b\u7f29\u5305\u540d\n    zip_error_init_with_code(&err, errcode);\n    if (!archive) {\n        return PFT_Error;\n    }\n\n    // \u6ce8\u91ca\u5b57\u7b26\u4e32\u8f6c\u6362\n    QByteArray tmp = comment.toUtf8();\n    const char *commentstr = tmp.constData();\n//    const char *commentstr13 = comment.toUtf8().constData(); // \u8be5\u5199\u6cd5\u4e0d\u5b89\u5168\uff0c\u4f1a\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    zip_uint16_t commentlength = static_cast<zip_uint16_t>(strlen(commentstr));     // \u83b7\u53d6\u6ce8\u91ca\u957f\u5ea6\n\n    /**\n      * \u8bbe\u7f6e\u538b\u7f29\u5305\u6ce8\u91ca\n      * \u5982\u679c\u6ce8\u91ca\u4e3a\u7a7a\uff0c\u539f\u6ce8\u91ca\u4f1a\u88ab\u79fb\u9664\u6389\n      * \u6ce8\u91ca\u7f16\u7801\u5fc5\u987b\u4e3aASCII\u6216\u8005UTF-8\n      */\n    errcode = zip_set_archive_comment(archive, commentstr, commentlength);\n\n    // \u7ed3\u679c\u5224\u65ad\n    if (ZIP_ER_OK != errcode) {\n        return PFT_Error;\n    }\n\n    // \u6ce8\u518c\u8fdb\u5ea6\u56de\u8c03\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);\n\n    // \u5173\u95ed\u4fdd\u5b58\n    if (zip_close(archive)) {\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::updateArchiveData(const UpdateOptions &/*options*/)\n{\n    m_mapFileCode.clear();\n    m_setHasHandlesDirs.clear();\n    m_setHasRootDirs.clear();\n    DataManager::get_instance().resetArchiveData();\n\n    // \u5904\u7406\u52a0\u8f7d\u6d41\u7a0b\n    int errcode = 0;\n    zip_error_t err;\n\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_error_init_with_code(&err, errcode);\n\n    //\u67d0\u4e9b\u7279\u6b8a\u6587\u4ef6\uff0c\u5982.crx\u7528zip\u6253\u4e0d\u5f00\uff0c\u9700\u8981\u66ff\u6362minizip\n    if (!archive) {\n//        m_bAllEntry = true;\n//        return minizip_list();\n    }\n\n    // \u83b7\u53d6\u6587\u4ef6\u538b\u7f29\u5305\u6587\u4ef6\u6570\u76ee\n    const auto nofEntries = zip_get_num_entries(archive, 0);\n\n    // \u5faa\u73af\u6784\u5efa\u6570\u636e\n    for (zip_int64_t i = 0; i < nofEntries; i++) {\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        handleArchiveData(archive, i);  // \u6784\u5efa\u6570\u636e\n    }\n\n    zip_close(archive);\n\n    return PFT_Nomral;\n}\n\nvoid LibzipPlugin::pauseOperation()\n{\n    m_bPause = true;\n}\n\nvoid LibzipPlugin::continueOperation()\n{\n    m_bPause = false;\n}\n\nbool LibzipPlugin::doKill()\n{\n    m_bPause = false;\n    m_bCancel = true;\n    return false;\n}\n\nbool LibzipPlugin::writeEntry(zip_t *archive, const QString &entry, const CompressOptions &options, bool isDir, const QString &strRoot)\n{\n    Q_ASSERT(archive);\n    QFileInfo info(entry);\n    QString str;\n    if (!options.strDestination.isEmpty()) {\n        str = QString(options.strDestination + entry.mid(strRoot.length()));\n    } else {\n        //\u79fb\u9664\u524d\u7f00\u8def\u5f84\n        str = entry.mid(strRoot.length());\n    }\n    zip_int64_t index;\n    if (isDir && !info.isSymLink()) {\n        index = zip_dir_add(archive, str.toUtf8().constData(), ZIP_FL_ENC_GUESS);\n        if (-1 == index) {\n            // If directory already exists in archive, we get an error.\n            return false;\n        }\n    } else if(info.isSymLink()) { // symlink\n        QByteArray strLinkArr = info.symLinkTarget().toUtf8();\n        struct zip_source *source = zip_source_buffer(archive , strLinkArr, strLinkArr.length(), 0);\n        if (source)\n        {\n            index = zip_add(archive, str.toUtf8().constData(), source);\n        }\n        else\n        {\n            zip_source_free(source);\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n        zip_source_commit_write(source);\n        zip_source_close(source);\n     } else {\n        // \u83b7\u53d6\u6e90\u6587\u4ef6\n        zip_source_t *src = zip_source_file(archive, QFile::encodeName(entry).constData(), 0, -1);\n        if (!src) {\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n\n        // \u5411\u538b\u7f29\u5305\u4e2d\u6dfb\u52a0\u6587\u4ef6\n        index = zip_file_add(archive, str.toUtf8().constData(), src, ZIP_FL_ENC_GUESS | ZIP_FL_OVERWRITE);\n        if (-1 == index) {\n            zip_source_free(src);\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n        zip_source_commit_write(src);\n        zip_source_close(src);\n    }\n    zip_uint64_t uindex = static_cast<zip_uint64_t>(index);\n#ifndef Q_OS_WIN\n    // \u8bbe\u7f6e\u6587\u4ef6\u6743\u9650\n    QT_STATBUF result;\n    if (QT_LSTAT(QFile::encodeName(entry).constData(), &result) != 0) {\n    } else {\n        zip_uint32_t attributes = result.st_mode << 16;\n        if (zip_file_set_external_attributes(archive, uindex, 0, ZIP_OPSYS_UNIX, attributes) != 0) {\n        }\n    }\n#endif\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7684\u52a0\u5bc6\u7b97\u6cd5\n    if (options.bEncryption && !options.strEncryptionMethod.isEmpty()) { //ReadOnlyArchiveInterface::password()\n        int ret = 0;\n        if (QLatin1String(\"AES128\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_128, options.strPassword.toUtf8().constData());\n        } else if (QLatin1String(\"AES192\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_192, options.strPassword.toUtf8().constData());\n        } else if (QLatin1String(\"AES256\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_256, options.strPassword.toUtf8().constData());\n        }\n        if (ret != 0) {\n            emit error((\"Failed to set compression options for entry: %1\"));\n            return false;\n        }\n    }\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7b97\u6cd5\n    zip_int32_t compMethod = ZIP_CM_DEFAULT;\n    if (!options.strCompressionMethod.isEmpty()) {\n        if (QLatin1String(\"Deflate\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_DEFLATE;\n        } else if (QLatin1String(\"BZip2\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_BZIP2;\n        } else if (QLatin1String(\"Store\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_STORE;\n        }\n    }\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7b49\u7ea7\n    const int compLevel = (options.iCompressionLevel != -1) ? options.iCompressionLevel : 6;\n    if (zip_set_file_compression(archive, uindex, compMethod, zip_uint32_t(compLevel)) != 0) {\n        emit error((\"Failed to set compression options for entry: %1\"));\n        return false;\n    }\n    return true;\n}\n\n\nvoid LibzipPlugin::progressCallback(zip_t *, double progress, void *that)\n{\n    static_cast<LibzipPlugin *>(that)->emitProgress(progress);      // \u8fdb\u5ea6\u56de\u8c03\n}\n\n\nint LibzipPlugin::cancelCallback(zip_t *, void *that)\n{\n    return static_cast<LibzipPlugin *>(that)->cancelResult();       // \u53d6\u6d88\u56de\u8c03\n}\n\nbool LibzipPlugin::handleArchiveData(zip_t *archive, zip_int64_t index)\n{\n    if (nullptr == archive) {\n        return false;\n    }\n\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer)) {\n        return false;\n    }\n\n    QByteArray strCode;\n    // \u5bf9\u6587\u4ef6\u540d\u8fdb\u884c\u7f16\u7801\u63a2\u6d4b\u5e76\u8f6c\u7801\n    QString name = m_common->trans2uft8(statBuffer.name, strCode);\n    m_mapFileCode[index] = strCode;\n    if(name.contains(QLatin1Char('\\\\')))\n        name = name.replace(QLatin1Char('\\\\'), QDir::separator());\n    //\u5bf9\u4e8e\u540d\u79f0\u4ee5\"/\"\u5f00\u5934\u7684\u53bb\u9664\u5f00\u59cb\u7684\"/\"\n    if(name.startsWith(QDir::separator())) {\n        name.remove(0,1);\n    }\n    FileEntry entry;\n    entry.iIndex = int(index);\n    entry.strFullPath = name;\n    statBuffer2FileEntry(statBuffer, entry);\n\n    handleEntry(entry);\n\n    // \u5b58\u50a8\u603b\u6570\u636e\n    DataManager::get_instance().archiveData().mapFileEntry[name] = entry;\n\n    return true;\n}\n\nvoid LibzipPlugin::statBuffer2FileEntry(const zip_stat_t &statBuffer, FileEntry &entry)\n{\n    // FileEntry stFileEntry;\n\n    // \u6587\u4ef6\u540d\n    if (statBuffer.valid & ZIP_STAT_NAME) {\n        const QStringList pieces = entry.strFullPath.split(QLatin1Char('/'), QString::SkipEmptyParts);\n        entry.strFileName = pieces.isEmpty() ? QString() : pieces.last();\n    }\n\n    // \u662f\u5426\u4e3a\u6587\u4ef6\u5939\n    if (entry.strFullPath.endsWith(QDir::separator())) {\n        entry.isDirectory = true;\n    }\n\n    // \u6587\u4ef6\u771f\u5b9e\u5927\u5c0f\uff08\u6587\u4ef6\u5939\u663e\u793a\u9879\uff09\n    if (statBuffer.valid & ZIP_STAT_SIZE) {\n        if (!entry.isDirectory) {\n            entry.qSize = qlonglong(statBuffer.size);\n            DataManager::get_instance().archiveData().qSize += statBuffer.size;\n            DataManager::get_instance().archiveData().qComressSize += statBuffer.comp_size;\n        } else {\n            entry.qSize = 0;\n        }\n    }\n\n    // \u6587\u4ef6\u6700\u540e\u4fee\u6539\u65f6\u95f4\n    if (statBuffer.valid & ZIP_STAT_MTIME) {\n        entry.uLastModifiedTime = uint(statBuffer.mtime);\n    }\n\n    DataManager::get_instance().archiveData().strComment = m_strComment;\n}\n\nErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // \u89e3\u538b\u6587\u4ef6\u540d\uff08\u538b\u7f29\u5305\u4e2d\uff09\n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // \u9488\u5bf9\u6587\u4ef6\u5939\u540d\u79f0\u8fc7\u957f\u7684\u60c5\u51b5\uff0c\u76f4\u63a5\u63d0\u793a\u89e3\u538b\u5931\u8d25\uff0c\u6587\u4ef6\u5939\u540d\u79f0\u8fc7\u957f\n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left\u51fd\u6570\u53c2\u6570\u4e3a\u622a\u53d6\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570,\u6587\u4ef6\u89e3\u538b\u7ed3\u675f\u540e\u624d\u6dfb\u52a0\u8ba1\u6570\uff0c\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // \u8def\u5f84\u52a0\u622a\u53d6\u540e\u7684\u6587\u4ef6\u540d\n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // \u63d0\u53d6\n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n    } else {\n        emit signalCurFileName(strFileName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // \u662f\u5426\u4e3a\u6587\u4ef6\u5939\n\n    // \u5224\u65ad\u89e3\u538b\u8def\u5f84\u662f\u5426\u5b58\u5728\uff0c\u4e0d\u5b58\u5728\u5219\u521b\u5efa\u6587\u4ef6\u5939\n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // \u89e3\u538b\u5b8c\u6574\u6587\u4ef6\u540d\uff08\u542b\u8def\u5f84\uff09\n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // \u83b7\u53d6\u5916\u90e8\u4fe1\u606f\uff08\u6743\u9650\uff09\n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // \u4ece\u538b\u7f29\u5305\u4e2d\u83b7\u53d6\u6587\u4ef6\u6743\u9650\n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // \u6587\u4ef6\u5939\n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // \u6587\u4ef6\u5939\u52a0\u53ef\u6267\u884c\u6743\u9650\n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //\u8f6f\u8fde\u63a5\u89e3\u538b\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // \u666e\u901a\u6587\u4ef6\n\n        // \u5224\u65ad\u662f\u5426\u6709\u540c\u540d\u6587\u4ef6\n        if (file.exists()) {\n            if (m_bSkipAll) {       // \u5168\u90e8\u8df3\u8fc7\n                m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // \u82e5\u4e0d\u662f\u5168\u90e8\u8986\u76d6\uff0c\u5355\u6761\u5904\u7406\n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // \u82e5\u6587\u4ef6\u5b58\u5728\u4e14\u4e0d\u662f\u53ef\u5199\u6743\u9650\uff0c\u91cd\u65b0\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // \u5bf9\u6587\u4ef6\u8def\u5f84\u505a\u5224\u65ad\uff0c\u9632\u6b62\u7279\u6b8a\u5305\u672a\u5148\u89e3\u538b\u51fa\u6587\u4ef6\u5939\uff0c\u5bfc\u81f4\u89e3\u538b\u5931\u8d25\n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // \u9519\u8bef\u5904\u7406\n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//\u5bc6\u7801\u9519\u8bef\n\n                // \u5bf9\u5bc6\u7801\u7f16\u7801\u7684\u63a2\u6d4b\n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 \u3010\u4e13\u4e1a\u7248\u3011\u30101060\u3011\u3010\u5f52\u6863\u7ba1\u7406\u5668\u3011\u30105.12.0.2\u3011\u65e0\u6cd5\u89e3\u538b\u4e2d\u6587\u5bc6\u7801\u7684zip\u538b\u7f29\u5305\uff08\u542b\u6709\u957f\u540d\u79f0\uff09\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//\u5bc6\u7801\u6b63\u786e\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // \u65e0\u5bc6\u7801\u8f93\u5165\n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // \u4ee5\u53ea\u5199\u7684\u65b9\u5f0f\u6253\u5f00\u5f85\u89e3\u538b\u7684\u6587\u4ef6\n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // \u5224\u65ad\u6587\u4ef6\u540d\u662f\u5426\u8fc7\u957f\n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // \u5199\u6587\u4ef6\n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // \u53f3\u952e\u89e3\u538b\u65f6\u6309\u7167\u6587\u4ef6\u6bd4\u4f8b\u8ba1\u7b97\u5927\u5c0f\n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //\u89e3\u538b\u6682\u505c\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // \u5c0f\u4e8ereadBytes\u4f5c\u4e3a\u78c1\u76d8\u7a7a\u95f4\u4e0d\u8db3\u7684\u5224\u65ad\u6807\u51c6\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // \u8ba1\u7b97\u8fdb\u5ea6\u5e76\u663e\u793a\uff08\u53f3\u952e\u5feb\u6377\u89e3\u538b\u4f7f\u7528\u538b\u7f29\u5305\u5927\u5c0f\uff0c\u8ba1\u7b97\u6bd4\u4f8b\uff09\n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // \u8bbe\u7f6e\u6587\u4ef6/\u6587\u4ef6\u5939\u6743\u9650\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n    return ET_NoError;\n}\n\nvoid LibzipPlugin::emitProgress(double dPercentage)\n{\n    bool flag = true;\n    while (flag) {\n        if (QThread::currentThread()->isInterruptionRequested()) { //\u7ebf\u7a0b\u7ed3\u675f\n            break;\n        }\n\n        // \u6682\u505c\n        if (m_bPause) {\n            sleep(1);\n            continue;\n        }\n\n        // \u5904\u7406\u5f53\u524d\u6587\u4ef6\u540d\n        if (m_pCurArchive) {\n            if (WT_Add == m_workStatus) {\n                // \u538b\u7f29\u64cd\u4f5c\u663e\u793a\u5f53\u524d\u6b63\u5728\u538b\u7f29\u7684\u6587\u4ef6\u540d\n                zip_uint64_t index = zip_uint64_t(m_curFileCount * dPercentage);\n                // \u53d1\u9001\u5f53\u524d\u6587\u4ef6\u540d\u4fe1\u53f7\n                emit signalCurFileName(m_common->trans2uft8(zip_get_name(m_pCurArchive, index, ZIP_FL_ENC_RAW), m_mapFileCode[zip_int64_t(index)]));\n            } else if (WT_Delete == m_workStatus) {\n                // \u5220\u9664\u64cd\u4f5c\u663e\u793a\u5f53\u524d\u6b63\u5728\u5220\u9664\u7684\u6587\u4ef6\u540d\n                int iSpan = qRound(m_listCurName.count() * dPercentage);    // \u83b7\u53d6\u5360\u6bd4\n                QString strCurFileName;\n                // \u6309\u7167\u8fdb\u5ea6\u5360\u6bd4\u5904\u7406\u5f53\u524d\u6587\u4ef6\u540d\n                if (iSpan < 0) {\n                    strCurFileName = m_listCurName[0];\n                } else if (iSpan >= m_listCurIndex.count()) {\n                    strCurFileName = m_listCurName[m_listCurName.count() - 1];\n                } else {\n                    strCurFileName = m_listCurName[iSpan];\n                }\n\n                // \u53d1\u9001\u5f53\u524d\u6587\u4ef6\u540d\u4fe1\u53f7\n                emit signalCurFileName(strCurFileName);\n            }\n\n        }\n\n        // \u53d1\u9001\u8fdb\u5ea6\u4fe1\u53f7\n        emit signalprogress(dPercentage * 100);\n\n        flag = false;\n    }\n\n    m_bPause = false;\n}\n\nint LibzipPlugin::cancelResult()\n{\n    if (m_bCancel) {\n        m_bCancel = false;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nQByteArray LibzipPlugin::passwordUnicode(const QString &strPassword, int iIndex)\n{\n    if (m_strArchiveName.endsWith(\".zip\")) {\n        // QStringList listCodecName = QStringList() << \"UTF-8\" << \"GB18030\" << \"GBK\" <<\"Big5\"<< \"us-ascii\";\n        int nCount = strPassword.count();\n        bool b = false;\n\n        // \u68c0\u6d4b\u5bc6\u7801\u662f\u5426\u542b\u6709\u4e2d\u6587\n        for (int i = 0 ; i < nCount ; i++) {\n            QChar cha = strPassword.at(i);\n            ushort uni = cha.unicode();\n            if (uni >= 0x4E00 && uni <= 0x9FA5) {   // \u5224\u65ad\u662f\u5426\u662f\u4e2d\u6587\n                b = true;\n                break;\n            }\n        }\n\n        // chinese\n        if (b) {\n            QTextCodec *utf8 = QTextCodec::codecForName(\"UTF-8\");\n            QTextCodec *gbk = QTextCodec::codecForName(m_listCodecs[iIndex].toUtf8().data());\n            // QTextCodec *gbk = QTextCodec::codecForName(\"UTF-8\");\n\n            //utf8 -> \u6240\u9700\u7f16\u7801\n            //1. utf8 -> unicode\n            QString strUnicode = utf8->toUnicode(strPassword.toUtf8().data());\n            //2. unicode -> \u6240\u9700\u7f16\u7801, \u5f97\u5230QByteArray\n            QByteArray gb_bytes = gbk->fromUnicode(strUnicode);\n            return gb_bytes; //\u83b7\u53d6\u5176char *115645 \u3010\u4e13\u4e1a\u7248\u3011\u30101060\u3011\u3010\u5f52\u6863\u7ba1\u7406\u5668\u3011\u30105.12.0.2\u3011\u65e0\u6cd5\u89e3\u538b\u4e2d\u6587\u5bc6\u7801\u7684zip\u538b\u7f29\u5305\uff08\u542b\u6709\u957f\u540d\u79f0\uff09\n        } else {\n            return strPassword.toUtf8();\n        }\n    } else {\n        return strPassword.toUtf8();\n    }\n\n}\n\nbool LibzipPlugin::deleteEntry(int index, zip_t *archive)\n{\n    // \u4e8b\u4ef6\u5faa\u73af\n    if (QThread::currentThread()->isInterruptionRequested()) {\n        if (zip_close(archive)) {\n            // \u53d1\u9001\u4fdd\u5b58\u5931\u8d25\n            emit error((\"Failed to write archive.\"));\n            m_eErrorType = ET_FileWriteError;\n            return false;\n        }\n        return false;\n    }\n\n    int statusDel = zip_delete(archive, zip_uint64_t(index));   // \u83b7\u53d6\u5220\u9664\u72b6\u6001\n    if (-1 == statusDel) {\n        // \u5220\u9664\u5931\u8d25\n        emit error((\"Failed to delete entry: %1\"));\n        m_eErrorType = ET_DeleteError;\n        return false;\n    }\n\n    return true;\n}\n\nbool LibzipPlugin::renameEntry(int index, zip_t *archive, const QString &strAlisa)\n{\n    // \u4e8b\u4ef6\u5faa\u73af\n    if (QThread::currentThread()->isInterruptionRequested()) {\n        if (zip_close(archive)) {\n            // \u53d1\u9001\u4fdd\u5b58\u5931\u8d25\n            emit error((\"Failed to write archive.\"));\n            m_eErrorType = ET_FileWriteError;\n            return false;\n        }\n        return false;\n    }\n\n    int statusDel = zip_rename(archive, zip_uint64_t(index), strAlisa.toUtf8().data());   // \u83b7\u53d6\u91cd\u547d\u540d\u72b6\u6001\n    if (-1 == statusDel) {\n        // \u91cd\u547d\u540d\u5931\u8d25\n        emit error((\"Failed to rename entry: %1\"));\n        m_eErrorType = ET_RenameError;\n        return false;\n    }\n\n    return true;\n}\n\nvoid LibzipPlugin::getIndexBySelEntry(const QList<FileEntry> &listEntry, bool isRename)\n{\n    m_listCurIndex.clear();\n    m_listCurName.clear();\n    ArchiveData stArchiveData = DataManager::get_instance().archiveData();\n\n    // \u7b5b\u9009\u5f85\u63d0\u53d6\u6587\u4ef6/\u6587\u4ef6\u5939\u7d22\u5f15\n    for (FileEntry entry : listEntry) {\n        auto iter = stArchiveData.mapFileEntry.find(entry.strFullPath);\n        for (; iter != stArchiveData.mapFileEntry.end();) {\n            if (!iter.key().startsWith(entry.strFullPath)) {\n                break;\n            } else {\n                // \u83b7\u53d6\u6709\u6548\u7d22\u5f15\n                if (iter.value().iIndex >= 0) {\n                    m_listCurIndex << iter.value().iIndex;      // \u4fdd\u5b58\u6587\u4ef6\u7d22\u5f15\n                    m_listCurName << iter.value().strFullPath;  // \u4fdd\u5b58\u6587\u4ef6\u540d\n                }\n\n                ++iter;\n\n                // \u5982\u679c\u6587\u4ef6\u5939\uff0c\u76f4\u63a5\u8df3\u8fc7\n                if (!entry.strFullPath.endsWith(QDir::separator())) {\n                    break;\n                }\n            }\n        }\n    }\n    if(isRename) return;//\u91cd\u547d\u540d\u4e0d\u505a\u6392\u5e8f\u5904\u7406\n    // \u5347\u5e8f\u6392\u5e8f\n    std::stable_sort(m_listCurIndex.begin(), m_listCurIndex.end());\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2017 Ragnar Thomsen <rthomsen6@gmail.com>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ( INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"libzipplugin.h\"\n#include \"common.h\"\n#include \"queries.h\"\n#include \"datamanager.h\"\n\n#include <QDebug>\n#include <QFile>\n#include <QFileInfo>\n#include <QDir>\n#include <QThread>\n#include <qplatformdefs.h>\n#include <QDirIterator>\n#include <QTimer>\n#include <QDataStream>\n#include <QTextCodec>\n\n#include <utime.h>\n\n//#include <zlib.h>\n#define READBYTES 10240         // \u6bcf\u6b21\u8bfb\u53d6\u6587\u4ef6\u5927\u5c0f\n\nLibzipPluginFactory::LibzipPluginFactory()\n{\n    registerPlugin<LibzipPlugin>();\n}\n\nLibzipPluginFactory::~LibzipPluginFactory()\n{\n\n}\n\n\n\nLibzipPlugin::LibzipPlugin(QObject *parent, const QVariantList &args)\n    : ReadWriteArchiveInterface(parent, args)\n{\n    qInfo() << \"LibzipPlugin\";\n    m_ePlugintype = PT_Libzip;\n    m_listCodecs.clear();\n    m_listCodecs << \"UTF-8\" << \"GB18030\" << \"GBK\" << \"Big5\" << \"us-ascii\";  // \u521d\u59cb\u5316\u4e2d\u6587\u7f16\u7801\u683c\u5f0f\n}\n\nLibzipPlugin::~LibzipPlugin()\n{\n\n}\n\nPluginFinishType LibzipPlugin::list()\n{\n    qInfo() << \"LibzipPlugin\u63d2\u4ef6\u52a0\u8f7d\u538b\u7f29\u5305\u6570\u636e\";\n    setPassword(QString());\n    m_mapFileCode.clear();\n    m_setHasHandlesDirs.clear();\n    m_setHasRootDirs.clear();\n    DataManager::get_instance().resetArchiveData();\n\n    // \u5904\u7406\u52a0\u8f7d\u6d41\u7a0b\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_error_init_with_code(&err, errcode);\n\n    // \u82e5\u6253\u5f00\u5931\u8d25\uff0c\u8fd4\u56de\u9519\u8bef\n    if (nullptr == archive) {\n        m_eErrorType = ET_ArchiveDamaged;\n        return PFT_Error;\n    }\n\n    // \u83b7\u53d6\u6587\u4ef6\u538b\u7f29\u5305\u6587\u4ef6\u6570\u76ee\n    const auto nofEntries = zip_get_num_entries(archive, 0);\n\n    // \u83b7\u53d6\u538b\u7f29\u5305\u7684\u6ce8\u91ca\u5185\u5bb9\n    QByteArray strCode;\n    m_strComment = m_common->trans2uft8(zip_get_archive_comment(archive, nullptr, ZIP_FL_ENC_RAW), strCode);\n\n    // \u5faa\u73af\u6784\u5efa\u6570\u636e\n    for (zip_int64_t i = 0; i < nofEntries; i++) {\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        handleArchiveData(archive, i);  // \u6784\u5efa\u6570\u636e\n    }\n\n    zip_close(archive);\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::testArchive()\n{\n    m_workStatus = WT_Test;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::extractFiles(const QList<FileEntry> &files, const ExtractionOptions &options)\n{\n    qInfo() << \"\u89e3\u538b\u7f29\u6570\u636e\";\n\n    setPassword(QString());\n    m_workStatus = WT_Extract;\n    int errcode = 0;\n    m_bOverwriteAll = false;        //\u662f\u5426\u5168\u90e8\u8986\u76d6\n    m_bSkipAll = false;             // \u662f\u5426\u5168\u90e8\u8df3\u8fc7\n    m_mapLongName.clear();\n    m_setLongName.clear();\n    m_mapLongDirName.clear();\n    m_mapRealDirValue.clear();\n//    m_bHandleCurEntry = false; //false:\u63d0\u53d6\u4f7f\u7528\u9009\u4e2d\u6587\u4ef6\u53ca\u5b50\u6587\u4ef6 true:\u63d0\u53d6\u4f7f\u7528\u9009\u4e2d\u6587\u4ef6\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u7279\u6b8a\u5305\u64cd\u4f5c\n        // return minizip_extractFiles(files, options);\n        m_eErrorType = ET_ArchiveDamaged ;\n        return PFT_Error;\n    }\n\n    // \u53f3\u952e\u89e3\u538b\u65f6\u6309\u7167\u6309\u7167\u538b\u7f29\u5305\u5927\u5c0f\u8ba1\u7b97\n    if (!options.bExistList) {\n        m_dScaleSize = 100.0 / options.qComressSize;\n    } else {\n        m_dScaleSize = 100.0 / options.qSize;\n    }\n    m_bDlnfs = m_common->isSubpathOfDlnfs(options.strTargetPath);\n\n    // \u6267\u884c\u89e3\u538b\u64cd\u4f5c\n    bool bHandleLongName = false;\n    if (options.bAllExtract) {  // \u5168\u90e8\u89e3\u538b\n        qlonglong qExtractSize = 0;\n        zip_int64_t nofEntries = zip_get_num_entries(archive, 0);\n        for (zip_int64_t i = 0; i < nofEntries; ++i) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                m_bCancel = false;      // \u91cd\u7f6e\u6807\u5fd7\u4f4d\n                break;\n            }\n\n            QString strFileName;\n\n            // \u89e3\u538b\u5355\u4e2a\u6587\u4ef6\n            m_eErrorType = extractEntry(archive, i, options, qExtractSize, strFileName, bHandleLongName);\n\n            // \u65b9\u4fbf\u53f3\u952e\u89e3\u538b\u65f6\u63d0\u793a\u662f\u5426\u6709\u6570\u636e\u89e3\u538b\u51fa\u6765\n            if (!options.bExistList && 0 == i) {\n                FileEntry entry;\n                entry.strFullPath = strFileName;\n                DataManager::get_instance().archiveData().listRootEntry << entry;\n            }\n\n            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // \u65e0\u9519\u8bef\uff0c\u7ee7\u7eed\u89e3\u538b\u4e0b\u4e00\u4e2a\u6587\u4ef6\n                continue;\n            } else if (ET_UserCancelOpertion == m_eErrorType) {    // \u7528\u6237\u53d6\u6d88\uff0c\u7ed3\u675f\u89e3\u538b\uff0c\u8fd4\u56de\u7ed3\u675f\u6807\u5fd7\n                zip_close(archive);\n                return PFT_Cancel;\n            } else {    // \u5904\u7406\u9519\u8bef\n                // \u5224\u65ad\u662f\u5426\u9700\u8981\u5bc6\u7801\uff0c\u82e5\u9700\u8981\u5bc6\u7801\uff0c\u5f39\u51fa\u5bc6\u7801\u8f93\u5165\u5bf9\u8bdd\u6846\uff0c\u7528\u6237\u8f93\u5165\u5bc6\u7801\u4e4b\u540e\uff0c\u91cd\u65b0\u89e3\u538b\u5f53\u524d\u6587\u4ef6\n                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {\n                    PasswordNeededQuery query(strFileName);\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        setPassword(QString());\n                        zip_close(archive);\n                        return PFT_Cancel;\n                    } else {\n                        setPassword(query.password());\n                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());\n                        i--;\n                    }\n                }  else {\n                    zip_close(archive);\n                    return PFT_Error;\n                }\n\n            }\n        }\n    } else { // \u90e8\u5206\u63d0\u53d6\n        qlonglong qExtractSize = 0;\n        m_listCurIndex.clear();\n        getIndexBySelEntry(files);    // \u83b7\u53d6\u7d22\u5f15\u503c\n\n        // \u63d0\u53d6\u6307\u5b9a\u6587\u4ef6\n        for (int i = 0; i < m_listCurIndex.count(); ++i) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            QString strFileName;\n\n            // \u89e3\u538b\u5355\u4e2a\u6587\u4ef6\n            m_eErrorType = extractEntry(archive, m_listCurIndex[i], options, qExtractSize, strFileName, bHandleLongName);\n\n            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // \u65e0\u9519\u8bef\uff0c\u7ee7\u7eed\u89e3\u538b\u4e0b\u4e00\u4e2a\u6587\u4ef6\n                continue;\n            } else if (ET_UserCancelOpertion == m_eErrorType) {    // \u7528\u6237\u53d6\u6d88\uff0c\u7ed3\u675f\u89e3\u538b\uff0c\u8fd4\u56de\u7ed3\u675f\u6807\u5fd7\n                zip_close(archive);\n                return PFT_Cancel;\n            } else {    // \u5904\u7406\u9519\u8bef\n                // \u5224\u65ad\u662f\u5426\u9700\u8981\u5bc6\u7801\uff0c\u82e5\u9700\u8981\u5bc6\u7801\uff0c\u5f39\u51fa\u5bc6\u7801\u8f93\u5165\u5bf9\u8bdd\u6846\uff0c\u7528\u6237\u8f93\u5165\u5bc6\u7801\u4e4b\u540e\uff0c\u91cd\u65b0\u89e3\u538b\u5f53\u524d\u6587\u4ef6\n                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {\n\n                    PasswordNeededQuery query(strFileName);\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        setPassword(QString());\n                        zip_close(archive);\n                        return PFT_Cancel;\n                    } else {\n                        setPassword(query.password());\n                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());\n                        i--;\n                    }\n                } else {\n                    zip_close(archive);\n                    return PFT_Error;\n                }\n\n            }\n        }\n    }\n\n    if (bHandleLongName == true) {\n        m_eErrorType = ET_LongNameError;\n    }\n\n    zip_close(archive);\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::addFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    setPassword(QString());\n    m_workStatus = WT_Add;\n    qInfo() << \"\u6dfb\u52a0\u538b\u7f29\u5305\u6570\u636e\";\n    int errcode = 0;\n    zip_error_t err;\n\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); //filename()\u538b\u7f29\u5305\u540d\n    zip_error_init_with_code(&err, errcode);\n    if (!archive) {\n        emit error((\"Failed to open the archive: %1\")); //ReadOnlyArchiveInterface::error\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    for (const FileEntry &e : files) {\n        // \u8fc7\u6ee4\u4e0a\u7ea7\u76ee\u5f55\uff08\u4e0d\u5bf9\u5168\u8def\u5f84\u8fdb\u884c\u538b\u7f29\uff09\n        QString strPath = QFileInfo(e.strFullPath).absolutePath() + QDir::separator();\n\n        //\u53d6\u6d88\u6309\u94ae \u7ed3\u675f\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        // If entry is a directory, traverse and add all its files and subfolders.\n        QFileInfo info(e.strFullPath);\n        if (QFileInfo(e.strFullPath).isDir() && !info.isSymLink()) {\n            if (!writeEntry(archive, e.strFullPath, options, true, strPath)) {\n                if (zip_close(archive)) {\n                    emit error((\"Failed to write archive.\"));\n                    return PFT_Error;\n                }\n                return PFT_Error;\n            }\n\n            QDirIterator it(e.strFullPath,\n                            QDir::AllEntries | QDir::Readable |\n                            QDir::Hidden | QDir::NoDotAndDotDot,\n                            QDirIterator::Subdirectories);\n\n            while (!QThread::currentThread()->isInterruptionRequested() && it.hasNext()) {\n                const QString path = it.next();\n\n                if (QFileInfo(path).isDir()&&!QFileInfo(path).isSymLink()) {\n                    if (!writeEntry(archive, path, options, true, strPath)) {\n                        if (zip_close(archive)) {\n                            emit error((\"Failed to write archive.\"));\n                            return PFT_Error;\n                        }\n                        return PFT_Error;\n                    }\n                } else {\n                    if (!writeEntry(archive, path, options, false, strPath)) {\n                        if (zip_close(archive)) {\n                            emit error((\"Failed to write archive.\"));\n                            return PFT_Error;\n                        }\n                        return PFT_Error;\n                    }\n                }\n                ++m_curFileCount;\n            }\n        } else {\n            if (!writeEntry(archive, e.strFullPath, options, false, strPath)) {\n                if (zip_close(archive)) {\n                    emit error((\"Failed to write archive.\"));\n                    return PFT_Error;\n                }\n                return PFT_Error;\n            }\n        }\n        ++m_curFileCount;\n    }\n\n\n    m_pCurArchive = archive;\n    // TODO:Register the callback function to get progress feedback.\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);\n\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        // ZIP_ER_WRITE    /* S Write error */\n        // ENOSPC          /* No space left on device */\n        if (zip_error_code_zip(zip_get_error(archive)) == ZIP_ER_WRITE && zip_error_code_system(zip_get_error(archive)) == ENOSPC) {\n            m_eErrorType = ET_InsufficientDiskSpace;\n        }\n\n        return PFT_Error;\n    }\n\n    // We list the entire archive after adding files to ensure entry\n    // properties are up-to-date.\n\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::moveFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(options)\n    m_workStatus = WT_Move;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::copyFiles(const QList<FileEntry> &files, const CompressOptions &options)\n{\n    Q_UNUSED(files)\n    Q_UNUSED(options)\n    m_workStatus = WT_Copy;\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::deleteFiles(const QList<FileEntry> &files)\n{\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    setPassword(QString());\n    m_workStatus = WT_Delete;\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u6253\u5f00\u538b\u7f29\u5305\u5931\u8d25\n        emit error((\"Failed to open the archive: %1\"));\n        m_eErrorType = ET_FileOpenError;\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    m_pCurArchive = archive; // \u7f6e\u7a7a\uff0c\u9632\u6b62\u8fdb\u5ea6\u5904\u7406\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); // \u8fdb\u5ea6\u56de\u8c03\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        // \u53d6\u6d88\u56de\u8c03\n\n    m_listCurIndex.clear();\n    getIndexBySelEntry(files);    // \u83b7\u53d6\u7d22\u5f15\u503c\n\n    // \u5faa\u73af\u8c03\u7528\u5220\u9664\u64cd\u4f5c\n    for (int i = 0; i < m_listCurIndex.count(); i++) {\n        deleteEntry(m_listCurIndex[i], archive/*, i, count*/);        //delete from archive\n    }\n\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::renameFiles(const QList<FileEntry> &files)\n{\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    setPassword(QString());\n    m_workStatus = WT_Rename;\n    int errcode = 0;\n    zip_error_t err;\n\n    // \u6253\u5f00\u538b\u7f29\u5305\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), 0, &errcode);\n    zip_error_init_with_code(&err, errcode);\n    if (nullptr == archive) {\n        // \u6253\u5f00\u538b\u7f29\u5305\u5931\u8d25\n        emit error((\"Failed to open the archive: %1\"));\n        m_eErrorType = ET_FileOpenError;\n        return PFT_Error;\n    }\n\n    m_curFileCount = 0;\n    m_pCurArchive = archive; // \u7f6e\u7a7a\uff0c\u9632\u6b62\u8fdb\u5ea6\u5904\u7406\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this); // \u8fdb\u5ea6\u56de\u8c03\n    zip_register_cancel_callback_with_state(archive, cancelCallback, nullptr, this);        // \u53d6\u6d88\u56de\u8c03\n\n    m_listCurIndex.clear();\n    getIndexBySelEntry(files, true);    // \u83b7\u53d6\u7d22\u5f15\u503c\uff0c\u53ea\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u6216\u6587\u4ef6\u5939\n\n    // \u5faa\u73af\u8c03\u7528\u91cd\u547d\u540d\u64cd\u4f5c,\u53ea\u9488\u5bf9\u5355\u4e2a\u6587\u4ef6\u6216\u6587\u4ef6\u5939\n    for (int i = 0; i < m_listCurIndex.count(); i++) {\n        QString strAlias;\n        if (!files[0].strFullPath.endsWith(QDir::separator())) { //\u6587\u4ef6\u91cd\u547d\u540d\n            QString strPath = QFileInfo(files[0].strFullPath).path();\n            if(strPath == \".\" || strPath.isEmpty() || strPath.isNull()) {\n                strAlias = files[0].strAlias;\n            } else {\n                strAlias = strPath + QDir::separator() + files[0].strAlias;\n            }\n        } else { //\u6587\u4ef6\u5939\u91cd\u547d\u540d\n            QString strPath = QFileInfo(files[0].strFullPath.left(files[0].strFullPath.length() - 1)).path();\n            if(strPath == \".\"){\n                strAlias = files[0].strAlias + QDir::separator();\n            } else {\n                strAlias = strPath + QDir::separator() + files[0].strAlias + QDir::separator();\n            }\n            strAlias = strAlias + m_listCurName[i].right(m_listCurName[i].length()-files[0].strFullPath.length());\n        }\n        renameEntry(m_listCurIndex[i], archive,  strAlias);        //rename from archive\n    }\n    if (zip_close(archive)) {\n        emit error((\"Failed to write archive.\"));\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::addComment(const QString &comment)\n{\n    setPassword(QString());\n    m_workStatus = WT_Comment;\n\n    // \u521d\u59cb\u5316\u53d8\u91cf\n    int errcode = 0;\n    zip_error_t err;\n\n    // Open archive.\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_CREATE, &errcode); //filename()\u538b\u7f29\u5305\u540d\n    zip_error_init_with_code(&err, errcode);\n    if (!archive) {\n        return PFT_Error;\n    }\n\n    // \u6ce8\u91ca\u5b57\u7b26\u4e32\u8f6c\u6362\n    QByteArray tmp = comment.toUtf8();\n    const char *commentstr = tmp.constData();\n//    const char *commentstr13 = comment.toUtf8().constData(); // \u8be5\u5199\u6cd5\u4e0d\u5b89\u5168\uff0c\u4f1a\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    zip_uint16_t commentlength = static_cast<zip_uint16_t>(strlen(commentstr));     // \u83b7\u53d6\u6ce8\u91ca\u957f\u5ea6\n\n    /**\n      * \u8bbe\u7f6e\u538b\u7f29\u5305\u6ce8\u91ca\n      * \u5982\u679c\u6ce8\u91ca\u4e3a\u7a7a\uff0c\u539f\u6ce8\u91ca\u4f1a\u88ab\u79fb\u9664\u6389\n      * \u6ce8\u91ca\u7f16\u7801\u5fc5\u987b\u4e3aASCII\u6216\u8005UTF-8\n      */\n    errcode = zip_set_archive_comment(archive, commentstr, commentlength);\n\n    // \u7ed3\u679c\u5224\u65ad\n    if (ZIP_ER_OK != errcode) {\n        return PFT_Error;\n    }\n\n    // \u6ce8\u518c\u8fdb\u5ea6\u56de\u8c03\n    zip_register_progress_callback_with_state(archive, 0.001, progressCallback, nullptr, this);\n\n    // \u5173\u95ed\u4fdd\u5b58\n    if (zip_close(archive)) {\n        m_eErrorType = ET_FileWriteError;\n        return PFT_Error;\n    }\n\n    return PFT_Nomral;\n}\n\nPluginFinishType LibzipPlugin::updateArchiveData(const UpdateOptions &/*options*/)\n{\n    m_mapFileCode.clear();\n    m_setHasHandlesDirs.clear();\n    m_setHasRootDirs.clear();\n    DataManager::get_instance().resetArchiveData();\n\n    // \u5904\u7406\u52a0\u8f7d\u6d41\u7a0b\n    int errcode = 0;\n    zip_error_t err;\n\n    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);   // \u6253\u5f00\u538b\u7f29\u5305\u6587\u4ef6\n    zip_error_init_with_code(&err, errcode);\n\n    //\u67d0\u4e9b\u7279\u6b8a\u6587\u4ef6\uff0c\u5982.crx\u7528zip\u6253\u4e0d\u5f00\uff0c\u9700\u8981\u66ff\u6362minizip\n    if (!archive) {\n//        m_bAllEntry = true;\n//        return minizip_list();\n    }\n\n    // \u83b7\u53d6\u6587\u4ef6\u538b\u7f29\u5305\u6587\u4ef6\u6570\u76ee\n    const auto nofEntries = zip_get_num_entries(archive, 0);\n\n    // \u5faa\u73af\u6784\u5efa\u6570\u636e\n    for (zip_int64_t i = 0; i < nofEntries; i++) {\n        if (QThread::currentThread()->isInterruptionRequested()) {\n            break;\n        }\n\n        handleArchiveData(archive, i);  // \u6784\u5efa\u6570\u636e\n    }\n\n    zip_close(archive);\n\n    return PFT_Nomral;\n}\n\nvoid LibzipPlugin::pauseOperation()\n{\n    m_bPause = true;\n}\n\nvoid LibzipPlugin::continueOperation()\n{\n    m_bPause = false;\n}\n\nbool LibzipPlugin::doKill()\n{\n    m_bPause = false;\n    m_bCancel = true;\n    return false;\n}\n\nbool LibzipPlugin::writeEntry(zip_t *archive, const QString &entry, const CompressOptions &options, bool isDir, const QString &strRoot)\n{\n    Q_ASSERT(archive);\n    QFileInfo info(entry);\n    QString str;\n    if (!options.strDestination.isEmpty()) {\n        str = QString(options.strDestination + entry.mid(strRoot.length()));\n    } else {\n        //\u79fb\u9664\u524d\u7f00\u8def\u5f84\n        str = entry.mid(strRoot.length());\n    }\n    zip_int64_t index;\n    if (isDir && !info.isSymLink()) {\n        index = zip_dir_add(archive, str.toUtf8().constData(), ZIP_FL_ENC_GUESS);\n        if (-1 == index) {\n            // If directory already exists in archive, we get an error.\n            return false;\n        }\n    } else if(info.isSymLink()) { // symlink\n        QByteArray strLinkArr = info.symLinkTarget().toUtf8();\n        struct zip_source *source = zip_source_buffer(archive , strLinkArr, strLinkArr.length(), 0);\n        if (source)\n        {\n            index = zip_add(archive, str.toUtf8().constData(), source);\n        }\n        else\n        {\n            zip_source_free(source);\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n        zip_source_commit_write(source);\n        zip_source_close(source);\n     } else {\n        // \u83b7\u53d6\u6e90\u6587\u4ef6\n        zip_source_t *src = zip_source_file(archive, QFile::encodeName(entry).constData(), 0, -1);\n        if (!src) {\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n\n        // \u5411\u538b\u7f29\u5305\u4e2d\u6dfb\u52a0\u6587\u4ef6\n        index = zip_file_add(archive, str.toUtf8().constData(), src, ZIP_FL_ENC_GUESS | ZIP_FL_OVERWRITE);\n        if (-1 == index) {\n            zip_source_free(src);\n            emit error((\"Failed to add entry: %1\"));\n            return false;\n        }\n        zip_source_commit_write(src);\n        zip_source_close(src);\n    }\n    zip_uint64_t uindex = static_cast<zip_uint64_t>(index);\n#ifndef Q_OS_WIN\n    // \u8bbe\u7f6e\u6587\u4ef6\u6743\u9650\n    QT_STATBUF result;\n    if (QT_LSTAT(QFile::encodeName(entry).constData(), &result) != 0) {\n    } else {\n        zip_uint32_t attributes = result.st_mode << 16;\n        if (zip_file_set_external_attributes(archive, uindex, 0, ZIP_OPSYS_UNIX, attributes) != 0) {\n        }\n    }\n#endif\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7684\u52a0\u5bc6\u7b97\u6cd5\n    if (options.bEncryption && !options.strEncryptionMethod.isEmpty()) { //ReadOnlyArchiveInterface::password()\n        int ret = 0;\n        if (QLatin1String(\"AES128\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_128, options.strPassword.toUtf8().constData());\n        } else if (QLatin1String(\"AES192\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_192, options.strPassword.toUtf8().constData());\n        } else if (QLatin1String(\"AES256\") == options.strEncryptionMethod) {\n            ret = zip_file_set_encryption(archive, uindex, ZIP_EM_AES_256, options.strPassword.toUtf8().constData());\n        }\n        if (ret != 0) {\n            emit error((\"Failed to set compression options for entry: %1\"));\n            return false;\n        }\n    }\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7b97\u6cd5\n    zip_int32_t compMethod = ZIP_CM_DEFAULT;\n    if (!options.strCompressionMethod.isEmpty()) {\n        if (QLatin1String(\"Deflate\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_DEFLATE;\n        } else if (QLatin1String(\"BZip2\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_BZIP2;\n        } else if (QLatin1String(\"Store\") == options.strCompressionMethod) {\n            compMethod = ZIP_CM_STORE;\n        }\n    }\n\n    // \u8bbe\u7f6e\u538b\u7f29\u7b49\u7ea7\n    const int compLevel = (options.iCompressionLevel != -1) ? options.iCompressionLevel : 6;\n    if (zip_set_file_compression(archive, uindex, compMethod, zip_uint32_t(compLevel)) != 0) {\n        emit error((\"Failed to set compression options for entry: %1\"));\n        return false;\n    }\n    return true;\n}\n\n\nvoid LibzipPlugin::progressCallback(zip_t *, double progress, void *that)\n{\n    static_cast<LibzipPlugin *>(that)->emitProgress(progress);      // \u8fdb\u5ea6\u56de\u8c03\n}\n\n\nint LibzipPlugin::cancelCallback(zip_t *, void *that)\n{\n    return static_cast<LibzipPlugin *>(that)->cancelResult();       // \u53d6\u6d88\u56de\u8c03\n}\n\nbool LibzipPlugin::handleArchiveData(zip_t *archive, zip_int64_t index)\n{\n    if (nullptr == archive) {\n        return false;\n    }\n\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer)) {\n        return false;\n    }\n\n    QByteArray strCode;\n    // \u5bf9\u6587\u4ef6\u540d\u8fdb\u884c\u7f16\u7801\u63a2\u6d4b\u5e76\u8f6c\u7801\n    QString name = m_common->trans2uft8(statBuffer.name, strCode);\n    m_mapFileCode[index] = strCode;\n    if(name.contains(QLatin1Char('\\\\')))\n        name = name.replace(QLatin1Char('\\\\'), QDir::separator());\n    //\u5bf9\u4e8e\u540d\u79f0\u4ee5\"/\"\u5f00\u5934\u7684\u53bb\u9664\u5f00\u59cb\u7684\"/\"\n    if(name.startsWith(QDir::separator())) {\n        name.remove(0,1);\n    }\n    FileEntry entry;\n    entry.iIndex = int(index);\n    entry.strFullPath = name;\n    statBuffer2FileEntry(statBuffer, entry);\n\n    handleEntry(entry);\n\n    // \u5b58\u50a8\u603b\u6570\u636e\n    DataManager::get_instance().archiveData().mapFileEntry[name] = entry;\n\n    return true;\n}\n\nvoid LibzipPlugin::statBuffer2FileEntry(const zip_stat_t &statBuffer, FileEntry &entry)\n{\n    // FileEntry stFileEntry;\n\n    // \u6587\u4ef6\u540d\n    if (statBuffer.valid & ZIP_STAT_NAME) {\n        const QStringList pieces = entry.strFullPath.split(QLatin1Char('/'), QString::SkipEmptyParts);\n        entry.strFileName = pieces.isEmpty() ? QString() : pieces.last();\n    }\n\n    // \u662f\u5426\u4e3a\u6587\u4ef6\u5939\n    if (entry.strFullPath.endsWith(QDir::separator())) {\n        entry.isDirectory = true;\n    }\n\n    // \u6587\u4ef6\u771f\u5b9e\u5927\u5c0f\uff08\u6587\u4ef6\u5939\u663e\u793a\u9879\uff09\n    if (statBuffer.valid & ZIP_STAT_SIZE) {\n        if (!entry.isDirectory) {\n            entry.qSize = qlonglong(statBuffer.size);\n            DataManager::get_instance().archiveData().qSize += statBuffer.size;\n            DataManager::get_instance().archiveData().qComressSize += statBuffer.comp_size;\n        } else {\n            entry.qSize = 0;\n        }\n    }\n\n    // \u6587\u4ef6\u6700\u540e\u4fee\u6539\u65f6\u95f4\n    if (statBuffer.valid & ZIP_STAT_MTIME) {\n        entry.uLastModifiedTime = uint(statBuffer.mtime);\n    }\n\n    DataManager::get_instance().archiveData().strComment = m_strComment;\n}\n\nErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)\n{\n    zip_stat_t statBuffer;\n    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {\n        return ET_FileReadError;\n    }\n\n    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // \u89e3\u538b\u6587\u4ef6\u540d\uff08\u538b\u7f29\u5305\u4e2d\uff09\n    //fix 232873\n    if(strFileName.indexOf(\"../\") != -1) {\n        qInfo() << \"skipped ../ path component(s) in \" << strFileName;\n        strFileName = strFileName.replace(\"../\", \"\");\n    }\n    if(strFileName.contains(QLatin1Char('\\\\')))\n        strFileName = strFileName.replace(QLatin1Char('\\\\'), QDir::separator());\n    QString strOriginName = strFileName;\n\n    // \u9488\u5bf9\u6587\u4ef6\u5939\u540d\u79f0\u8fc7\u957f\u7684\u60c5\u51b5\uff0c\u76f4\u63a5\u63d0\u793a\u89e3\u538b\u5931\u8d25\uff0c\u6587\u4ef6\u5939\u540d\u79f0\u8fc7\u957f\n//    QStringList listPath = strFileName.split(QDir::separator());\n//    listPath.removeLast();\n//    for (int i = 0; i < listPath.count(); ++i) {\n//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {\n//            emit signalCurFileName(strFileName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n//            return ET_LongNameError;\n//        }\n//    }\n\n    QString strFilePath;\n    QString strTempFileName = strFileName;\n    int iIndex = strFileName.lastIndexOf(QDir::separator());\n\n    if (iIndex >= 0) {\n        strFilePath = strFileName.left(iIndex);   // bug114527 left\u51fd\u6570\u53c2\u6570\u4e3a\u622a\u53d6\u7684\u5b57\u7b26\u4e32\u957f\u5ea6\n        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);\n    }\n\n    QString tempFilePathName;\n    if(!m_bDlnfs) {\n        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);\n        if(sDir.length() > 0) {\n           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;\n           if(strFileName.endsWith(QDir::separator())) {\n               strFileName = sDir;\n           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {\n               strFileName = sDir + strTempFileName;\n           }\n           if(!m_mapLongDirName.isEmpty()) {\n               bHandleLongName = true;\n           }\n        }\n        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {\n            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);\n\n            // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570,\u6587\u4ef6\u89e3\u538b\u7ed3\u675f\u540e\u624d\u6dfb\u52a0\u8ba1\u6570\uff0c\n            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // \u8def\u5f84\u52a0\u622a\u53d6\u540e\u7684\u6587\u4ef6\u540d\n            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {\n                return ET_LongNameError;\n            }\n            bHandleLongName = true;\n            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();\n            if(10 < sSuffix.length()){\n                sSuffix = QFileInfo(strTempFileName).suffix();\n                if(10 < sSuffix.length()) {\n                    sSuffix = sSuffix.right(10);\n                }\n            }\n            strTempFileName = strTemp + QString(\"(%1)\").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + \".\" + sSuffix;\n\n            strFileName = strTempFileName;\n            if (iIndex >= 0) {\n                strFileName = strFilePath + QDir::separator() + strTempFileName;\n            }\n\n        }\n    }\n\n    // \u63d0\u53d6\n    if (!options.strDestination.isEmpty()) {\n        if(bHandleLongName) {\n            int nCnt = options.strDestination.count(QDir::separator());\n            int nIndex = 0;\n            for(int i = 0; i < nCnt; i++){\n                nIndex = strFileName.indexOf(QDir::separator(), nIndex);\n                nIndex++;\n            }\n            strFileName = strFileName.remove(0, nIndex);\n        } else {\n            strFileName = strFileName.remove(0, options.strDestination.size());\n        }\n    }\n\n\n    if (bHandleLongName) {\n        emit signalCurFileName(strOriginName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n    } else {\n        emit signalCurFileName(strFileName); // \u53d1\u9001\u5f53\u524d\u6b63\u5728\u89e3\u538b\u7684\u6587\u4ef6\u540d\n    }\n\n    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // \u662f\u5426\u4e3a\u6587\u4ef6\u5939\n\n    // \u5224\u65ad\u89e3\u538b\u8def\u5f84\u662f\u5426\u5b58\u5728\uff0c\u4e0d\u5b58\u5728\u5219\u521b\u5efa\u6587\u4ef6\u5939\n    if (QDir().exists(options.strTargetPath) == false)\n        QDir().mkpath(options.strTargetPath);\n\n    // \u89e3\u538b\u5b8c\u6574\u6587\u4ef6\u540d\uff08\u542b\u8def\u5f84\uff09\n    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;\n\n    QFile file(strDestFileName);\n\n    // Store parent mtime.\n    QString parentDir;\n    if (strFileName.endsWith(QDir::separator())) {\n        QDir pDir = QFileInfo(strDestFileName).dir();\n        pDir.cdUp();\n        parentDir = pDir.path();\n    } else {\n        parentDir = QFileInfo(strDestFileName).path();\n    }\n    // For top-level items, don't restore parent dir mtime.\n    const bool restoreParentMtime = (parentDir != options.strTargetPath);\n\n    time_t parent_mtime;\n    if (restoreParentMtime) {\n        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;\n    }\n\n    // \u83b7\u53d6\u5916\u90e8\u4fe1\u606f\uff08\u6743\u9650\uff09\n    zip_uint8_t opsys;\n    zip_uint32_t attributes;\n    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {\n        emit error((\"Failed to read metadata for entry: %1\"));\n    }\n\n    // \u4ece\u538b\u7f29\u5305\u4e2d\u83b7\u53d6\u6587\u4ef6\u6743\u9650\n    mode_t value = mode_t();\n    switch (opsys) {\n    case ZIP_OPSYS_UNIX:\n        value = attributes >> 16;\n        break;\n    default:    // TODO: non-UNIX.\n        break;\n    }\n    bool isLink = false;\n    if(S_ISLNK(value)) {\n        isLink = true;\n    }\n    QFileDevice::Permissions per = getPermissions(value);\n\n    if (bIsDirectory && !isLink) {     // \u6587\u4ef6\u5939\n        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())\n            return ET_LongNameError;\n\n        QDir dir;\n        dir.mkpath(strDestFileName);\n\n        // \u6587\u4ef6\u5939\u52a0\u53ef\u6267\u884c\u6743\u9650\n        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;\n    } else if(isLink) { //\u8f6f\u8fde\u63a5\u89e3\u538b\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        char buf[READBYTES] = {0};\n        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n        if (readBytes > 0) {\n            QString strBuf = QString(buf).toLocal8Bit();\n            if (QFile::link(strBuf, strDestFileName)) {\n                qInfo() << \"Symlink's created:\" << buf << strFileName;\n            } else {\n                qInfo() << \"Can't create symlink\" << buf << strFileName;\n            }\n        }\n        file.close();\n        zip_fclose(zipFile);\n    } else {        // \u666e\u901a\u6587\u4ef6\n\n        // \u5224\u65ad\u662f\u5426\u6709\u540c\u540d\u6587\u4ef6\n        if (file.exists()) {\n            if (m_bSkipAll) {       // \u5168\u90e8\u8df3\u8fc7\n                m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                return ET_NoError;\n            } else {\n                if (!m_bOverwriteAll) {     // \u82e5\u4e0d\u662f\u5168\u90e8\u8986\u76d6\uff0c\u5355\u6761\u5904\u7406\n\n                    OverwriteQuery query(strDestFileName);\n\n                    emit signalQuery(&query);\n                    query.waitForResponse();\n\n                    if (query.responseCancelled()) {\n                        emit signalCancel();\n                        return ET_UserCancelOpertion;\n                    } else if (query.responseSkip()) {\n                        m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                        return ET_NoError;\n                    } else if (query.responseSkipAll()) {\n                        m_bSkipAll = true;\n                        m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n                        return ET_NoError;\n                    }  else if (query.responseOverwriteAll()) {\n                        m_bOverwriteAll = true;\n                    }\n                }\n            }\n        }\n\n        if (bHandleLongName) {\n            m_setLongName << strFileName;\n        }\n\n        // \u82e5\u6587\u4ef6\u5b58\u5728\u4e14\u4e0d\u662f\u53ef\u5199\u6743\u9650\uff0c\u91cd\u65b0\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\n        if (file.exists() && !file.isWritable()) {\n            file.remove();\n            file.setFileName(strDestFileName);\n            file.setPermissions(QFileDevice::WriteUser);\n        }\n\n        // \u5bf9\u6587\u4ef6\u8def\u5f84\u505a\u5224\u65ad\uff0c\u9632\u6b62\u7279\u6b8a\u5305\u672a\u5148\u89e3\u538b\u51fa\u6587\u4ef6\u5939\uff0c\u5bfc\u81f4\u89e3\u538b\u5931\u8d25\n        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)\n            QDir().mkpath(QFileInfo(strDestFileName).path());\n\n        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n        // \u9519\u8bef\u5904\u7406\n        if (nullptr == zipFile) {\n            int iErr = zip_error_code_zip(zip_get_error(archive));\n            if (ZIP_ER_WRONGPASSWD == iErr) {//\u5bc6\u7801\u9519\u8bef\n\n                // \u5bf9\u5bc6\u7801\u7f16\u7801\u7684\u63a2\u6d4b\n                bool bCheckFinished = false;\n                int iCodecIndex = 0;\n                while (nullptr == zipFile && false == bCheckFinished) {\n                    if (m_listCodecs.length() == iCodecIndex) {\n                        bCheckFinished = true;\n                        if (file.exists()) {\n                            file.remove();\n                        }\n\n                        return ET_WrongPassword;\n                    } else {\n                        // 115645 \u3010\u4e13\u4e1a\u7248\u3011\u30101060\u3011\u3010\u5f52\u6863\u7ba1\u7406\u5668\u3011\u30105.12.0.2\u3011\u65e0\u6cd5\u89e3\u538b\u4e2d\u6587\u5bc6\u7801\u7684zip\u538b\u7f29\u5305\uff08\u542b\u6709\u957f\u540d\u79f0\uff09\n                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());\n                        iCodecIndex++;\n                        zip_error_clear(archive);\n                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);\n                        iErr = zip_error_code_zip(zip_get_error(archive));\n                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//\u5bc6\u7801\u6b63\u786e\n                            bCheckFinished = true;\n                        }\n                    }\n                }\n            } else if (ZIP_ER_NOPASSWD == iErr) {   // \u65e0\u5bc6\u7801\u8f93\u5165\n                return ET_NeedPassword;\n            } else {\n                return ET_FileOpenError;\n            }\n        }\n\n        // \u4ee5\u53ea\u5199\u7684\u65b9\u5f0f\u6253\u5f00\u5f85\u89e3\u538b\u7684\u6587\u4ef6\n        if (file.open(QIODevice::WriteOnly) == false) {\n            zip_fclose(zipFile);\n\n            QList<QString> entryNameList = strDestFileName.split('/');\n            foreach (auto &tmp, entryNameList) {\n                // \u5224\u65ad\u6587\u4ef6\u540d\u662f\u5426\u8fc7\u957f\n                if (NAME_MAX < tmp.toLocal8Bit().length()) {\n                    return ET_LongNameError;\n                }\n            }\n\n            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n            return ET_FileWriteError;\n        }\n\n        // \u5199\u6587\u4ef6\n        QDataStream out(&file);\n        zip_int64_t sum = 0;\n        char buf[READBYTES];\n        int writeSize = 0;\n        double dScale = 1;\n        // \u53f3\u952e\u89e3\u538b\u65f6\u6309\u7167\u6587\u4ef6\u6bd4\u4f8b\u8ba1\u7b97\u5927\u5c0f\n        if (!options.bExistList) {\n            dScale = double(statBuffer.comp_size) / statBuffer.size;\n        }\n        while (sum != zip_int64_t(statBuffer.size)) {\n            if (QThread::currentThread()->isInterruptionRequested()) {\n                break;\n            }\n\n            if (m_bPause) { //\u89e3\u538b\u6682\u505c\n                sleep(1);\n                continue;\n            }\n\n            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));\n\n            if (readBytes < 0) {\n                file.close();\n                zip_fclose(zipFile);\n                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                return ET_FileWriteError;\n            }\n\n            if (out.writeRawData(buf, int(readBytes)) != readBytes) {\n                file.close();\n                zip_fclose(zipFile);\n\n                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // \u5c0f\u4e8ereadBytes\u4f5c\u4e3a\u78c1\u76d8\u7a7a\u95f4\u4e0d\u8db3\u7684\u5224\u65ad\u6807\u51c6\n                    return ET_InsufficientDiskSpace;\n                } else {\n                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());\n                    return ET_FileWriteError;\n                }\n            }\n\n            sum += readBytes;\n            writeSize += readBytes;\n\n            // \u8ba1\u7b97\u8fdb\u5ea6\u5e76\u663e\u793a\uff08\u53f3\u952e\u5feb\u6377\u89e3\u538b\u4f7f\u7528\u538b\u7f29\u5305\u5927\u5c0f\uff0c\u8ba1\u7b97\u6bd4\u4f8b\uff09\n            qExtractSize += readBytes * dScale;\n            emit signalprogress((double(qExtractSize)) * m_dScaleSize);\n        }\n\n        file.close();\n        zip_fclose(zipFile);\n    }\n    if(!isLink) {\n        // \u8bbe\u7f6e\u6587\u4ef6/\u6587\u4ef6\u5939\u6743\u9650\n        file.setPermissions(per);\n\n        // Set mtime for entry.\n        utimbuf times;\n        times.modtime = statBuffer.mtime;\n        utime(strDestFileName.toUtf8().constData(), &times);\n\n        if (restoreParentMtime) {\n            // Restore mtime for parent dir.\n            times.modtime = parent_mtime;\n            utime(parentDir.toUtf8().constData(), &times);\n        }\n    }\n    m_mapLongName[tempFilePathName]++;   // \u4fdd\u5b58\u6587\u4ef6\u8def\u5f84\uff0c\u4e0d\u540c\u76ee\u5f55\u4e0b\u7684\u540c\u540d\u6587\u4ef6\u5206\u5f00\u8ba1\u6570\uff0c\u89e3\u538b\u6210\u529f\uff0c\u6dfb\u52a0\u8ba1\u6570\n    return ET_NoError;\n}\n\nvoid LibzipPlugin::emitProgress(double dPercentage)\n{\n    bool flag = true;\n    while (flag) {\n        if (QThread::currentThread()->isInterruptionRequested()) { //\u7ebf\u7a0b\u7ed3\u675f\n            break;\n        }\n\n        // \u6682\u505c\n        if (m_bPause) {\n            sleep(1);\n            continue;\n        }\n\n        // \u5904\u7406\u5f53\u524d\u6587\u4ef6\u540d\n        if (m_pCurArchive) {\n            if (WT_Add == m_workStatus) {\n                // \u538b\u7f29\u64cd\u4f5c\u663e\u793a\u5f53\u524d\u6b63\u5728\u538b\u7f29\u7684\u6587\u4ef6\u540d\n                zip_uint64_t index = zip_uint64_t(m_curFileCount * dPercentage);\n                // \u53d1\u9001\u5f53\u524d\u6587\u4ef6\u540d\u4fe1\u53f7\n                emit signalCurFileName(m_common->trans2uft8(zip_get_name(m_pCurArchive, index, ZIP_FL_ENC_RAW), m_mapFileCode[zip_int64_t(index)]));\n            } else if (WT_Delete == m_workStatus) {\n                // \u5220\u9664\u64cd\u4f5c\u663e\u793a\u5f53\u524d\u6b63\u5728\u5220\u9664\u7684\u6587\u4ef6\u540d\n                int iSpan = qRound(m_listCurName.count() * dPercentage);    // \u83b7\u53d6\u5360\u6bd4\n                QString strCurFileName;\n                // \u6309\u7167\u8fdb\u5ea6\u5360\u6bd4\u5904\u7406\u5f53\u524d\u6587\u4ef6\u540d\n                if (iSpan < 0) {\n                    strCurFileName = m_listCurName[0];\n                } else if (iSpan >= m_listCurIndex.count()) {\n                    strCurFileName = m_listCurName[m_listCurName.count() - 1];\n                } else {\n                    strCurFileName = m_listCurName[iSpan];\n                }\n\n                // \u53d1\u9001\u5f53\u524d\u6587\u4ef6\u540d\u4fe1\u53f7\n                emit signalCurFileName(strCurFileName);\n            }\n\n        }\n\n        // \u53d1\u9001\u8fdb\u5ea6\u4fe1\u53f7\n        emit signalprogress(dPercentage * 100);\n\n        flag = false;\n    }\n\n    m_bPause = false;\n}\n\nint LibzipPlugin::cancelResult()\n{\n    if (m_bCancel) {\n        m_bCancel = false;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nQByteArray LibzipPlugin::passwordUnicode(const QString &strPassword, int iIndex)\n{\n    if (m_strArchiveName.endsWith(\".zip\")) {\n        // QStringList listCodecName = QStringList() << \"UTF-8\" << \"GB18030\" << \"GBK\" <<\"Big5\"<< \"us-ascii\";\n        int nCount = strPassword.count();\n        bool b = false;\n\n        // \u68c0\u6d4b\u5bc6\u7801\u662f\u5426\u542b\u6709\u4e2d\u6587\n        for (int i = 0 ; i < nCount ; i++) {\n            QChar cha = strPassword.at(i);\n            ushort uni = cha.unicode();\n            if (uni >= 0x4E00 && uni <= 0x9FA5) {   // \u5224\u65ad\u662f\u5426\u662f\u4e2d\u6587\n                b = true;\n                break;\n            }\n        }\n\n        // chinese\n        if (b) {\n            QTextCodec *utf8 = QTextCodec::codecForName(\"UTF-8\");\n            QTextCodec *gbk = QTextCodec::codecForName(m_listCodecs[iIndex].toUtf8().data());\n            // QTextCodec *gbk = QTextCodec::codecForName(\"UTF-8\");\n\n            //utf8 -> \u6240\u9700\u7f16\u7801\n            //1. utf8 -> unicode\n            QString strUnicode = utf8->toUnicode(strPassword.toUtf8().data());\n            //2. unicode -> \u6240\u9700\u7f16\u7801, \u5f97\u5230QByteArray\n            QByteArray gb_bytes = gbk->fromUnicode(strUnicode);\n            return gb_bytes; //\u83b7\u53d6\u5176char *115645 \u3010\u4e13\u4e1a\u7248\u3011\u30101060\u3011\u3010\u5f52\u6863\u7ba1\u7406\u5668\u3011\u30105.12.0.2\u3011\u65e0\u6cd5\u89e3\u538b\u4e2d\u6587\u5bc6\u7801\u7684zip\u538b\u7f29\u5305\uff08\u542b\u6709\u957f\u540d\u79f0\uff09\n        } else {\n            return strPassword.toUtf8();\n        }\n    } else {\n        return strPassword.toUtf8();\n    }\n\n}\n\nbool LibzipPlugin::deleteEntry(int index, zip_t *archive)\n{\n    // \u4e8b\u4ef6\u5faa\u73af\n    if (QThread::currentThread()->isInterruptionRequested()) {\n        if (zip_close(archive)) {\n            // \u53d1\u9001\u4fdd\u5b58\u5931\u8d25\n            emit error((\"Failed to write archive.\"));\n            m_eErrorType = ET_FileWriteError;\n            return false;\n        }\n        return false;\n    }\n\n    int statusDel = zip_delete(archive, zip_uint64_t(index));   // \u83b7\u53d6\u5220\u9664\u72b6\u6001\n    if (-1 == statusDel) {\n        // \u5220\u9664\u5931\u8d25\n        emit error((\"Failed to delete entry: %1\"));\n        m_eErrorType = ET_DeleteError;\n        return false;\n    }\n\n    return true;\n}\n\nbool LibzipPlugin::renameEntry(int index, zip_t *archive, const QString &strAlisa)\n{\n    // \u4e8b\u4ef6\u5faa\u73af\n    if (QThread::currentThread()->isInterruptionRequested()) {\n        if (zip_close(archive)) {\n            // \u53d1\u9001\u4fdd\u5b58\u5931\u8d25\n            emit error((\"Failed to write archive.\"));\n            m_eErrorType = ET_FileWriteError;\n            return false;\n        }\n        return false;\n    }\n\n    int statusDel = zip_rename(archive, zip_uint64_t(index), strAlisa.toUtf8().data());   // \u83b7\u53d6\u91cd\u547d\u540d\u72b6\u6001\n    if (-1 == statusDel) {\n        // \u91cd\u547d\u540d\u5931\u8d25\n        emit error((\"Failed to rename entry: %1\"));\n        m_eErrorType = ET_RenameError;\n        return false;\n    }\n\n    return true;\n}\n\nvoid LibzipPlugin::getIndexBySelEntry(const QList<FileEntry> &listEntry, bool isRename)\n{\n    m_listCurIndex.clear();\n    m_listCurName.clear();\n    ArchiveData stArchiveData = DataManager::get_instance().archiveData();\n\n    // \u7b5b\u9009\u5f85\u63d0\u53d6\u6587\u4ef6/\u6587\u4ef6\u5939\u7d22\u5f15\n    for (FileEntry entry : listEntry) {\n        auto iter = stArchiveData.mapFileEntry.find(entry.strFullPath);\n        for (; iter != stArchiveData.mapFileEntry.end();) {\n            if (!iter.key().startsWith(entry.strFullPath)) {\n                break;\n            } else {\n                // \u83b7\u53d6\u6709\u6548\u7d22\u5f15\n                if (iter.value().iIndex >= 0) {\n                    m_listCurIndex << iter.value().iIndex;      // \u4fdd\u5b58\u6587\u4ef6\u7d22\u5f15\n                    m_listCurName << iter.value().strFullPath;  // \u4fdd\u5b58\u6587\u4ef6\u540d\n                }\n\n                ++iter;\n\n                // \u5982\u679c\u6587\u4ef6\u5939\uff0c\u76f4\u63a5\u8df3\u8fc7\n                if (!entry.strFullPath.endsWith(QDir::separator())) {\n                    break;\n                }\n            }\n        }\n    }\n    if(isRename) return;//\u91cd\u547d\u540d\u4e0d\u505a\u6392\u5e8f\u5904\u7406\n    // \u5347\u5e8f\u6392\u5e8f\n    std::stable_sort(m_listCurIndex.begin(), m_listCurIndex.end());\n}\n"], "filenames": ["3rdparty/libzipplugin/libzipplugin.cpp"], "buggy_code_start_loc": [763], "buggy_code_end_loc": [763], "fixing_code_start_loc": [764], "fixing_code_end_loc": [769], "type": "CWE-22", "message": "Deepin-Compressor is the default archive manager of Deepin Linux OS. Prior to 5.12.21, there's a path traversal vulnerability in deepin-compressor that can be exploited to achieve Remote Command Execution on the target system upon opening crafted archives. Users are advised to update to version 5.12.21 which addresses the issue. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-50255", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-27T17:15:07.847", "lastModified": "2024-01-04T17:03:20.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Deepin-Compressor is the default archive manager of Deepin Linux OS. Prior to 5.12.21, there's a path traversal vulnerability in deepin-compressor that can be exploited to achieve Remote Command Execution on the target system upon opening crafted archives. Users are advised to update to version 5.12.21 which addresses the issue. There are no known workarounds for this vulnerability.\n"}, {"lang": "es", "value": "Deepin-Compressor es el administrador de archivos predeterminado del sistema operativo Deepin Linux. Antes de la versi\u00f3n 5.12.21, hab\u00eda una vulnerabilidad de path traversal en deepin-compressor que se pod\u00eda explotar para lograr la ejecuci\u00f3n remota de comandos en el sistema de destino al abrir archivos manipulados. Se recomienda a los usuarios que actualicen a la versi\u00f3n 5.12.21, que soluciona el problema. No se conocen workarounds para esta vulnerabilidad. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-23"}, {"lang": "en", "value": "CWE-26"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:deepin:deepin-compressor:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.21", "matchCriteriaId": "4B8C269F-A8B9-4677-B050-5C9F7DD7D4FA"}]}]}], "references": [{"url": "https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/linuxdeepin/developer-center/security/advisories/GHSA-rw5r-8p9h-3gp2", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/linuxdeepin/deepin-compressor/commit/82f668c78c133873f5094cfab6e4eabc0b70e4b6"}}