{"buggy_code": ["#!/bin/sh\n# SPDX-FileCopyrightText: 2022 wargio <deroad@libero.it>\n# SPDX-License-Identifier: LGPL-3.0-only\nset -e\n\nNGINX_VERSION=\"$1\"\nN_CPUS=$(nproc)\n\nif [ -z \"$NGINX_VERSION\" ]; then\n\techo \"usage: $0 <nginx version>\"\n\techo \"example: $0 1.12.2\"\n\texit 1\nfi\n\necho \"############################\"\necho \"   NGINX VERSION: $NGINX_VERSION\"\necho \"############################\"\n\nNEW_BUILD=true\nif [ -d \"nginx-tmp\" ] && [ \"$NGINX_VERSION\" == $(cat nginx-tmp/nginx.version) ]; then\n    NEW_BUILD=false\nfi\n\nif $NEW_BUILD ; then\n    rm -rf nginx-source nginx-tmp nginx.tar.gz 2>&1 > /dev/null\n    wget --no-clobber -O nginx.tar.gz \"https://nginx.org/download/nginx-$NGINX_VERSION.tar.gz\"\n    mkdir -p nginx-source nginx-tmp/naxsi_ut/root\n    echo \"$NGINX_VERSION\" > nginx-tmp/nginx.version\n    tar -C nginx-source -xzf nginx.tar.gz --strip-components=1\n    rm nginx.tar.gz\nfi\n\nexport NAXSI_SRC_PATH=$(realpath naxsi_src/)\nexport NAXSI_TMP_PATH=$(realpath nginx-tmp/)\nexport NGINX_TMP_PATH=$(realpath nginx-source/)\n\nif $NEW_BUILD ; then\n    cd \"$NGINX_TMP_PATH\"\n    ./configure --with-cc-opt='-g -O2 -Wextra -Wall -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2' \\\n                --with-ld-opt='-Wl,-z,relro -Wl,-z,now -fPIC' \\\n                --with-select_module \\\n                --conf-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.conf\" \\\n                --http-client-body-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/body/\" \\\n                --http-fastcgi-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/fastcgi/\" \\\n                --http-proxy-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/proxy/\" \\\n                --lock-path=\"$NAXSI_TMP_PATH/nginx.lock\" \\\n                --pid-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.pid\" \\\n                --modules-path=\"$NAXSI_TMP_PATH/naxsi_ut/modules/\" \\\n                --without-mail_pop3_module \\\n                --without-mail_smtp_module \\\n                --without-mail_imap_module \\\n                --with-http_v2_module \\\n                --without-http_uwsgi_module \\\n                --without-http_scgi_module \\\n                --prefix=\"$NAXSI_TMP_PATH/\" \\\n                --add-dynamic-module=\"$NAXSI_SRC_PATH\" \\\n                --error-log-path=\"$NAXSI_TMP_PATH/naxsi_ut/error.log\" \\\n                --conf-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.conf\"\n    cd ..\nfi\n\nmake -C \"$NGINX_TMP_PATH\" -j$N_CPUS install\n", "// SPDX-FileCopyrightText: 2016-2019, Thibault 'bui' Koechlin <tko@nbs-system.com>\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include <ngx_config.h>\n\n#include <naxsi.h>\n#include <naxsi_macros.h>\n#include <naxsi_net.h>\n\n/* used to store locations during the configuration time.\n   then, accessed by the hashtable building feature during \"init\" time. */\n\n/*\n** Static defined rules struct for internal rules.\n** We use those to be able to call is_rule_whitelisted_n() on those\n** rules at any time ;)\n*/\n\n#define InternalRule(var_name, rule_id, block, drop)             \\\n  ngx_http_rule_t var_name = {                                   \\\n    /*type*/ 0,            /*whitelist flag*/ 0,                 \\\n    /*wl_id ptr*/ NULL,    /*rule_id*/ rule_id,                  \\\n    /*log_msg*/ NULL,      /*score*/ 0,                          \\\n    /*sscores*/ NULL,                                            \\\n    /*block*/ block,       /*allow*/ 0,                          \\\n    /*drop*/ drop,         /*log*/ 0,                            \\\n    /*br ptrs*/ NULL                                             \\\n  }\n\nInternalRule(nx_int__weird_request,           1, 1, 0);\nInternalRule(nx_int__big_request,             2, 1, 0);\nInternalRule(nx_int__uncommon_hex_encoding,  10, 1, 0);\nInternalRule(nx_int__uncommon_content_type,  11, 1, 0);\nInternalRule(nx_int__uncommon_url,           12, 1, 0);\nInternalRule(nx_int__uncommon_post_format,   13, 1, 0);\nInternalRule(nx_int__uncommon_post_boundary, 14, 1, 0);\nInternalRule(nx_int__invalid_json,           15, 1, 0);\nInternalRule(nx_int__empty_post_body,        16, 1, 0);\nInternalRule(nx_int__libinject_sql,          17, 1, 0);\nInternalRule(nx_int__libinject_xss,          18, 1, 0);\nInternalRule(nx_int__no_rules,               19, 0, 1);\nInternalRule(nx_int__bad_utf8,               20, 0, 1);\nInternalRule(nx_int__illegal_host_header,    21, 0, 1);\n\n#define naxsi_error_fatal(ctx, r, ...)                                                             \\\n  do {                                                                                             \\\n    if (ctx)                                                                                       \\\n      ctx->block = 1;                                                                              \\\n    if (ctx)                                                                                       \\\n      ctx->drop = 1;                                                                               \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,                                                              \\\n                  r->connection->log,                                                              \\\n                  0,                                                                               \\\n                  \"XX-******** NGINX NAXSI INTERNAL ERROR ********\");                              \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, __VA_ARGS__);                         \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,                                                              \\\n                  r->connection->log,                                                              \\\n                  0,                                                                               \\\n                  \"XX-func:%s file:%s line:%d\",                                                    \\\n                  __func__,                                                                        \\\n                  __FILE__,                                                                        \\\n                  __LINE__);                                                                       \\\n    if (r && r->uri.data)                                                                          \\\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-uri:%s\", r->uri.data);          \\\n  } while (0)\n\nvoid\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r);\nint\nngx_http_process_basic_rule_buffer(ngx_str_t* str, ngx_http_rule_t* rl, ngx_int_t* match);\nvoid\nngx_http_naxsi_payload_handler(ngx_http_request_t* r);\nint\nngx_http_basestr_ruleset_n(ngx_pool_t*             pool,\n                           ngx_str_t*              name,\n                           ngx_str_t*              value,\n                           ngx_array_t*            rules,\n                           ngx_http_request_t*     req,\n                           ngx_http_request_ctx_t* ctx,\n                           naxsi_match_zone_t      zone);\nvoid\nngx_http_naxsi_body_parse(ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_naxsi_main_conf_t* main_cf);\n\nvoid\nngx_http_naxsi_rawbody_parse(ngx_http_request_ctx_t* ctx,\n                             ngx_http_request_t*     r,\n                             u_char*                 src,\n                             u_int                   len);\nunsigned char*\nngx_utf8_check(ngx_str_t* str);\n\n#if NGX_PCRE2\n/*\n * variables to use pcre2\n */\nstatic pcre2_match_data* ngx_pcre2_match_data;\nstatic ngx_uint_t        ngx_pcre2_match_data_size;\n\n/*\n * helper function to use pcre2\n */\nngx_int_t\nngx_pcre2_exec(ngx_regex_t*   re,\n               unsigned char* str,\n               unsigned int   len,\n               ngx_int_t      tmp_idx,\n               int*           captures,\n               ngx_uint_t     size)\n{\n  size_t*    ov;\n  ngx_int_t  rc;\n  ngx_uint_t n, i;\n\n  /*\n   * The pcre2_match() function might allocate memory for backtracking\n   * frames, typical allocations are from 40k and above.  So the allocator\n   * is configured to do direct allocations from heap during matching.\n   */\n\n  if (ngx_pcre2_match_data == NULL || size > ngx_pcre2_match_data_size) {\n    /*\n     * Allocate a match data if not yet allocated or smaller than\n     * needed.\n     */\n\n    if (ngx_pcre2_match_data) {\n      pcre2_match_data_free(ngx_pcre2_match_data);\n    }\n\n    ngx_pcre2_match_data_size = size;\n    ngx_pcre2_match_data      = pcre2_match_data_create(size / 3, NULL);\n\n    if (ngx_pcre2_match_data == NULL) {\n      rc = PCRE2_ERROR_NOMEMORY;\n      goto failed;\n    }\n  }\n\n  rc = pcre2_match(re, str, len, tmp_idx, 0, ngx_pcre2_match_data, NULL);\n\n  if (rc < 0) {\n    goto failed;\n  }\n\n  n  = pcre2_get_ovector_count(ngx_pcre2_match_data);\n  ov = pcre2_get_ovector_pointer(ngx_pcre2_match_data);\n\n  if (n > size / 3) {\n    n = size / 3;\n  }\n\n  for (i = 0; i < n; i++) {\n    captures[i * 2]     = ov[i * 2];\n    captures[i * 2 + 1] = ov[i * 2 + 1];\n  }\n\nfailed:\n\n  return rc;\n}\n#endif\n\n/*\n** in : string to inspect, associated rule\n** does : apply the rule on the string, return 1 if matched,\n**    0 else and -1 on error\n*/\nint\nngx_http_process_basic_rule_buffer(ngx_str_t* str, ngx_http_rule_t* rl, ngx_int_t* nb_match)\n\n{\n  ngx_int_t      match, tmp_idx, len;\n  unsigned char* ret;\n  int            captures[30];\n  if (!rl->br || !nb_match)\n    return (-1);\n\n  *nb_match = 0;\n  if (rl->br->match_type == RX && rl->br->rx) {\n    tmp_idx = 0;\n    len     = str->len;\n    while\n#if (NGX_PCRE2)\n      (tmp_idx < len &&\n       (match = ngx_pcre2_exec(rl->br->rx->regex, str->data, str->len, tmp_idx, captures, 30)) >= 0)\n#elif defined nginx_version && (nginx_version >= 1002002 && nginx_version != 1003000)\n      (tmp_idx < len && (match = pcre_exec(rl->br->rx->regex->code,\n                                           0,\n                                           (const char*)str->data,\n                                           str->len,\n                                           tmp_idx,\n                                           0,\n                                           captures,\n                                           30)) >= 0)\n#elif defined nginx_version && (nginx_version > 1001011)\n      (tmp_idx < len && (match = pcre_exec(rl->br->rx->regex->pcre,\n                                           0,\n                                           (const char*)str->data,\n                                           str->len,\n                                           tmp_idx,\n                                           0,\n                                           captures,\n                                           30)) >= 0)\n#elif defined nginx_version && (nginx_version <= 1001011)\n      (tmp_idx < len &&\n       (match = pcre_exec(\n          rl->br->rx->regex, 0, (const char*)str->data, str->len, tmp_idx, 0, captures, 30)) >= 0)\n#elif defined nginx_version\n#error \"Inconsistent nginx version.\"\n      (0)\n#else\n#error \"nginx_version not defined.\"\n      (0)\n#endif\n    {\n      *nb_match += match;\n      tmp_idx = captures[1];\n    }\n    if (*nb_match > 0) {\n      if (rl->br->negative)\n        return (0);\n      else\n        return (1);\n    } else if (*nb_match == 0) {\n      if (rl->br->negative)\n        return (1);\n      else\n        return (0);\n    }\n    return (-1);\n  } else if (rl->br->match_type == STR && rl->br->str) {\n    match   = 0;\n    tmp_idx = 0;\n    while (1) {\n      ret = (unsigned char*)strfaststr((unsigned char*)str->data + tmp_idx,\n                                       (unsigned int)str->len - tmp_idx,\n                                       (unsigned char*)rl->br->str->data,\n                                       (unsigned int)rl->br->str->len);\n      if (ret) {\n        match     = 1;\n        *nb_match = *nb_match + 1;\n      } else\n        break;\n      if (nb_match && ret < (str->data + str->len)) {\n        tmp_idx = (ret - str->data) + 1;\n        if (tmp_idx > (int)(str->len - 1))\n          break;\n      } else\n        break;\n    }\n    if (match) {\n      if (rl->br->negative)\n        return (0);\n      else\n        return (1);\n    } else {\n      if (rl->br->negative)\n        return (1);\n      else\n        return (0);\n    }\n  } else if (rl->br->match_type == LIBINJ_XSS) {\n    if (libinjection_xss((const char*)str->data, str->len) == 1)\n      return (1);\n  } else if (rl->br->match_type == LIBINJ_SQL) {\n    sfilter state;\n\n    libinjection_sqli_init(&state, (const char*)str->data, str->len, FLAG_NONE);\n    if (libinjection_is_sqli(&state) == 1)\n      return (1);\n  }\n\n  return (0);\n}\n\n/*\n** Check if a (matched) rule is whitelisted.\n** This func will look for the current URI in the wlr_url_hash [hashtable]\n** It will also look for varname in the wlr_body|args|headers_hash [hashtable]\n** and It will also look for disabled rules.\n** 1 - If the rule is disabled, it's whitelisted\n** 2 - If a matching URL is found, check if the further information confirms\n*that the rule should be whitelisted\n** ($URL:/bar|$ARGS_VAR:foo : it's not because URL matches that we should\n*whitelist rule)\n** 3 - If a matching varname is found, check zone and rules IDs.\n** [TODO] : Add mz matches with style BODY|HEADERS|...\n** returns (1) if rule is whitelisted, else (0)\n*/\n\nint\nngx_http_naxsi_is_whitelist_adapted(ngx_http_whitelist_rule_t* b,\n                                    ngx_str_t*                 name,\n                                    naxsi_match_zone_t         zone,\n                                    ngx_http_rule_t*           r,\n                                    ngx_http_request_t*        req,\n                                    naxsi_match_type_t         type,\n                                    ngx_int_t                  target_name)\n{\n  /* if something was found, check the rule ID */\n  if (!b) {\n    return (0);\n  }\n  /* FILE_EXT zone is just a hack, as it indeed targets BODY */\n  if (zone == FILE_EXT)\n    zone = BODY;\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"Possible whitelist ... check...\");\n\n  /* if whitelist targets arg name, but the rules hit content*/\n  if (b->target_name && !target_name) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"whitelist targets name, but rule matched content.\");\n    return (0);\n  }\n  /* if if the whitelist target contents, but the rule hit arg name*/\n  if (!b->target_name && target_name) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"whitelist targets content, but rule matched name.\");\n    return (0);\n  }\n\n  if (type == NAME_ONLY) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"Name match in zone %s\",\n             zone == ARGS      ? \"ARGS\"\n             : zone == BODY    ? \"BODY\"\n             : zone == HEADERS ? \"HEADERS\"\n                               : \"UNKNOWN!!!!!\");\n    // False Positive, there was a whitelist that matches the argument name,\n    // But is was actually matching an existing URI name.\n    if (b->zone == ANY && (zone == ARGS || zone == BODY || zone == HEADERS)) {\n      return (nx_check_ids(r->rule_id, b->ids));\n    } else if (zone != b->zone || b->uri_only) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, name match, but WL was only on URL.\");\n      return (0);\n    }\n    return (nx_check_ids(r->rule_id, b->ids));\n  }\n  if (type == URI_ONLY || type == MIXED) {\n    /* zone must match */\n    if (b->uri_only && type != URI_ONLY) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, type is URI_ONLY, but not whitelist\");\n      return (0);\n    }\n\n    if (zone != b->zone && b->zone != ANY) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, URL match, but not zone\");\n      return (0);\n    }\n\n    return (nx_check_ids(r->rule_id, b->ids));\n  }\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"finished wl check, failed.\");\n\n  return (0);\n}\n\nngx_http_whitelist_rule_t*\nnx_find_wl_in_hash(ngx_http_request_t*        req,\n                   ngx_str_t*                 mstr,\n                   ngx_http_naxsi_loc_conf_t* cf,\n                   naxsi_match_zone_t         zone)\n{\n  ngx_int_t                  k       = 0;\n  ngx_http_whitelist_rule_t* b       = NULL;\n  ngx_str_t                  scratch = { .data = NULL, .len = mstr->len };\n\n  scratch.data = ngx_pcalloc(req->pool, mstr->len + 1);\n  if (!scratch.data) {\n    return NULL;\n  }\n\n  k = ngx_hash_strlow(scratch.data, mstr->data, mstr->len);\n\n  if ((zone == BODY || zone == FILE_EXT || zone == ANY) && cf->wlr_body_hash &&\n      cf->wlr_body_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_body_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == HEADERS || (zone == ANY && !b)) && cf->wlr_headers_hash &&\n      cf->wlr_headers_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_headers_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == URL || (zone == ANY && !b)) && cf->wlr_url_hash && cf->wlr_url_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_url_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == ARGS || (zone == ANY && !b)) && cf->wlr_args_hash && cf->wlr_args_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_args_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"find wl in hash %d %p %s.\",\n           k,\n           b,\n           zone == ARGS       ? \"ARGS\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == BODY     ? \"BODY\"\n           : zone == URL      ? \"URL\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n           : zone == ANY      ? \"ANY\"\n                              : \"UNKNOWN\");\n  ngx_pfree(req->pool, scratch.data);\n  return (b);\n}\n\nint\nnaxsi_can_ignore_ip(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_ips || cf->ignore_ips_ha.keys.nelts < 1) {\n    return 0;\n  }\n  char ip_str[INET6_ADDRSTRLEN + 1] = { 0 };\n  if (!naxsi_parse_ip(ipstr, NULL, ip_str)) {\n    return 0;\n  }\n\n  ngx_str_t  scratch = { .data = (unsigned char*)ip_str, .len = strlen(ip_str) };\n  ngx_uint_t k       = ngx_hash_key(scratch.data, scratch.len);\n  return ngx_hash_find(cf->ignore_ips, k, (u_char*)scratch.data, scratch.len) != NULL ? 1 : 0;\n}\n\nint\nnaxsi_can_ignore_cidr(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_cidrs) {\n    return 0;\n  }\n  ngx_uint_t i;\n  ip_t       ip = ip_zero;\n  if (!naxsi_parse_ip(ipstr, &ip, NULL)) {\n    return 0;\n  }\n\n  for (i = 0; i < cf->ignore_cidrs->nelts; i++) {\n    cidr_t* cidr = &((cidr_t*)cf->ignore_cidrs->elts)[i];\n    if (naxsi_is_in_subnet(cidr, &ip)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n#define custloc_array(x) ((ngx_http_custom_rule_location_t*)x)\n\n/*\n** wrapper used for regex matchzones. Should be used by classic basestr* as\n*well.\n*/\nint\nngx_http_naxsi_pcre_wrapper(ngx_regex_compile_t* rx, unsigned char* str, unsigned int len)\n{\n  int match;\n  int captures[30];\n\n#if (NGX_PCRE2)\n  match = ngx_pcre2_exec(rx->regex, str, len, 0, captures, 1);\n#elif defined nginx_version && (nginx_version >= 1002002 && nginx_version != 1003000)\n  match = pcre_exec(rx->regex->code, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version && (nginx_version > 1001011)\n  match = pcre_exec(rx->regex->pcre, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version && (nginx_version <= 1001011)\n  match = pcre_exec(rx->regex, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version\n#error \"Inconsistent nginx version.\"\n  return (0);\n#else\n#error \"nginx_version not defined.\"\n  return (0);\n#endif\n  if (match > 0)\n    return (1);\n  return (match);\n}\n\nint\nngx_http_naxsi_is_rule_whitelisted_rx(ngx_http_request_t*        req,\n                                      ngx_http_naxsi_loc_conf_t* cf,\n                                      ngx_http_rule_t*           r,\n                                      ngx_str_t*                 name,\n                                      naxsi_match_zone_t         zone,\n                                      ngx_int_t                  target_name)\n{\n  ngx_http_rule_t* p;\n  ngx_uint_t       i, x;\n  int              rx_match, violation;\n\n  /* Look it up in regexed whitelists for matchzones */\n  if (!cf->rxmz_wlr || cf->rxmz_wlr->nelts < 1) {\n    return (0);\n  }\n  NX_DEBUG(_debug_wl_debug_rx,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"RXX - Trying to find rx for %v\",\n           name);\n\n  for (i = 0; i < cf->rxmz_wlr->nelts; i++) {\n\n    p = (((ngx_http_rule_t**)(cf->rxmz_wlr->elts))[i]);\n\n    if (!p->br || !p->br->custom_locations || p->br->custom_locations->nelts < 1) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"Rule pushed to RXMZ, but has no custom_location.\");\n\n      continue;\n    }\n\n    /*\n    ** once we have pointer to the rule :\n    ** - go through each custom location (ie. ARGS_VAR_X:foobar*)\n    ** - verify that regular expressions match. If not, it means whitelist does\n    *not apply.\n    */\n\n    NX_DEBUG(_debug_wl_debug_rx,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"%d/%d RXMZ rule has %d custom locations\",\n             i,\n             cf->rxmz_wlr->nelts,\n             p->br->custom_locations->nelts);\n\n    if (p->br->zone != (ngx_int_t)zone && p->br->zone != ANY) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"%d/%d Not targeting same zone.\",\n               i,\n               cf->rxmz_wlr->nelts);\n\n      continue;\n    }\n\n    if (target_name != p->br->target_name) {\n      NX_DEBUG(\n        _debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"only one target_name\");\n\n      continue;\n    }\n\n    for (x = 0, violation = 0; x < p->br->custom_locations->nelts && violation == 0; x++) {\n      /* does custom location targets a body var ? */\n      if (custloc_array(p->br->custom_locations->elts)[x].body_var) {\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, name->data, name->len);\n        if (rx_match < 0) {\n          violation = 1;\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[BODY] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   name);\n\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[BODY] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 name);\n      }\n\n      if (custloc_array(p->br->custom_locations->elts)[x].args_var) {\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, name->data, name->len);\n        if (rx_match < 0) {\n          violation = 1;\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[ARGS] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   name);\n\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[ARGS] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 name);\n      }\n\n      if (custloc_array(p->br->custom_locations->elts)[x].specific_url) {\n        /* if there is a specific url, check it regardless of zone. */\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, req->uri.data, req->uri.len);\n        if (rx_match < 0) {\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[URI] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   &(req->uri));\n\n          violation = 1;\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[URI] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 &(req->uri));\n      }\n    }\n    if (violation == 0) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"wut, rule whitelisted by rx.\");\n\n      if (nx_check_ids(r->rule_id, p->wlid_array) == 1)\n        return (1);\n    } else {\n      NX_DEBUG(_debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"not good ----\");\n    }\n  }\n  return (0);\n}\n\nint\nngx_http_naxsi_is_rule_whitelisted_n(ngx_http_request_t*        req,\n                                     ngx_http_naxsi_loc_conf_t* cf,\n                                     ngx_http_rule_t*           r,\n                                     ngx_str_t*                 name,\n                                     naxsi_match_zone_t         zone,\n                                     ngx_int_t                  target_name)\n{\n  ngx_int_t                  k            = 0;\n  ngx_http_whitelist_rule_t* b            = NULL;\n  unsigned int               i            = 0;\n  ngx_http_rule_t**          dr           = NULL;\n  ngx_str_t                  tmp_hashname = { 0 };\n  ngx_str_t                  nullname     = ngx_null_string;\n\n  /* if name is NULL, replace it by an empty string */\n  if (!name)\n    name = &nullname;\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"is rule [%d] whitelisted in zone %s for item %V\",\n           r->rule_id,\n           zone == ARGS       ? \"ARGS\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == BODY     ? \"BODY\"\n           : zone == URL      ? \"URL\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n           : zone == ANY      ? \"ANY\"\n                              : \"UNKNOWN\",\n           name);\n  NX_DEBUG(_debug_whitelist_compat && target_name,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"extra: exception happened in |NAME\");\n\n  /* Check if the rule is part of disabled rules for this location */\n  if (cf->disabled_rules) {\n    dr = cf->disabled_rules->elts;\n    for (i = 0; i < cf->disabled_rules->nelts; i++) {\n\n      /* Is rule disabled ? */\n      if (nx_check_ids(r->rule_id, dr[i]->wlid_array)) {\n\n        NX_DEBUG(_debug_whitelist_compat,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"rule %d is disabled somewhere\",\n                 r->rule_id);\n        /* if it doesn't specify zone, skip zone-check */\n        if (!dr[i]->br) {\n          NX_DEBUG(_debug_whitelist_compat,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"no zone, skip zone-check\");\n          continue;\n        }\n\n        /* If rule target nothing, it's whitelisted everywhere */\n        if (!(dr[i]->br->args || dr[i]->br->headers || dr[i]->br->body || dr[i]->br->url)) {\n          NX_DEBUG(_debug_whitelist_compat,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"rule %d is fully disabled\",\n                   r->rule_id);\n          return (1);\n        }\n\n        /* if exc is in name, but rule is not specificaly disabled for name (and\n         * targets a zone)  */\n        if (target_name != dr[i]->br->target_name)\n          continue;\n\n        switch (zone) {\n          case ANY:\n            if (dr[i]->br->any) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in ANY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case ARGS:\n            if (dr[i]->br->args) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in ARGS\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case HEADERS:\n            if (dr[i]->br->headers) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in HEADERS\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case BODY:\n            if (dr[i]->br->body) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in BODY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case RAW_BODY:\n            if (dr[i]->br->body) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in BODY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case FILE_EXT:\n            if (dr[i]->br->file_ext) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in FILE_EXT\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case URL:\n            if (dr[i]->br->url) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in URL zone:%d\",\n                       r->rule_id,\n                       zone);\n              return (1);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing varname [%V]\",\n           name);\n  /*\n  ** check for ARGS_VAR:x(|NAME) whitelists.\n  ** (name) or (#name)\n  */\n  if (name->len > 0) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing varname [%V] (rule:%d) - 'wl:X_VAR:%V'\",\n             name,\n             r->rule_id,\n             name);\n    /* try to find in hashtables */\n    b = nx_find_wl_in_hash(req, name, cf, zone);\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, NAME_ONLY, target_name)) {\n      return (1);\n    }\n    /*prefix hash with '#', to find whitelists that would be done only on\n     * ARGS_VAR:X|NAME */\n    tmp_hashname.len = name->len + 1;\n    /* too bad we have to realloc just to add the '#' */\n    tmp_hashname.data    = ngx_pcalloc(req->pool, tmp_hashname.len + 1);\n    tmp_hashname.data[0] = '#';\n    memcpy(tmp_hashname.data + 1, name->data, name->len);\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing varname [%V] (rule:%d) - 'wl:X_VAR:%V|NAME'\",\n             name,\n             r->rule_id,\n             name);\n    b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n    ngx_pfree(req->pool, tmp_hashname.data);\n    tmp_hashname.data = NULL;\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, NAME_ONLY, target_name)) {\n      return (1);\n    }\n  }\n\n  /* Plain URI whitelists */\n  if (cf->wlr_url_hash && cf->wlr_url_hash->size > 0) {\n\n    /* check the URL no matter what zone we're in */\n    tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 1);\n    /* mimic find_wl_in_hash, we are looking in a different hashtable */\n    if (!tmp_hashname.data) {\n      return (0);\n    }\n    tmp_hashname.len = req->uri.len;\n    k                = ngx_hash_strlow(tmp_hashname.data, req->uri.data, req->uri.len);\n\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing uri [%V] (rule:%d) 'wl:$URI:%V|*' %d\",\n             &req->uri,\n             r->rule_id,\n             &tmp_hashname,\n             k);\n\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_url_hash, k, (u_char*)tmp_hashname.data, tmp_hashname.len);\n    ngx_pfree(req->pool, tmp_hashname.data);\n    tmp_hashname.data = NULL;\n\n    NX_DEBUG(_debug_whitelist_compat, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"%p\", b);\n\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n      return (1);\n    }\n  }\n\n  /* Lookup for $URL|URL (uri)*/\n  tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 1);\n  if (!tmp_hashname.data) {\n    return (0);\n  }\n  tmp_hashname.len = req->uri.len;\n  ngx_memcpy(tmp_hashname.data, req->uri.data, req->uri.len);\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing uri#1 [%V] (rule:%d) ($URL:%V|URI)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n  tmp_hashname.data = NULL;\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n    return (1);\n  }\n\n  /* Looking $URL:x|ZONE|NAME */\n  tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 2);\n  /* should make it sound crit isn't it ?*/\n  if (!tmp_hashname.data)\n    return (0);\n  tmp_hashname.len     = req->uri.len + 1;\n  tmp_hashname.data[0] = '#';\n  ngx_memcpy(tmp_hashname.data + 1, req->uri.data, req->uri.len);\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing uri#3 [%V] (rule:%d) ($URL:%V|ZONE|NAME)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n  tmp_hashname.data = NULL;\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n    return (1);\n  }\n\n  /* Maybe it was $URL+$VAR (uri#name) or (#uri#name) */\n  tmp_hashname.len = req->uri.len + 1 + name->len;\n  /* one extra byte for target_name '#' */\n  tmp_hashname.data = ngx_pcalloc(req->pool, tmp_hashname.len + 2);\n  if (target_name) {\n    tmp_hashname.len++;\n    strcat((char*)tmp_hashname.data, \"#\");\n  }\n  strncat((char*)tmp_hashname.data, (char*)req->uri.data, req->uri.len);\n  strcat((char*)tmp_hashname.data, \"#\");\n  strncat((char*)tmp_hashname.data, (char*)name->data, name->len);\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing MIX [%V] (rule:%d) ($URL:%V|$X_VAR:y) or ($URL:%V|$X_VAR:y|NAME)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &(tmp_hashname), cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, MIXED, target_name)) {\n    return (1);\n  }\n\n  /*\n  ** Look it up in regexed whitelists for matchzones\n  */\n  if (ngx_http_naxsi_is_rule_whitelisted_rx(req, cf, r, name, zone, target_name) == 1) {\n    NX_DEBUG(\n      _debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"Whitelisted by RX !\");\n\n    return (1);\n  }\n\n  return (0);\n}\n\n/*\n** Create log lines, possibly splitted\n** and linked by random numbers.\n*/\n#define MAX_LINE_SIZE (NGX_MAX_ERROR_STR - 100)\n#define MAX_SEED_LEN  17 /*seed_start=10000*/\n\nngx_str_t*\nngx_http_append_log(ngx_http_request_t* r, ngx_array_t* ostr, ngx_str_t* fragment, u_int* offset)\n{\n  u_int        seed, sub;\n  static u_int prev_seed = 0;\n\n  /*\n  ** avoid random collisions, as we % 1000 them,\n  ** this is very likely to happen !\n  */\n\n  /*\n  ** extra space has been reserved to append the seed.\n  */\n#ifndef _WIN32\n  while ((seed = random() % 1000) == prev_seed)\n#else  // _WIN32\n  while ((seed = rand() % 1000) == prev_seed)\n#endif // !_WIN32\n    ;\n  sub           = snprintf((char*)(fragment->data + *offset), MAX_SEED_LEN, \"&seed_start=%d\", seed);\n  fragment->len = *offset + sub;\n  fragment      = ngx_array_push(ostr);\n  if (!fragment)\n    return (NULL);\n  fragment->data = ngx_pcalloc(r->pool, MAX_LINE_SIZE + 1);\n  if (!fragment->data)\n    return (NULL);\n  sub       = snprintf((char*)fragment->data, MAX_SEED_LEN, \"seed_end=%d\", seed);\n  prev_seed = seed;\n  *offset   = sub;\n  return (fragment);\n}\n\nngx_int_t\nnaxsi_create_log_array(ngx_http_request_ctx_t* ctx,\n                       ngx_http_request_t*     r,\n                       ngx_array_t*            ostr,\n                       ngx_str_t**             ret_uri)\n{\n  u_int                     sz_left, sub, offset = 0, i;\n  ngx_str_t *               fragment, *tmp_uri;\n  ngx_http_special_score_t* sc;\n  const char*               fmt_base   = \"ip=%.*s&server=%.*s&uri=%.*s&config=%.*s&rid=\";\n  const char*               fmt_score  = \"&cscore%d=%.*s&score%d=%zu\";\n  const char*               fmt_rm     = \"&zone%d=%s&id%d=%d&var_name%d=%.*s\";\n  const char*               fmt_config = \"\";\n\n  if (ctx->learning) {\n    fmt_config = ctx->drop ? \"learning-drop\" : \"learning\";\n  } else if (ctx->drop) {\n    fmt_config = \"drop\";\n  } else if (ctx->block) {\n    fmt_config = \"block\";\n  } else if (ctx->ignore) {\n    fmt_config = \"ignore\";\n  }\n\n  ngx_http_matched_rule_t* mr;\n  char                     tmp_zone[30];\n\n  tmp_uri = ngx_pcalloc(r->pool, sizeof(ngx_str_t));\n  if (!tmp_uri)\n    return (NGX_ERROR);\n  *ret_uri = tmp_uri;\n\n  if (r->uri.len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {\n    r->uri.len /= 4;\n  }\n\n  tmp_uri->len  = r->uri.len + (2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS));\n  tmp_uri->data = ngx_pcalloc(r->pool, tmp_uri->len + 1);\n  ngx_escape_uri(tmp_uri->data, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS);\n\n  fragment = ngx_array_push(ostr);\n  if (!fragment) {\n    return (NGX_ERROR);\n  }\n  fragment->data = ngx_pcalloc(r->pool, MAX_LINE_SIZE + 1);\n  if (!fragment->data) {\n    return (NGX_ERROR);\n  }\n  sub = offset = 0;\n  /* we keep extra space for seed*/\n  sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - 1;\n\n  /*\n  ** don't handle uri > 4k, string will be split\n  */\n\n  sub = snprintf((char*)fragment->data,\n                 sz_left,\n                 fmt_base,\n                 r->connection->addr_text.len,\n                 r->connection->addr_text.data,\n                 r->headers_in.server.len,\n                 r->headers_in.server.data,\n                 tmp_uri->len,\n                 tmp_uri->data,\n                 strlen(fmt_config),\n                 fmt_config);\n\n  if (sub >= sz_left) {\n    sub = sz_left - 1;\n  }\n  sz_left -= sub;\n  offset += sub;\n\n  sub = NAXSI_REQUEST_ID_SIZE << 1;\n  if (sz_left > (100 + sub)) {\n    ngx_hex_dump(fragment->data + offset, ctx->request_id, NAXSI_REQUEST_ID_SIZE);\n    if (sub >= sz_left) {\n      sub = sz_left - 1;\n    }\n    sz_left -= sub;\n    offset += sub;\n  }\n\n  /*\n  ** if URI exceeds the MAX_LINE_SIZE, log directly, avoid null deref (#178)\n  */\n  if (sz_left < 100) {\n    fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n    if (!fragment)\n      return (NGX_ERROR);\n    sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n  }\n\n  /*\n  ** append scores\n  */\n  for (i = 0; ctx->special_scores && i < ctx->special_scores->nelts; i++) {\n    sc = ctx->special_scores->elts;\n    if (sc[i].sc_score != 0) {\n      sub = snprintf(0, 0, fmt_score, i, sc[i].sc_tag->len, sc[i].sc_tag->data, i, sc[i].sc_score);\n      if (sub >= sz_left) {\n        /*\n        ** ngx_http_append_log will add seed_start and seed_end, and adjust the\n        *offset.\n        */\n        fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n        if (!fragment)\n          return (NGX_ERROR);\n        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n      }\n      sub = snprintf((char*)(fragment->data + offset),\n                     sz_left,\n                     fmt_score,\n                     i,\n                     sc[i].sc_tag->len,\n                     sc[i].sc_tag->data,\n                     i,\n                     sc[i].sc_score);\n      if (sub >= sz_left) {\n        sub = sz_left - 1;\n      }\n      offset += sub;\n      sz_left -= sub;\n    }\n  }\n  /*\n  ** and matched zone/id/name\n  */\n  if (ctx->matched) {\n    mr  = ctx->matched->elts;\n    sub = 0;\n    i   = 0;\n    do {\n      memset(tmp_zone, 0, sizeof(tmp_zone));\n      if (mr[i].body_var)\n        strcat(tmp_zone, \"BODY\");\n      else if (mr[i].args_var)\n        strcat(tmp_zone, \"ARGS\");\n      else if (mr[i].headers_var)\n        strcat(tmp_zone, \"HEADERS\");\n      else if (mr[i].url)\n        strcat(tmp_zone, \"URL\");\n      else if (mr[i].file_ext)\n        strcat(tmp_zone, \"FILE_EXT\");\n      if (mr[i].target_name)\n        strcat(tmp_zone, \"|NAME\");\n\n      ngx_str_t tmp_val;\n\n      if (mr[i].name->len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {\n        mr[i].name->len /= 4;\n      }\n\n      tmp_val.len =\n        mr[i].name->len +\n        (2 * ngx_escape_uri(NULL, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT));\n\n      tmp_val.data = ngx_pcalloc(r->pool, tmp_val.len + 1);\n      ngx_escape_uri(tmp_val.data, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT);\n\n      sub =\n        snprintf(0, 0, fmt_rm, i, tmp_zone, i, mr[i].rule->rule_id, i, tmp_val.len, tmp_val.data);\n      /*\n      ** This one would not fit :\n      ** append a seed to the current fragment,\n      ** and start a new one\n      */\n      if (sub >= sz_left) {\n        fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n        if (!fragment)\n          return (NGX_ERROR);\n        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n      }\n      sub = snprintf((char*)fragment->data + offset,\n                     sz_left,\n                     fmt_rm,\n                     i,\n                     tmp_zone,\n                     i,\n                     mr[i].rule->rule_id,\n                     i,\n                     tmp_val.len,\n                     tmp_val.data);\n      if (sub >= sz_left)\n        sub = sz_left - 1;\n      offset += sub;\n      sz_left -= sub;\n      i += 1;\n    } while (i < ctx->matched->nelts);\n  }\n  fragment->len = offset;\n  return (NGX_HTTP_OK);\n}\n\nchar*\nreplace_str(const char* s, const char* oldW, const char* newW)\n{\n  char* result;\n  int   i, cnt = 0;\n  int   newWlen = strlen(newW);\n  int   oldWlen = strlen(oldW);\n\n  // Counting the number of times old word\n  // occur in the string\n  for (i = 0; s[i] != '\\0'; i++) {\n    if (strstr(&s[i], oldW) == &s[i]) {\n      cnt++;\n      // Jumping to index after the old word.\n      i += oldWlen - 1;\n    }\n  }\n\n  // Making new string of enough length\n  result = (char*)malloc(i + cnt * (newWlen - oldWlen) + 1);\n\n  if (!result)\n    return 0;\n\n  i = 0;\n  while (*s) {\n    // compare the substring with the result\n    if (strstr(s, oldW) == s) {\n      strcpy(&result[i], newW);\n      i += newWlen;\n      s += oldWlen;\n    } else {\n      result[i++] = *s++;\n    }\n  }\n\n  result[i] = '\\0';\n  return result;\n}\n\nngx_int_t\nngx_http_output_forbidden_page(ngx_http_request_ctx_t* ctx, ngx_http_request_t* r)\n{\n  ngx_str_t *                tmp_uri, denied_args;\n  ngx_str_t                  empty = ngx_string(\"\");\n  ngx_http_naxsi_loc_conf_t* cf;\n  ngx_array_t*               ostr;\n  ngx_table_elt_t*           h;\n  unsigned int               i = 0;\n\n  cf = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  /* get array of signatures strings */\n  ostr = ngx_array_create(r->pool, 1, sizeof(ngx_str_t));\n  if (naxsi_create_log_array(ctx, r, ostr, &tmp_uri) != NGX_HTTP_OK) {\n    return (NGX_ERROR);\n  }\n\n  if (!ctx->json_log) {\n    for (i = 0; i < ostr->nelts; i++) {\n      ngx_log_error(NGX_LOG_ERR,\n                    cf->log ? cf->log : r->connection->log,\n                    0,\n                    \"NAXSI_FMT: %s\",\n                    ((ngx_str_t*)ostr->elts)[i].data);\n    }\n  } else {\n    const char* hex  = \"0123456789abcdef\";\n    ngx_str_t*  elts = (ngx_str_t*)ostr->elts;\n    for (i = 0; i < ostr->nelts; i++) {\n      char json[NAXSI_LOG_JSON_STRLEN] = { 0 };\n      // line only\n      const char* line = (const char*)elts[i].data;\n      char*       curr = json + 2;\n      char*       end  = (curr + sizeof(json)) - 4;\n\n      json[0] = '{';\n      json[1] = '\"';\n\n      size_t j;\n      for (j = 0; line[j] && curr < end; j++) {\n        if (line[j] == '=') {\n          *curr = '\"';\n          curr++;\n          break_if(curr >= end);\n          *curr = ':';\n          curr++;\n          break_if(curr >= end);\n          *curr = '\"';\n        } else if (line[j] == '&') {\n          *curr = '\"';\n          curr++;\n          break_if(curr >= end);\n          *curr = ',';\n          curr++;\n          break_if(curr >= end);\n          *curr = '\"';\n        } else if (line[j] == '\"' || line[j] == '\\\\' /* || line[i] == '/'*/) {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = line[j];\n        } else if (line[j] == '\\b') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'b';\n        } else if (line[j] == '\\f') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'f';\n        } else if (line[j] == '\\n') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'n';\n        } else if (line[j] == '\\r') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'r';\n        } else if (line[j] == '\\t') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 't';\n        } else if (is_printable(line[j])) {\n          *curr = line[j];\n        } else {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'u';\n          curr++;\n          break_if(curr >= end);\n          *curr = '0';\n          curr++;\n          break_if(curr >= end);\n          *curr = '0';\n          curr++;\n          break_if(curr >= end);\n          *curr = hex[line[j] >> 8];\n          curr++;\n          break_if(curr >= end);\n          *curr = hex[line[j] & 0x0F];\n        }\n        curr++;\n      }\n\n      if (curr >= end) {\n        ngx_log_error(NGX_LOG_ERR,\n                      r->connection->log,\n                      0,\n                      \"cannot generate json structure due NGX_MAX_ERROR_STR size.\");\n        continue;\n      }\n\n      *curr = '\"';\n      curr++;\n      *curr = '}';\n      curr++;\n      *curr = 0;\n\n      ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"%s\", json);\n    }\n  }\n\n  if (ostr->nelts >= 1) {\n    denied_args.data = ((ngx_str_t*)ostr->elts)[0].data;\n    denied_args.len  = ((ngx_str_t*)ostr->elts)[0].len;\n  } else {\n    denied_args.data = empty.data;\n    denied_args.len  = empty.len;\n  }\n\n  /*\n  ** If we shouldn't block the request,\n  ** but a log score was reached, stop.\n  */\n  if (ctx->log && (!ctx->block && !ctx->drop)) {\n    return (NGX_DECLINED);\n  }\n\n  /*\n  ** If we are in learning without post_action and without drop\n  ** stop here as well.\n  */\n  if (ctx->learning && !ctx->post_action && !ctx->drop) {\n    return (NGX_DECLINED);\n  }\n  /*\n  ** add headers with original url\n  ** and arguments, as well as\n  ** the first fragment of log\n  */\n\n#define NAXSI_HEADER_ORIG_URL  \"x-orig_url\"\n#define NAXSI_HEADER_ORIG_ARGS \"x-orig_args\"\n#define NAXSI_HEADER_NAXSI_SIG \"x-naxsi_sig\"\n\n  if (r->headers_in.headers.last) {\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_ORIG_URL);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));\n    h->value.len  = tmp_uri->len;\n    h->value.data = ngx_pcalloc(r->pool, tmp_uri->len + 1);\n    memcpy(h->value.data, tmp_uri->data, tmp_uri->len);\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_ORIG_ARGS);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));\n    h->value.len  = r->args.len;\n    h->value.data = ngx_pcalloc(r->pool, r->args.len + 1);\n    memcpy(h->value.data, r->args.data, r->args.len);\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_NAXSI_SIG);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));\n    h->value.len  = denied_args.len;\n    h->value.data = denied_args.data;\n  }\n\n  if (ctx->learning && !ctx->drop) {\n    if (ctx->post_action) {\n      ngx_http_core_loc_conf_t* clcf;\n      clcf                   = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n      clcf->post_action.data = cf->denied_url->data;\n      clcf->post_action.len  = cf->denied_url->len;\n    }\n    return (NGX_DECLINED);\n  } else {\n    ngx_http_internal_redirect(r, cf->denied_url, &empty);\n    return (NGX_HTTP_OK);\n  }\n}\n\n/*\n** new rulematch, less arguments ^\n*/\nint\nngx_http_apply_rulematch_v_n(ngx_http_rule_t*        r,\n                             ngx_http_request_ctx_t* ctx,\n                             ngx_http_request_t*     req,\n                             ngx_str_t*              name,\n                             ngx_str_t*              value,\n                             naxsi_match_zone_t      zone,\n                             ngx_int_t               nb_match,\n                             ngx_int_t               target_name)\n{\n  unsigned int               found = 0, i, z;\n  ngx_http_special_score_t * sc, *rsc;\n  ngx_http_naxsi_loc_conf_t* cf;\n  ngx_http_matched_rule_t*   mr;\n  ngx_str_t                  empty = ngx_string(\"\");\n\n  if (!name) {\n    name = &empty;\n  }\n  if (!value) {\n    value = &empty;\n  }\n\n  cf = ngx_http_get_module_loc_conf(req, ngx_http_naxsi_module);\n  if (!cf || !ctx)\n    return (0);\n  if (ngx_http_naxsi_is_rule_whitelisted_n(req, cf, r, name, zone, target_name) == 1) {\n\n    NX_DEBUG(\n      _debug_whitelist_light, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"rule is whitelisted.\");\n\n    return (0);\n  }\n  NX_DEBUG(_debug_extensive_log,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"Current extensive log value: %d\",\n           ctx->extensive_log);\n\n  if (ctx->extensive_log) {\n    if (target_name) {\n      naxsi_log_offending(ctx, req, value, name, r, zone, target_name);\n    } else {\n      naxsi_log_offending(ctx, req, name, value, r, zone, target_name);\n    }\n  }\n  if (nb_match == 0)\n    nb_match = 1;\n  if (!ctx->matched)\n    ctx->matched = ngx_array_create(req->pool, 2, sizeof(ngx_http_matched_rule_t));\n  /* log stuff, cause this case sux */\n  if (!ctx->matched)\n    return (0);\n  mr = ngx_array_push(ctx->matched);\n  if (!mr)\n    return (0);\n  memset(mr, 0, sizeof(ngx_http_matched_rule_t));\n  if (target_name)\n    mr->target_name = 1;\n  switch (zone) {\n    case HEADERS:\n      mr->headers_var = 1;\n      break;\n    case URL:\n      mr->url = 1;\n      break;\n    case ARGS:\n      mr->args_var = 1;\n      break;\n    case BODY:\n      mr->body_var = 1;\n      break;\n    case FILE_EXT:\n      mr->file_ext = 1;\n      break;\n    default:\n      break;\n  };\n  mr->rule = r;\n  // the current \"name\" ptr will be free by caller, so make a copy\n  mr->name = ngx_pcalloc(req->pool, sizeof(ngx_str_t));\n  if (name->len > 0) {\n    mr->name->data = ngx_pcalloc(req->pool, name->len + 1);\n    memcpy(mr->name->data, name->data, name->len);\n    mr->name->len = name->len;\n  } else {\n    mr->name->data = NULL;\n    mr->name->len  = 0;\n  }\n  /* apply special score on rulematch */\n  if (r->sscores) {\n    NX_DEBUG(_debug_whitelist,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"Rule applies %d custom scores\",\n             r->sscores->nelts);\n\n    if (!ctx->special_scores) // create the list\n      ctx->special_scores = ngx_array_create(req->pool, 1, sizeof(ngx_http_special_score_t));\n    rsc = r->sscores->elts;\n    for (z = 0; z < r->sscores->nelts; z++) {\n      // search into the list for matching special score\n      found = 0;\n      sc    = ctx->special_scores->elts;\n      for (i = 0; i < ctx->special_scores->nelts; i++) {\n        if (rsc[z].sc_tag && sc[i].sc_tag && sc[i].sc_tag->len == rsc[z].sc_tag->len &&\n            !ngx_strcmp(sc[i].sc_tag->data, rsc[z].sc_tag->data)) {\n          NX_DEBUG(_debug_whitelist,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"Special Score (%V) actual=%d,next=%d\",\n                   rsc[z].sc_tag,\n                   sc[i].sc_score,\n                   sc[i].sc_score + (rsc[z].sc_score * nb_match));\n\n          sc[i].sc_score += (rsc[z].sc_score * nb_match);\n          found = 1;\n          break;\n        }\n      }\n\n      if (!found) {\n        NX_DEBUG(_debug_whitelist,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"Special Score (%V)  next=%d\",\n                 rsc[z].sc_tag,\n                 (rsc[z].sc_score * nb_match));\n\n        sc = ngx_array_push(ctx->special_scores);\n        if (!sc)\n          return (0);\n        memset(sc, 0, sizeof(ngx_http_special_score_t));\n        sc->sc_tag   = rsc[z].sc_tag;\n        sc->sc_score = (rsc[z].sc_score * nb_match);\n      }\n    }\n  }\n  /* else, apply normal score */\n  ctx->score += (r->score * nb_match);\n  if (r->block)\n    ctx->block = 1;\n  if (r->allow)\n    ctx->allow = 1;\n  if (r->drop)\n    ctx->drop = 1;\n  if (r->log)\n    ctx->log = 1;\n  ngx_http_naxsi_update_current_ctx_status(ctx, cf, req);\n  return (1);\n}\n\n/*\n** does : this functions receives an string in the form [foo=bar&bla=foo..]\n**    it splits the string into varname/value couples, and then pass\n**    this couple along with valid rules to checking func.\n** WARN/TODO : Even I tried to make my code bof proof, this should be seriously\n*audited :)\n*/\nint\nngx_http_spliturl_ruleset(ngx_pool_t*             pool,\n                          ngx_str_t*              nx_str,\n                          ngx_array_t*            rules,\n                          ngx_array_t*            main_rules,\n                          ngx_http_request_t*     req,\n                          ngx_http_request_ctx_t* ctx,\n                          naxsi_match_zone_t      zone)\n{\n  ngx_str_t name, val;\n  char *    eq, *ev, *orig, *str;\n  int       len, full_len;\n  int       nullbytes = 0;\n\n  if (naxsi_escape_nullbytes(nx_str) > 0) {\n    ngx_str_t dummy;\n    dummy.data = NULL;\n    dummy.len  = 0;\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__uncommon_hex_encoding, ctx, req, &dummy, &dummy, zone, 1, 0);\n  }\n  str = (char*)nx_str->data;\n\n  NX_DEBUG(_debug_spliturl_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX-check url-like [%s]\",\n           str);\n\n  orig     = str;\n  full_len = strlen(orig);\n  while (str < (orig + full_len) && *str) {\n    if (*str == '&') {\n      str++;\n      continue;\n    }\n    if ((ctx->block && !ctx->learning) || ctx->drop)\n      return (0);\n    eq = strchr(str, '=');\n    ev = strchr(str, '&');\n\n    if ((!eq && !ev) /*?foobar */ || (eq && ev && eq > ev)) /*?foobar&bla=test*/ {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-url has no '&' and '=' or has both [%s]\",\n               str);\n\n      if (!ev)\n        ev = str + strlen(str);\n      /* len is now [name] */\n      len       = ev - str;\n      val.data  = (unsigned char*)str;\n      val.len   = ev - str;\n      name.data = (unsigned char*)NULL;\n      name.len  = 0;\n    }\n    /* ?&&val | ?var&& | ?val& | ?&val | ?val&var */\n    else if (!eq && ev) {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-url has no '=' but has '&' [%s]\",\n               str);\n\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, req, NULL, NULL, zone, 1, 0);\n      if (ev > str) /* ?var& | ?var&val */ {\n        val.data  = (unsigned char*)str;\n        val.len   = ev - str;\n        name.data = (unsigned char*)NULL;\n        name.len  = 0;\n        len       = ev - str;\n      } else /* ?& | ?&&val */ {\n        val.data = name.data = NULL;\n        val.len = name.len = 0;\n        len                = 1;\n      }\n    } else /* should be normal like ?var=bar& ..*/ {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-Classic format url [%s]\",\n               str);\n\n      if (!ev) /* ?bar=lol */\n        ev = str + strlen(str);\n      /* len is now [name]=[content] */\n      len = ev - str;\n      eq  = strnchr(str, '=', len);\n      if (!eq) {\n        if (ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, req, NULL, NULL, zone, 1, 0)) {\n          naxsi_error_fatal(ctx, req, \"malformed url, possible attack [%s]\", str);\n        }\n        return (1);\n      }\n      eq++;\n      val.data  = (unsigned char*)eq;\n      val.len   = ev - eq;\n      name.data = (unsigned char*)str;\n      name.len  = eq - str - 1;\n    }\n    if (name.len) {\n      nullbytes = naxsi_unescape(&name);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, req, &name, &val, zone, 1, 1);\n      }\n    }\n    if (val.len) {\n      nullbytes = naxsi_unescape(&val);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, req, &name, &val, zone, 1, 0);\n      }\n    }\n    NX_DEBUG(_debug_spliturl_ruleset,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"XX-extract  [%V]=[%V]\",\n             &(name),\n             &(val));\n\n    if (rules) {\n      ngx_http_basestr_ruleset_n(pool, &name, &val, rules, req, ctx, zone);\n    } else {\n      NX_DEBUG(\n        _debug_spliturl_ruleset, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no arg rules ?\");\n    }\n\n    if (main_rules) {\n      ngx_http_basestr_ruleset_n(pool, &name, &val, main_rules, req, ctx, zone);\n    } else {\n      NX_DEBUG(\n        _debug_spliturl_ruleset, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no main rules ?\");\n    }\n\n    str += len;\n  }\n\n  return (0);\n}\n\n/*\n** check variable + name against a set of rules, checking against 'custom'\n*location rules too.\n*/\n\nvoid\nngx_http_libinjection(ngx_pool_t*             pool,\n                      ngx_str_t*              name,\n                      ngx_str_t*              value,\n                      ngx_http_request_ctx_t* ctx,\n                      ngx_http_request_t*     req,\n                      naxsi_match_zone_t      zone)\n{\n  /*\n  ** Libinjection integration :\n  ** 1 - check if libinjection_sql is explicitly enabled\n  ** 2 - check if libinjection_xss is explicitly enabled\n  ** if 1 is true : perform check on both name and content,\n  **        in case of match, apply internal rule\n  **        increasing the LIBINJECTION_SQL score\n  ** if 2 is true ; same as for '1' but with\n  **        LIBINJECTION_XSS\n  */\n  sfilter state;\n  int     issqli;\n\n  if (ctx->libinjection_sql) {\n\n    /* hardcoded call to libinjection on NAME, apply internal rule if matched.\n     */\n    libinjection_sqli_init(&state, (const char*)name->data, name->len, FLAG_NONE);\n    issqli = libinjection_is_sqli(&state);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_sql, ctx, req, name, value, zone, 1, 1);\n    }\n\n    /* hardcoded call to libinjection on CONTENT, apply internal rule if\n     * matched. */\n    libinjection_sqli_init(&state, (const char*)value->data, value->len, FLAG_NONE);\n    issqli = libinjection_is_sqli(&state);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_sql, ctx, req, name, value, zone, 1, 0);\n    }\n  }\n\n  if (ctx->libinjection_xss) {\n    /* first on var_name */\n    issqli = libinjection_xss((const char*)name->data, name->len);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_xss, ctx, req, name, value, zone, 1, 1);\n    }\n\n    /* hardcoded call to libinjection on CONTENT, apply internal rule if\n     * matched. */\n    issqli = libinjection_xss((const char*)value->data, value->len);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_xss, ctx, req, name, value, zone, 1, 0);\n    }\n  }\n}\n\nint\nngx_http_basestr_ruleset_n(ngx_pool_t*             pool,\n                           ngx_str_t*              name,\n                           ngx_str_t*              value,\n                           ngx_array_t*            rules,\n                           ngx_http_request_t*     req,\n                           ngx_http_request_ctx_t* ctx,\n                           naxsi_match_zone_t      zone)\n{\n  ngx_http_rule_t*                 r;\n  unsigned int                     i, ret, z, uri_constraint_ok = 1, rule_matched = 0;\n  ngx_int_t                        nb_match = 0;\n  ngx_http_custom_rule_location_t* location;\n\n  naxsi_escape_nullbytes(value);\n\n  NX_DEBUG(_debug_basestr_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX- check check [%V]=[%V] in zone %s\",\n           name,\n           value,\n           zone == BODY       ? \"BODY\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == URL      ? \"URL\"\n           : zone == ARGS     ? \"ARGS\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n                              : \"UNKNOWN\");\n\n  if (!rules) {\n    ngx_log_debug(\n      NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no no rules has been defined for naxsi.\");\n    return (0);\n  }\n  r = rules->elts;\n  NX_DEBUG(_debug_basestr_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX-checking %d rules ...\",\n           rules->nelts);\n\n  /* check for overlong/surrogate utf8 encoding */\n  if (ngx_utf8_check(name) != NULL) {\n    ngx_http_apply_rulematch_v_n(&nx_int__bad_utf8, ctx, req, NULL, NULL, zone, 1, 1);\n    return (0);\n  } else if (ngx_utf8_check(value) != NULL) {\n    ngx_http_apply_rulematch_v_n(&nx_int__bad_utf8, ctx, req, NULL, NULL, zone, 1, 0);\n    return (0);\n  }\n\n  /* call to libinjection */\n  ngx_http_libinjection(pool, name, value, ctx, req, zone);\n\n  for (i = 0; i < rules->nelts && ((!ctx->block || ctx->learning) && !ctx->drop); i++) {\n    /*properly reset counter*/\n    uri_constraint_ok = 1;\n    rule_matched      = 0;\n    NX_DEBUG(_debug_basestr_ruleset,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"XX-RULE %d : START\",\n             r[i].rule_id);\n\n    /* does the rule have a custom location ? custom location means checking\n     * only on a specific argument */\n    if (name && r[i].br->custom_location) {\n      location = r[i].br->custom_locations->elts;\n\n      /*\n      ** make a first pass, just in order to check that any\n      ** $URL / $URL_X constraints are validated before checking any other\n      ** parameters.\n      ** Unlike other criterias (wich are treated as 'OR')\n      ** this one must be valid to go forward\n      */\n      for (z = 0; z < r[i].br->custom_locations->nelts; z++) {\n\n        if (location[z].specific_url) {\n          /* if matchzone is a regex, ensure it matches (ie. BODY_VAR_X /\n           * ARGS_VAR_X / ..) */\n          if (r[i].br->rx_mz) {\n\n            if (ngx_http_naxsi_pcre_wrapper(location[z].target_rx, req->uri.data, req->uri.len) ==\n                -1) {\n              uri_constraint_ok = 0;\n            }\n          }\n\n          /* if it was a static string, ensure it matches (ie. BODY_VAR /\n           * ARGS_VAR / ..) */\n          if (!r[i].br->rx_mz) {\n            if (req->uri.len != location[z].target.len ||\n                strncasecmp((const char*)req->uri.data,\n                            (const char*)location[z].target.data,\n                            req->uri.len) != 0) {\n              uri_constraint_ok = 0;\n            }\n          }\n          break;\n        }\n      }\n\n      /*\n      ** if one of the custom location rule specifies an $URL/$URL_X\n      ** and it was mismatched, skip the rule.\n      */\n      if (uri_constraint_ok == 0) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX URI CONSTRAINT MISMATCH, SKIP\");\n        continue;\n      }\n\n      /* for each custom location */\n      for (z = 0; z < r[i].br->custom_locations->nelts; z++) {\n\n        rule_matched = 0;\n        /* check if zone is correct before checking names cf. issue #120 */\n        if (!(zone == BODY && location[z].body_var != 0) &&\n            !(zone == HEADERS && location[z].headers_var != 0) &&\n            !(zone == ARGS && location[z].args_var != 0))\n          continue;\n\n        /* if matchzone is a regex, ensure it matches (ie. BODY_VAR_X /\n         * ARGS_VAR_X / ..) */\n        if (r[i].br->rx_mz &&\n            ngx_http_naxsi_pcre_wrapper(location[z].target_rx, name->data, name->len) == -1)\n          continue;\n\n        /* if it was a static string, ensure it matches (ie. BODY_VAR / ARGS_VAR\n         * / ..) */\n        if ((!r[i].br->rx_mz) && (name->len != location[z].target.len ||\n                                  strncasecmp((const char*)name->data,\n                                              (const char*)location[z].target.data,\n                                              location[z].target.len)))\n          continue;\n\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-[SPECIFIC] check one rule [%d] iteration %d * %d\",\n                 r[i].rule_id,\n                 i,\n                 z);\n\n        /* match rule against var content, */\n        ret = ngx_http_process_basic_rule_buffer(value, &(r[i]), &nb_match);\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch [%V]=[%V] [rule=%d] (match %d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n          rule_matched = 1;\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 0);\n        }\n\n        if (!r[i].br->negative) {\n          /* match rule against var name, */\n          ret = ngx_http_process_basic_rule_buffer(name, &(r[i]), &nb_match);\n          /* if our rule matched, apply effects (score etc.) */\n          if (ret == 1) {\n            NX_DEBUG(_debug_basestr_ruleset,\n                     NGX_LOG_DEBUG_HTTP,\n                     req->connection->log,\n                     0,\n                     \"XX-apply rulematch[in name] [%V]=[%V] [rule=%d] (match \"\n                     \"%d times)\",\n                     name,\n                     value,\n                     r[i].rule_id,\n                     nb_match);\n            rule_matched = 1;\n            ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, name, zone, nb_match, 1);\n          }\n        }\n        if (rule_matched == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-[SPECIFIC] Rule %d matched in custom_location, go to next rule\",\n                   r[i].rule_id);\n\n          break;\n        }\n      }\n    }\n\n    /*\n    ** check against the rule if the current zone is matching\n    ** the zone the rule is meant to be check against\n    */\n    if ((zone == HEADERS && r[i].br->headers) || (zone == URL && r[i].br->url) ||\n        (zone == ARGS && r[i].br->args) || (zone == BODY && r[i].br->raw_body) ||\n        (zone == BODY && r[i].br->body_rule) || (zone == FILE_EXT && r[i].br->file_ext)) {\n\n      /*\n      ** If the Rule **specifically** targets name (ie. mz:BODY|NAME), only\n      *check against name\n      */\n      if (!r[i].br->target_name) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-test rulematch (value) [zone-wide]!1 [%V]=[%V] [rule =%d] \"\n                 \"(%d times)\",\n                 name,\n                 value,\n                 r[i].rule_id,\n                 nb_match);\n\n        /* check the rule against the value*/\n        ret = ngx_http_process_basic_rule_buffer(value, &(r[i]), &nb_match);\n        /*if our rule matched, apply effects (score etc.)*/\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch (value) [%V]=[%V] [rule=%d] (%d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 0);\n        }\n      }\n\n      if (!r[i].br->negative) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-test rulematch [against-name]!1 [%V]=[%V] [rule=%d] (%d times)\",\n                 name,\n                 value,\n                 r[i].rule_id,\n                 nb_match);\n\n        /* check the rule against the name*/\n        ret = ngx_http_process_basic_rule_buffer(name, &(r[i]), &nb_match);\n        /*if our rule matched, apply effects (score etc.)*/\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch!1 [%V]=[%V] [rule=%d] (%d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 1);\n        }\n      }\n    }\n  }\n  return (0);\n}\n\n/*\n** does : parse body data, a.k.a POST/PUT datas. identifies content-type,\n**    and, if appropriate, boundary. then parse the stuff if multipart/for..\n**    or rely on spliturl if application/x-w..\n** this function sucks ! I don't parse bigger-than-body-size posts that\n**     are partially stored in files, TODO ;)\n*/\n\n/*\n** Parse content-disposition line.\n*/\nint\nnx_content_disposition_parse(unsigned char*      str,\n                             unsigned char*      line_end,\n                             unsigned char**     fvarn_start,\n                             unsigned char**     fvarn_end,\n                             unsigned char**     ffilen_start,\n                             unsigned char**     ffilen_end,\n                             ngx_http_request_t* r)\n{\n\n  unsigned char *varn_start = NULL, *varn_end = NULL;\n  unsigned char *filen_start = NULL, *filen_end = NULL;\n  /* we have two cases :\n  ** ---- file upload\n  ** Content-Disposition: form-data; name=\"somename\";\n  *filename=\"NetworkManager.conf\"\\r\\n\n  ** Content-Type: application/octet-stream\\r\\n\\r\\n\n  ** <DATA>\n  ** ---- normal post var\n  ** Content-Disposition: form-data; name=\"lastname\"\\r\\n\\r\\n\n  ** <DATA>\n  */\n\n  while (str < line_end) {\n    /* rfc allow spaces and tabs inbetween */\n    while (str < line_end && (*str == ' ' || *str == '\\t')) {\n      str++;\n    }\n    if (str < line_end && *str == ';') {\n      str++;\n    }\n    while (str < line_end && (*str == ' ' || *str == '\\t')) {\n      str++;\n    }\n\n    if (str >= line_end) {\n      break;\n    }\n\n    if (!ngx_strncmp(str, \"name=\\\"\", 6)) {\n      /* we already successfully parsed a name, reject that. */\n      if (varn_end || varn_start) {\n        return (NGX_ERROR);\n      }\n\n      varn_end = varn_start = str + 6;\n      do {\n        varn_end = (unsigned char*)strnchr((const char*)varn_end, '\"', line_end - varn_start);\n        if (!varn_end || (varn_end && *(varn_end - 1) != '\\\\')) {\n          break;\n        }\n        varn_end++;\n      } while (varn_end && varn_end < line_end);\n\n      if (!varn_end || !*varn_end) {\n        return (NGX_ERROR);\n      }\n\n      str = varn_end;\n      if (str < line_end + 1) {\n        str++;\n      } else {\n        return (NGX_ERROR);\n      }\n      *fvarn_start = varn_start;\n      *fvarn_end   = varn_end;\n    } else if (!ngx_strncmp(str, \"filename=\\\"\", 10)) {\n      /* we already successfully parsed a filename, reject that. */\n      if (filen_end || filen_start) {\n        return (NGX_ERROR);\n      }\n      filen_end = filen_start = str + 10;\n      do {\n        filen_end = (unsigned char*)strnchr((const char*)filen_end, '\"', line_end - filen_start);\n        if (!filen_end) {\n          break;\n        }\n        if (filen_end && *(filen_end - 1) != '\\\\') {\n          break;\n        }\n        filen_end++;\n      } while (filen_end && filen_end < line_end);\n      if (!filen_end) {\n        return (NGX_ERROR);\n      }\n      str = filen_end;\n      if (str < line_end + 1) {\n        str++;\n      } else {\n        return (NGX_ERROR);\n      }\n      *ffilen_end   = filen_end;\n      *ffilen_start = filen_start;\n    } else if (str == line_end - 1) {\n      break;\n    } else {\n      /* gargabe is present ?*/\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"extra data in content-disposition ? end:%p, str:%p, diff=%d\",\n               line_end,\n               str,\n               line_end - str);\n\n      return (NGX_ERROR);\n    }\n  }\n  /* tssk tssk */\n  if (filen_end > line_end || varn_end > line_end) {\n    return (NGX_ERROR);\n  }\n  return (NGX_OK);\n}\n\nint\nnx_content_type_parse(ngx_http_request_t* r, unsigned char** boundary, unsigned int* boundary_len)\n{\n  unsigned char* h;\n  unsigned char* end;\n\n  h   = r->headers_in.content_type->value.data + strlen(\"multipart/form-data;\");\n  end = r->headers_in.content_type->value.data + r->headers_in.content_type->value.len;\n  /* skip potential whitespace/tabs */\n  while (h < end && *h && (*h == ' ' || *h == '\\t'))\n    h++;\n  if (strncmp((const char*)h, \"boundary=\", 9))\n    return (NGX_ERROR);\n  h += 9;\n  *boundary_len = end - h;\n  *boundary     = h;\n  /* RFC 1867/1341 says 70 char max,\n     I arbitrarily set min to 3 (yes) */\n  if (*boundary_len > 70 || *boundary_len < 3)\n    return (NGX_ERROR);\n  return (NGX_OK);\n}\n\nvoid\nngx_http_naxsi_multipart_parse(ngx_http_request_ctx_t* ctx,\n                               ngx_http_request_t*     r,\n                               u_char*                 src,\n                               u_int                   len)\n{\n  ngx_str_t                   final_var, final_data;\n  u_char *                    boundary, *varn_start, *varn_end;\n  u_char *                    filen_start, *filen_end;\n  u_char *                    end, *line_end;\n  u_int                       boundary_len, varn_len, varc_len, idx, nullbytes;\n  ngx_http_naxsi_loc_conf_t*  cf;\n  ngx_http_naxsi_main_conf_t* main_cf;\n\n  cf      = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  main_cf = ngx_http_get_module_main_conf(r, ngx_http_naxsi_module);\n\n  /*extract boundary*/\n  if (nx_content_type_parse(r, (unsigned char**)&boundary, &boundary_len) != NGX_OK) {\n    if (boundary && boundary_len > 1) {\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX-POST boundary : (%s) : %d\",\n               boundary,\n               boundary_len);\n    }\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n  NX_DEBUG(_debug_post_heavy,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"XX-POST boundary : (%s) : %d\",\n           boundary,\n           boundary_len);\n\n  /* fetch every line starting with boundary */\n  idx = 0;\n  while (idx < len) {\n\n    NX_DEBUG(_debug_post_heavy,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-POST data : (%s)\",\n             src + idx);\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,\n                  r->connection->log,\n                  0,\n                  \"Remaining Len:%d (boundary len:%d)\",\n                  len - idx,\n                  boundary_len);\n\n    /* if we've reached the last boundary '--' + boundary + '--' + '\\r\\n'$END */\n    /* Authorize requests that don't have the leading \\r\\n */\n    if (idx + boundary_len + 6 == len || idx + boundary_len + 4 == len) {\n      if (ngx_strncmp(src + idx, \"--\", 2) || ngx_strncmp(src + idx + 2, boundary, boundary_len) ||\n          ngx_strncmp(src + idx + boundary_len + 2, \"--\", 2)) {\n        /* bad closing boundary ?*/\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n        return;\n      } else\n        break;\n    }\n\n    /* --boundary\\r\\n : New var */\n    if ((len - idx < 4 + boundary_len) || src[idx] != '-' || src[idx + 1] != '-' ||\n        /* and if it's really followed by a boundary */\n        ngx_strncmp(src + idx + 2, boundary, boundary_len) ||\n        /* and if it's not the last boundary of the buffer */\n        idx + boundary_len + 2 + 2 >= len ||\n        /* and if it's followed by \\r\\n */\n        src[idx + boundary_len + 2] != '\\r' || src[idx + boundary_len + 3] != '\\n') {\n      /* bad boundary */\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n    idx += boundary_len + 4;\n    /* we have two cases :\n    ** ---- file upload\n    ** Content-Disposition: form-data; name=\"somename\";\n    *filename=\"NetworkManager.conf\"\\r\\n\n    ** Content-Type: application/octet-stream\\r\\n\\r\\n\n    ** <DATA>\n    ** ---- normal post var\n    ** Content-Disposition: form-data; name=\"lastname\"\\r\\n\\r\\n\n    ** <DATA>\n    */\n    /* 31 = echo -n \"content-disposition: form-data;\" | wc -c */\n    if (ngx_strncasecmp(src + idx, (u_char*)\"content-disposition: form-data;\", 31)) {\n      ngx_log_debug(\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"Unknown content-type: [%s]\", src + idx);\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : unknown content-disposition\");\n      }\n      return;\n    }\n    idx += 31;\n    line_end = (u_char*)ngx_strchr(src + idx, '\\n');\n    if (!line_end) {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : malformed boundary line\");\n      }\n      return;\n    }\n    /* Parse content-disposition, extract name / filename */\n    varn_start = varn_end = filen_start = filen_end = NULL;\n    if (nx_content_disposition_parse(\n          src + idx, line_end, &varn_start, &varn_end, &filen_start, &filen_end, r) != NGX_OK) {\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n    /* var name is mandatory */\n    if (!varn_start || !varn_end || varn_end <= varn_start) {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : no 'name' in POST var\");\n      }\n      return;\n    }\n    varn_len = varn_end - varn_start;\n\n    /* If there is a filename, it is followed by a \"content-type\" line, skip it\n     */\n    if (filen_start && filen_end) {\n      line_end = (u_char*)ngx_strchr(line_end + 1, '\\n');\n      if (!line_end) {\n        if (ngx_http_apply_rulematch_v_n(\n              &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n          naxsi_error_fatal(ctx, r, \"POST data : malformed filename (no content-type ?)\");\n        }\n        return;\n      }\n    }\n    /*\n    ** now idx point to the end of the\n    ** content-disposition: form-data; filename=\"\" name=\"\"\n    */\n    idx += (u_char*)line_end - (src + idx) + 1;\n    if (src[idx] != '\\r' || src[idx + 1] != '\\n') {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : malformed content-disposition line\");\n      }\n      return;\n    }\n    idx += 2;\n    /* seek the end of the data */\n    end = NULL;\n    while (idx < len) {\n      end = (u_char*)sstrfaststr(src + idx, len - idx, \"\\r\\n--\", strlen(\"\\r\\n--\"));\n      /* file data can contain \\x0 */\n      while (!end) {\n        idx += strlen((const char*)src + idx);\n        if (idx < len - 2) {\n          idx++;\n          end = (u_char*)sstrfaststr(src + idx, len - idx, \"\\r\\n--\", strlen(\"\\r\\n--\"));\n        } else {\n          break;\n        }\n      }\n      if (!end || ngx_strncmp(end + 4, boundary, boundary_len)) {\n        if (ngx_http_apply_rulematch_v_n(\n              &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n          naxsi_error_fatal(ctx, r, \"POST data : malformed content-disposition line\");\n        }\n        return;\n      }\n      if (!ngx_strncmp(end + 4, boundary, boundary_len)) {\n        break;\n      } else {\n        idx += ((u_char*)end - (src + idx)) + 1;\n        end = NULL;\n      }\n    }\n    if (!end) {\n      naxsi_error_fatal(ctx, r, \"POST data : malformed line\");\n      return;\n    }\n    if (filen_start) {\n      final_var.data  = (unsigned char*)varn_start;\n      final_var.len   = varn_len;\n      final_data.data = (unsigned char*)filen_start;\n      final_data.len  = filen_end - filen_start;\n      nullbytes       = naxsi_unescape(&final_var);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 1);\n      }\n      nullbytes = naxsi_unescape(&final_data);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 0);\n      }\n\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"[POST] checking filename [%V] = [%V]\",\n               &final_var,\n               &final_data);\n\n      /* here we got val name + val content !*/\n      if (cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, cf->body_rules, r, ctx, FILE_EXT);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"[POST] No local body rules\");\n      }\n\n      if (main_cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, main_cf->body_rules, r, ctx, FILE_EXT);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"[POST] No main body rules\");\n      }\n\n      idx += (u_char*)end - (src + idx);\n    } else if (varn_start) {\n      varc_len        = (u_char*)end - (src + idx);\n      final_var.data  = (unsigned char*)varn_start;\n      final_var.len   = varn_len;\n      final_data.data = src + idx;\n      final_data.len  = varc_len;\n      nullbytes       = naxsi_unescape(&final_var);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 1);\n      }\n      nullbytes = naxsi_unescape(&final_data);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 0);\n      }\n\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"[POST] [%V]=[%V]\",\n               &final_var,\n               &final_data);\n\n      /* here we got val name + val content !*/\n      if (cf->body_rules) {\n        ngx_http_basestr_ruleset_n(r->pool, &final_var, &final_data, cf->body_rules, r, ctx, BODY);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"No local body rules ?!\");\n      }\n\n      if (main_cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, main_cf->body_rules, r, ctx, BODY);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"No main body rules ?!\");\n      }\n\n      idx += (u_char*)end - (src + idx);\n    } else {\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"(multipart) : \");\n    }\n    if (!ngx_strncmp(end, \"\\r\\n\", 2))\n      idx += 2;\n  }\n}\n\nvoid\nngx_http_naxsi_body_parse(ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_naxsi_main_conf_t* main_cf)\n{\n  u_char*      src;\n  ngx_str_t    tmp;\n  ngx_chain_t* bb;\n  u_char*      full_body;\n  u_int        full_body_len;\n\n  NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-BODY PARSE\");\n\n  if (!r->request_body->bufs) {\n    ngx_http_apply_rulematch_v_n(&nx_int__empty_post_body, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n  if (!r->headers_in.content_type) {\n    NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-No content type ..\");\n\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_content_type, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  if (r->request_body->temp_file) {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,\n                  r->connection->log,\n                  0,\n                  \"naxsi: POST REQUEST to temp_file, partially parsed.\");\n    ngx_http_apply_rulematch_v_n(&nx_int__big_request, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-VALID BODY\");\n\n  /* request body in single buffer */\n  if (r->request_body->bufs->next == NULL) {\n    full_body_len = (u_int)(r->request_body->bufs->buf->last - r->request_body->bufs->buf->pos);\n    full_body     = ngx_pcalloc(r->pool, (u_int)(full_body_len + 1));\n    memcpy(full_body, r->request_body->bufs->buf->pos, full_body_len);\n  }\n\n  /* request body in chain */\n  else {\n    NX_DEBUG(_debug_body_parse,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"[POST] REQUEST BODY IN CHAIN !\");\n\n    for (full_body_len = 0, bb = r->request_body->bufs; bb; bb = bb->next)\n      full_body_len += (bb->buf->last - bb->buf->pos);\n    full_body = ngx_pcalloc(r->pool, full_body_len + 1);\n    src       = full_body;\n    if (!full_body)\n      return;\n    for (bb = r->request_body->bufs; bb; bb = bb->next)\n      full_body = ngx_cpymem(full_body, bb->buf->pos, bb->buf->last - bb->buf->pos);\n    full_body = src;\n    NX_DEBUG(_debug_body_parse,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"[POST] REQUEST BODY IN CHAIN [%s] (len=%d)\",\n             full_body,\n             full_body_len);\n  }\n\n  NX_DEBUG(_debug_body_parse,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"content-len header (%d) mismatch actual len (%d) ??\",\n           r->headers_in.content_length_n,\n           full_body_len);\n\n  /* File probably got buffered. */\n  if (r->headers_in.content_length_n != full_body_len) {\n    ngx_http_apply_rulematch_v_n(&nx_int__big_request, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  /* x-www-form-urlencoded POSTs */\n  /* 33 = echo -n \"application/x-www-form-urlencoded\" | wc -c */\n  if (!ngx_strncasecmp(\n        r->headers_in.content_type->value.data, (u_char*)\"application/x-www-form-urlencoded\", 33)) {\n    NX_DEBUG(\n      _debug_post_heavy, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-application/x-www..\");\n\n    tmp.len  = full_body_len;\n    tmp.data = full_body;\n\n    NX_DEBUG(\n      _debug_post_heavy, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-POST DATA [%V]\", &tmp);\n\n    if (ngx_http_spliturl_ruleset(\n          r->pool, &tmp, cf->body_rules, main_cf->body_rules, r, ctx, BODY)) {\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n  }\n  /* 19 = echo -n \"multipart/form-data\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"multipart/form-data\", 19)) {\n    ngx_http_naxsi_multipart_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 16 = echo -n \"application/json\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/json\", 16)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 24 = echo -n \"application/vnd.api+json\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/vnd.api+json\", 24)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 22 = echo -n \"application/csp-report\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/csp-report\", 22)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  } else {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"[POST] Unknown content-type\");\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_content_type, ctx, r, NULL, NULL, BODY, 1, 0);\n    /*\n    ** Only attempt to process \"raw\" body if id:nx_int__uncommon_content_type\n    *was\n    ** whitelisted. Else, it should be blocking and stop processing here.\n    */\n    if ((!ctx->block || ctx->learning) && !ctx->drop) {\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"After uncommon content-type\");\n      ngx_http_naxsi_rawbody_parse(ctx, r, full_body, full_body_len);\n    }\n  }\n}\n\n/*\n** does : this is a 'main' function, all the stuff goes from here.\n**    to make it short, it does the following :\n** - if we got header rules, apply header_rules on each.\n** - apply generic_rules on url decoded URI.\n** - if we got get_rules and get args, apply get_rules varname/value couple.\n** - if we are in a POST/PUT request and we got body_rules, apply rules :)\n*/\nvoid\nngx_http_naxsi_uri_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                         ngx_http_naxsi_loc_conf_t*  cf,\n                         ngx_http_request_ctx_t*     ctx,\n                         ngx_http_request_t*         r)\n{\n  ngx_str_t tmp, name;\n\n  if (!r->uri.len)\n    return;\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  if (!main_cf->generic_rules && !cf->generic_rules) {\n    tmp.data = NULL;\n    tmp.len  = 0;\n    ngx_http_apply_rulematch_v_n(&nx_int__no_rules, ctx, r, &tmp, &tmp, URL, 1, 0);\n    return;\n  }\n  tmp.len  = r->uri.len;\n  tmp.data = ngx_pcalloc(r->pool, r->uri.len + 1);\n  if (!tmp.data) {\n    naxsi_error_fatal(ctx, r, \"failed alloc of %d\", r->uri.len + 1);\n    return;\n  }\n  memcpy(tmp.data, r->uri.data, r->uri.len);\n  if (naxsi_escape_nullbytes(&tmp) > 0) {\n    ngx_str_t tmp_name, tmp_val;\n    tmp_name.data = tmp_val.data = NULL;\n    tmp_name.len = tmp_val.len = 0;\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__uncommon_hex_encoding, ctx, r, &tmp_name, &tmp_val, URL, 1, 0);\n  }\n  name.data = NULL;\n  name.len  = 0;\n  if (cf->generic_rules)\n    ngx_http_basestr_ruleset_n(r->pool, &name, &tmp, cf->generic_rules, r, ctx, URL);\n  if (main_cf->generic_rules)\n    ngx_http_basestr_ruleset_n(r->pool, &name, &tmp, main_cf->generic_rules, r, ctx, URL);\n  ngx_pfree(r->pool, tmp.data);\n}\n\nvoid\nngx_http_naxsi_args_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r)\n{\n  ngx_str_t tmp;\n\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  if (!r->args.len)\n    return;\n  if (!cf->get_rules && !main_cf->get_rules)\n    return;\n  tmp.len  = r->args.len;\n  tmp.data = ngx_pcalloc(r->pool, r->args.len + 1);\n  if (!tmp.data) {\n    naxsi_error_fatal(ctx, r, \"failed alloc\");\n    return;\n  }\n  memcpy(tmp.data, r->args.data, r->args.len);\n\n  if (ngx_http_spliturl_ruleset(r->pool, &tmp, cf->get_rules, main_cf->get_rules, r, ctx, ARGS)) {\n    naxsi_error_fatal(ctx, r, \"spliturl error : malformed url, possible attack\");\n    return;\n  }\n  ngx_pfree(r->pool, tmp.data);\n}\n\nvoid\nngx_http_naxsi_headers_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                             ngx_http_naxsi_loc_conf_t*  cf,\n                             ngx_http_request_ctx_t*     ctx,\n                             ngx_http_request_t*         r)\n{\n  ngx_list_part_t* part;\n  ngx_table_elt_t* h;\n  unsigned int     i;\n  ngx_str_t        lowcase_header;\n\n  if (!cf->header_rules && !main_cf->header_rules)\n    return;\n  // this check may be removed, as it shouldn't be needed anymore !\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  part = &r->headers_in.headers.part;\n  h    = part->elts;\n  // this check may be removed, as it shouldn't be needed anymore !\n  for (i = 0; ((!ctx->block || ctx->learning) && !ctx->block); i++) {\n    if (i >= part->nelts) {\n      if (part->next == NULL)\n        break;\n      part = part->next;\n      h    = part->elts;\n      i    = 0;\n    }\n    lowcase_header.data = h[i].lowcase_key;\n    lowcase_header.len  = h[i].key.len;\n    if (naxsi_escape_nullbytes(&lowcase_header) > 0) {\n      ngx_http_apply_rulematch_v_n(\n        &nx_int__uncommon_hex_encoding, ctx, r, &h[i].key, &h[i].value, HEADERS, 1, 1);\n    }\n    if (naxsi_escape_nullbytes(&h[i].value) > 0) {\n      ngx_http_apply_rulematch_v_n(\n        &nx_int__uncommon_hex_encoding, ctx, r, &h[i].key, &h[i].value, HEADERS, 1, 0);\n    }\n    if (cf->header_rules) {\n      ngx_http_basestr_ruleset_n(\n        r->pool, &lowcase_header, &(h[i].value), cf->header_rules, r, ctx, HEADERS);\n    }\n    if (main_cf->header_rules) {\n      ngx_http_basestr_ruleset_n(\n        r->pool, &lowcase_header, &(h[i].value), main_cf->header_rules, r, ctx, HEADERS);\n    }\n  }\n\n  if (naxsi_is_illegal_host_name(&r->headers_in.server) > 0) {\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__illegal_host_header, ctx, r, NULL, &r->headers_in.server, HEADERS, 1, 0);\n  }\n  return;\n}\n\nvoid\nngx_http_naxsi_data_parse(ngx_http_request_ctx_t* ctx, ngx_http_request_t* r)\n{\n  ngx_http_naxsi_loc_conf_t*  cf;\n  ngx_http_naxsi_main_conf_t* main_cf;\n\n  cf      = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  main_cf = ngx_http_get_module_main_conf(r, ngx_http_naxsi_module);\n  if (!cf || !ctx) {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"naxsi: unable to parse data.\");\n    return;\n  }\n  /* process rules only if request is not already blocked or if\n     the learning mode is enabled */\n  ngx_http_naxsi_headers_parse(main_cf, cf, ctx, r);\n  /* check uri */\n  ngx_http_naxsi_uri_parse(main_cf, cf, ctx, r);\n  /* check args */\n  ngx_http_naxsi_args_parse(main_cf, cf, ctx, r);\n  /* check method */\n  if ((r->method == NGX_HTTP_PATCH || r->method == NGX_HTTP_POST || r->method == NGX_HTTP_PUT) &&\n      /* presence of body rules (PATCH/POST/PUT rules) */\n      (cf->body_rules || main_cf->body_rules) &&\n      /* and the presence of data to parse */\n      r->request_body && ((!ctx->block || ctx->learning) && !ctx->drop))\n    ngx_http_naxsi_body_parse(ctx, r, cf, main_cf);\n\n  ngx_http_naxsi_update_current_ctx_status(ctx, cf, r);\n}\n\nvoid\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-custom check rules\");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n#if (NGX_HTTP_X_FORWARDED_FOR)\n#if (nginx_version < 1023000)\n    ngx_table_elt_t** h;\n    if (r->headers_in.x_forwarded_for.nelts >= 1) {\n      h = r->headers_in.x_forwarded_for.elts;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore X-Forwarded-For: %V\",\n               h[0]->value);\n      ngx_str_t* ip = &h[0]->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#else\n    ngx_table_elt_t* xff;\n    if (r->headers_in.x_forwarded_for != NULL) {\n      xff = r->headers_in.x_forwarded_for;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore X-Forwarded-For: %V\",\n               xff->value);\n      ngx_str_t* ip = &xff->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#endif\n#endif\n    {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore client ip: %V\",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    }\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-we have custom check rules and CTX got special score :)\");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \"XX- custom score rule triggered ..\");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}\n\n/*\n** This function is called when the body is read.\n** Will set-up flags to tell that parsing can be done,\n** and then run the core phases again\n** (WARNING: check backward compatibility of count--\n** with older version of nginx 0.7.x)\n*/\nvoid\nngx_http_naxsi_payload_handler(ngx_http_request_t* r)\n{\n  ngx_http_request_ctx_t* ctx;\n  ctx        = ngx_http_get_module_ctx(r, ngx_http_naxsi_module);\n  ctx->ready = 1;\n  r->count--;\n  NX_DEBUG(_debug_payload_handler,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"XX-dummy PAYLOAD HANDLER !\");\n\n  if (ctx->wait_for_body) {\n    NX_DEBUG(_debug_payload_handler,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-dummy : AFTER NGX_AGAIN\");\n\n    ctx->wait_for_body = 0;\n    ngx_http_core_run_phases(r);\n  }\n}\n", "#vi:filetype=perl\n\nuse lib 'lib';\nuse Test::Nginx::Socket;\n\nrepeat_each(1);\n\nplan tests => repeat_each(1) * blocks();\nno_root_location();\nno_long_string();\n$ENV{TEST_NGINX_SERVROOT} = server_root();\nrun_tests();\n\n__DATA__\n=== TEST 1: IgnoreIP defined\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.1: IgnoreIP request \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.2: IgnoreIP request with X-Forwarded-For allow (ipv4) \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.3: IgnoreIP request with X-Forwarded-For allow (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP \"2001:4860:4860::8844\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8844\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.4: IgnoreIP request with X-Forwarded-For deny (ipv4)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2.2.2.2\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.5: IgnoreIP request with X-Forwarded-For deny (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP \"2001:4860:4860::8844\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.6: Multiple IgnoreIP defined\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     IgnoreIP  \"1.2.3.4\";\n     IgnoreIP  \"2.3.4.1\";\n     IgnoreIP  \"2606:4700:4700::1111\";\n     IgnoreIP  \"2606:4700:4700::1001\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.7: Verify IgnoreIP (IPv4) works\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     #IgnoreIP  \"2606:4700:4700::1001\"; # IPv6 can't be tested.\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n=== TEST 1.8: IgnoreIP request inheritance\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n\n     location /foobar {\n          BasicRule wl:10;\n     }\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar?a=update/table\n--- curl\n--- curl_options: --interface 127.0.0.1\n--- error_code: 200\n\n=== TEST 1.9: IgnoreIP internal rules\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     DeniedUrl \"/RequestDenied\";\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nPUT /foobar\n--- error_code: 405\n", "#vi:filetype=perl\n\nuse lib 'lib';\nuse Test::Nginx::Socket;\n\nrepeat_each(1);\n\nplan tests => repeat_each(1) * blocks();\nno_root_location();\nno_long_string();\n$ENV{TEST_NGINX_SERVROOT} = server_root();\nrun_tests();\n\n__DATA__\n=== TEST 1: IgnoreCIDR defined (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.1: IgnoreCIDR request (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.2: IgnoreCIDR request with X-Forwarded-For allow (no file) \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.3: IgnoreCIDR request with X-Forwarded-For deny (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2.2.2.2\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.4: Verify IgnoreCIDR works\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n\n=== TEST 1.5: Verify IgnoreCIDR x.x.x.x./32 is converted to IgnoreIP\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.1/32\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n=== TEST 1.6: IgnoreCIDR request with X-Forwarded-For allow (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::/112\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.7: Verify IgnoreCIDR 2001:4860:4860::8888/128 is converted to IgnoreIP\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::8888/128\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.8: IgnoreCIDR request inheritance\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n\n     location /foobar {\n          BasicRule wl:10;\n     }\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar?a=update/table\n--- curl\n--- curl_options: --interface 127.0.0.1\n--- error_code: 200\n\n=== TEST 1.9: IgnoreCIDR internal rules\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nPUT /foobar\n--- error_code: 405\n"], "fixing_code": ["#!/bin/sh\n# SPDX-FileCopyrightText: 2022 wargio <deroad@libero.it>\n# SPDX-License-Identifier: LGPL-3.0-only\nset -e\n\nNGINX_VERSION=\"$1\"\nN_CPUS=$(nproc)\n\nif [ -z \"$NGINX_VERSION\" ]; then\n\techo \"usage: $0 <nginx version>\"\n\techo \"example: $0 1.12.2\"\n\texit 1\nfi\n\necho \"############################\"\necho \"   NGINX VERSION: $NGINX_VERSION\"\necho \"############################\"\n\nNEW_BUILD=true\nif [ -d \"nginx-tmp\" ] && [ \"$NGINX_VERSION\" == $(cat nginx-tmp/nginx.version) ]; then\n    NEW_BUILD=false\nfi\n\nif $NEW_BUILD ; then\n    rm -rf nginx-source nginx-tmp nginx.tar.gz 2>&1 > /dev/null\n    wget --no-clobber -O nginx.tar.gz \"https://nginx.org/download/nginx-$NGINX_VERSION.tar.gz\"\n    mkdir -p nginx-source nginx-tmp/naxsi_ut/root\n    echo \"$NGINX_VERSION\" > nginx-tmp/nginx.version\n    tar -C nginx-source -xzf nginx.tar.gz --strip-components=1\n    rm nginx.tar.gz\nfi\n\nexport NAXSI_SRC_PATH=$(realpath naxsi_src/)\nexport NAXSI_TMP_PATH=$(realpath nginx-tmp/)\nexport NGINX_TMP_PATH=$(realpath nginx-source/)\n\nif $NEW_BUILD ; then\n    cd \"$NGINX_TMP_PATH\"\n    ./configure --with-cc-opt='-g -O2 -Wextra -Wall -fstack-protector-strong -Wformat -Werror=format-security -fPIC -Wdate-time -D_FORTIFY_SOURCE=2' \\\n                --with-ld-opt='-Wl,-z,relro -Wl,-z,now -fPIC' \\\n                --with-select_module \\\n                --conf-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.conf\" \\\n                --http-client-body-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/body/\" \\\n                --http-fastcgi-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/fastcgi/\" \\\n                --http-proxy-temp-path=\"$NAXSI_TMP_PATH/naxsi_ut/proxy/\" \\\n                --lock-path=\"$NAXSI_TMP_PATH/nginx.lock\" \\\n                --pid-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.pid\" \\\n                --modules-path=\"$NAXSI_TMP_PATH/naxsi_ut/modules/\" \\\n                --without-mail_pop3_module \\\n                --without-mail_smtp_module \\\n                --without-mail_imap_module \\\n                --with-http_realip_module \\\n                --with-http_v2_module \\\n                --without-http_uwsgi_module \\\n                --without-http_scgi_module \\\n                --prefix=\"$NAXSI_TMP_PATH/\" \\\n                --add-dynamic-module=\"$NAXSI_SRC_PATH\" \\\n                --error-log-path=\"$NAXSI_TMP_PATH/naxsi_ut/error.log\" \\\n                --conf-path=\"$NAXSI_TMP_PATH/naxsi_ut/nginx.conf\"\n    cd ..\nfi\n\nmake -C \"$NGINX_TMP_PATH\" -j$N_CPUS install\n", "// SPDX-FileCopyrightText: 2016-2019, Thibault 'bui' Koechlin <tko@nbs-system.com>\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include <ngx_config.h>\n\n#include <naxsi.h>\n#include <naxsi_macros.h>\n#include <naxsi_net.h>\n\n/* used to store locations during the configuration time.\n   then, accessed by the hashtable building feature during \"init\" time. */\n\n/*\n** Static defined rules struct for internal rules.\n** We use those to be able to call is_rule_whitelisted_n() on those\n** rules at any time ;)\n*/\n\n#define InternalRule(var_name, rule_id, block, drop)             \\\n  ngx_http_rule_t var_name = {                                   \\\n    /*type*/ 0,            /*whitelist flag*/ 0,                 \\\n    /*wl_id ptr*/ NULL,    /*rule_id*/ rule_id,                  \\\n    /*log_msg*/ NULL,      /*score*/ 0,                          \\\n    /*sscores*/ NULL,                                            \\\n    /*block*/ block,       /*allow*/ 0,                          \\\n    /*drop*/ drop,         /*log*/ 0,                            \\\n    /*br ptrs*/ NULL                                             \\\n  }\n\nInternalRule(nx_int__weird_request,           1, 1, 0);\nInternalRule(nx_int__big_request,             2, 1, 0);\nInternalRule(nx_int__uncommon_hex_encoding,  10, 1, 0);\nInternalRule(nx_int__uncommon_content_type,  11, 1, 0);\nInternalRule(nx_int__uncommon_url,           12, 1, 0);\nInternalRule(nx_int__uncommon_post_format,   13, 1, 0);\nInternalRule(nx_int__uncommon_post_boundary, 14, 1, 0);\nInternalRule(nx_int__invalid_json,           15, 1, 0);\nInternalRule(nx_int__empty_post_body,        16, 1, 0);\nInternalRule(nx_int__libinject_sql,          17, 1, 0);\nInternalRule(nx_int__libinject_xss,          18, 1, 0);\nInternalRule(nx_int__no_rules,               19, 0, 1);\nInternalRule(nx_int__bad_utf8,               20, 0, 1);\nInternalRule(nx_int__illegal_host_header,    21, 0, 1);\n\n#define naxsi_error_fatal(ctx, r, ...)                                                             \\\n  do {                                                                                             \\\n    if (ctx)                                                                                       \\\n      ctx->block = 1;                                                                              \\\n    if (ctx)                                                                                       \\\n      ctx->drop = 1;                                                                               \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,                                                              \\\n                  r->connection->log,                                                              \\\n                  0,                                                                               \\\n                  \"XX-******** NGINX NAXSI INTERNAL ERROR ********\");                              \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, __VA_ARGS__);                         \\\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,                                                              \\\n                  r->connection->log,                                                              \\\n                  0,                                                                               \\\n                  \"XX-func:%s file:%s line:%d\",                                                    \\\n                  __func__,                                                                        \\\n                  __FILE__,                                                                        \\\n                  __LINE__);                                                                       \\\n    if (r && r->uri.data)                                                                          \\\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-uri:%s\", r->uri.data);          \\\n  } while (0)\n\nvoid\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r);\nint\nngx_http_process_basic_rule_buffer(ngx_str_t* str, ngx_http_rule_t* rl, ngx_int_t* match);\nvoid\nngx_http_naxsi_payload_handler(ngx_http_request_t* r);\nint\nngx_http_basestr_ruleset_n(ngx_pool_t*             pool,\n                           ngx_str_t*              name,\n                           ngx_str_t*              value,\n                           ngx_array_t*            rules,\n                           ngx_http_request_t*     req,\n                           ngx_http_request_ctx_t* ctx,\n                           naxsi_match_zone_t      zone);\nvoid\nngx_http_naxsi_body_parse(ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_naxsi_main_conf_t* main_cf);\n\nvoid\nngx_http_naxsi_rawbody_parse(ngx_http_request_ctx_t* ctx,\n                             ngx_http_request_t*     r,\n                             u_char*                 src,\n                             u_int                   len);\nunsigned char*\nngx_utf8_check(ngx_str_t* str);\n\n#if NGX_PCRE2\n/*\n * variables to use pcre2\n */\nstatic pcre2_match_data* ngx_pcre2_match_data;\nstatic ngx_uint_t        ngx_pcre2_match_data_size;\n\n/*\n * helper function to use pcre2\n */\nngx_int_t\nngx_pcre2_exec(ngx_regex_t*   re,\n               unsigned char* str,\n               unsigned int   len,\n               ngx_int_t      tmp_idx,\n               int*           captures,\n               ngx_uint_t     size)\n{\n  size_t*    ov;\n  ngx_int_t  rc;\n  ngx_uint_t n, i;\n\n  /*\n   * The pcre2_match() function might allocate memory for backtracking\n   * frames, typical allocations are from 40k and above.  So the allocator\n   * is configured to do direct allocations from heap during matching.\n   */\n\n  if (ngx_pcre2_match_data == NULL || size > ngx_pcre2_match_data_size) {\n    /*\n     * Allocate a match data if not yet allocated or smaller than\n     * needed.\n     */\n\n    if (ngx_pcre2_match_data) {\n      pcre2_match_data_free(ngx_pcre2_match_data);\n    }\n\n    ngx_pcre2_match_data_size = size;\n    ngx_pcre2_match_data      = pcre2_match_data_create(size / 3, NULL);\n\n    if (ngx_pcre2_match_data == NULL) {\n      rc = PCRE2_ERROR_NOMEMORY;\n      goto failed;\n    }\n  }\n\n  rc = pcre2_match(re, str, len, tmp_idx, 0, ngx_pcre2_match_data, NULL);\n\n  if (rc < 0) {\n    goto failed;\n  }\n\n  n  = pcre2_get_ovector_count(ngx_pcre2_match_data);\n  ov = pcre2_get_ovector_pointer(ngx_pcre2_match_data);\n\n  if (n > size / 3) {\n    n = size / 3;\n  }\n\n  for (i = 0; i < n; i++) {\n    captures[i * 2]     = ov[i * 2];\n    captures[i * 2 + 1] = ov[i * 2 + 1];\n  }\n\nfailed:\n\n  return rc;\n}\n#endif\n\n/*\n** in : string to inspect, associated rule\n** does : apply the rule on the string, return 1 if matched,\n**    0 else and -1 on error\n*/\nint\nngx_http_process_basic_rule_buffer(ngx_str_t* str, ngx_http_rule_t* rl, ngx_int_t* nb_match)\n\n{\n  ngx_int_t      match, tmp_idx, len;\n  unsigned char* ret;\n  int            captures[30];\n  if (!rl->br || !nb_match)\n    return (-1);\n\n  *nb_match = 0;\n  if (rl->br->match_type == RX && rl->br->rx) {\n    tmp_idx = 0;\n    len     = str->len;\n    while\n#if (NGX_PCRE2)\n      (tmp_idx < len &&\n       (match = ngx_pcre2_exec(rl->br->rx->regex, str->data, str->len, tmp_idx, captures, 30)) >= 0)\n#elif defined nginx_version && (nginx_version >= 1002002 && nginx_version != 1003000)\n      (tmp_idx < len && (match = pcre_exec(rl->br->rx->regex->code,\n                                           0,\n                                           (const char*)str->data,\n                                           str->len,\n                                           tmp_idx,\n                                           0,\n                                           captures,\n                                           30)) >= 0)\n#elif defined nginx_version && (nginx_version > 1001011)\n      (tmp_idx < len && (match = pcre_exec(rl->br->rx->regex->pcre,\n                                           0,\n                                           (const char*)str->data,\n                                           str->len,\n                                           tmp_idx,\n                                           0,\n                                           captures,\n                                           30)) >= 0)\n#elif defined nginx_version && (nginx_version <= 1001011)\n      (tmp_idx < len &&\n       (match = pcre_exec(\n          rl->br->rx->regex, 0, (const char*)str->data, str->len, tmp_idx, 0, captures, 30)) >= 0)\n#elif defined nginx_version\n#error \"Inconsistent nginx version.\"\n      (0)\n#else\n#error \"nginx_version not defined.\"\n      (0)\n#endif\n    {\n      *nb_match += match;\n      tmp_idx = captures[1];\n    }\n    if (*nb_match > 0) {\n      if (rl->br->negative)\n        return (0);\n      else\n        return (1);\n    } else if (*nb_match == 0) {\n      if (rl->br->negative)\n        return (1);\n      else\n        return (0);\n    }\n    return (-1);\n  } else if (rl->br->match_type == STR && rl->br->str) {\n    match   = 0;\n    tmp_idx = 0;\n    while (1) {\n      ret = (unsigned char*)strfaststr((unsigned char*)str->data + tmp_idx,\n                                       (unsigned int)str->len - tmp_idx,\n                                       (unsigned char*)rl->br->str->data,\n                                       (unsigned int)rl->br->str->len);\n      if (ret) {\n        match     = 1;\n        *nb_match = *nb_match + 1;\n      } else\n        break;\n      if (nb_match && ret < (str->data + str->len)) {\n        tmp_idx = (ret - str->data) + 1;\n        if (tmp_idx > (int)(str->len - 1))\n          break;\n      } else\n        break;\n    }\n    if (match) {\n      if (rl->br->negative)\n        return (0);\n      else\n        return (1);\n    } else {\n      if (rl->br->negative)\n        return (1);\n      else\n        return (0);\n    }\n  } else if (rl->br->match_type == LIBINJ_XSS) {\n    if (libinjection_xss((const char*)str->data, str->len) == 1)\n      return (1);\n  } else if (rl->br->match_type == LIBINJ_SQL) {\n    sfilter state;\n\n    libinjection_sqli_init(&state, (const char*)str->data, str->len, FLAG_NONE);\n    if (libinjection_is_sqli(&state) == 1)\n      return (1);\n  }\n\n  return (0);\n}\n\n/*\n** Check if a (matched) rule is whitelisted.\n** This func will look for the current URI in the wlr_url_hash [hashtable]\n** It will also look for varname in the wlr_body|args|headers_hash [hashtable]\n** and It will also look for disabled rules.\n** 1 - If the rule is disabled, it's whitelisted\n** 2 - If a matching URL is found, check if the further information confirms\n*that the rule should be whitelisted\n** ($URL:/bar|$ARGS_VAR:foo : it's not because URL matches that we should\n*whitelist rule)\n** 3 - If a matching varname is found, check zone and rules IDs.\n** [TODO] : Add mz matches with style BODY|HEADERS|...\n** returns (1) if rule is whitelisted, else (0)\n*/\n\nint\nngx_http_naxsi_is_whitelist_adapted(ngx_http_whitelist_rule_t* b,\n                                    ngx_str_t*                 name,\n                                    naxsi_match_zone_t         zone,\n                                    ngx_http_rule_t*           r,\n                                    ngx_http_request_t*        req,\n                                    naxsi_match_type_t         type,\n                                    ngx_int_t                  target_name)\n{\n  /* if something was found, check the rule ID */\n  if (!b) {\n    return (0);\n  }\n  /* FILE_EXT zone is just a hack, as it indeed targets BODY */\n  if (zone == FILE_EXT)\n    zone = BODY;\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"Possible whitelist ... check...\");\n\n  /* if whitelist targets arg name, but the rules hit content*/\n  if (b->target_name && !target_name) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"whitelist targets name, but rule matched content.\");\n    return (0);\n  }\n  /* if if the whitelist target contents, but the rule hit arg name*/\n  if (!b->target_name && target_name) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"whitelist targets content, but rule matched name.\");\n    return (0);\n  }\n\n  if (type == NAME_ONLY) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"Name match in zone %s\",\n             zone == ARGS      ? \"ARGS\"\n             : zone == BODY    ? \"BODY\"\n             : zone == HEADERS ? \"HEADERS\"\n                               : \"UNKNOWN!!!!!\");\n    // False Positive, there was a whitelist that matches the argument name,\n    // But is was actually matching an existing URI name.\n    if (b->zone == ANY && (zone == ARGS || zone == BODY || zone == HEADERS)) {\n      return (nx_check_ids(r->rule_id, b->ids));\n    } else if (zone != b->zone || b->uri_only) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, name match, but WL was only on URL.\");\n      return (0);\n    }\n    return (nx_check_ids(r->rule_id, b->ids));\n  }\n  if (type == URI_ONLY || type == MIXED) {\n    /* zone must match */\n    if (b->uri_only && type != URI_ONLY) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, type is URI_ONLY, but not whitelist\");\n      return (0);\n    }\n\n    if (zone != b->zone && b->zone != ANY) {\n      NX_DEBUG(_debug_whitelist_compat,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"bad whitelist, URL match, but not zone\");\n      return (0);\n    }\n\n    return (nx_check_ids(r->rule_id, b->ids));\n  }\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"finished wl check, failed.\");\n\n  return (0);\n}\n\nngx_http_whitelist_rule_t*\nnx_find_wl_in_hash(ngx_http_request_t*        req,\n                   ngx_str_t*                 mstr,\n                   ngx_http_naxsi_loc_conf_t* cf,\n                   naxsi_match_zone_t         zone)\n{\n  ngx_int_t                  k       = 0;\n  ngx_http_whitelist_rule_t* b       = NULL;\n  ngx_str_t                  scratch = { .data = NULL, .len = mstr->len };\n\n  scratch.data = ngx_pcalloc(req->pool, mstr->len + 1);\n  if (!scratch.data) {\n    return NULL;\n  }\n\n  k = ngx_hash_strlow(scratch.data, mstr->data, mstr->len);\n\n  if ((zone == BODY || zone == FILE_EXT || zone == ANY) && cf->wlr_body_hash &&\n      cf->wlr_body_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_body_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == HEADERS || (zone == ANY && !b)) && cf->wlr_headers_hash &&\n      cf->wlr_headers_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_headers_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == URL || (zone == ANY && !b)) && cf->wlr_url_hash && cf->wlr_url_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_url_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n  if ((zone == ARGS || (zone == ANY && !b)) && cf->wlr_args_hash && cf->wlr_args_hash->size > 0) {\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_args_hash, k, (u_char*)scratch.data, scratch.len);\n  }\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"find wl in hash %d %p %s.\",\n           k,\n           b,\n           zone == ARGS       ? \"ARGS\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == BODY     ? \"BODY\"\n           : zone == URL      ? \"URL\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n           : zone == ANY      ? \"ANY\"\n                              : \"UNKNOWN\");\n  ngx_pfree(req->pool, scratch.data);\n  return (b);\n}\n\nint\nnaxsi_can_ignore_ip(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_ips || cf->ignore_ips_ha.keys.nelts < 1) {\n    return 0;\n  }\n  char ip_str[INET6_ADDRSTRLEN + 1] = { 0 };\n  if (!naxsi_parse_ip(ipstr, NULL, ip_str)) {\n    return 0;\n  }\n\n  ngx_str_t  scratch = { .data = (unsigned char*)ip_str, .len = strlen(ip_str) };\n  ngx_uint_t k       = ngx_hash_key(scratch.data, scratch.len);\n  return ngx_hash_find(cf->ignore_ips, k, (u_char*)scratch.data, scratch.len) != NULL ? 1 : 0;\n}\n\nint\nnaxsi_can_ignore_cidr(const ngx_str_t* ipstr, ngx_http_naxsi_loc_conf_t* cf)\n{\n  if (!cf->ignore_cidrs) {\n    return 0;\n  }\n  ngx_uint_t i;\n  ip_t       ip = ip_zero;\n  if (!naxsi_parse_ip(ipstr, &ip, NULL)) {\n    return 0;\n  }\n\n  for (i = 0; i < cf->ignore_cidrs->nelts; i++) {\n    cidr_t* cidr = &((cidr_t*)cf->ignore_cidrs->elts)[i];\n    if (naxsi_is_in_subnet(cidr, &ip)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n#define custloc_array(x) ((ngx_http_custom_rule_location_t*)x)\n\n/*\n** wrapper used for regex matchzones. Should be used by classic basestr* as\n*well.\n*/\nint\nngx_http_naxsi_pcre_wrapper(ngx_regex_compile_t* rx, unsigned char* str, unsigned int len)\n{\n  int match;\n  int captures[30];\n\n#if (NGX_PCRE2)\n  match = ngx_pcre2_exec(rx->regex, str, len, 0, captures, 1);\n#elif defined nginx_version && (nginx_version >= 1002002 && nginx_version != 1003000)\n  match = pcre_exec(rx->regex->code, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version && (nginx_version > 1001011)\n  match = pcre_exec(rx->regex->pcre, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version && (nginx_version <= 1001011)\n  match = pcre_exec(rx->regex, 0, (const char*)str, len, 0, 0, captures, 1);\n#elif defined nginx_version\n#error \"Inconsistent nginx version.\"\n  return (0);\n#else\n#error \"nginx_version not defined.\"\n  return (0);\n#endif\n  if (match > 0)\n    return (1);\n  return (match);\n}\n\nint\nngx_http_naxsi_is_rule_whitelisted_rx(ngx_http_request_t*        req,\n                                      ngx_http_naxsi_loc_conf_t* cf,\n                                      ngx_http_rule_t*           r,\n                                      ngx_str_t*                 name,\n                                      naxsi_match_zone_t         zone,\n                                      ngx_int_t                  target_name)\n{\n  ngx_http_rule_t* p;\n  ngx_uint_t       i, x;\n  int              rx_match, violation;\n\n  /* Look it up in regexed whitelists for matchzones */\n  if (!cf->rxmz_wlr || cf->rxmz_wlr->nelts < 1) {\n    return (0);\n  }\n  NX_DEBUG(_debug_wl_debug_rx,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"RXX - Trying to find rx for %v\",\n           name);\n\n  for (i = 0; i < cf->rxmz_wlr->nelts; i++) {\n\n    p = (((ngx_http_rule_t**)(cf->rxmz_wlr->elts))[i]);\n\n    if (!p->br || !p->br->custom_locations || p->br->custom_locations->nelts < 1) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"Rule pushed to RXMZ, but has no custom_location.\");\n\n      continue;\n    }\n\n    /*\n    ** once we have pointer to the rule :\n    ** - go through each custom location (ie. ARGS_VAR_X:foobar*)\n    ** - verify that regular expressions match. If not, it means whitelist does\n    *not apply.\n    */\n\n    NX_DEBUG(_debug_wl_debug_rx,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"%d/%d RXMZ rule has %d custom locations\",\n             i,\n             cf->rxmz_wlr->nelts,\n             p->br->custom_locations->nelts);\n\n    if (p->br->zone != (ngx_int_t)zone && p->br->zone != ANY) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"%d/%d Not targeting same zone.\",\n               i,\n               cf->rxmz_wlr->nelts);\n\n      continue;\n    }\n\n    if (target_name != p->br->target_name) {\n      NX_DEBUG(\n        _debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"only one target_name\");\n\n      continue;\n    }\n\n    for (x = 0, violation = 0; x < p->br->custom_locations->nelts && violation == 0; x++) {\n      /* does custom location targets a body var ? */\n      if (custloc_array(p->br->custom_locations->elts)[x].body_var) {\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, name->data, name->len);\n        if (rx_match < 0) {\n          violation = 1;\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[BODY] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   name);\n\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[BODY] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 name);\n      }\n\n      if (custloc_array(p->br->custom_locations->elts)[x].args_var) {\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, name->data, name->len);\n        if (rx_match < 0) {\n          violation = 1;\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[ARGS] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   name);\n\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[ARGS] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 name);\n      }\n\n      if (custloc_array(p->br->custom_locations->elts)[x].specific_url) {\n        /* if there is a specific url, check it regardless of zone. */\n        rx_match = ngx_http_naxsi_pcre_wrapper(\n          custloc_array(p->br->custom_locations->elts)[x].target_rx, req->uri.data, req->uri.len);\n        if (rx_match < 0) {\n          NX_DEBUG(_debug_wl_debug_rx,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"[URI] FAIL:%d (rx:%V, str:%V)\",\n                   rx_match,\n                   &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                   &(req->uri));\n\n          violation = 1;\n          break;\n        }\n        NX_DEBUG(_debug_wl_debug_rx,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"[URI] Match:%d (rx:%V, str:%V)\",\n                 rx_match,\n                 &(custloc_array(p->br->custom_locations->elts)[x].target_rx->pattern),\n                 &(req->uri));\n      }\n    }\n    if (violation == 0) {\n      NX_DEBUG(_debug_wl_debug_rx,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"wut, rule whitelisted by rx.\");\n\n      if (nx_check_ids(r->rule_id, p->wlid_array) == 1)\n        return (1);\n    } else {\n      NX_DEBUG(_debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"not good ----\");\n    }\n  }\n  return (0);\n}\n\nint\nngx_http_naxsi_is_rule_whitelisted_n(ngx_http_request_t*        req,\n                                     ngx_http_naxsi_loc_conf_t* cf,\n                                     ngx_http_rule_t*           r,\n                                     ngx_str_t*                 name,\n                                     naxsi_match_zone_t         zone,\n                                     ngx_int_t                  target_name)\n{\n  ngx_int_t                  k            = 0;\n  ngx_http_whitelist_rule_t* b            = NULL;\n  unsigned int               i            = 0;\n  ngx_http_rule_t**          dr           = NULL;\n  ngx_str_t                  tmp_hashname = { 0 };\n  ngx_str_t                  nullname     = ngx_null_string;\n\n  /* if name is NULL, replace it by an empty string */\n  if (!name)\n    name = &nullname;\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"is rule [%d] whitelisted in zone %s for item %V\",\n           r->rule_id,\n           zone == ARGS       ? \"ARGS\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == BODY     ? \"BODY\"\n           : zone == URL      ? \"URL\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n           : zone == ANY      ? \"ANY\"\n                              : \"UNKNOWN\",\n           name);\n  NX_DEBUG(_debug_whitelist_compat && target_name,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"extra: exception happened in |NAME\");\n\n  /* Check if the rule is part of disabled rules for this location */\n  if (cf->disabled_rules) {\n    dr = cf->disabled_rules->elts;\n    for (i = 0; i < cf->disabled_rules->nelts; i++) {\n\n      /* Is rule disabled ? */\n      if (nx_check_ids(r->rule_id, dr[i]->wlid_array)) {\n\n        NX_DEBUG(_debug_whitelist_compat,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"rule %d is disabled somewhere\",\n                 r->rule_id);\n        /* if it doesn't specify zone, skip zone-check */\n        if (!dr[i]->br) {\n          NX_DEBUG(_debug_whitelist_compat,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"no zone, skip zone-check\");\n          continue;\n        }\n\n        /* If rule target nothing, it's whitelisted everywhere */\n        if (!(dr[i]->br->args || dr[i]->br->headers || dr[i]->br->body || dr[i]->br->url)) {\n          NX_DEBUG(_debug_whitelist_compat,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"rule %d is fully disabled\",\n                   r->rule_id);\n          return (1);\n        }\n\n        /* if exc is in name, but rule is not specificaly disabled for name (and\n         * targets a zone)  */\n        if (target_name != dr[i]->br->target_name)\n          continue;\n\n        switch (zone) {\n          case ANY:\n            if (dr[i]->br->any) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in ANY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case ARGS:\n            if (dr[i]->br->args) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in ARGS\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case HEADERS:\n            if (dr[i]->br->headers) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in HEADERS\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case BODY:\n            if (dr[i]->br->body) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in BODY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case RAW_BODY:\n            if (dr[i]->br->body) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in BODY\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case FILE_EXT:\n            if (dr[i]->br->file_ext) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in FILE_EXT\",\n                       r->rule_id);\n              return (1);\n            }\n            break;\n          case URL:\n            if (dr[i]->br->url) {\n              NX_DEBUG(_debug_whitelist_compat,\n                       NGX_LOG_DEBUG_HTTP,\n                       req->connection->log,\n                       0,\n                       \"rule %d is disabled in URL zone:%d\",\n                       r->rule_id,\n                       zone);\n              return (1);\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  }\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing varname [%V]\",\n           name);\n  /*\n  ** check for ARGS_VAR:x(|NAME) whitelists.\n  ** (name) or (#name)\n  */\n  if (name->len > 0) {\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing varname [%V] (rule:%d) - 'wl:X_VAR:%V'\",\n             name,\n             r->rule_id,\n             name);\n    /* try to find in hashtables */\n    b = nx_find_wl_in_hash(req, name, cf, zone);\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, NAME_ONLY, target_name)) {\n      return (1);\n    }\n    /*prefix hash with '#', to find whitelists that would be done only on\n     * ARGS_VAR:X|NAME */\n    tmp_hashname.len = name->len + 1;\n    /* too bad we have to realloc just to add the '#' */\n    tmp_hashname.data    = ngx_pcalloc(req->pool, tmp_hashname.len + 1);\n    tmp_hashname.data[0] = '#';\n    memcpy(tmp_hashname.data + 1, name->data, name->len);\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing varname [%V] (rule:%d) - 'wl:X_VAR:%V|NAME'\",\n             name,\n             r->rule_id,\n             name);\n    b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n    ngx_pfree(req->pool, tmp_hashname.data);\n    tmp_hashname.data = NULL;\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, NAME_ONLY, target_name)) {\n      return (1);\n    }\n  }\n\n  /* Plain URI whitelists */\n  if (cf->wlr_url_hash && cf->wlr_url_hash->size > 0) {\n\n    /* check the URL no matter what zone we're in */\n    tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 1);\n    /* mimic find_wl_in_hash, we are looking in a different hashtable */\n    if (!tmp_hashname.data) {\n      return (0);\n    }\n    tmp_hashname.len = req->uri.len;\n    k                = ngx_hash_strlow(tmp_hashname.data, req->uri.data, req->uri.len);\n\n    NX_DEBUG(_debug_whitelist_compat,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"hashing uri [%V] (rule:%d) 'wl:$URI:%V|*' %d\",\n             &req->uri,\n             r->rule_id,\n             &tmp_hashname,\n             k);\n\n    b = (ngx_http_whitelist_rule_t*)ngx_hash_find(\n      cf->wlr_url_hash, k, (u_char*)tmp_hashname.data, tmp_hashname.len);\n    ngx_pfree(req->pool, tmp_hashname.data);\n    tmp_hashname.data = NULL;\n\n    NX_DEBUG(_debug_whitelist_compat, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"%p\", b);\n\n    if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n      return (1);\n    }\n  }\n\n  /* Lookup for $URL|URL (uri)*/\n  tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 1);\n  if (!tmp_hashname.data) {\n    return (0);\n  }\n  tmp_hashname.len = req->uri.len;\n  ngx_memcpy(tmp_hashname.data, req->uri.data, req->uri.len);\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing uri#1 [%V] (rule:%d) ($URL:%V|URI)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n  tmp_hashname.data = NULL;\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n    return (1);\n  }\n\n  /* Looking $URL:x|ZONE|NAME */\n  tmp_hashname.data = ngx_pcalloc(req->pool, req->uri.len + 2);\n  /* should make it sound crit isn't it ?*/\n  if (!tmp_hashname.data)\n    return (0);\n  tmp_hashname.len     = req->uri.len + 1;\n  tmp_hashname.data[0] = '#';\n  ngx_memcpy(tmp_hashname.data + 1, req->uri.data, req->uri.len);\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing uri#3 [%V] (rule:%d) ($URL:%V|ZONE|NAME)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &tmp_hashname, cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n  tmp_hashname.data = NULL;\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, URI_ONLY, target_name)) {\n    return (1);\n  }\n\n  /* Maybe it was $URL+$VAR (uri#name) or (#uri#name) */\n  tmp_hashname.len = req->uri.len + 1 + name->len;\n  /* one extra byte for target_name '#' */\n  tmp_hashname.data = ngx_pcalloc(req->pool, tmp_hashname.len + 2);\n  if (target_name) {\n    tmp_hashname.len++;\n    strcat((char*)tmp_hashname.data, \"#\");\n  }\n  strncat((char*)tmp_hashname.data, (char*)req->uri.data, req->uri.len);\n  strcat((char*)tmp_hashname.data, \"#\");\n  strncat((char*)tmp_hashname.data, (char*)name->data, name->len);\n\n  NX_DEBUG(_debug_whitelist_compat,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"hashing MIX [%V] (rule:%d) ($URL:%V|$X_VAR:y) or ($URL:%V|$X_VAR:y|NAME)\",\n           &req->uri,\n           r->rule_id,\n           &tmp_hashname,\n           &tmp_hashname);\n  b = nx_find_wl_in_hash(req, &(tmp_hashname), cf, zone);\n  ngx_pfree(req->pool, tmp_hashname.data);\n\n  if (ngx_http_naxsi_is_whitelist_adapted(b, name, zone, r, req, MIXED, target_name)) {\n    return (1);\n  }\n\n  /*\n  ** Look it up in regexed whitelists for matchzones\n  */\n  if (ngx_http_naxsi_is_rule_whitelisted_rx(req, cf, r, name, zone, target_name) == 1) {\n    NX_DEBUG(\n      _debug_wl_debug_rx, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"Whitelisted by RX !\");\n\n    return (1);\n  }\n\n  return (0);\n}\n\n/*\n** Create log lines, possibly splitted\n** and linked by random numbers.\n*/\n#define MAX_LINE_SIZE (NGX_MAX_ERROR_STR - 100)\n#define MAX_SEED_LEN  17 /*seed_start=10000*/\n\nngx_str_t*\nngx_http_append_log(ngx_http_request_t* r, ngx_array_t* ostr, ngx_str_t* fragment, u_int* offset)\n{\n  u_int        seed, sub;\n  static u_int prev_seed = 0;\n\n  /*\n  ** avoid random collisions, as we % 1000 them,\n  ** this is very likely to happen !\n  */\n\n  /*\n  ** extra space has been reserved to append the seed.\n  */\n#ifndef _WIN32\n  while ((seed = random() % 1000) == prev_seed)\n#else  // _WIN32\n  while ((seed = rand() % 1000) == prev_seed)\n#endif // !_WIN32\n    ;\n  sub           = snprintf((char*)(fragment->data + *offset), MAX_SEED_LEN, \"&seed_start=%d\", seed);\n  fragment->len = *offset + sub;\n  fragment      = ngx_array_push(ostr);\n  if (!fragment)\n    return (NULL);\n  fragment->data = ngx_pcalloc(r->pool, MAX_LINE_SIZE + 1);\n  if (!fragment->data)\n    return (NULL);\n  sub       = snprintf((char*)fragment->data, MAX_SEED_LEN, \"seed_end=%d\", seed);\n  prev_seed = seed;\n  *offset   = sub;\n  return (fragment);\n}\n\nngx_int_t\nnaxsi_create_log_array(ngx_http_request_ctx_t* ctx,\n                       ngx_http_request_t*     r,\n                       ngx_array_t*            ostr,\n                       ngx_str_t**             ret_uri)\n{\n  u_int                     sz_left, sub, offset = 0, i;\n  ngx_str_t *               fragment, *tmp_uri;\n  ngx_http_special_score_t* sc;\n  const char*               fmt_base   = \"ip=%.*s&server=%.*s&uri=%.*s&config=%.*s&rid=\";\n  const char*               fmt_score  = \"&cscore%d=%.*s&score%d=%zu\";\n  const char*               fmt_rm     = \"&zone%d=%s&id%d=%d&var_name%d=%.*s\";\n  const char*               fmt_config = \"\";\n\n  if (ctx->learning) {\n    fmt_config = ctx->drop ? \"learning-drop\" : \"learning\";\n  } else if (ctx->drop) {\n    fmt_config = \"drop\";\n  } else if (ctx->block) {\n    fmt_config = \"block\";\n  } else if (ctx->ignore) {\n    fmt_config = \"ignore\";\n  }\n\n  ngx_http_matched_rule_t* mr;\n  char                     tmp_zone[30];\n\n  tmp_uri = ngx_pcalloc(r->pool, sizeof(ngx_str_t));\n  if (!tmp_uri)\n    return (NGX_ERROR);\n  *ret_uri = tmp_uri;\n\n  if (r->uri.len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {\n    r->uri.len /= 4;\n  }\n\n  tmp_uri->len  = r->uri.len + (2 * ngx_escape_uri(NULL, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS));\n  tmp_uri->data = ngx_pcalloc(r->pool, tmp_uri->len + 1);\n  ngx_escape_uri(tmp_uri->data, r->uri.data, r->uri.len, NGX_ESCAPE_ARGS);\n\n  fragment = ngx_array_push(ostr);\n  if (!fragment) {\n    return (NGX_ERROR);\n  }\n  fragment->data = ngx_pcalloc(r->pool, MAX_LINE_SIZE + 1);\n  if (!fragment->data) {\n    return (NGX_ERROR);\n  }\n  sub = offset = 0;\n  /* we keep extra space for seed*/\n  sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - 1;\n\n  /*\n  ** don't handle uri > 4k, string will be split\n  */\n\n  sub = snprintf((char*)fragment->data,\n                 sz_left,\n                 fmt_base,\n                 r->connection->addr_text.len,\n                 r->connection->addr_text.data,\n                 r->headers_in.server.len,\n                 r->headers_in.server.data,\n                 tmp_uri->len,\n                 tmp_uri->data,\n                 strlen(fmt_config),\n                 fmt_config);\n\n  if (sub >= sz_left) {\n    sub = sz_left - 1;\n  }\n  sz_left -= sub;\n  offset += sub;\n\n  sub = NAXSI_REQUEST_ID_SIZE << 1;\n  if (sz_left > (100 + sub)) {\n    ngx_hex_dump(fragment->data + offset, ctx->request_id, NAXSI_REQUEST_ID_SIZE);\n    if (sub >= sz_left) {\n      sub = sz_left - 1;\n    }\n    sz_left -= sub;\n    offset += sub;\n  }\n\n  /*\n  ** if URI exceeds the MAX_LINE_SIZE, log directly, avoid null deref (#178)\n  */\n  if (sz_left < 100) {\n    fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n    if (!fragment)\n      return (NGX_ERROR);\n    sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n  }\n\n  /*\n  ** append scores\n  */\n  for (i = 0; ctx->special_scores && i < ctx->special_scores->nelts; i++) {\n    sc = ctx->special_scores->elts;\n    if (sc[i].sc_score != 0) {\n      sub = snprintf(0, 0, fmt_score, i, sc[i].sc_tag->len, sc[i].sc_tag->data, i, sc[i].sc_score);\n      if (sub >= sz_left) {\n        /*\n        ** ngx_http_append_log will add seed_start and seed_end, and adjust the\n        *offset.\n        */\n        fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n        if (!fragment)\n          return (NGX_ERROR);\n        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n      }\n      sub = snprintf((char*)(fragment->data + offset),\n                     sz_left,\n                     fmt_score,\n                     i,\n                     sc[i].sc_tag->len,\n                     sc[i].sc_tag->data,\n                     i,\n                     sc[i].sc_score);\n      if (sub >= sz_left) {\n        sub = sz_left - 1;\n      }\n      offset += sub;\n      sz_left -= sub;\n    }\n  }\n  /*\n  ** and matched zone/id/name\n  */\n  if (ctx->matched) {\n    mr  = ctx->matched->elts;\n    sub = 0;\n    i   = 0;\n    do {\n      memset(tmp_zone, 0, sizeof(tmp_zone));\n      if (mr[i].body_var)\n        strcat(tmp_zone, \"BODY\");\n      else if (mr[i].args_var)\n        strcat(tmp_zone, \"ARGS\");\n      else if (mr[i].headers_var)\n        strcat(tmp_zone, \"HEADERS\");\n      else if (mr[i].url)\n        strcat(tmp_zone, \"URL\");\n      else if (mr[i].file_ext)\n        strcat(tmp_zone, \"FILE_EXT\");\n      if (mr[i].target_name)\n        strcat(tmp_zone, \"|NAME\");\n\n      ngx_str_t tmp_val;\n\n      if (mr[i].name->len >= (NGX_MAX_UINT32_VALUE / 4) - 1) {\n        mr[i].name->len /= 4;\n      }\n\n      tmp_val.len =\n        mr[i].name->len +\n        (2 * ngx_escape_uri(NULL, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT));\n\n      tmp_val.data = ngx_pcalloc(r->pool, tmp_val.len + 1);\n      ngx_escape_uri(tmp_val.data, mr[i].name->data, mr[i].name->len, NGX_ESCAPE_URI_COMPONENT);\n\n      sub =\n        snprintf(0, 0, fmt_rm, i, tmp_zone, i, mr[i].rule->rule_id, i, tmp_val.len, tmp_val.data);\n      /*\n      ** This one would not fit :\n      ** append a seed to the current fragment,\n      ** and start a new one\n      */\n      if (sub >= sz_left) {\n        fragment = ngx_http_append_log(r, ostr, fragment, &offset);\n        if (!fragment)\n          return (NGX_ERROR);\n        sz_left = MAX_LINE_SIZE - MAX_SEED_LEN - offset - 1;\n      }\n      sub = snprintf((char*)fragment->data + offset,\n                     sz_left,\n                     fmt_rm,\n                     i,\n                     tmp_zone,\n                     i,\n                     mr[i].rule->rule_id,\n                     i,\n                     tmp_val.len,\n                     tmp_val.data);\n      if (sub >= sz_left)\n        sub = sz_left - 1;\n      offset += sub;\n      sz_left -= sub;\n      i += 1;\n    } while (i < ctx->matched->nelts);\n  }\n  fragment->len = offset;\n  return (NGX_HTTP_OK);\n}\n\nchar*\nreplace_str(const char* s, const char* oldW, const char* newW)\n{\n  char* result;\n  int   i, cnt = 0;\n  int   newWlen = strlen(newW);\n  int   oldWlen = strlen(oldW);\n\n  // Counting the number of times old word\n  // occur in the string\n  for (i = 0; s[i] != '\\0'; i++) {\n    if (strstr(&s[i], oldW) == &s[i]) {\n      cnt++;\n      // Jumping to index after the old word.\n      i += oldWlen - 1;\n    }\n  }\n\n  // Making new string of enough length\n  result = (char*)malloc(i + cnt * (newWlen - oldWlen) + 1);\n\n  if (!result)\n    return 0;\n\n  i = 0;\n  while (*s) {\n    // compare the substring with the result\n    if (strstr(s, oldW) == s) {\n      strcpy(&result[i], newW);\n      i += newWlen;\n      s += oldWlen;\n    } else {\n      result[i++] = *s++;\n    }\n  }\n\n  result[i] = '\\0';\n  return result;\n}\n\nngx_int_t\nngx_http_output_forbidden_page(ngx_http_request_ctx_t* ctx, ngx_http_request_t* r)\n{\n  ngx_str_t *                tmp_uri, denied_args;\n  ngx_str_t                  empty = ngx_string(\"\");\n  ngx_http_naxsi_loc_conf_t* cf;\n  ngx_array_t*               ostr;\n  ngx_table_elt_t*           h;\n  unsigned int               i = 0;\n\n  cf = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  /* get array of signatures strings */\n  ostr = ngx_array_create(r->pool, 1, sizeof(ngx_str_t));\n  if (naxsi_create_log_array(ctx, r, ostr, &tmp_uri) != NGX_HTTP_OK) {\n    return (NGX_ERROR);\n  }\n\n  if (!ctx->json_log) {\n    for (i = 0; i < ostr->nelts; i++) {\n      ngx_log_error(NGX_LOG_ERR,\n                    cf->log ? cf->log : r->connection->log,\n                    0,\n                    \"NAXSI_FMT: %s\",\n                    ((ngx_str_t*)ostr->elts)[i].data);\n    }\n  } else {\n    const char* hex  = \"0123456789abcdef\";\n    ngx_str_t*  elts = (ngx_str_t*)ostr->elts;\n    for (i = 0; i < ostr->nelts; i++) {\n      char json[NAXSI_LOG_JSON_STRLEN] = { 0 };\n      // line only\n      const char* line = (const char*)elts[i].data;\n      char*       curr = json + 2;\n      char*       end  = (curr + sizeof(json)) - 4;\n\n      json[0] = '{';\n      json[1] = '\"';\n\n      size_t j;\n      for (j = 0; line[j] && curr < end; j++) {\n        if (line[j] == '=') {\n          *curr = '\"';\n          curr++;\n          break_if(curr >= end);\n          *curr = ':';\n          curr++;\n          break_if(curr >= end);\n          *curr = '\"';\n        } else if (line[j] == '&') {\n          *curr = '\"';\n          curr++;\n          break_if(curr >= end);\n          *curr = ',';\n          curr++;\n          break_if(curr >= end);\n          *curr = '\"';\n        } else if (line[j] == '\"' || line[j] == '\\\\' /* || line[i] == '/'*/) {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = line[j];\n        } else if (line[j] == '\\b') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'b';\n        } else if (line[j] == '\\f') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'f';\n        } else if (line[j] == '\\n') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'n';\n        } else if (line[j] == '\\r') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'r';\n        } else if (line[j] == '\\t') {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 't';\n        } else if (is_printable(line[j])) {\n          *curr = line[j];\n        } else {\n          *curr = '\\\\';\n          curr++;\n          break_if(curr >= end);\n          *curr = 'u';\n          curr++;\n          break_if(curr >= end);\n          *curr = '0';\n          curr++;\n          break_if(curr >= end);\n          *curr = '0';\n          curr++;\n          break_if(curr >= end);\n          *curr = hex[line[j] >> 8];\n          curr++;\n          break_if(curr >= end);\n          *curr = hex[line[j] & 0x0F];\n        }\n        curr++;\n      }\n\n      if (curr >= end) {\n        ngx_log_error(NGX_LOG_ERR,\n                      r->connection->log,\n                      0,\n                      \"cannot generate json structure due NGX_MAX_ERROR_STR size.\");\n        continue;\n      }\n\n      *curr = '\"';\n      curr++;\n      *curr = '}';\n      curr++;\n      *curr = 0;\n\n      ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, \"%s\", json);\n    }\n  }\n\n  if (ostr->nelts >= 1) {\n    denied_args.data = ((ngx_str_t*)ostr->elts)[0].data;\n    denied_args.len  = ((ngx_str_t*)ostr->elts)[0].len;\n  } else {\n    denied_args.data = empty.data;\n    denied_args.len  = empty.len;\n  }\n\n  /*\n  ** If we shouldn't block the request,\n  ** but a log score was reached, stop.\n  */\n  if (ctx->log && (!ctx->block && !ctx->drop)) {\n    return (NGX_DECLINED);\n  }\n\n  /*\n  ** If we are in learning without post_action and without drop\n  ** stop here as well.\n  */\n  if (ctx->learning && !ctx->post_action && !ctx->drop) {\n    return (NGX_DECLINED);\n  }\n  /*\n  ** add headers with original url\n  ** and arguments, as well as\n  ** the first fragment of log\n  */\n\n#define NAXSI_HEADER_ORIG_URL  \"x-orig_url\"\n#define NAXSI_HEADER_ORIG_ARGS \"x-orig_args\"\n#define NAXSI_HEADER_NAXSI_SIG \"x-naxsi_sig\"\n\n  if (r->headers_in.headers.last) {\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_ORIG_URL);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_URL) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_URL, strlen(NAXSI_HEADER_ORIG_URL));\n    h->value.len  = tmp_uri->len;\n    h->value.data = ngx_pcalloc(r->pool, tmp_uri->len + 1);\n    memcpy(h->value.data, tmp_uri->data, tmp_uri->len);\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_ORIG_ARGS);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_ORIG_ARGS) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_ORIG_ARGS, strlen(NAXSI_HEADER_ORIG_ARGS));\n    h->value.len  = r->args.len;\n    h->value.data = ngx_pcalloc(r->pool, r->args.len + 1);\n    memcpy(h->value.data, r->args.data, r->args.len);\n\n    h = ngx_list_push(&(r->headers_in.headers));\n    if (!h)\n      return (NGX_ERROR);\n    h->key.len  = strlen(NAXSI_HEADER_NAXSI_SIG);\n    h->key.data = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);\n    if (!h->key.data)\n      return (NGX_ERROR);\n    memcpy(h->key.data, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));\n    h->lowcase_key = ngx_pcalloc(r->pool, strlen(NAXSI_HEADER_NAXSI_SIG) + 1);\n    memcpy(h->lowcase_key, NAXSI_HEADER_NAXSI_SIG, strlen(NAXSI_HEADER_NAXSI_SIG));\n    h->value.len  = denied_args.len;\n    h->value.data = denied_args.data;\n  }\n\n  if (ctx->learning && !ctx->drop) {\n    if (ctx->post_action) {\n      ngx_http_core_loc_conf_t* clcf;\n      clcf                   = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n      clcf->post_action.data = cf->denied_url->data;\n      clcf->post_action.len  = cf->denied_url->len;\n    }\n    return (NGX_DECLINED);\n  } else {\n    ngx_http_internal_redirect(r, cf->denied_url, &empty);\n    return (NGX_HTTP_OK);\n  }\n}\n\n/*\n** new rulematch, less arguments ^\n*/\nint\nngx_http_apply_rulematch_v_n(ngx_http_rule_t*        r,\n                             ngx_http_request_ctx_t* ctx,\n                             ngx_http_request_t*     req,\n                             ngx_str_t*              name,\n                             ngx_str_t*              value,\n                             naxsi_match_zone_t      zone,\n                             ngx_int_t               nb_match,\n                             ngx_int_t               target_name)\n{\n  unsigned int               found = 0, i, z;\n  ngx_http_special_score_t * sc, *rsc;\n  ngx_http_naxsi_loc_conf_t* cf;\n  ngx_http_matched_rule_t*   mr;\n  ngx_str_t                  empty = ngx_string(\"\");\n\n  if (!name) {\n    name = &empty;\n  }\n  if (!value) {\n    value = &empty;\n  }\n\n  cf = ngx_http_get_module_loc_conf(req, ngx_http_naxsi_module);\n  if (!cf || !ctx)\n    return (0);\n  if (ngx_http_naxsi_is_rule_whitelisted_n(req, cf, r, name, zone, target_name) == 1) {\n\n    NX_DEBUG(\n      _debug_whitelist_light, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"rule is whitelisted.\");\n\n    return (0);\n  }\n  NX_DEBUG(_debug_extensive_log,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"Current extensive log value: %d\",\n           ctx->extensive_log);\n\n  if (ctx->extensive_log) {\n    if (target_name) {\n      naxsi_log_offending(ctx, req, value, name, r, zone, target_name);\n    } else {\n      naxsi_log_offending(ctx, req, name, value, r, zone, target_name);\n    }\n  }\n  if (nb_match == 0)\n    nb_match = 1;\n  if (!ctx->matched)\n    ctx->matched = ngx_array_create(req->pool, 2, sizeof(ngx_http_matched_rule_t));\n  /* log stuff, cause this case sux */\n  if (!ctx->matched)\n    return (0);\n  mr = ngx_array_push(ctx->matched);\n  if (!mr)\n    return (0);\n  memset(mr, 0, sizeof(ngx_http_matched_rule_t));\n  if (target_name)\n    mr->target_name = 1;\n  switch (zone) {\n    case HEADERS:\n      mr->headers_var = 1;\n      break;\n    case URL:\n      mr->url = 1;\n      break;\n    case ARGS:\n      mr->args_var = 1;\n      break;\n    case BODY:\n      mr->body_var = 1;\n      break;\n    case FILE_EXT:\n      mr->file_ext = 1;\n      break;\n    default:\n      break;\n  };\n  mr->rule = r;\n  // the current \"name\" ptr will be free by caller, so make a copy\n  mr->name = ngx_pcalloc(req->pool, sizeof(ngx_str_t));\n  if (name->len > 0) {\n    mr->name->data = ngx_pcalloc(req->pool, name->len + 1);\n    memcpy(mr->name->data, name->data, name->len);\n    mr->name->len = name->len;\n  } else {\n    mr->name->data = NULL;\n    mr->name->len  = 0;\n  }\n  /* apply special score on rulematch */\n  if (r->sscores) {\n    NX_DEBUG(_debug_whitelist,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"Rule applies %d custom scores\",\n             r->sscores->nelts);\n\n    if (!ctx->special_scores) // create the list\n      ctx->special_scores = ngx_array_create(req->pool, 1, sizeof(ngx_http_special_score_t));\n    rsc = r->sscores->elts;\n    for (z = 0; z < r->sscores->nelts; z++) {\n      // search into the list for matching special score\n      found = 0;\n      sc    = ctx->special_scores->elts;\n      for (i = 0; i < ctx->special_scores->nelts; i++) {\n        if (rsc[z].sc_tag && sc[i].sc_tag && sc[i].sc_tag->len == rsc[z].sc_tag->len &&\n            !ngx_strcmp(sc[i].sc_tag->data, rsc[z].sc_tag->data)) {\n          NX_DEBUG(_debug_whitelist,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"Special Score (%V) actual=%d,next=%d\",\n                   rsc[z].sc_tag,\n                   sc[i].sc_score,\n                   sc[i].sc_score + (rsc[z].sc_score * nb_match));\n\n          sc[i].sc_score += (rsc[z].sc_score * nb_match);\n          found = 1;\n          break;\n        }\n      }\n\n      if (!found) {\n        NX_DEBUG(_debug_whitelist,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"Special Score (%V)  next=%d\",\n                 rsc[z].sc_tag,\n                 (rsc[z].sc_score * nb_match));\n\n        sc = ngx_array_push(ctx->special_scores);\n        if (!sc)\n          return (0);\n        memset(sc, 0, sizeof(ngx_http_special_score_t));\n        sc->sc_tag   = rsc[z].sc_tag;\n        sc->sc_score = (rsc[z].sc_score * nb_match);\n      }\n    }\n  }\n  /* else, apply normal score */\n  ctx->score += (r->score * nb_match);\n  if (r->block)\n    ctx->block = 1;\n  if (r->allow)\n    ctx->allow = 1;\n  if (r->drop)\n    ctx->drop = 1;\n  if (r->log)\n    ctx->log = 1;\n  ngx_http_naxsi_update_current_ctx_status(ctx, cf, req);\n  return (1);\n}\n\n/*\n** does : this functions receives an string in the form [foo=bar&bla=foo..]\n**    it splits the string into varname/value couples, and then pass\n**    this couple along with valid rules to checking func.\n** WARN/TODO : Even I tried to make my code bof proof, this should be seriously\n*audited :)\n*/\nint\nngx_http_spliturl_ruleset(ngx_pool_t*             pool,\n                          ngx_str_t*              nx_str,\n                          ngx_array_t*            rules,\n                          ngx_array_t*            main_rules,\n                          ngx_http_request_t*     req,\n                          ngx_http_request_ctx_t* ctx,\n                          naxsi_match_zone_t      zone)\n{\n  ngx_str_t name, val;\n  char *    eq, *ev, *orig, *str;\n  int       len, full_len;\n  int       nullbytes = 0;\n\n  if (naxsi_escape_nullbytes(nx_str) > 0) {\n    ngx_str_t dummy;\n    dummy.data = NULL;\n    dummy.len  = 0;\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__uncommon_hex_encoding, ctx, req, &dummy, &dummy, zone, 1, 0);\n  }\n  str = (char*)nx_str->data;\n\n  NX_DEBUG(_debug_spliturl_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX-check url-like [%s]\",\n           str);\n\n  orig     = str;\n  full_len = strlen(orig);\n  while (str < (orig + full_len) && *str) {\n    if (*str == '&') {\n      str++;\n      continue;\n    }\n    if ((ctx->block && !ctx->learning) || ctx->drop)\n      return (0);\n    eq = strchr(str, '=');\n    ev = strchr(str, '&');\n\n    if ((!eq && !ev) /*?foobar */ || (eq && ev && eq > ev)) /*?foobar&bla=test*/ {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-url has no '&' and '=' or has both [%s]\",\n               str);\n\n      if (!ev)\n        ev = str + strlen(str);\n      /* len is now [name] */\n      len       = ev - str;\n      val.data  = (unsigned char*)str;\n      val.len   = ev - str;\n      name.data = (unsigned char*)NULL;\n      name.len  = 0;\n    }\n    /* ?&&val | ?var&& | ?val& | ?&val | ?val&var */\n    else if (!eq && ev) {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-url has no '=' but has '&' [%s]\",\n               str);\n\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, req, NULL, NULL, zone, 1, 0);\n      if (ev > str) /* ?var& | ?var&val */ {\n        val.data  = (unsigned char*)str;\n        val.len   = ev - str;\n        name.data = (unsigned char*)NULL;\n        name.len  = 0;\n        len       = ev - str;\n      } else /* ?& | ?&&val */ {\n        val.data = name.data = NULL;\n        val.len = name.len = 0;\n        len                = 1;\n      }\n    } else /* should be normal like ?var=bar& ..*/ {\n      NX_DEBUG(_debug_spliturl_ruleset,\n               NGX_LOG_DEBUG_HTTP,\n               req->connection->log,\n               0,\n               \"XX-Classic format url [%s]\",\n               str);\n\n      if (!ev) /* ?bar=lol */\n        ev = str + strlen(str);\n      /* len is now [name]=[content] */\n      len = ev - str;\n      eq  = strnchr(str, '=', len);\n      if (!eq) {\n        if (ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, req, NULL, NULL, zone, 1, 0)) {\n          naxsi_error_fatal(ctx, req, \"malformed url, possible attack [%s]\", str);\n        }\n        return (1);\n      }\n      eq++;\n      val.data  = (unsigned char*)eq;\n      val.len   = ev - eq;\n      name.data = (unsigned char*)str;\n      name.len  = eq - str - 1;\n    }\n    if (name.len) {\n      nullbytes = naxsi_unescape(&name);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, req, &name, &val, zone, 1, 1);\n      }\n    }\n    if (val.len) {\n      nullbytes = naxsi_unescape(&val);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, req, &name, &val, zone, 1, 0);\n      }\n    }\n    NX_DEBUG(_debug_spliturl_ruleset,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"XX-extract  [%V]=[%V]\",\n             &(name),\n             &(val));\n\n    if (rules) {\n      ngx_http_basestr_ruleset_n(pool, &name, &val, rules, req, ctx, zone);\n    } else {\n      NX_DEBUG(\n        _debug_spliturl_ruleset, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no arg rules ?\");\n    }\n\n    if (main_rules) {\n      ngx_http_basestr_ruleset_n(pool, &name, &val, main_rules, req, ctx, zone);\n    } else {\n      NX_DEBUG(\n        _debug_spliturl_ruleset, NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no main rules ?\");\n    }\n\n    str += len;\n  }\n\n  return (0);\n}\n\n/*\n** check variable + name against a set of rules, checking against 'custom'\n*location rules too.\n*/\n\nvoid\nngx_http_libinjection(ngx_pool_t*             pool,\n                      ngx_str_t*              name,\n                      ngx_str_t*              value,\n                      ngx_http_request_ctx_t* ctx,\n                      ngx_http_request_t*     req,\n                      naxsi_match_zone_t      zone)\n{\n  /*\n  ** Libinjection integration :\n  ** 1 - check if libinjection_sql is explicitly enabled\n  ** 2 - check if libinjection_xss is explicitly enabled\n  ** if 1 is true : perform check on both name and content,\n  **        in case of match, apply internal rule\n  **        increasing the LIBINJECTION_SQL score\n  ** if 2 is true ; same as for '1' but with\n  **        LIBINJECTION_XSS\n  */\n  sfilter state;\n  int     issqli;\n\n  if (ctx->libinjection_sql) {\n\n    /* hardcoded call to libinjection on NAME, apply internal rule if matched.\n     */\n    libinjection_sqli_init(&state, (const char*)name->data, name->len, FLAG_NONE);\n    issqli = libinjection_is_sqli(&state);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_sql, ctx, req, name, value, zone, 1, 1);\n    }\n\n    /* hardcoded call to libinjection on CONTENT, apply internal rule if\n     * matched. */\n    libinjection_sqli_init(&state, (const char*)value->data, value->len, FLAG_NONE);\n    issqli = libinjection_is_sqli(&state);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_sql, ctx, req, name, value, zone, 1, 0);\n    }\n  }\n\n  if (ctx->libinjection_xss) {\n    /* first on var_name */\n    issqli = libinjection_xss((const char*)name->data, name->len);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_xss, ctx, req, name, value, zone, 1, 1);\n    }\n\n    /* hardcoded call to libinjection on CONTENT, apply internal rule if\n     * matched. */\n    issqli = libinjection_xss((const char*)value->data, value->len);\n    if (issqli == 1) {\n      ngx_http_apply_rulematch_v_n(&nx_int__libinject_xss, ctx, req, name, value, zone, 1, 0);\n    }\n  }\n}\n\nint\nngx_http_basestr_ruleset_n(ngx_pool_t*             pool,\n                           ngx_str_t*              name,\n                           ngx_str_t*              value,\n                           ngx_array_t*            rules,\n                           ngx_http_request_t*     req,\n                           ngx_http_request_ctx_t* ctx,\n                           naxsi_match_zone_t      zone)\n{\n  ngx_http_rule_t*                 r;\n  unsigned int                     i, ret, z, uri_constraint_ok = 1, rule_matched = 0;\n  ngx_int_t                        nb_match = 0;\n  ngx_http_custom_rule_location_t* location;\n\n  naxsi_escape_nullbytes(value);\n\n  NX_DEBUG(_debug_basestr_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX- check check [%V]=[%V] in zone %s\",\n           name,\n           value,\n           zone == BODY       ? \"BODY\"\n           : zone == HEADERS  ? \"HEADERS\"\n           : zone == URL      ? \"URL\"\n           : zone == ARGS     ? \"ARGS\"\n           : zone == FILE_EXT ? \"FILE_EXT\"\n           : zone == RAW_BODY ? \"RAW_BODY\"\n                              : \"UNKNOWN\");\n\n  if (!rules) {\n    ngx_log_debug(\n      NGX_LOG_DEBUG_HTTP, req->connection->log, 0, \"XX-no no rules has been defined for naxsi.\");\n    return (0);\n  }\n  r = rules->elts;\n  NX_DEBUG(_debug_basestr_ruleset,\n           NGX_LOG_DEBUG_HTTP,\n           req->connection->log,\n           0,\n           \"XX-checking %d rules ...\",\n           rules->nelts);\n\n  /* check for overlong/surrogate utf8 encoding */\n  if (ngx_utf8_check(name) != NULL) {\n    ngx_http_apply_rulematch_v_n(&nx_int__bad_utf8, ctx, req, NULL, NULL, zone, 1, 1);\n    return (0);\n  } else if (ngx_utf8_check(value) != NULL) {\n    ngx_http_apply_rulematch_v_n(&nx_int__bad_utf8, ctx, req, NULL, NULL, zone, 1, 0);\n    return (0);\n  }\n\n  /* call to libinjection */\n  ngx_http_libinjection(pool, name, value, ctx, req, zone);\n\n  for (i = 0; i < rules->nelts && ((!ctx->block || ctx->learning) && !ctx->drop); i++) {\n    /*properly reset counter*/\n    uri_constraint_ok = 1;\n    rule_matched      = 0;\n    NX_DEBUG(_debug_basestr_ruleset,\n             NGX_LOG_DEBUG_HTTP,\n             req->connection->log,\n             0,\n             \"XX-RULE %d : START\",\n             r[i].rule_id);\n\n    /* does the rule have a custom location ? custom location means checking\n     * only on a specific argument */\n    if (name && r[i].br->custom_location) {\n      location = r[i].br->custom_locations->elts;\n\n      /*\n      ** make a first pass, just in order to check that any\n      ** $URL / $URL_X constraints are validated before checking any other\n      ** parameters.\n      ** Unlike other criterias (wich are treated as 'OR')\n      ** this one must be valid to go forward\n      */\n      for (z = 0; z < r[i].br->custom_locations->nelts; z++) {\n\n        if (location[z].specific_url) {\n          /* if matchzone is a regex, ensure it matches (ie. BODY_VAR_X /\n           * ARGS_VAR_X / ..) */\n          if (r[i].br->rx_mz) {\n\n            if (ngx_http_naxsi_pcre_wrapper(location[z].target_rx, req->uri.data, req->uri.len) ==\n                -1) {\n              uri_constraint_ok = 0;\n            }\n          }\n\n          /* if it was a static string, ensure it matches (ie. BODY_VAR /\n           * ARGS_VAR / ..) */\n          if (!r[i].br->rx_mz) {\n            if (req->uri.len != location[z].target.len ||\n                strncasecmp((const char*)req->uri.data,\n                            (const char*)location[z].target.data,\n                            req->uri.len) != 0) {\n              uri_constraint_ok = 0;\n            }\n          }\n          break;\n        }\n      }\n\n      /*\n      ** if one of the custom location rule specifies an $URL/$URL_X\n      ** and it was mismatched, skip the rule.\n      */\n      if (uri_constraint_ok == 0) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX URI CONSTRAINT MISMATCH, SKIP\");\n        continue;\n      }\n\n      /* for each custom location */\n      for (z = 0; z < r[i].br->custom_locations->nelts; z++) {\n\n        rule_matched = 0;\n        /* check if zone is correct before checking names cf. issue #120 */\n        if (!(zone == BODY && location[z].body_var != 0) &&\n            !(zone == HEADERS && location[z].headers_var != 0) &&\n            !(zone == ARGS && location[z].args_var != 0))\n          continue;\n\n        /* if matchzone is a regex, ensure it matches (ie. BODY_VAR_X /\n         * ARGS_VAR_X / ..) */\n        if (r[i].br->rx_mz &&\n            ngx_http_naxsi_pcre_wrapper(location[z].target_rx, name->data, name->len) == -1)\n          continue;\n\n        /* if it was a static string, ensure it matches (ie. BODY_VAR / ARGS_VAR\n         * / ..) */\n        if ((!r[i].br->rx_mz) && (name->len != location[z].target.len ||\n                                  strncasecmp((const char*)name->data,\n                                              (const char*)location[z].target.data,\n                                              location[z].target.len)))\n          continue;\n\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-[SPECIFIC] check one rule [%d] iteration %d * %d\",\n                 r[i].rule_id,\n                 i,\n                 z);\n\n        /* match rule against var content, */\n        ret = ngx_http_process_basic_rule_buffer(value, &(r[i]), &nb_match);\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch [%V]=[%V] [rule=%d] (match %d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n          rule_matched = 1;\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 0);\n        }\n\n        if (!r[i].br->negative) {\n          /* match rule against var name, */\n          ret = ngx_http_process_basic_rule_buffer(name, &(r[i]), &nb_match);\n          /* if our rule matched, apply effects (score etc.) */\n          if (ret == 1) {\n            NX_DEBUG(_debug_basestr_ruleset,\n                     NGX_LOG_DEBUG_HTTP,\n                     req->connection->log,\n                     0,\n                     \"XX-apply rulematch[in name] [%V]=[%V] [rule=%d] (match \"\n                     \"%d times)\",\n                     name,\n                     value,\n                     r[i].rule_id,\n                     nb_match);\n            rule_matched = 1;\n            ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, name, zone, nb_match, 1);\n          }\n        }\n        if (rule_matched == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-[SPECIFIC] Rule %d matched in custom_location, go to next rule\",\n                   r[i].rule_id);\n\n          break;\n        }\n      }\n    }\n\n    /*\n    ** check against the rule if the current zone is matching\n    ** the zone the rule is meant to be check against\n    */\n    if ((zone == HEADERS && r[i].br->headers) || (zone == URL && r[i].br->url) ||\n        (zone == ARGS && r[i].br->args) || (zone == BODY && r[i].br->raw_body) ||\n        (zone == BODY && r[i].br->body_rule) || (zone == FILE_EXT && r[i].br->file_ext)) {\n\n      /*\n      ** If the Rule **specifically** targets name (ie. mz:BODY|NAME), only\n      *check against name\n      */\n      if (!r[i].br->target_name) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-test rulematch (value) [zone-wide]!1 [%V]=[%V] [rule =%d] \"\n                 \"(%d times)\",\n                 name,\n                 value,\n                 r[i].rule_id,\n                 nb_match);\n\n        /* check the rule against the value*/\n        ret = ngx_http_process_basic_rule_buffer(value, &(r[i]), &nb_match);\n        /*if our rule matched, apply effects (score etc.)*/\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch (value) [%V]=[%V] [rule=%d] (%d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 0);\n        }\n      }\n\n      if (!r[i].br->negative) {\n        NX_DEBUG(_debug_basestr_ruleset,\n                 NGX_LOG_DEBUG_HTTP,\n                 req->connection->log,\n                 0,\n                 \"XX-test rulematch [against-name]!1 [%V]=[%V] [rule=%d] (%d times)\",\n                 name,\n                 value,\n                 r[i].rule_id,\n                 nb_match);\n\n        /* check the rule against the name*/\n        ret = ngx_http_process_basic_rule_buffer(name, &(r[i]), &nb_match);\n        /*if our rule matched, apply effects (score etc.)*/\n        if (ret == 1) {\n          NX_DEBUG(_debug_basestr_ruleset,\n                   NGX_LOG_DEBUG_HTTP,\n                   req->connection->log,\n                   0,\n                   \"XX-apply rulematch!1 [%V]=[%V] [rule=%d] (%d times)\",\n                   name,\n                   value,\n                   r[i].rule_id,\n                   nb_match);\n\n          ngx_http_apply_rulematch_v_n(&(r[i]), ctx, req, name, value, zone, nb_match, 1);\n        }\n      }\n    }\n  }\n  return (0);\n}\n\n/*\n** does : parse body data, a.k.a POST/PUT datas. identifies content-type,\n**    and, if appropriate, boundary. then parse the stuff if multipart/for..\n**    or rely on spliturl if application/x-w..\n** this function sucks ! I don't parse bigger-than-body-size posts that\n**     are partially stored in files, TODO ;)\n*/\n\n/*\n** Parse content-disposition line.\n*/\nint\nnx_content_disposition_parse(unsigned char*      str,\n                             unsigned char*      line_end,\n                             unsigned char**     fvarn_start,\n                             unsigned char**     fvarn_end,\n                             unsigned char**     ffilen_start,\n                             unsigned char**     ffilen_end,\n                             ngx_http_request_t* r)\n{\n\n  unsigned char *varn_start = NULL, *varn_end = NULL;\n  unsigned char *filen_start = NULL, *filen_end = NULL;\n  /* we have two cases :\n  ** ---- file upload\n  ** Content-Disposition: form-data; name=\"somename\";\n  *filename=\"NetworkManager.conf\"\\r\\n\n  ** Content-Type: application/octet-stream\\r\\n\\r\\n\n  ** <DATA>\n  ** ---- normal post var\n  ** Content-Disposition: form-data; name=\"lastname\"\\r\\n\\r\\n\n  ** <DATA>\n  */\n\n  while (str < line_end) {\n    /* rfc allow spaces and tabs inbetween */\n    while (str < line_end && (*str == ' ' || *str == '\\t')) {\n      str++;\n    }\n    if (str < line_end && *str == ';') {\n      str++;\n    }\n    while (str < line_end && (*str == ' ' || *str == '\\t')) {\n      str++;\n    }\n\n    if (str >= line_end) {\n      break;\n    }\n\n    if (!ngx_strncmp(str, \"name=\\\"\", 6)) {\n      /* we already successfully parsed a name, reject that. */\n      if (varn_end || varn_start) {\n        return (NGX_ERROR);\n      }\n\n      varn_end = varn_start = str + 6;\n      do {\n        varn_end = (unsigned char*)strnchr((const char*)varn_end, '\"', line_end - varn_start);\n        if (!varn_end || (varn_end && *(varn_end - 1) != '\\\\')) {\n          break;\n        }\n        varn_end++;\n      } while (varn_end && varn_end < line_end);\n\n      if (!varn_end || !*varn_end) {\n        return (NGX_ERROR);\n      }\n\n      str = varn_end;\n      if (str < line_end + 1) {\n        str++;\n      } else {\n        return (NGX_ERROR);\n      }\n      *fvarn_start = varn_start;\n      *fvarn_end   = varn_end;\n    } else if (!ngx_strncmp(str, \"filename=\\\"\", 10)) {\n      /* we already successfully parsed a filename, reject that. */\n      if (filen_end || filen_start) {\n        return (NGX_ERROR);\n      }\n      filen_end = filen_start = str + 10;\n      do {\n        filen_end = (unsigned char*)strnchr((const char*)filen_end, '\"', line_end - filen_start);\n        if (!filen_end) {\n          break;\n        }\n        if (filen_end && *(filen_end - 1) != '\\\\') {\n          break;\n        }\n        filen_end++;\n      } while (filen_end && filen_end < line_end);\n      if (!filen_end) {\n        return (NGX_ERROR);\n      }\n      str = filen_end;\n      if (str < line_end + 1) {\n        str++;\n      } else {\n        return (NGX_ERROR);\n      }\n      *ffilen_end   = filen_end;\n      *ffilen_start = filen_start;\n    } else if (str == line_end - 1) {\n      break;\n    } else {\n      /* gargabe is present ?*/\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"extra data in content-disposition ? end:%p, str:%p, diff=%d\",\n               line_end,\n               str,\n               line_end - str);\n\n      return (NGX_ERROR);\n    }\n  }\n  /* tssk tssk */\n  if (filen_end > line_end || varn_end > line_end) {\n    return (NGX_ERROR);\n  }\n  return (NGX_OK);\n}\n\nint\nnx_content_type_parse(ngx_http_request_t* r, unsigned char** boundary, unsigned int* boundary_len)\n{\n  unsigned char* h;\n  unsigned char* end;\n\n  h   = r->headers_in.content_type->value.data + strlen(\"multipart/form-data;\");\n  end = r->headers_in.content_type->value.data + r->headers_in.content_type->value.len;\n  /* skip potential whitespace/tabs */\n  while (h < end && *h && (*h == ' ' || *h == '\\t'))\n    h++;\n  if (strncmp((const char*)h, \"boundary=\", 9))\n    return (NGX_ERROR);\n  h += 9;\n  *boundary_len = end - h;\n  *boundary     = h;\n  /* RFC 1867/1341 says 70 char max,\n     I arbitrarily set min to 3 (yes) */\n  if (*boundary_len > 70 || *boundary_len < 3)\n    return (NGX_ERROR);\n  return (NGX_OK);\n}\n\nvoid\nngx_http_naxsi_multipart_parse(ngx_http_request_ctx_t* ctx,\n                               ngx_http_request_t*     r,\n                               u_char*                 src,\n                               u_int                   len)\n{\n  ngx_str_t                   final_var, final_data;\n  u_char *                    boundary, *varn_start, *varn_end;\n  u_char *                    filen_start, *filen_end;\n  u_char *                    end, *line_end;\n  u_int                       boundary_len, varn_len, varc_len, idx, nullbytes;\n  ngx_http_naxsi_loc_conf_t*  cf;\n  ngx_http_naxsi_main_conf_t* main_cf;\n\n  cf      = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  main_cf = ngx_http_get_module_main_conf(r, ngx_http_naxsi_module);\n\n  /*extract boundary*/\n  if (nx_content_type_parse(r, (unsigned char**)&boundary, &boundary_len) != NGX_OK) {\n    if (boundary && boundary_len > 1) {\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX-POST boundary : (%s) : %d\",\n               boundary,\n               boundary_len);\n    }\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n  NX_DEBUG(_debug_post_heavy,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"XX-POST boundary : (%s) : %d\",\n           boundary,\n           boundary_len);\n\n  /* fetch every line starting with boundary */\n  idx = 0;\n  while (idx < len) {\n\n    NX_DEBUG(_debug_post_heavy,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-POST data : (%s)\",\n             src + idx);\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,\n                  r->connection->log,\n                  0,\n                  \"Remaining Len:%d (boundary len:%d)\",\n                  len - idx,\n                  boundary_len);\n\n    /* if we've reached the last boundary '--' + boundary + '--' + '\\r\\n'$END */\n    /* Authorize requests that don't have the leading \\r\\n */\n    if (idx + boundary_len + 6 == len || idx + boundary_len + 4 == len) {\n      if (ngx_strncmp(src + idx, \"--\", 2) || ngx_strncmp(src + idx + 2, boundary, boundary_len) ||\n          ngx_strncmp(src + idx + boundary_len + 2, \"--\", 2)) {\n        /* bad closing boundary ?*/\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n        return;\n      } else\n        break;\n    }\n\n    /* --boundary\\r\\n : New var */\n    if ((len - idx < 4 + boundary_len) || src[idx] != '-' || src[idx + 1] != '-' ||\n        /* and if it's really followed by a boundary */\n        ngx_strncmp(src + idx + 2, boundary, boundary_len) ||\n        /* and if it's not the last boundary of the buffer */\n        idx + boundary_len + 2 + 2 >= len ||\n        /* and if it's followed by \\r\\n */\n        src[idx + boundary_len + 2] != '\\r' || src[idx + boundary_len + 3] != '\\n') {\n      /* bad boundary */\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_boundary, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n    idx += boundary_len + 4;\n    /* we have two cases :\n    ** ---- file upload\n    ** Content-Disposition: form-data; name=\"somename\";\n    *filename=\"NetworkManager.conf\"\\r\\n\n    ** Content-Type: application/octet-stream\\r\\n\\r\\n\n    ** <DATA>\n    ** ---- normal post var\n    ** Content-Disposition: form-data; name=\"lastname\"\\r\\n\\r\\n\n    ** <DATA>\n    */\n    /* 31 = echo -n \"content-disposition: form-data;\" | wc -c */\n    if (ngx_strncasecmp(src + idx, (u_char*)\"content-disposition: form-data;\", 31)) {\n      ngx_log_debug(\n        NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"Unknown content-type: [%s]\", src + idx);\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : unknown content-disposition\");\n      }\n      return;\n    }\n    idx += 31;\n    line_end = (u_char*)ngx_strchr(src + idx, '\\n');\n    if (!line_end) {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : malformed boundary line\");\n      }\n      return;\n    }\n    /* Parse content-disposition, extract name / filename */\n    varn_start = varn_end = filen_start = filen_end = NULL;\n    if (nx_content_disposition_parse(\n          src + idx, line_end, &varn_start, &varn_end, &filen_start, &filen_end, r) != NGX_OK) {\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n    /* var name is mandatory */\n    if (!varn_start || !varn_end || varn_end <= varn_start) {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : no 'name' in POST var\");\n      }\n      return;\n    }\n    varn_len = varn_end - varn_start;\n\n    /* If there is a filename, it is followed by a \"content-type\" line, skip it\n     */\n    if (filen_start && filen_end) {\n      line_end = (u_char*)ngx_strchr(line_end + 1, '\\n');\n      if (!line_end) {\n        if (ngx_http_apply_rulematch_v_n(\n              &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n          naxsi_error_fatal(ctx, r, \"POST data : malformed filename (no content-type ?)\");\n        }\n        return;\n      }\n    }\n    /*\n    ** now idx point to the end of the\n    ** content-disposition: form-data; filename=\"\" name=\"\"\n    */\n    idx += (u_char*)line_end - (src + idx) + 1;\n    if (src[idx] != '\\r' || src[idx + 1] != '\\n') {\n      if (ngx_http_apply_rulematch_v_n(\n            &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n        naxsi_error_fatal(ctx, r, \"POST data : malformed content-disposition line\");\n      }\n      return;\n    }\n    idx += 2;\n    /* seek the end of the data */\n    end = NULL;\n    while (idx < len) {\n      end = (u_char*)sstrfaststr(src + idx, len - idx, \"\\r\\n--\", strlen(\"\\r\\n--\"));\n      /* file data can contain \\x0 */\n      while (!end) {\n        idx += strlen((const char*)src + idx);\n        if (idx < len - 2) {\n          idx++;\n          end = (u_char*)sstrfaststr(src + idx, len - idx, \"\\r\\n--\", strlen(\"\\r\\n--\"));\n        } else {\n          break;\n        }\n      }\n      if (!end || ngx_strncmp(end + 4, boundary, boundary_len)) {\n        if (ngx_http_apply_rulematch_v_n(\n              &nx_int__uncommon_post_format, ctx, r, NULL, NULL, BODY, 1, 0)) {\n          naxsi_error_fatal(ctx, r, \"POST data : malformed content-disposition line\");\n        }\n        return;\n      }\n      if (!ngx_strncmp(end + 4, boundary, boundary_len)) {\n        break;\n      } else {\n        idx += ((u_char*)end - (src + idx)) + 1;\n        end = NULL;\n      }\n    }\n    if (!end) {\n      naxsi_error_fatal(ctx, r, \"POST data : malformed line\");\n      return;\n    }\n    if (filen_start) {\n      final_var.data  = (unsigned char*)varn_start;\n      final_var.len   = varn_len;\n      final_data.data = (unsigned char*)filen_start;\n      final_data.len  = filen_end - filen_start;\n      nullbytes       = naxsi_unescape(&final_var);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 1);\n      }\n      nullbytes = naxsi_unescape(&final_data);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 0);\n      }\n\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"[POST] checking filename [%V] = [%V]\",\n               &final_var,\n               &final_data);\n\n      /* here we got val name + val content !*/\n      if (cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, cf->body_rules, r, ctx, FILE_EXT);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"[POST] No local body rules\");\n      }\n\n      if (main_cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, main_cf->body_rules, r, ctx, FILE_EXT);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"[POST] No main body rules\");\n      }\n\n      idx += (u_char*)end - (src + idx);\n    } else if (varn_start) {\n      varc_len        = (u_char*)end - (src + idx);\n      final_var.data  = (unsigned char*)varn_start;\n      final_var.len   = varn_len;\n      final_data.data = src + idx;\n      final_data.len  = varc_len;\n      nullbytes       = naxsi_unescape(&final_var);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 1);\n      }\n      nullbytes = naxsi_unescape(&final_data);\n      if (nullbytes > 0) {\n        ngx_http_apply_rulematch_v_n(\n          &nx_int__uncommon_hex_encoding, ctx, r, &final_var, &final_data, BODY, 1, 0);\n      }\n\n      NX_DEBUG(_debug_post_heavy,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"[POST] [%V]=[%V]\",\n               &final_var,\n               &final_data);\n\n      /* here we got val name + val content !*/\n      if (cf->body_rules) {\n        ngx_http_basestr_ruleset_n(r->pool, &final_var, &final_data, cf->body_rules, r, ctx, BODY);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"No local body rules ?!\");\n      }\n\n      if (main_cf->body_rules) {\n        ngx_http_basestr_ruleset_n(\n          r->pool, &final_var, &final_data, main_cf->body_rules, r, ctx, BODY);\n      } else {\n        NX_DEBUG(_debug_post_heavy,\n                 /* here we got val name + val content !*/\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"No main body rules ?!\");\n      }\n\n      idx += (u_char*)end - (src + idx);\n    } else {\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"(multipart) : \");\n    }\n    if (!ngx_strncmp(end, \"\\r\\n\", 2))\n      idx += 2;\n  }\n}\n\nvoid\nngx_http_naxsi_body_parse(ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_naxsi_main_conf_t* main_cf)\n{\n  u_char*      src;\n  ngx_str_t    tmp;\n  ngx_chain_t* bb;\n  u_char*      full_body;\n  u_int        full_body_len;\n\n  NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-BODY PARSE\");\n\n  if (!r->request_body->bufs) {\n    ngx_http_apply_rulematch_v_n(&nx_int__empty_post_body, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n  if (!r->headers_in.content_type) {\n    NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-No content type ..\");\n\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_content_type, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  if (r->request_body->temp_file) {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP,\n                  r->connection->log,\n                  0,\n                  \"naxsi: POST REQUEST to temp_file, partially parsed.\");\n    ngx_http_apply_rulematch_v_n(&nx_int__big_request, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  NX_DEBUG(_debug_body_parse, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-VALID BODY\");\n\n  /* request body in single buffer */\n  if (r->request_body->bufs->next == NULL) {\n    full_body_len = (u_int)(r->request_body->bufs->buf->last - r->request_body->bufs->buf->pos);\n    full_body     = ngx_pcalloc(r->pool, (u_int)(full_body_len + 1));\n    memcpy(full_body, r->request_body->bufs->buf->pos, full_body_len);\n  }\n\n  /* request body in chain */\n  else {\n    NX_DEBUG(_debug_body_parse,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"[POST] REQUEST BODY IN CHAIN !\");\n\n    for (full_body_len = 0, bb = r->request_body->bufs; bb; bb = bb->next)\n      full_body_len += (bb->buf->last - bb->buf->pos);\n    full_body = ngx_pcalloc(r->pool, full_body_len + 1);\n    src       = full_body;\n    if (!full_body)\n      return;\n    for (bb = r->request_body->bufs; bb; bb = bb->next)\n      full_body = ngx_cpymem(full_body, bb->buf->pos, bb->buf->last - bb->buf->pos);\n    full_body = src;\n    NX_DEBUG(_debug_body_parse,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"[POST] REQUEST BODY IN CHAIN [%s] (len=%d)\",\n             full_body,\n             full_body_len);\n  }\n\n  NX_DEBUG(_debug_body_parse,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"content-len header (%d) mismatch actual len (%d) ??\",\n           r->headers_in.content_length_n,\n           full_body_len);\n\n  /* File probably got buffered. */\n  if (r->headers_in.content_length_n != full_body_len) {\n    ngx_http_apply_rulematch_v_n(&nx_int__big_request, ctx, r, NULL, NULL, BODY, 1, 0);\n    return;\n  }\n\n  /* x-www-form-urlencoded POSTs */\n  /* 33 = echo -n \"application/x-www-form-urlencoded\" | wc -c */\n  if (!ngx_strncasecmp(\n        r->headers_in.content_type->value.data, (u_char*)\"application/x-www-form-urlencoded\", 33)) {\n    NX_DEBUG(\n      _debug_post_heavy, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-application/x-www..\");\n\n    tmp.len  = full_body_len;\n    tmp.data = full_body;\n\n    NX_DEBUG(\n      _debug_post_heavy, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-POST DATA [%V]\", &tmp);\n\n    if (ngx_http_spliturl_ruleset(\n          r->pool, &tmp, cf->body_rules, main_cf->body_rules, r, ctx, BODY)) {\n      ngx_http_apply_rulematch_v_n(&nx_int__uncommon_url, ctx, r, NULL, NULL, BODY, 1, 0);\n      return;\n    }\n  }\n  /* 19 = echo -n \"multipart/form-data\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"multipart/form-data\", 19)) {\n    ngx_http_naxsi_multipart_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 16 = echo -n \"application/json\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/json\", 16)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 24 = echo -n \"application/vnd.api+json\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/vnd.api+json\", 24)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  }\n  /* 22 = echo -n \"application/csp-report\" | wc -c */\n  else if (!ngx_strncasecmp(\n             r->headers_in.content_type->value.data, (u_char*)\"application/csp-report\", 22)) {\n    ngx_http_naxsi_json_parse(ctx, r, full_body, full_body_len);\n  } else {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"[POST] Unknown content-type\");\n    ngx_http_apply_rulematch_v_n(&nx_int__uncommon_content_type, ctx, r, NULL, NULL, BODY, 1, 0);\n    /*\n    ** Only attempt to process \"raw\" body if id:nx_int__uncommon_content_type\n    *was\n    ** whitelisted. Else, it should be blocking and stop processing here.\n    */\n    if ((!ctx->block || ctx->learning) && !ctx->drop) {\n      ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"After uncommon content-type\");\n      ngx_http_naxsi_rawbody_parse(ctx, r, full_body, full_body_len);\n    }\n  }\n}\n\n/*\n** does : this is a 'main' function, all the stuff goes from here.\n**    to make it short, it does the following :\n** - if we got header rules, apply header_rules on each.\n** - apply generic_rules on url decoded URI.\n** - if we got get_rules and get args, apply get_rules varname/value couple.\n** - if we are in a POST/PUT request and we got body_rules, apply rules :)\n*/\nvoid\nngx_http_naxsi_uri_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                         ngx_http_naxsi_loc_conf_t*  cf,\n                         ngx_http_request_ctx_t*     ctx,\n                         ngx_http_request_t*         r)\n{\n  ngx_str_t tmp, name;\n\n  if (!r->uri.len)\n    return;\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  if (!main_cf->generic_rules && !cf->generic_rules) {\n    tmp.data = NULL;\n    tmp.len  = 0;\n    ngx_http_apply_rulematch_v_n(&nx_int__no_rules, ctx, r, &tmp, &tmp, URL, 1, 0);\n    return;\n  }\n  tmp.len  = r->uri.len;\n  tmp.data = ngx_pcalloc(r->pool, r->uri.len + 1);\n  if (!tmp.data) {\n    naxsi_error_fatal(ctx, r, \"failed alloc of %d\", r->uri.len + 1);\n    return;\n  }\n  memcpy(tmp.data, r->uri.data, r->uri.len);\n  if (naxsi_escape_nullbytes(&tmp) > 0) {\n    ngx_str_t tmp_name, tmp_val;\n    tmp_name.data = tmp_val.data = NULL;\n    tmp_name.len = tmp_val.len = 0;\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__uncommon_hex_encoding, ctx, r, &tmp_name, &tmp_val, URL, 1, 0);\n  }\n  name.data = NULL;\n  name.len  = 0;\n  if (cf->generic_rules)\n    ngx_http_basestr_ruleset_n(r->pool, &name, &tmp, cf->generic_rules, r, ctx, URL);\n  if (main_cf->generic_rules)\n    ngx_http_basestr_ruleset_n(r->pool, &name, &tmp, main_cf->generic_rules, r, ctx, URL);\n  ngx_pfree(r->pool, tmp.data);\n}\n\nvoid\nngx_http_naxsi_args_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                          ngx_http_naxsi_loc_conf_t*  cf,\n                          ngx_http_request_ctx_t*     ctx,\n                          ngx_http_request_t*         r)\n{\n  ngx_str_t tmp;\n\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  if (!r->args.len)\n    return;\n  if (!cf->get_rules && !main_cf->get_rules)\n    return;\n  tmp.len  = r->args.len;\n  tmp.data = ngx_pcalloc(r->pool, r->args.len + 1);\n  if (!tmp.data) {\n    naxsi_error_fatal(ctx, r, \"failed alloc\");\n    return;\n  }\n  memcpy(tmp.data, r->args.data, r->args.len);\n\n  if (ngx_http_spliturl_ruleset(r->pool, &tmp, cf->get_rules, main_cf->get_rules, r, ctx, ARGS)) {\n    naxsi_error_fatal(ctx, r, \"spliturl error : malformed url, possible attack\");\n    return;\n  }\n  ngx_pfree(r->pool, tmp.data);\n}\n\nvoid\nngx_http_naxsi_headers_parse(ngx_http_naxsi_main_conf_t* main_cf,\n                             ngx_http_naxsi_loc_conf_t*  cf,\n                             ngx_http_request_ctx_t*     ctx,\n                             ngx_http_request_t*         r)\n{\n  ngx_list_part_t* part;\n  ngx_table_elt_t* h;\n  unsigned int     i;\n  ngx_str_t        lowcase_header;\n\n  if (!cf->header_rules && !main_cf->header_rules)\n    return;\n  // this check may be removed, as it shouldn't be needed anymore !\n  if ((ctx->block && !ctx->learning) || ctx->drop)\n    return;\n  part = &r->headers_in.headers.part;\n  h    = part->elts;\n  // this check may be removed, as it shouldn't be needed anymore !\n  for (i = 0; ((!ctx->block || ctx->learning) && !ctx->block); i++) {\n    if (i >= part->nelts) {\n      if (part->next == NULL)\n        break;\n      part = part->next;\n      h    = part->elts;\n      i    = 0;\n    }\n    lowcase_header.data = h[i].lowcase_key;\n    lowcase_header.len  = h[i].key.len;\n    if (naxsi_escape_nullbytes(&lowcase_header) > 0) {\n      ngx_http_apply_rulematch_v_n(\n        &nx_int__uncommon_hex_encoding, ctx, r, &h[i].key, &h[i].value, HEADERS, 1, 1);\n    }\n    if (naxsi_escape_nullbytes(&h[i].value) > 0) {\n      ngx_http_apply_rulematch_v_n(\n        &nx_int__uncommon_hex_encoding, ctx, r, &h[i].key, &h[i].value, HEADERS, 1, 0);\n    }\n    if (cf->header_rules) {\n      ngx_http_basestr_ruleset_n(\n        r->pool, &lowcase_header, &(h[i].value), cf->header_rules, r, ctx, HEADERS);\n    }\n    if (main_cf->header_rules) {\n      ngx_http_basestr_ruleset_n(\n        r->pool, &lowcase_header, &(h[i].value), main_cf->header_rules, r, ctx, HEADERS);\n    }\n  }\n\n  if (naxsi_is_illegal_host_name(&r->headers_in.server) > 0) {\n    ngx_http_apply_rulematch_v_n(\n      &nx_int__illegal_host_header, ctx, r, NULL, &r->headers_in.server, HEADERS, 1, 0);\n  }\n  return;\n}\n\nvoid\nngx_http_naxsi_data_parse(ngx_http_request_ctx_t* ctx, ngx_http_request_t* r)\n{\n  ngx_http_naxsi_loc_conf_t*  cf;\n  ngx_http_naxsi_main_conf_t* main_cf;\n\n  cf      = ngx_http_get_module_loc_conf(r, ngx_http_naxsi_module);\n  main_cf = ngx_http_get_module_main_conf(r, ngx_http_naxsi_module);\n  if (!cf || !ctx) {\n    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"naxsi: unable to parse data.\");\n    return;\n  }\n  /* process rules only if request is not already blocked or if\n     the learning mode is enabled */\n  ngx_http_naxsi_headers_parse(main_cf, cf, ctx, r);\n  /* check uri */\n  ngx_http_naxsi_uri_parse(main_cf, cf, ctx, r);\n  /* check args */\n  ngx_http_naxsi_args_parse(main_cf, cf, ctx, r);\n  /* check method */\n  if ((r->method == NGX_HTTP_PATCH || r->method == NGX_HTTP_POST || r->method == NGX_HTTP_PUT) &&\n      /* presence of body rules (PATCH/POST/PUT rules) */\n      (cf->body_rules || main_cf->body_rules) &&\n      /* and the presence of data to parse */\n      r->request_body && ((!ctx->block || ctx->learning) && !ctx->drop))\n    ngx_http_naxsi_body_parse(ctx, r, cf, main_cf);\n\n  ngx_http_naxsi_update_current_ctx_status(ctx, cf, r);\n}\n\nvoid\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-custom check rules\");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore client ip: %V\",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-we have custom check rules and CTX got special score :)\");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \"XX- custom score rule triggered ..\");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}\n\n/*\n** This function is called when the body is read.\n** Will set-up flags to tell that parsing can be done,\n** and then run the core phases again\n** (WARNING: check backward compatibility of count--\n** with older version of nginx 0.7.x)\n*/\nvoid\nngx_http_naxsi_payload_handler(ngx_http_request_t* r)\n{\n  ngx_http_request_ctx_t* ctx;\n  ctx        = ngx_http_get_module_ctx(r, ngx_http_naxsi_module);\n  ctx->ready = 1;\n  r->count--;\n  NX_DEBUG(_debug_payload_handler,\n           NGX_LOG_DEBUG_HTTP,\n           r->connection->log,\n           0,\n           \"XX-dummy PAYLOAD HANDLER !\");\n\n  if (ctx->wait_for_body) {\n    NX_DEBUG(_debug_payload_handler,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-dummy : AFTER NGX_AGAIN\");\n\n    ctx->wait_for_body = 0;\n    ngx_http_core_run_phases(r);\n  }\n}\n", "#vi:filetype=perl\n\nuse lib 'lib';\nuse Test::Nginx::Socket;\n\nrepeat_each(1);\n\nplan tests => repeat_each(1) * blocks();\nno_root_location();\nno_long_string();\n$ENV{TEST_NGINX_SERVROOT} = server_root();\nrun_tests();\n\n__DATA__\n=== TEST 1: IgnoreIP defined\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.1: IgnoreIP request \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.2.1: IgnoreIP request with X-Forwarded-For allow without real_ip config (ipv4) \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.2.2: IgnoreIP request with X-Forwarded-For allow with real_ip config (ipv4) \n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nset_real_ip_from 127.0.0.1;\nreal_ip_header X-Forwarded-For;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.3.1: IgnoreIP request with X-Forwarded-For allow without reaL_ip config (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP \"2001:4860:4860::8844\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8844\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.3.2: IgnoreIP request with X-Forwarded-For allow with real_ip config (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nset_real_ip_from 127.0.0.1;\nset_real_ip_from ::1/128;\nreal_ip_header X-Forwarded-For;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP \"2001:4860:4860::8844\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8844\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.4: IgnoreIP request with X-Forwarded-For deny (ipv4)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2.2.2.2\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.5: IgnoreIP request with X-Forwarded-For deny (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP \"2001:4860:4860::8844\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.6: Multiple IgnoreIP defined\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"1.1.1.1\";\n     IgnoreIP  \"1.2.3.4\";\n     IgnoreIP  \"2.3.4.1\";\n     IgnoreIP  \"2606:4700:4700::1111\";\n     IgnoreIP  \"2606:4700:4700::1001\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.7: Verify IgnoreIP (IPv4) works\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     #IgnoreIP  \"2606:4700:4700::1001\"; # IPv6 can't be tested.\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n=== TEST 1.8: IgnoreIP request inheritance\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n\n     location /foobar {\n          BasicRule wl:10;\n     }\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar?a=update/table\n--- curl\n--- curl_options: --interface 127.0.0.1\n--- error_code: 200\n\n=== TEST 1.9: IgnoreIP internal rules\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreIP  \"127.0.0.1\";\n     DeniedUrl \"/RequestDenied\";\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nPUT /foobar\n--- error_code: 405\n", "#vi:filetype=perl\n\nuse lib 'lib';\nuse Test::Nginx::Socket;\n\nrepeat_each(1);\n\nplan tests => repeat_each(1) * blocks();\nno_root_location();\nno_long_string();\n$ENV{TEST_NGINX_SERVROOT} = server_root();\nrun_tests();\n\n__DATA__\n=== TEST 1: IgnoreCIDR defined (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.1: IgnoreCIDR request (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /?a=buibui\n--- error_code: 200\n\n=== TEST 1.2.1: IgnoreCIDR request with X-Forwarded-For allow without real_ip config (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.2.2: IgnoreCIDR request with X-Forwarded-For allow with real_ip config (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nset_real_ip_from 127.0.0.1;\nreal_ip_header X-Forwarded-For;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 1.1.1.1\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.3: IgnoreCIDR request with X-Forwarded-For deny (no file)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"1.1.1.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n         index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2.2.2.2\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.4: Verify IgnoreCIDR works\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n\n=== TEST 1.5: Verify IgnoreCIDR x.x.x.x./32 is converted to IgnoreIP\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nMainRule \"str:/foobar\" \"mz:URL\" \"s:$TRAVERSAL:4\" id:123456;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.1/32\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar\n--- error_code: 200\n\n=== TEST 1.6.1: IgnoreCIDR request with X-Forwarded-For allow without real_ip config (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::/112\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.6.2: IgnoreCIDR request with X-Forwarded-For allow with real_ip config (ipv6)\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nset_real_ip_from 127.0.0.1;\nset_real_ip_from ::1/128;\nreal_ip_header X-Forwarded-For;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::/112\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.7.1: Verify IgnoreCIDR 2001:4860:4860::8888/128 is converted to IgnoreIP without real_ip config\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::8888/128\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 412\n\n=== TEST 1.7.2: Verify IgnoreCIDR 2001:4860:4860::8888/128 is converted to IgnoreIP with real_ip config\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\nset_real_ip_from 127.0.0.1;\nset_real_ip_from ::1/128;\nreal_ip_header X-Forwarded-For;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR \"2001:4860:4860::8888/128\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- more_headers\nX-Forwarded-For: 2001:4860:4860::8888\n--- request\nGET /?a=<>\n--- error_code: 200\n\n=== TEST 1.8: IgnoreCIDR request inheritance\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     CheckRule \"$SQL >= 8\" BLOCK;\n     CheckRule \"$RFI >= 8\" BLOCK;\n     CheckRule \"$TRAVERSAL >= 4\" BLOCK;\n     CheckRule \"$XSS >= 8\" BLOCK;\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n\n     location /foobar {\n          BasicRule wl:10;\n     }\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nGET /foobar?a=update/table\n--- curl\n--- curl_options: --interface 127.0.0.1\n--- error_code: 200\n\n=== TEST 1.9: IgnoreCIDR internal rules\n--- user_files\n>>> foobar\nfoobar text\n--- main_config\nload_module $TEST_NGINX_NAXSI_MODULE_SO;\n--- http_config\ninclude $TEST_NGINX_NAXSI_RULES;\n--- config\nlocation / {\n     SecRulesEnabled;\n     IgnoreCIDR  \"127.0.0.0/24\";\n     DeniedUrl \"/RequestDenied\";\n     root $TEST_NGINX_SERVROOT/html/;\n     index index.html index.htm;\n}\nlocation /RequestDenied {\n     return 412;\n}\n--- request\nPUT /foobar\n--- error_code: 405\n"], "filenames": [".scripts/ci-build.sh", "naxsi_src/naxsi_runtime.c", "unit-tests/tests/33ignoreip.t", "unit-tests/tests/34ignorecidr.t"], "buggy_code_start_loc": [51, 2915, 63, 63], "buggy_code_end_loc": [51, 2954, 113, 197], "fixing_code_start_loc": [52, 2914, 63, 63], "fixing_code_end_loc": [53, 2922, 170, 283], "type": "NVD-CWE-noinfo", "message": "NAXSI is an open-source maintenance web application firewall (WAF) for NGINX. An issue present starting in version 1.3 and prior to version 1.6 allows someone to bypass the WAF when a malicious `X-Forwarded-For` IP matches `IgnoreIP` `IgnoreCIDR` rules. This old code was arranged to allow older NGINX versions to also support `IgnoreIP` `IgnoreCIDR` when multiple reverse proxies were present. The issue is patched in version 1.6. As a workaround, do not set any `IgnoreIP` `IgnoreCIDR` for older versions.\n", "other": {"cve": {"id": "CVE-2023-45132", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-11T21:15:10.207", "lastModified": "2023-10-18T02:38:01.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NAXSI is an open-source maintenance web application firewall (WAF) for NGINX. An issue present starting in version 1.3 and prior to version 1.6 allows someone to bypass the WAF when a malicious `X-Forwarded-For` IP matches `IgnoreIP` `IgnoreCIDR` rules. This old code was arranged to allow older NGINX versions to also support `IgnoreIP` `IgnoreCIDR` when multiple reverse proxies were present. The issue is patched in version 1.6. As a workaround, do not set any `IgnoreIP` `IgnoreCIDR` for older versions.\n"}, {"lang": "es", "value": "NAXSI es un firewall de aplicaciones web (WAF) de mantenimiento de c\u00f3digo abierto para NGINX. Un problema est\u00e1 presente a partir de la versi\u00f3n 1.3 y anteriores a la versi\u00f3n 1.6 permite que alguien omita el WAF cuando una IP maliciosa `X-Forwarded-For` coincide con las reglas `IgnoreIP` `IgnoreCIDR`. Este c\u00f3digo antiguo se organiz\u00f3 para permitir que las versiones anteriores de NGINX tambi\u00e9n admitieran `IgnoreIP` `IgnoreCIDR` cuando hab\u00eda varios servidores proxy inversos presentes. El problema se solucion\u00f3 en la versi\u00f3n 1.6. Como workaround, no configure ning\u00fan `IgnoreIP` `IgnoreCIDR` para versiones anteriores."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-693"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wargio:naxsi:*:*:*:*:*:nginx:*:*", "versionStartIncluding": "1.3", "versionEndExcluding": "1.6", "matchCriteriaId": "8409BA98-A088-4290-86DF-9654A90D7FAF"}]}]}], "references": [{"url": "https://github.com/wargio/naxsi/commit/1b712526ed3314dd6be7e8b0259eabda63c19537", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wargio/naxsi/pull/103", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wargio/naxsi/security/advisories/GHSA-7qjc-q4j9-pc8x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wargio/naxsi/commit/1b712526ed3314dd6be7e8b0259eabda63c19537"}}