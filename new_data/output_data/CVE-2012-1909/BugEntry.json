{"buggy_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n#include \"headers.h\"\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\n// Name of client reported in the 'version' message. Report the same name\n// for both bitcoind and bitcoin-qt, to make it harder for attackers to\n// target servers or GUI users specifically.\nconst std::string CLIENT_NAME(\"Satoshi\");\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nstatic map<uint256, CTransaction> mapTransactions;\nCCriticalSection cs_mapTransactions;\nunsigned int nTransactionsUpdated = 0;\nmap<COutPoint, CInPoint> mapNextTx;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nuint256 hashGenesisBlock(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\nstatic CBigNum bnProofOfWorkLimit(~uint256(0) >> 32);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nCBigNum bnBestChainWork = 0;\nCBigNum bnBestInvalidWork = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64 nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n\nmap<uint256, CDataStream*> mapOrphanTransactions;\nmultimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n\ndouble dHashesPerSec;\nint64 nHPSTimerStart;\n\n// Settings\nint64 nTransactionFee = 0;\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    CRITICAL_BLOCK(cs_setpwalletRegistered)\n    {\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    CRITICAL_BLOCK(cs_setpwalletRegistered)\n    {\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid static SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid static ResendWalletTransactions()\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions();\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nvoid AddOrphanTx(const CDataStream& vMsg)\n{\n    CTransaction tx;\n    CDataStream(vMsg) >> tx;\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return;\n\n    CDataStream* pvMsg = mapOrphanTransactions[hash] = new CDataStream(vMsg);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CDataStream* pvMsg = mapOrphanTransactions[hash];\n    CTransaction tx;\n    CDataStream(*pvMsg) >> tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);\n             mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)\n        {\n            if ((*mi).second == pvMsg)\n                mapOrphanTransactionsByPrev.erase(mi++);\n            else\n                mi++;\n        }\n    }\n    delete pvMsg;\n    mapOrphanTransactions.erase(hash);\n}\n\nint LimitOrphanTxSize(int nMaxOrphans)\n{\n    int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        std::vector<unsigned char> randbytes(32);\n        RAND_bytes(&randbytes[0], 32);\n        uint256 randomhash(randbytes);\n        map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n            nArgsExpected += ScriptSigArgsExpected(whichType2, vSolutions2);\n        }\n\n        if (stack.size() != nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nint\nCTransaction::GetLegacySigOpCount() const\n{\n    int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64 nValueOut = 0;\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!CheckTransaction())\n        return error(\"AcceptToMemoryPool() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (IsCoinBase())\n        return DoS(100, error(\"AcceptToMemoryPool() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)nLockTime > std::numeric_limits<int>::max())\n        return error(\"AcceptToMemoryPool() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !IsStandard())\n        return error(\"AcceptToMemoryPool() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = GetHash();\n    CRITICAL_BLOCK(cs_mapTransactions)\n        if (mapTransactions.count(hash))\n            return false;\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        COutPoint outpoint = vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!IsNewerThan(*ptxOld))\n                return false;\n            for (int i = 0; i < vin.size(); i++)\n            {\n                COutPoint outpoint = vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"AcceptToMemoryPool() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return error(\"AcceptToMemoryPool() : FetchInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = GetValueIn(mapInputs)-GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n\n        // Don't accept it if it can't get into a block\n        if (nFees < GetMinFee(1000, true, GMF_RELAY))\n            return error(\"AcceptToMemoryPool() : not enough fees\");\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            CRITICAL_BLOCK(cs)\n            {\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(*this))\n                    return error(\"AcceptToMemoryPool() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        if (ptxOld)\n        {\n            printf(\"AcceptToMemoryPool() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            ptxOld->RemoveFromMemoryPool();\n        }\n        AddToMemoryPoolUnchecked();\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"AcceptToMemoryPool(): accepted %s\\n\", hash.ToString().substr(0,10).c_str());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(bool fCheckInputs, bool* pfMissingInputs)\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n}\n\nuint64 nPooledTx = 0;\n\nbool CTransaction::AddToMemoryPoolUnchecked()\n{\n    printf(\"AcceptToMemoryPoolUnchecked(): size %lu\\n\",  mapTransactions.size());\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call AcceptToMemoryPool to properly check the transaction first.\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        uint256 hash = GetHash();\n        mapTransactions[hash] = *this;\n        for (int i = 0; i < vin.size(); i++)\n            mapNextTx[vin[i].prevout] = CInPoint(&mapTransactions[hash], i);\n        nTransactionsUpdated++;\n        ++nPooledTx;\n    }\n    return true;\n}\n\n\nbool CTransaction::RemoveFromMemoryPool()\n{\n    // Remove transaction from memory pool\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        uint256 hash = GetHash();\n        if (mapTransactions.count(hash))\n        {\n            BOOST_FOREACH(const CTxIn& txin, vin)\n                mapNextTx.erase(txin.prevout);\n            mapTransactions.erase(hash);\n            nTransactionsUpdated++;\n            --nPooledTx;\n        }\n    }\n    return true;\n}\n\n\n\n\n\n\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n{\n    if (hashBlock == 0 || nIndex == -1)\n        return 0;\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    // Make sure the merkle branch connects to this block\n    if (!fMerkleVerified)\n    {\n        if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n            return 0;\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return max(0, (COINBASE_MATURITY+20) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, false);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mapTransactions.count(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction() \n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\nint CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\nint64 static GetBlockValue(int nHeight, int64 nFees)\n{\n    int64 nSubsidy = 50 * COIN;\n\n    // Subsidy is cut in half every 4 years\n    nSubsidy >>= (nHeight / 210000);\n\n    return nSubsidy + nFees;\n}\n\nstatic const int64 nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\nstatic const int64 nTargetSpacing = 10 * 60;\nstatic const int64 nInterval = nTargetTimespan / nTargetSpacing;\n\n//\n// minimum amount of work that could possibly be required nTime after\n// minimum work required was nBase\n//\nunsigned int ComputeMinWork(unsigned int nBase, int64 nTime)\n{\n    // Testnet has min-difficulty blocks\n    // after nTargetSpacing*2 time between blocks:\n    if (fTestNet && nTime > nTargetSpacing*2)\n        return bnProofOfWorkLimit.GetCompact();\n\n    CBigNum bnResult;\n    bnResult.SetCompact(nBase);\n    while (nTime > 0 && bnResult < bnProofOfWorkLimit)\n    {\n        // Maximum 400% adjustment...\n        bnResult *= 4;\n        // ... in best-case exactly 4-times-normal target time\n        nTime -= nTargetTimespan*4;\n    }\n    if (bnResult > bnProofOfWorkLimit)\n        bnResult = bnProofOfWorkLimit;\n    return bnResult.GetCompact();\n}\n\nunsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlock *pblock)\n{\n    unsigned int nProofOfWorkLimit = bnProofOfWorkLimit.GetCompact();\n\n    // Genesis block\n    if (pindexLast == NULL)\n        return nProofOfWorkLimit;\n\n    // Only change once per interval\n    if ((pindexLast->nHeight+1) % nInterval != 0)\n    {\n        // Special rules for testnet after 15 Feb 2012:\n        if (fTestNet && pblock->nTime > 1329264000)\n        {\n            // If the new block's timestamp is more than 2* 10 minutes\n            // then allow mining of a min-difficulty block.\n            if (pblock->nTime - pindexLast->nTime > nTargetSpacing*2)\n                return nProofOfWorkLimit;\n            else\n            {\n                // Return the last non-special-min-difficulty-rules-block\n                const CBlockIndex* pindex = pindexLast;\n                while (pindex->pprev && pindex->nHeight % nInterval != 0 && pindex->nBits == nProofOfWorkLimit)\n                    pindex = pindex->pprev;\n                return pindex->nBits;\n            }\n        }\n\n        return pindexLast->nBits;\n    }\n\n    // Go back by what we want to be 14 days worth of blocks\n    const CBlockIndex* pindexFirst = pindexLast;\n    for (int i = 0; pindexFirst && i < nInterval-1; i++)\n        pindexFirst = pindexFirst->pprev;\n    assert(pindexFirst);\n\n    // Limit adjustment step\n    int64 nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n    printf(\"  nActualTimespan = %\"PRI64d\"  before bounds\\n\", nActualTimespan);\n    if (nActualTimespan < nTargetTimespan/4)\n        nActualTimespan = nTargetTimespan/4;\n    if (nActualTimespan > nTargetTimespan*4)\n        nActualTimespan = nTargetTimespan*4;\n\n    // Retarget\n    CBigNum bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= nTargetTimespan;\n\n    if (bnNew > bnProofOfWorkLimit)\n        bnNew = bnProofOfWorkLimit;\n\n    /// debug print\n    printf(\"GetNextWorkRequired RETARGET\\n\");\n    printf(\"nTargetTimespan = %\"PRI64d\"    nActualTimespan = %\"PRI64d\"\\n\", nTargetTimespan, nActualTimespan);\n    printf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n    printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n\n    return bnNew.GetCompact();\n}\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64 nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return (GetTime() - nLastUpdate < 10 &&\n            pindexBest->GetBlockTime() < GetTime() - 24 * 60 * 60);\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->bnChainWork > bnBestInvalidWork)\n    {\n        bnBestInvalidWork = pindexNew->bnChainWork;\n        CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n        MainFrameRepaint();\n    }\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s\\n\", pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight, pindexNew->bnChainWork.ToString().c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n        printf(\"InvalidChainFound: WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\\n\");\n}\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n\n    // Updating time can change work required on testnet:\n    if (fTestNet)\n        nBits = GetNextWorkRequired(pindexPrev, this);\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            CRITICAL_BLOCK(cs_mapTransactions)\n            {\n                if (!mapTransactions.count(prevout.hash))\n                    return error(\"FetchInputs() : %s mapTransactions prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mapTransactions[prevout.hash];\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n's are valid:\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64 nResult = 0;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nint CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int nSigOps = 0;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64 nValueIn = 0;\n        int64 nFees = 0;\n        for (int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase, check that it's matured\n            if (txPrev.IsCoinBase())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n                {\n                    // only during transition phase for P2SH: do not invoke anti-DoS code for\n                    // potentially old clients relaying bad P2SH transactions\n                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n                        return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (nValueIn < GetValueOut())\n            return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n        // Tally transaction fees\n        int64 nTxFee = nValueIn - GetValueOut();\n        if (nTxFee < 0)\n            return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n        nFees += nTxFee;\n        if (!MoneyRange(nFees))\n            return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        int64 nValueIn = 0;\n        for (int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mapTransactions.count(prevout.hash))\n                return false;\n            CTransaction& txPrev = mapTransactions[prevout.hash];\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, true, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    return true;\n}\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // To avoid being on the short end of a block-chain split,\n    // don't do secondary validation of pay-to-script-hash transactions\n    // until blocks with timestamps after paytoscripthashtime (see init.cpp for default).\n    // This code can be removed once a super-majority of the network has upgraded.\n    int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());\n    bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock failed\");\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            txdb.TxnAbort();\n            return error(\"Reorganize() : ConnectBlock failed\");\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete)\n        tx.RemoveFromMemoryPool();\n\n    printf(\"REORGANIZE: Disconnected %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connected %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    return true;\n}\n\n\nstatic void\nrunCommand(std::string strCommand)\n{\n    int nErr = ::system(strCommand.c_str());\n    if (nErr)\n        printf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    txdb.TxnBegin();\n    if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        // Adding to current best branch\n        if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : ConnectBlock failed\");\n        }\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n\n        // Add to current best branch\n        pindexNew->pprev->pnext = pindexNew;\n\n        // Delete redundant memory transactions\n        BOOST_FOREACH(CTransaction& tx, vtx)\n            tx.RemoveFromMemoryPool();\n    }\n    else\n    {\n        // New best branch\n        if (!Reorganize(txdb, pindexNew))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    nBestHeight = pindexBest->nHeight;\n    bnBestChainWork = pindexNew->bnChainWork;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n    printf(\"SetBestChain: new best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    pindexNew->phashBlock = &((*mi).first);\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n    pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n\n    CTxDB txdb;\n    txdb.TxnBegin();\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->bnChainWork > bnBestChainWork)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    txdb.Close();\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    MainFrameRepaint();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const\n{\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    // Check proof of work matches claimed amount\n    if (!CheckProofOfWork(GetHash(), nBits))\n        return DoS(50, error(\"CheckBlock() : proof of work failed\"));\n\n    // Check timestamp\n    if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n    int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    // Check merkleroot\n    if (hashMerkleRoot != BuildMerkleTree())\n        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n\n    return true;\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    // Check proof of work\n    if (nBits != GetNextWorkRequired(pindexPrev, this))\n        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n\n    // Check timestamp against prev\n    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n        return error(\"AcceptBlock() : block's timestamp is too early\");\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckBlock(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    if (hashBestChain == hash)\n        CRITICAL_BLOCK(cs_vNodes)\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 140700))\n                    pnode->PushInventory(CInv(MSG_BLOCK, hash));\n\n    return true;\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n    {\n        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n        if (deltaTime < 0)\n        {\n            if (pfrom)\n                pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n        }\n        CBigNum bnNewBlock;\n        bnNewBlock.SetCompact(pblock->nBits);\n        CBigNum bnRequired;\n        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n        if (bnNewBlock > bnRequired)\n        {\n            if (pfrom)\n                pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block with too little proof-of-work\");\n        }\n    }\n\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n    return true;\n}\n\n\n\n\n\n\n\n\nbool CheckDiskSpace(uint64 nAdditionalBytes)\n{\n    uint64 nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for 15MB because database could create another 10MB log file at any time\n    if (nFreeBytesAvailable < (uint64)15000000 + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low  \");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        ThreadSafeMessageBox(strMessage, \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n        CreateThread(Shutdown, NULL);\n        return false;\n    }\n    return true;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if (nFile == -1)\n        return NULL;\n    FILE* file = fopen(strprintf(\"%s/blk%04d.dat\", GetDataDir().c_str(), nFile).c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    loop\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if (ftell(file) < 0x7F000000 - MAX_SIZE)\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew)\n{\n    if (fTestNet)\n    {\n        hashGenesisBlock = uint256(\"0x00000007199508e34a9ff81e6ec0c477a4cccff2a4767a8eee39c11db367b008\");\n        bnProofOfWorkLimit = CBigNum(~uint256(0) >> 28);\n        pchMessageStart[0] = 0xfa;\n        pchMessageStart[1] = 0xbf;\n        pchMessageStart[2] = 0xb5;\n        pchMessageStart[3] = 0xda;\n    }\n\n    //\n    // Load block index\n    //\n    CTxDB txdb(\"cr\");\n    if (!txdb.LoadBlockIndex())\n        return false;\n    txdb.Close();\n\n    //\n    // Init with genesis block\n    //\n    if (mapBlockIndex.empty())\n    {\n        if (!fAllowNew)\n            return false;\n\n        // Genesis Block:\n        // CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\n        //   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n        //     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)\n        //     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)\n        //   vMerkleTree: 4a5e1e\n\n        // Genesis block\n        const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n        CTransaction txNew;\n        txNew.vin.resize(1);\n        txNew.vout.resize(1);\n        txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n        txNew.vout[0].nValue = 50 * COIN;\n        txNew.vout[0].scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n        CBlock block;\n        block.vtx.push_back(txNew);\n        block.hashPrevBlock = 0;\n        block.hashMerkleRoot = block.BuildMerkleTree();\n        block.nVersion = 1;\n        block.nTime    = 1231006505;\n        block.nBits    = 0x1d00ffff;\n        block.nNonce   = 2083236893;\n\n        if (fTestNet)\n        {\n            block.nTime    = 1296688602;\n            block.nBits    = 0x1d07fff8;\n            block.nNonce   = 384568319;\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", hashGenesisBlock.ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n        assert(block.hashMerkleRoot == uint256(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n        block.print();\n        assert(block.GetHash() == hashGenesisBlock);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n    }\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // precompute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %s  tx %d\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().substr(0,20).c_str(),\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main timechain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nmap<uint256, CAlert> mapAlerts;\nCCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // Longer invalid proof-of-work chain\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n    {\n        nPriority = 2000;\n        strStatusBar = strRPC = \"WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\";\n    }\n\n    // Alerts\n    CRITICAL_BLOCK(cs_mapAlerts)\n    {\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\nbool CAlert::ProcessAlert()\n{\n    if (!CheckSignature())\n        return false;\n    if (!IsInEffect())\n        return false;\n\n    CRITICAL_BLOCK(cs_mapAlerts)\n    {\n        // Cancel previous alerts\n        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n        {\n            const CAlert& alert = (*mi).second;\n            if (Cancels(alert))\n            {\n                printf(\"cancelling alert %d\\n\", alert.nID);\n                mapAlerts.erase(mi++);\n            }\n            else if (!alert.IsInEffect())\n            {\n                printf(\"expiring alert %d\\n\", alert.nID);\n                mapAlerts.erase(mi++);\n            }\n            else\n                mi++;\n        }\n\n        // Check if this alert has been cancelled\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.Cancels(*this))\n            {\n                printf(\"alert already cancelled by %d\\n\", alert.nID);\n                return false;\n            }\n        }\n\n        // Add to mapAlerts\n        mapAlerts.insert(make_pair(GetHash(), *this));\n    }\n\n    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n    MainFrameRepaint();\n    return true;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:    return mapTransactions.count(inv.hash) || mapOrphanTransactions.count(inv.hash) || txdb.ContainsTx(inv.hash);\n    case MSG_BLOCK: return mapBlockIndex.count(inv.hash) || mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n\n\n// The message start string is designed to be unlikely to occur in normal data.\n// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n// a large 4-byte int at any alignment.\nunsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, vector<unsigned char> > mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug) {\n        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    }\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < 209)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !fUseProxy && addrLocalHost.IsRoutable() &&\n                !IsInitialBlockDownload())\n            {\n                CAddress addr(addrLocalHost);\n                addr.nTime = GetAdjustedTime();\n                pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->nVersion >= 31402 || mapAddresses.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient &&\n            (pfrom->nVersion < 32000 || pfrom->nVersion >= 32400) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        CRITICAL_BLOCK(cs_mapAlerts)\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < 31402 && mapAddresses.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %d\", vAddr.size());\n        }\n\n        // Store the new addresses\n        CAddrDB addrDB;\n        addrDB.TxnBegin();\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            // ignore IPv6 for now, since it isn't implemented anyway\n            if (!addr.IsIPv4())\n                continue;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            AddAddress(addr, 2 * 60 * 60, &addrDB);\n            pfrom->AddAddressKnown(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                CRITICAL_BLOCK(cs_vNodes)\n                {\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n                    int64 hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < 31402)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = 2;\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n        }\n        addrDB.TxnCommit();  // Save addresses (it's ok if this fails)\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n    }\n\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        CTxDB txdb(\"r\");\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                CRITICAL_BLOCK(cs_mapRelay)\n                {\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500 + locator.GetDistanceBack();\n        unsigned int nBytes = 0;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            nBytes += block.GetSerializeSize(SER_NETWORK);\n            if (--nLimit <= 0 || nBytes >= SendBufferSize()/2)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000 + locator.GetDistanceBack();\n        printf(\"getheaders %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        CDataStream vMsg(vRecv);\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n\n                    if (tx.AcceptToMemoryPool(true))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vWorkQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %d tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n\n        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, block.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Nodes rebroadcast an addr every 24 hours\n        pfrom->vAddrToSend.clear();\n        int64 nSince = GetAdjustedTime() - 3 * 60 * 60; // in the last 3 hours\n        CRITICAL_BLOCK(cs_mapAddresses)\n        {\n            unsigned int nCount = 0;\n            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n            {\n                const CAddress& addr = item.second;\n                if (addr.nTime > nSince)\n                    nCount++;\n            }\n            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n            {\n                const CAddress& addr = item.second;\n                if (addr.nTime > nSince && GetRand(nCount) < 2500)\n                    pfrom->PushAddress(addr);\n            }\n        }\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        CRITICAL_BLOCK(pfrom->cs_mapRequests)\n        {\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            CRITICAL_BLOCK(cs_vNodes)\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    loop\n    {\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if (vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            CRITICAL_BLOCK(cs_main)\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from underlength message on vRecv\n                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from overlong size\n                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessage()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessage()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    CRITICAL_BLOCK(cs_main)\n    {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty())\n            pto->PushMessage(\"ping\");\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64 nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            CRITICAL_BLOCK(cs_vNodes)\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen && !fUseProxy && addrLocalHost.IsRoutable())\n                    {\n                        CAddress addr(addrLocalHost);\n                        addr.nTime = GetAdjustedTime();\n                        pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        // Clear out old addresses periodically so it's not too much work at once\n        static int64 nLastClear;\n        if (nLastClear == 0)\n            nLastClear = GetTime();\n        if (GetTime() - nLastClear > 10 * 60 && vNodes.size() >= 3)\n        {\n            nLastClear = GetTime();\n            CRITICAL_BLOCK(cs_mapAddresses)\n            {\n                CAddrDB addrdb;\n                int64 nSince = GetAdjustedTime() - 14 * 24 * 60 * 60;\n                for (map<vector<unsigned char>, CAddress>::iterator mi = mapAddresses.begin();\n                     mi != mapAddresses.end();)\n                {\n                    const CAddress& addr = (*mi).second;\n                    if (addr.nTime < nSince)\n                    {\n                        if (mapAddresses.size() < 1000 || GetTime() > nLastClear + 20)\n                            break;\n                        addrdb.EraseAddress(addr);\n                        mapAddresses.erase(mi++);\n                    }\n                    else\n                        mi++;\n                }\n            }\n        }\n\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        CRITICAL_BLOCK(pto->cs_inventory)\n        {\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64 nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n            }\n            mapAlreadyAskedFor[inv] = nNow;\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BitcoinMiner\n//\n\nint static FormatHashBlocks(void* pbuffer, unsigned int len)\n{\n    unsigned char* pdata = (unsigned char*)pbuffer;\n    unsigned int blocks = 1 + ((len + 8) / 64);\n    unsigned char* pend = pdata + 64 * blocks;\n    memset(pdata + len, 0, 64 * blocks - len);\n    pdata[len] = 0x80;\n    unsigned int bits = len * 8;\n    pend[-1] = (bits >> 0) & 0xff;\n    pend[-2] = (bits >> 8) & 0xff;\n    pend[-3] = (bits >> 16) & 0xff;\n    pend[-4] = (bits >> 24) & 0xff;\n    return blocks;\n}\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\nvoid SHA256Transform(void* pstate, void* pinput, const void* pinit)\n{\n    SHA256_CTX ctx;\n    unsigned char data[64];\n\n    SHA256_Init(&ctx);\n\n    for (int i = 0; i < 16; i++)\n        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n\n    for (int i = 0; i < 8; i++)\n        ctx.h[i] = ((uint32_t*)pinit)[i];\n\n    SHA256_Update(&ctx, data, sizeof(data));\n    for (int i = 0; i < 8; i++) \n        ((uint32_t*)pstate)[i] = ctx.h[i];\n}\n\n//\n// ScanHash scans nonces looking for a hash with at least some zero bits.\n// It operates on big endian data.  Caller does the byte reversing.\n// All input buffers are 16-byte aligned.  nNonce is usually preserved\n// between calls, but periodically or if nNonce is 0xffff0000 or above,\n// the block is rebuilt and nNonce starts over at zero.\n//\nunsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n{\n    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n    for (;;)\n    {\n        // Crypto++ SHA-256\n        // Hash pdata using pmidstate as the starting state into\n        // preformatted buffer phash1, then hash phash1 into phash\n        nNonce++;\n        SHA256Transform(phash1, pdata, pmidstate);\n        SHA256Transform(phash, phash1, pSHA256InitState);\n\n        // Return the nonce if the hash has at least some zero bits,\n        // caller will check if it has enough to reach the target\n        if (((unsigned short*)phash)[14] == 0)\n            return nNonce;\n\n        // If nothing found after trying for a while, return -1\n        if ((nNonce & 0xffff) == 0)\n        {\n            nHashesDone = 0xffff+1;\n            return -1;\n        }\n    }\n}\n\n// Some explaining would be appreciated\nclass COrphan\n{\npublic:\n    CTransaction* ptx;\n    set<uint256> setDependsOn;\n    double dPriority;\n\n    COrphan(CTransaction* ptxIn)\n    {\n        ptx = ptxIn;\n        dPriority = 0;\n    }\n\n    void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }\n};\n\n\nuint64 nLastBlockTx = 0;\nuint64 nLastBlockSize = 0;\n\nCBlock* CreateNewBlock(CReserveKey& reservekey)\n{\n    CBlockIndex* pindexPrev = pindexBest;\n\n    // Create new block\n    auto_ptr<CBlock> pblock(new CBlock());\n    if (!pblock.get())\n        return NULL;\n\n    // Create coinbase tx\n    CTransaction txNew;\n    txNew.vin.resize(1);\n    txNew.vin[0].prevout.SetNull();\n    txNew.vout.resize(1);\n    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n\n    // Add our coinbase tx as first transaction\n    pblock->vtx.push_back(txNew);\n\n    // Collect memory pool transactions into the block\n    int64 nFees = 0;\n    CRITICAL_BLOCK(cs_main)\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        CTxDB txdb(\"r\");\n\n        // Priority order to process transactions\n        list<COrphan> vOrphan; // list memory doesn't move\n        map<uint256, vector<COrphan*> > mapDependers;\n        multimap<double, CTransaction*> mapPriority;\n        for (map<uint256, CTransaction>::iterator mi = mapTransactions.begin(); mi != mapTransactions.end(); ++mi)\n        {\n            CTransaction& tx = (*mi).second;\n            if (tx.IsCoinBase() || !tx.IsFinal())\n                continue;\n\n            COrphan* porphan = NULL;\n            double dPriority = 0;\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n            {\n                // Read prev transaction\n                CTransaction txPrev;\n                CTxIndex txindex;\n                if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n                {\n                    // Has to wait for dependencies\n                    if (!porphan)\n                    {\n                        // Use list for automatic deletion\n                        vOrphan.push_back(COrphan(&tx));\n                        porphan = &vOrphan.back();\n                    }\n                    mapDependers[txin.prevout.hash].push_back(porphan);\n                    porphan->setDependsOn.insert(txin.prevout.hash);\n                    continue;\n                }\n                int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n\n                // Read block header\n                int nConf = txindex.GetDepthInMainChain();\n\n                dPriority += (double)nValueIn * nConf;\n\n                if (fDebug && GetBoolArg(\"-printpriority\"))\n                    printf(\"priority     nValueIn=%-12I64d nConf=%-5d dPriority=%-20.1f\\n\", nValueIn, nConf, dPriority);\n            }\n\n            // Priority is sum(valuein * age) / txsize\n            dPriority /= ::GetSerializeSize(tx, SER_NETWORK);\n\n            if (porphan)\n                porphan->dPriority = dPriority;\n            else\n                mapPriority.insert(make_pair(-dPriority, &(*mi).second));\n\n            if (fDebug && GetBoolArg(\"-printpriority\"))\n            {\n                printf(\"priority %-20.1f %s\\n%s\", dPriority, tx.GetHash().ToString().substr(0,10).c_str(), tx.ToString().c_str());\n                if (porphan)\n                    porphan->print();\n                printf(\"\\n\");\n            }\n        }\n\n        // Collect transactions into block\n        map<uint256, CTxIndex> mapTestPool;\n        uint64 nBlockSize = 1000;\n        uint64 nBlockTx = 0;\n        int nBlockSigOps = 100;\n        while (!mapPriority.empty())\n        {\n            // Take highest priority transaction off priority queue\n            double dPriority = -(*mapPriority.begin()).first;\n            CTransaction& tx = *(*mapPriority.begin()).second;\n            mapPriority.erase(mapPriority.begin());\n\n            // Size limits\n            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK);\n            if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                continue;\n\n            // Legacy limits on sigOps:\n            int nTxSigOps = tx.GetLegacySigOpCount();\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            // Transaction fee required depends on block size\n            bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));\n            int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree, GMF_BLOCK);\n\n            // Connecting shouldn't fail due to dependency on other memory pool transactions\n            // because we're already processing them in order of dependency\n            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n            MapPrevTx mapInputs;\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n                continue;\n\n            int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n            if (nTxFees < nMinFee)\n                continue;\n\n            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n                continue;\n            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n            swap(mapTestPool, mapTestPoolTmp);\n\n            // Added\n            pblock->vtx.push_back(tx);\n            nBlockSize += nTxSize;\n            ++nBlockTx;\n            nBlockSigOps += nTxSigOps;\n            nFees += nTxFees;\n\n            // Add transactions that depend on this one to the priority queue\n            uint256 hash = tx.GetHash();\n            if (mapDependers.count(hash))\n            {\n                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n                {\n                    if (!porphan->setDependsOn.empty())\n                    {\n                        porphan->setDependsOn.erase(hash);\n                        if (porphan->setDependsOn.empty())\n                            mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));\n                    }\n                }\n            }\n        }\n\n        nLastBlockTx = nBlockTx;\n        nLastBlockSize = nBlockSize;\n        printf(\"CreateNewBlock(): total size %lu\\n\", nBlockSize);\n\n    }\n    pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n\n    // Fill in header\n    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n    pblock->UpdateTime(pindexPrev);\n    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n    pblock->nNonce         = 0;\n\n    return pblock.release();\n}\n\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << pblock->nTime << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}\n\n\nvoid FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)\n{\n    //\n    // Prebuild hash buffers\n    //\n    struct\n    {\n        struct unnamed2\n        {\n            int nVersion;\n            uint256 hashPrevBlock;\n            uint256 hashMerkleRoot;\n            unsigned int nTime;\n            unsigned int nBits;\n            unsigned int nNonce;\n        }\n        block;\n        unsigned char pchPadding0[64];\n        uint256 hash1;\n        unsigned char pchPadding1[64];\n    }\n    tmp;\n    memset(&tmp, 0, sizeof(tmp));\n\n    tmp.block.nVersion       = pblock->nVersion;\n    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;\n    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;\n    tmp.block.nTime          = pblock->nTime;\n    tmp.block.nBits          = pblock->nBits;\n    tmp.block.nNonce         = pblock->nNonce;\n\n    FormatHashBlocks(&tmp.block, sizeof(tmp.block));\n    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n\n    // Byte swap all the input buffer\n    for (int i = 0; i < sizeof(tmp)/4; i++)\n        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n\n    // Precalc the first half of the first hash, which stays constant\n    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);\n\n    memcpy(pdata, &tmp.block, 128);\n    memcpy(phash1, &tmp.hash1, 64);\n}\n\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n{\n    uint256 hash = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    if (hash > hashTarget)\n        return false;\n\n    //// debug print\n    printf(\"BitcoinMiner:\\n\");\n    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    CRITICAL_BLOCK(cs_main)\n    {\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"BitcoinMiner : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        CRITICAL_BLOCK(wallet.cs_wallet)\n            wallet.mapRequestCount[pblock->GetHash()] = 0;\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}\n\nvoid static ThreadBitcoinMiner(void* parg);\n\nstatic bool fGenerateBitcoins = false;\nstatic bool fLimitProcessors = false;\nstatic int nLimitProcessors = -1;\n\nvoid static BitcoinMiner(CWallet *pwallet)\n{\n    printf(\"BitcoinMiner started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Each thread has its own key and counter\n    CReserveKey reservekey(pwallet);\n    unsigned int nExtraNonce = 0;\n\n    while (fGenerateBitcoins)\n    {\n        if (AffinityBugWorkaround(ThreadBitcoinMiner))\n            return;\n        if (fShutdown)\n            return;\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            Sleep(1000);\n            if (fShutdown)\n                return;\n            if (!fGenerateBitcoins)\n                return;\n        }\n\n\n        //\n        // Create new block\n        //\n        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrev = pindexBest;\n\n        auto_ptr<CBlock> pblock(CreateNewBlock(reservekey));\n        if (!pblock.get())\n            return;\n        IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce);\n\n        printf(\"Running BitcoinMiner with %d transactions in block\\n\", pblock->vtx.size());\n\n\n        //\n        // Prebuild hash buffers\n        //\n        char pmidstatebuf[32+16]; char* pmidstate = alignup<16>(pmidstatebuf);\n        char pdatabuf[128+16];    char* pdata     = alignup<16>(pdatabuf);\n        char phash1buf[64+16];    char* phash1    = alignup<16>(phash1buf);\n\n        FormatHashBuffers(pblock.get(), pmidstate, pdata, phash1);\n\n        unsigned int& nBlockTime = *(unsigned int*)(pdata + 64 + 4);\n        unsigned int& nBlockBits = *(unsigned int*)(pdata + 64 + 8);\n        unsigned int& nBlockNonce = *(unsigned int*)(pdata + 64 + 12);\n\n\n        //\n        // Search\n        //\n        int64 nStart = GetTime();\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n        uint256 hashbuf[2];\n        uint256& hash = *alignup<16>(hashbuf);\n        loop\n        {\n            unsigned int nHashesDone = 0;\n            unsigned int nNonceFound;\n\n            // Crypto++ SHA-256\n            nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,\n                                            (char*)&hash, nHashesDone);\n\n            // Check if something found\n            if (nNonceFound != -1)\n            {\n                for (int i = 0; i < sizeof(hash)/4; i++)\n                    ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n\n                if (hash <= hashTarget)\n                {\n                    // Found a solution\n                    pblock->nNonce = ByteReverse(nNonceFound);\n                    assert(hash == pblock->GetHash());\n\n                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n                    CheckWork(pblock.get(), *pwalletMain, reservekey);\n                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                    break;\n                }\n            }\n\n            // Meter hashes/sec\n            static int64 nHashCounter;\n            if (nHPSTimerStart == 0)\n            {\n                nHPSTimerStart = GetTimeMillis();\n                nHashCounter = 0;\n            }\n            else\n                nHashCounter += nHashesDone;\n            if (GetTimeMillis() - nHPSTimerStart > 4000)\n            {\n                static CCriticalSection cs;\n                CRITICAL_BLOCK(cs)\n                {\n                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n                    {\n                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                        nHPSTimerStart = GetTimeMillis();\n                        nHashCounter = 0;\n                        string strStatus = strprintf(\"    %.0f khash/s\", dHashesPerSec/1000.0);\n                        UIThreadCall(boost::bind(CalledSetStatusBar, strStatus, 0));\n                        static int64 nLogTime;\n                        if (GetTime() - nLogTime > 30 * 60)\n                        {\n                            nLogTime = GetTime();\n                            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n                            printf(\"hashmeter %3d CPUs %6.0f khash/s\\n\", vnThreadsRunning[THREAD_MINER], dHashesPerSec/1000.0);\n                        }\n                    }\n                }\n            }\n\n            // Check for stop or if block needs to be rebuilt\n            if (fShutdown)\n                return;\n            if (!fGenerateBitcoins)\n                return;\n            if (fLimitProcessors && vnThreadsRunning[THREAD_MINER] > nLimitProcessors)\n                return;\n            if (vNodes.empty())\n                break;\n            if (nBlockNonce >= 0xffff0000)\n                break;\n            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                break;\n            if (pindexPrev != pindexBest)\n                break;\n\n            // Update nTime every few seconds\n            pblock->UpdateTime(pindexPrev);\n            nBlockTime = ByteReverse(pblock->nTime);\n            if (fTestNet)\n            {\n                // Changing pblock->nTime can change work required on testnet:\n                nBlockBits = ByteReverse(pblock->nBits);\n                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n            }\n        }\n    }\n}\n\nvoid static ThreadBitcoinMiner(void* parg)\n{\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_MINER]++;\n        BitcoinMiner(pwallet);\n        vnThreadsRunning[THREAD_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(&e, \"ThreadBitcoinMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(NULL, \"ThreadBitcoinMiner()\");\n    }\n    UIThreadCall(boost::bind(CalledSetStatusBar, \"\", 0));\n    nHPSTimerStart = 0;\n    if (vnThreadsRunning[THREAD_MINER] == 0)\n        dHashesPerSec = 0;\n    printf(\"ThreadBitcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_MINER]);\n}\n\n\nvoid GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n{\n    fGenerateBitcoins = fGenerate;\n    nLimitProcessors = GetArg(\"-genproclimit\", -1);\n    if (nLimitProcessors == 0)\n        fGenerateBitcoins = false;\n    fLimitProcessors = (nLimitProcessors != -1);\n\n    if (fGenerate)\n    {\n        int nProcessors = boost::thread::hardware_concurrency();\n        printf(\"%d processors\\n\", nProcessors);\n        if (nProcessors < 1)\n            nProcessors = 1;\n        if (fLimitProcessors && nProcessors > nLimitProcessors)\n            nProcessors = nLimitProcessors;\n        int nAddThreads = nProcessors - vnThreadsRunning[THREAD_MINER];\n        printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n        for (int i = 0; i < nAddThreads; i++)\n        {\n            if (!CreateThread(ThreadBitcoinMiner, pwallet))\n                printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");\n            Sleep(10);\n        }\n    }\n}\n"], "fixing_code": ["// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2012 The Bitcoin developers\n// Distributed under the MIT/X11 software license, see the accompanying\n// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n#include \"headers.h\"\n#include \"checkpoints.h\"\n#include \"db.h\"\n#include \"net.h\"\n#include \"init.h\"\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n//\n// Global state\n//\n\n// Name of client reported in the 'version' message. Report the same name\n// for both bitcoind and bitcoin-qt, to make it harder for attackers to\n// target servers or GUI users specifically.\nconst std::string CLIENT_NAME(\"Satoshi\");\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nCCriticalSection cs_main;\n\nstatic map<uint256, CTransaction> mapTransactions;\nCCriticalSection cs_mapTransactions;\nunsigned int nTransactionsUpdated = 0;\nmap<COutPoint, CInPoint> mapNextTx;\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nuint256 hashGenesisBlock(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\nstatic CBigNum bnProofOfWorkLimit(~uint256(0) >> 32);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nCBigNum bnBestChainWork = 0;\nCBigNum bnBestInvalidWork = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64 nTimeBestReceived = 0;\n\nCMedianFilter<int> cPeerBlockCounts(5, 0); // Amount of blocks that other nodes claim to have\n\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n\nmap<uint256, CDataStream*> mapOrphanTransactions;\nmultimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;\n\n// Constant stuff for coinbase transactions we create:\nCScript COINBASE_FLAGS;\n\nconst string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n\ndouble dHashesPerSec;\nint64 nHPSTimerStart;\n\n// Settings\nint64 nTransactionFee = 0;\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// dispatching functions\n//\n\n// These functions dispatch to one or all registered wallets\n\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    CRITICAL_BLOCK(cs_setpwalletRegistered)\n    {\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    CRITICAL_BLOCK(cs_setpwalletRegistered)\n    {\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}\n\n// check whether the passed transaction is from us\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}\n\n// get the wallet transaction with the given hash (if it exists)\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}\n\n// erases transaction with the given hash from all wallets\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}\n\n// make sure all wallets know about the given transaction, in the given block\nvoid static SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}\n\n// notify wallets about a new best chain\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}\n\n// notify wallets about an updated transaction\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}\n\n// dump all wallets\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}\n\n// notify wallets about an incoming inventory (for request counts)\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}\n\n// ask wallets to resend their transactions\nvoid static ResendWalletTransactions()\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions();\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// mapOrphanTransactions\n//\n\nvoid AddOrphanTx(const CDataStream& vMsg)\n{\n    CTransaction tx;\n    CDataStream(vMsg) >> tx;\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return;\n\n    CDataStream* pvMsg = mapOrphanTransactions[hash] = new CDataStream(vMsg);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));\n}\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CDataStream* pvMsg = mapOrphanTransactions[hash];\n    CTransaction tx;\n    CDataStream(*pvMsg) >> tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);\n             mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)\n        {\n            if ((*mi).second == pvMsg)\n                mapOrphanTransactionsByPrev.erase(mi++);\n            else\n                mi++;\n        }\n    }\n    delete pvMsg;\n    mapOrphanTransactions.erase(hash);\n}\n\nint LimitOrphanTxSize(int nMaxOrphans)\n{\n    int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        std::vector<unsigned char> randbytes(32);\n        RAND_bytes(&randbytes[0], 32);\n        uint256 randomhash(randbytes);\n        map<uint256, CDataStream*>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTransaction and CTxIndex\n//\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}\n\nbool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}\n\nbool CTransaction::IsStandard() const\n{\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n    return true;\n}\n\n//\n// Check transaction inputs, and make sure any\n// pay-to-script-hash transactions are evaluating IsStandard scripts\n//\n// Why bother? To avoid denial-of-service attacks; an attacker\n// can submit a standard HASH... OP_EQUAL transaction,\n// which will get accepted into blocks. The redemption\n// script can be anything; an attacker could use a very\n// expensive-to-check-upon-redemption script like:\n//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n//\nbool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n            nArgsExpected += ScriptSigArgsExpected(whichType2, vSolutions2);\n        }\n\n        if (stack.size() != nArgsExpected)\n            return false;\n    }\n\n    return true;\n}\n\nint\nCTransaction::GetLegacySigOpCount() const\n{\n    int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\n\nint CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\n\n\n\n\n\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64 nValueOut = 0;\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!CheckTransaction())\n        return error(\"AcceptToMemoryPool() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (IsCoinBase())\n        return DoS(100, error(\"AcceptToMemoryPool() : coinbase as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64)nLockTime > std::numeric_limits<int>::max())\n        return error(\"AcceptToMemoryPool() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !IsStandard())\n        return error(\"AcceptToMemoryPool() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = GetHash();\n    CRITICAL_BLOCK(cs_mapTransactions)\n        if (mapTransactions.count(hash))\n            return false;\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        COutPoint outpoint = vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!IsNewerThan(*ptxOld))\n                return false;\n            for (int i = 0; i < vin.size(); i++)\n            {\n                COutPoint outpoint = vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"AcceptToMemoryPool() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return error(\"AcceptToMemoryPool() : FetchInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64 nFees = GetValueIn(mapInputs)-GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n\n        // Don't accept it if it can't get into a block\n        if (nFees < GetMinFee(1000, true, GMF_RELAY))\n            return error(\"AcceptToMemoryPool() : not enough fees\");\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make other's transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64 nLastTime;\n            int64 nNow = GetTime();\n\n            CRITICAL_BLOCK(cs)\n            {\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(*this))\n                    return error(\"AcceptToMemoryPool() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"AcceptToMemoryPool() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        if (ptxOld)\n        {\n            printf(\"AcceptToMemoryPool() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            ptxOld->RemoveFromMemoryPool();\n        }\n        AddToMemoryPoolUnchecked();\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"AcceptToMemoryPool(): accepted %s\\n\", hash.ToString().substr(0,10).c_str());\n    return true;\n}\n\nbool CTransaction::AcceptToMemoryPool(bool fCheckInputs, bool* pfMissingInputs)\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb, fCheckInputs, pfMissingInputs);\n}\n\nuint64 nPooledTx = 0;\n\nbool CTransaction::AddToMemoryPoolUnchecked()\n{\n    printf(\"AcceptToMemoryPoolUnchecked(): size %lu\\n\",  mapTransactions.size());\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call AcceptToMemoryPool to properly check the transaction first.\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        uint256 hash = GetHash();\n        mapTransactions[hash] = *this;\n        for (int i = 0; i < vin.size(); i++)\n            mapNextTx[vin[i].prevout] = CInPoint(&mapTransactions[hash], i);\n        nTransactionsUpdated++;\n        ++nPooledTx;\n    }\n    return true;\n}\n\n\nbool CTransaction::RemoveFromMemoryPool()\n{\n    // Remove transaction from memory pool\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        uint256 hash = GetHash();\n        if (mapTransactions.count(hash))\n        {\n            BOOST_FOREACH(const CTxIn& txin, vin)\n                mapNextTx.erase(txin.prevout);\n            mapTransactions.erase(hash);\n            nTransactionsUpdated++;\n            --nPooledTx;\n        }\n    }\n    return true;\n}\n\n\n\n\n\n\nint CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const\n{\n    if (hashBlock == 0 || nIndex == -1)\n        return 0;\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    // Make sure the merkle branch connects to this block\n    if (!fMerkleVerified)\n    {\n        if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n            return 0;\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}\n\n\nint CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!IsCoinBase())\n        return 0;\n    return max(0, (COINBASE_MATURITY+20) - GetDepthInMainChain());\n}\n\n\nbool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, false);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}\n\nbool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}\n\n\n\nbool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mapTransactions.count(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}\n\nbool CWalletTx::AcceptWalletTransaction() \n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}\n\nint CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CBlock and CBlockIndex\n//\n\nbool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}\n\nint64 static GetBlockValue(int nHeight, int64 nFees)\n{\n    int64 nSubsidy = 50 * COIN;\n\n    // Subsidy is cut in half every 4 years\n    nSubsidy >>= (nHeight / 210000);\n\n    return nSubsidy + nFees;\n}\n\nstatic const int64 nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\nstatic const int64 nTargetSpacing = 10 * 60;\nstatic const int64 nInterval = nTargetTimespan / nTargetSpacing;\n\n//\n// minimum amount of work that could possibly be required nTime after\n// minimum work required was nBase\n//\nunsigned int ComputeMinWork(unsigned int nBase, int64 nTime)\n{\n    // Testnet has min-difficulty blocks\n    // after nTargetSpacing*2 time between blocks:\n    if (fTestNet && nTime > nTargetSpacing*2)\n        return bnProofOfWorkLimit.GetCompact();\n\n    CBigNum bnResult;\n    bnResult.SetCompact(nBase);\n    while (nTime > 0 && bnResult < bnProofOfWorkLimit)\n    {\n        // Maximum 400% adjustment...\n        bnResult *= 4;\n        // ... in best-case exactly 4-times-normal target time\n        nTime -= nTargetTimespan*4;\n    }\n    if (bnResult > bnProofOfWorkLimit)\n        bnResult = bnProofOfWorkLimit;\n    return bnResult.GetCompact();\n}\n\nunsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlock *pblock)\n{\n    unsigned int nProofOfWorkLimit = bnProofOfWorkLimit.GetCompact();\n\n    // Genesis block\n    if (pindexLast == NULL)\n        return nProofOfWorkLimit;\n\n    // Only change once per interval\n    if ((pindexLast->nHeight+1) % nInterval != 0)\n    {\n        // Special rules for testnet after 15 Feb 2012:\n        if (fTestNet && pblock->nTime > 1329264000)\n        {\n            // If the new block's timestamp is more than 2* 10 minutes\n            // then allow mining of a min-difficulty block.\n            if (pblock->nTime - pindexLast->nTime > nTargetSpacing*2)\n                return nProofOfWorkLimit;\n            else\n            {\n                // Return the last non-special-min-difficulty-rules-block\n                const CBlockIndex* pindex = pindexLast;\n                while (pindex->pprev && pindex->nHeight % nInterval != 0 && pindex->nBits == nProofOfWorkLimit)\n                    pindex = pindex->pprev;\n                return pindex->nBits;\n            }\n        }\n\n        return pindexLast->nBits;\n    }\n\n    // Go back by what we want to be 14 days worth of blocks\n    const CBlockIndex* pindexFirst = pindexLast;\n    for (int i = 0; pindexFirst && i < nInterval-1; i++)\n        pindexFirst = pindexFirst->pprev;\n    assert(pindexFirst);\n\n    // Limit adjustment step\n    int64 nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n    printf(\"  nActualTimespan = %\"PRI64d\"  before bounds\\n\", nActualTimespan);\n    if (nActualTimespan < nTargetTimespan/4)\n        nActualTimespan = nTargetTimespan/4;\n    if (nActualTimespan > nTargetTimespan*4)\n        nActualTimespan = nTargetTimespan*4;\n\n    // Retarget\n    CBigNum bnNew;\n    bnNew.SetCompact(pindexLast->nBits);\n    bnNew *= nActualTimespan;\n    bnNew /= nTargetTimespan;\n\n    if (bnNew > bnProofOfWorkLimit)\n        bnNew = bnProofOfWorkLimit;\n\n    /// debug print\n    printf(\"GetNextWorkRequired RETARGET\\n\");\n    printf(\"nTargetTimespan = %\"PRI64d\"    nActualTimespan = %\"PRI64d\"\\n\", nTargetTimespan, nActualTimespan);\n    printf(\"Before: %08x  %s\\n\", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());\n    printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n\n    return bnNew.GetCompact();\n}\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\n// Return maximum amount of blocks that other nodes claim to have\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64 nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return (GetTime() - nLastUpdate < 10 &&\n            pindexBest->GetBlockTime() < GetTime() - 24 * 60 * 60);\n}\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->bnChainWork > bnBestInvalidWork)\n    {\n        bnBestInvalidWork = pindexNew->bnChainWork;\n        CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n        MainFrameRepaint();\n    }\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s\\n\", pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight, pindexNew->bnChainWork.ToString().c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n        printf(\"InvalidChainFound: WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\\n\");\n}\n\nvoid CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n\n    // Updating time can change work required on testnet:\n    if (fTestNet)\n        nBits = GetNextWorkRequired(pindexPrev, this);\n}\n\n\n\n\n\n\n\n\n\n\n\nbool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}\n\n\nbool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            CRITICAL_BLOCK(cs_mapTransactions)\n            {\n                if (!mapTransactions.count(prevout.hash))\n                    return error(\"FetchInputs() : %s mapTransactions prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mapTransactions[prevout.hash];\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n's are valid:\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64 nResult = 0;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nint CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int nSigOps = 0;\n    for (int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                 map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64 nValueIn = 0;\n        int64 nFees = 0;\n        for (int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %d %d prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase, check that it's matured\n            if (txPrev.IsCoinBase())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, fStrictPayToScriptHash, 0))\n                {\n                    // only during transition phase for P2SH: do not invoke anti-DoS code for\n                    // potentially old clients relaying bad P2SH transactions\n                    if (fStrictPayToScriptHash && VerifySignature(txPrev, *this, i, false, 0))\n                        return error(\"ConnectInputs() : %s P2SH VerifySignature failed\", GetHash().ToString().substr(0,10).c_str());\n\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (nValueIn < GetValueOut())\n            return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n        // Tally transaction fees\n        int64 nTxFee = nValueIn - GetValueOut();\n        if (nTxFee < 0)\n            return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n        nFees += nTxFee;\n        if (!MoneyRange(nFees))\n            return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n    }\n\n    return true;\n}\n\n\nbool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        int64 nValueIn = 0;\n        for (int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mapTransactions.count(prevout.hash))\n                return false;\n            CTransaction& txPrev = mapTransactions[prevout.hash];\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, true, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}\n\n\n\n\nbool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    return true;\n}\n\nbool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Check it again in case a previous version let a bad block in\n    if (!CheckBlock())\n        return false;\n\n    // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n    // unless those are already completely spent.\n    // If such overwrites are allowed, coinbases and transactions depending upon those\n    // can be duplicated to remove the ability to spend the first instance -- even after\n    // being sent to another address.\n    // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n    // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n    // already refuses previously-known transaction id's entirely.\n    // This rule applies to all blocks whose timestamp is after March 15, 2012, 0:00 UTC.\n    // On testnet it is enabled as of februari 20, 2012, 0:00 UTC.\n    if (pindex->nTime > 1331769600 || (fTestNet && pindex->nTime > 1329696000))\n        BOOST_FOREACH(CTransaction& tx, vtx)\n        {\n            CTxIndex txindexOld;\n            if (txdb.ReadTxIndex(tx.GetHash(), txindexOld))\n                BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                    if (pos.IsNull())\n                        return false;\n        }\n\n    // To avoid being on the short end of a block-chain split,\n    // don't do secondary validation of pay-to-script-hash transactions\n    // until blocks with timestamps after paytoscripthashtime (see init.cpp for default).\n    // This code can be removed once a super-majority of the network has upgraded.\n    int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", std::numeric_limits<int64_t>::max());\n    bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);\n\n    //// issue here: it doesn't know the version\n    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64 nFees = 0;\n    int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK);\n\n        MapPrevTx mapInputs;\n        if (!tx.IsCoinBase())\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            if (fStrictPayToScriptHash)\n            {\n                // Add in sigops done by pay-to-script-hash inputs;\n                // this is to prevent a \"rogue miner\" from creating\n                // an incredibly-expensive-to-validate block.\n                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n                if (nSigOps > MAX_BLOCK_SIGOPS)\n                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n            }\n\n            nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n\n            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                return false;\n        }\n\n        mapQueuedChanges[tx.GetHash()] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n        return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock failed\");\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!tx.IsCoinBase())\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            txdb.TxnAbort();\n            return error(\"Reorganize() : ConnectBlock failed\");\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete)\n        tx.RemoveFromMemoryPool();\n\n    printf(\"REORGANIZE: Disconnected %i blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connected %i blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    return true;\n}\n\n\nstatic void\nrunCommand(std::string strCommand)\n{\n    int nErr = ::system(strCommand.c_str());\n    if (nErr)\n        printf(\"runCommand error: system(%s) returned %d\\n\", strCommand.c_str(), nErr);\n}\n\nbool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    txdb.TxnBegin();\n    if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        // Adding to current best branch\n        if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : ConnectBlock failed\");\n        }\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n\n        // Add to current best branch\n        pindexNew->pprev->pnext = pindexNew;\n\n        // Delete redundant memory transactions\n        BOOST_FOREACH(CTransaction& tx, vtx)\n            tx.RemoveFromMemoryPool();\n    }\n    else\n    {\n        // New best branch\n        if (!Reorganize(txdb, pindexNew))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    nBestHeight = pindexBest->nHeight;\n    bnBestChainWork = pindexNew->bnChainWork;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n    printf(\"SetBestChain: new best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}\n\n\nbool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    pindexNew->phashBlock = &((*mi).first);\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n    pindexNew->bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();\n\n    CTxDB txdb;\n    txdb.TxnBegin();\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->bnChainWork > bnBestChainWork)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    txdb.Close();\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    MainFrameRepaint();\n    return true;\n}\n\n\n\n\nbool CBlock::CheckBlock() const\n{\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    // Check proof of work matches claimed amount\n    if (!CheckProofOfWork(GetHash(), nBits))\n        return DoS(50, error(\"CheckBlock() : proof of work failed\"));\n\n    // Check timestamp\n    if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n    int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    // Check merkleroot\n    if (hashMerkleRoot != BuildMerkleTree())\n        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n\n    return true;\n}\n\nbool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    // Check proof of work\n    if (nBits != GetNextWorkRequired(pindexPrev, this))\n        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n\n    // Check timestamp against prev\n    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n        return error(\"AcceptBlock() : block's timestamp is too early\");\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckBlock(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    if (hashBestChain == hash)\n        CRITICAL_BLOCK(cs_vNodes)\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 140700))\n                    pnode->PushInventory(CInv(MSG_BLOCK, hash));\n\n    return true;\n}\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n    {\n        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n        if (deltaTime < 0)\n        {\n            if (pfrom)\n                pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n        }\n        CBigNum bnNewBlock;\n        bnNewBlock.SetCompact(pblock->nBits);\n        CBigNum bnRequired;\n        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n        if (bnNewBlock > bnRequired)\n        {\n            if (pfrom)\n                pfrom->Misbehaving(100);\n            return error(\"ProcessBlock() : block with too little proof-of-work\");\n        }\n    }\n\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n    return true;\n}\n\n\n\n\n\n\n\n\nbool CheckDiskSpace(uint64 nAdditionalBytes)\n{\n    uint64 nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for 15MB because database could create another 10MB log file at any time\n    if (nFreeBytesAvailable < (uint64)15000000 + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low  \");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        ThreadSafeMessageBox(strMessage, \"Bitcoin\", wxOK | wxICON_EXCLAMATION);\n        CreateThread(Shutdown, NULL);\n        return false;\n    }\n    return true;\n}\n\nFILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)\n{\n    if (nFile == -1)\n        return NULL;\n    FILE* file = fopen(strprintf(\"%s/blk%04d.dat\", GetDataDir().c_str(), nFile).c_str(), pszMode);\n    if (!file)\n        return NULL;\n    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))\n    {\n        if (fseek(file, nBlockPos, SEEK_SET) != 0)\n        {\n            fclose(file);\n            return NULL;\n        }\n    }\n    return file;\n}\n\nstatic unsigned int nCurrentBlockFile = 1;\n\nFILE* AppendBlockFile(unsigned int& nFileRet)\n{\n    nFileRet = 0;\n    loop\n    {\n        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, \"ab\");\n        if (!file)\n            return NULL;\n        if (fseek(file, 0, SEEK_END) != 0)\n            return NULL;\n        // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB\n        if (ftell(file) < 0x7F000000 - MAX_SIZE)\n        {\n            nFileRet = nCurrentBlockFile;\n            return file;\n        }\n        fclose(file);\n        nCurrentBlockFile++;\n    }\n}\n\nbool LoadBlockIndex(bool fAllowNew)\n{\n    if (fTestNet)\n    {\n        hashGenesisBlock = uint256(\"0x00000007199508e34a9ff81e6ec0c477a4cccff2a4767a8eee39c11db367b008\");\n        bnProofOfWorkLimit = CBigNum(~uint256(0) >> 28);\n        pchMessageStart[0] = 0xfa;\n        pchMessageStart[1] = 0xbf;\n        pchMessageStart[2] = 0xb5;\n        pchMessageStart[3] = 0xda;\n    }\n\n    //\n    // Load block index\n    //\n    CTxDB txdb(\"cr\");\n    if (!txdb.LoadBlockIndex())\n        return false;\n    txdb.Close();\n\n    //\n    // Init with genesis block\n    //\n    if (mapBlockIndex.empty())\n    {\n        if (!fAllowNew)\n            return false;\n\n        // Genesis Block:\n        // CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\n        //   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n        //     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)\n        //     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)\n        //   vMerkleTree: 4a5e1e\n\n        // Genesis block\n        const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n        CTransaction txNew;\n        txNew.vin.resize(1);\n        txNew.vout.resize(1);\n        txNew.vin[0].scriptSig = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n        txNew.vout[0].nValue = 50 * COIN;\n        txNew.vout[0].scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n        CBlock block;\n        block.vtx.push_back(txNew);\n        block.hashPrevBlock = 0;\n        block.hashMerkleRoot = block.BuildMerkleTree();\n        block.nVersion = 1;\n        block.nTime    = 1231006505;\n        block.nBits    = 0x1d00ffff;\n        block.nNonce   = 2083236893;\n\n        if (fTestNet)\n        {\n            block.nTime    = 1296688602;\n            block.nBits    = 0x1d07fff8;\n            block.nNonce   = 384568319;\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", hashGenesisBlock.ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n        assert(block.hashMerkleRoot == uint256(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n        block.print();\n        assert(block.GetHash() == hashGenesisBlock);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n    }\n\n    return true;\n}\n\n\n\nvoid PrintBlockTree()\n{\n    // precompute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %s  tx %d\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().substr(0,20).c_str(),\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main timechain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CAlert\n//\n\nmap<uint256, CAlert> mapAlerts;\nCCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // Longer invalid proof-of-work chain\n    if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n    {\n        nPriority = 2000;\n        strStatusBar = strRPC = \"WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\";\n    }\n\n    // Alerts\n    CRITICAL_BLOCK(cs_mapAlerts)\n    {\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}\n\nbool CAlert::ProcessAlert()\n{\n    if (!CheckSignature())\n        return false;\n    if (!IsInEffect())\n        return false;\n\n    CRITICAL_BLOCK(cs_mapAlerts)\n    {\n        // Cancel previous alerts\n        for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n        {\n            const CAlert& alert = (*mi).second;\n            if (Cancels(alert))\n            {\n                printf(\"cancelling alert %d\\n\", alert.nID);\n                mapAlerts.erase(mi++);\n            }\n            else if (!alert.IsInEffect())\n            {\n                printf(\"expiring alert %d\\n\", alert.nID);\n                mapAlerts.erase(mi++);\n            }\n            else\n                mi++;\n        }\n\n        // Check if this alert has been cancelled\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.Cancels(*this))\n            {\n                printf(\"alert already cancelled by %d\\n\", alert.nID);\n                return false;\n            }\n        }\n\n        // Add to mapAlerts\n        mapAlerts.insert(make_pair(GetHash(), *this));\n    }\n\n    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n    MainFrameRepaint();\n    return true;\n}\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Messages\n//\n\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:    return mapTransactions.count(inv.hash) || mapOrphanTransactions.count(inv.hash) || txdb.ContainsTx(inv.hash);\n    case MSG_BLOCK: return mapBlockIndex.count(inv.hash) || mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}\n\n\n\n\n// The message start string is designed to be unlikely to occur in normal data.\n// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n// a large 4-byte int at any alignment.\nunsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, vector<unsigned char> > mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug) {\n        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n    }\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n\n\n\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64 nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64 nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < 209)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !fUseProxy && addrLocalHost.IsRoutable() &&\n                !IsInitialBlockDownload())\n            {\n                CAddress addr(addrLocalHost);\n                addr.nTime = GetAdjustedTime();\n                pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->nVersion >= 31402 || mapAddresses.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient &&\n            (pfrom->nVersion < 32000 || pfrom->nVersion >= 32400) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        CRITICAL_BLOCK(cs_mapAlerts)\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < 31402 && mapAddresses.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %d\", vAddr.size());\n        }\n\n        // Store the new addresses\n        CAddrDB addrDB;\n        addrDB.TxnBegin();\n        int64 nNow = GetAdjustedTime();\n        int64 nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            // ignore IPv6 for now, since it isn't implemented anyway\n            if (!addr.IsIPv4())\n                continue;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            AddAddress(addr, 2 * 60 * 60, &addrDB);\n            pfrom->AddAddressKnown(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                CRITICAL_BLOCK(cs_vNodes)\n                {\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n                    int64 hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < 31402)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = 2;\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n        }\n        addrDB.TxnCommit();  // Save addresses (it's ok if this fails)\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n    }\n\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %d\", vInv.size());\n        }\n\n        CTxDB txdb(\"r\");\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > 50000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %d\", vInv.size());\n        }\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // Bypass PushInventory, this must send even if redundant,\n                        // and we want it right after the last block so they don't\n                        // wait for other stuff first.\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                CRITICAL_BLOCK(cs_mapRelay)\n                {\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end())\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500 + locator.GetDistanceBack();\n        unsigned int nBytes = 0;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            nBytes += block.GetSerializeSize(SER_NETWORK);\n            if (--nLimit <= 0 || nBytes >= SendBufferSize()/2)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000 + locator.GetDistanceBack();\n        printf(\"getheaders %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        CDataStream vMsg(vRecv);\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayMessage(inv, vMsg);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);\n                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);\n                     ++mi)\n                {\n                    const CDataStream& vMsg = *((*mi).second);\n                    CTransaction tx;\n                    CDataStream(vMsg) >> tx;\n                    CInv inv(MSG_TX, tx.GetHash());\n\n                    if (tx.AcceptToMemoryPool(true))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayMessage(inv, vMsg);\n                        mapAlreadyAskedFor.erase(inv);\n                        vWorkQueue.push_back(inv.hash);\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vWorkQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n            AddOrphanTx(vMsg);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %d tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n\n        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, block.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Nodes rebroadcast an addr every 24 hours\n        pfrom->vAddrToSend.clear();\n        int64 nSince = GetAdjustedTime() - 3 * 60 * 60; // in the last 3 hours\n        CRITICAL_BLOCK(cs_mapAddresses)\n        {\n            unsigned int nCount = 0;\n            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n            {\n                const CAddress& addr = item.second;\n                if (addr.nTime > nSince)\n                    nCount++;\n            }\n            BOOST_FOREACH(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)\n            {\n                const CAddress& addr = item.second;\n                if (addr.nTime > nSince && GetRand(nCount) < 2500)\n                    pfrom->PushAddress(addr);\n            }\n        }\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        CRITICAL_BLOCK(pfrom->cs_mapRequests)\n        {\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        if (alert.ProcessAlert())\n        {\n            // Relay\n            pfrom->setKnown.insert(alert.GetHash());\n            CRITICAL_BLOCK(cs_vNodes)\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    alert.RelayTo(pnode);\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    loop\n    {\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if (vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %d BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            CRITICAL_BLOCK(cs_main)\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from underlength message on vRecv\n                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from overlong size\n                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessage()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessage()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessage()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}\n\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    CRITICAL_BLOCK(cs_main)\n    {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty())\n            pto->PushMessage(\"ping\");\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64 nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            CRITICAL_BLOCK(cs_vNodes)\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen && !fUseProxy && addrLocalHost.IsRoutable())\n                    {\n                        CAddress addr(addrLocalHost);\n                        addr.nTime = GetAdjustedTime();\n                        pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        // Clear out old addresses periodically so it's not too much work at once\n        static int64 nLastClear;\n        if (nLastClear == 0)\n            nLastClear = GetTime();\n        if (GetTime() - nLastClear > 10 * 60 && vNodes.size() >= 3)\n        {\n            nLastClear = GetTime();\n            CRITICAL_BLOCK(cs_mapAddresses)\n            {\n                CAddrDB addrdb;\n                int64 nSince = GetAdjustedTime() - 14 * 24 * 60 * 60;\n                for (map<vector<unsigned char>, CAddress>::iterator mi = mapAddresses.begin();\n                     mi != mapAddresses.end();)\n                {\n                    const CAddress& addr = (*mi).second;\n                    if (addr.nTime < nSince)\n                    {\n                        if (mapAddresses.size() < 1000 || GetTime() > nLastClear + 20)\n                            break;\n                        addrdb.EraseAddress(addr);\n                        mapAddresses.erase(mi++);\n                    }\n                    else\n                        mi++;\n                }\n            }\n        }\n\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        CRITICAL_BLOCK(pto->cs_inventory)\n        {\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64 nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n            }\n            mapAlreadyAskedFor[inv] = nNow;\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// BitcoinMiner\n//\n\nint static FormatHashBlocks(void* pbuffer, unsigned int len)\n{\n    unsigned char* pdata = (unsigned char*)pbuffer;\n    unsigned int blocks = 1 + ((len + 8) / 64);\n    unsigned char* pend = pdata + 64 * blocks;\n    memset(pdata + len, 0, 64 * blocks - len);\n    pdata[len] = 0x80;\n    unsigned int bits = len * 8;\n    pend[-1] = (bits >> 0) & 0xff;\n    pend[-2] = (bits >> 8) & 0xff;\n    pend[-3] = (bits >> 16) & 0xff;\n    pend[-4] = (bits >> 24) & 0xff;\n    return blocks;\n}\n\nstatic const unsigned int pSHA256InitState[8] =\n{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n\nvoid SHA256Transform(void* pstate, void* pinput, const void* pinit)\n{\n    SHA256_CTX ctx;\n    unsigned char data[64];\n\n    SHA256_Init(&ctx);\n\n    for (int i = 0; i < 16; i++)\n        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n\n    for (int i = 0; i < 8; i++)\n        ctx.h[i] = ((uint32_t*)pinit)[i];\n\n    SHA256_Update(&ctx, data, sizeof(data));\n    for (int i = 0; i < 8; i++) \n        ((uint32_t*)pstate)[i] = ctx.h[i];\n}\n\n//\n// ScanHash scans nonces looking for a hash with at least some zero bits.\n// It operates on big endian data.  Caller does the byte reversing.\n// All input buffers are 16-byte aligned.  nNonce is usually preserved\n// between calls, but periodically or if nNonce is 0xffff0000 or above,\n// the block is rebuilt and nNonce starts over at zero.\n//\nunsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n{\n    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n    for (;;)\n    {\n        // Crypto++ SHA-256\n        // Hash pdata using pmidstate as the starting state into\n        // preformatted buffer phash1, then hash phash1 into phash\n        nNonce++;\n        SHA256Transform(phash1, pdata, pmidstate);\n        SHA256Transform(phash, phash1, pSHA256InitState);\n\n        // Return the nonce if the hash has at least some zero bits,\n        // caller will check if it has enough to reach the target\n        if (((unsigned short*)phash)[14] == 0)\n            return nNonce;\n\n        // If nothing found after trying for a while, return -1\n        if ((nNonce & 0xffff) == 0)\n        {\n            nHashesDone = 0xffff+1;\n            return -1;\n        }\n    }\n}\n\n// Some explaining would be appreciated\nclass COrphan\n{\npublic:\n    CTransaction* ptx;\n    set<uint256> setDependsOn;\n    double dPriority;\n\n    COrphan(CTransaction* ptxIn)\n    {\n        ptx = ptxIn;\n        dPriority = 0;\n    }\n\n    void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }\n};\n\n\nuint64 nLastBlockTx = 0;\nuint64 nLastBlockSize = 0;\n\nCBlock* CreateNewBlock(CReserveKey& reservekey)\n{\n    CBlockIndex* pindexPrev = pindexBest;\n\n    // Create new block\n    auto_ptr<CBlock> pblock(new CBlock());\n    if (!pblock.get())\n        return NULL;\n\n    // Create coinbase tx\n    CTransaction txNew;\n    txNew.vin.resize(1);\n    txNew.vin[0].prevout.SetNull();\n    txNew.vout.resize(1);\n    txNew.vout[0].scriptPubKey << reservekey.GetReservedKey() << OP_CHECKSIG;\n\n    // Add our coinbase tx as first transaction\n    pblock->vtx.push_back(txNew);\n\n    // Collect memory pool transactions into the block\n    int64 nFees = 0;\n    CRITICAL_BLOCK(cs_main)\n    CRITICAL_BLOCK(cs_mapTransactions)\n    {\n        CTxDB txdb(\"r\");\n\n        // Priority order to process transactions\n        list<COrphan> vOrphan; // list memory doesn't move\n        map<uint256, vector<COrphan*> > mapDependers;\n        multimap<double, CTransaction*> mapPriority;\n        for (map<uint256, CTransaction>::iterator mi = mapTransactions.begin(); mi != mapTransactions.end(); ++mi)\n        {\n            CTransaction& tx = (*mi).second;\n            if (tx.IsCoinBase() || !tx.IsFinal())\n                continue;\n\n            COrphan* porphan = NULL;\n            double dPriority = 0;\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n            {\n                // Read prev transaction\n                CTransaction txPrev;\n                CTxIndex txindex;\n                if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n                {\n                    // Has to wait for dependencies\n                    if (!porphan)\n                    {\n                        // Use list for automatic deletion\n                        vOrphan.push_back(COrphan(&tx));\n                        porphan = &vOrphan.back();\n                    }\n                    mapDependers[txin.prevout.hash].push_back(porphan);\n                    porphan->setDependsOn.insert(txin.prevout.hash);\n                    continue;\n                }\n                int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n\n                // Read block header\n                int nConf = txindex.GetDepthInMainChain();\n\n                dPriority += (double)nValueIn * nConf;\n\n                if (fDebug && GetBoolArg(\"-printpriority\"))\n                    printf(\"priority     nValueIn=%-12I64d nConf=%-5d dPriority=%-20.1f\\n\", nValueIn, nConf, dPriority);\n            }\n\n            // Priority is sum(valuein * age) / txsize\n            dPriority /= ::GetSerializeSize(tx, SER_NETWORK);\n\n            if (porphan)\n                porphan->dPriority = dPriority;\n            else\n                mapPriority.insert(make_pair(-dPriority, &(*mi).second));\n\n            if (fDebug && GetBoolArg(\"-printpriority\"))\n            {\n                printf(\"priority %-20.1f %s\\n%s\", dPriority, tx.GetHash().ToString().substr(0,10).c_str(), tx.ToString().c_str());\n                if (porphan)\n                    porphan->print();\n                printf(\"\\n\");\n            }\n        }\n\n        // Collect transactions into block\n        map<uint256, CTxIndex> mapTestPool;\n        uint64 nBlockSize = 1000;\n        uint64 nBlockTx = 0;\n        int nBlockSigOps = 100;\n        while (!mapPriority.empty())\n        {\n            // Take highest priority transaction off priority queue\n            double dPriority = -(*mapPriority.begin()).first;\n            CTransaction& tx = *(*mapPriority.begin()).second;\n            mapPriority.erase(mapPriority.begin());\n\n            // Size limits\n            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK);\n            if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n                continue;\n\n            // Legacy limits on sigOps:\n            int nTxSigOps = tx.GetLegacySigOpCount();\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            // Transaction fee required depends on block size\n            bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));\n            int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree, GMF_BLOCK);\n\n            // Connecting shouldn't fail due to dependency on other memory pool transactions\n            // because we're already processing them in order of dependency\n            map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);\n            MapPrevTx mapInputs;\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapTestPoolTmp, false, true, mapInputs, fInvalid))\n                continue;\n\n            int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n            if (nTxFees < nMinFee)\n                continue;\n\n            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                continue;\n\n            if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n                continue;\n            mapTestPoolTmp[tx.GetHash()] = CTxIndex(CDiskTxPos(1,1,1), tx.vout.size());\n            swap(mapTestPool, mapTestPoolTmp);\n\n            // Added\n            pblock->vtx.push_back(tx);\n            nBlockSize += nTxSize;\n            ++nBlockTx;\n            nBlockSigOps += nTxSigOps;\n            nFees += nTxFees;\n\n            // Add transactions that depend on this one to the priority queue\n            uint256 hash = tx.GetHash();\n            if (mapDependers.count(hash))\n            {\n                BOOST_FOREACH(COrphan* porphan, mapDependers[hash])\n                {\n                    if (!porphan->setDependsOn.empty())\n                    {\n                        porphan->setDependsOn.erase(hash);\n                        if (porphan->setDependsOn.empty())\n                            mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));\n                    }\n                }\n            }\n        }\n\n        nLastBlockTx = nBlockTx;\n        nLastBlockSize = nBlockSize;\n        printf(\"CreateNewBlock(): total size %lu\\n\", nBlockSize);\n\n    }\n    pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n\n    // Fill in header\n    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n    pblock->UpdateTime(pindexPrev);\n    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock.get());\n    pblock->nNonce         = 0;\n\n    return pblock.release();\n}\n\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << pblock->nTime << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}\n\n\nvoid FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)\n{\n    //\n    // Prebuild hash buffers\n    //\n    struct\n    {\n        struct unnamed2\n        {\n            int nVersion;\n            uint256 hashPrevBlock;\n            uint256 hashMerkleRoot;\n            unsigned int nTime;\n            unsigned int nBits;\n            unsigned int nNonce;\n        }\n        block;\n        unsigned char pchPadding0[64];\n        uint256 hash1;\n        unsigned char pchPadding1[64];\n    }\n    tmp;\n    memset(&tmp, 0, sizeof(tmp));\n\n    tmp.block.nVersion       = pblock->nVersion;\n    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;\n    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;\n    tmp.block.nTime          = pblock->nTime;\n    tmp.block.nBits          = pblock->nBits;\n    tmp.block.nNonce         = pblock->nNonce;\n\n    FormatHashBlocks(&tmp.block, sizeof(tmp.block));\n    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n\n    // Byte swap all the input buffer\n    for (int i = 0; i < sizeof(tmp)/4; i++)\n        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n\n    // Precalc the first half of the first hash, which stays constant\n    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);\n\n    memcpy(pdata, &tmp.block, 128);\n    memcpy(phash1, &tmp.hash1, 64);\n}\n\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n{\n    uint256 hash = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    if (hash > hashTarget)\n        return false;\n\n    //// debug print\n    printf(\"BitcoinMiner:\\n\");\n    printf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex().c_str(), hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    CRITICAL_BLOCK(cs_main)\n    {\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"BitcoinMiner : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        CRITICAL_BLOCK(wallet.cs_wallet)\n            wallet.mapRequestCount[pblock->GetHash()] = 0;\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}\n\nvoid static ThreadBitcoinMiner(void* parg);\n\nstatic bool fGenerateBitcoins = false;\nstatic bool fLimitProcessors = false;\nstatic int nLimitProcessors = -1;\n\nvoid static BitcoinMiner(CWallet *pwallet)\n{\n    printf(\"BitcoinMiner started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Each thread has its own key and counter\n    CReserveKey reservekey(pwallet);\n    unsigned int nExtraNonce = 0;\n\n    while (fGenerateBitcoins)\n    {\n        if (AffinityBugWorkaround(ThreadBitcoinMiner))\n            return;\n        if (fShutdown)\n            return;\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            Sleep(1000);\n            if (fShutdown)\n                return;\n            if (!fGenerateBitcoins)\n                return;\n        }\n\n\n        //\n        // Create new block\n        //\n        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrev = pindexBest;\n\n        auto_ptr<CBlock> pblock(CreateNewBlock(reservekey));\n        if (!pblock.get())\n            return;\n        IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce);\n\n        printf(\"Running BitcoinMiner with %d transactions in block\\n\", pblock->vtx.size());\n\n\n        //\n        // Prebuild hash buffers\n        //\n        char pmidstatebuf[32+16]; char* pmidstate = alignup<16>(pmidstatebuf);\n        char pdatabuf[128+16];    char* pdata     = alignup<16>(pdatabuf);\n        char phash1buf[64+16];    char* phash1    = alignup<16>(phash1buf);\n\n        FormatHashBuffers(pblock.get(), pmidstate, pdata, phash1);\n\n        unsigned int& nBlockTime = *(unsigned int*)(pdata + 64 + 4);\n        unsigned int& nBlockBits = *(unsigned int*)(pdata + 64 + 8);\n        unsigned int& nBlockNonce = *(unsigned int*)(pdata + 64 + 12);\n\n\n        //\n        // Search\n        //\n        int64 nStart = GetTime();\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n        uint256 hashbuf[2];\n        uint256& hash = *alignup<16>(hashbuf);\n        loop\n        {\n            unsigned int nHashesDone = 0;\n            unsigned int nNonceFound;\n\n            // Crypto++ SHA-256\n            nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,\n                                            (char*)&hash, nHashesDone);\n\n            // Check if something found\n            if (nNonceFound != -1)\n            {\n                for (int i = 0; i < sizeof(hash)/4; i++)\n                    ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n\n                if (hash <= hashTarget)\n                {\n                    // Found a solution\n                    pblock->nNonce = ByteReverse(nNonceFound);\n                    assert(hash == pblock->GetHash());\n\n                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n                    CheckWork(pblock.get(), *pwalletMain, reservekey);\n                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n                    break;\n                }\n            }\n\n            // Meter hashes/sec\n            static int64 nHashCounter;\n            if (nHPSTimerStart == 0)\n            {\n                nHPSTimerStart = GetTimeMillis();\n                nHashCounter = 0;\n            }\n            else\n                nHashCounter += nHashesDone;\n            if (GetTimeMillis() - nHPSTimerStart > 4000)\n            {\n                static CCriticalSection cs;\n                CRITICAL_BLOCK(cs)\n                {\n                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n                    {\n                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n                        nHPSTimerStart = GetTimeMillis();\n                        nHashCounter = 0;\n                        string strStatus = strprintf(\"    %.0f khash/s\", dHashesPerSec/1000.0);\n                        UIThreadCall(boost::bind(CalledSetStatusBar, strStatus, 0));\n                        static int64 nLogTime;\n                        if (GetTime() - nLogTime > 30 * 60)\n                        {\n                            nLogTime = GetTime();\n                            printf(\"%s \", DateTimeStrFormat(\"%x %H:%M\", GetTime()).c_str());\n                            printf(\"hashmeter %3d CPUs %6.0f khash/s\\n\", vnThreadsRunning[THREAD_MINER], dHashesPerSec/1000.0);\n                        }\n                    }\n                }\n            }\n\n            // Check for stop or if block needs to be rebuilt\n            if (fShutdown)\n                return;\n            if (!fGenerateBitcoins)\n                return;\n            if (fLimitProcessors && vnThreadsRunning[THREAD_MINER] > nLimitProcessors)\n                return;\n            if (vNodes.empty())\n                break;\n            if (nBlockNonce >= 0xffff0000)\n                break;\n            if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                break;\n            if (pindexPrev != pindexBest)\n                break;\n\n            // Update nTime every few seconds\n            pblock->UpdateTime(pindexPrev);\n            nBlockTime = ByteReverse(pblock->nTime);\n            if (fTestNet)\n            {\n                // Changing pblock->nTime can change work required on testnet:\n                nBlockBits = ByteReverse(pblock->nBits);\n                hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n            }\n        }\n    }\n}\n\nvoid static ThreadBitcoinMiner(void* parg)\n{\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_MINER]++;\n        BitcoinMiner(pwallet);\n        vnThreadsRunning[THREAD_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(&e, \"ThreadBitcoinMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MINER]--;\n        PrintException(NULL, \"ThreadBitcoinMiner()\");\n    }\n    UIThreadCall(boost::bind(CalledSetStatusBar, \"\", 0));\n    nHPSTimerStart = 0;\n    if (vnThreadsRunning[THREAD_MINER] == 0)\n        dHashesPerSec = 0;\n    printf(\"ThreadBitcoinMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_MINER]);\n}\n\n\nvoid GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n{\n    fGenerateBitcoins = fGenerate;\n    nLimitProcessors = GetArg(\"-genproclimit\", -1);\n    if (nLimitProcessors == 0)\n        fGenerateBitcoins = false;\n    fLimitProcessors = (nLimitProcessors != -1);\n\n    if (fGenerate)\n    {\n        int nProcessors = boost::thread::hardware_concurrency();\n        printf(\"%d processors\\n\", nProcessors);\n        if (nProcessors < 1)\n            nProcessors = 1;\n        if (fLimitProcessors && nProcessors > nLimitProcessors)\n            nProcessors = nLimitProcessors;\n        int nAddThreads = nProcessors - vnThreadsRunning[THREAD_MINER];\n        printf(\"Starting %d BitcoinMiner threads\\n\", nAddThreads);\n        for (int i = 0; i < nAddThreads; i++)\n        {\n            if (!CreateThread(ThreadBitcoinMiner, pwallet))\n                printf(\"Error: CreateThread(ThreadBitcoinMiner) failed\\n\");\n            Sleep(10);\n        }\n    }\n}\n"], "filenames": ["src/main.cpp"], "buggy_code_start_loc": [979], "buggy_code_end_loc": [1257], "fixing_code_start_loc": [979], "fixing_code_end_loc": [1280], "type": "CWE-16", "message": "The Bitcoin protocol, as used in bitcoind before 0.4.4, wxBitcoin, Bitcoin-Qt, and other programs, does not properly handle multiple transactions with the same identifier, which allows remote attackers to cause a denial of service (unspendable transaction) by leveraging the ability to create a duplicate coinbase transaction.", "other": {"cve": {"id": "CVE-2012-1909", "sourceIdentifier": "cve@mitre.org", "published": "2012-08-06T16:55:01.400", "lastModified": "2020-03-18T17:37:31.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Bitcoin protocol, as used in bitcoind before 0.4.4, wxBitcoin, Bitcoin-Qt, and other programs, does not properly handle multiple transactions with the same identifier, which allows remote attackers to cause a denial of service (unspendable transaction) by leveraging the ability to create a duplicate coinbase transaction."}, {"lang": "es", "value": "El protocolo Bitcoin, como se usa en bitcoind anterior a v0.4.4, wxBitcoin, Bitcoin Qt, y otros programas, no maneja adecuadamente las transacciones m\u00faltiples con el mismo identificador, lo que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (transacci\u00f3n unspendable) mediante el aprovechamiento de la capacidad de crear una transacci\u00f3n coinbase duplicado."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-16"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:*:*:*:*:*:*:*:*", "matchCriteriaId": "D009847B-E8E7-4472-8260-4A334438C587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:*:rc2:*:*:*:*:*:*", "versionEndIncluding": "0.4.4", "matchCriteriaId": "85185B12-FD03-43E7-85D0-3BF8299A3340"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "1CD19345-15B5-4B2F-B3B9-4D57CCBFFF96"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "F0499EA1-85AD-48EC-A8D0-CBEDB85429AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "61F25360-9436-41C9-82CB-39D7FF087C2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.10:*:*:*:*:*:*:*", "matchCriteriaId": "83F460DD-E537-430D-A370-485E0A707560"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.11:*:*:*:*:*:*:*", "matchCriteriaId": "BD9264DE-6336-4654-8E8A-A3725B845D23"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.3.12:*:*:*:*:*:*:*", "matchCriteriaId": "B7A0874D-2223-4577-A8E6-93455B9C1DA4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "0C15FA7C-F87A-45F5-B6A3-5E2DA63AACB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "F5F6B138-0ED9-4205-B544-66C4C60C3A68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:bitcoin_core:0.4.1:rc6:*:*:*:*:*:*", "matchCriteriaId": "8494FF99-5D8C-497A-90E7-3D87807F5997"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bitcoin:wxbitcoin:*:*:*:*:*:*:*:*", "matchCriteriaId": "68AA5321-2756-4741-9437-6D8904A677E5"}]}]}], "references": [{"url": "http://r6.ca/blog/20120206T005236Z.html", "source": "cve@mitre.org"}, {"url": "http://sourceforge.net/mailarchive/forum.php?thread_name=CAPg%2BsBhmGHnMResVxPDZdfpmWTb9uqD0RrQD7oSXBQq7oHpm8g%40mail.gmail.com&forum_name=bitcoin-development", "source": "cve@mitre.org"}, {"url": "https://bitcointalk.org/index.php?topic=67738.0", "source": "cve@mitre.org"}, {"url": "https://bugs.gentoo.org/show_bug.cgi?id=407793", "source": "cve@mitre.org"}, {"url": "https://en.bitcoin.it/wiki/BIP_0030", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://en.bitcoin.it/wiki/CVEs", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/sipa/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/sipa/bitcoin/commit/a206b0ea12eb4606b93323268fc81a4f1f952531"}}