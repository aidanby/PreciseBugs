{"buggy_code": ["/**\n * Copyright (C) 2012-2013 Kaj Magnus Lindberg (born 1979)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage debiki\n\nimport akka.actor._\nimport akka.pattern.gracefulStop\nimport com.codahale.metrics\nimport com.debiki.core._\nimport com.debiki.core.Prelude._\nimport com.debiki.dao.rdb.{Rdb, RdbDaoFactory}\nimport com.github.benmanes.caffeine\nimport com.zaxxer.hikari.HikariDataSource\nimport debiki.EdHttp._\nimport ed.server.spam.{SpamCheckActor, SpamChecker}\nimport debiki.dao._\nimport debiki.dao.migrations.ScalaBasedMigrations\nimport ed.server.search.SearchEngineIndexer\nimport ed.server.notf.NotifierActor\nimport java.{lang => jl, net => jn}\nimport java.util.concurrent.TimeUnit\nimport ed.server.pubsub.{PubSub, PubSubApi, StrangerCounterApi}\nimport org.{elasticsearch => es}\nimport org.scalactic._\nimport play.{api => p}\nimport play.api.libs.ws.WSClient\nimport redis.RedisClient\nimport scala.collection.immutable\nimport scala.concurrent.duration._\nimport scala.concurrent.{Await, ExecutionContext, Future, TimeoutException}\nimport scala.util.matching.Regex\nimport ed.server.EdContext\nimport ed.server.http.GetRequest\nimport ed.server.jobs.Janitor\nimport play.api.http.{HeaderNames => p_HeaderNames}\nimport play.api.mvc.RequestHeader\nimport talkyard.server.TyLogging\n\n\nobject Globals extends TyLogging {\n\n  class NoStateError extends AssertionError(\n    \"No Globals.State created, please call onServerStartup() [DwE5NOS0]\")\n\n  object AppSecretNotChangedException extends QuickException\n  object StillConnectingException extends QuickException\n\n  class DatabasePoolInitializationException(cause: Exception) extends RuntimeException(cause)\n\n  val LoginOriginConfValName = \"talkyard.loginOrigin\"\n  val CdnOriginConfValName = \"talkyard.cdn.origin\"\n  val LocalhostUploadsDirConfValName = \"talkyard.uploads.localhostDir\"\n  val DefaultLocalhostUploadsDir = \"/opt/talkyard/uploads/\"\n\n  val AppSecretConfValName = \"play.http.secret.key\"\n  val AppSecretDefVal = \"change_this\"\n  val DefaultSiteIdConfValName = \"talkyard.defaultSiteId\"\n  val DefaultSiteHostnameConfValName = \"talkyard.hostname\"\n  val BecomeOwnerEmailConfValName = \"talkyard.becomeOwnerEmailAddress\"\n  val SiteOwnerTermsUrl = \"talkyard.siteOwnerTermsUrl\"\n  val SiteOwnerPrivacyUrl = \"talkyard.siteOwnerPrivacyUrl\"\n  val MaxGroupMentionNotfsConfValName = \"talkyard.maxGroupMentionNotifications\"\n\n  val CreateSiteHostnameConfValName = \"talkyard.createSiteHostname\"\n\n  CLEAN_UP; REMOVE //  Now placed in  core  instead -------\n  def isProd: Boolean = _isProd\n\n  def isDevOrTest: Boolean = !isProd\n\n  /** One never changes from Prod to Dev or Test, or from Dev or Test to Prod, so we can safely\n    * remember isProd, forever. (However, is-Dev and is-Test might change, depending on which\n    * commands one types in the cli.)\n    */\n  def setIsProdForever(isIt: Boolean): Unit = {\n    dieIf(hasSet && isIt != _isProd, \"EdE2PWVU07\")\n    _isProd = isIt\n    hasSet = true\n    com.debiki.core.Prelude.setIsProdForever(isIt)\n  }\n\n  private var _isProd = true\n  private var hasSet = false\n  // ------------------------------------------------------\n}\n\n\nclass E2eTestCounters {\n  @volatile var numReportedSpamFalsePositives: Int = 0\n  @volatile var numReportedSpamFalseNegatives: Int = 0\n}\n\n\nclass Globals(  // RENAME to TyApp? or AppContext? TyAppContext? variable name = appCtx\n                // But then rename EdContext  to ... what?\n  private val appLoaderContext: p.ApplicationLoader.Context,\n  val executionContext: scala.concurrent.ExecutionContext,\n  val wsClient: WSClient,\n  val actorSystem: ActorSystem,\n  val tracer: io.opentracing.Tracer) extends TyLogging {\n\n  def outer: Globals = this\n\n  import Globals._\n\n  def setEdContext(edContext: EdContext): Unit = {\n    dieIf(this.edContext ne null, \"EdE7UBR10\")\n    this.edContext = edContext\n  }\n\n  var edContext: EdContext = _\n\n  val e2eTestCounters = new E2eTestCounters\n\n  private implicit def execCtc: ExecutionContext = executionContext\n\n  val conf: p.Configuration = appLoaderContext.initialConfiguration\n  def rawConf: p.Configuration = conf\n\n  val config = new Config(conf)\n\n  // Dupl [305926XFG24] -------------------\n  private def getBoolOrFalse(confValName: String): Boolean =\n    getBoolOrDefault(confValName, default = false)\n\n  private def getIntOrDefault(confName: String, default: Int): Int =\n    conf.getOptional[Int](confName) getOrElse default\n\n  private def getBoolOrDefault(confName: String, default: Boolean): Boolean =\n    conf.getOptional[Boolean](confName) getOrElse default\n\n  // private def getStringOrEmpty[A](confName: String): String =\n  //   getStringOrDefault(confName, \"\")\n  //\n  //private def getStringOrDefault[A](confName: String, default: String): String =\n  //  conf.getOptional[String](confName).trimNoneIfBlank getOrElse default\n\n  private def getStringNoneIfBlank[A](confName: String): Option[String] =\n    conf.getOptional[String](confName).noneIfBlank\n  // --------------------------------------\n\n\n  /** Can be accessed also after the test is done and Play.maybeApplication is None.\n    */\n  val isDev: Boolean = appLoaderContext.environment.mode == play.api.Mode.Dev\n  val isOrWasTest: Boolean = appLoaderContext.environment.mode == play.api.Mode.Test\n  val isProd: Boolean = Globals.isProd\n\n  // This helps with shutting down when running tests \u2014 might not work properly now\n  // with Play 2.8 but seems the test shutdown properly anyway.\n  def testsDoneServerGone: Boolean =\n    isOrWasTest && (!isInitialized )  // [PLAY28] ?? || Play.maybeApplication.isEmpty)\n\n  val isTestDisableScripts: Boolean = isOrWasTest && {\n    val disable = getBoolOrFalse(\"isTestDisableScripts\")\n    if (disable) {\n      logger.info(\"Is test with scripts disabled. [EsM4GY82]\")\n    }\n    disable\n  }\n\n  lazy val (isTestDisableBackgroundJobs, isTestEnableJanitor): (Boolean, Boolean) =\n      if (isProd) (false, false) else {\n    val disableJobs = getBoolOrFalse(\"isTestDisableBackgroundJobs\")\n    val butEnableJanitor = getBoolOrFalse(\"isTestEnableJanitor\")\n    if (disableJobs) {\n      val butJanitor = if (butEnableJanitor) \", except for the Janitor\" else \", incl the Janitor\"\n      logger.info(s\"Is test with background jobs disabled$butJanitor. [EsM6JY0K2]\")\n    }\n    (disableJobs, butEnableJanitor)\n  }\n\n  def isInitialized: Boolean = (_state ne null) && _state.isGood\n\n  @volatile private var _state: State Or Option[Exception] = _\n\n  private def state: State = {\n    if (_state eq null) {\n      throw new NoStateError()\n    }\n    // Errors thrown here will be shown in the browser. Admin friendly :-)\n    _state match {\n      case Good(state) => state\n      case Bad(anyException) =>\n        logger.warn(\"Accessing state before it's been created. I'm still trying to start.\")\n        throw anyException getOrElse StillConnectingException\n    }\n  }\n\n\n  @volatile var killed = false\n  @volatile var shallStopStuff = false\n\n  // 5 seconds sometimes in a test \u2014> \"\"\"\n  // debiki.RateLimiterSpec *** ABORTED ***\n  // Futures timed out after [5 seconds]\n  // \"\"\"\n  // (in that case, all tests went fine, but couldn't shutdown the test server quickly enough)\n  val ShutdownTimeout: FiniteDuration = 10.seconds\n\n  /** For now (forever?), ignore platforms that don't send Linux signals.\n    */\n  sun.misc.Signal.handle(new sun.misc.Signal(\"TERM\"), new sun.misc.SignalHandler () {\n    def handle(signal: sun.misc.Signal): Unit = {\n      logger.info(\"Got SIGTERM, exiting with status 0 [EsMSIGTERM]\")\n      killed = true\n      System.exit(0)  // doing this here instead of [9KYKW25] although leaves PID file [65YKFU02]\n    }\n  })\n\n  sun.misc.Signal.handle(new sun.misc.Signal(\"INT\"), new sun.misc.SignalHandler () {\n    def handle(signal: sun.misc.Signal): Unit = {\n      logger.info(\"Got SIGINT, exiting with status 0 [EsMSIGINT]\")\n      killed = true\n      System.exit(0)  // doing this here instead of [9KYKW25] although leaves PID file [65YKFU02]\n    }\n  })\n\n\n  val metricRegistry = new metrics.MetricRegistry()\n  val mostMetrics = new MostMetrics(metricRegistry)\n\n  val talkyardVersion: String = {\n    // Placed here by docker-compose.yml, in dev builds, and the Dockerfile, in prod builds.\n    // [Scala_213] Using(...) { ... }\n    var source: scala.io.Source = null\n    try {\n      source = scala.io.Source.fromFile(\"/opt/talkyard/app/version.txt\")(scala.io.Codec.UTF8)\n      source.mkString.trim\n    }\n    finally {\n      if (source ne null) source.close()\n    }\n  }\n\n  // Could rename to \"rendererVersion\".\n  val applicationVersion = \"0.00.77\"  // later, read from some build config file\n\n  def applicationSecret: String = _appSecret\n\n  private var _appSecret: String = _\n\n  private def reloadAppSecret(): Unit = {\n    _appSecret = conf.getOptional[String](AppSecretConfValName).orElse(\n      conf.getOptional[String](\"play.crypto.secret\")).noneIfBlank.getOrDie(\n      s\"Config value '$AppSecretConfValName' missing [EdENOAPPSECRET]\")\n  }\n\n\n  /** Lets people do weird things, namely fake their ip address (&fakeIp=... url param)\n    * in order to create many e2e test sites \u2014 also in prod mode, for smoke tests.\n    * The e2e test sites will have ids like {{{test__...}}} so that they can be deleted safely.\n    */\n\n  val e2eTestPassword: Option[String] = getStringNoneIfBlank(\"talkyard.e2eTestPassword\")\n\n  /** Lets people do some forbidden things, like creating a site with a too short\n    * local hostname.\n    */\n  val forbiddenPassword: Option[String] = getStringNoneIfBlank(\"talkyard.forbiddenPassword\")\n\n  /** Maybe later, let individual sites require longer passwords. This conf val will then be the\n    * minimum length, for all sites. (So server admins can require a min length they're ok with.)\n    * 8 = rather low, but zxcvbn helpfully blocks really bad 8 char passwords like \"password\".\n    * 10 = can be good passwords.\n    */\n  val minPasswordLengthAllSites: Int =\n    conf.getOptional[Int](\"talkyard.minPasswordLength\") match {\n      case None =>\n        AllSettings.MinPasswordLengthHardcodedDefault\n      case Some(length) =>\n        dieIf(length < AllSettings.HardMinPasswordLength, \"TyE2WKG7\",\n          \"I refuse to start: Min password length is less than 8 chars; that's too easy to crack. Bye.\")\n        length\n    }\n\n  val mayFastForwardTime: Boolean =\n    if (!isProd) true\n    else getBoolOrFalse(\"talkyard.mayFastForwardTime\")\n\n  def systemDao: SystemDao = state.systemDao  // [rename] to newSystemDao()?\n\n\n  def siteDao(siteId: SiteId): SiteDao =  // RENAME [rename] to newSiteDao?\n    state.siteDaoFactory.newSiteDao(siteId)\n\n\n  def redisClient: RedisClient = state.redisClient\n\n\n  def sendEmail(email: Email, siteId: SiteId): Unit = {\n    state.mailerActorRef ! (email, siteId)\n  }\n\n  def sendEmails(emails: Iterable[Email], siteId: SiteId): Unit = {\n    COULD_OPTIMIZE // send just one message with all emails to send.\n    emails foreach { email =>\n      sendEmail(email, siteId)\n    }\n  }\n\n  def endToEndTestMailer: ActorRef = state.mailerActorRef\n  def spamCheckActor: Option[ActorRef] = state.spamCheckActorRef\n\n  def renderPageContentInBackground(\n        sitePageId: SitePageId, customParams: Option[PageRenderParamsAndHash]): Unit = {\n    if (!isTestDisableBackgroundJobs) {\n      state.renderContentActorRef ! (sitePageId, customParams)\n    }\n  }\n\n  /** Good to stop it, when importing sites via JSON, so can avoid PostgreSQL serialization\n    * failures. Later: One single actor for all database writes? + message passing. [one-db-writer]\n    */\n  def pauseAutoBackgorundRenderer3Seconds(): Unit = {\n    if (isTestDisableBackgroundJobs) return\n    state.renderContentActorRef ! RenderContentService.PauseThreeSeconds\n  }\n\n  def spamChecker: SpamChecker = state.spamChecker\n\n  /** Is non-zero iff server maintenance is going on, so that the server is read-only.\n    * Should be set to the Unix second when one thinks the maintenance will be done,\n    * or to 1 if one isn't sure. A change requires a Play app server restart to get picked up.\n    */\n  val maintWorkUntilSecs: Option[Long] = conf.getOptional[Long](\"talkyard.maintenanceUntilUnixSeconds\")\n\n  /* Add configurable support email address?  [CONFADDRS]\n  val supportEmailAddress: Option[String] =\n    getStringNoneIfBlank(\"talkyard.supportEmailAddress\") */\n\n  val securityComplaintsEmailAddress: Option[String] =\n    getStringNoneIfBlank(\"talkyard.securityComplaintsEmailAddress\")\n\n\n  /** Either exactly all sites uses HTTPS, or all of them use HTTP.\n    * A mixed configuration makes little sense I think:\n    * 1) On the public internet, obviously HTTPS should be used, always.\n    * 2) On an intranet, HTTP might be okay. And HTTPS. But not a combination of HTTP and HTTPS:\n    *   a) What about an intranet with some sites using HTTPS and some using HTTPS?\n    *     Then the organization would setup a Certificate Authority, install\n    *     certs in the members' browsers, but then uses them only sometimes, for some\n    *     sites? Why? That seems weird. Supporting this seems like not-well-spent-time.\n    *   b) What about sites that are accessible over HTTP on the intranet and HTTPS\n    *     on the public Internet? Then email links will break (they'll use either http or https).\n    *   c) What about some sites accessible only over HTTP on an intranet,\n    *     and others accessible only on the public Internet over HTTPS?\n    *     Then some firewall has to block access to the HTTP sites from the public internet.\n    *     Seems like a risky and unusual configuration. Not well spent time.\n    *     They might as well use two servers instead, one for the public internet,\n    *     one internally?\n    * -->\n    *  Either HTTP for all sites (assuming a trusted intranet), or HTTPS for all sites.\n    */\n  val secure: Boolean =\n    conf.getOptional[Boolean](\"talkyard.secure\") getOrElse {\n      logger.info(\"Config value 'talkyard.secure' missing; defaulting to true. [DwM3KEF2]\")\n      true\n    }\n\n\n  lazy val (anyLoginOrigin, loginOriginConfigErrorMessage): (Option[String], Option[String]) =\n    if (isOrWasTest) {\n      // The base domain should have been automatically configured with the test server's\n      // listen port.\n      (Some(s\"$scheme://$baseDomainWithPort\"), None)\n    }\n    else {\n      val anyOrigin = conf.getOptional[String](LoginOriginConfValName) orElse {\n        defaultSiteHostname map { hostname =>\n          s\"$scheme://$hostname$colonPort\"\n        }\n      }\n      var anyError: Option[String] = None\n      anyOrigin foreach { origin =>\n        if (secure && !origin.startsWith(\"https:\")) {\n          anyError = Some(s\"Config value '$LoginOriginConfValName' does not start with 'https:'\")\n          logger.error(s\"Disabling OAuth: ${anyError.get}. It is: '$origin' [DwE6KW5]\")\n        }\n      }\n      (anyOrigin, anyError)\n    }\n\n\n  object socialLogin {\n    import com.mohiva.play.silhouette.impl.providers.{OAuth1Settings, OAuth2Settings}\n\n    val googleOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGoogle(confValName: String) = getConfValOrThrowDisabled(confValName, \"Google\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.google.authorizationURL\"),\n        accessTokenURL = getGoogle(\"silhouette.google.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"google\"),\n        clientID = getGoogle(\"silhouette.google.clientID\"),\n        clientSecret = getGoogle(\"silhouette.google.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.google.scope\"))\n    }\n\n    val facebookOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getFacebook(confValName: String) = getConfValOrThrowDisabled(confValName, \"Facebook\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.facebook.authorizationURL\"),\n        accessTokenURL = getFacebook(\"silhouette.facebook.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"facebook\"),\n        clientID = getFacebook(\"silhouette.facebook.clientID\"),\n        clientSecret = getFacebook(\"silhouette.facebook.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.facebook.scope\"))\n    }\n\n    val twitterOAuthSettings: OAuth1Settings Or ErrorMessage = goodOrError {\n      def getTwitter(confValName: String) = getConfValOrThrowDisabled(confValName, \"Twitter\")\n      OAuth1Settings(\n        requestTokenURL = getTwitter(\"silhouette.twitter.requestTokenURL\"),\n        accessTokenURL = getTwitter(\"silhouette.twitter.accessTokenURL\"),\n        authorizationURL = getTwitter(\"silhouette.twitter.authorizationURL\"),\n        callbackURL = makeRedirectUrl(\"twitter\").get,\n        consumerKey = getTwitter(\"silhouette.twitter.consumerKey\"),\n        consumerSecret = getTwitter(\"silhouette.twitter.consumerSecret\"))\n    }\n\n    val githubOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGitHub(confValName: String) = getConfValOrThrowDisabled(confValName, \"GitHub\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.github.authorizationURL\"),\n        accessTokenURL = getGitHub(\"silhouette.github.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"github\"),\n        apiURL = getStringNoneIfBlank(\"silhouette.github.apiURL\"),\n        clientID = getGitHub(\"silhouette.github.clientID\"),\n        clientSecret = getGitHub(\"silhouette.github.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.github.scope\"))\n    }\n\n    // rm\n    val gitlabOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGitLab(confValName: String) = getConfValOrThrowDisabled(confValName, \"GitLab\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.gitlab.authorizationURL\"),\n        accessTokenURL = getGitLab(\"silhouette.gitlab.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"gitlab\"),\n        clientID = getGitLab(\"silhouette.gitlab.clientID\"),\n        clientSecret = getGitLab(\"silhouette.gitlab.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.gitlab.scope\"))\n    }\n\n    val linkedInOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getLinkedin(confValName: String) = getConfValOrThrowDisabled(confValName, \"LinkedIn\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.linkedin.authorizationURL\"),\n        accessTokenURL = getLinkedin(\"silhouette.linkedin.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"linkedin\"),\n        // These fields no longer available in LinkedIn's API v2, unless one somehow\n        // partners with LinkedIn;\n        //apiURL = Some(\"https://api.linkedin.com/v2/me?fields=id,first-name,last-name,formatted-name,picture-url,email-address&oauth2_access_token=%s\"),\n        // Also profilePicture results in an error.\n        // Instead:\n        apiURL = Some(\"https://api.linkedin.com/v2/me?fields=id,firstName,lastName&oauth2_access_token=%s\"),\n        clientID = getLinkedin(\"silhouette.linkedin.clientID\"),\n        clientSecret = getLinkedin(\"silhouette.linkedin.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.linkedin.scope\"))\n    }\n\n    // rm\n    val vkOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getVk(confValName: String) = getConfValOrThrowDisabled(confValName, \"VK\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.vk.authorizationURL\"),\n        accessTokenURL = getVk(\"silhouette.vk.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"vk\"),\n        clientID = getVk(\"silhouette.vk.clientID\"),\n        clientSecret = getVk(\"silhouette.vk.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.vk.scope\"))\n    }\n\n    // rm\n    val instagramOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getInstagram(confValName: String) = getConfValOrThrowDisabled(confValName, \"Instagram\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.instagram.authorizationURL\"),\n        accessTokenURL = getInstagram(\"silhouette.instagram.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"instagram\"),\n        clientID = getInstagram(\"silhouette.instagram.clientID\"),\n        clientSecret = getInstagram(\"silhouette.instagram.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.instagram.scope\"))\n    }\n\n\n    private def goodOrError[A](block: => A): A Or ErrorMessage =\n      try Good(block)\n      catch {\n        case ex: QuickMessageException => Bad(ex.message)\n      }\n\n    private def getConfValOrThrowDisabled(confValName: String, providerName: String): String =\n      getStringNoneIfBlank(confValName) getOrElse {\n        throw new QuickMessageException(\n          s\"Login via $providerName not possible: Config value missing: $confValName [TyE0SOCIALCONF\")\n      }\n\n    private def makeRedirectUrl(provider: String): Option[String] = {\n      // A relative path which will be resolved against the current request's host.\n      // BUG?: seems Silhouette changes from https to http. So add origin ourselves:\n      val urlPath = controllers.routes.LoginWithOpenAuthController.finishAuthentication(provider).url\n      Some(anyLoginOrigin.getOrElse(\"\") + urlPath)\n    }\n  }\n\n\n  /** If secure=true, then prefix with 'https:', if absent (i.e. if only '//' specified),\n    * so a 'http:' embedded comments iframe parent base address (i.e. a <base href=...> elem)\n    * won't make us use http instead of https \u2014 that could break embedded comments when testing\n    * locally and embedding page = http://localhost/... .\n    */\n  val anyCdnOrigin: Option[String] =\n    config.cdn.origin.map(origin => {\n      if (origin.startsWith(\"https:\")) origin\n      else if (secure && origin.startsWith(\"//\")) \"https:\" + origin\n      else if (!secure) origin\n      else if (origin.startsWith(\"http:\")) {\n        die(\"EdEINSECCDNORIG\", o\"\"\"The server is configured to use https, but in the config file,\n            $CdnOriginConfValName is http://... (not https)\"\"\")\n      }\n      else {\n        die(\"EdEBADCDNORIG\", o\"\"\"In the config file, $CdnOriginConfValName is not http(s)\n            but something else weird.\"\"\")\n      }\n    })\n\n  def cdnOrSiteOrigin(siteHost: St): St =\n    anyCdnOrigin.getOrElse(schemeColonSlashSlash + siteHost)\n\n  val scheme: String = if (secure) \"https\" else \"http\"\n  def schemeColonSlashSlash: String = scheme + \"://\"\n\n  val port: Int = {\n    if (isOrWasTest) {\n      // Not on classpath: play.api.test.Helpers.testServerPort\n      // Instead, duplicate its implementation here:\n      sys.props.get(\"testserver.port\").map(_.toInt) getOrElse 19001\n    }\n    else {\n      conf.getOptional[Int](\"talkyard.port\") getOrElse {\n        if (secure) 443\n        else 80\n      }\n    }\n  }\n\n  def colonPort: String =\n    if (secure && port == 443) \"\"\n    else if (!secure && port == 80) \"\"\n    else s\":$port\"\n\n  val baseDomainNoPort: String =\n    if (isOrWasTest) \"localhost\"\n    else getStringNoneIfBlank(\"talkyard.baseDomain\") getOrElse \"localhost\"\n\n  val baseDomainWithPort: String =  // [CONFADDRS]\n    if (secure && port == 443) baseDomainNoPort\n    else if (!secure && port == 80) baseDomainNoPort\n    else s\"$baseDomainNoPort:$port\"\n\n\n  /** Accessing this hostname will return the default site, namely site 1 (or defaultSiteId,\n    * if configured.)\n    */\n  val defaultSiteHostname: Option[String] =\n    getStringNoneIfBlank(DefaultSiteHostnameConfValName)\n\n  if (defaultSiteHostname.exists(_ contains ':'))\n    logger.error(s\"Config value $DefaultSiteHostnameConfValName contains ':' [DwE4KUWF7]\")\n\n  val becomeFirstSiteOwnerEmail: Option[String] =\n    getStringNoneIfBlank(BecomeOwnerEmailConfValName)\n\n  val siteOwnerTermsUrl: Option[String] =\n    getStringNoneIfBlank(SiteOwnerTermsUrl)\n\n  val siteOwnerPrivacyUrl: Option[String] =\n    getStringNoneIfBlank(SiteOwnerPrivacyUrl)\n\n  /** If accessing the server via ip address, then, if no website with a matching ip has been\n    * configured in the database, we'll show the site with id 'defaultSiteId'. If not defined,\n    * we'll use FirstSiteId (i.e. 1, one).\n    */\n\n  val defaultSiteId: SiteId = getIntOrDefault(DefaultSiteIdConfValName, FirstSiteId)\n\n  /** New sites may be created only from this hostname. */\n  val anyCreateSiteHostname: Option[String] =\n    getStringNoneIfBlank(CreateSiteHostnameConfValName)\n  val anyCreateTestSiteHostname: Option[String] =\n    getStringNoneIfBlank(\"talkyard.createTestSiteHostname\")\n\n  val anyUploadsDir: Option[String] = {\n    val value = getStringNoneIfBlank(LocalhostUploadsDirConfValName)\n    val pathSlash = if (value.exists(_.endsWith(\"/\"))) value else value.map(_ + \"/\")\n    pathSlash match {\n      case None =>\n        Some(DefaultLocalhostUploadsDir)\n      case Some(path) =>\n        // SECURITY COULD test more dangerous dirs. Or whitelist instead?\n        if (path == \"/\" || path.startsWith(\"/etc/\") || path.startsWith(\"/bin/\")) {\n          logger.warn(o\"\"\"Config value $LocalhostUploadsDirConfValName specifies\n                a dangerous path: $path \u2014 file uploads disabled. [DwE0GM2]\"\"\")\n          None\n        }\n        else {\n          pathSlash\n        }\n    }\n  }\n\n  val anyPublicUploadsDir: Option[String] = anyUploadsDir.map(_ + \"public/\")\n\n  def settingsBySiteId(siteId: SiteId): AllSettings =\n    siteDao(siteId).getWholeSiteSettings()\n\n  def siteById(siteId: SiteId): Option[Site] =\n    systemDao.getSiteById(siteId)\n\n  def originOfSiteId(siteId: SiteId): Option[String] =\n    systemDao.getSiteById(siteId).flatMap(_.canonicalHostname.map(originOf))\n\n  def theHostnameOf(site: Site): String =\n    site.canonicalHostnameStr getOrElse siteByPubIdHostnamePort(site.pubId)\n\n  def theOriginOf(site: Site): String =\n    originOf(site) getOrElse siteByPubIdOrigin(site.pubId)\n\n  def originOf(site: Site): Option[String] = site.canonicalHostname.map(originOf)\n  def originOf(host: Hostname): String = originOf(host.hostname)\n  def originOf(hostOrHostname: String): String = {\n    val (hostname, colonPortParam) = hostOrHostname.span(_ != ':')\n    def portParam = colonPortParam drop 1\n    dieIf(colonPortParam.nonEmpty && colonPortParam != colonPort,\n      \"EdE47SK2\", o\"\"\"Bad port: $portParam. You're accessing the server via non-standard\n        port $portParam, but then you need to add config value `talkyard.port=$portParam`,\n        in file /opt/talkyard/conf/app/play.conf,\n        otherwise I won't know for sure which port to include in URLs I generate.\n        Also restart the app server for the new config to take effect:\n        sudo docker-compose restart web app\"\"\")\n    s\"$scheme://$hostname$colonPort\"\n  }\n  def originOf(request: p.mvc.RequestHeader): String = s\"$scheme://${request.host}\"\n\n  def originOf(request: GetRequest): String =\n    originOf(request.underlying)\n\n\n  def poweredBy = s\"https://www.talkyard.io\"\n\n\n  /** If a hostname matches this pattern, the site id can be extracted directly from the url.\n    */\n  val siteByIdHostnameRegex: Regex = {\n    // The hostname must be directly below the base domain, otherwise\n    // wildcard HTTPS certificates won't work: they cover 1 level below the\n    // base domain only, e.g. host.example.com but not sub.host.example.com,\n    // if the cert was issued for *.example.com.\n    s\"\"\"^$SiteByIdHostnamePrefix(.*)\\\\.$baseDomainNoPort$$\"\"\".r\n  }\n\n  def SiteByIdHostnamePrefix = \"site-\"\n\n  def siteByPubIdOrigin(pubId: PubSiteId): String =\n    s\"$scheme://${siteByPubIdHostnamePort(pubId)}\"\n\n  def siteByIdOrigin(siteId: SiteId): String =\n    s\"$scheme://${siteByIdHostnamePort(siteId)}\"\n\n  // [Scala_3]  can replace the two below with just one:  `siteId: SiteId | PubSiteId`.\n  // And the two ...By..Origin above too.\n\n  def siteByIdHostnamePort(siteId: SiteId): String =\n    s\"$SiteByIdHostnamePrefix$siteId.$baseDomainWithPort\"\n\n  def siteByPubIdHostnamePort(pubId: PubSiteId): String =\n    s\"$SiteByIdHostnamePrefix$pubId.$baseDomainWithPort\"\n\n\n  def pubSub: PubSubApi = state.pubSub\n  def strangerCounter: StrangerCounterApi = state.strangerCounter\n\n\n  /** Looks up a site by hostname, or directly by id.\n    *\n    * By id: If a HTTP request specifies a hostname like \"site-<id>.<baseDomain>\",\n    * for example:  site-123.example.com,\n    * then the site is looked up directly by id.\n    */\n  def lookupSiteOrThrow(request: RequestHeader): SiteBrief = {\n    // Nginx sends the host name in the Host header \u2014 not in the request line.\n    // (So, no need to use Play's request.host, which looks first in the request\n    // line for any Absolute-URI,  e.g.: 'https://example.com/url/path',  defined in RFC 3986\n    // https://tools.ietf.org/html/rfc3986#page-27\n    // \u2014 Nginx instead sends just  '/url/path' and the host in the Host header.)\n    // Later:\n    //val hostInHeader = request.headers.get(p_HeaderNames.HOST).getOrElse(\"\") //  [ngx_host_hdr]\n    // For now: (doesn't matter \u2014 this'll use the Host header anyway)\n    val hostInHeader = request.host\n    lookupSiteOrThrow(host = hostInHeader, request.uri)\n  }\n\n\n  def lookupSiteOrThrow(url: String): SiteBrief = {\n    val (scheme, separatorHostPathQuery) = url.span(_ != ':')\n    val (host, pathAndQuery) =\n      separatorHostPathQuery.drop(3).span(_ != '/') // drop(3) drops \"://\"\n    lookupSiteOrThrow(host = host, pathAndQuery)\n  }\n\n\n  private def lookupSiteOrThrow(host: String, pathAndQuery: String): SiteBrief = {\n    // Play supports one HTTP and one HTTPS port only, so it makes little sense\n    // to include any port number when looking up a site.\n    val hostname = if (host contains ':') host.span(_ != ':')._1 else host\n\n    def defaultSiteIdAndHostname = {\n      val hostname = defaultSiteHostname getOrElse throwForbidden(\n        \"EsE5UYK2\", o\"\"\"No site hostname configured (config value: $DefaultSiteHostnameConfValName)\"\"\")\n      if (defaultSiteId != FirstSiteId) {\n        val site = systemDao.getSiteById(defaultSiteId).getOrDie(\n          \"EdEDEFSITEID\", o\"\"\"There's no site with id $defaultSiteId, which is the configured\n            default site id (config value: $DefaultSiteIdConfValName)\"\"\")\n        SiteBrief(defaultSiteId, site.pubId, Some(hostname), site.status,\n              featureFlags = site.featureFlags)\n      }\n      else {\n        // Lazy-create the very first site, with id 1, if doesn't yet exist.\n        val firstSite = systemDao.getOrCreateFirstSite()\n        SiteBrief(FirstSiteId, firstSite.pubId, Some(hostname), firstSite.status,\n              featureFlags = firstSite.featureFlags)\n      }\n    }\n\n    if (defaultSiteHostname is hostname)\n      return defaultSiteIdAndHostname\n\n    // If the hostname is like \"site-123.example.com\" then we'll just lookup site id 123.\n    // Or if the id is long, like \"site-aabbcc112233.ex.com\" then we'll lookup by publ id aabb...33.\n    val SiteByIdRegex = siteByIdHostnameRegex // uppercase, otherwise Scala won't \"de-structure\".\n    hostname match {\n      case SiteByIdRegex(siteIdString: String) =>\n        val anySite =\n          if (siteIdString.length >= Site.MinPubSiteIdLength) {\n            systemDao.getSiteByPubId(siteIdString)\n          }\n          else {\n            SECURITY; PRIVACY // LATER, don't allow lookup by direct id, in prod mode,  [5UKFBQW2]\n            // because that'd let people find and crawl all sites hosted by this server\n            // (by crawling site-1, site-2, ...). And the server owners might not like that.\n            // (Access by publ site ids is ok though: they are long random strings, not sequential ids.)\n            // throwForbiddenIf(isProd && !okForbiddenPassword,\n            //    \"TyE4HJWQ10\", \"Looking up sites by private id is not allowed\")\n            val siteId = siteIdString.toIntOrThrow(\"EdE5PJW2\", s\"Bad site id: $siteIdString\")\n            systemDao.getSiteById(siteId)\n          }\n        anySite match {\n          case None =>\n            throwNotFound(\"DwE72SF6\", s\"No site with id $siteIdString\")\n          case Some(site: Site) =>\n            COULD // link to canonical host if (site.hosts.exists(_.role == SiteHost.RoleCanonical))\n            // Let the config file hostname have precedence over the database.\n            if (site.id == defaultSiteId && defaultSiteHostname.isDefined)\n              return site.brief.copy(hostname = defaultSiteHostname)\n            else\n              return site.brief\n        }\n      case _ =>\n    }\n\n    // Id unknown so we'll lookup the hostname instead.\n    val lookupResult = systemDao.lookupCanonicalHost(hostname) match {\n      case Some(result) =>\n        if (result.thisHost == result.canonicalHost)\n          result\n        else result.thisHost.role match {\n          case Hostname.RoleDuplicate =>\n            result\n          case Hostname.RoleRedirect =>\n            throwPermanentRedirect(originOf(result.canonicalHost.hostname) + pathAndQuery)\n          case Hostname.RoleLink =>\n            die(\"DwE2KFW7\", \"Not implemented: <link rel='canonical'>\")\n          case Hostname.RoleDeleted =>\n            die(\"TyEMAT752\", s\"Shouldn't have loaded deleted hostname: $result\")\n          case _ =>\n            die(\"DwE20SE4\")\n        }\n      case None =>\n        if (Site.Ipv4AnyPortRegex.matches(hostname)) {\n          // Make it possible to access the server before any domain has been pointed\n          // to it, just after installation, by lazy-creating an empty default site.\n          return defaultSiteIdAndHostname\n        }\n        throwSiteNotFound(\n          hostname, debugCode = \"LKPCANHOST\")\n    }\n    val site = systemDao.getSiteById(lookupResult.siteId) getOrDie \"EsE2KU503\"\n    site.brief\n  }\n\n\n  def startStuff(): Unit = {\n    if (_state ne null)\n      throw new jl.IllegalStateException(o\"\"\"Server already running, was it not properly\n        shut down last time? Please hit CTRL+C to kill it. [DwE83KJ9]\"\"\")\n\n    DeadlockDetector.ensureStarted()\n\n    // Let the server start, whilst we try to connect to services like the database and Redis.\n    // If we're unable to connect to a service, then we'll set _state to a\n    // developer / operations-team friendly error message about the service being\n    // inaccessible, and some tips about how troubleshoot this and how to start it.\n    // Whilst the state is being created, we'll show a message in any browser that\n    // the server is starting, please wait \u2014 to me, that's more user friendly than\n    // a blank page, in case this takes long.\n    val createStateFuture = Future {\n      tryCreateStateUntilKilled()\n    }\n\n    createStateFuture foreach { _ =>\n      logger.info(\"State created. [EsMSTATEREADY]\")\n    }\n\n    // When testing, never proceed before the server has started properly, or tests will fail (I think).\n    if (isOrWasTest) {\n      try {\n        Await.ready(createStateFuture, 99.seconds)\n        if (killed) {\n          logger.info(\"Killed. Bye. [EsMKILLED]\")\n          // Don't know how to tell Play to exit? Maybe might as well just:\n          System.exit(0)\n          // However this leaves a RUNNING_PID file. So the docker container deletes it\n          // before start, see docker/play-prod/Dockerfile [65YKFU02]  <\u2014 this was before,\n          //                                     when also Prod mode waited for the future.\n\n          // However this block won't run if we've started already. So exiting directly\n          // in the signal handler instea, right now, see [9KYKW25] above. Not sure why Play\n          // apparently ignores signals, once we've started (i.e. returned from this function).\n        }\n      }\n      catch {\n        case _: TimeoutException =>\n          logger.error(\"Creating state takes too long, something is amiss? [EsESTATESLOW]\")\n          System.exit(0)\n      }\n    }\n  }\n\n\n  private def tryCreateStateUntilKilled(): Unit = {\n    logger.info(\"Creating state.... [EdMCREATESTATE]\")\n    _state = Bad(None)\n    var firsAttempt = true\n\n    while (_state.isBad && !killed && !shallStopStuff) {\n      if (!firsAttempt) {\n        // Don't attempt to connect to everything too quickly, because then 100 MB log data\n        // with \"Error connecting to database ...\" are quickly generated.\n        Thread.sleep(4000)\n        if (killed || shallStopStuff) {\n          logger.info(killed ? \"Killed. Bye. [EsM200KILLED]\" |\n              \"Aborting create-state loop, shall stop stuff [EsMSTOPSTATE1]\")\n          return\n        }\n      }\n      firsAttempt = false\n      val cache = makeCache\n      try {\n        reloadAppSecret()\n        if (isProd && _appSecret == AppSecretDefVal)\n          throw AppSecretNotChangedException\n\n        logger.info(\"Connecting to database... [EsM200CONNDB]\")\n        val readOnlyDataSource = Debiki.createPostgresHikariDataSource(readOnly = true, conf, isOrWasTest)\n        val readWriteDataSource = Debiki.createPostgresHikariDataSource(readOnly = false, conf, isOrWasTest)\n        val rdb = new Rdb(readOnlyDataSource, readWriteDataSource)\n        val dbDaoFactory = new RdbDaoFactory(\n          rdb, ScalaBasedMigrations, getCurrentTime = now, cdnOrigin = anyCdnOrigin, isOrWasTest)\n\n        // Create any missing database tables before `new State`, otherwise State\n        // creates background threads that might attempt to access the tables.\n        logger.info(\"Running database migrations... [EsM200MIGRDB]\")\n        new SystemDao(dbDaoFactory, cache, this).applyEvolutions()\n\n        logger.info(\"Done migrating database. Connecting to other services... [EsM200CONNOTR]\")\n        val newState = new State(dbDaoFactory, cache)\n\n        if (isOrWasTest && conf.getOptional[Boolean](\"isTestShallEmptyDatabase\").contains(true)) {\n          logger.info(\"Emptying database... [EsM200EMPTYDB]\")\n          newState.systemDao.emptyDatabase()\n        }\n\n        _state = Good(newState)\n        logger.info(\"Done creating state [EsMSTATEOK]\")\n      }\n      catch {\n        case ex: com.zaxxer.hikari.pool.HikariPool.PoolInitializationException =>\n          _state = Bad(Some(new DatabasePoolInitializationException(ex)))\n        case ex @ AppSecretNotChangedException =>\n          logger.error(s\"Admin error: The admin hasn't edited '$AppSecretConfValName' [EdE2QCHP4]\", ex)\n          _state = Bad(Some(ex))\n        case ex @ StillConnectingException =>\n          logger.error(\"Bug: StillConnectingException [EdE3PG7FY1]\", ex)\n          _state = Bad(Some(ex))\n        case ex: Exception =>\n          logger.error(\"Unknown state creation error [EsE4GY67]\", ex)\n          _state = Bad(Some(ex))\n      }\n    }\n\n    if (killed || shallStopStuff) {\n      logger.info(\"Aborting create-state loop [EsMSTOPSTATE2]\")\n      return\n    }\n\n    // The render engines might be needed by some Java (Scala) evolutions.\n    // Let's create them in this parallel thread rather than blocking the whole server.\n    // (Takes 2? 5? seconds.)\n    edContext.nashorn.startCreatingRenderEngines()\n\n    if (!isTestDisableBackgroundJobs) {\n      actorSystem.scheduler.scheduleOnce(5.seconds, state.renderContentActorRef,\n          RenderContentService.RegenerateStaleHtml())(executionContext)\n    }\n\n    logger.info(\"Done creating rendering engines [EsMENGDONE]\")\n  }\n\n\n  def stopStuff(): Unit = {\n    // Play.start() first calls Play.stop(), so:\n    if (_state eq null)\n      return\n\n    if (_state.isBad) {\n      shallStopStuff = true\n    }\n    else {\n      if (isDevOrTest) {\n        // Could wait for this to complete, but doesn't matter \u2014 just dev & test.\n        logger.info(s\"Closing WebSockets ...\")\n        pubSub.closeWebSocketConnections()\n      }\n\n      // Shutdown the NotifierActor before the MailerActor, so no notifications\n      // are lost because the MailerActor was gone, couldn't send them.\n      logger.info(s\"Stopping the NotifierActor ...\")\n      val (name, future) = stopPlease(state.notifierActorRef)\n      Await.result(future, ShutdownTimeout)\n\n      // Shutdown in parallel.\n      logger.info(s\"Stopping remaining actors ...\")\n      val futureShutdownResults = Seq(\n            stopPlease(state.mailerActorRef),\n            stopPlease(state.renderContentActorRef),\n            stopPlease(state.indexerActorRef),\n            stopPlease(state.spamCheckActorRef),\n            stopPlease(state.janitorActorRef),\n            stopPlease(state.pubSubActorRef))\n\n      state.elasticSearchClient.close()\n      state.redisClient.quit()\n      state.dbDaoFactory.db.readOnlyDataSource.asInstanceOf[HikariDataSource].close()\n      state.dbDaoFactory.db.readWriteDataSource.asInstanceOf[HikariDataSource].close()\n      wsClient.close()\n\n      // Wait ... (Also see:\n      // https://stackoverflow.com/questions/16256279/how-to-wait-for-several-futures )\n      futureShutdownResults foreach { nameAndFutureResult =>\n        logger.info(s\"Waiting for ${nameAndFutureResult._1} to stop ...\")\n        Await.result(nameAndFutureResult._2, ShutdownTimeout)\n      }\n      logger.info(s\"All actors stopped\")\n    }\n\n    _state = null\n    timeStartMillis = None\n    timeOffsetMillis = 0\n\n    shutdownLogging()\n  }\n\n\n  private def stopPlease(anyActorRef: Option[ActorRef])\n        : (String, Future[Boolean]) = anyActorRef match {\n    case None => (\"None\", Future.successful(true))\n    case Some(ref) => stopPlease(ref)\n  }\n\n\n  private def stopPlease(actorRef: ActorRef): (String, Future[Boolean]) = {\n    logger.info(s\"Telling actor to stop: ${actorRef.path}\")\n    val future = gracefulStop(actorRef, ShutdownTimeout)\n    (actorRef.path.name, future)\n  }\n\n\n  def shutdownLogging(): Unit = {\n    // Flush any async log messages, just in case, so they won't get lost.\n    // See: https://logback.qos.ch/manual/configuration.html#stopContext\n    // and: https://github.com/logstash/logstash-logback-encoder/tree/logstash-logback-encoder-4.9\n    // this: \"\"\"In order to guarantee that logged messages have had a chance to be processed by\n    // the TCP appender, you'll need to cleanly shut down logback when your application exits.\"\"\"\n    import org.slf4j.LoggerFactory\n    import ch.qos.logback.classic.LoggerContext\n    // assume SLF4J is bound to logback-classic in the current environment\n    val loggerContext = LoggerFactory.getILoggerFactory.asInstanceOf[LoggerContext]\n    loggerContext.stop()\n  }\n\n\n  /** Caffeine is a lot faster than EhCache, and it doesn't have annoying problems with\n    * a singleton that causes weird classloader related errors on Play app stop-restart.\n    * (For a super large out-of-process survive-restarts cache, we use Redis not EhCache.)\n    */\n  private def makeCache: DaoMemCache = caffeine.cache.Caffeine.newBuilder()\n    .maximumWeight(10*1000)  // change to config value, e.g. 1e9 = 1GB mem cache. Default to 50M?\n    .weigher[String, DaoMemCacheAnyItem](new caffeine.cache.Weigher[String, DaoMemCacheAnyItem] {\n    override def weigh(key: String, value: DaoMemCacheAnyItem): Int = {\n      // For now. Later, use e.g. size of cached HTML page + X bytes for fixed min size?\n      // Can use to measure size: http://stackoverflow.com/a/30021105/694469\n      //   --> http://openjdk.java.net/projects/code-tools/jol/\n      1\n    }\n  }).build().asInstanceOf[DaoMemCache]\n\n\n  def now(): When = {\n    // [E2EBUG]: This won't work when running many e2e tests in parallel.\n    // But can make this work, by letting the time offset be per site.\n    val millisNow =\n      if (!isInitialized || !mayFastForwardTime) System.currentTimeMillis()\n      else {\n        val millisStart = timeStartMillis getOrElse System.currentTimeMillis()\n        millisStart + timeOffsetMillis\n      }\n    When.fromMillis(millisNow)\n  }\n\n  /** When running tests only. */\n  def testSetTime(when: When): Unit = {\n    timeStartMillis = Some(when.millis)\n    timeOffsetMillis = 0\n  }\n\n  /** When running tests only. */\n  def testFastForwardTimeMillis(millis: Long): Unit = {\n    timeOffsetMillis += millis\n  }\n\n  /** When running tests only. */\n  def testResetTime(): Unit = {\n    timeStartMillis = None\n    timeOffsetMillis = 0\n  }\n\n  @volatile\n  private var timeStartMillis: Option[Long] = None\n\n  @volatile\n  private var timeOffsetMillis: Long = 0\n\n\n  val loadGlobalAdminScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalAdminScript\")\n  val loadGlobalStaffScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalStaffScript\")\n  val loadGlobalAllScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalAllScript\")\n\n  /** Not needed any longer, after I ported to compile time dependency injection, with Play 2.6?\n    */\n  private class State(\n    val dbDaoFactory: RdbDaoFactory,\n    val cache: DaoMemCache) {\n\n    // Redis. (A Redis client pool makes sense if we haven't saturate the CPU on localhost, or\n    // if there're many Redis servers and we want to round robin between them. Not needed, now.)\n    val redisHost: ErrorMessage =\n      conf.getOptional[String](\"talkyard.redis.host\").noneIfBlank getOrElse \"localhost\"\n    val redisClient: RedisClient = RedisClient(host = redisHost)(actorSystem)\n\n    // Online user ids are cached in Redis so they'll be remembered accross server restarts,\n    // and will be available to all app servers. But we cache them again with more details here\n    // in-process mem too. (More details = we've looked up username etc in the database, but\n    // in Redis we cache only user ids.) Not for longer than a few seconds though,\n    // so that the online-users-json sent to the browsers on page load will be mostly up-to-date.\n    // (It'll get patched, later, via pubsub events. SHOULD implement this, otherwise\n    // race conditions can cause the online-users list in the browser to become incorrect.)\n    private val usersOnlineCache: UsersOnlineCache =\n      caffeine.cache.Caffeine.newBuilder()\n        .expireAfterWrite(3, TimeUnit.SECONDS)\n        .maximumSize(Int.MaxValue)\n        .build()\n        .asInstanceOf[UsersOnlineCache]\n\n    // ElasticSearch clients are thread safe. Their lifecycle should be the application lifecycle.\n    // (see https://discuss.elastic.co/t/is-nodeclient-thread-safe/4231/3 )\n    // (Later, could enable a certain 'client.transport.sniff' setting)\n    //\n    // old comment:\n    // The client might throw: org.elasticsearch.action.search.SearchPhaseExecutionException\n    // if the ElasticSearch database has not yet started up properly.\n    // If you wait for:\n    //   newClient.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet()\n    // then the newClient apparently works fine \u2014\u00a0but waiting for that (once at\n    // server startup) takes 30 seconds, on my computer, today 2013-07-20.\n    //\n    val elasticSearchHost = \"search\"\n\n    val elasticSearchClient: es.client.transport.TransportClient =\n      new es.transport.client.PreBuiltTransportClient(es.common.settings.Settings.EMPTY)\n        .addTransportAddress(\n          new es.common.transport.TransportAddress(\n            jn.InetAddress.getByName(elasticSearchHost), 9300))\n\n    val siteDaoFactory = new SiteDaoFactory(\n      edContext, dbDaoFactory, redisClient, cache, usersOnlineCache, elasticSearchClient, config)\n\n    val mailerActorRef: ActorRef = MailerActor.startNewActor(actorSystem, siteDaoFactory, conf, now, isProd)\n\n    val notifierActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(\n        NotifierActor.startNewActor(executionContext, actorSystem, systemDao, siteDaoFactory))\n\n    def indexerBatchSize: Int = getIntOrDefault(\"talkyard.search.indexer.batchSize\", 100)\n    def indexerIntervalSeconds: Int = getIntOrDefault(\"talkyard.search.indexer.intervalSeconds\", 5)\n\n    val indexerActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(SearchEngineIndexer.startNewActor(\n          indexerBatchSize, indexerIntervalSeconds, executionContext,\n          elasticSearchClient, actorSystem, systemDao))\n\n    def spamCheckBatchSize: Int = getIntOrDefault(\"talkyard.spamcheck.batchSize\", 20)\n    def spamCheckIntervalSeconds: Int =\n      getIntOrDefault(\"talkyard.spamcheck.intervalSeconds\", if (isOrWasTest) 1 else 4)\n\n    val spamCheckActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(SpamCheckActor.startNewActor(\n        spamCheckBatchSize, spamCheckIntervalSeconds, actorSystem, executionContext, systemDao))\n\n    // (Currently not in use, now with WebSocket ending in Play not in Nginx.)\n    val nginxHost: String =\n      conf.getOptional[String](\"talkyard.nginx.host\").noneIfBlank getOrElse \"localhost\"\n\n    val (pubSub, pubSubActorRef, strangerCounter) = PubSub.startNewActor(outer)\n\n    val renderContentActorRef: ActorRef =\n      RenderContentService.startNewActor(outer, edContext.nashorn)\n\n    val spamChecker = new SpamChecker(\n          config, isDevTest = isOrWasTest, siteById, originOfSiteId, settingsBySiteId,\n          executionContext, appLoaderContext.initialConfiguration, wsClient,\n          edContext.nashorn)\n\n    spamChecker.start()\n\n    val janitorActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs && !isTestEnableJanitor) None\n      else Some(Janitor.startNewActor(outer))\n\n    def systemDao: SystemDao = new SystemDao(dbDaoFactory, cache, outer) // RENAME to newSystemDao()?\n\n  }\n\n}\n\n\nobject Config {\n  val CreateSitePath = \"talkyard.createSite\"\n  val SuperAdminPath = \"talkyard.superAdmin\"\n  val SuperAdminEmailAddressesPath = s\"$SuperAdminPath.emailAddresses\"\n  val DnsCnameTargetHostConfValName = \"talkyard.cnameTargetHost\"\n}\n\n\nclass Config(conf: play.api.Configuration) extends TyLogging {\n\n  import Globals._\n\n  // Dupl [305926XFG24] -------------------\n  private def getIntOrDefault(confName: String, default: Int): Int =\n    conf.getOptional[Int](confName) getOrElse default\n\n  private def getF64OrDefault(confName: St, default: f64): f64 =\n    conf.getOptional[f64](confName) getOrElse default\n\n  private def getBoolOrDefault(confName: String, default: Boolean): Boolean =\n    conf.getOptional[Boolean](confName) getOrElse default\n\n  private def getStringOrEmpty(confName: String): String =\n    getStringOrDefault(confName, \"\")\n\n  private def getStringOrDefault(confName: String, default: String): String =\n    conf.getOptional[String](confName).trimNoneIfBlank getOrElse default\n  // --------------------------------------\n\n  val useServiceWorker: Boolean = getBoolOrDefault(\"talkyard.useServiceWorker\", default = true)\n\n  val maxWebSocketConnectionsAllSitesTotal: Int =\n    getIntOrDefault(\"talkyard.maxWebSockets\", 200)\n\n  // Remove these later \u2014 just for now, new feature switches.\n  // Don't set to true just yet \u2014 Apple iOS 12 handles None as Strict,\n  // that seems really bad?\n  val sameSiteNone: Boolean = getBoolOrDefault(\"talkyard.sameSiteNone\", default = false)\n  val sameSiteLax: Boolean = getBoolOrDefault(\"talkyard.sameSiteLax\", default = false)\n\n  val autoPurgeDelayDays: Opt[f64] =\n    conf.getOptional[f64](\"talkyard.autoPurgeDelayDays\")\n\n\n  CLEAN_UP; REMOVE // use  ffMayPatchSite  instead\n  private val mayPatchSiteIds: String = \",\" + getStringOrEmpty(\"talkyard.mayPatchSiteIds\") + \",\"\n  def mayPatchSite(siteId: SiteId): Boolean =\n    siteId == FirstSiteId ||                        // <\u2014\u2014 people's self hosted installations, fine\n      includesSiteId(mayPatchSiteIds, siteId)       // <\u2014\u2014 talkyard.net \u2014 restricted\n\n  private def includesSiteId(value: St, siteId: SiteId): Bo =\n    value.contains(\",\" + siteId + \",\")\n\n  val mayImportSite: Boolean = getBoolOrDefault(\"talkyard.mayImportSite\", default = false)\n  val maxImportDumpBytes: Int = getIntOrDefault(\"talkyard.maxImportDumpBytes\", default = 50*1000*1000)\n\n  val oneTimeSecretSecondsToLive: Long = getIntOrDefault(\n    \"talkyard.oneTimeSecretSecondsToLive\",\n    // Typically, the subsequent steps will be automatic, by the browser [306KUD244],\n    // so we can set a short expire time (no need to wait for the human to do\n    // anything). In dev mode though, allow time for debugging & breakpoints.\n    // Short time-to-live is good, mitigates session fixation attacks?\n    // Maybe just 15 seconds would be better? Let's wait with that.\n    default = if (Globals.isProd) 30 else 30 * 60).toLong\n\n  // Or use sites_t.feature_flags_c for the superadmin site instead?\n  val featureFlags: St = { // Map[String, FeatureOnOff] = {\n    conf.getOptional[St](\"talkyard.featureFlags\") getOrElse \"\"\n  }\n\n  val isTestDisableRateLimits: Boolean = {\n    val disable = getBoolOrDefault(\"talkyard.isTestDisableRateLimits\", default = false)\n    if (disable) {\n      logger.info(\"Is test with rate limits disabled. [TyM0RATELIM]\")\n    }\n    disable\n  }\n\n  val dnsCnameTargetHost: Option[String] =\n    conf.getOptional[String](Config.DnsCnameTargetHostConfValName).noneIfBlank\n\n  CLEAN_UP; REMOVE // this + the routes file entry [2KGLCQ4], use UploadsUrlBasePath instead only.\n  val uploadsUrlPath: String = controllers.routes.UploadsController.servePublicFile(\"\").url\n  require(uploadsUrlPath == ed.server.UploadsUrlBasePath, \"TyE2UKDU0\")\n\n  val maxGroupMentionNotfs: Int =\n    conf.getOptional[Int](MaxGroupMentionNotfsConfValName) getOrElse 25\n\n  val akismetApiKey: Option[String] =\n    conf.getOptional[String](\"talkyard.akismet.apiKey\").noneIfBlank orElse  // old name\n      conf.getOptional[String](\"talkyard.akismetApiKey\").noneIfBlank\n\n  // FOR NOW\n  val emailWebhooksApiSecret: Opt[St] =\n    conf.getOptional[St](\"talkyard.emailWebhooksApiSecret\").noneIfBlank\n\n  object uploads {\n    TESTS_MISSING // test that these conf vals work properly, by running UploadsDaoSpec twice,\n    // once with default values, once with 2 x higher values (people typically want to increase,\n    // not decrease, these limits).\n\n    private val p = \"talkyard.uploads.\"\n    // COULD make this configurable dynamically, per site, in the admin area, per site, too.\n    // The limits below, would then be a hard max, for each site, regardless of admin area settings.\n    //\n    // Hmm, no, instead, this can be a per group setting,  [more_pat_perms]\n    // configurable via: /-/groups/groupname.\n    // There's a whole site setting too, and that's the max-for-everyone setting.\n    // Also allowed upload types will be a per user/group setting, in addition\n    // to a site wide restriction.\n\n    val maxBytesPerDayMember: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerDayMember\", 10*Megabytes / 1000) * 1000\n\n    val maxBytesPerDayStaff: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerDayStaff\", 999*Megabytes / 1000) * 1000\n\n    val maxBytesPerWeekMember: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerWeekMember\", 25*Megabytes / 1000) * 1000\n\n    val maxBytesPerWeekStaff: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerWeekStaff\", 999*Megabytes / 1000) * 1000\n\n    private val largeUploadsSiteIds: String =\n        \",\" + getStringOrEmpty(p + \"mayUploadLargeFilesSiteIds\") + \",\"\n    def mayUploadLargeFiles(siteId: SiteId): Bo =\n      siteId == FirstSiteId ||\n        includesSiteId(largeUploadsSiteIds, siteId)\n\n    val maxBytesLargeFile: i32 =\n      i64ToMinMaxI32(conf.getOptional[f64](p + \"maxMiBLargeFile\").map(mib => (mib * Mebibyte64).toLong)\n            .getOrElse(maxUploadSizeBytes)) // <\u2014 REMOVE change to 10 MiB, default?\n\n    val maxBytesSmallFile: i32 =\n      f64ToMinMaxI32(getF64OrDefault(p + \"maxMiBSmallFile\", default = 1) * Mebibyte64)\n\n    // Old, remove\n    // 2 values: 1 for whole server, absolute max all sites.\n    // 1 per site.  serverGlobalMaxUploadKb   and siteDefaultMaxUploadKb\n    // Or  maxUploadKbServerGlobal  and  maxUploadKbSiteDefault\n    // And admins can config their site's siteDefaultMaxFileKb\n    //   up to serverGlobalMaxFileKb?\n    private def maxUploadSizeBytes: i64 =\n      (conf.getOptional[i64](\"talkyard.uploads.maxKiloBytesPerFile\") orElse\n        conf.getOptional[i64](\"talkyard.uploads.maxKiloBytes\")).map(_ * Kibibyte64)\n            .getOrElse(3 * Mebibyte64)  // or 25 MiB? Nginx: TY_NGX_LIMIT_REQ_BODY_SIZE=25m\n  }\n\n  object cdn {\n    /** No trailing slash. */\n    val origin: Option[String] =\n      conf.getOptional[String](CdnOriginConfValName).map(_.dropRightWhile(_ == '/')).noneIfBlank\n\n    def uploadsUrlPrefix: Option[String] = origin.map(_ + uploadsUrlPath)\n  }\n\n  object createSite {\n    private def path = Config.CreateSitePath\n\n    REFACTOR; RENAME // to ...tooManyTryLaterUrl\n    val tooManyTryLaterPagePath: Option[String] = conf.getOptional[String](s\"$path.tooManyTryLaterPagePath\")\n\n    val maxSitesPerPerson: Int = getIntOrDefault(s\"$path.maxSitesPerIp\", 10)\n    val maxTestSitesPerPerson: Int = getIntOrDefault(s\"$path.maxTestSitesPerIp\", maxSitesPerPerson * 3)\n\n    val maxSitesTotal: Int = getIntOrDefault(s\"$path.maxSitesTotal\", 1000)\n    val maxTestSitesTotal: Int = getIntOrDefault(s\"$path.maxTestSitesTotal\", maxSitesTotal * 3)\n\n    REFACTOR; RENAME // Later: rename to ed.createSite.newSiteQuotaMBs?\n    def quotaLimitMegabytes(isForBlogComments: Boolean, isTestSite: Boolean): Option[Int] = {\n      val limitForRealSite =\n        if (!isForBlogComments) quotaLimitMegabytesForum\n        else {\n          quotaLimitMegabytesBlogComments orElse {\n            // Blogs are relatively small, so restrict them a bit more.\n            quotaLimitMegabytesForum.map(_ / 10)\n          }\n        }\n      val resultMaybeZero =\n        if (isTestSite) limitForRealSite.map(_ / 10)\n        else limitForRealSite\n      resultMaybeZero.map(Math.max(_, 1))\n    }\n\n    private val quotaLimitMegabytesForum: Option[Int] =\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytesForum\") orElse\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytes\")\n\n    private val quotaLimitMegabytesBlogComments: Option[Int] =\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytesBlogComments\")\n  }\n\n  object superAdmin {\n    private def path = Config.SuperAdminPath\n    val hostname: Option[String] = conf.getOptional[String](s\"$path.hostname\")\n    val siteIdString: Option[String] = conf.getOptional[String](s\"$path.siteId\")\n    val emailAddresses: immutable.Seq[String] =\n      conf.getOptional[String](Config.SuperAdminEmailAddressesPath) match {\n        case None => Nil\n        case Some(emails) => emails.split(',').map(_.trim).toVector\n      }\n  }\n\n\n}\n\n", "/**\n * Copyright (c) 2020 Kaj Magnus Lindberg\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage talkyard.server.api\n\nimport com.debiki.core._\nimport controllers.OkApiJson\nimport debiki.RateLimits\nimport ed.server.http._\nimport ed.server.auth.MayMaybe\nimport debiki.EdHttp._\nimport Prelude._\nimport debiki.dao.{LoadPostsResult, PageStuff, SiteDao}\nimport ed.server.{EdContext, EdController}\nimport javax.inject.Inject\nimport play.api.libs.json.{JsObject, JsValue, JsArray, Json}\nimport play.api.mvc.{Action, ControllerComponents, Result}\nimport talkyard.server.JsX\nimport org.scalactic.{Bad, ErrorMessage, Good, Or}\n\n\n/** The ListQuery API, see: (project root)/tests/e2e/pub-api.ts\n  */\nclass GetController @Inject()(cc: ControllerComponents, edContext: EdContext)\n  extends EdController(cc, edContext) {\n\n\n\n  def apiV0_get(): Action[JsValue] = PostJsonAction(  // [PUB_API]\n          RateLimits.ReadsFromDb, maxBytes = 2000) { request: JsonPostRequest =>\n    getThingsImpl(request)\n  }\n\n\n  private def getThingsImpl(request: JsonPostRequest): Result = {\n    import request.body\n    val pretty = (body \\ \"pretty\").asOpt[Bo].getOrElse(false)\n    val getQueryJson = (body \\ \"getQuery\").as[JsObject]\n    val anyGetWhat = (getQueryJson \\ \"getWhat\").asOpt[Ref]\n    throwUnimplementedIf(anyGetWhat.isNot(\"Pages\"),\n          \"TyE2R502MWD\", \"Can only get pages as of now; 'getWhat' must be 'Pages'\")\n    val refs = (getQueryJson \\ \"getRefs\").asOpt[Seq[Ref]] getOrElse Nil\n    getPagesImpl(request, refs, pretty = pretty)\n  }\n\n\n  private def getPagesImpl(request: JsonPostRequest, pageRefs: Seq[Ref], pretty: Bo)\n          : Result = {\n    import request.{dao, requester}\n\n    val authzCtx = dao.getForumAuthzContext(requester)\n\n    throwUnimplementedIf(pageRefs.size >= 30,\n          \"TyE603MRT4\", \"Currently at most 30 at a time\")\n\n    def notFoundMsg(embUrl: St, pageId: PageId = NoPageId): St = {\n      s\"No page with that embedding url or discussion id: $embUrl\"\n    }\n\n    type PageRefAndId = (St, PageId)\n    val refsAndIds: Seq[PageRefAndId Or ErrMsg] = pageRefs map { ref: St =>\n      val refOrErr: St Or ErrMsg = parseRef(ref, allowParticipantRef = false) flatMap {\n        case ParsedRef.EmbeddingUrl(url) => Good(url)\n        case ParsedRef.DiscussionId(id) => Good(id)\n        case x => Bad(s\"Not an embedding url or discussion id: $x\")\n      }\n      refOrErr flatMap { ref: St =>\n        val anyPageId: Opt[PageId] = dao.getRealPageId(ref)\n        anyPageId match {\n          case Some(id) => Good((ref, id))\n          case None => Bad(notFoundMsg(ref))\n        }\n      }\n    }\n\n    val topicsOrErrs = refsAndIds map { refAndIdOrErr =>\n      refAndIdOrErr flatMap {\n        case (ref: St, pageId) => dao.getPagePathAndMeta(pageId) match {\n          case Some(page: PagePathAndMeta) =>\n            COULD_OPTIMIZE // will typically always be same cat, for emb cmts.\n            val categories = dao.getAncestorCategoriesRootLast(page.categoryId)\n            val may = ed.server.auth.Authz.maySeePage(\n                  page.meta,\n                  user = authzCtx.requester,\n                  groupIds = authzCtx.groupIdsUserIdFirst,\n                  pageMembers = Set.empty, // getAnyPrivateGroupTalkMembers(page.meta),\n                  catsRootLast = categories,\n                  tooManyPermissions = authzCtx.tooManyPermissions,\n                  // Embedded discussion topics are typically unlisted.\n                  maySeeUnlisted = true)\n           if (may == MayMaybe.Yes) Good(page)\n           else Bad(notFoundMsg(ref))  // or if dev/test: s\"Cannot find page $pageId\"\n          case None =>\n            Bad(notFoundMsg(ref))      // ... here too?  + err code\n        }\n      }\n    }\n\n    // Later, reuse?:\n    // ThingsFoundJson.makePagesFoundListResponse(topicsOrErrs, dao, pretty)\n    // For now:\n    // Typescript: SearchQueryResults, and ListQueryResults\n    val siteIdsOrigins = dao.theSiteIdsOrigins()\n    OkApiJson(Json.obj(\n          \"origin\" -> siteIdsOrigins.siteOrigin,\n          \"thingsOrErrs\" -> JsArray(\n            topicsOrErrs.map({\n              case Good(pagePathAndMeta) =>\n                Json.obj(\n                    \"numOpDoItVotes\" -> pagePathAndMeta.meta.numOrigPostDoItVotes,\n                    \"numOpDoNotVotes\" -> pagePathAndMeta.meta.numOrigPostDoNotVotes,\n                    \"numOpLikeVotes\" -> pagePathAndMeta.meta.numOrigPostLikeVotes,\n                    \"numTotRepliesVisible\" -> pagePathAndMeta.meta.numRepliesVisible)\n              case Bad(errMsg) =>\n                Json.obj(\"errMsg\" -> errMsg, \"errCode\" -> \"TyEPGNF\")\n            }))\n          ), pretty)\n  }\n\n}\n\n\n\n"], "fixing_code": ["/**\n * Copyright (C) 2012-2013 Kaj Magnus Lindberg (born 1979)\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage debiki\n\nimport akka.actor._\nimport akka.pattern.gracefulStop\nimport com.codahale.metrics\nimport com.debiki.core._\nimport com.debiki.core.Prelude._\nimport com.debiki.dao.rdb.{Rdb, RdbDaoFactory}\nimport com.github.benmanes.caffeine\nimport com.zaxxer.hikari.HikariDataSource\nimport debiki.EdHttp._\nimport ed.server.spam.{SpamCheckActor, SpamChecker}\nimport debiki.dao._\nimport debiki.dao.migrations.ScalaBasedMigrations\nimport ed.server.search.SearchEngineIndexer\nimport ed.server.notf.NotifierActor\nimport java.{lang => jl, net => jn}\nimport java.util.concurrent.TimeUnit\nimport ed.server.pubsub.{PubSub, PubSubApi, StrangerCounterApi}\nimport org.{elasticsearch => es}\nimport org.scalactic._\nimport play.{api => p}\nimport play.api.libs.ws.WSClient\nimport redis.RedisClient\nimport scala.collection.immutable\nimport scala.concurrent.duration._\nimport scala.concurrent.{Await, ExecutionContext, Future, TimeoutException}\nimport scala.util.matching.Regex\nimport ed.server.EdContext\nimport ed.server.http.GetRequest\nimport ed.server.jobs.Janitor\nimport play.api.http.{HeaderNames => p_HeaderNames}\nimport play.api.mvc.RequestHeader\nimport talkyard.server.TyLogging\n\n\nobject Globals extends TyLogging {\n\n  class NoStateError extends AssertionError(\n    \"No Globals.State created, please call onServerStartup() [DwE5NOS0]\")\n\n  object AppSecretNotChangedException extends QuickException\n  object StillConnectingException extends QuickException\n\n  class DatabasePoolInitializationException(cause: Exception) extends RuntimeException(cause)\n\n  val LoginOriginConfValName = \"talkyard.loginOrigin\"\n  val CdnOriginConfValName = \"talkyard.cdn.origin\"\n  val LocalhostUploadsDirConfValName = \"talkyard.uploads.localhostDir\"\n  val DefaultLocalhostUploadsDir = \"/opt/talkyard/uploads/\"\n\n  val AppSecretConfValName = \"play.http.secret.key\"\n  val AppSecretDefVal = \"change_this\"\n  val DefaultSiteIdConfValName = \"talkyard.defaultSiteId\"\n  val DefaultSiteHostnameConfValName = \"talkyard.hostname\"\n  val BecomeOwnerEmailConfValName = \"talkyard.becomeOwnerEmailAddress\"\n  val SiteOwnerTermsUrl = \"talkyard.siteOwnerTermsUrl\"\n  val SiteOwnerPrivacyUrl = \"talkyard.siteOwnerPrivacyUrl\"\n  val MaxGroupMentionNotfsConfValName = \"talkyard.maxGroupMentionNotifications\"\n\n  val CreateSiteHostnameConfValName = \"talkyard.createSiteHostname\"\n\n  CLEAN_UP; REMOVE //  Now placed in  core  instead -------\n  def isProd: Boolean = _isProd\n\n  def isDevOrTest: Boolean = !isProd\n\n  /** One never changes from Prod to Dev or Test, or from Dev or Test to Prod, so we can safely\n    * remember isProd, forever. (However, is-Dev and is-Test might change, depending on which\n    * commands one types in the cli.)\n    */\n  def setIsProdForever(isIt: Boolean): Unit = {\n    dieIf(hasSet && isIt != _isProd, \"EdE2PWVU07\")\n    _isProd = isIt\n    hasSet = true\n    com.debiki.core.Prelude.setIsProdForever(isIt)\n  }\n\n  private var _isProd = true\n  private var hasSet = false\n  // ------------------------------------------------------\n}\n\n\nclass E2eTestCounters {\n  @volatile var numReportedSpamFalsePositives: Int = 0\n  @volatile var numReportedSpamFalseNegatives: Int = 0\n}\n\n\nclass Globals(  // RENAME to TyApp? or AppContext? TyAppContext? variable name = appCtx\n                // But then rename EdContext  to ... what?\n  private val appLoaderContext: p.ApplicationLoader.Context,\n  val executionContext: scala.concurrent.ExecutionContext,\n  val wsClient: WSClient,\n  val actorSystem: ActorSystem,\n  val tracer: io.opentracing.Tracer) extends TyLogging {\n\n  def outer: Globals = this\n\n  import Globals._\n\n  def setEdContext(edContext: EdContext): Unit = {\n    dieIf(this.edContext ne null, \"EdE7UBR10\")\n    this.edContext = edContext\n  }\n\n  var edContext: EdContext = _\n\n  val e2eTestCounters = new E2eTestCounters\n\n  private implicit def execCtc: ExecutionContext = executionContext\n\n  val conf: p.Configuration = appLoaderContext.initialConfiguration\n  def rawConf: p.Configuration = conf\n\n  val config = new Config(conf)\n\n  // Dupl [305926XFG24] -------------------\n  private def getBoolOrFalse(confValName: String): Boolean =\n    getBoolOrDefault(confValName, default = false)\n\n  private def getIntOrDefault(confName: String, default: Int): Int =\n    conf.getOptional[Int](confName) getOrElse default\n\n  private def getBoolOrDefault(confName: String, default: Boolean): Boolean =\n    conf.getOptional[Boolean](confName) getOrElse default\n\n  // private def getStringOrEmpty[A](confName: String): String =\n  //   getStringOrDefault(confName, \"\")\n  //\n  //private def getStringOrDefault[A](confName: String, default: String): String =\n  //  conf.getOptional[String](confName).trimNoneIfBlank getOrElse default\n\n  private def getStringNoneIfBlank[A](confName: String): Option[String] =\n    conf.getOptional[String](confName).noneIfBlank\n  // --------------------------------------\n\n\n  /** Can be accessed also after the test is done and Play.maybeApplication is None.\n    */\n  val isDev: Boolean = appLoaderContext.environment.mode == play.api.Mode.Dev\n  val isOrWasTest: Boolean = appLoaderContext.environment.mode == play.api.Mode.Test\n  val isProd: Boolean = Globals.isProd\n\n  // This helps with shutting down when running tests \u2014 might not work properly now\n  // with Play 2.8 but seems the test shutdown properly anyway.\n  def testsDoneServerGone: Boolean =\n    isOrWasTest && (!isInitialized )  // [PLAY28] ?? || Play.maybeApplication.isEmpty)\n\n  val isTestDisableScripts: Boolean = isOrWasTest && {\n    val disable = getBoolOrFalse(\"isTestDisableScripts\")\n    if (disable) {\n      logger.info(\"Is test with scripts disabled. [EsM4GY82]\")\n    }\n    disable\n  }\n\n  lazy val (isTestDisableBackgroundJobs, isTestEnableJanitor): (Boolean, Boolean) =\n      if (isProd) (false, false) else {\n    val disableJobs = getBoolOrFalse(\"isTestDisableBackgroundJobs\")\n    val butEnableJanitor = getBoolOrFalse(\"isTestEnableJanitor\")\n    if (disableJobs) {\n      val butJanitor = if (butEnableJanitor) \", except for the Janitor\" else \", incl the Janitor\"\n      logger.info(s\"Is test with background jobs disabled$butJanitor. [EsM6JY0K2]\")\n    }\n    (disableJobs, butEnableJanitor)\n  }\n\n  def isInitialized: Boolean = (_state ne null) && _state.isGood\n\n  @volatile private var _state: State Or Option[Exception] = _\n\n  private def state: State = {\n    if (_state eq null) {\n      throw new NoStateError()\n    }\n    // Errors thrown here will be shown in the browser. Admin friendly :-)\n    _state match {\n      case Good(state) => state\n      case Bad(anyException) =>\n        logger.warn(\"Accessing state before it's been created. I'm still trying to start.\")\n        throw anyException getOrElse StillConnectingException\n    }\n  }\n\n\n  @volatile var killed = false\n  @volatile var shallStopStuff = false\n\n  // 5 seconds sometimes in a test \u2014> \"\"\"\n  // debiki.RateLimiterSpec *** ABORTED ***\n  // Futures timed out after [5 seconds]\n  // \"\"\"\n  // (in that case, all tests went fine, but couldn't shutdown the test server quickly enough)\n  val ShutdownTimeout: FiniteDuration = 10.seconds\n\n  /** For now (forever?), ignore platforms that don't send Linux signals.\n    */\n  sun.misc.Signal.handle(new sun.misc.Signal(\"TERM\"), new sun.misc.SignalHandler () {\n    def handle(signal: sun.misc.Signal): Unit = {\n      logger.info(\"Got SIGTERM, exiting with status 0 [EsMSIGTERM]\")\n      killed = true\n      System.exit(0)  // doing this here instead of [9KYKW25] although leaves PID file [65YKFU02]\n    }\n  })\n\n  sun.misc.Signal.handle(new sun.misc.Signal(\"INT\"), new sun.misc.SignalHandler () {\n    def handle(signal: sun.misc.Signal): Unit = {\n      logger.info(\"Got SIGINT, exiting with status 0 [EsMSIGINT]\")\n      killed = true\n      System.exit(0)  // doing this here instead of [9KYKW25] although leaves PID file [65YKFU02]\n    }\n  })\n\n\n  val metricRegistry = new metrics.MetricRegistry()\n  val mostMetrics = new MostMetrics(metricRegistry)\n\n  val talkyardVersion: String = {\n    // Placed here by docker-compose.yml, in dev builds, and the Dockerfile, in prod builds.\n    // [Scala_213] Using(...) { ... }\n    var source: scala.io.Source = null\n    try {\n      source = scala.io.Source.fromFile(\"/opt/talkyard/app/version.txt\")(scala.io.Codec.UTF8)\n      source.mkString.trim\n    }\n    finally {\n      if (source ne null) source.close()\n    }\n  }\n\n  // Could rename to \"rendererVersion\".\n  val applicationVersion = \"0.00.77\"  // later, read from some build config file\n\n  def applicationSecret: String = _appSecret\n\n  private var _appSecret: String = _\n\n  private def reloadAppSecret(): Unit = {\n    _appSecret = conf.getOptional[String](AppSecretConfValName).orElse(\n      conf.getOptional[String](\"play.crypto.secret\")).noneIfBlank.getOrDie(\n      s\"Config value '$AppSecretConfValName' missing [EdENOAPPSECRET]\")\n  }\n\n\n  /** Lets people do weird things, namely fake their ip address (&fakeIp=... url param)\n    * in order to create many e2e test sites \u2014 also in prod mode, for smoke tests.\n    * The e2e test sites will have ids like {{{test__...}}} so that they can be deleted safely.\n    */\n\n  val e2eTestPassword: Option[String] = getStringNoneIfBlank(\"talkyard.e2eTestPassword\")\n\n  /** Lets people do some forbidden things, like creating a site with a too short\n    * local hostname.\n    */\n  val forbiddenPassword: Option[String] = getStringNoneIfBlank(\"talkyard.forbiddenPassword\")\n\n  /** Maybe later, let individual sites require longer passwords. This conf val will then be the\n    * minimum length, for all sites. (So server admins can require a min length they're ok with.)\n    * 8 = rather low, but zxcvbn helpfully blocks really bad 8 char passwords like \"password\".\n    * 10 = can be good passwords.\n    */\n  val minPasswordLengthAllSites: Int =\n    conf.getOptional[Int](\"talkyard.minPasswordLength\") match {\n      case None =>\n        AllSettings.MinPasswordLengthHardcodedDefault\n      case Some(length) =>\n        dieIf(length < AllSettings.HardMinPasswordLength, \"TyE2WKG7\",\n          \"I refuse to start: Min password length is less than 8 chars; that's too easy to crack. Bye.\")\n        length\n    }\n\n  val mayFastForwardTime: Boolean =\n    if (!isProd) true\n    else getBoolOrFalse(\"talkyard.mayFastForwardTime\")\n\n  def systemDao: SystemDao = state.systemDao  // [rename] to newSystemDao()?\n\n\n  def siteDao(siteId: SiteId): SiteDao =  // RENAME [rename] to newSiteDao?\n    state.siteDaoFactory.newSiteDao(siteId)\n\n\n  def redisClient: RedisClient = state.redisClient\n\n\n  def sendEmail(email: Email, siteId: SiteId): Unit = {\n    state.mailerActorRef ! (email, siteId)\n  }\n\n  def sendEmails(emails: Iterable[Email], siteId: SiteId): Unit = {\n    COULD_OPTIMIZE // send just one message with all emails to send.\n    emails foreach { email =>\n      sendEmail(email, siteId)\n    }\n  }\n\n  def endToEndTestMailer: ActorRef = state.mailerActorRef\n  def spamCheckActor: Option[ActorRef] = state.spamCheckActorRef\n\n  def renderPageContentInBackground(\n        sitePageId: SitePageId, customParams: Option[PageRenderParamsAndHash]): Unit = {\n    if (!isTestDisableBackgroundJobs) {\n      state.renderContentActorRef ! (sitePageId, customParams)\n    }\n  }\n\n  /** Good to stop it, when importing sites via JSON, so can avoid PostgreSQL serialization\n    * failures. Later: One single actor for all database writes? + message passing. [one-db-writer]\n    */\n  def pauseAutoBackgorundRenderer3Seconds(): Unit = {\n    if (isTestDisableBackgroundJobs) return\n    state.renderContentActorRef ! RenderContentService.PauseThreeSeconds\n  }\n\n  def spamChecker: SpamChecker = state.spamChecker\n\n  /** Is non-zero iff server maintenance is going on, so that the server is read-only.\n    * Should be set to the Unix second when one thinks the maintenance will be done,\n    * or to 1 if one isn't sure. A change requires a Play app server restart to get picked up.\n    */\n  val maintWorkUntilSecs: Option[Long] = conf.getOptional[Long](\"talkyard.maintenanceUntilUnixSeconds\")\n\n  /* Add configurable support email address?  [CONFADDRS]\n  val supportEmailAddress: Option[String] =\n    getStringNoneIfBlank(\"talkyard.supportEmailAddress\") */\n\n  val securityComplaintsEmailAddress: Option[String] =\n    getStringNoneIfBlank(\"talkyard.securityComplaintsEmailAddress\")\n\n\n  /** Either exactly all sites uses HTTPS, or all of them use HTTP.\n    * A mixed configuration makes little sense I think:\n    * 1) On the public internet, obviously HTTPS should be used, always.\n    * 2) On an intranet, HTTP might be okay. And HTTPS. But not a combination of HTTP and HTTPS:\n    *   a) What about an intranet with some sites using HTTPS and some using HTTPS?\n    *     Then the organization would setup a Certificate Authority, install\n    *     certs in the members' browsers, but then uses them only sometimes, for some\n    *     sites? Why? That seems weird. Supporting this seems like not-well-spent-time.\n    *   b) What about sites that are accessible over HTTP on the intranet and HTTPS\n    *     on the public Internet? Then email links will break (they'll use either http or https).\n    *   c) What about some sites accessible only over HTTP on an intranet,\n    *     and others accessible only on the public Internet over HTTPS?\n    *     Then some firewall has to block access to the HTTP sites from the public internet.\n    *     Seems like a risky and unusual configuration. Not well spent time.\n    *     They might as well use two servers instead, one for the public internet,\n    *     one internally?\n    * -->\n    *  Either HTTP for all sites (assuming a trusted intranet), or HTTPS for all sites.\n    */\n  val secure: Boolean =\n    conf.getOptional[Boolean](\"talkyard.secure\") getOrElse {\n      logger.info(\"Config value 'talkyard.secure' missing; defaulting to true. [DwM3KEF2]\")\n      true\n    }\n\n\n  lazy val (anyLoginOrigin, loginOriginConfigErrorMessage): (Option[String], Option[String]) =\n    if (isOrWasTest) {\n      // The base domain should have been automatically configured with the test server's\n      // listen port.\n      (Some(s\"$scheme://$baseDomainWithPort\"), None)\n    }\n    else {\n      val anyOrigin = conf.getOptional[String](LoginOriginConfValName) orElse {\n        defaultSiteHostname map { hostname =>\n          s\"$scheme://$hostname$colonPort\"\n        }\n      }\n      var anyError: Option[String] = None\n      anyOrigin foreach { origin =>\n        if (secure && !origin.startsWith(\"https:\")) {\n          anyError = Some(s\"Config value '$LoginOriginConfValName' does not start with 'https:'\")\n          logger.error(s\"Disabling OAuth: ${anyError.get}. It is: '$origin' [DwE6KW5]\")\n        }\n      }\n      (anyOrigin, anyError)\n    }\n\n\n  object socialLogin {\n    import com.mohiva.play.silhouette.impl.providers.{OAuth1Settings, OAuth2Settings}\n\n    val googleOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGoogle(confValName: String) = getConfValOrThrowDisabled(confValName, \"Google\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.google.authorizationURL\"),\n        accessTokenURL = getGoogle(\"silhouette.google.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"google\"),\n        clientID = getGoogle(\"silhouette.google.clientID\"),\n        clientSecret = getGoogle(\"silhouette.google.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.google.scope\"))\n    }\n\n    val facebookOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getFacebook(confValName: String) = getConfValOrThrowDisabled(confValName, \"Facebook\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.facebook.authorizationURL\"),\n        accessTokenURL = getFacebook(\"silhouette.facebook.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"facebook\"),\n        clientID = getFacebook(\"silhouette.facebook.clientID\"),\n        clientSecret = getFacebook(\"silhouette.facebook.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.facebook.scope\"))\n    }\n\n    val twitterOAuthSettings: OAuth1Settings Or ErrorMessage = goodOrError {\n      def getTwitter(confValName: String) = getConfValOrThrowDisabled(confValName, \"Twitter\")\n      OAuth1Settings(\n        requestTokenURL = getTwitter(\"silhouette.twitter.requestTokenURL\"),\n        accessTokenURL = getTwitter(\"silhouette.twitter.accessTokenURL\"),\n        authorizationURL = getTwitter(\"silhouette.twitter.authorizationURL\"),\n        callbackURL = makeRedirectUrl(\"twitter\").get,\n        consumerKey = getTwitter(\"silhouette.twitter.consumerKey\"),\n        consumerSecret = getTwitter(\"silhouette.twitter.consumerSecret\"))\n    }\n\n    val githubOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGitHub(confValName: String) = getConfValOrThrowDisabled(confValName, \"GitHub\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.github.authorizationURL\"),\n        accessTokenURL = getGitHub(\"silhouette.github.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"github\"),\n        apiURL = getStringNoneIfBlank(\"silhouette.github.apiURL\"),\n        clientID = getGitHub(\"silhouette.github.clientID\"),\n        clientSecret = getGitHub(\"silhouette.github.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.github.scope\"))\n    }\n\n    // rm\n    val gitlabOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getGitLab(confValName: String) = getConfValOrThrowDisabled(confValName, \"GitLab\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.gitlab.authorizationURL\"),\n        accessTokenURL = getGitLab(\"silhouette.gitlab.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"gitlab\"),\n        clientID = getGitLab(\"silhouette.gitlab.clientID\"),\n        clientSecret = getGitLab(\"silhouette.gitlab.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.gitlab.scope\"))\n    }\n\n    val linkedInOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getLinkedin(confValName: String) = getConfValOrThrowDisabled(confValName, \"LinkedIn\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.linkedin.authorizationURL\"),\n        accessTokenURL = getLinkedin(\"silhouette.linkedin.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"linkedin\"),\n        // These fields no longer available in LinkedIn's API v2, unless one somehow\n        // partners with LinkedIn;\n        //apiURL = Some(\"https://api.linkedin.com/v2/me?fields=id,first-name,last-name,formatted-name,picture-url,email-address&oauth2_access_token=%s\"),\n        // Also profilePicture results in an error.\n        // Instead:\n        apiURL = Some(\"https://api.linkedin.com/v2/me?fields=id,firstName,lastName&oauth2_access_token=%s\"),\n        clientID = getLinkedin(\"silhouette.linkedin.clientID\"),\n        clientSecret = getLinkedin(\"silhouette.linkedin.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.linkedin.scope\"))\n    }\n\n    // rm\n    val vkOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getVk(confValName: String) = getConfValOrThrowDisabled(confValName, \"VK\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.vk.authorizationURL\"),\n        accessTokenURL = getVk(\"silhouette.vk.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"vk\"),\n        clientID = getVk(\"silhouette.vk.clientID\"),\n        clientSecret = getVk(\"silhouette.vk.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.vk.scope\"))\n    }\n\n    // rm\n    val instagramOAuthSettings: OAuth2Settings Or ErrorMessage = goodOrError {\n      def getInstagram(confValName: String) = getConfValOrThrowDisabled(confValName, \"Instagram\")\n      OAuth2Settings(\n        authorizationURL = getStringNoneIfBlank(\"silhouette.instagram.authorizationURL\"),\n        accessTokenURL = getInstagram(\"silhouette.instagram.accessTokenURL\"),\n        redirectURL = makeRedirectUrl(\"instagram\"),\n        clientID = getInstagram(\"silhouette.instagram.clientID\"),\n        clientSecret = getInstagram(\"silhouette.instagram.clientSecret\"),\n        scope = getStringNoneIfBlank(\"silhouette.instagram.scope\"))\n    }\n\n\n    private def goodOrError[A](block: => A): A Or ErrorMessage =\n      try Good(block)\n      catch {\n        case ex: QuickMessageException => Bad(ex.message)\n      }\n\n    private def getConfValOrThrowDisabled(confValName: String, providerName: String): String =\n      getStringNoneIfBlank(confValName) getOrElse {\n        throw new QuickMessageException(\n          s\"Login via $providerName not possible: Config value missing: $confValName [TyE0SOCIALCONF\")\n      }\n\n    private def makeRedirectUrl(provider: String): Option[String] = {\n      // A relative path which will be resolved against the current request's host.\n      // BUG?: seems Silhouette changes from https to http. So add origin ourselves:\n      val urlPath = controllers.routes.LoginWithOpenAuthController.finishAuthentication(provider).url\n      Some(anyLoginOrigin.getOrElse(\"\") + urlPath)\n    }\n  }\n\n\n  /** If secure=true, then prefix with 'https:', if absent (i.e. if only '//' specified),\n    * so a 'http:' embedded comments iframe parent base address (i.e. a <base href=...> elem)\n    * won't make us use http instead of https \u2014 that could break embedded comments when testing\n    * locally and embedding page = http://localhost/... .\n    */\n  val anyCdnOrigin: Option[String] =\n    config.cdn.origin.map(origin => {\n      if (origin.startsWith(\"https:\")) origin\n      else if (secure && origin.startsWith(\"//\")) \"https:\" + origin\n      else if (!secure) origin\n      else if (origin.startsWith(\"http:\")) {\n        die(\"EdEINSECCDNORIG\", o\"\"\"The server is configured to use https, but in the config file,\n            $CdnOriginConfValName is http://... (not https)\"\"\")\n      }\n      else {\n        die(\"EdEBADCDNORIG\", o\"\"\"In the config file, $CdnOriginConfValName is not http(s)\n            but something else weird.\"\"\")\n      }\n    })\n\n  def cdnOrSiteOrigin(siteHost: St): St =\n    anyCdnOrigin.getOrElse(schemeColonSlashSlash + siteHost)\n\n  val scheme: String = if (secure) \"https\" else \"http\"\n  def schemeColonSlashSlash: String = scheme + \"://\"\n\n  val port: Int = {\n    if (isOrWasTest) {\n      // Not on classpath: play.api.test.Helpers.testServerPort\n      // Instead, duplicate its implementation here:\n      sys.props.get(\"testserver.port\").map(_.toInt) getOrElse 19001\n    }\n    else {\n      conf.getOptional[Int](\"talkyard.port\") getOrElse {\n        if (secure) 443\n        else 80\n      }\n    }\n  }\n\n  def colonPort: String =\n    if (secure && port == 443) \"\"\n    else if (!secure && port == 80) \"\"\n    else s\":$port\"\n\n  val baseDomainNoPort: String =\n    if (isOrWasTest) \"localhost\"\n    else getStringNoneIfBlank(\"talkyard.baseDomain\") getOrElse \"localhost\"\n\n  val baseDomainWithPort: String =  // [CONFADDRS]\n    if (secure && port == 443) baseDomainNoPort\n    else if (!secure && port == 80) baseDomainNoPort\n    else s\"$baseDomainNoPort:$port\"\n\n\n  /** Accessing this hostname will return the default site, namely site 1 (or defaultSiteId,\n    * if configured.)\n    */\n  val defaultSiteHostname: Option[String] =\n    getStringNoneIfBlank(DefaultSiteHostnameConfValName)\n\n  if (defaultSiteHostname.exists(_ contains ':'))\n    logger.error(s\"Config value $DefaultSiteHostnameConfValName contains ':' [DwE4KUWF7]\")\n\n  val becomeFirstSiteOwnerEmail: Option[String] =\n    getStringNoneIfBlank(BecomeOwnerEmailConfValName)\n\n  val siteOwnerTermsUrl: Option[String] =\n    getStringNoneIfBlank(SiteOwnerTermsUrl)\n\n  val siteOwnerPrivacyUrl: Option[String] =\n    getStringNoneIfBlank(SiteOwnerPrivacyUrl)\n\n  /** If accessing the server via ip address, then, if no website with a matching ip has been\n    * configured in the database, we'll show the site with id 'defaultSiteId'. If not defined,\n    * we'll use FirstSiteId (i.e. 1, one).\n    */\n\n  val defaultSiteId: SiteId = getIntOrDefault(DefaultSiteIdConfValName, FirstSiteId)\n\n  /** New sites may be created only from this hostname. */\n  val anyCreateSiteHostname: Option[String] =\n    getStringNoneIfBlank(CreateSiteHostnameConfValName)\n  val anyCreateTestSiteHostname: Option[String] =\n    getStringNoneIfBlank(\"talkyard.createTestSiteHostname\")\n\n  val anyUploadsDir: Option[String] = {\n    val value = getStringNoneIfBlank(LocalhostUploadsDirConfValName)\n    val pathSlash = if (value.exists(_.endsWith(\"/\"))) value else value.map(_ + \"/\")\n    pathSlash match {\n      case None =>\n        Some(DefaultLocalhostUploadsDir)\n      case Some(path) =>\n        // SECURITY COULD test more dangerous dirs. Or whitelist instead?\n        if (path == \"/\" || path.startsWith(\"/etc/\") || path.startsWith(\"/bin/\")) {\n          logger.warn(o\"\"\"Config value $LocalhostUploadsDirConfValName specifies\n                a dangerous path: $path \u2014 file uploads disabled. [DwE0GM2]\"\"\")\n          None\n        }\n        else {\n          pathSlash\n        }\n    }\n  }\n\n  val anyPublicUploadsDir: Option[String] = anyUploadsDir.map(_ + \"public/\")\n\n  def settingsBySiteId(siteId: SiteId): AllSettings =\n    siteDao(siteId).getWholeSiteSettings()\n\n  def siteById(siteId: SiteId): Option[Site] =\n    systemDao.getSiteById(siteId)\n\n  def originOfSiteId(siteId: SiteId): Option[String] =\n    systemDao.getSiteById(siteId).flatMap(_.canonicalHostname.map(originOf))\n\n  def theHostnameOf(site: Site): String =\n    site.canonicalHostnameStr getOrElse siteByPubIdHostnamePort(site.pubId)\n\n  def theOriginOf(site: Site): String =\n    originOf(site) getOrElse siteByPubIdOrigin(site.pubId)\n\n  def originOf(site: Site): Option[String] = site.canonicalHostname.map(originOf)\n  def originOf(host: Hostname): String = originOf(host.hostname)\n  def originOf(hostOrHostname: String): String = {\n    val (hostname, colonPortParam) = hostOrHostname.span(_ != ':')\n    def portParam = colonPortParam drop 1\n    dieIf(colonPortParam.nonEmpty && colonPortParam != colonPort,\n      \"EdE47SK2\", o\"\"\"Bad port: $portParam. You're accessing the server via non-standard\n        port $portParam, but then you need to add config value `talkyard.port=$portParam`,\n        in file /opt/talkyard/conf/app/play.conf,\n        otherwise I won't know for sure which port to include in URLs I generate.\n        Also restart the app server for the new config to take effect:\n        sudo docker-compose restart web app\"\"\")\n    s\"$scheme://$hostname$colonPort\"\n  }\n  def originOf(request: p.mvc.RequestHeader): String = s\"$scheme://${request.host}\"\n\n  def originOf(request: GetRequest): String =\n    originOf(request.underlying)\n\n\n  def poweredBy = s\"https://www.talkyard.io\"\n\n\n  /** If a hostname matches this pattern, the site id can be extracted directly from the url.\n    */\n  val siteByIdHostnameRegex: Regex = {\n    // The hostname must be directly below the base domain, otherwise\n    // wildcard HTTPS certificates won't work: they cover 1 level below the\n    // base domain only, e.g. host.example.com but not sub.host.example.com,\n    // if the cert was issued for *.example.com.\n    s\"\"\"^$SiteByIdHostnamePrefix(.*)\\\\.$baseDomainNoPort$$\"\"\".r\n  }\n\n  def SiteByIdHostnamePrefix = \"site-\"\n\n  def siteByPubIdOrigin(pubId: PubSiteId): String =\n    s\"$scheme://${siteByPubIdHostnamePort(pubId)}\"\n\n  def siteByIdOrigin(siteId: SiteId): String =\n    s\"$scheme://${siteByIdHostnamePort(siteId)}\"\n\n  // [Scala_3]  can replace the two below with just one:  `siteId: SiteId | PubSiteId`.\n  // And the two ...By..Origin above too.\n\n  def siteByIdHostnamePort(siteId: SiteId): String =\n    s\"$SiteByIdHostnamePrefix$siteId.$baseDomainWithPort\"\n\n  def siteByPubIdHostnamePort(pubId: PubSiteId): String =\n    s\"$SiteByIdHostnamePrefix$pubId.$baseDomainWithPort\"\n\n\n  def pubSub: PubSubApi = state.pubSub\n  def strangerCounter: StrangerCounterApi = state.strangerCounter\n\n\n  /** Looks up a site by hostname, or directly by id.\n    *\n    * By id: If a HTTP request specifies a hostname like \"site-<id>.<baseDomain>\",\n    * for example:  site-123.example.com,\n    * then the site is looked up directly by id.\n    */\n  def lookupSiteOrThrow(request: RequestHeader): SiteBrief = {\n    // Nginx sends the host name in the Host header \u2014 not in the request line.\n    // (So, no need to use Play's request.host, which looks first in the request\n    // line for any Absolute-URI,  e.g.: 'https://example.com/url/path',  defined in RFC 3986\n    // https://tools.ietf.org/html/rfc3986#page-27\n    // \u2014 Nginx instead sends just  '/url/path' and the host in the Host header.)\n    // Later:\n    //val hostInHeader = request.headers.get(p_HeaderNames.HOST).getOrElse(\"\") //  [ngx_host_hdr]\n    // For now: (doesn't matter \u2014 this'll use the Host header anyway)\n    val hostInHeader = request.host\n    lookupSiteOrThrow(host = hostInHeader, request.uri)\n  }\n\n\n  def lookupSiteOrThrow(url: String): SiteBrief = {\n    val (scheme, separatorHostPathQuery) = url.span(_ != ':')\n    val (host, pathAndQuery) =\n      separatorHostPathQuery.drop(3).span(_ != '/') // drop(3) drops \"://\"\n    lookupSiteOrThrow(host = host, pathAndQuery)\n  }\n\n\n  private def lookupSiteOrThrow(host: String, pathAndQuery: String): SiteBrief = {\n    // Play supports one HTTP and one HTTPS port only, so it makes little sense\n    // to include any port number when looking up a site.\n    val hostname = if (host contains ':') host.span(_ != ':')._1 else host\n\n    def defaultSiteIdAndHostname = {\n      val hostname = defaultSiteHostname getOrElse throwForbidden(\n        \"EsE5UYK2\", o\"\"\"No site hostname configured (config value: $DefaultSiteHostnameConfValName)\"\"\")\n      if (defaultSiteId != FirstSiteId) {\n        val site = systemDao.getSiteById(defaultSiteId).getOrDie(\n          \"EdEDEFSITEID\", o\"\"\"There's no site with id $defaultSiteId, which is the configured\n            default site id (config value: $DefaultSiteIdConfValName)\"\"\")\n        SiteBrief(defaultSiteId, site.pubId, Some(hostname), site.status,\n              featureFlags = site.featureFlags)\n      }\n      else {\n        // Lazy-create the very first site, with id 1, if doesn't yet exist.\n        val firstSite = systemDao.getOrCreateFirstSite()\n        SiteBrief(FirstSiteId, firstSite.pubId, Some(hostname), firstSite.status,\n              featureFlags = firstSite.featureFlags)\n      }\n    }\n\n    if (defaultSiteHostname is hostname)\n      return defaultSiteIdAndHostname\n\n    // If the hostname is like \"site-123.example.com\" then we'll just lookup site id 123.\n    // Or if the id is long, like \"site-aabbcc112233.ex.com\" then we'll lookup by publ id aabb...33.\n    val SiteByIdRegex = siteByIdHostnameRegex // uppercase, otherwise Scala won't \"de-structure\".\n    hostname match {\n      case SiteByIdRegex(siteIdString: String) =>\n        val anySite =\n          if (siteIdString.length >= Site.MinPubSiteIdLength) {\n            systemDao.getSiteByPubId(siteIdString)\n          }\n          else {\n            SECURITY; PRIVACY // LATER, don't allow lookup by direct id, in prod mode,  [5UKFBQW2]\n            // because that'd let people find and crawl all sites hosted by this server\n            // (by crawling site-1, site-2, ...). And the server owners might not like that.\n            // (Access by publ site ids is ok though: they are long random strings, not sequential ids.)\n            // throwForbiddenIf(isProd && !okForbiddenPassword,\n            //    \"TyE4HJWQ10\", \"Looking up sites by private id is not allowed\")\n            val siteId = siteIdString.toIntOrThrow(\"EdE5PJW2\", s\"Bad site id: $siteIdString\")\n            systemDao.getSiteById(siteId)\n          }\n        anySite match {\n          case None =>\n            throwNotFound(\"DwE72SF6\", s\"No site with id $siteIdString\")\n          case Some(site: Site) =>\n            COULD // link to canonical host if (site.hosts.exists(_.role == SiteHost.RoleCanonical))\n            // Let the config file hostname have precedence over the database.\n            if (site.id == defaultSiteId && defaultSiteHostname.isDefined)\n              return site.brief.copy(hostname = defaultSiteHostname)\n            else\n              return site.brief\n        }\n      case _ =>\n    }\n\n    // Id unknown so we'll lookup the hostname instead.\n    val lookupResult = systemDao.lookupCanonicalHost(hostname) match {\n      case Some(result) =>\n        if (result.thisHost == result.canonicalHost)\n          result\n        else result.thisHost.role match {\n          case Hostname.RoleDuplicate =>\n            result\n          case Hostname.RoleRedirect =>\n            throwPermanentRedirect(originOf(result.canonicalHost.hostname) + pathAndQuery)\n          case Hostname.RoleLink =>\n            die(\"DwE2KFW7\", \"Not implemented: <link rel='canonical'>\")\n          case Hostname.RoleDeleted =>\n            die(\"TyEMAT752\", s\"Shouldn't have loaded deleted hostname: $result\")\n          case _ =>\n            die(\"DwE20SE4\")\n        }\n      case None =>\n        /* Not really needed. Better to use a real domain name.\n        if (Site.Ipv4AnyPortRegex.matches(hostname)) {\n          // Make it possible to access the server before any domain has been pointed\n          // to it, just after installation, by lazy-creating an empty default site.\n          return defaultSiteIdAndHostname\n        } */\n        throwSiteNotFound(\n          hostname, debugCode = \"LKPCANHOST\")\n    }\n    val site = systemDao.getSiteById(lookupResult.siteId) getOrDie \"EsE2KU503\"\n    site.brief\n  }\n\n\n  def startStuff(): Unit = {\n    if (_state ne null)\n      throw new jl.IllegalStateException(o\"\"\"Server already running, was it not properly\n        shut down last time? Please hit CTRL+C to kill it. [DwE83KJ9]\"\"\")\n\n    DeadlockDetector.ensureStarted()\n\n    // Let the server start, whilst we try to connect to services like the database and Redis.\n    // If we're unable to connect to a service, then we'll set _state to a\n    // developer / operations-team friendly error message about the service being\n    // inaccessible, and some tips about how troubleshoot this and how to start it.\n    // Whilst the state is being created, we'll show a message in any browser that\n    // the server is starting, please wait \u2014 to me, that's more user friendly than\n    // a blank page, in case this takes long.\n    val createStateFuture = Future {\n      tryCreateStateUntilKilled()\n    }\n\n    createStateFuture foreach { _ =>\n      logger.info(\"State created. [EsMSTATEREADY]\")\n    }\n\n    // When testing, never proceed before the server has started properly, or tests will fail (I think).\n    if (isOrWasTest) {\n      try {\n        Await.ready(createStateFuture, 99.seconds)\n        if (killed) {\n          logger.info(\"Killed. Bye. [EsMKILLED]\")\n          // Don't know how to tell Play to exit? Maybe might as well just:\n          System.exit(0)\n          // However this leaves a RUNNING_PID file. So the docker container deletes it\n          // before start, see docker/play-prod/Dockerfile [65YKFU02]  <\u2014 this was before,\n          //                                     when also Prod mode waited for the future.\n\n          // However this block won't run if we've started already. So exiting directly\n          // in the signal handler instea, right now, see [9KYKW25] above. Not sure why Play\n          // apparently ignores signals, once we've started (i.e. returned from this function).\n        }\n      }\n      catch {\n        case _: TimeoutException =>\n          logger.error(\"Creating state takes too long, something is amiss? [EsESTATESLOW]\")\n          System.exit(0)\n      }\n    }\n  }\n\n\n  private def tryCreateStateUntilKilled(): Unit = {\n    logger.info(\"Creating state.... [EdMCREATESTATE]\")\n    _state = Bad(None)\n    var firsAttempt = true\n\n    while (_state.isBad && !killed && !shallStopStuff) {\n      if (!firsAttempt) {\n        // Don't attempt to connect to everything too quickly, because then 100 MB log data\n        // with \"Error connecting to database ...\" are quickly generated.\n        Thread.sleep(4000)\n        if (killed || shallStopStuff) {\n          logger.info(killed ? \"Killed. Bye. [EsM200KILLED]\" |\n              \"Aborting create-state loop, shall stop stuff [EsMSTOPSTATE1]\")\n          return\n        }\n      }\n      firsAttempt = false\n      val cache = makeCache\n      try {\n        reloadAppSecret()\n        if (isProd && _appSecret == AppSecretDefVal)\n          throw AppSecretNotChangedException\n\n        logger.info(\"Connecting to database... [EsM200CONNDB]\")\n        val readOnlyDataSource = Debiki.createPostgresHikariDataSource(readOnly = true, conf, isOrWasTest)\n        val readWriteDataSource = Debiki.createPostgresHikariDataSource(readOnly = false, conf, isOrWasTest)\n        val rdb = new Rdb(readOnlyDataSource, readWriteDataSource)\n        val dbDaoFactory = new RdbDaoFactory(\n          rdb, ScalaBasedMigrations, getCurrentTime = now, cdnOrigin = anyCdnOrigin, isOrWasTest)\n\n        // Create any missing database tables before `new State`, otherwise State\n        // creates background threads that might attempt to access the tables.\n        logger.info(\"Running database migrations... [EsM200MIGRDB]\")\n        new SystemDao(dbDaoFactory, cache, this).applyEvolutions()\n\n        logger.info(\"Done migrating database. Connecting to other services... [EsM200CONNOTR]\")\n        val newState = new State(dbDaoFactory, cache)\n\n        if (isOrWasTest && conf.getOptional[Boolean](\"isTestShallEmptyDatabase\").contains(true)) {\n          logger.info(\"Emptying database... [EsM200EMPTYDB]\")\n          newState.systemDao.emptyDatabase()\n        }\n\n        _state = Good(newState)\n        logger.info(\"Done creating state [EsMSTATEOK]\")\n      }\n      catch {\n        case ex: com.zaxxer.hikari.pool.HikariPool.PoolInitializationException =>\n          _state = Bad(Some(new DatabasePoolInitializationException(ex)))\n        case ex @ AppSecretNotChangedException =>\n          logger.error(s\"Admin error: The admin hasn't edited '$AppSecretConfValName' [EdE2QCHP4]\", ex)\n          _state = Bad(Some(ex))\n        case ex @ StillConnectingException =>\n          logger.error(\"Bug: StillConnectingException [EdE3PG7FY1]\", ex)\n          _state = Bad(Some(ex))\n        case ex: Exception =>\n          logger.error(\"Unknown state creation error [EsE4GY67]\", ex)\n          _state = Bad(Some(ex))\n      }\n    }\n\n    if (killed || shallStopStuff) {\n      logger.info(\"Aborting create-state loop [EsMSTOPSTATE2]\")\n      return\n    }\n\n    // The render engines might be needed by some Java (Scala) evolutions.\n    // Let's create them in this parallel thread rather than blocking the whole server.\n    // (Takes 2? 5? seconds.)\n    edContext.nashorn.startCreatingRenderEngines()\n\n    if (!isTestDisableBackgroundJobs) {\n      actorSystem.scheduler.scheduleOnce(5.seconds, state.renderContentActorRef,\n          RenderContentService.RegenerateStaleHtml())(executionContext)\n    }\n\n    logger.info(\"Done creating rendering engines [EsMENGDONE]\")\n  }\n\n\n  def stopStuff(): Unit = {\n    // Play.start() first calls Play.stop(), so:\n    if (_state eq null)\n      return\n\n    if (_state.isBad) {\n      shallStopStuff = true\n    }\n    else {\n      if (isDevOrTest) {\n        // Could wait for this to complete, but doesn't matter \u2014 just dev & test.\n        logger.info(s\"Closing WebSockets ...\")\n        pubSub.closeWebSocketConnections()\n      }\n\n      // Shutdown the NotifierActor before the MailerActor, so no notifications\n      // are lost because the MailerActor was gone, couldn't send them.\n      logger.info(s\"Stopping the NotifierActor ...\")\n      val (name, future) = stopPlease(state.notifierActorRef)\n      Await.result(future, ShutdownTimeout)\n\n      // Shutdown in parallel.\n      logger.info(s\"Stopping remaining actors ...\")\n      val futureShutdownResults = Seq(\n            stopPlease(state.mailerActorRef),\n            stopPlease(state.renderContentActorRef),\n            stopPlease(state.indexerActorRef),\n            stopPlease(state.spamCheckActorRef),\n            stopPlease(state.janitorActorRef),\n            stopPlease(state.pubSubActorRef))\n\n      state.elasticSearchClient.close()\n      state.redisClient.quit()\n      state.dbDaoFactory.db.readOnlyDataSource.asInstanceOf[HikariDataSource].close()\n      state.dbDaoFactory.db.readWriteDataSource.asInstanceOf[HikariDataSource].close()\n      wsClient.close()\n\n      // Wait ... (Also see:\n      // https://stackoverflow.com/questions/16256279/how-to-wait-for-several-futures )\n      futureShutdownResults foreach { nameAndFutureResult =>\n        logger.info(s\"Waiting for ${nameAndFutureResult._1} to stop ...\")\n        Await.result(nameAndFutureResult._2, ShutdownTimeout)\n      }\n      logger.info(s\"All actors stopped\")\n    }\n\n    _state = null\n    timeStartMillis = None\n    timeOffsetMillis = 0\n\n    shutdownLogging()\n  }\n\n\n  private def stopPlease(anyActorRef: Option[ActorRef])\n        : (String, Future[Boolean]) = anyActorRef match {\n    case None => (\"None\", Future.successful(true))\n    case Some(ref) => stopPlease(ref)\n  }\n\n\n  private def stopPlease(actorRef: ActorRef): (String, Future[Boolean]) = {\n    logger.info(s\"Telling actor to stop: ${actorRef.path}\")\n    val future = gracefulStop(actorRef, ShutdownTimeout)\n    (actorRef.path.name, future)\n  }\n\n\n  def shutdownLogging(): Unit = {\n    // Flush any async log messages, just in case, so they won't get lost.\n    // See: https://logback.qos.ch/manual/configuration.html#stopContext\n    // and: https://github.com/logstash/logstash-logback-encoder/tree/logstash-logback-encoder-4.9\n    // this: \"\"\"In order to guarantee that logged messages have had a chance to be processed by\n    // the TCP appender, you'll need to cleanly shut down logback when your application exits.\"\"\"\n    import org.slf4j.LoggerFactory\n    import ch.qos.logback.classic.LoggerContext\n    // assume SLF4J is bound to logback-classic in the current environment\n    val loggerContext = LoggerFactory.getILoggerFactory.asInstanceOf[LoggerContext]\n    loggerContext.stop()\n  }\n\n\n  /** Caffeine is a lot faster than EhCache, and it doesn't have annoying problems with\n    * a singleton that causes weird classloader related errors on Play app stop-restart.\n    * (For a super large out-of-process survive-restarts cache, we use Redis not EhCache.)\n    */\n  private def makeCache: DaoMemCache = caffeine.cache.Caffeine.newBuilder()\n    .maximumWeight(10*1000)  // change to config value, e.g. 1e9 = 1GB mem cache. Default to 50M?\n    .weigher[String, DaoMemCacheAnyItem](new caffeine.cache.Weigher[String, DaoMemCacheAnyItem] {\n    override def weigh(key: String, value: DaoMemCacheAnyItem): Int = {\n      // For now. Later, use e.g. size of cached HTML page + X bytes for fixed min size?\n      // Can use to measure size: http://stackoverflow.com/a/30021105/694469\n      //   --> http://openjdk.java.net/projects/code-tools/jol/\n      1\n    }\n  }).build().asInstanceOf[DaoMemCache]\n\n\n  def now(): When = {\n    // [E2EBUG]: This won't work when running many e2e tests in parallel.\n    // But can make this work, by letting the time offset be per site.\n    val millisNow =\n      if (!isInitialized || !mayFastForwardTime) System.currentTimeMillis()\n      else {\n        val millisStart = timeStartMillis getOrElse System.currentTimeMillis()\n        millisStart + timeOffsetMillis\n      }\n    When.fromMillis(millisNow)\n  }\n\n  /** When running tests only. */\n  def testSetTime(when: When): Unit = {\n    timeStartMillis = Some(when.millis)\n    timeOffsetMillis = 0\n  }\n\n  /** When running tests only. */\n  def testFastForwardTimeMillis(millis: Long): Unit = {\n    timeOffsetMillis += millis\n  }\n\n  /** When running tests only. */\n  def testResetTime(): Unit = {\n    timeStartMillis = None\n    timeOffsetMillis = 0\n  }\n\n  @volatile\n  private var timeStartMillis: Option[Long] = None\n\n  @volatile\n  private var timeOffsetMillis: Long = 0\n\n\n  val loadGlobalAdminScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalAdminScript\")\n  val loadGlobalStaffScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalStaffScript\")\n  val loadGlobalAllScript: Boolean = getBoolOrFalse(\"talkyard.loadGlobalAllScript\")\n\n  /** Not needed any longer, after I ported to compile time dependency injection, with Play 2.6?\n    */\n  private class State(\n    val dbDaoFactory: RdbDaoFactory,\n    val cache: DaoMemCache) {\n\n    // Redis. (A Redis client pool makes sense if we haven't saturate the CPU on localhost, or\n    // if there're many Redis servers and we want to round robin between them. Not needed, now.)\n    val redisHost: ErrorMessage =\n      conf.getOptional[String](\"talkyard.redis.host\").noneIfBlank getOrElse \"localhost\"\n    val redisClient: RedisClient = RedisClient(host = redisHost)(actorSystem)\n\n    // Online user ids are cached in Redis so they'll be remembered accross server restarts,\n    // and will be available to all app servers. But we cache them again with more details here\n    // in-process mem too. (More details = we've looked up username etc in the database, but\n    // in Redis we cache only user ids.) Not for longer than a few seconds though,\n    // so that the online-users-json sent to the browsers on page load will be mostly up-to-date.\n    // (It'll get patched, later, via pubsub events. SHOULD implement this, otherwise\n    // race conditions can cause the online-users list in the browser to become incorrect.)\n    private val usersOnlineCache: UsersOnlineCache =\n      caffeine.cache.Caffeine.newBuilder()\n        .expireAfterWrite(3, TimeUnit.SECONDS)\n        .maximumSize(Int.MaxValue)\n        .build()\n        .asInstanceOf[UsersOnlineCache]\n\n    // ElasticSearch clients are thread safe. Their lifecycle should be the application lifecycle.\n    // (see https://discuss.elastic.co/t/is-nodeclient-thread-safe/4231/3 )\n    // (Later, could enable a certain 'client.transport.sniff' setting)\n    //\n    // old comment:\n    // The client might throw: org.elasticsearch.action.search.SearchPhaseExecutionException\n    // if the ElasticSearch database has not yet started up properly.\n    // If you wait for:\n    //   newClient.admin().cluster().prepareHealth().setWaitForGreenStatus().execute().actionGet()\n    // then the newClient apparently works fine \u2014\u00a0but waiting for that (once at\n    // server startup) takes 30 seconds, on my computer, today 2013-07-20.\n    //\n    val elasticSearchHost = \"search\"\n\n    val elasticSearchClient: es.client.transport.TransportClient =\n      new es.transport.client.PreBuiltTransportClient(es.common.settings.Settings.EMPTY)\n        .addTransportAddress(\n          new es.common.transport.TransportAddress(\n            jn.InetAddress.getByName(elasticSearchHost), 9300))\n\n    val siteDaoFactory = new SiteDaoFactory(\n      edContext, dbDaoFactory, redisClient, cache, usersOnlineCache, elasticSearchClient, config)\n\n    val mailerActorRef: ActorRef = MailerActor.startNewActor(actorSystem, siteDaoFactory, conf, now, isProd)\n\n    val notifierActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(\n        NotifierActor.startNewActor(executionContext, actorSystem, systemDao, siteDaoFactory))\n\n    def indexerBatchSize: Int = getIntOrDefault(\"talkyard.search.indexer.batchSize\", 100)\n    def indexerIntervalSeconds: Int = getIntOrDefault(\"talkyard.search.indexer.intervalSeconds\", 5)\n\n    val indexerActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(SearchEngineIndexer.startNewActor(\n          indexerBatchSize, indexerIntervalSeconds, executionContext,\n          elasticSearchClient, actorSystem, systemDao))\n\n    def spamCheckBatchSize: Int = getIntOrDefault(\"talkyard.spamcheck.batchSize\", 20)\n    def spamCheckIntervalSeconds: Int =\n      getIntOrDefault(\"talkyard.spamcheck.intervalSeconds\", if (isOrWasTest) 1 else 4)\n\n    val spamCheckActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs) None\n      else Some(SpamCheckActor.startNewActor(\n        spamCheckBatchSize, spamCheckIntervalSeconds, actorSystem, executionContext, systemDao))\n\n    // (Currently not in use, now with WebSocket ending in Play not in Nginx.)\n    val nginxHost: String =\n      conf.getOptional[String](\"talkyard.nginx.host\").noneIfBlank getOrElse \"localhost\"\n\n    val (pubSub, pubSubActorRef, strangerCounter) = PubSub.startNewActor(outer)\n\n    val renderContentActorRef: ActorRef =\n      RenderContentService.startNewActor(outer, edContext.nashorn)\n\n    val spamChecker = new SpamChecker(\n          config, isDevTest = isOrWasTest, siteById, originOfSiteId, settingsBySiteId,\n          executionContext, appLoaderContext.initialConfiguration, wsClient,\n          edContext.nashorn)\n\n    spamChecker.start()\n\n    val janitorActorRef: Option[ActorRef] =\n      if (isTestDisableBackgroundJobs && !isTestEnableJanitor) None\n      else Some(Janitor.startNewActor(outer))\n\n    def systemDao: SystemDao = new SystemDao(dbDaoFactory, cache, outer) // RENAME to newSystemDao()?\n\n  }\n\n}\n\n\nobject Config {\n  val CreateSitePath = \"talkyard.createSite\"\n  val SuperAdminPath = \"talkyard.superAdmin\"\n  val SuperAdminEmailAddressesPath = s\"$SuperAdminPath.emailAddresses\"\n  val DnsCnameTargetHostConfValName = \"talkyard.cnameTargetHost\"\n}\n\n\nclass Config(conf: play.api.Configuration) extends TyLogging {\n\n  import Globals._\n\n  // Dupl [305926XFG24] -------------------\n  private def getIntOrDefault(confName: String, default: Int): Int =\n    conf.getOptional[Int](confName) getOrElse default\n\n  private def getF64OrDefault(confName: St, default: f64): f64 =\n    conf.getOptional[f64](confName) getOrElse default\n\n  private def getBoolOrDefault(confName: String, default: Boolean): Boolean =\n    conf.getOptional[Boolean](confName) getOrElse default\n\n  private def getStringOrEmpty(confName: String): String =\n    getStringOrDefault(confName, \"\")\n\n  private def getStringOrDefault(confName: String, default: String): String =\n    conf.getOptional[String](confName).trimNoneIfBlank getOrElse default\n  // --------------------------------------\n\n  val useServiceWorker: Boolean = getBoolOrDefault(\"talkyard.useServiceWorker\", default = true)\n\n  val maxWebSocketConnectionsAllSitesTotal: Int =\n    getIntOrDefault(\"talkyard.maxWebSockets\", 200)\n\n  // Remove these later \u2014 just for now, new feature switches.\n  // Don't set to true just yet \u2014 Apple iOS 12 handles None as Strict,\n  // that seems really bad?\n  val sameSiteNone: Boolean = getBoolOrDefault(\"talkyard.sameSiteNone\", default = false)\n  val sameSiteLax: Boolean = getBoolOrDefault(\"talkyard.sameSiteLax\", default = false)\n\n  val autoPurgeDelayDays: Opt[f64] =\n    conf.getOptional[f64](\"talkyard.autoPurgeDelayDays\")\n\n\n  CLEAN_UP; REMOVE // use  ffMayPatchSite  instead\n  private val mayPatchSiteIds: String = \",\" + getStringOrEmpty(\"talkyard.mayPatchSiteIds\") + \",\"\n  def mayPatchSite(siteId: SiteId): Boolean =\n    siteId == FirstSiteId ||                        // <\u2014\u2014 people's self hosted installations, fine\n      includesSiteId(mayPatchSiteIds, siteId)       // <\u2014\u2014 talkyard.net \u2014 restricted\n\n  private def includesSiteId(value: St, siteId: SiteId): Bo =\n    value.contains(\",\" + siteId + \",\")\n\n  val mayImportSite: Boolean = getBoolOrDefault(\"talkyard.mayImportSite\", default = false)\n  val maxImportDumpBytes: Int = getIntOrDefault(\"talkyard.maxImportDumpBytes\", default = 50*1000*1000)\n\n  val oneTimeSecretSecondsToLive: Long = getIntOrDefault(\n    \"talkyard.oneTimeSecretSecondsToLive\",\n    // Typically, the subsequent steps will be automatic, by the browser [306KUD244],\n    // so we can set a short expire time (no need to wait for the human to do\n    // anything). In dev mode though, allow time for debugging & breakpoints.\n    // Short time-to-live is good, mitigates session fixation attacks?\n    // Maybe just 15 seconds would be better? Let's wait with that.\n    default = if (Globals.isProd) 30 else 30 * 60).toLong\n\n  // Or use sites_t.feature_flags_c for the superadmin site instead?\n  val featureFlags: St = { // Map[String, FeatureOnOff] = {\n    conf.getOptional[St](\"talkyard.featureFlags\") getOrElse \"\"\n  }\n\n  val isTestDisableRateLimits: Boolean = {\n    val disable = getBoolOrDefault(\"talkyard.isTestDisableRateLimits\", default = false)\n    if (disable) {\n      logger.info(\"Is test with rate limits disabled. [TyM0RATELIM]\")\n    }\n    disable\n  }\n\n  val dnsCnameTargetHost: Option[String] =\n    conf.getOptional[String](Config.DnsCnameTargetHostConfValName).noneIfBlank\n\n  CLEAN_UP; REMOVE // this + the routes file entry [2KGLCQ4], use UploadsUrlBasePath instead only.\n  val uploadsUrlPath: String = controllers.routes.UploadsController.servePublicFile(\"\").url\n  require(uploadsUrlPath == ed.server.UploadsUrlBasePath, \"TyE2UKDU0\")\n\n  val maxGroupMentionNotfs: Int =\n    conf.getOptional[Int](MaxGroupMentionNotfsConfValName) getOrElse 25\n\n  val akismetApiKey: Option[String] =\n    conf.getOptional[String](\"talkyard.akismet.apiKey\").noneIfBlank orElse  // old name\n      conf.getOptional[String](\"talkyard.akismetApiKey\").noneIfBlank\n\n  // FOR NOW\n  val emailWebhooksApiSecret: Opt[St] =\n    conf.getOptional[St](\"talkyard.emailWebhooksApiSecret\").noneIfBlank\n\n  object uploads {\n    TESTS_MISSING // test that these conf vals work properly, by running UploadsDaoSpec twice,\n    // once with default values, once with 2 x higher values (people typically want to increase,\n    // not decrease, these limits).\n\n    private val p = \"talkyard.uploads.\"\n    // COULD make this configurable dynamically, per site, in the admin area, per site, too.\n    // The limits below, would then be a hard max, for each site, regardless of admin area settings.\n    //\n    // Hmm, no, instead, this can be a per group setting,  [more_pat_perms]\n    // configurable via: /-/groups/groupname.\n    // There's a whole site setting too, and that's the max-for-everyone setting.\n    // Also allowed upload types will be a per user/group setting, in addition\n    // to a site wide restriction.\n\n    val maxBytesPerDayMember: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerDayMember\", 10*Megabytes / 1000) * 1000\n\n    val maxBytesPerDayStaff: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerDayStaff\", 999*Megabytes / 1000) * 1000\n\n    val maxBytesPerWeekMember: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerWeekMember\", 25*Megabytes / 1000) * 1000\n\n    val maxBytesPerWeekStaff: Int =\n      getIntOrDefault(p + \"maxKiloBytesPerWeekStaff\", 999*Megabytes / 1000) * 1000\n\n    private val largeUploadsSiteIds: String =\n        \",\" + getStringOrEmpty(p + \"mayUploadLargeFilesSiteIds\") + \",\"\n    def mayUploadLargeFiles(siteId: SiteId): Bo =\n      siteId == FirstSiteId ||\n        includesSiteId(largeUploadsSiteIds, siteId)\n\n    val maxBytesLargeFile: i32 =\n      i64ToMinMaxI32(conf.getOptional[f64](p + \"maxMiBLargeFile\").map(mib => (mib * Mebibyte64).toLong)\n            .getOrElse(maxUploadSizeBytes)) // <\u2014 REMOVE change to 10 MiB, default?\n\n    val maxBytesSmallFile: i32 =\n      f64ToMinMaxI32(getF64OrDefault(p + \"maxMiBSmallFile\", default = 1) * Mebibyte64)\n\n    // Old, remove\n    // 2 values: 1 for whole server, absolute max all sites.\n    // 1 per site.  serverGlobalMaxUploadKb   and siteDefaultMaxUploadKb\n    // Or  maxUploadKbServerGlobal  and  maxUploadKbSiteDefault\n    // And admins can config their site's siteDefaultMaxFileKb\n    //   up to serverGlobalMaxFileKb?\n    private def maxUploadSizeBytes: i64 =\n      (conf.getOptional[i64](\"talkyard.uploads.maxKiloBytesPerFile\") orElse\n        conf.getOptional[i64](\"talkyard.uploads.maxKiloBytes\")).map(_ * Kibibyte64)\n            .getOrElse(3 * Mebibyte64)  // or 25 MiB? Nginx: TY_NGX_LIMIT_REQ_BODY_SIZE=25m\n  }\n\n  object cdn {\n    /** No trailing slash. */\n    val origin: Option[String] =\n      conf.getOptional[String](CdnOriginConfValName).map(_.dropRightWhile(_ == '/')).noneIfBlank\n\n    def uploadsUrlPrefix: Option[String] = origin.map(_ + uploadsUrlPath)\n  }\n\n  object createSite {\n    private def path = Config.CreateSitePath\n\n    REFACTOR; RENAME // to ...tooManyTryLaterUrl\n    val tooManyTryLaterPagePath: Option[String] = conf.getOptional[String](s\"$path.tooManyTryLaterPagePath\")\n\n    val maxSitesPerPerson: Int = getIntOrDefault(s\"$path.maxSitesPerIp\", 10)\n    val maxTestSitesPerPerson: Int = getIntOrDefault(s\"$path.maxTestSitesPerIp\", maxSitesPerPerson * 3)\n\n    val maxSitesTotal: Int = getIntOrDefault(s\"$path.maxSitesTotal\", 1000)\n    val maxTestSitesTotal: Int = getIntOrDefault(s\"$path.maxTestSitesTotal\", maxSitesTotal * 3)\n\n    REFACTOR; RENAME // Later: rename to ed.createSite.newSiteQuotaMBs?\n    def quotaLimitMegabytes(isForBlogComments: Boolean, isTestSite: Boolean): Option[Int] = {\n      val limitForRealSite =\n        if (!isForBlogComments) quotaLimitMegabytesForum\n        else {\n          quotaLimitMegabytesBlogComments orElse {\n            // Blogs are relatively small, so restrict them a bit more.\n            quotaLimitMegabytesForum.map(_ / 10)\n          }\n        }\n      val resultMaybeZero =\n        if (isTestSite) limitForRealSite.map(_ / 10)\n        else limitForRealSite\n      resultMaybeZero.map(Math.max(_, 1))\n    }\n\n    private val quotaLimitMegabytesForum: Option[Int] =\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytesForum\") orElse\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytes\")\n\n    private val quotaLimitMegabytesBlogComments: Option[Int] =\n      conf.getOptional[Int](\"talkyard.newSite.quotaLimitMegabytesBlogComments\")\n  }\n\n  object superAdmin {\n    private def path = Config.SuperAdminPath\n    val hostname: Option[String] = conf.getOptional[String](s\"$path.hostname\")\n    val siteIdString: Option[String] = conf.getOptional[String](s\"$path.siteId\")\n    val emailAddresses: immutable.Seq[String] =\n      conf.getOptional[String](Config.SuperAdminEmailAddressesPath) match {\n        case None => Nil\n        case Some(emails) => emails.split(',').map(_.trim).toVector\n      }\n  }\n\n\n}\n\n", "/**\n * Copyright (c) 2020 Kaj Magnus Lindberg\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage talkyard.server.api\n\nimport com.debiki.core._\nimport controllers.OkApiJson\nimport debiki.RateLimits\nimport ed.server.http._\nimport ed.server.auth.MayMaybe\nimport debiki.EdHttp._\nimport Prelude._\nimport debiki.dao.{LoadPostsResult, PageStuff, SiteDao}\nimport ed.server.{EdContext, EdController}\nimport javax.inject.Inject\nimport play.api.libs.json.{JsObject, JsValue, JsArray, Json}\nimport play.api.mvc.{Action, ControllerComponents, Result}\nimport talkyard.server.JsX\nimport org.scalactic.{Bad, ErrorMessage, Good, Or}\n\n\n/** The ListQuery API, see: (project root)/tests/e2e/pub-api.ts\n  */\nclass GetController @Inject()(cc: ControllerComponents, edContext: EdContext)\n  extends EdController(cc, edContext) {\n\n\n\n  def apiV0_get(): Action[JsValue] = PostJsonAction(  // [PUB_API]\n          RateLimits.ReadsFromDb, maxBytes = 2000) { request: JsonPostRequest =>\n    getThingsImpl(request)\n  }\n\n\n  private def getThingsImpl(request: JsonPostRequest): Result = {\n    import request.body\n    val pretty = (body \\ \"pretty\").asOpt[Bo].getOrElse(false)\n    val getQueryJson = (body \\ \"getQuery\").as[JsObject]\n    val anyGetWhat = (getQueryJson \\ \"getWhat\").asOpt[Ref]\n    throwUnimplementedIf(anyGetWhat.isNot(\"Pages\"),\n          \"TyE2R502MWD\", \"Can only get pages as of now; 'getWhat' must be 'Pages'\")\n    val refs = (getQueryJson \\ \"getRefs\").asOpt[Seq[Ref]] getOrElse Nil\n    getPagesImpl(request, refs, pretty = pretty)\n  }\n\n\n  private def getPagesImpl(request: JsonPostRequest, pageRefs: Seq[Ref], pretty: Bo)\n          : Result = {\n    import request.{dao, requester}\n\n    val authzCtx = dao.getForumAuthzContext(requester)\n\n    throwUnimplementedIf(pageRefs.size > 50,\n          \"TyE603MRT4\", \"Currently at most 50 at a time\")\n\n    def notFoundMsg(embUrl: St, pageId: PageId = NoPageId): St = {\n      s\"No page with that embedding url or discussion id: $embUrl\"\n    }\n\n    type PageRefAndId = (St, PageId)\n    val refsAndIds: Seq[PageRefAndId Or ErrMsg] = pageRefs map { ref: St =>\n      val refOrErr: St Or ErrMsg = parseRef(ref, allowParticipantRef = false) flatMap {\n        case ParsedRef.EmbeddingUrl(url) => Good(url)\n        case ParsedRef.DiscussionId(id) => Good(id)\n        case x => Bad(s\"Not an embedding url or discussion id: $x\")\n      }\n      refOrErr flatMap { ref: St =>\n        val anyPageId: Opt[PageId] = dao.getRealPageId(ref)\n        anyPageId match {\n          case Some(id) => Good((ref, id))\n          case None => Bad(notFoundMsg(ref))\n        }\n      }\n    }\n\n    val topicsOrErrs = refsAndIds map { refAndIdOrErr =>\n      refAndIdOrErr flatMap {\n        case (ref: St, pageId) => dao.getPagePathAndMeta(pageId) match {\n          case Some(page: PagePathAndMeta) =>\n            COULD_OPTIMIZE // will typically always be same cat, for emb cmts.\n            val categories = dao.getAncestorCategoriesRootLast(page.categoryId)\n            val may = ed.server.auth.Authz.maySeePage(\n                  page.meta,\n                  user = authzCtx.requester,\n                  groupIds = authzCtx.groupIdsUserIdFirst,\n                  pageMembers = Set.empty, // getAnyPrivateGroupTalkMembers(page.meta),\n                  catsRootLast = categories,\n                  tooManyPermissions = authzCtx.tooManyPermissions,\n                  // Embedded discussion topics are typically unlisted.\n                  maySeeUnlisted = true)\n           if (may == MayMaybe.Yes) Good(page)\n           else Bad(notFoundMsg(ref))  // or if dev/test: s\"Cannot find page $pageId\"\n          case None =>\n            Bad(notFoundMsg(ref))      // ... here too?  + err code\n        }\n      }\n    }\n\n    // Later, reuse?:\n    // ThingsFoundJson.makePagesFoundListResponse(topicsOrErrs, dao, pretty)\n    // For now:\n    // Typescript: SearchQueryResults, and ListQueryResults\n    val siteIdsOrigins = dao.theSiteIdsOrigins()\n    OkApiJson(Json.obj(\n          \"origin\" -> siteIdsOrigins.siteOrigin,\n          \"thingsOrErrs\" -> JsArray(\n            topicsOrErrs.map({\n              case Good(pagePathAndMeta) =>\n                Json.obj(\n                    \"numOpDoItVotes\" -> pagePathAndMeta.meta.numOrigPostDoItVotes,\n                    \"numOpDoNotVotes\" -> pagePathAndMeta.meta.numOrigPostDoNotVotes,\n                    \"numOpLikeVotes\" -> pagePathAndMeta.meta.numOrigPostLikeVotes,\n                    \"numTotRepliesVisible\" -> pagePathAndMeta.meta.numRepliesVisible)\n              case Bad(errMsg) =>\n                Json.obj(\"errMsg\" -> errMsg, \"errCode\" -> \"TyEPGNF\")\n            }))\n          ), pretty)\n  }\n\n}\n\n\n\n"], "filenames": ["appsv/server/debiki/Globals.scala", "appsv/server/talkyard/server/api/GetController.scala"], "buggy_code_start_loc": [803, 67], "buggy_code_end_loc": [809, 69], "fixing_code_start_loc": [804, 67], "fixing_code_end_loc": [810, 69], "type": "CWE-74", "message": "In Talkyard, versions v0.04.01 through v0.6.74-WIP-63220cb, v0.2020.22-WIP-b2e97fe0e through v0.2021.02-WIP-879ef3fe1 and tyse-v0.2021.02-879ef3fe1-regular through tyse-v0.2021.28-af66b6905-regular, are vulnerable to Host Header Injection. By luring a victim application-user to click on a link, an unauthenticated attacker can use the \u201cforgot password\u201d functionality to reset the victim\u2019s password and successfully take over their account.", "other": {"cve": {"id": "CVE-2021-25980", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-11-11T07:15:11.380", "lastModified": "2021-11-16T17:19:46.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Talkyard, versions v0.04.01 through v0.6.74-WIP-63220cb, v0.2020.22-WIP-b2e97fe0e through v0.2021.02-WIP-879ef3fe1 and tyse-v0.2021.02-879ef3fe1-regular through tyse-v0.2021.28-af66b6905-regular, are vulnerable to Host Header Injection. By luring a victim application-user to click on a link, an unauthenticated attacker can use the \u201cforgot password\u201d functionality to reset the victim\u2019s password and successfully take over their account."}, {"lang": "es", "value": "En Talkyard, las versiones v0.04.01 hasta v0.6.74-WIP-63220cb, versiones v0.2020.22-WIP-b2e97fe0e hasta v0.2021.02-WIP-879ef3fe1 y versiones tyse-v0.2021.02-879ef3fe1-regular hasta tyse-v0.2021.28-af66b6905-regular, son vulnerables a una inyecci\u00f3n de encabezados de host. Atrayendo a un usuario de la aplicaci\u00f3n v\u00edctima para que haga clic en un enlace, un atacante no autenticado puede usar la funcionalidad \"forgot password\" para restablecer la contrase\u00f1a de la v\u00edctima y hacerse con su cuenta"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:talkyard:talkyard:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.04.01", "versionEndIncluding": "0.6.74-wip-63220cb", "matchCriteriaId": "C3AD90CD-FF57-4CA1-85B3-3EADB9159EB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:talkyard:talkyard:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.2020.22-wip-b2e97fe0e", "versionEndIncluding": "0.2021.02-wip-879ef3fe1", "matchCriteriaId": "74C594EE-CC21-4F19-9E76-AB4A2A5B8ACA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:talkyard:talkyard:*:*:*:*:*:*:*:*", "versionStartIncluding": "tyse-v0.2021.02-879ef3fe1-regular", "versionEndIncluding": "tyse-v0.2021.28-af66b6905-regular", "matchCriteriaId": "AE16449B-47FA-4F64-868C-056B170CAB0D"}]}]}], "references": [{"url": "https://github.com/debiki/talkyard/commit/4067e191a909ed06f250d09a40e43aa5edbb0289", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25980", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/debiki/talkyard/commit/4067e191a909ed06f250d09a40e43aa5edbb0289"}}