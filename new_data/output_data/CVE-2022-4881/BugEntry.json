{"buggy_code": ["\nlocal CL_LIMIT, CL_LIMIT_OVERRIDE, CL_NO_CLENGTH\n\nif CLIENT then\n\tCL_LIMIT = CreateConVar(\"pac_webcontent_limit\", \"-1\", {FCVAR_ARCHIVE}, \"webcontent limit, -1 = unlimited, 1024 = 1mb\")\n\tCL_NO_CLENGTH = CreateConVar(\"pac_webcontent_allow_no_content_length\", \"0\", {FCVAR_ARCHIVE}, \"allow downloads with no content length\")\n\tCL_LIMIT_OVERRIDE = CreateConVar(\"pac_webcontent_limit_force\", \"0\", {FCVAR_ARCHIVE}, \"Override serverside setting\")\nend\n\nlocal SV_LIMIT = CreateConVar(\"sv_pac_webcontent_limit\", \"-1\", CLIENT and {FCVAR_REPLICATED} or {FCVAR_ARCHIVE, FCVAR_REPLICATED}, \"webcontent limit, -1 = unlimited, 1024 = 1mb\")\nlocal SV_NO_CLENGTH = CreateConVar(\"sv_pac_webcontent_allow_no_content_length\", \"-1\", CLIENT and {FCVAR_REPLICATED} or {FCVAR_ARCHIVE, FCVAR_REPLICATED}, \"allow downloads with no content length\")\n\nfunction pac.FixGMODUrl(url)\n\t-- to avoid \"invalid url\" errors\n\t-- gmod does not allow urls containing \"10.\", \"172.16.\", \"192.168.\", \"127.\" or \"://localhost\"\n\t-- we escape 10. and 127. can occur (mydomain.com/model10.zip) and assume the server supports\n\t-- the escaped request\n\treturn url:Replace(\"10.\", \"%31%30%2e\"):Replace(\"127.\", \"%31%32%37%2e\")\nend\n\nlocal function http(method, url, headers, cb, failcb)\n\n\turl = pac.FixGMODUrl(url)\n\n\treturn HTTP({\n\t\tmethod = method,\n\t\turl = url,\n\t\theaders = headers,\n\t\tsuccess = function(code, data, headers)\n\t\t\tif code < 400 then\n\t\t\t\tcb(data, #data, headers)\n\t\t\telse\n\t\t\t\tlocal header = {}\n\t\t\t\tfor k,v in pairs(headers) do\n\t\t\t\t\ttable.insert(header, tostring(k) .. \": \" .. tostring(v))\n\t\t\t\tend\n\n\t\t\t\tlocal err = \"server returned code \" .. code .. \":\\n\\n\"\n\t\t\t\terr = err .. \"url: \"..url..\"\\n\"\n\t\t\t\terr = err .. \"================\\n\"\n\n\t\t\t\terr = err .. \"HEADER:\\n\"\n\t\t\t\terr = err .. table.concat(header, \"\\n\") .. \"\\n\"\n\n\t\t\t\terr = err .. \"================\\n\"\n\n\t\t\t\terr = err .. \"BODY:\\n\"\n\t\t\t\terr = err .. data .. \"\\n\"\n\n\t\t\t\terr = err .. \"================\\n\"\n\t\t\t\tfailcb(err, code >= 400, code)\n\t\t\tend\n\t\tend,\n\t\tfailed = function(err)\n\t\t\tif failcb then\n\t\t\t\tfailcb(\"_G.HTTP error: \" .. err)\n\t\t\telse\n\t\t\t\tpac.Message(\"_G.HTTP error: \" .. err)\n\t\t\tend\n\t\tend\n\t})\nend\n\nfunction pac.FixUrl(url)\n\turl = url:Trim()\n\n\tif url:find(\"dropbox\", 1, true) then\n\t\turl = url:gsub([[^http%://dl%.dropboxusercontent%.com/]], [[https://dl.dropboxusercontent.com/]])\n\t\turl = url:gsub([[^https?://dl.dropbox.com/]], [[https://www.dropbox.com/]])\n\t\turl = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]], [[https://dl.dropboxusercontent.com/s/%1]])\n\t\turl = url:gsub([[^https?://www.dropbox.com/s/(.+)$]], [[https://dl.dropboxusercontent.com/s/%1]])\n\t\treturn url\n\tend\n\n\tif url:find(\"drive.google.com\", 1, true) and not url:find(\"export=download\", 1, true) then\n\t\tlocal id =\n\t\t\turl:match(\"https://drive.google.com/file/d/(.-)/\") or\n\t\t\turl:match(\"https://drive.google.com/file/d/(.-)$\") or\n\t\t\turl:match(\"https://drive.google.com/open%?id=(.-)$\")\n\n\t\tif id then\n\t\t\treturn \"https://drive.google.com/uc?export=download&id=\" .. id\n\t\tend\n\t\treturn url\n\tend\n\n\tif url:find(\"gitlab.com\", 1, true) then\n\t\treturn url:gsub(\"^(https?://.-/.-/.-/)blob\", \"%1raw\")\n\tend\n\n\turl = url:gsub([[^http%://onedrive%.live%.com/redir?]],[[https://onedrive.live.com/download?]])\n\turl = url:gsub(\"pastebin.com/([a-zA-Z0-9]*)$\", \"pastebin.com/raw.php?i=%1\")\n\turl = url:gsub(\"github.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/\", \"github.com/%1/%2/raw/\")\n\n\treturn url\nend\n\nfunction pac.getContentLength(url, cb, failcb)\n\treturn http(\"HEAD\", url, {[\"Accept-Encoding\"] = \"none\"}, function(_, _, headers)\n\t\tlocal length\n\n\t\t-- server have rights to send headers in any case\n\t\tfor key, value in pairs(headers) do\n\t\t\tif string.lower(key) == \"content-length\" then\n\t\t\t\tlength = tonumber(value)\n\n\t\t\t\tif not length or math.floor(length) ~= length then\n\t\t\t\t\treturn failcb(string.format(\"malformed server reply with header content-length (got %q, expected valid integer number)\", value), true)\n\t\t\t\tend\n\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tif length then return cb(length) end\n\n\t\treturn pac.contentLengthFallback(url, cb, failcb)\n\tend, function(err, over400, code)\n\t\tif code == 405 then\n\t\t\treturn pac.contentLengthFallback(url, cb, failcb)\n\t\tend\n\n\t\treturn failcb(err, over400)\n\tend )\nend\n\n-- Performs a GET but requests 0 bytes\n-- We can then read the response headers to determine the content size.\n-- This allows Google Drive and other hosts to work with PAC even with content-length limits set\n-- (They typically block HEAD requests)\nfunction pac.contentLengthFallback(url, cb, failcb)\n\tlocal function fail()\n\t\treturn failcb(\"unable to determine content length\", true)\n\tend\n\n\treturn http(\"GET\", url, {[\"Range\"] = \"bytes=0-0\"}, function(data, data_length, headers)\n\t\t-- e.g. \"bytes 0-0/11784402\"\n\t\tlocal contentRange = headers[\"Content-Range\"]\n\t\tif not contentRange then return fail() end\n\n\t\tlocal spl = string.Split(contentRange, \"/\")\n\t\tlocal contentLength = spl[2]\n\n\t\tif contentLength then return cb(tonumber(contentLength)) end\n\n\t\treturn fail()\n\tend )\nend\n\nfunction pac.HTTPGet(url, cb, failcb)\n\tif not url or url:len() < 4 then\n\t\tfailcb(\"url length is less than 4 (\" .. tostring(url) .. \")\", true)\n\t\treturn\n\tend\n\n\turl = pac.FixUrl(url)\n\n\tlocal limit = SV_LIMIT:GetInt()\n\n\tif CLIENT and (CL_LIMIT_OVERRIDE:GetBool() or limit == -1) then\n\t\tlimit = CL_LIMIT:GetInt()\n\tend\n\n\tif limit == -1 then\n\t\treturn http(\"GET\", url, nil, cb, failcb)\n\tend\n\n\treturn pac.getContentLength(url, function(length)\n\t\tif length then\n\t\t\tif length <= (limit * 1024) then\n\t\t\t\thttp(\"GET\", url, nil, cb, failcb)\n\t\t\telse\n\t\t\t\tfailcb(\"download is too big (\" .. string.NiceSize(length) .. \")\", true)\n\t\t\tend\n\t\telse\n\t\t\tlocal allow_no_contentlength = SV_NO_CLENGTH:GetInt()\n\n\t\t\tif CLIENT and (CL_LIMIT_OVERRIDE:GetBool() or allow_no_contentlength < 0) then\n\t\t\t\tallow_no_contentlength = CL_NO_CLENGTH:GetInt()\n\t\t\tend\n\n\t\t\tif allow_no_contentlength > 0 then\n\t\t\t\thttp(\"GET\", url, nil, cb, failcb)\n\t\t\telse\n\t\t\t\tfailcb(\"unknown file size when allow_no_contentlength is \" .. allow_no_contentlength, true)\n\t\t\tend\n\t\tend\n\tend, failcb)\nend\n", "local urltex = {}\n\nurltex.TextureSize = 1024\nurltex.ActivePanel = urltex.ActivePanel or NULL\nurltex.Queue = urltex.Queue or {}\nurltex.Cache = urltex.Cache or {}\n\nconcommand.Add(\"pac_urltex_clear_cache\", function()\n\turltex.Cache = {}\n\turltex.Queue = {}\nend)\n\nif urltex.ActivePanel:IsValid() then\n\turltex.ActivePanel:Remove()\nend\n\nlocal enable = CreateClientConVar(\"pac_enable_urltex\", \"1\", true)\nlocal EMPTY_FUNC = function() end\nlocal function findFlag(url, flagID)\n\tlocal startPos, endPos = url:find(flagID)\n\tif not startPos then return url, false end\n\n\tif url:sub(endPos + 1, endPos + 1) == ' ' or url:sub(startPos - 1, startPos - 1) == ' ' then\n\t\turl = url:gsub(' ?' .. flagID .. ' ?', '')\n\t\treturn url, true\n\tend\n\n\treturn url, false\nend\n\nfunction urltex.GetMaterialFromURL(url, callback, skip_cache, shader, size, size_hack, additionalData)\n\tif size_hack == nil then\n\t\tsize_hack = true\n\tend\n\n\tadditionalData = additionalData or {}\n\tshader = shader or \"VertexLitGeneric\"\n\tif not enable:GetBool() then return end\n\tlocal noclampS, noclamp, noclampT\n\n\turl, noclampS = findFlag(url, 'noclamps')\n\turl, noclampT = findFlag(url, 'noclampt')\n\turl, noclamp = findFlag(url, 'noclamp')\n\n\tlocal urlAddress = url\n\tlocal urlIndex = url\n\n\tif noclamp then\n\t\turlIndex = urlIndex .. ' noclamp'\n\telseif noclampS then\n\t\turlIndex = urlIndex .. ' noclampS'\n\telseif noclampT then\n\t\turlIndex = urlIndex .. ' noclampT'\n\tend\n\n\tnoclamp = noclamp or noclampS and noclampT\n\n\tlocal renderTargetNeeded =\n\t\tnoclampS or\n\t\tnoclamp or\n\t\tnoclampT\n\n\tif isfunction(callback) and not skip_cache and urltex.Cache[urlIndex] then\n\t\tlocal tex = urltex.Cache[urlIndex]\n\t\tlocal mat = CreateMaterial(\"pac3_urltex_\" .. pac.Hash(), shader, additionalData)\n\t\tmat:SetTexture(\"$basetexture\", tex)\n\t\tcallback(mat, tex)\n\t\treturn\n\tend\n\n\tcallback = callback or EMPTY_FUNC\n\n\tif urltex.Queue[urlIndex] then\n\t\ttable.insert(urltex.Queue[urlIndex].callbacks, callback)\n\telse\n\t\turltex.Queue[urlIndex] = {\n\t\t\turl = urlAddress,\n\t\t\turlIndex = urlIndex,\n\t\t\tcallbacks = {callback},\n\t\t\ttries = 0,\n\t\t\tsize = size,\n\t\t\tsize_hack = size_hack,\n\t\t\tshader = shader,\n\t\t\tnoclampS = noclampS,\n\t\t\tnoclampT = noclampT,\n\t\t\tnoclamp = noclamp,\n\t\t\trt = renderTargetNeeded,\n\t\t\tadditionalData = additionalData\n\t\t}\n\tend\nend\n\nfunction urltex.Think()\n\tif not pac.IsEnabled() then return end\n\n\tif table.Count(urltex.Queue) > 0 then\n\t\tfor url, data in pairs(urltex.Queue) do\n\t\t\t-- when the panel is gone start a new one\n\t\t\tif not urltex.ActivePanel:IsValid() then\n\t\t\t\turltex.StartDownload(data.url, data)\n\t\t\tend\n\t\tend\n\t\turltex.Busy = true\n\telse\n\t\turltex.Busy = false\n\tend\nend\n\ntimer.Create(\"urltex_queue\", 0.1, 0, urltex.Think)\n\nfunction urltex.StartDownload(url, data)\n\tif urltex.ActivePanel:IsValid() then\n\t\turltex.ActivePanel:Remove()\n\tend\n\n\turl = pac.FixUrl(url)\n\tlocal size = data.size or urltex.TextureSize\n\tlocal id = \"urltex_download_\" .. url\n\tlocal pnl\n\tlocal frames_passed = 0\n\n\tlocal function createDownloadPanel()\n\t\tpnl = vgui.Create(\"DHTML\")\n\t\t-- Tested in PPM/2, this code works perfectly\n\t\tpnl:SetVisible(false)\n\t\tpnl:SetSize(size, size)\n\t\tpnl:SetHTML([[<html>\n\t\t\t\t<head>\n\t\t\t\t<style type=\"text/css\">\n\t\t\t\t\thtml\n\t\t\t\t\t{\n\t\t\t\t\t\toverflow:hidden;\n\t\t\t\t\t\t]] .. (data.size_hack and \"margin: -8px -8px;\" or \"margin: 0px 0px;\") .. [[\n\t\t\t\t\t}\n\t\t\t\t</style>\n\t\t\t\t<script>\n\t\t\t\t\twindow.onload = function() {\n\t\t\t\t\t\tsetInterval(function() {\n\t\t\t\t\t\t\tconsole.log('REAL_FRAME_PASSED');\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t};\n\t\t\t\t</script>\n\t\t\t\t</head>\n\n\t\t\t\t<body>\n\t\t\t\t\t<img src=\"]] .. url .. [[\" alt=\"\" width=\"]] .. size .. [[\" height=\"]] .. size .. [[\" />\n\t\t\t\t</body>\n\t\t\t</html>]])\n\n\t\tpnl:Refresh()\n\n\t\tfunction pnl:ConsoleMessage(msg)\n\t\t\tif msg == 'REAL_FRAME_PASSED' then\n\t\t\t\tframes_passed = frames_passed + 1\n\t\t\tend\n\t\tend\n\n\t\turltex.ActivePanel = pnl\n\tend\n\n\tlocal go = false\n\tlocal time = 0\n\tlocal timeoutNum = 0\n\tlocal think\n\n\tlocal function onTimeout()\n\t\ttimeoutNum = timeoutNum + 1\n\t\tif IsValid(pnl) then pnl:Remove() end\n\n\t\tif timeoutNum < 5 then\n\t\t\tpac.dprint(\"material download %q timed out.. trying again for the %ith time\", url, timeoutNum)\n\t\t\t-- try again\n\t\t\tgo = false\n\t\t\ttime = 0\n\t\t\tcreateDownloadPanel()\n\t\telse\n\t\t\tpac.dprint(\"material download %q timed out for good\", url, timeoutNum)\n\t\t\thook.Remove(\"Think\", id)\n\t\t\ttimer.Remove(id)\n\t\t\turltex.Queue[data.urlIndex] = nil\n\t\tend\n\tend\n\n\tfunction think()\n\t\t-- panel is no longer valid\n\t\tif not pnl:IsValid() then\n\t\t\tonTimeout()\n\t\t\treturn\n\t\tend\n\n\t\t-- give it some time.. IsLoading is sometimes lying, especially on chromium branch\n\t\tif not go and not pnl:IsLoading() then\n\t\t\ttime = pac.RealTime + 1\n\t\t\tgo = true\n\t\tend\n\n\t\tif go and time < pac.RealTime and frames_passed > 20 then\n\t\t\tpnl:UpdateHTMLTexture()\n\t\t\tlocal html_mat = pnl:GetHTMLMaterial()\n\n\t\t\tif html_mat then\n\t\t\t\tlocal crc = pac.Hash()\n\t\t\t\tlocal vertex_mat = CreateMaterial(\"pac3_urltex_\" .. crc, data.shader, data.additionalData)\n\t\t\t\tlocal tex = html_mat:GetTexture(\"$basetexture\")\n\t\t\t\ttex:Download()\n\t\t\t\tvertex_mat:SetTexture(\"$basetexture\", tex)\n\t\t\t\t-- tex:Download()\n\n\t\t\t\turltex.Cache[data.urlIndex] = tex\n\n\t\t\t\tpac.RemoveHook(\"Think\", id)\n\t\t\t\ttimer.Remove(id)\n\t\t\t\turltex.Queue[data.urlIndex] = nil\n\t\t\t\tlocal rt\n\n\t\t\t\tif data.rt then\n\t\t\t\t\tlocal textureFlags = 0\n\t\t\t\t\ttextureFlags = textureFlags + 4 -- clamp S\n\t\t\t\t\ttextureFlags = textureFlags + 8 -- clamp T\n\t\t\t\t\ttextureFlags = textureFlags + 16 -- anisotropic\n\t\t\t\t\ttextureFlags = textureFlags + 256 -- no mipmaps\n\t\t\t\t\t-- textureFlags = textureFlags + 2048 -- Texture is procedural\n\t\t\t\t\ttextureFlags = textureFlags + 32768 -- Texture is a render target\n\t\t\t\t\t-- textureFlags = textureFlags + 67108864 -- Usable as a vertex texture\n\n\t\t\t\t\tif data.noclamp then\n\t\t\t\t\t\ttextureFlags = textureFlags - 4\n\t\t\t\t\t\ttextureFlags = textureFlags - 8\n\t\t\t\t\telseif data.noclampS then\n\t\t\t\t\t\ttextureFlags = textureFlags - 4\n\t\t\t\t\telseif data.noclampT then\n\t\t\t\t\t\ttextureFlags = textureFlags - 8\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal vertex_mat2 = CreateMaterial(\"pac3_urltex_\" .. crc .. '_hack', 'UnlitGeneric', data.additionalData)\n\t\t\t\t\tvertex_mat2:SetTexture(\"$basetexture\", tex)\n\t\t\t\t\trt = GetRenderTargetEx(\"pac3_urltex_\" .. crc, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, textureFlags, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGB888)\n\t\t\t\t\trender.PushRenderTarget(rt)\n\t\t\t\t\trender.Clear(0, 0, 0, 255, false, false)\n\t\t\t\t\tcam.Start2D()\n\t\t\t\t\tsurface.SetMaterial(vertex_mat2)\n\t\t\t\t\tsurface.SetDrawColor(255, 255, 255)\n\t\t\t\t\tsurface.DrawTexturedRect(0, 0, size, size)\n\t\t\t\t\tcam.End2D()\n\t\t\t\t\trender.PopRenderTarget()\n\t\t\t\t\tvertex_mat:SetTexture('$basetexture', rt)\n\t\t\t\t\turltex.Cache[data.urlIndex] = rt\n\t\t\t\tend\n\n\t\t\t\ttimer.Simple(0, function()\n\t\t\t\t\tpnl:Remove()\n\t\t\t\tend)\n\n\t\t\t\tif data.callbacks then\n\t\t\t\t\tfor i, callback in pairs(data.callbacks) do\n\t\t\t\t\t\tcallback(vertex_mat, rt or tex)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tpac.AddHook(\"Think\", id, think)\n\n\t-- 5 sec max timeout, 5 maximal timeouts\n\ttimer.Create(id, 5, 5, onTimeout)\n\tcreateDownloadPanel()\nend\n\nreturn urltex"], "fixing_code": ["\nlocal CL_LIMIT, CL_LIMIT_OVERRIDE, CL_NO_CLENGTH\n\nif CLIENT then\n\tCL_LIMIT = CreateConVar(\"pac_webcontent_limit\", \"-1\", {FCVAR_ARCHIVE}, \"webcontent limit, -1 = unlimited, 1024 = 1mb\")\n\tCL_NO_CLENGTH = CreateConVar(\"pac_webcontent_allow_no_content_length\", \"0\", {FCVAR_ARCHIVE}, \"allow downloads with no content length\")\n\tCL_LIMIT_OVERRIDE = CreateConVar(\"pac_webcontent_limit_force\", \"0\", {FCVAR_ARCHIVE}, \"Override serverside setting\")\nend\n\nlocal SV_LIMIT = CreateConVar(\"sv_pac_webcontent_limit\", \"-1\", CLIENT and {FCVAR_REPLICATED} or {FCVAR_ARCHIVE, FCVAR_REPLICATED}, \"webcontent limit, -1 = unlimited, 1024 = 1mb\")\nlocal SV_NO_CLENGTH = CreateConVar(\"sv_pac_webcontent_allow_no_content_length\", \"-1\", CLIENT and {FCVAR_REPLICATED} or {FCVAR_ARCHIVE, FCVAR_REPLICATED}, \"allow downloads with no content length\")\n\nfunction pac.FixGMODUrl(url)\n\t-- to avoid \"invalid url\" errors\n\t-- gmod does not allow urls containing \"10.\", \"172.16.\", \"192.168.\", \"127.\" or \"://localhost\"\n\t-- we escape 10. and 127. can occur (mydomain.com/model10.zip) and assume the server supports\n\t-- the escaped request\n\treturn url:Replace(\"10.\", \"%31%30%2e\"):Replace(\"127.\", \"%31%32%37%2e\")\nend\n\nlocal function http(method, url, headers, cb, failcb)\n\n\turl = pac.FixGMODUrl(url)\n\n\treturn HTTP({\n\t\tmethod = method,\n\t\turl = url,\n\t\theaders = headers,\n\t\tsuccess = function(code, data, headers)\n\t\t\tif code < 400 then\n\t\t\t\tcb(data, #data, headers)\n\t\t\telse\n\t\t\t\tlocal header = {}\n\t\t\t\tfor k,v in pairs(headers) do\n\t\t\t\t\ttable.insert(header, tostring(k) .. \": \" .. tostring(v))\n\t\t\t\tend\n\n\t\t\t\tlocal err = \"server returned code \" .. code .. \":\\n\\n\"\n\t\t\t\terr = err .. \"url: \"..url..\"\\n\"\n\t\t\t\terr = err .. \"================\\n\"\n\n\t\t\t\terr = err .. \"HEADER:\\n\"\n\t\t\t\terr = err .. table.concat(header, \"\\n\") .. \"\\n\"\n\n\t\t\t\terr = err .. \"================\\n\"\n\n\t\t\t\terr = err .. \"BODY:\\n\"\n\t\t\t\terr = err .. data .. \"\\n\"\n\n\t\t\t\terr = err .. \"================\\n\"\n\t\t\t\tfailcb(err, code >= 400, code)\n\t\t\tend\n\t\tend,\n\t\tfailed = function(err)\n\t\t\tif failcb then\n\t\t\t\tfailcb(\"_G.HTTP error: \" .. err)\n\t\t\telse\n\t\t\t\tpac.Message(\"_G.HTTP error: \" .. err)\n\t\t\tend\n\t\tend\n\t})\nend\n\nfunction pac.FixUrl(url)\n\turl = url:Trim()\n\turl = url:gsub(\"[\\\"'<>\\n\\\\]+\", \"\")\n\n\tif url:find(\"dropbox\", 1, true) then\n\t\turl = url:gsub([[^http%://dl%.dropboxusercontent%.com/]], [[https://dl.dropboxusercontent.com/]])\n\t\turl = url:gsub([[^https?://dl.dropbox.com/]], [[https://www.dropbox.com/]])\n\t\turl = url:gsub([[^https?://www.dropbox.com/s/(.+)%?dl%=[01]$]], [[https://dl.dropboxusercontent.com/s/%1]])\n\t\turl = url:gsub([[^https?://www.dropbox.com/s/(.+)$]], [[https://dl.dropboxusercontent.com/s/%1]])\n\t\treturn url\n\tend\n\n\tif url:find(\"drive.google.com\", 1, true) and not url:find(\"export=download\", 1, true) then\n\t\tlocal id =\n\t\t\turl:match(\"https://drive.google.com/file/d/(.-)/\") or\n\t\t\turl:match(\"https://drive.google.com/file/d/(.-)$\") or\n\t\t\turl:match(\"https://drive.google.com/open%?id=(.-)$\")\n\n\t\tif id then\n\t\t\treturn \"https://drive.google.com/uc?export=download&id=\" .. id\n\t\tend\n\t\treturn url\n\tend\n\n\tif url:find(\"gitlab.com\", 1, true) then\n\t\treturn url:gsub(\"^(https?://.-/.-/.-/)blob\", \"%1raw\")\n\tend\n\n\turl = url:gsub([[^http%://onedrive%.live%.com/redir?]],[[https://onedrive.live.com/download?]])\n\turl = url:gsub(\"pastebin.com/([a-zA-Z0-9]*)$\", \"pastebin.com/raw.php?i=%1\")\n\turl = url:gsub(\"github.com/([a-zA-Z0-9_]+)/([a-zA-Z0-9_]+)/blob/\", \"github.com/%1/%2/raw/\")\n\n\treturn url\nend\n\nfunction pac.getContentLength(url, cb, failcb)\n\treturn http(\"HEAD\", url, {[\"Accept-Encoding\"] = \"none\"}, function(_, _, headers)\n\t\tlocal length\n\n\t\t-- server have rights to send headers in any case\n\t\tfor key, value in pairs(headers) do\n\t\t\tif string.lower(key) == \"content-length\" then\n\t\t\t\tlength = tonumber(value)\n\n\t\t\t\tif not length or math.floor(length) ~= length then\n\t\t\t\t\treturn failcb(string.format(\"malformed server reply with header content-length (got %q, expected valid integer number)\", value), true)\n\t\t\t\tend\n\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\n\t\tif length then return cb(length) end\n\n\t\treturn pac.contentLengthFallback(url, cb, failcb)\n\tend, function(err, over400, code)\n\t\tif code == 405 then\n\t\t\treturn pac.contentLengthFallback(url, cb, failcb)\n\t\tend\n\n\t\treturn failcb(err, over400)\n\tend )\nend\n\n-- Performs a GET but requests 0 bytes\n-- We can then read the response headers to determine the content size.\n-- This allows Google Drive and other hosts to work with PAC even with content-length limits set\n-- (They typically block HEAD requests)\nfunction pac.contentLengthFallback(url, cb, failcb)\n\tlocal function fail()\n\t\treturn failcb(\"unable to determine content length\", true)\n\tend\n\n\treturn http(\"GET\", url, {[\"Range\"] = \"bytes=0-0\"}, function(data, data_length, headers)\n\t\t-- e.g. \"bytes 0-0/11784402\"\n\t\tlocal contentRange = headers[\"Content-Range\"]\n\t\tif not contentRange then return fail() end\n\n\t\tlocal spl = string.Split(contentRange, \"/\")\n\t\tlocal contentLength = spl[2]\n\n\t\tif contentLength then return cb(tonumber(contentLength)) end\n\n\t\treturn fail()\n\tend )\nend\n\nfunction pac.HTTPGet(url, cb, failcb)\n\tif not url or url:len() < 4 then\n\t\tfailcb(\"url length is less than 4 (\" .. tostring(url) .. \")\", true)\n\t\treturn\n\tend\n\n\turl = pac.FixUrl(url)\n\n\tlocal limit = SV_LIMIT:GetInt()\n\n\tif CLIENT and (CL_LIMIT_OVERRIDE:GetBool() or limit == -1) then\n\t\tlimit = CL_LIMIT:GetInt()\n\tend\n\n\tif limit == -1 then\n\t\treturn http(\"GET\", url, nil, cb, failcb)\n\tend\n\n\treturn pac.getContentLength(url, function(length)\n\t\tif length then\n\t\t\tif length <= (limit * 1024) then\n\t\t\t\thttp(\"GET\", url, nil, cb, failcb)\n\t\t\telse\n\t\t\t\tfailcb(\"download is too big (\" .. string.NiceSize(length) .. \")\", true)\n\t\t\tend\n\t\telse\n\t\t\tlocal allow_no_contentlength = SV_NO_CLENGTH:GetInt()\n\n\t\t\tif CLIENT and (CL_LIMIT_OVERRIDE:GetBool() or allow_no_contentlength < 0) then\n\t\t\t\tallow_no_contentlength = CL_NO_CLENGTH:GetInt()\n\t\t\tend\n\n\t\t\tif allow_no_contentlength > 0 then\n\t\t\t\thttp(\"GET\", url, nil, cb, failcb)\n\t\t\telse\n\t\t\t\tfailcb(\"unknown file size when allow_no_contentlength is \" .. allow_no_contentlength, true)\n\t\t\tend\n\t\tend\n\tend, failcb)\nend\n", "local urltex = {}\n\nurltex.TextureSize = 1024\nurltex.ActivePanel = urltex.ActivePanel or NULL\nurltex.Queue = urltex.Queue or {}\nurltex.Cache = urltex.Cache or {}\n\nconcommand.Add(\"pac_urltex_clear_cache\", function()\n\turltex.Cache = {}\n\turltex.Queue = {}\nend)\n\nif urltex.ActivePanel:IsValid() then\n\turltex.ActivePanel:Remove()\nend\n\nlocal enable = CreateClientConVar(\"pac_enable_urltex\", \"1\", true)\nlocal EMPTY_FUNC = function() end\nlocal function findFlag(url, flagID)\n\tlocal startPos, endPos = url:find(flagID)\n\tif not startPos then return url, false end\n\n\tif url:sub(endPos + 1, endPos + 1) == ' ' or url:sub(startPos - 1, startPos - 1) == ' ' then\n\t\turl = url:gsub(' ?' .. flagID .. ' ?', '')\n\t\treturn url, true\n\tend\n\n\treturn url, false\nend\n\nfunction urltex.GetMaterialFromURL(url, callback, skip_cache, shader, size, size_hack, additionalData)\n\tif size_hack == nil then\n\t\tsize_hack = true\n\tend\n\n\tadditionalData = additionalData or {}\n\tshader = shader or \"VertexLitGeneric\"\n\tif not enable:GetBool() then return end\n\tlocal noclampS, noclamp, noclampT\n\n\turl, noclampS = findFlag(url, 'noclamps')\n\turl, noclampT = findFlag(url, 'noclampt')\n\turl, noclamp = findFlag(url, 'noclamp')\n\n\tlocal urlAddress = url\n\tlocal urlIndex = url\n\n\tif noclamp then\n\t\turlIndex = urlIndex .. ' noclamp'\n\telseif noclampS then\n\t\turlIndex = urlIndex .. ' noclampS'\n\telseif noclampT then\n\t\turlIndex = urlIndex .. ' noclampT'\n\tend\n\n\tnoclamp = noclamp or noclampS and noclampT\n\n\tlocal renderTargetNeeded =\n\t\tnoclampS or\n\t\tnoclamp or\n\t\tnoclampT\n\n\tif isfunction(callback) and not skip_cache and urltex.Cache[urlIndex] then\n\t\tlocal tex = urltex.Cache[urlIndex]\n\t\tlocal mat = CreateMaterial(\"pac3_urltex_\" .. pac.Hash(), shader, additionalData)\n\t\tmat:SetTexture(\"$basetexture\", tex)\n\t\tcallback(mat, tex)\n\t\treturn\n\tend\n\n\tcallback = callback or EMPTY_FUNC\n\n\tif urltex.Queue[urlIndex] then\n\t\ttable.insert(urltex.Queue[urlIndex].callbacks, callback)\n\telse\n\t\turltex.Queue[urlIndex] = {\n\t\t\turl = urlAddress,\n\t\t\turlIndex = urlIndex,\n\t\t\tcallbacks = {callback},\n\t\t\ttries = 0,\n\t\t\tsize = size,\n\t\t\tsize_hack = size_hack,\n\t\t\tshader = shader,\n\t\t\tnoclampS = noclampS,\n\t\t\tnoclampT = noclampT,\n\t\t\tnoclamp = noclamp,\n\t\t\trt = renderTargetNeeded,\n\t\t\tadditionalData = additionalData\n\t\t}\n\tend\nend\n\nfunction urltex.Think()\n\tif not pac.IsEnabled() then return end\n\n\tif table.Count(urltex.Queue) > 0 then\n\t\tfor url, data in pairs(urltex.Queue) do\n\t\t\t-- when the panel is gone start a new one\n\t\t\tif not urltex.ActivePanel:IsValid() then\n\t\t\t\turltex.StartDownload(data.url, data)\n\t\t\tend\n\t\tend\n\t\turltex.Busy = true\n\telse\n\t\turltex.Busy = false\n\tend\nend\n\ntimer.Create(\"urltex_queue\", 0.1, 0, urltex.Think)\n\nfunction urltex.StartDownload(url, data)\n\tif urltex.ActivePanel:IsValid() then\n\t\turltex.ActivePanel:Remove()\n\tend\n\n\turl = pac.FixUrl(url)\n\tlocal size = tonumber(data.size or urltex.TextureSize)\n\tlocal id = \"urltex_download_\" .. url\n\tlocal pnl\n\tlocal frames_passed = 0\n\n\tlocal function createDownloadPanel()\n\t\tpnl = vgui.Create(\"DHTML\")\n\t\t-- Tested in PPM/2, this code works perfectly\n\t\tpnl:SetVisible(false)\n\t\tpnl:SetSize(size, size)\n\t\tpnl:SetHTML([[<html>\n\t\t\t\t<head>\n\t\t\t\t<style type=\"text/css\">\n\t\t\t\t\thtml\n\t\t\t\t\t{\n\t\t\t\t\t\toverflow:hidden;\n\t\t\t\t\t\t]] .. (data.size_hack and \"margin: -8px -8px;\" or \"margin: 0px 0px;\") .. [[\n\t\t\t\t\t}\n\t\t\t\t</style>\n\t\t\t\t<script>\n\t\t\t\t\twindow.onload = function() {\n\t\t\t\t\t\tsetInterval(function() {\n\t\t\t\t\t\t\tconsole.log('REAL_FRAME_PASSED');\n\t\t\t\t\t\t}, 50);\n\t\t\t\t\t};\n\t\t\t\t</script>\n\t\t\t\t</head>\n\n\t\t\t\t<body>\n\t\t\t\t\t<img src=\"]] .. url .. [[\" alt=\"\" width=\"]] .. size .. [[\" height=\"]] .. size .. [[\" />\n\t\t\t\t</body>\n\t\t\t</html>]])\n\n\t\tpnl:Refresh()\n\n\t\tfunction pnl:ConsoleMessage(msg)\n\t\t\tif msg == 'REAL_FRAME_PASSED' then\n\t\t\t\tframes_passed = frames_passed + 1\n\t\t\tend\n\t\tend\n\n\t\turltex.ActivePanel = pnl\n\tend\n\n\tlocal go = false\n\tlocal time = 0\n\tlocal timeoutNum = 0\n\tlocal think\n\n\tlocal function onTimeout()\n\t\ttimeoutNum = timeoutNum + 1\n\t\tif IsValid(pnl) then pnl:Remove() end\n\n\t\tif timeoutNum < 5 then\n\t\t\tpac.dprint(\"material download %q timed out.. trying again for the %ith time\", url, timeoutNum)\n\t\t\t-- try again\n\t\t\tgo = false\n\t\t\ttime = 0\n\t\t\tcreateDownloadPanel()\n\t\telse\n\t\t\tpac.dprint(\"material download %q timed out for good\", url, timeoutNum)\n\t\t\thook.Remove(\"Think\", id)\n\t\t\ttimer.Remove(id)\n\t\t\turltex.Queue[data.urlIndex] = nil\n\t\tend\n\tend\n\n\tfunction think()\n\t\t-- panel is no longer valid\n\t\tif not pnl:IsValid() then\n\t\t\tonTimeout()\n\t\t\treturn\n\t\tend\n\n\t\t-- give it some time.. IsLoading is sometimes lying, especially on chromium branch\n\t\tif not go and not pnl:IsLoading() then\n\t\t\ttime = pac.RealTime + 1\n\t\t\tgo = true\n\t\tend\n\n\t\tif go and time < pac.RealTime and frames_passed > 20 then\n\t\t\tpnl:UpdateHTMLTexture()\n\t\t\tlocal html_mat = pnl:GetHTMLMaterial()\n\n\t\t\tif html_mat then\n\t\t\t\tlocal crc = pac.Hash()\n\t\t\t\tlocal vertex_mat = CreateMaterial(\"pac3_urltex_\" .. crc, data.shader, data.additionalData)\n\t\t\t\tlocal tex = html_mat:GetTexture(\"$basetexture\")\n\t\t\t\ttex:Download()\n\t\t\t\tvertex_mat:SetTexture(\"$basetexture\", tex)\n\t\t\t\t-- tex:Download()\n\n\t\t\t\turltex.Cache[data.urlIndex] = tex\n\n\t\t\t\tpac.RemoveHook(\"Think\", id)\n\t\t\t\ttimer.Remove(id)\n\t\t\t\turltex.Queue[data.urlIndex] = nil\n\t\t\t\tlocal rt\n\n\t\t\t\tif data.rt then\n\t\t\t\t\tlocal textureFlags = 0\n\t\t\t\t\ttextureFlags = textureFlags + 4 -- clamp S\n\t\t\t\t\ttextureFlags = textureFlags + 8 -- clamp T\n\t\t\t\t\ttextureFlags = textureFlags + 16 -- anisotropic\n\t\t\t\t\ttextureFlags = textureFlags + 256 -- no mipmaps\n\t\t\t\t\t-- textureFlags = textureFlags + 2048 -- Texture is procedural\n\t\t\t\t\ttextureFlags = textureFlags + 32768 -- Texture is a render target\n\t\t\t\t\t-- textureFlags = textureFlags + 67108864 -- Usable as a vertex texture\n\n\t\t\t\t\tif data.noclamp then\n\t\t\t\t\t\ttextureFlags = textureFlags - 4\n\t\t\t\t\t\ttextureFlags = textureFlags - 8\n\t\t\t\t\telseif data.noclampS then\n\t\t\t\t\t\ttextureFlags = textureFlags - 4\n\t\t\t\t\telseif data.noclampT then\n\t\t\t\t\t\ttextureFlags = textureFlags - 8\n\t\t\t\t\tend\n\n\t\t\t\t\tlocal vertex_mat2 = CreateMaterial(\"pac3_urltex_\" .. crc .. '_hack', 'UnlitGeneric', data.additionalData)\n\t\t\t\t\tvertex_mat2:SetTexture(\"$basetexture\", tex)\n\t\t\t\t\trt = GetRenderTargetEx(\"pac3_urltex_\" .. crc, size, size, RT_SIZE_NO_CHANGE, MATERIAL_RT_DEPTH_NONE, textureFlags, CREATERENDERTARGETFLAGS_UNFILTERABLE_OK, IMAGE_FORMAT_RGB888)\n\t\t\t\t\trender.PushRenderTarget(rt)\n\t\t\t\t\trender.Clear(0, 0, 0, 255, false, false)\n\t\t\t\t\tcam.Start2D()\n\t\t\t\t\tsurface.SetMaterial(vertex_mat2)\n\t\t\t\t\tsurface.SetDrawColor(255, 255, 255)\n\t\t\t\t\tsurface.DrawTexturedRect(0, 0, size, size)\n\t\t\t\t\tcam.End2D()\n\t\t\t\t\trender.PopRenderTarget()\n\t\t\t\t\tvertex_mat:SetTexture('$basetexture', rt)\n\t\t\t\t\turltex.Cache[data.urlIndex] = rt\n\t\t\t\tend\n\n\t\t\t\ttimer.Simple(0, function()\n\t\t\t\t\tpnl:Remove()\n\t\t\t\tend)\n\n\t\t\t\tif data.callbacks then\n\t\t\t\t\tfor i, callback in pairs(data.callbacks) do\n\t\t\t\t\t\tcallback(vertex_mat, rt or tex)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tpac.AddHook(\"Think\", id, think)\n\n\t-- 5 sec max timeout, 5 maximal timeouts\n\ttimer.Create(id, 5, 5, onTimeout)\n\tcreateDownloadPanel()\nend\n\nreturn urltex\n"], "filenames": ["lua/pac3/core/shared/http.lua", "lua/pac3/libraries/urltex.lua"], "buggy_code_start_loc": [65, 117], "buggy_code_end_loc": [65, 271], "fixing_code_start_loc": [66, 117], "fixing_code_end_loc": [67, 271], "type": "CWE-79", "message": "A vulnerability was found in CapsAdmin PAC3. It has been rated as problematic. Affected by this issue is some unknown functionality of the file lua/pac3/core/shared/http.lua. The manipulation of the argument url leads to cross site scripting. The attack may be launched remotely. The name of the patch is 8fc9e12dfa21d757be6eb4194c763e848b299ac0. It is recommended to apply a patch to fix this issue. VDB-217646 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2022-4881", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-08T13:15:10.047", "lastModified": "2023-01-12T20:10:12.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in CapsAdmin PAC3. It has been rated as problematic. Affected by this issue is some unknown functionality of the file lua/pac3/core/shared/http.lua. The manipulation of the argument url leads to cross site scripting. The attack may be launched remotely. The name of the patch is 8fc9e12dfa21d757be6eb4194c763e848b299ac0. It is recommended to apply a patch to fix this issue. VDB-217646 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pac3_project:pac3:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-07-13", "matchCriteriaId": "C1597D7A-DA18-40CB-9BDD-9133A18E3C88"}]}]}], "references": [{"url": "https://github.com/CapsAdmin/pac3/commit/8fc9e12dfa21d757be6eb4194c763e848b299ac0", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CapsAdmin/pac3/pull/1210", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217646", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.217646", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/CapsAdmin/pac3/commit/8fc9e12dfa21d757be6eb4194c763e848b299ac0"}}