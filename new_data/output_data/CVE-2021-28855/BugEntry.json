{"buggy_code": ["// This file is part of Deark.\n// Copyright (C) 2016 Jason Summers\n// See the file COPYING for terms of use.\n\n// Macintosh PICT graphics\n\n#include <deark-config.h>\n#include <deark-private.h>\n#include <deark-fmtutil.h>\nDE_DECLARE_MODULE(de_module_pict);\n\nstruct pict_point {\n\ti64 y, x;\n};\n\nstruct pict_rect {\n\ti64 t, l, b, r;\n};\n\nstruct detection_info {\n\tint file_version;\n\tint has_fileheader;\n};\n\ntypedef struct localctx_struct {\n\tstruct detection_info dti;\n\tint version; // 1 or 2: The version mode that the parser is currently using\n\tint is_extended_v2;\n\tint decode_qtif;\n\tdbuf *iccprofile_file;\n} lctx;\n\ntypedef int (*item_decoder_fn)(deark *c, lctx *d, i64 opcode, i64 data_pos,\n\ti64 *bytes_used);\n\nstruct opcode_info {\n\tu16 opcode;\n#define SZCODE_SPECIAL 0\n#define SZCODE_EXACT   1\n#define SZCODE_REGION  2\n#define SZCODE_POLYGON 3\n\tu16 size_code;\n\tu32 size; // Data size, not including opcode. Logic depends on size_code.\n\tconst char *name;\n\titem_decoder_fn fn;\n};\n\nstatic double pict_read_fixed(dbuf *f, i64 pos)\n{\n\ti64 n;\n\n\t// I think QuickDraw's \"Fixed point\" numbers are signed, but I don't know\n\t// how negative numbers are handled.\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\n// Read a QuickDraw Point. Caller supplies point struct.\nstatic void pict_read_point(dbuf *f, i64 pos,\n\tstruct pict_point *point, const char *dbgname)\n{\n\tpoint->y = dbuf_geti16be(f, pos);\n\tpoint->x = dbuf_geti16be(f, pos+2);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)\", dbgname, (int)point->x, (int)point->y);\n\t}\n}\n\n// Read a QuickDraw Rectangle. Caller supplies rect struct.\nstatic void pict_read_rect(dbuf *f, i64 pos,\n\tstruct pict_rect *rect, const char *dbgname)\n{\n\trect->t = dbuf_geti16be(f, pos);\n\trect->l = dbuf_geti16be(f, pos+2);\n\trect->b = dbuf_geti16be(f, pos+4);\n\trect->r = dbuf_geti16be(f, pos+6);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)-(%d,%d)\", dbgname, (int)rect->l, (int)rect->t,\n\t\t\t(int)rect->r, (int)rect->b);\n\t}\n}\n\nstatic int handler_RGBColor(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\tunsigned int clr16[3];\n\tu8 clr8[3];\n\tu32 clr;\n\tchar csamp[16];\n\ti64 pos = data_pos;\n\ti64 k;\n\n\tfor(k=0; k<3; k++) {\n\t\tclr16[k] = (unsigned int)de_getu16be_p(&pos);\n\t\tclr8[k] = (u8)(clr16[k]>>8);\n\t}\n\tclr = DE_MAKE_RGB(clr8[0], clr8[1], clr8[2]);\n\tde_get_colorsample_code(c, clr, csamp, sizeof(csamp));\n\tde_dbg(c, \"color: (0x%04x,0x%04x,0x%04x)%s\", clr16[0], clr16[1], clr16[2], csamp);\n\treturn 1;\n}\n\n// Version\nstatic int handler_11(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 ver;\n\n\t*bytes_used = 1;\n\tver = de_getbyte(data_pos);\n\tde_dbg(c, \"version: %d\", (int)ver);\n\n\tif(ver==2) {\n\t\td->version = 2;\n\t}\n\telse if(ver!=1) {\n\t\tde_err(c, \"Unsupported PICT version: %d\", (int)ver);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n// LongText\nstatic int handler_28(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\tde_ucstring *s = NULL;\n\tstruct pict_point pt;\n\n\tpict_read_point(c->infile, data_pos, &pt, \"txLoc\");\n\ttlen = (i64)de_getbyte(data_pos+4);\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+5, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\t*bytes_used = 5+tlen;\n\tucstring_destroy(s);\n\treturn 1;\n}\n\n// DVText\nstatic int handler_DxText(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\ti64 dx;\n\tde_ucstring *s = NULL;\n\n\tdx = (i64)de_getbyte(data_pos);\n\tde_dbg(c, \"%s: %d\", opcode==0x2a?\"dv\":\"dh\", (int)dx);\n\n\ttlen = (i64)de_getbyte(data_pos+1);\n\t*bytes_used = 2+tlen;\n\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+2, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\n\tucstring_destroy(s);\n\treturn 1;\n}\n\n// DHDVText\nstatic int handler_2b(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\ti64 dh, dv;\n\tde_ucstring *s = NULL;\n\n\tdh = (i64)de_getbyte(data_pos);\n\tdv = (i64)de_getbyte(data_pos+1);\n\tde_dbg(c, \"dh,dv: (%d,%d)\", (int)dh, (int)dv);\n\n\ttlen = (i64)de_getbyte(data_pos+2);\n\tde_dbg(c, \"text size: %d\", (int)tlen);\n\t*bytes_used = 3+tlen;\n\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+3, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\n\treturn 1;\n}\n\n// fontName\nstatic int handler_2c(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 n;\n\ti64 tlen;\n\ti64 id;\n\tde_ucstring *s = NULL;\n\n\tn = de_getu16be(data_pos);\n\t*bytes_used = 2+n;\n\tid = de_getu16be(data_pos+2);\n\tde_dbg(c, \"old font id: %d\", (int)id);\n\ttlen = (i64)de_getbyte(data_pos+4);\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+5, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"font name: \\\"%s\\\"\", ucstring_getpsz(s));\n\tucstring_destroy(s);\n\treturn 1;\n}\n\nstatic int handler_Rectangle(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\tstruct pict_rect rect;\n\n\tpict_read_rect(c->infile, data_pos, &rect, \"rect\");\n\treturn 1;\n}\n\n// final few bitmap header fields (18 bytes)\nstatic void read_src_dst_mode(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tstruct pict_rect tmprect;\n\ti64 n;\n\n\tde_dbg(c, \"src/dst/mode part of bitmap header, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpict_read_rect(c->infile, pos, &tmprect, \"srcRect\");\n\tpos += 8;\n\tpict_read_rect(c->infile, pos, &tmprect, \"dstRect\");\n\tpos += 8;\n\n\tn = de_getu16be(pos);\n\tde_dbg(c, \"transfer mode: %d\", (int)n);\n\t//pos += 2;\n\tde_dbg_indent(c, -1);\n}\n\n// Pre-scan the pixel data to figure out its size.\n// (We could instead scan and decode it at the same time, but error handling\n// would get really messy.)\n// Returns 0 on fatal error (if we could not even parse the data).\nstatic int get_pixdata_size(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\ti64 pos1, i64 *pixdata_size)\n{\n\ti64 pos;\n\ti64 j;\n\ti64 bytecount;\n\tint retval = 0;\n\n\tpos = pos1;\n\tde_dbg(c, \"PixData at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tif(bi->height<0 || bi->height>65535) {\n\t\tde_err(c, \"Invalid bitmap height (%d)\", (int)bi->height);\n\t\tgoto done;\n\t}\n\n\t// Make sure rowbytes is sane. We use it to decide how much memory to allocate.\n\t// Note: I've seen valid bitmaps with as many as 284 extra bytes per row.\n\tif(bi->rowbytes > (bi->npwidth * bi->pixelsize)/8 + 1000) {\n\t\tde_err(c, \"Bad rowBytes value (%d)\", (int)bi->rowbytes);\n\t\tgoto done;\n\t}\n\n\tif(bi->packing_type>=3 || (bi->packing_type==0 && bi->rowbytes>=8)) {\n\t\tfor(j=0; j<bi->height; j++) {\n\t\t\tif(bi->rowbytes > 250) {\n\t\t\t\tbytecount = de_getu16be(pos);\n\t\t\t\tpos+=2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytecount = (i64)de_getbyte(pos);\n\t\t\t\tpos+=1;\n\t\t\t}\n\t\t\tpos += bytecount;\n\t\t}\n\t}\n\telse if(bi->packing_type==1 || (bi->packing_type==0 && bi->rowbytes<8)) {\n\t\tpos += bi->rowbytes * bi->height; // uncompressed\n\t}\n\telse {\n\t\tde_err(c, \"Unsupported packing type: %d\", (int)bi->packing_type);\n\t\tgoto done;\n\t}\n\n\t*pixdata_size = pos - pos1;\n\tde_dbg(c, \"PixData size: %d\", (int)*pixdata_size);\n\tretval = 1;\n\ndone:\n\tde_dbg_indent(c, -1);\n\treturn retval;\n}\n\nstatic void decode_bitmap_rgb24(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 cr, cg, cb;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tcr = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+0)*bi->pdwidth + i);\n\t\t\tcg = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+1)*bi->pdwidth + i);\n\t\t\tcb = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+2)*bi->pdwidth + i);\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, DE_MAKE_RGB(cr,cg,cb));\n\t\t}\n\t}\n}\n\nstatic void decode_bitmap_rgb16(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 c0, c1; //, cg, cb;\n\tu32 clr;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tc0 = dbuf_getbyte(unc_pixels, j*bi->rowspan + i*2);\n\t\t\tc1 = dbuf_getbyte(unc_pixels, j*bi->rowspan + i*2+1);\n\t\t\tclr = ((u32)c0 << 8)|c1;\n\t\t\tclr = de_rgb555_to_888(clr);\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, clr);\n\t\t}\n\t}\n}\n\nstatic void decode_bitmap_paletted(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 b;\n\tu32 clr;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tb = de_get_bits_symbol(unc_pixels, bi->pixelsize, j*bi->rowspan, i);\n\t\t\tclr = bi->pal[(unsigned int)b];\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, clr);\n\t\t}\n\t}\n}\n\nstatic int decode_bitmap(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\ti64 j;\n\tdbuf *unc_pixels = NULL;\n\tde_bitmap *img = NULL;\n\tde_finfo *fi = NULL;\n\ti64 bytecount;\n\ti64 bitmapsize;\n\tint dst_nsamples;\n\tstruct de_dfilter_in_params dcmpri;\n\tstruct de_dfilter_out_params dcmpro;\n\tstruct de_dfilter_results dres;\n\n\tde_dfilter_init_objects(c, &dcmpri, &dcmpro, &dres);\n\n\tbi->rowspan = bi->rowbytes;\n\tif(bi->pixelsize==32 && bi->cmpcount==3 && bi->cmpsize==8) {\n\t\tbi->rowspan = (bi->rowbytes/4)*3;\n\t}\n\n\tbitmapsize = bi->height * bi->rowspan;\n\tunc_pixels = dbuf_create_membuf(c, bitmapsize, 1);\n\n\tdcmpri.f = c->infile;\n\tdcmpro.f = unc_pixels;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tif(bi->packing_type==1 || bi->rowbytes<8) {\n\t\t\tbytecount = bi->rowbytes;\n\t\t}\n\t\telse if(bi->rowbytes > 250) {\n\t\t\tbytecount = de_getu16be(pos);\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\tbytecount = (i64)de_getbyte(pos);\n\t\t\tpos+=1;\n\t\t}\n\n\t\tif(bi->packing_type==1 || bi->rowbytes<8) {\n\t\t\tdbuf_copy(c->infile, pos, bytecount, unc_pixels);\n\t\t}\n\t\telse if(bi->packing_type==3 && bi->pixelsize==16) {\n\t\t\tstruct de_packbits_params pbparams;\n\n\t\t\tde_zeromem(&pbparams, sizeof(struct de_packbits_params));\n\t\t\tpbparams.is_packbits16 = 1;\n\t\t\tdcmpri.pos = pos;\n\t\t\tdcmpri.len = bytecount;\n\t\t\tfmtutil_decompress_packbits_ex(c, &dcmpri, &dcmpro, &dres, &pbparams);\n\t\t}\n\t\telse {\n\t\t\tdcmpri.pos = pos;\n\t\t\tdcmpri.len = bytecount;\n\t\t\tfmtutil_decompress_packbits_ex(c, &dcmpri, &dcmpro, &dres, NULL);\n\t\t}\n\n\t\t// Make sure the data decompressed to the right number of bytes.\n\t\tif(unc_pixels->len != (j+1)*bi->rowspan) {\n\t\t\tdbuf_truncate(unc_pixels, (j+1)*bi->rowspan);\n\t\t}\n\n\t\tpos += bytecount;\n\t}\n\n\tdst_nsamples = 3;\n\tif(bi->uses_pal) {\n\t\tif(de_is_grayscale_palette(bi->pal, bi->num_pal_entries)) {\n\t\t\tdst_nsamples = 1;\n\t\t}\n\t}\n\n\timg = de_bitmap_create2(c, bi->npwidth, bi->pdwidth, bi->height, dst_nsamples);\n\n\tfi = de_finfo_create(c);\n\n\tif(bi->hdpi>=1.0 && bi->vdpi>=1.0) {\n\t\tfi->density.code = DE_DENSITY_DPI;\n\t\tfi->density.xdens = bi->hdpi;\n\t\tfi->density.ydens = bi->vdpi;\n\t}\n\n\tif(bi->uses_pal) {\n\t\tdecode_bitmap_paletted(c, d, bi, unc_pixels, img, pos);\n\t}\n\telse {\n\t\tif(bi->pixelsize==16) {\n\t\t\tdecode_bitmap_rgb16(c, d, bi, unc_pixels, img, pos);\n\t\t}\n\t\telse {\n\t\t\tdecode_bitmap_rgb24(c, d, bi, unc_pixels, img, pos);\n\t\t}\n\t}\n\n\tde_bitmap_write_to_file_finfo(img, fi, 0);\n\n\tde_bitmap_destroy(img);\n\tde_finfo_destroy(c, fi);\n\tdbuf_close(unc_pixels);\n\treturn 1;\n}\n\nstatic int decode_pixdata(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tint retval = 0;\n\n\tde_dbg_indent(c, 1);\n\n\tif(bi->npwidth==0 || bi->height==0) {\n\t\tde_warn(c, \"Ignoring zero-size bitmap (%d\"DE_CHAR_TIMES\"%d)\",\n\t\t\t(int)bi->npwidth, (int)bi->height);\n\t\tgoto done;\n\t}\n\tif(!de_good_image_dimensions(c, bi->npwidth, bi->height)) goto done;\n\n\tif(bi->pixelsize!=1 && bi->pixelsize!=2 && bi->pixelsize!=4 && bi->pixelsize!=8 &&\n\t\tbi->pixelsize!=16 && bi->pixelsize!=24 && bi->pixelsize!=32)\n\t{\n\t\tde_err(c, \"%d bits/pixel images are not supported\", (int)bi->pixelsize);\n\t\tgoto done;\n\t}\n\tif((bi->uses_pal && bi->pixeltype!=0) || (!bi->uses_pal && bi->pixeltype!=16)) {\n\t\tde_err(c, \"Pixel type %d is not supported\", (int)bi->pixeltype);\n\t\tgoto done;\n\t}\n\tif(bi->cmpcount!=1 && bi->cmpcount!=3 && bi->cmpcount!=4) {\n\t\tde_err(c, \"Component count %d is not supported\", (int)bi->cmpcount);\n\t\tgoto done;\n\t}\n\tif(bi->cmpsize!=1 && bi->cmpsize!=2 && bi->cmpsize!=4 && bi->cmpsize!=5 &&\n\t\tbi->cmpsize!=8)\n\t{\n\t\tde_err(c, \"%d-bit components are not supported\", (int)bi->cmpsize);\n\t\tgoto done;\n\t}\n\tif(bi->packing_type!=0 && bi->packing_type!=1 && bi->packing_type!=3 && bi->packing_type!=4) {\n\t\tde_err(c, \"Packing type %d is not supported\", (int)bi->packing_type);\n\t\tgoto done;\n\t}\n\tif((bi->uses_pal &&\n\t\t(bi->packing_type==0 || bi->packing_type==1) &&\n\t\t(bi->pixelsize==1 || bi->pixelsize==2 || bi->pixelsize==4 || bi->pixelsize==8) &&\n\t\tbi->cmpcount==1 && bi->cmpsize==bi->pixelsize) ||\n\t\t(!bi->uses_pal && bi->packing_type==3 && bi->pixelsize==16 && bi->cmpcount==3 && bi->cmpsize==5) ||\n\t\t(!bi->uses_pal && bi->packing_type==4 && bi->pixelsize==32 && bi->cmpcount==3 && bi->cmpsize==8) ||\n\t\t(!bi->uses_pal && bi->packing_type==4 && bi->pixelsize==32 && bi->cmpcount==4 && bi->cmpsize==8))\n\t{\n\t\t;\n\t}\n\telse {\n\t\tde_err(c, \"This type of image is not supported\");\n\t\tgoto done;\n\t}\n\n\tif(bi->cmpcount==4) {\n\t\tde_warn(c, \"This image might have transparency, which is not supported.\");\n\t}\n\n\tdecode_bitmap(c, d, bi, pos);\n\ndone:\n\tde_dbg_indent(c, -1);\n\treturn retval;\n}\n\n// For opcodes 0x90, 0x91, 0x98, 0x99, 0x9a, 0x9b\nstatic int handler_98_9a(deark *c, lctx *d, i64 opcode, i64 pos1, i64 *bytes_used)\n{\n\tstruct fmtutil_macbitmap_info *bi = NULL;\n\ti64 pixdata_size = 0;\n\ti64 colortable_size = 0;\n\tint retval = 0;\n\ti64 pos;\n\n\tbi = de_malloc(c, sizeof(struct fmtutil_macbitmap_info));\n\tpos = pos1;\n\n\tif(opcode==0x9a || opcode==0x9b) {\n\t\tfmtutil_macbitmap_read_baseaddr(c, c->infile, bi, pos);\n\t\tpos += 4;\n\t}\n\n\tfmtutil_macbitmap_read_rowbytes_and_bounds(c, c->infile, bi, pos);\n\tpos += 10;\n\n\tif(bi->pixmap_flag) {\n\t\tfmtutil_macbitmap_read_pixmap_only_fields(c, c->infile, bi, pos);\n\t\tpos += 36;\n\t}\n\n\tif((opcode==0x90 || opcode==0x91 || opcode==0x98 || opcode==0x99) && bi->pixmap_flag) {\n\t\t// Prepare to read the palette\n\t\tbi->uses_pal = 1;\n\t\tbi->has_colortable = 1;\n\t}\n\telse if((opcode==0x90 || opcode==0x91 || opcode==0x98 || opcode==0x99) && !bi->pixmap_flag) {\n\t\t// Settings implied by the lack of a PixMap header\n\t\tbi->pixelsize = 1;\n\t\tbi->cmpcount = 1;\n\t\tbi->cmpsize = 1;\n\t\tbi->uses_pal = 1;\n\t\tbi->num_pal_entries = 2;\n\t\tbi->pal[0] = DE_STOCKCOLOR_WHITE;\n\t\tbi->pal[1] = DE_STOCKCOLOR_BLACK;\n\t}\n\telse if((opcode==0x9a || opcode==0x9b) && !bi->pixmap_flag) {\n\t\tde_err(c, \"DirectBitsRect image without PixMap flag is not supported\");\n\t\tgoto done;\n\t}\n\n\tif(bi->has_colortable) {\n\t\tif(!fmtutil_macbitmap_read_colortable(c, c->infile, bi, pos, &colortable_size)) goto done;\n\t\tpos += colortable_size;\n\t}\n\n\tread_src_dst_mode(c, d, bi, pos);\n\tpos += 18;\n\n\tif(opcode==0x91 || opcode==0x99 || opcode==0x9b) {\n\t\ti64 rgnsize;\n\n\t\tde_dbg(c, \"region at %\"I64_FMT, pos);\n\t\tde_dbg_indent(c, 1);\n\t\trgnsize = de_getu16be(pos);\n\t\tde_dbg(c, \"region size: %d\", (int)rgnsize);\n\t\tde_dbg_indent(c, -1);\n\t\tif(rgnsize<2) goto done;\n\t\tpos += rgnsize;\n\t\tif(!c->padpix) {\n\t\t\tde_info(c, \"Note: Ignoring clipping region. Output image might have \"\n\t\t\t\t\"extraneous pixels.\");\n\t\t}\n\t}\n\n\tif(!get_pixdata_size(c, d, bi, pos, &pixdata_size)) {\n\t\tgoto done;\n\t}\n\tdecode_pixdata(c, d, bi, pos);\n\tpos += pixdata_size;\n\n\t*bytes_used = pos - pos1;\n\n\tretval = 1;\n\ndone:\n\tde_free(c, bi);\n\treturn retval;\n}\n\nstatic int handler_pixpat(deark *c, lctx *d, i64 opcode, i64 pos1, i64 *bytes_used)\n{\n\tunsigned int pattype;\n\ti64 pos = pos1;\n\tint needmsg = 1;\n\tint retval = 0;\n\ti64 colortable_size = 0;\n\ti64 pixdata_size = 0;\n\tstruct fmtutil_macbitmap_info *bi = NULL;\n\n\tpattype = (unsigned int)de_getu16be_p(&pos);\n\tde_dbg(c, \"PatType: %u\", pattype);\n\tpos += 8; // Pat1Data\n\n\tif(pattype==2) { // ditherPat(?)\n\t\tpos += 6; // RGB\n\t\tretval = 1;\n\t\tgoto done;\n\t}\n\n\tbi = de_malloc(c, sizeof(struct fmtutil_macbitmap_info));\n\n\tfmtutil_macbitmap_read_rowbytes_and_bounds(c, c->infile, bi, pos);\n\tpos += 10;\n\tfmtutil_macbitmap_read_pixmap_only_fields(c, c->infile, bi, pos);\n\tpos += 36;\n\n\tbi->uses_pal = 1;\n\tif(!fmtutil_macbitmap_read_colortable(c, c->infile, bi, pos, &colortable_size)) goto done;\n\tpos += colortable_size;\n\n\tif(!get_pixdata_size(c, d, bi, pos, &pixdata_size)) {\n\t\tgoto done;\n\t}\n\t// Note: We could extract the \"PixMap\" pattern easily enough here, by calling\n\t// decode_pixdata(). But if we do that, maybe we should also extract the\n\t// Pat1Data data above, as well as other opcodes like BkPat.\n\tpos += pixdata_size;\n\tretval = 1;\n\ndone:\n\tif(!retval && needmsg) {\n\t\tde_err(c, \"Failed to parse PixPat data\");\n\t}\n\tif(retval) {\n\t\t*bytes_used = pos - pos1;\n\t}\n\tde_free(c, bi);\n\treturn retval;\n}\n\nstatic void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}\n\n// ShortComment\nstatic int handler_a0(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\tkind = de_getu16be(data_pos);\n\tde_dbg(c, \"comment kind: %d\", (int)kind);\n\treturn 1;\n}\n\n// LongComment\nstatic int handler_a1(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\ti64 len;\n\n\tkind = de_getu16be(data_pos);\n\tlen = de_getu16be(data_pos+2);\n\tde_dbg(c, \"comment kind: %d, size: %d\", (int)kind, (int)len);\n\t*bytes_used = 4+len;\n\n\tif(kind==100 && len>=4) {\n\t\tstruct de_fourcc sig4cc;\n\n\t\tdbuf_read_fourcc(c->infile, data_pos+4, &sig4cc, 4, 0x0);\n\t\tde_dbg(c, \"application comment, signature=0x%08x '%s'\",\n\t\t\t(unsigned int)sig4cc.id, sig4cc.id_dbgstr);\n\t\tde_dbg_hexdump(c, c->infile, data_pos+8, len-4, 256, NULL, 0x1);\n\t}\n\telse if(kind==224) {\n\t\tdo_iccprofile_item(c, d, data_pos+4, len);\n\t}\n\telse {\n\t\tde_dbg_hexdump(c, c->infile, data_pos+4, len, 256, NULL, 0x1);\n\t}\n\n\treturn 1;\n}\n\n// HeaderOp\nstatic int handler_0c00(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 hdrver;\n\tdouble hres, vres;\n\tstruct pict_rect srcrect;\n\n\thdrver = de_getu16be(data_pos);\n\td->is_extended_v2 = (hdrver==0xfffe);\n\n\tde_dbg(c, \"extended v2: %s\", d->is_extended_v2?\"yes\":\"no\");\n\tif(d->is_extended_v2) {\n\t\thres = pict_read_fixed(c->infile, data_pos+4);\n\t\tvres = pict_read_fixed(c->infile, data_pos+8);\n\t\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", hres, vres);\n\t\tpict_read_rect(c->infile, data_pos+12, &srcrect, \"srcRect\");\n\t}\n\n\treturn 1;\n}\n\nstatic void do_handle_qtif_idsc(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 idsc_dpos, idsc_dlen;\n\ti64 idat_dpos, idat_dlen;\n\tdbuf *outf = NULL;\n\tstruct de_fourcc cmpr4cc;\n\n\tif(d->decode_qtif) {\n\t\tde_run_module_by_id_on_slice2(c, \"qtif\", \"I\", c->infile, pos, len);\n\t\treturn;\n\t}\n\n\t// Try to construct a .qtif file.\n\t// This way, we do something potentially useful even if the image has\n\t// a compression scheme that our qtif module doesn't support.\n\n\tidsc_dpos = pos;\n\tidsc_dlen = de_getu32be(idsc_dpos);\n\tde_dbg(c, \"idsc: pos=%\"I64_FMT\", len=%\"I64_FMT, idsc_dpos, idsc_dlen);\n\tif(idsc_dpos+idsc_dlen > pos+len) goto done;\n\n\tdbuf_read_fourcc(c->infile, idsc_dpos+4, &cmpr4cc, 4, 0x0);\n\tde_dbg(c, \"compression type: \\\"%s\\\"\", cmpr4cc.id_dbgstr);\n\n\tidat_dpos = idsc_dpos + idsc_dlen;\n\tidat_dlen = de_getu32be(idsc_dpos+44);\n\tde_dbg(c, \"idat: pos=%\"I64_FMT\", len=%\"I64_FMT, idat_dpos, idat_dlen);\n\tif(idat_dlen==0) {\n\t\tidat_dlen = pos+len-idat_dpos; // ??\n\t}\n\tif(idat_dpos+idat_dlen > pos+len) goto done;\n\n#define CODE_idat 0x69646174U\n#define CODE_idsc 0x69647363U\n\toutf = dbuf_create_output_file(c, \"qtif\", NULL, 0);\n\n\tdbuf_writeu32be(outf, 8+idsc_dlen);\n\tdbuf_writeu32be(outf, CODE_idsc);\n\tdbuf_copy(c->infile, idsc_dpos, idsc_dlen, outf);\n\n\tdbuf_writeu32be(outf, 8+idat_dlen);\n\tdbuf_writeu32be(outf, CODE_idat);\n\tdbuf_copy(c->infile, idat_dpos, idat_dlen, outf);\n\ndone:\n\tdbuf_close(outf);\n}\n\n// CompressedQuickTime (0x8200) & UncompressedQuickTime (0x8201)\nstatic int handler_QuickTime(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 payload_pos;\n\ti64 payload_len;\n\ti64 endpos;\n\ti64 idsc_pos;\n\n\tpayload_len = de_getu32be(data_pos);\n\tpayload_pos = data_pos+4;\n\tde_dbg(c, \"payload: pos=%\"I64_FMT\", len=%\"I64_FMT, payload_pos, payload_len);\n\tendpos = payload_pos+payload_len;\n\tif(endpos > c->infile->len) return 0;\n\t*bytes_used = 4+payload_len;\n\n\t// Following the size field seems to be 68 or 50 bytes of data,\n\t// followed by QuickTime \"idsc\" data, followed by image data.\n\tidsc_pos = payload_pos + ((opcode==0x8201) ? 50 : 68);\n\n\tdo_handle_qtif_idsc(c, d, idsc_pos, endpos-idsc_pos);\n\treturn 1;\n}\n\nstatic const struct opcode_info opcode_info_arr[] = {\n\t// TODO: This list might not be complete, and it needs to be complete in\n\t// order to parse all PICT files.\n\t// Note that some opcode ranges are handled in do_handle_item().\n\t{ 0x0000, SZCODE_EXACT,   0,  \"NOP\", NULL },\n\t{ 0x0001, SZCODE_REGION,  0,  \"Clip\", NULL },\n\t{ 0x0002, SZCODE_EXACT,   8,  \"BkPat\", NULL },\n\t{ 0x0003, SZCODE_EXACT,   2,  \"TxFont\", NULL },\n\t{ 0x0004, SZCODE_EXACT,   1,  \"TxFace\", NULL },\n\t{ 0x0005, SZCODE_EXACT,   2,  \"TxMode\", NULL },\n\t{ 0x0006, SZCODE_EXACT,   4,  \"SpExtra\", NULL },\n\t{ 0x0007, SZCODE_EXACT,   4,  \"PnSize\", NULL },\n\t{ 0x0008, SZCODE_EXACT,   2,  \"PnMode\", NULL },\n\t{ 0x0009, SZCODE_EXACT,   8,  \"PnPat\", NULL },\n\t{ 0x000a, SZCODE_EXACT,   8,  \"FillPat\", NULL },\n\t{ 0x000b, SZCODE_EXACT,   4,  \"OvSize\", NULL },\n\t{ 0x000c, SZCODE_EXACT,   4,  \"Origin\", NULL },\n\t{ 0x000d, SZCODE_EXACT,   2,  \"TxSize\", NULL },\n\t{ 0x000e, SZCODE_EXACT,   4,  \"FgColor\", NULL },\n\t{ 0x000f, SZCODE_EXACT,   4,  \"BkColor\", NULL },\n\t{ 0x0010, SZCODE_EXACT,   8,  \"TxRatio\", NULL },\n\t{ 0x0011, SZCODE_EXACT,   1,  \"Version\", handler_11 },\n\t{ 0x0012, SZCODE_SPECIAL, 0,  \"BkPixPat\", handler_pixpat },\n\t{ 0x0013, SZCODE_SPECIAL, 0,  \"PnPixPat\", handler_pixpat },\n\t{ 0x0014, SZCODE_SPECIAL, 0,  \"FillPixPat\", handler_pixpat },\n\t{ 0x0015, SZCODE_EXACT,   2,  \"PnLocHFrac\", NULL },\n\t{ 0x0016, SZCODE_EXACT,   2,  \"ChExtra\", NULL },\n\t{ 0x001a, SZCODE_EXACT,   6,  \"RGBFgCol\", handler_RGBColor },\n\t{ 0x001b, SZCODE_EXACT,   6,  \"RGBBkCol\", handler_RGBColor },\n\t{ 0x001c, SZCODE_EXACT,   0,  \"HiliteMode\", NULL },\n\t{ 0x001d, SZCODE_EXACT,   6,  \"HiliteColor\", handler_RGBColor },\n\t{ 0x001e, SZCODE_EXACT,   0,  \"DefHilite\", NULL },\n\t{ 0x001f, SZCODE_EXACT,   6,  \"OpColor\", handler_RGBColor },\n\t{ 0x0020, SZCODE_EXACT,   8,  \"Line\", NULL },\n\t{ 0x0021, SZCODE_EXACT,   4,  \"LineFrom\", NULL },\n\t{ 0x0022, SZCODE_EXACT,   6,  \"ShortLine\", NULL },\n\t{ 0x0023, SZCODE_EXACT,   2,  \"ShortLineFrom\", NULL },\n\t{ 0x0028, SZCODE_SPECIAL, 0,  \"LongText\", handler_28 },\n\t{ 0x0029, SZCODE_SPECIAL, 0,  \"DHText\", handler_DxText },\n\t{ 0x002a, SZCODE_SPECIAL, 0,  \"DVText\", handler_DxText },\n\t{ 0x002b, SZCODE_SPECIAL, 0,  \"DHDVText\", handler_2b },\n\t{ 0x002c, SZCODE_SPECIAL, 0,  \"fontName\", handler_2c },\n\t{ 0x002d, SZCODE_SPECIAL, 0,  \"lineJustify\", NULL },\n\t{ 0x002e, SZCODE_SPECIAL, 0,  \"glyphState\", NULL },\n\t{ 0x0030, SZCODE_EXACT,   8,  \"frameRect\", handler_Rectangle },\n\t{ 0x0031, SZCODE_EXACT,   8,  \"paintRect\", handler_Rectangle },\n\t{ 0x0032, SZCODE_EXACT,   8,  \"eraseRect\", handler_Rectangle },\n\t{ 0x0033, SZCODE_EXACT,   8,  \"invertRect\", handler_Rectangle },\n\t{ 0x0034, SZCODE_EXACT,   8,  \"fillRect\", handler_Rectangle },\n\t{ 0x0038, SZCODE_EXACT,   0,  \"frameSameRect\", NULL },\n\t{ 0x0039, SZCODE_EXACT,   0,  \"paintSameRect\", NULL },\n\t{ 0x003a, SZCODE_EXACT,   0,  \"eraseSameRect\", NULL },\n\t{ 0x003b, SZCODE_EXACT,   0,  \"invertSameRect\", NULL },\n\t{ 0x003c, SZCODE_EXACT,   0,  \"fillSameRect\", NULL },\n\t{ 0x0040, SZCODE_EXACT,   8,  \"frameRRect\", handler_Rectangle },\n\t{ 0x0041, SZCODE_EXACT,   8,  \"paintRRect\", handler_Rectangle },\n\t{ 0x0042, SZCODE_EXACT,   8,  \"eraseRRect\", handler_Rectangle },\n\t{ 0x0043, SZCODE_EXACT,   8,  \"invertRRect\", handler_Rectangle },\n\t{ 0x0044, SZCODE_EXACT,   8,  \"fillRRect\", handler_Rectangle },\n\t{ 0x0048, SZCODE_EXACT,   0,  \"frameSameRRect\", NULL },\n\t{ 0x0049, SZCODE_EXACT,   0,  \"paintSameRRect\", NULL },\n\t{ 0x004a, SZCODE_EXACT,   0,  \"eraseSameRRect\", NULL },\n\t{ 0x004b, SZCODE_EXACT,   0,  \"invertSameRRect\", NULL },\n\t{ 0x004c, SZCODE_EXACT,   0,  \"fillSameRRect\", NULL },\n\t{ 0x0050, SZCODE_EXACT,   8,  \"frameOval\", handler_Rectangle },\n\t{ 0x0051, SZCODE_EXACT,   8,  \"paintOval\", handler_Rectangle },\n\t{ 0x0052, SZCODE_EXACT,   8,  \"eraseOval\", handler_Rectangle },\n\t{ 0x0053, SZCODE_EXACT,   8,  \"invertOval\", handler_Rectangle },\n\t{ 0x0054, SZCODE_EXACT,   8,  \"fillOval\", handler_Rectangle },\n\t{ 0x0058, SZCODE_EXACT,   0,  \"frameSameOval\", NULL },\n\t{ 0x0059, SZCODE_EXACT,   0,  \"paintSameOval\", NULL },\n\t{ 0x005a, SZCODE_EXACT,   0,  \"eraseSameOval\", NULL },\n\t{ 0x005b, SZCODE_EXACT,   0,  \"invertSameOval\", NULL },\n\t{ 0x005c, SZCODE_EXACT,   0,  \"fillSameOval\", NULL },\n\t{ 0x0060, SZCODE_EXACT,   12, \"frameArc\", NULL },\n\t{ 0x0061, SZCODE_EXACT,   12, \"paintArc\", NULL },\n\t{ 0x0062, SZCODE_EXACT,   12, \"eraseArc\", NULL },\n\t{ 0x0063, SZCODE_EXACT,   12, \"invertArc\", NULL },\n\t{ 0x0064, SZCODE_EXACT,   12, \"fillArc\", NULL },\n\t{ 0x0068, SZCODE_EXACT,   4,  \"frameSameArc\", NULL },\n\t{ 0x0069, SZCODE_EXACT,   4,  \"paintSameArc\", NULL },\n\t{ 0x006a, SZCODE_EXACT,   4,  \"eraseSameArc\", NULL },\n\t{ 0x006b, SZCODE_EXACT,   4,  \"invertSameArc\", NULL },\n\t{ 0x006c, SZCODE_EXACT,   4,  \"fillSameArc\", NULL },\n\t{ 0x0080, SZCODE_REGION,  0,  \"frameRgn\", NULL },\n\t{ 0x0081, SZCODE_REGION,  0,  \"paintRgn\", NULL },\n\t{ 0x0082, SZCODE_REGION,  0,  \"eraseRgn\", NULL },\n\t{ 0x0083, SZCODE_REGION,  0,  \"invertRgn\", NULL },\n\t{ 0x0084, SZCODE_REGION,  0,  \"fillRgn\", NULL },\n\t{ 0x0070, SZCODE_POLYGON, 0,  \"framePoly\", NULL },\n\t{ 0x0071, SZCODE_POLYGON, 0,  \"paintPoly\", NULL },\n\t{ 0x0072, SZCODE_POLYGON, 0,  \"erasePoly\", NULL },\n\t{ 0x0073, SZCODE_POLYGON, 0,  \"invertPoly\", NULL },\n\t{ 0x0074, SZCODE_POLYGON, 0,  \"fillPoly\", NULL },\n\t{ 0x0090, SZCODE_SPECIAL, 0,  \"BitsRect\", handler_98_9a },\n\t{ 0x0091, SZCODE_SPECIAL, 0,  \"BitsRgn\", handler_98_9a },\n\t{ 0x0098, SZCODE_SPECIAL, 0,  \"PackBitsRect\", handler_98_9a },\n\t{ 0x0099, SZCODE_SPECIAL, 0,  \"PackBitsRgn\", handler_98_9a },\n\t{ 0x009a, SZCODE_SPECIAL, 0,  \"DirectBitsRect\", handler_98_9a },\n\t{ 0x009b, SZCODE_SPECIAL, 0,  \"DirectBitsRgn\", handler_98_9a },\n\t{ 0x00a0, SZCODE_EXACT,   2,  \"ShortComment\", handler_a0 },\n\t{ 0x00a1, SZCODE_SPECIAL, 0,  \"LongComment\", handler_a1 },\n\t{ 0x00ff, SZCODE_EXACT,   2,  \"opEndPic\", NULL },\n\t{ 0x0c00, SZCODE_EXACT,   24, \"HeaderOp\", handler_0c00 },\n\t{ 0x8200, SZCODE_SPECIAL, 0,  \"CompressedQuickTime\", handler_QuickTime },\n\t{ 0x8201, SZCODE_SPECIAL, 0,  \"UncompressedQuickTime\", handler_QuickTime }\n};\n\nstatic const struct opcode_info *find_opcode_info(i64 opcode)\n{\n\tsize_t i;\n\n\tfor(i=0; i<DE_ARRAYCOUNT(opcode_info_arr); i++) {\n\t\tif(opcode_info_arr[i].opcode == opcode) {\n\t\t\treturn &opcode_info_arr[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int do_handle_item(deark *c, lctx *d, i64 opcode_pos, i64 opcode,\n\t\t\t\t\t\t   i64 data_pos, i64 *data_bytes_used)\n{\n\tconst char *opcode_name;\n\tconst struct opcode_info *opi;\n\ti64 n;\n\tstruct pict_rect tmprect;\n\tint ret = 0;\n\n\t*data_bytes_used = 0;\n\n\topi = find_opcode_info(opcode);\n\tif(opi && opi->name) opcode_name = opi->name;\n\telse opcode_name = \"?\";\n\n\tif(d->version==2)\n\t\tde_dbg(c, \"opcode 0x%04x (%s) at %d\", (unsigned int)opcode, opcode_name, (int)opcode_pos);\n\telse\n\t\tde_dbg(c, \"opcode 0x%02x (%s) at %d\", (unsigned int)opcode, opcode_name, (int)opcode_pos);\n\n\tif(opi && opi->fn) {\n\t\tde_dbg_indent(c, 1);\n\t\t*data_bytes_used = opi->size; // Default to the size in the table.\n\t\tret = opi->fn(c, d, opcode, data_pos, data_bytes_used);\n\t\tde_dbg_indent(c, -1);\n\t}\n\telse if(opi && opi->size_code==SZCODE_EXACT) {\n\t\t*data_bytes_used = opi->size;\n\t\tret = 1;\n\t}\n\telse if(opi && opi->size_code==SZCODE_REGION) {\n\t\tn = de_getu16be(data_pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_dbg(c, \"region size: %d\", (int)n);\n\t\tif(n>=10) {\n\t\t\tpict_read_rect(c->infile, data_pos+2, &tmprect, \"rect\");\n\t\t}\n\t\tde_dbg_indent(c, -1);\n\t\t*data_bytes_used = n;\n\t\tret = 1;\n\t}\n\telse if(opi && opi->size_code==SZCODE_POLYGON) {\n\t\tn = de_getu16be(data_pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_dbg(c, \"polygon size: %d\", (int)n);\n\t\tde_dbg_indent(c, -1);\n\t\t*data_bytes_used = n;\n\t\tret = 1;\n\t}\n\telse if(opcode>=0x2c && opcode<=0x2f) {\n\t\t// Starts with 2-byte size, size does not include the \"size\" field.\n\t\tn = de_getu16be(data_pos);\n\t\t*data_bytes_used = 2+n;\n\t\tret = 1;\n\t}\n\telse if(opcode>=0x8100 && opcode<=0xffff) {\n\t\t// Starts with 4-byte size, size does not include the \"size\" field.\n\t\tn = de_getu32be(data_pos);\n\t\t*data_bytes_used = 4+n;\n\t\tret = 1;\n\t}\n\telse {\n\t\tde_err(c, \"Unsupported opcode: 0x%04x\", (unsigned int)opcode);\n\t}\n\n\treturn ret;\n}\n\nstatic void do_read_items(deark *c, lctx *d, i64 pos)\n{\n\ti64 opcode;\n\ti64 opcode_pos;\n\ti64 bytes_used;\n\tint ret;\n\n\twhile(1) {\n\t\tif(pos%2 && d->version==2) {\n\t\t\tpos++; // 2-byte alignment\n\t\t}\n\n\t\tif(pos >= c->infile->len) break;\n\n\t\topcode_pos = pos;\n\n\t\tif(d->version==2) {\n\t\t\topcode = de_getu16be(pos);\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\topcode = (i64)de_getbyte(pos);\n\t\t\tpos+=1;\n\t\t}\n\n\t\tret = do_handle_item(c, d, opcode_pos, opcode, pos, &bytes_used);\n\t\tif(!ret) goto done;\n\t\tif(opcode==0x00ff) goto done; // End of image\n\n\t\tpos += bytes_used;\n\t}\ndone:\n\t;\n}\n\n// mode: 0=called from de_identify..., 1=called from de_run...\nstatic void do_detect_version(deark *c, struct detection_info *dti, int mode)\n{\n\tstatic const u8 v1pattern[2] = { 0x11, 0x01 };\n\tstatic const u8 v2pattern[6] = { 0x00, 0x11, 0x02, 0xff, 0x0c, 0x00 };\n\tu8 buf[6];\n\tint v1_nohdr = 0;\n\tint v2_nohdr = 0;\n\tint v1_hdr = 0;\n\tint v2_hdr = 0;\n\n\tdti->file_version = 0;\n\tdti->has_fileheader = 0;\n\n\tde_read(buf, 522, sizeof(buf));\n\tif(!de_memcmp(buf, v2pattern, 6)) {\n\t\tv2_hdr = 1;\n\t}\n\telse if(!de_memcmp(buf, v1pattern, 2)) {\n\t\tv1_hdr = 1;\n\t}\n\telse {\n\t\tde_read(buf, 10, sizeof(buf));\n\t\tif(!de_memcmp(buf, v2pattern, 6)) {\n\t\t\tv2_nohdr = 1;\n\t\t}\n\t\telse if(!de_memcmp(buf, v1pattern, 2)) {\n\t\t\tv1_nohdr = 1;\n\t\t}\n\t}\n\n\tif(!v1_hdr && !v2_hdr && !v1_nohdr && !v2_nohdr) {\n\t\treturn;\n\t}\n\n\tif(v2_hdr) {\n\t\tdti->file_version = 2;\n\t\tdti->has_fileheader = 1;\n\t\treturn;\n\t}\n\telse if(v2_nohdr) {\n\t\tdti->file_version = 2;\n\t\treturn;\n\t}\n\n\tif(mode==0) {\n\t\t// For v1, check that the file ends as expected\n\t\tde_read(buf, c->infile->len-2, 2);\n\t\tif(buf[1]==0xff) {\n\t\t\t; // v1 files should end with 0xff\n\t\t}\n\t\telse if(buf[0]==0xff && buf[1]==0x00) {\n\t\t\t; // But a few have an extra NUL byte at the end\n\t\t}\n\t}\n\n\tif(v1_hdr) {\n\t\tdti->file_version = 1;\n\t\tdti->has_fileheader = 1;\n\t\treturn;\n\t}\n\telse if(v1_nohdr) {\n\t\tdti->file_version = 1;\n\t\treturn;\n\t}\n}\n\nstatic void de_run_pict(deark *c, de_module_params *mparams)\n{\n\tlctx *d = NULL;\n\ti64 pos = 0;\n\ti64 picsize;\n\tstruct pict_rect framerect;\n\n\td = de_malloc(c, sizeof(lctx));\n\n\tdo_detect_version(c, &d->dti, 1);\n\tif(d->dti.file_version>0) {\n\t\tde_declare_fmtf(c, \"PICT v%d%s\", d->dti.file_version,\n\t\t\td->dti.has_fileheader?\"\":\", without file header\");\n\t}\n\n\td->version = 1;\n\n\tif(d->dti.has_fileheader) {\n\t\tpos += 512;\n\t}\n\n\tpicsize = de_getu16be(pos);\n\tde_dbg(c, \"picSize: %d\", (int)picsize);\n\tpos+=2;\n\tpict_read_rect(c->infile, pos, &framerect, \"picFrame\");\n\tpos+=8;\n\n\tdo_read_items(c, d, pos);\n\n\tdbuf_close(d->iccprofile_file);\n\tde_free(c, d);\n}\n\nstatic int de_identify_pict(deark *c)\n{\n\tstruct detection_info dti;\n\n\tdo_detect_version(c, &dti, 0);\n\tif(dti.file_version==2) {\n\t\treturn 85;\n\t}\n\telse if(dti.file_version==1) {\n\t\tif(dti.has_fileheader) return 25;\n\t\treturn 15;\n\t}\n\treturn 0;\n}\n\nvoid de_module_pict(deark *c, struct deark_module_info *mi)\n{\n\tmi->id = \"pict\";\n\tmi->desc = \"Macintosh PICT\";\n\tmi->run_fn = de_run_pict;\n\tmi->identify_fn = de_identify_pict;\n}\n"], "fixing_code": ["// This file is part of Deark.\n// Copyright (C) 2016 Jason Summers\n// See the file COPYING for terms of use.\n\n// Macintosh PICT graphics\n\n#include <deark-config.h>\n#include <deark-private.h>\n#include <deark-fmtutil.h>\nDE_DECLARE_MODULE(de_module_pict);\n\nstruct pict_point {\n\ti64 y, x;\n};\n\nstruct pict_rect {\n\ti64 t, l, b, r;\n};\n\nstruct detection_info {\n\tint file_version;\n\tint has_fileheader;\n};\n\ntypedef struct localctx_struct {\n\tstruct detection_info dti;\n\tint version; // 1 or 2: The version mode that the parser is currently using\n\tint is_extended_v2;\n\tint decode_qtif;\n\tdbuf *iccprofile_file;\n} lctx;\n\ntypedef int (*item_decoder_fn)(deark *c, lctx *d, i64 opcode, i64 data_pos,\n\ti64 *bytes_used);\n\nstruct opcode_info {\n\tu16 opcode;\n#define SZCODE_SPECIAL 0\n#define SZCODE_EXACT   1\n#define SZCODE_REGION  2\n#define SZCODE_POLYGON 3\n\tu16 size_code;\n\tu32 size; // Data size, not including opcode. Logic depends on size_code.\n\tconst char *name;\n\titem_decoder_fn fn;\n};\n\nstatic double pict_read_fixed(dbuf *f, i64 pos)\n{\n\ti64 n;\n\n\t// I think QuickDraw's \"Fixed point\" numbers are signed, but I don't know\n\t// how negative numbers are handled.\n\tn = dbuf_geti32be(f, pos);\n\treturn ((double)n)/65536.0;\n}\n\n// Read a QuickDraw Point. Caller supplies point struct.\nstatic void pict_read_point(dbuf *f, i64 pos,\n\tstruct pict_point *point, const char *dbgname)\n{\n\tpoint->y = dbuf_geti16be(f, pos);\n\tpoint->x = dbuf_geti16be(f, pos+2);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)\", dbgname, (int)point->x, (int)point->y);\n\t}\n}\n\n// Read a QuickDraw Rectangle. Caller supplies rect struct.\nstatic void pict_read_rect(dbuf *f, i64 pos,\n\tstruct pict_rect *rect, const char *dbgname)\n{\n\trect->t = dbuf_geti16be(f, pos);\n\trect->l = dbuf_geti16be(f, pos+2);\n\trect->b = dbuf_geti16be(f, pos+4);\n\trect->r = dbuf_geti16be(f, pos+6);\n\n\tif(dbgname) {\n\t\tde_dbg(f->c, \"%s: (%d,%d)-(%d,%d)\", dbgname, (int)rect->l, (int)rect->t,\n\t\t\t(int)rect->r, (int)rect->b);\n\t}\n}\n\nstatic int handler_RGBColor(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\tunsigned int clr16[3];\n\tu8 clr8[3];\n\tu32 clr;\n\tchar csamp[16];\n\ti64 pos = data_pos;\n\ti64 k;\n\n\tfor(k=0; k<3; k++) {\n\t\tclr16[k] = (unsigned int)de_getu16be_p(&pos);\n\t\tclr8[k] = (u8)(clr16[k]>>8);\n\t}\n\tclr = DE_MAKE_RGB(clr8[0], clr8[1], clr8[2]);\n\tde_get_colorsample_code(c, clr, csamp, sizeof(csamp));\n\tde_dbg(c, \"color: (0x%04x,0x%04x,0x%04x)%s\", clr16[0], clr16[1], clr16[2], csamp);\n\treturn 1;\n}\n\n// Version\nstatic int handler_11(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 ver;\n\n\t*bytes_used = 1;\n\tver = de_getbyte(data_pos);\n\tde_dbg(c, \"version: %d\", (int)ver);\n\n\tif(ver==2) {\n\t\td->version = 2;\n\t}\n\telse if(ver!=1) {\n\t\tde_err(c, \"Unsupported PICT version: %d\", (int)ver);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n// LongText\nstatic int handler_28(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\tde_ucstring *s = NULL;\n\tstruct pict_point pt;\n\n\tpict_read_point(c->infile, data_pos, &pt, \"txLoc\");\n\ttlen = (i64)de_getbyte(data_pos+4);\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+5, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\t*bytes_used = 5+tlen;\n\tucstring_destroy(s);\n\treturn 1;\n}\n\n// DVText\nstatic int handler_DxText(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\ti64 dx;\n\tde_ucstring *s = NULL;\n\n\tdx = (i64)de_getbyte(data_pos);\n\tde_dbg(c, \"%s: %d\", opcode==0x2a?\"dv\":\"dh\", (int)dx);\n\n\ttlen = (i64)de_getbyte(data_pos+1);\n\t*bytes_used = 2+tlen;\n\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+2, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\n\tucstring_destroy(s);\n\treturn 1;\n}\n\n// DHDVText\nstatic int handler_2b(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 tlen;\n\ti64 dh, dv;\n\tde_ucstring *s = NULL;\n\n\tdh = (i64)de_getbyte(data_pos);\n\tdv = (i64)de_getbyte(data_pos+1);\n\tde_dbg(c, \"dh,dv: (%d,%d)\", (int)dh, (int)dv);\n\n\ttlen = (i64)de_getbyte(data_pos+2);\n\tde_dbg(c, \"text size: %d\", (int)tlen);\n\t*bytes_used = 3+tlen;\n\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+3, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"text: \\\"%s\\\"\", ucstring_getpsz(s));\n\n\treturn 1;\n}\n\n// fontName\nstatic int handler_2c(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 n;\n\ti64 tlen;\n\ti64 id;\n\tde_ucstring *s = NULL;\n\n\tn = de_getu16be(data_pos);\n\t*bytes_used = 2+n;\n\tid = de_getu16be(data_pos+2);\n\tde_dbg(c, \"old font id: %d\", (int)id);\n\ttlen = (i64)de_getbyte(data_pos+4);\n\ts = ucstring_create(c);\n\tdbuf_read_to_ucstring(c->infile, data_pos+5, tlen, s, 0, DE_ENCODING_MACROMAN);\n\tde_dbg(c, \"font name: \\\"%s\\\"\", ucstring_getpsz(s));\n\tucstring_destroy(s);\n\treturn 1;\n}\n\nstatic int handler_Rectangle(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\tstruct pict_rect rect;\n\n\tpict_read_rect(c->infile, data_pos, &rect, \"rect\");\n\treturn 1;\n}\n\n// final few bitmap header fields (18 bytes)\nstatic void read_src_dst_mode(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tstruct pict_rect tmprect;\n\ti64 n;\n\n\tde_dbg(c, \"src/dst/mode part of bitmap header, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tpict_read_rect(c->infile, pos, &tmprect, \"srcRect\");\n\tpos += 8;\n\tpict_read_rect(c->infile, pos, &tmprect, \"dstRect\");\n\tpos += 8;\n\n\tn = de_getu16be(pos);\n\tde_dbg(c, \"transfer mode: %d\", (int)n);\n\t//pos += 2;\n\tde_dbg_indent(c, -1);\n}\n\n// Pre-scan the pixel data to figure out its size.\n// (We could instead scan and decode it at the same time, but error handling\n// would get really messy.)\n// Returns 0 on fatal error (if we could not even parse the data).\nstatic int get_pixdata_size(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\ti64 pos1, i64 *pixdata_size)\n{\n\ti64 pos;\n\ti64 j;\n\ti64 bytecount;\n\tint retval = 0;\n\n\tpos = pos1;\n\tde_dbg(c, \"PixData at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\n\tif(bi->height<0 || bi->height>65535) {\n\t\tde_err(c, \"Invalid bitmap height (%d)\", (int)bi->height);\n\t\tgoto done;\n\t}\n\n\t// Make sure rowbytes is sane. We use it to decide how much memory to allocate.\n\t// Note: I've seen valid bitmaps with as many as 284 extra bytes per row.\n\tif(bi->rowbytes > (bi->npwidth * bi->pixelsize)/8 + 1000) {\n\t\tde_err(c, \"Bad rowBytes value (%d)\", (int)bi->rowbytes);\n\t\tgoto done;\n\t}\n\n\tif(bi->packing_type>=3 || (bi->packing_type==0 && bi->rowbytes>=8)) {\n\t\tfor(j=0; j<bi->height; j++) {\n\t\t\tif(bi->rowbytes > 250) {\n\t\t\t\tbytecount = de_getu16be(pos);\n\t\t\t\tpos+=2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbytecount = (i64)de_getbyte(pos);\n\t\t\t\tpos+=1;\n\t\t\t}\n\t\t\tpos += bytecount;\n\t\t}\n\t}\n\telse if(bi->packing_type==1 || (bi->packing_type==0 && bi->rowbytes<8)) {\n\t\tpos += bi->rowbytes * bi->height; // uncompressed\n\t}\n\telse {\n\t\tde_err(c, \"Unsupported packing type: %d\", (int)bi->packing_type);\n\t\tgoto done;\n\t}\n\n\t*pixdata_size = pos - pos1;\n\tde_dbg(c, \"PixData size: %d\", (int)*pixdata_size);\n\tretval = 1;\n\ndone:\n\tde_dbg_indent(c, -1);\n\treturn retval;\n}\n\nstatic void decode_bitmap_rgb24(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 cr, cg, cb;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tcr = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+0)*bi->pdwidth + i);\n\t\t\tcg = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+1)*bi->pdwidth + i);\n\t\t\tcb = dbuf_getbyte(unc_pixels, j*bi->rowspan + (bi->cmpcount-3+2)*bi->pdwidth + i);\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, DE_MAKE_RGB(cr,cg,cb));\n\t\t}\n\t}\n}\n\nstatic void decode_bitmap_rgb16(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 c0, c1; //, cg, cb;\n\tu32 clr;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tc0 = dbuf_getbyte(unc_pixels, j*bi->rowspan + i*2);\n\t\t\tc1 = dbuf_getbyte(unc_pixels, j*bi->rowspan + i*2+1);\n\t\t\tclr = ((u32)c0 << 8)|c1;\n\t\t\tclr = de_rgb555_to_888(clr);\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, clr);\n\t\t}\n\t}\n}\n\nstatic void decode_bitmap_paletted(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi,\n\tdbuf *unc_pixels, de_bitmap *img, i64 pos)\n{\n\ti64 i, j;\n\tu8 b;\n\tu32 clr;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tfor(i=0; i<bi->pdwidth; i++) {\n\t\t\tb = de_get_bits_symbol(unc_pixels, bi->pixelsize, j*bi->rowspan, i);\n\t\t\tclr = bi->pal[(unsigned int)b];\n\t\t\tde_bitmap_setpixel_rgb(img, i, j, clr);\n\t\t}\n\t}\n}\n\nstatic int decode_bitmap(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\ti64 j;\n\tdbuf *unc_pixels = NULL;\n\tde_bitmap *img = NULL;\n\tde_finfo *fi = NULL;\n\ti64 bytecount;\n\ti64 bitmapsize;\n\tint dst_nsamples;\n\tstruct de_dfilter_in_params dcmpri;\n\tstruct de_dfilter_out_params dcmpro;\n\tstruct de_dfilter_results dres;\n\n\tde_dfilter_init_objects(c, &dcmpri, &dcmpro, &dres);\n\n\tbi->rowspan = bi->rowbytes;\n\tif(bi->pixelsize==32 && bi->cmpcount==3 && bi->cmpsize==8) {\n\t\tbi->rowspan = (bi->rowbytes/4)*3;\n\t}\n\n\tbitmapsize = bi->height * bi->rowspan;\n\tunc_pixels = dbuf_create_membuf(c, bitmapsize, 1);\n\n\tdcmpri.f = c->infile;\n\tdcmpro.f = unc_pixels;\n\n\tfor(j=0; j<bi->height; j++) {\n\t\tif(bi->packing_type==1 || bi->rowbytes<8) {\n\t\t\tbytecount = bi->rowbytes;\n\t\t}\n\t\telse if(bi->rowbytes > 250) {\n\t\t\tbytecount = de_getu16be(pos);\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\tbytecount = (i64)de_getbyte(pos);\n\t\t\tpos+=1;\n\t\t}\n\n\t\tif(bi->packing_type==1 || bi->rowbytes<8) {\n\t\t\tdbuf_copy(c->infile, pos, bytecount, unc_pixels);\n\t\t}\n\t\telse if(bi->packing_type==3 && bi->pixelsize==16) {\n\t\t\tstruct de_packbits_params pbparams;\n\n\t\t\tde_zeromem(&pbparams, sizeof(struct de_packbits_params));\n\t\t\tpbparams.is_packbits16 = 1;\n\t\t\tdcmpri.pos = pos;\n\t\t\tdcmpri.len = bytecount;\n\t\t\tfmtutil_decompress_packbits_ex(c, &dcmpri, &dcmpro, &dres, &pbparams);\n\t\t}\n\t\telse {\n\t\t\tdcmpri.pos = pos;\n\t\t\tdcmpri.len = bytecount;\n\t\t\tfmtutil_decompress_packbits_ex(c, &dcmpri, &dcmpro, &dres, NULL);\n\t\t}\n\n\t\t// Make sure the data decompressed to the right number of bytes.\n\t\tif(unc_pixels->len != (j+1)*bi->rowspan) {\n\t\t\tdbuf_truncate(unc_pixels, (j+1)*bi->rowspan);\n\t\t}\n\n\t\tpos += bytecount;\n\t}\n\n\tdst_nsamples = 3;\n\tif(bi->uses_pal) {\n\t\tif(de_is_grayscale_palette(bi->pal, bi->num_pal_entries)) {\n\t\t\tdst_nsamples = 1;\n\t\t}\n\t}\n\n\timg = de_bitmap_create2(c, bi->npwidth, bi->pdwidth, bi->height, dst_nsamples);\n\n\tfi = de_finfo_create(c);\n\n\tif(bi->hdpi>=1.0 && bi->vdpi>=1.0) {\n\t\tfi->density.code = DE_DENSITY_DPI;\n\t\tfi->density.xdens = bi->hdpi;\n\t\tfi->density.ydens = bi->vdpi;\n\t}\n\n\tif(bi->uses_pal) {\n\t\tdecode_bitmap_paletted(c, d, bi, unc_pixels, img, pos);\n\t}\n\telse {\n\t\tif(bi->pixelsize==16) {\n\t\t\tdecode_bitmap_rgb16(c, d, bi, unc_pixels, img, pos);\n\t\t}\n\t\telse {\n\t\t\tdecode_bitmap_rgb24(c, d, bi, unc_pixels, img, pos);\n\t\t}\n\t}\n\n\tde_bitmap_write_to_file_finfo(img, fi, 0);\n\n\tde_bitmap_destroy(img);\n\tde_finfo_destroy(c, fi);\n\tdbuf_close(unc_pixels);\n\treturn 1;\n}\n\nstatic int decode_pixdata(deark *c, lctx *d, struct fmtutil_macbitmap_info *bi, i64 pos)\n{\n\tint retval = 0;\n\n\tde_dbg_indent(c, 1);\n\n\tif(bi->npwidth==0 || bi->height==0) {\n\t\tde_warn(c, \"Ignoring zero-size bitmap (%d\"DE_CHAR_TIMES\"%d)\",\n\t\t\t(int)bi->npwidth, (int)bi->height);\n\t\tgoto done;\n\t}\n\tif(!de_good_image_dimensions(c, bi->npwidth, bi->height)) goto done;\n\n\tif(bi->pixelsize!=1 && bi->pixelsize!=2 && bi->pixelsize!=4 && bi->pixelsize!=8 &&\n\t\tbi->pixelsize!=16 && bi->pixelsize!=24 && bi->pixelsize!=32)\n\t{\n\t\tde_err(c, \"%d bits/pixel images are not supported\", (int)bi->pixelsize);\n\t\tgoto done;\n\t}\n\tif((bi->uses_pal && bi->pixeltype!=0) || (!bi->uses_pal && bi->pixeltype!=16)) {\n\t\tde_err(c, \"Pixel type %d is not supported\", (int)bi->pixeltype);\n\t\tgoto done;\n\t}\n\tif(bi->cmpcount!=1 && bi->cmpcount!=3 && bi->cmpcount!=4) {\n\t\tde_err(c, \"Component count %d is not supported\", (int)bi->cmpcount);\n\t\tgoto done;\n\t}\n\tif(bi->cmpsize!=1 && bi->cmpsize!=2 && bi->cmpsize!=4 && bi->cmpsize!=5 &&\n\t\tbi->cmpsize!=8)\n\t{\n\t\tde_err(c, \"%d-bit components are not supported\", (int)bi->cmpsize);\n\t\tgoto done;\n\t}\n\tif(bi->packing_type!=0 && bi->packing_type!=1 && bi->packing_type!=3 && bi->packing_type!=4) {\n\t\tde_err(c, \"Packing type %d is not supported\", (int)bi->packing_type);\n\t\tgoto done;\n\t}\n\tif((bi->uses_pal &&\n\t\t(bi->packing_type==0 || bi->packing_type==1) &&\n\t\t(bi->pixelsize==1 || bi->pixelsize==2 || bi->pixelsize==4 || bi->pixelsize==8) &&\n\t\tbi->cmpcount==1 && bi->cmpsize==bi->pixelsize) ||\n\t\t(!bi->uses_pal && bi->packing_type==3 && bi->pixelsize==16 && bi->cmpcount==3 && bi->cmpsize==5) ||\n\t\t(!bi->uses_pal && bi->packing_type==4 && bi->pixelsize==32 && bi->cmpcount==3 && bi->cmpsize==8) ||\n\t\t(!bi->uses_pal && bi->packing_type==4 && bi->pixelsize==32 && bi->cmpcount==4 && bi->cmpsize==8))\n\t{\n\t\t;\n\t}\n\telse {\n\t\tde_err(c, \"This type of image is not supported\");\n\t\tgoto done;\n\t}\n\n\tif(bi->cmpcount==4) {\n\t\tde_warn(c, \"This image might have transparency, which is not supported.\");\n\t}\n\n\tdecode_bitmap(c, d, bi, pos);\n\ndone:\n\tde_dbg_indent(c, -1);\n\treturn retval;\n}\n\n// For opcodes 0x90, 0x91, 0x98, 0x99, 0x9a, 0x9b\nstatic int handler_98_9a(deark *c, lctx *d, i64 opcode, i64 pos1, i64 *bytes_used)\n{\n\tstruct fmtutil_macbitmap_info *bi = NULL;\n\ti64 pixdata_size = 0;\n\ti64 colortable_size = 0;\n\tint retval = 0;\n\ti64 pos;\n\n\tbi = de_malloc(c, sizeof(struct fmtutil_macbitmap_info));\n\tpos = pos1;\n\n\tif(opcode==0x9a || opcode==0x9b) {\n\t\tfmtutil_macbitmap_read_baseaddr(c, c->infile, bi, pos);\n\t\tpos += 4;\n\t}\n\n\tfmtutil_macbitmap_read_rowbytes_and_bounds(c, c->infile, bi, pos);\n\tpos += 10;\n\n\tif(bi->pixmap_flag) {\n\t\tfmtutil_macbitmap_read_pixmap_only_fields(c, c->infile, bi, pos);\n\t\tpos += 36;\n\t}\n\n\tif((opcode==0x90 || opcode==0x91 || opcode==0x98 || opcode==0x99) && bi->pixmap_flag) {\n\t\t// Prepare to read the palette\n\t\tbi->uses_pal = 1;\n\t\tbi->has_colortable = 1;\n\t}\n\telse if((opcode==0x90 || opcode==0x91 || opcode==0x98 || opcode==0x99) && !bi->pixmap_flag) {\n\t\t// Settings implied by the lack of a PixMap header\n\t\tbi->pixelsize = 1;\n\t\tbi->cmpcount = 1;\n\t\tbi->cmpsize = 1;\n\t\tbi->uses_pal = 1;\n\t\tbi->num_pal_entries = 2;\n\t\tbi->pal[0] = DE_STOCKCOLOR_WHITE;\n\t\tbi->pal[1] = DE_STOCKCOLOR_BLACK;\n\t}\n\telse if((opcode==0x9a || opcode==0x9b) && !bi->pixmap_flag) {\n\t\tde_err(c, \"DirectBitsRect image without PixMap flag is not supported\");\n\t\tgoto done;\n\t}\n\n\tif(bi->has_colortable) {\n\t\tif(!fmtutil_macbitmap_read_colortable(c, c->infile, bi, pos, &colortable_size)) goto done;\n\t\tpos += colortable_size;\n\t}\n\n\tread_src_dst_mode(c, d, bi, pos);\n\tpos += 18;\n\n\tif(opcode==0x91 || opcode==0x99 || opcode==0x9b) {\n\t\ti64 rgnsize;\n\n\t\tde_dbg(c, \"region at %\"I64_FMT, pos);\n\t\tde_dbg_indent(c, 1);\n\t\trgnsize = de_getu16be(pos);\n\t\tde_dbg(c, \"region size: %d\", (int)rgnsize);\n\t\tde_dbg_indent(c, -1);\n\t\tif(rgnsize<2) goto done;\n\t\tpos += rgnsize;\n\t\tif(!c->padpix) {\n\t\t\tde_info(c, \"Note: Ignoring clipping region. Output image might have \"\n\t\t\t\t\"extraneous pixels.\");\n\t\t}\n\t}\n\n\tif(!get_pixdata_size(c, d, bi, pos, &pixdata_size)) {\n\t\tgoto done;\n\t}\n\tdecode_pixdata(c, d, bi, pos);\n\tpos += pixdata_size;\n\n\t*bytes_used = pos - pos1;\n\n\tretval = 1;\n\ndone:\n\tde_free(c, bi);\n\treturn retval;\n}\n\nstatic int handler_pixpat(deark *c, lctx *d, i64 opcode, i64 pos1, i64 *bytes_used)\n{\n\tunsigned int pattype;\n\ti64 pos = pos1;\n\tint needmsg = 1;\n\tint retval = 0;\n\ti64 colortable_size = 0;\n\ti64 pixdata_size = 0;\n\tstruct fmtutil_macbitmap_info *bi = NULL;\n\n\tpattype = (unsigned int)de_getu16be_p(&pos);\n\tde_dbg(c, \"PatType: %u\", pattype);\n\tpos += 8; // Pat1Data\n\n\tif(pattype==2) { // ditherPat(?)\n\t\tpos += 6; // RGB\n\t\tretval = 1;\n\t\tgoto done;\n\t}\n\n\tbi = de_malloc(c, sizeof(struct fmtutil_macbitmap_info));\n\n\tfmtutil_macbitmap_read_rowbytes_and_bounds(c, c->infile, bi, pos);\n\tpos += 10;\n\tfmtutil_macbitmap_read_pixmap_only_fields(c, c->infile, bi, pos);\n\tpos += 36;\n\n\tbi->uses_pal = 1;\n\tif(!fmtutil_macbitmap_read_colortable(c, c->infile, bi, pos, &colortable_size)) goto done;\n\tpos += colortable_size;\n\n\tif(!get_pixdata_size(c, d, bi, pos, &pixdata_size)) {\n\t\tgoto done;\n\t}\n\t// Note: We could extract the \"PixMap\" pattern easily enough here, by calling\n\t// decode_pixdata(). But if we do that, maybe we should also extract the\n\t// Pat1Data data above, as well as other opcodes like BkPat.\n\tpos += pixdata_size;\n\tretval = 1;\n\ndone:\n\tif(!retval && needmsg) {\n\t\tde_err(c, \"Failed to parse PixPat data\");\n\t}\n\tif(retval) {\n\t\t*bytes_used = pos - pos1;\n\t}\n\tde_free(c, bi);\n\treturn retval;\n}\n\nstatic void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\n\tif(selector!=1) {\n\t\t// If this is not a Continuation segment, close any current file.\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\n\tif(selector==0) { // Beginning segment\n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\n\tif(selector==0 || selector==1) {\n\t\t// Beginning and Continuation segments normally have profile data.\n\t\t// End segments (selector==2) are not allowed to include data.\n\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}\n\n// ShortComment\nstatic int handler_a0(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\tkind = de_getu16be(data_pos);\n\tde_dbg(c, \"comment kind: %d\", (int)kind);\n\treturn 1;\n}\n\n// LongComment\nstatic int handler_a1(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 kind;\n\ti64 len;\n\n\tkind = de_getu16be(data_pos);\n\tlen = de_getu16be(data_pos+2);\n\tde_dbg(c, \"comment kind: %d, size: %d\", (int)kind, (int)len);\n\t*bytes_used = 4+len;\n\n\tif(kind==100 && len>=4) {\n\t\tstruct de_fourcc sig4cc;\n\n\t\tdbuf_read_fourcc(c->infile, data_pos+4, &sig4cc, 4, 0x0);\n\t\tde_dbg(c, \"application comment, signature=0x%08x '%s'\",\n\t\t\t(unsigned int)sig4cc.id, sig4cc.id_dbgstr);\n\t\tde_dbg_hexdump(c, c->infile, data_pos+8, len-4, 256, NULL, 0x1);\n\t}\n\telse if(kind==224) {\n\t\tdo_iccprofile_item(c, d, data_pos+4, len);\n\t}\n\telse {\n\t\tde_dbg_hexdump(c, c->infile, data_pos+4, len, 256, NULL, 0x1);\n\t}\n\n\treturn 1;\n}\n\n// HeaderOp\nstatic int handler_0c00(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 hdrver;\n\tdouble hres, vres;\n\tstruct pict_rect srcrect;\n\n\thdrver = de_getu16be(data_pos);\n\td->is_extended_v2 = (hdrver==0xfffe);\n\n\tde_dbg(c, \"extended v2: %s\", d->is_extended_v2?\"yes\":\"no\");\n\tif(d->is_extended_v2) {\n\t\thres = pict_read_fixed(c->infile, data_pos+4);\n\t\tvres = pict_read_fixed(c->infile, data_pos+8);\n\t\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", hres, vres);\n\t\tpict_read_rect(c->infile, data_pos+12, &srcrect, \"srcRect\");\n\t}\n\n\treturn 1;\n}\n\nstatic void do_handle_qtif_idsc(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 idsc_dpos, idsc_dlen;\n\ti64 idat_dpos, idat_dlen;\n\tdbuf *outf = NULL;\n\tstruct de_fourcc cmpr4cc;\n\n\tif(d->decode_qtif) {\n\t\tde_run_module_by_id_on_slice2(c, \"qtif\", \"I\", c->infile, pos, len);\n\t\treturn;\n\t}\n\n\t// Try to construct a .qtif file.\n\t// This way, we do something potentially useful even if the image has\n\t// a compression scheme that our qtif module doesn't support.\n\n\tidsc_dpos = pos;\n\tidsc_dlen = de_getu32be(idsc_dpos);\n\tde_dbg(c, \"idsc: pos=%\"I64_FMT\", len=%\"I64_FMT, idsc_dpos, idsc_dlen);\n\tif(idsc_dpos+idsc_dlen > pos+len) goto done;\n\n\tdbuf_read_fourcc(c->infile, idsc_dpos+4, &cmpr4cc, 4, 0x0);\n\tde_dbg(c, \"compression type: \\\"%s\\\"\", cmpr4cc.id_dbgstr);\n\n\tidat_dpos = idsc_dpos + idsc_dlen;\n\tidat_dlen = de_getu32be(idsc_dpos+44);\n\tde_dbg(c, \"idat: pos=%\"I64_FMT\", len=%\"I64_FMT, idat_dpos, idat_dlen);\n\tif(idat_dlen==0) {\n\t\tidat_dlen = pos+len-idat_dpos; // ??\n\t}\n\tif(idat_dpos+idat_dlen > pos+len) goto done;\n\n#define CODE_idat 0x69646174U\n#define CODE_idsc 0x69647363U\n\toutf = dbuf_create_output_file(c, \"qtif\", NULL, 0);\n\n\tdbuf_writeu32be(outf, 8+idsc_dlen);\n\tdbuf_writeu32be(outf, CODE_idsc);\n\tdbuf_copy(c->infile, idsc_dpos, idsc_dlen, outf);\n\n\tdbuf_writeu32be(outf, 8+idat_dlen);\n\tdbuf_writeu32be(outf, CODE_idat);\n\tdbuf_copy(c->infile, idat_dpos, idat_dlen, outf);\n\ndone:\n\tdbuf_close(outf);\n}\n\n// CompressedQuickTime (0x8200) & UncompressedQuickTime (0x8201)\nstatic int handler_QuickTime(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)\n{\n\ti64 payload_pos;\n\ti64 payload_len;\n\ti64 endpos;\n\ti64 idsc_pos;\n\n\tpayload_len = de_getu32be(data_pos);\n\tpayload_pos = data_pos+4;\n\tde_dbg(c, \"payload: pos=%\"I64_FMT\", len=%\"I64_FMT, payload_pos, payload_len);\n\tendpos = payload_pos+payload_len;\n\tif(endpos > c->infile->len) return 0;\n\t*bytes_used = 4+payload_len;\n\n\t// Following the size field seems to be 68 or 50 bytes of data,\n\t// followed by QuickTime \"idsc\" data, followed by image data.\n\tidsc_pos = payload_pos + ((opcode==0x8201) ? 50 : 68);\n\n\tdo_handle_qtif_idsc(c, d, idsc_pos, endpos-idsc_pos);\n\treturn 1;\n}\n\nstatic const struct opcode_info opcode_info_arr[] = {\n\t// TODO: This list might not be complete, and it needs to be complete in\n\t// order to parse all PICT files.\n\t// Note that some opcode ranges are handled in do_handle_item().\n\t{ 0x0000, SZCODE_EXACT,   0,  \"NOP\", NULL },\n\t{ 0x0001, SZCODE_REGION,  0,  \"Clip\", NULL },\n\t{ 0x0002, SZCODE_EXACT,   8,  \"BkPat\", NULL },\n\t{ 0x0003, SZCODE_EXACT,   2,  \"TxFont\", NULL },\n\t{ 0x0004, SZCODE_EXACT,   1,  \"TxFace\", NULL },\n\t{ 0x0005, SZCODE_EXACT,   2,  \"TxMode\", NULL },\n\t{ 0x0006, SZCODE_EXACT,   4,  \"SpExtra\", NULL },\n\t{ 0x0007, SZCODE_EXACT,   4,  \"PnSize\", NULL },\n\t{ 0x0008, SZCODE_EXACT,   2,  \"PnMode\", NULL },\n\t{ 0x0009, SZCODE_EXACT,   8,  \"PnPat\", NULL },\n\t{ 0x000a, SZCODE_EXACT,   8,  \"FillPat\", NULL },\n\t{ 0x000b, SZCODE_EXACT,   4,  \"OvSize\", NULL },\n\t{ 0x000c, SZCODE_EXACT,   4,  \"Origin\", NULL },\n\t{ 0x000d, SZCODE_EXACT,   2,  \"TxSize\", NULL },\n\t{ 0x000e, SZCODE_EXACT,   4,  \"FgColor\", NULL },\n\t{ 0x000f, SZCODE_EXACT,   4,  \"BkColor\", NULL },\n\t{ 0x0010, SZCODE_EXACT,   8,  \"TxRatio\", NULL },\n\t{ 0x0011, SZCODE_EXACT,   1,  \"Version\", handler_11 },\n\t{ 0x0012, SZCODE_SPECIAL, 0,  \"BkPixPat\", handler_pixpat },\n\t{ 0x0013, SZCODE_SPECIAL, 0,  \"PnPixPat\", handler_pixpat },\n\t{ 0x0014, SZCODE_SPECIAL, 0,  \"FillPixPat\", handler_pixpat },\n\t{ 0x0015, SZCODE_EXACT,   2,  \"PnLocHFrac\", NULL },\n\t{ 0x0016, SZCODE_EXACT,   2,  \"ChExtra\", NULL },\n\t{ 0x001a, SZCODE_EXACT,   6,  \"RGBFgCol\", handler_RGBColor },\n\t{ 0x001b, SZCODE_EXACT,   6,  \"RGBBkCol\", handler_RGBColor },\n\t{ 0x001c, SZCODE_EXACT,   0,  \"HiliteMode\", NULL },\n\t{ 0x001d, SZCODE_EXACT,   6,  \"HiliteColor\", handler_RGBColor },\n\t{ 0x001e, SZCODE_EXACT,   0,  \"DefHilite\", NULL },\n\t{ 0x001f, SZCODE_EXACT,   6,  \"OpColor\", handler_RGBColor },\n\t{ 0x0020, SZCODE_EXACT,   8,  \"Line\", NULL },\n\t{ 0x0021, SZCODE_EXACT,   4,  \"LineFrom\", NULL },\n\t{ 0x0022, SZCODE_EXACT,   6,  \"ShortLine\", NULL },\n\t{ 0x0023, SZCODE_EXACT,   2,  \"ShortLineFrom\", NULL },\n\t{ 0x0028, SZCODE_SPECIAL, 0,  \"LongText\", handler_28 },\n\t{ 0x0029, SZCODE_SPECIAL, 0,  \"DHText\", handler_DxText },\n\t{ 0x002a, SZCODE_SPECIAL, 0,  \"DVText\", handler_DxText },\n\t{ 0x002b, SZCODE_SPECIAL, 0,  \"DHDVText\", handler_2b },\n\t{ 0x002c, SZCODE_SPECIAL, 0,  \"fontName\", handler_2c },\n\t{ 0x002d, SZCODE_SPECIAL, 0,  \"lineJustify\", NULL },\n\t{ 0x002e, SZCODE_SPECIAL, 0,  \"glyphState\", NULL },\n\t{ 0x0030, SZCODE_EXACT,   8,  \"frameRect\", handler_Rectangle },\n\t{ 0x0031, SZCODE_EXACT,   8,  \"paintRect\", handler_Rectangle },\n\t{ 0x0032, SZCODE_EXACT,   8,  \"eraseRect\", handler_Rectangle },\n\t{ 0x0033, SZCODE_EXACT,   8,  \"invertRect\", handler_Rectangle },\n\t{ 0x0034, SZCODE_EXACT,   8,  \"fillRect\", handler_Rectangle },\n\t{ 0x0038, SZCODE_EXACT,   0,  \"frameSameRect\", NULL },\n\t{ 0x0039, SZCODE_EXACT,   0,  \"paintSameRect\", NULL },\n\t{ 0x003a, SZCODE_EXACT,   0,  \"eraseSameRect\", NULL },\n\t{ 0x003b, SZCODE_EXACT,   0,  \"invertSameRect\", NULL },\n\t{ 0x003c, SZCODE_EXACT,   0,  \"fillSameRect\", NULL },\n\t{ 0x0040, SZCODE_EXACT,   8,  \"frameRRect\", handler_Rectangle },\n\t{ 0x0041, SZCODE_EXACT,   8,  \"paintRRect\", handler_Rectangle },\n\t{ 0x0042, SZCODE_EXACT,   8,  \"eraseRRect\", handler_Rectangle },\n\t{ 0x0043, SZCODE_EXACT,   8,  \"invertRRect\", handler_Rectangle },\n\t{ 0x0044, SZCODE_EXACT,   8,  \"fillRRect\", handler_Rectangle },\n\t{ 0x0048, SZCODE_EXACT,   0,  \"frameSameRRect\", NULL },\n\t{ 0x0049, SZCODE_EXACT,   0,  \"paintSameRRect\", NULL },\n\t{ 0x004a, SZCODE_EXACT,   0,  \"eraseSameRRect\", NULL },\n\t{ 0x004b, SZCODE_EXACT,   0,  \"invertSameRRect\", NULL },\n\t{ 0x004c, SZCODE_EXACT,   0,  \"fillSameRRect\", NULL },\n\t{ 0x0050, SZCODE_EXACT,   8,  \"frameOval\", handler_Rectangle },\n\t{ 0x0051, SZCODE_EXACT,   8,  \"paintOval\", handler_Rectangle },\n\t{ 0x0052, SZCODE_EXACT,   8,  \"eraseOval\", handler_Rectangle },\n\t{ 0x0053, SZCODE_EXACT,   8,  \"invertOval\", handler_Rectangle },\n\t{ 0x0054, SZCODE_EXACT,   8,  \"fillOval\", handler_Rectangle },\n\t{ 0x0058, SZCODE_EXACT,   0,  \"frameSameOval\", NULL },\n\t{ 0x0059, SZCODE_EXACT,   0,  \"paintSameOval\", NULL },\n\t{ 0x005a, SZCODE_EXACT,   0,  \"eraseSameOval\", NULL },\n\t{ 0x005b, SZCODE_EXACT,   0,  \"invertSameOval\", NULL },\n\t{ 0x005c, SZCODE_EXACT,   0,  \"fillSameOval\", NULL },\n\t{ 0x0060, SZCODE_EXACT,   12, \"frameArc\", NULL },\n\t{ 0x0061, SZCODE_EXACT,   12, \"paintArc\", NULL },\n\t{ 0x0062, SZCODE_EXACT,   12, \"eraseArc\", NULL },\n\t{ 0x0063, SZCODE_EXACT,   12, \"invertArc\", NULL },\n\t{ 0x0064, SZCODE_EXACT,   12, \"fillArc\", NULL },\n\t{ 0x0068, SZCODE_EXACT,   4,  \"frameSameArc\", NULL },\n\t{ 0x0069, SZCODE_EXACT,   4,  \"paintSameArc\", NULL },\n\t{ 0x006a, SZCODE_EXACT,   4,  \"eraseSameArc\", NULL },\n\t{ 0x006b, SZCODE_EXACT,   4,  \"invertSameArc\", NULL },\n\t{ 0x006c, SZCODE_EXACT,   4,  \"fillSameArc\", NULL },\n\t{ 0x0080, SZCODE_REGION,  0,  \"frameRgn\", NULL },\n\t{ 0x0081, SZCODE_REGION,  0,  \"paintRgn\", NULL },\n\t{ 0x0082, SZCODE_REGION,  0,  \"eraseRgn\", NULL },\n\t{ 0x0083, SZCODE_REGION,  0,  \"invertRgn\", NULL },\n\t{ 0x0084, SZCODE_REGION,  0,  \"fillRgn\", NULL },\n\t{ 0x0070, SZCODE_POLYGON, 0,  \"framePoly\", NULL },\n\t{ 0x0071, SZCODE_POLYGON, 0,  \"paintPoly\", NULL },\n\t{ 0x0072, SZCODE_POLYGON, 0,  \"erasePoly\", NULL },\n\t{ 0x0073, SZCODE_POLYGON, 0,  \"invertPoly\", NULL },\n\t{ 0x0074, SZCODE_POLYGON, 0,  \"fillPoly\", NULL },\n\t{ 0x0090, SZCODE_SPECIAL, 0,  \"BitsRect\", handler_98_9a },\n\t{ 0x0091, SZCODE_SPECIAL, 0,  \"BitsRgn\", handler_98_9a },\n\t{ 0x0098, SZCODE_SPECIAL, 0,  \"PackBitsRect\", handler_98_9a },\n\t{ 0x0099, SZCODE_SPECIAL, 0,  \"PackBitsRgn\", handler_98_9a },\n\t{ 0x009a, SZCODE_SPECIAL, 0,  \"DirectBitsRect\", handler_98_9a },\n\t{ 0x009b, SZCODE_SPECIAL, 0,  \"DirectBitsRgn\", handler_98_9a },\n\t{ 0x00a0, SZCODE_EXACT,   2,  \"ShortComment\", handler_a0 },\n\t{ 0x00a1, SZCODE_SPECIAL, 0,  \"LongComment\", handler_a1 },\n\t{ 0x00ff, SZCODE_EXACT,   2,  \"opEndPic\", NULL },\n\t{ 0x0c00, SZCODE_EXACT,   24, \"HeaderOp\", handler_0c00 },\n\t{ 0x8200, SZCODE_SPECIAL, 0,  \"CompressedQuickTime\", handler_QuickTime },\n\t{ 0x8201, SZCODE_SPECIAL, 0,  \"UncompressedQuickTime\", handler_QuickTime }\n};\n\nstatic const struct opcode_info *find_opcode_info(i64 opcode)\n{\n\tsize_t i;\n\n\tfor(i=0; i<DE_ARRAYCOUNT(opcode_info_arr); i++) {\n\t\tif(opcode_info_arr[i].opcode == opcode) {\n\t\t\treturn &opcode_info_arr[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int do_handle_item(deark *c, lctx *d, i64 opcode_pos, i64 opcode,\n\t\t\t\t\t\t   i64 data_pos, i64 *data_bytes_used)\n{\n\tconst char *opcode_name;\n\tconst struct opcode_info *opi;\n\ti64 n;\n\tstruct pict_rect tmprect;\n\tint ret = 0;\n\n\t*data_bytes_used = 0;\n\n\topi = find_opcode_info(opcode);\n\tif(opi && opi->name) opcode_name = opi->name;\n\telse opcode_name = \"?\";\n\n\tif(d->version==2)\n\t\tde_dbg(c, \"opcode 0x%04x (%s) at %d\", (unsigned int)opcode, opcode_name, (int)opcode_pos);\n\telse\n\t\tde_dbg(c, \"opcode 0x%02x (%s) at %d\", (unsigned int)opcode, opcode_name, (int)opcode_pos);\n\n\tif(opi && opi->fn) {\n\t\tde_dbg_indent(c, 1);\n\t\t*data_bytes_used = opi->size; // Default to the size in the table.\n\t\tret = opi->fn(c, d, opcode, data_pos, data_bytes_used);\n\t\tde_dbg_indent(c, -1);\n\t}\n\telse if(opi && opi->size_code==SZCODE_EXACT) {\n\t\t*data_bytes_used = opi->size;\n\t\tret = 1;\n\t}\n\telse if(opi && opi->size_code==SZCODE_REGION) {\n\t\tn = de_getu16be(data_pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_dbg(c, \"region size: %d\", (int)n);\n\t\tif(n>=10) {\n\t\t\tpict_read_rect(c->infile, data_pos+2, &tmprect, \"rect\");\n\t\t}\n\t\tde_dbg_indent(c, -1);\n\t\t*data_bytes_used = n;\n\t\tret = 1;\n\t}\n\telse if(opi && opi->size_code==SZCODE_POLYGON) {\n\t\tn = de_getu16be(data_pos);\n\t\tde_dbg_indent(c, 1);\n\t\tde_dbg(c, \"polygon size: %d\", (int)n);\n\t\tde_dbg_indent(c, -1);\n\t\t*data_bytes_used = n;\n\t\tret = 1;\n\t}\n\telse if(opcode>=0x2c && opcode<=0x2f) {\n\t\t// Starts with 2-byte size, size does not include the \"size\" field.\n\t\tn = de_getu16be(data_pos);\n\t\t*data_bytes_used = 2+n;\n\t\tret = 1;\n\t}\n\telse if(opcode>=0x8100 && opcode<=0xffff) {\n\t\t// Starts with 4-byte size, size does not include the \"size\" field.\n\t\tn = de_getu32be(data_pos);\n\t\t*data_bytes_used = 4+n;\n\t\tret = 1;\n\t}\n\telse {\n\t\tde_err(c, \"Unsupported opcode: 0x%04x\", (unsigned int)opcode);\n\t}\n\n\treturn ret;\n}\n\nstatic void do_read_items(deark *c, lctx *d, i64 pos)\n{\n\ti64 opcode;\n\ti64 opcode_pos;\n\ti64 bytes_used;\n\tint ret;\n\n\twhile(1) {\n\t\tif(pos%2 && d->version==2) {\n\t\t\tpos++; // 2-byte alignment\n\t\t}\n\n\t\tif(pos >= c->infile->len) break;\n\n\t\topcode_pos = pos;\n\n\t\tif(d->version==2) {\n\t\t\topcode = de_getu16be(pos);\n\t\t\tpos+=2;\n\t\t}\n\t\telse {\n\t\t\topcode = (i64)de_getbyte(pos);\n\t\t\tpos+=1;\n\t\t}\n\n\t\tret = do_handle_item(c, d, opcode_pos, opcode, pos, &bytes_used);\n\t\tif(!ret) goto done;\n\t\tif(opcode==0x00ff) goto done; // End of image\n\n\t\tpos += bytes_used;\n\t}\ndone:\n\t;\n}\n\n// mode: 0=called from de_identify..., 1=called from de_run...\nstatic void do_detect_version(deark *c, struct detection_info *dti, int mode)\n{\n\tstatic const u8 v1pattern[2] = { 0x11, 0x01 };\n\tstatic const u8 v2pattern[6] = { 0x00, 0x11, 0x02, 0xff, 0x0c, 0x00 };\n\tu8 buf[6];\n\tint v1_nohdr = 0;\n\tint v2_nohdr = 0;\n\tint v1_hdr = 0;\n\tint v2_hdr = 0;\n\n\tdti->file_version = 0;\n\tdti->has_fileheader = 0;\n\n\tde_read(buf, 522, sizeof(buf));\n\tif(!de_memcmp(buf, v2pattern, 6)) {\n\t\tv2_hdr = 1;\n\t}\n\telse if(!de_memcmp(buf, v1pattern, 2)) {\n\t\tv1_hdr = 1;\n\t}\n\telse {\n\t\tde_read(buf, 10, sizeof(buf));\n\t\tif(!de_memcmp(buf, v2pattern, 6)) {\n\t\t\tv2_nohdr = 1;\n\t\t}\n\t\telse if(!de_memcmp(buf, v1pattern, 2)) {\n\t\t\tv1_nohdr = 1;\n\t\t}\n\t}\n\n\tif(!v1_hdr && !v2_hdr && !v1_nohdr && !v2_nohdr) {\n\t\treturn;\n\t}\n\n\tif(v2_hdr) {\n\t\tdti->file_version = 2;\n\t\tdti->has_fileheader = 1;\n\t\treturn;\n\t}\n\telse if(v2_nohdr) {\n\t\tdti->file_version = 2;\n\t\treturn;\n\t}\n\n\tif(mode==0) {\n\t\t// For v1, check that the file ends as expected\n\t\tde_read(buf, c->infile->len-2, 2);\n\t\tif(buf[1]==0xff) {\n\t\t\t; // v1 files should end with 0xff\n\t\t}\n\t\telse if(buf[0]==0xff && buf[1]==0x00) {\n\t\t\t; // But a few have an extra NUL byte at the end\n\t\t}\n\t}\n\n\tif(v1_hdr) {\n\t\tdti->file_version = 1;\n\t\tdti->has_fileheader = 1;\n\t\treturn;\n\t}\n\telse if(v1_nohdr) {\n\t\tdti->file_version = 1;\n\t\treturn;\n\t}\n}\n\nstatic void de_run_pict(deark *c, de_module_params *mparams)\n{\n\tlctx *d = NULL;\n\ti64 pos = 0;\n\ti64 picsize;\n\tstruct pict_rect framerect;\n\n\td = de_malloc(c, sizeof(lctx));\n\n\tdo_detect_version(c, &d->dti, 1);\n\tif(d->dti.file_version>0) {\n\t\tde_declare_fmtf(c, \"PICT v%d%s\", d->dti.file_version,\n\t\t\td->dti.has_fileheader?\"\":\", without file header\");\n\t}\n\n\td->version = 1;\n\n\tif(d->dti.has_fileheader) {\n\t\tpos += 512;\n\t}\n\n\tpicsize = de_getu16be(pos);\n\tde_dbg(c, \"picSize: %d\", (int)picsize);\n\tpos+=2;\n\tpict_read_rect(c->infile, pos, &framerect, \"picFrame\");\n\tpos+=8;\n\n\tdo_read_items(c, d, pos);\n\n\tdbuf_close(d->iccprofile_file);\n\tde_free(c, d);\n}\n\nstatic int de_identify_pict(deark *c)\n{\n\tstruct detection_info dti;\n\n\tdo_detect_version(c, &dti, 0);\n\tif(dti.file_version==2) {\n\t\treturn 85;\n\t}\n\telse if(dti.file_version==1) {\n\t\tif(dti.has_fileheader) return 25;\n\t\treturn 15;\n\t}\n\treturn 0;\n}\n\nvoid de_module_pict(deark *c, struct deark_module_info *mi)\n{\n\tmi->id = \"pict\";\n\tmi->desc = \"Macintosh PICT\";\n\tmi->run_fn = de_run_pict;\n\tmi->identify_fn = de_identify_pict;\n}\n"], "filenames": ["modules/pict.c"], "buggy_code_start_loc": [662], "buggy_code_end_loc": [662], "fixing_code_start_loc": [663], "fixing_code_end_loc": [668], "type": "CWE-476", "message": "In Deark before 1.5.8, a specially crafted input file can cause a NULL pointer dereference in the dbuf_write function (src/deark-dbuf.c).", "other": {"cve": {"id": "CVE-2021-28855", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-14T17:15:14.363", "lastModified": "2021-04-19T21:28:29.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Deark before 1.5.8, a specially crafted input file can cause a NULL pointer dereference in the dbuf_write function (src/deark-dbuf.c)."}, {"lang": "es", "value": "En Deark versiones anteriores a 15.8, un archivo de entrada especialmente dise\u00f1ado puede causar una desreferencia del puntero NULL en la funci\u00f3n dbuf_write (en el archivo src/deark-dbuf.c)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:deark:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.8", "matchCriteriaId": "DDEFD567-5B77-4505-9D83-F9A2EF0BBAB3"}]}]}], "references": [{"url": "https://fatihhcelik.github.io/posts/NULL-Pointer-Dereference-Deark/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jsummers/deark/commit/287f5ac31dfdc074669182f51ece637706070eeb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/deark/commit/287f5ac31dfdc074669182f51ece637706070eeb"}}