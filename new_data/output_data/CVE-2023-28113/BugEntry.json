{"buggy_code": ["use std::ops::Shl;\n\nuse hex_literal::hex;\nuse num_bigint::{BigUint, RandBigInt};\nuse rand;\n\npub struct DhGroup {\n    pub(crate) prime: &'static [u8],\n    pub(crate) generator: usize,\n    pub(crate) exp_size: u64,\n}\n\npub const DH_GROUP1: DhGroup = DhGroup {\n    prime: hex!(\n        \"\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n         29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n         EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\n         E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED\n         EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381\n         FFFFFFFF FFFFFFFF\n        \"\n    )\n    .as_slice(),\n    generator: 2,\n    exp_size: 256,\n};\n\npub const DH_GROUP14: DhGroup = DhGroup {\n    prime: hex!(\n        \"\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n        29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n        EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\n        E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED\n        EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D\n        C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F\n        83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D\n        670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B\n        E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9\n        DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510\n        15728E5A 8AACAA68 FFFFFFFF FFFFFFFF\n        \"\n    )\n    .as_slice(),\n    generator: 2,\n    exp_size: 256,\n};\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct DH {\n    prime_num: BigUint,\n    generator: usize,\n    exp_size: u64,\n    private_key: BigUint,\n    public_key: BigUint,\n    shared_secret: BigUint,\n}\n\nimpl DH {\n    pub fn new(group: &DhGroup) -> Self {\n        Self {\n            prime_num: BigUint::from_bytes_be(group.prime),\n            generator: group.generator,\n            exp_size: group.exp_size,\n            private_key: BigUint::default(),\n            public_key: BigUint::default(),\n            shared_secret: BigUint::default(),\n        }\n    }\n\n    pub fn generate_private_key(&mut self) -> BigUint {\n        let mut rng = rand::thread_rng();\n        self.private_key = rng.gen_biguint((self.exp_size * 8) - 2u64).shl(1);\n        self.private_key.clone()\n    }\n\n    pub fn generate_public_key(&mut self) -> BigUint {\n        self.public_key = BigUint::from(self.generator).modpow(&self.private_key, &self.prime_num);\n        self.public_key.clone()\n    }\n\n    pub fn compute_shared_secret(&mut self, other_public_key: BigUint) -> BigUint {\n        self.shared_secret = other_public_key.modpow(&self.private_key, &self.prime_num);\n        self.shared_secret.clone()\n    }\n\n    pub fn decode_public_key(buffer: &[u8]) -> BigUint {\n        BigUint::from_bytes_be(buffer)\n    }\n}\n", "mod groups;\nuse std::marker::PhantomData;\n\nuse byteorder::{BigEndian, ByteOrder};\nuse digest::Digest;\nuse groups::DH;\nuse num_bigint::BigUint;\nuse russh_cryptovec::CryptoVec;\nuse russh_keys::encoding::Encoding;\nuse sha1::Sha1;\nuse sha2::Sha256;\n\nuse self::groups::{DhGroup, DH_GROUP1, DH_GROUP14};\nuse super::{compute_keys, KexAlgorithm, KexType};\nuse crate::session::Exchange;\nuse crate::{cipher, mac, msg};\n\npub struct DhGroup1Sha1KexType {}\n\nimpl KexType for DhGroup1Sha1KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha1>::new(&DH_GROUP1)) as Box<dyn KexAlgorithm + Send>\n    }\n}\npub struct DhGroup14Sha1KexType {}\n\nimpl KexType for DhGroup14Sha1KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha1>::new(&DH_GROUP14)) as Box<dyn KexAlgorithm + Send>\n    }\n}\npub struct DhGroup14Sha256KexType {}\n\nimpl KexType for DhGroup14Sha256KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha256>::new(&DH_GROUP14)) as Box<dyn KexAlgorithm + Send>\n    }\n}\n\n#[doc(hidden)]\npub struct DhGroupKex<D: Digest> {\n    dh: DH,\n    shared_secret: Option<Vec<u8>>,\n    _digest: PhantomData<D>,\n}\n\nimpl<D: Digest> DhGroupKex<D> {\n    pub fn new(group: &DhGroup) -> DhGroupKex<D> {\n        let dh = DH::new(group);\n        DhGroupKex {\n            dh,\n            shared_secret: None,\n            _digest: PhantomData,\n        }\n    }\n}\n\nimpl<D: Digest> std::fmt::Debug for DhGroupKex<D> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(\n            f,\n            \"Algorithm {{ local_secret: [hidden], shared_secret: [hidden] }}\",\n        )\n    }\n}\n\nfn biguint_to_mpint(biguint: &BigUint) -> Vec<u8> {\n    let mut mpint = Vec::new();\n    let bytes = biguint.to_bytes_be();\n    if let Some(b) = bytes.first() {\n        if b > &0x7f {\n            mpint.push(0);\n        }\n    }\n    mpint.extend(&bytes);\n    mpint\n}\n\nimpl<D: Digest> KexAlgorithm for DhGroupKex<D> {\n    fn skip_exchange(&self) -> bool {\n        false\n    }\n\n    #[doc(hidden)]\n    fn server_dh(&mut self, exchange: &mut Exchange, payload: &[u8]) -> Result<(), crate::Error> {\n        debug!(\"server_dh\");\n\n        let client_pubkey = {\n            if payload.first() != Some(&msg::KEX_ECDH_INIT) {\n                return Err(crate::Error::Inconsistent);\n            }\n\n            #[allow(clippy::indexing_slicing)] // length checked\n            let pubkey_len = BigEndian::read_u32(&payload[1..]) as usize;\n\n            if payload.len() < 5 + pubkey_len {\n                return Err(crate::Error::Inconsistent);\n            }\n\n            &payload\n                .get(5..(5 + pubkey_len))\n                .ok_or(crate::Error::Inconsistent)?\n        };\n\n        debug!(\"client_pubkey: {:?}\", client_pubkey);\n\n        self.dh.generate_private_key();\n        let server_pubkey = biguint_to_mpint(&self.dh.generate_public_key());\n\n        // fill exchange.\n        exchange.server_ephemeral.clear();\n        exchange.server_ephemeral.extend(&server_pubkey);\n\n        let shared = self\n            .dh\n            .compute_shared_secret(DH::decode_public_key(client_pubkey));\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n\n    #[doc(hidden)]\n    fn client_dh(\n        &mut self,\n        client_ephemeral: &mut CryptoVec,\n        buf: &mut CryptoVec,\n    ) -> Result<(), crate::Error> {\n        self.dh.generate_private_key();\n        let client_pubkey = biguint_to_mpint(&self.dh.generate_public_key());\n\n        // fill exchange.\n        client_ephemeral.clear();\n        client_ephemeral.extend(&client_pubkey);\n\n        buf.push(msg::KEX_ECDH_INIT);\n        buf.extend_ssh_string(&client_pubkey);\n\n        Ok(())\n    }\n\n    fn compute_shared_secret(&mut self, remote_pubkey_: &[u8]) -> Result<(), crate::Error> {\n        let remote_pubkey = DH::decode_public_key(remote_pubkey_);\n        let shared = self.dh.compute_shared_secret(remote_pubkey);\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n\n    fn compute_exchange_hash(\n        &self,\n        key: &CryptoVec,\n        exchange: &Exchange,\n        buffer: &mut CryptoVec,\n    ) -> Result<CryptoVec, crate::Error> {\n        // Computing the exchange hash, see page 7 of RFC 5656.\n        buffer.clear();\n        buffer.extend_ssh_string(&exchange.client_id);\n        buffer.extend_ssh_string(&exchange.server_id);\n        buffer.extend_ssh_string(&exchange.client_kex_init);\n        buffer.extend_ssh_string(&exchange.server_kex_init);\n\n        buffer.extend(key);\n        buffer.extend_ssh_string(&exchange.client_ephemeral);\n        buffer.extend_ssh_string(&exchange.server_ephemeral);\n\n        if let Some(ref shared) = self.shared_secret {\n            buffer.extend_ssh_mpint(shared);\n        }\n\n        let mut hasher = D::new();\n        hasher.update(&buffer);\n\n        let mut res = CryptoVec::new();\n        res.extend(hasher.finalize().as_slice());\n        Ok(res)\n    }\n\n    fn compute_keys(\n        &self,\n        session_id: &CryptoVec,\n        exchange_hash: &CryptoVec,\n        cipher: cipher::Name,\n        remote_to_local_mac: mac::Name,\n        local_to_remote_mac: mac::Name,\n        is_server: bool,\n    ) -> Result<super::cipher::CipherPair, crate::Error> {\n        compute_keys::<D>(\n            self.shared_secret.as_deref(),\n            session_id,\n            exchange_hash,\n            cipher,\n            remote_to_local_mac,\n            local_to_remote_mac,\n            is_server,\n        )\n    }\n}\n"], "fixing_code": ["use hex_literal::hex;\nuse num_bigint::{BigUint, RandBigInt};\nuse rand;\n\npub struct DhGroup {\n    pub(crate) prime: &'static [u8],\n    pub(crate) generator: usize,\n    pub(crate) exp_size: u64,\n}\n\npub const DH_GROUP1: DhGroup = DhGroup {\n    prime: hex!(\n        \"\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n         29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n         EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\n         E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED\n         EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381\n         FFFFFFFF FFFFFFFF\n        \"\n    )\n    .as_slice(),\n    generator: 2,\n    exp_size: 256,\n};\n\npub const DH_GROUP14: DhGroup = DhGroup {\n    prime: hex!(\n        \"\n        FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n        29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\n        EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\n        E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED\n        EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D\n        C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F\n        83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D\n        670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3B\n        E39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9\n        DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA0510\n        15728E5A 8AACAA68 FFFFFFFF FFFFFFFF\n        \"\n    )\n    .as_slice(),\n    generator: 2,\n    exp_size: 256,\n};\n\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct DH {\n    prime_num: BigUint,\n    generator: usize,\n    exp_size: u64,\n    private_key: BigUint,\n    public_key: BigUint,\n    shared_secret: BigUint,\n}\n\nimpl DH {\n    pub fn new(group: &DhGroup) -> Self {\n        Self {\n            prime_num: BigUint::from_bytes_be(group.prime),\n            generator: group.generator,\n            exp_size: group.exp_size,\n            private_key: BigUint::default(),\n            public_key: BigUint::default(),\n            shared_secret: BigUint::default(),\n        }\n    }\n\n    pub fn generate_private_key(&mut self, is_server: bool) -> BigUint {\n        let q = (&self.prime_num - &BigUint::from(1u8)) / &BigUint::from(2u8);\n        let mut rng = rand::thread_rng();\n        self.private_key = rng.gen_biguint_range(\n            &if is_server {\n                1u8.into()\n            } else {\n                2u8.into()\n            },\n            &q,\n        );\n        self.private_key.clone()\n    }\n\n    pub fn generate_public_key(&mut self) -> BigUint {\n        self.public_key = BigUint::from(self.generator).modpow(&self.private_key, &self.prime_num);\n        self.public_key.clone()\n    }\n\n    pub fn compute_shared_secret(&mut self, other_public_key: BigUint) -> BigUint {\n        self.shared_secret = other_public_key.modpow(&self.private_key, &self.prime_num);\n        self.shared_secret.clone()\n    }\n\n    pub fn validate_shared_secret(&self, shared_secret: &BigUint) -> bool {\n        let one = BigUint::from(1u8);\n        let prime_minus_one = &self.prime_num - &one;\n\n        shared_secret > &one && shared_secret < &prime_minus_one\n    }\n\n    pub fn decode_public_key(buffer: &[u8]) -> BigUint {\n        BigUint::from_bytes_be(buffer)\n    }\n\n    pub fn validate_public_key(&self, public_key: &BigUint) -> bool {\n        let one = BigUint::from(1u8);\n        let prime_minus_one = &self.prime_num - &one;\n\n        public_key > &one && public_key < &prime_minus_one\n    }\n}\n", "mod groups;\nuse std::marker::PhantomData;\n\nuse byteorder::{BigEndian, ByteOrder};\nuse digest::Digest;\nuse groups::DH;\nuse log::debug;\nuse num_bigint::BigUint;\nuse russh_cryptovec::CryptoVec;\nuse russh_keys::encoding::Encoding;\nuse sha1::Sha1;\nuse sha2::Sha256;\n\nuse self::groups::{DhGroup, DH_GROUP1, DH_GROUP14};\nuse super::{compute_keys, KexAlgorithm, KexType};\nuse crate::session::Exchange;\nuse crate::{cipher, mac, msg};\n\npub struct DhGroup1Sha1KexType {}\n\nimpl KexType for DhGroup1Sha1KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha1>::new(&DH_GROUP1)) as Box<dyn KexAlgorithm + Send>\n    }\n}\npub struct DhGroup14Sha1KexType {}\n\nimpl KexType for DhGroup14Sha1KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha1>::new(&DH_GROUP14)) as Box<dyn KexAlgorithm + Send>\n    }\n}\npub struct DhGroup14Sha256KexType {}\n\nimpl KexType for DhGroup14Sha256KexType {\n    fn make(&self) -> Box<dyn KexAlgorithm + Send> {\n        Box::new(DhGroupKex::<Sha256>::new(&DH_GROUP14)) as Box<dyn KexAlgorithm + Send>\n    }\n}\n\n#[doc(hidden)]\npub struct DhGroupKex<D: Digest> {\n    dh: DH,\n    shared_secret: Option<Vec<u8>>,\n    _digest: PhantomData<D>,\n}\n\nimpl<D: Digest> DhGroupKex<D> {\n    pub fn new(group: &DhGroup) -> DhGroupKex<D> {\n        let dh = DH::new(group);\n        DhGroupKex {\n            dh,\n            shared_secret: None,\n            _digest: PhantomData,\n        }\n    }\n}\n\nimpl<D: Digest> std::fmt::Debug for DhGroupKex<D> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(\n            f,\n            \"Algorithm {{ local_secret: [hidden], shared_secret: [hidden] }}\",\n        )\n    }\n}\n\nfn biguint_to_mpint(biguint: &BigUint) -> Vec<u8> {\n    let mut mpint = Vec::new();\n    let bytes = biguint.to_bytes_be();\n    if let Some(b) = bytes.first() {\n        if b > &0x7f {\n            mpint.push(0);\n        }\n    }\n    mpint.extend(&bytes);\n    mpint\n}\n\nimpl<D: Digest> KexAlgorithm for DhGroupKex<D> {\n    fn skip_exchange(&self) -> bool {\n        false\n    }\n\n    #[doc(hidden)]\n    fn server_dh(&mut self, exchange: &mut Exchange, payload: &[u8]) -> Result<(), crate::Error> {\n        debug!(\"server_dh\");\n\n        let client_pubkey = {\n            if payload.first() != Some(&msg::KEX_ECDH_INIT) {\n                return Err(crate::Error::Inconsistent);\n            }\n\n            #[allow(clippy::indexing_slicing)] // length checked\n            let pubkey_len = BigEndian::read_u32(&payload[1..]) as usize;\n\n            if payload.len() < 5 + pubkey_len {\n                return Err(crate::Error::Inconsistent);\n            }\n\n            &payload\n                .get(5..(5 + pubkey_len))\n                .ok_or(crate::Error::Inconsistent)?\n        };\n\n        debug!(\"client_pubkey: {:?}\", client_pubkey);\n\n        self.dh.generate_private_key(true);\n        let server_pubkey = &self.dh.generate_public_key();\n        if !self.dh.validate_public_key(server_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n\n        let encoded_server_pubkey = biguint_to_mpint(server_pubkey);\n\n        // fill exchange.\n        exchange.server_ephemeral.clear();\n        exchange.server_ephemeral.extend(&encoded_server_pubkey);\n\n        let decoded_client_pubkey = DH::decode_public_key(client_pubkey);\n        if !self.dh.validate_public_key(&decoded_client_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n\n        let shared = self.dh.compute_shared_secret(decoded_client_pubkey);\n        if !self.dh.validate_shared_secret(&shared) {\n            return Err(crate::Error::Inconsistent);\n        }\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n\n    #[doc(hidden)]\n    fn client_dh(\n        &mut self,\n        client_ephemeral: &mut CryptoVec,\n        buf: &mut CryptoVec,\n    ) -> Result<(), crate::Error> {\n        self.dh.generate_private_key(false);\n        let client_pubkey = &self.dh.generate_public_key();\n\n        if !self.dh.validate_public_key(client_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n\n        // fill exchange.\n        let encoded_pubkey = biguint_to_mpint(client_pubkey);\n        client_ephemeral.clear();\n        client_ephemeral.extend(&encoded_pubkey);\n\n        buf.push(msg::KEX_ECDH_INIT);\n        buf.extend_ssh_string(&encoded_pubkey);\n\n        Ok(())\n    }\n\n    fn compute_shared_secret(&mut self, remote_pubkey_: &[u8]) -> Result<(), crate::Error> {\n        let remote_pubkey = DH::decode_public_key(remote_pubkey_);\n\n        if !self.dh.validate_public_key(&remote_pubkey) {\n            return Err(crate::Error::Inconsistent);\n        }\n\n        let shared = self.dh.compute_shared_secret(remote_pubkey);\n        if !self.dh.validate_shared_secret(&shared) {\n            return Err(crate::Error::Inconsistent);\n        }\n        self.shared_secret = Some(biguint_to_mpint(&shared));\n        Ok(())\n    }\n\n    fn compute_exchange_hash(\n        &self,\n        key: &CryptoVec,\n        exchange: &Exchange,\n        buffer: &mut CryptoVec,\n    ) -> Result<CryptoVec, crate::Error> {\n        // Computing the exchange hash, see page 7 of RFC 5656.\n        buffer.clear();\n        buffer.extend_ssh_string(&exchange.client_id);\n        buffer.extend_ssh_string(&exchange.server_id);\n        buffer.extend_ssh_string(&exchange.client_kex_init);\n        buffer.extend_ssh_string(&exchange.server_kex_init);\n\n        buffer.extend(key);\n        buffer.extend_ssh_string(&exchange.client_ephemeral);\n        buffer.extend_ssh_string(&exchange.server_ephemeral);\n\n        if let Some(ref shared) = self.shared_secret {\n            buffer.extend_ssh_mpint(shared);\n        }\n\n        let mut hasher = D::new();\n        hasher.update(&buffer);\n\n        let mut res = CryptoVec::new();\n        res.extend(hasher.finalize().as_slice());\n        Ok(res)\n    }\n\n    fn compute_keys(\n        &self,\n        session_id: &CryptoVec,\n        exchange_hash: &CryptoVec,\n        cipher: cipher::Name,\n        remote_to_local_mac: mac::Name,\n        local_to_remote_mac: mac::Name,\n        is_server: bool,\n    ) -> Result<super::cipher::CipherPair, crate::Error> {\n        compute_keys::<D>(\n            self.shared_secret.as_deref(),\n            session_id,\n            exchange_hash,\n            cipher,\n            remote_to_local_mac,\n            local_to_remote_mac,\n            is_server,\n        )\n    }\n}\n"], "filenames": ["russh/src/kex/dh/groups.rs", "russh/src/kex/dh/mod.rs"], "buggy_code_start_loc": [1, 6], "buggy_code_end_loc": [90, 142], "fixing_code_start_loc": [0, 7], "fixing_code_end_loc": [111, 168], "type": "CWE-347", "message": "russh is a Rust SSH client and server library. Starting in version 0.34.0 and prior to versions 0.36.2 and 0.37.1, Diffie-Hellman key validation is insufficient, which can lead to insecure shared secrets and therefore breaks confidentiality. Connections between a russh client and server or those of a russh peer with some other misbehaving peer are most likely to be problematic. These may vulnerable to eavesdropping. Most other implementations reject such keys, so this is mainly an interoperability issue in such a case. This issue is fixed in versions 0.36.2 and 0.37.1", "other": {"cve": {"id": "CVE-2023-28113", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-16T21:15:13.360", "lastModified": "2023-03-23T19:41:32.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "russh is a Rust SSH client and server library. Starting in version 0.34.0 and prior to versions 0.36.2 and 0.37.1, Diffie-Hellman key validation is insufficient, which can lead to insecure shared secrets and therefore breaks confidentiality. Connections between a russh client and server or those of a russh peer with some other misbehaving peer are most likely to be problematic. These may vulnerable to eavesdropping. Most other implementations reject such keys, so this is mainly an interoperability issue in such a case. This issue is fixed in versions 0.36.2 and 0.37.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-358"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:russh_project:russh:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.34.0", "versionEndExcluding": "0.36.2", "matchCriteriaId": "EDED086A-4529-4255-8DCF-CDEDB3E6BD68"}, {"vulnerable": true, "criteria": "cpe:2.3:a:russh_project:russh:0.37.0:-:*:*:*:rust:*:*", "matchCriteriaId": "9DB6C4E2-4FDD-401E-A0D2-87E5BA1091EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:russh_project:russh:0.37.0:beta1:*:*:*:rust:*:*", "matchCriteriaId": "19B00BD6-5AAF-403A-AFE0-F9B0213016F6"}]}]}], "references": [{"url": "https://github.com/warp-tech/russh/blob/master/russh/src/kex/dh/groups.rs#L72-L76", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/warp-tech/russh/blob/master/russh/src/kex/dh/groups.rs#L78-L81", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/warp-tech/russh/commit/d831a3716d3719dc76f091fcea9d94bd4ef97c6e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/warp-tech/russh/releases/tag/v0.36.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/warp-tech/russh/releases/tag/v0.37.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/warp-tech/russh/security/advisories/GHSA-cqvm-j2r2-hwpg", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/warp-tech/russh/commit/d831a3716d3719dc76f091fcea9d94bd4ef97c6e"}}