{"buggy_code": ["// SPDX-License-Identifier: ISC\n/*\n * Copyright (c) 2007-2011 Atheros Communications Inc.\n * Copyright (c) 2011-2012,2017 Qualcomm Atheros, Inc.\n * Copyright (c) 2016-2017 Erik Stromdahl <erik.stromdahl@gmail.com>\n */\n\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n#include \"bmi.h\"\n#include \"hif.h\"\n#include \"htc.h\"\n#include \"usb.h\"\n\nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe);\n\n/* inlined helper functions */\n\nstatic inline enum ath10k_htc_ep_id\neid_from_htc_hdr(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn (enum ath10k_htc_ep_id)htc_hdr->eid;\n}\n\nstatic inline bool is_trailer_only_msg(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn __le16_to_cpu(htc_hdr->len) == htc_hdr->trailer_len;\n}\n\n/* pipe/urb operations */\nstatic struct ath10k_urb_context *\nath10k_usb_alloc_urb_from_pipe(struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tif (!list_empty(&pipe->urb_list_head)) {\n\t\turb_context = list_first_entry(&pipe->urb_list_head,\n\t\t\t\t\t       struct ath10k_urb_context, link);\n\t\tlist_del(&urb_context->link);\n\t\tpipe->urb_cnt--;\n\t}\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n\n\treturn urb_context;\n}\n\nstatic void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}\n\nstatic void ath10k_usb_cleanup_recv_urb(struct ath10k_urb_context *urb_context)\n{\n\tdev_kfree_skb(urb_context->skb);\n\turb_context->skb = NULL;\n\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n}\n\nstatic void ath10k_usb_free_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\n\tif (!pipe->ar_usb) {\n\t\t/* nothing allocated for this pipe */\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb free resources lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\n\tif (pipe->urb_alloc != pipe->urb_cnt) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t   \"usb urb leak lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\t}\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\tkfree(urb_context);\n\t}\n}\n\nstatic void ath10k_usb_cleanup_pipe_resources(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++)\n\t\tath10k_usb_free_pipe_resources(ar, &ar_usb->pipes[i]);\n}\n\n/* hif usb rx/tx completion functions */\n\nstatic void ath10k_usb_recv_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\tint status = 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t   \"usb recv pipe %d stat %d len %d urb 0x%pK\\n\",\n\t\t   pipe->logical_pipe_num, urb->status, urb->actual_length,\n\t\t   urb);\n\n\tif (urb->status != 0) {\n\t\tstatus = -EIO;\n\t\tswitch (urb->status) {\n\t\tcase -ECONNRESET:\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\t/* no need to spew these errors when device\n\t\t\t * removed or urb killed due to driver shutdown\n\t\t\t */\n\t\t\tstatus = -ECANCELED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb recv pipe %d ep 0x%2.2x failed: %d\\n\",\n\t\t\t\t   pipe->logical_pipe_num,\n\t\t\t\t   pipe->ep_address, urb->status);\n\t\t\tbreak;\n\t\t}\n\t\tgoto cleanup_recv_urb;\n\t}\n\n\tif (urb->actual_length == 0)\n\t\tgoto cleanup_recv_urb;\n\n\tskb = urb_context->skb;\n\n\t/* we are going to pass it up */\n\turb_context->skb = NULL;\n\tskb_put(skb, urb->actual_length);\n\n\t/* note: queue implements a lock */\n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n\ncleanup_recv_urb:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n\n\tif (status == 0 &&\n\t    pipe->urb_cnt >= pipe->urb_cnt_thresh) {\n\t\t/* our free urbs are piling up, post more transfers */\n\t\tath10k_usb_post_recv_transfers(ar, pipe);\n\t}\n}\n\nstatic void ath10k_usb_transmit_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\tif (urb->status != 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"pipe: %d, failed:%d\\n\",\n\t\t\t   pipe->logical_pipe_num, urb->status);\n\t}\n\n\tskb = urb_context->skb;\n\turb_context->skb = NULL;\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n\n\t/* note: queue implements a lock */\n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n}\n\n/* pipe operations */\nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tstruct urb *urb;\n\tint usb_status;\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(recv_pipe);\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\turb_context->skb = dev_alloc_skb(ATH10K_USB_RX_BUFFER_SIZE);\n\t\tif (!urb_context->skb)\n\t\t\tgoto err;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\tgoto err;\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  recv_pipe->ar_usb->udev,\n\t\t\t\t  recv_pipe->usb_pipe_handle,\n\t\t\t\t  urb_context->skb->data,\n\t\t\t\t  ATH10K_USB_RX_BUFFER_SIZE,\n\t\t\t\t  ath10k_usb_recv_complete, urb_context);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"usb bulk recv submit %d 0x%x ep 0x%2.2x len %d buf 0x%pK\\n\",\n\t\t\t   recv_pipe->logical_pipe_num,\n\t\t\t   recv_pipe->usb_pipe_handle, recv_pipe->ep_address,\n\t\t\t   ATH10K_USB_RX_BUFFER_SIZE, urb_context->skb);\n\n\t\tusb_anchor_urb(urb, &recv_pipe->urb_submitted);\n\t\tusb_status = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t\tif (usb_status) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk recv failed: %d\\n\",\n\t\t\t\t   usb_status);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn;\n\nerr:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n}\n\nstatic void ath10k_usb_flush_all(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tif (ar_usb->pipes[i].ar_usb) {\n\t\t\tusb_kill_anchored_urbs(&ar_usb->pipes[i].urb_submitted);\n\t\t\tcancel_work_sync(&ar_usb->pipes[i].io_complete_work);\n\t\t}\n\t}\n}\n\nstatic void ath10k_usb_start_recv_pipes(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tar_usb->pipes[ATH10K_USB_PIPE_RX_DATA].urb_cnt_thresh = 1;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n}\n\nstatic void ath10k_usb_tx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tstruct ath10k_htc_ep *ep;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\tep = &ar->htc.endpoint[htc_hdr->eid];\n\tath10k_htc_notify_tx_completion(ep, skb);\n\t/* The TX complete handler now owns the skb... */\n}\n\nstatic void ath10k_usb_rx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tenum ath10k_htc_ep_id eid;\n\tstruct ath10k_htc_ep *ep;\n\tu16 payload_len;\n\tu8 *trailer;\n\tint ret;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\teid = eid_from_htc_hdr(htc_hdr);\n\tep = &ar->htc.endpoint[eid];\n\n\tif (ep->service_id == 0) {\n\t\tath10k_warn(ar, \"ep %d is not connected\\n\", eid);\n\t\tgoto out_free_skb;\n\t}\n\n\tpayload_len = le16_to_cpu(htc_hdr->len);\n\tif (!payload_len) {\n\t\tath10k_warn(ar, \"zero length frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (payload_len < htc_hdr->trailer_len) {\n\t\tath10k_warn(ar, \"malformed frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (htc_hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT) {\n\t\ttrailer = skb->data + sizeof(*htc_hdr) + payload_len -\n\t\t\t  htc_hdr->trailer_len;\n\n\t\tret = ath10k_htc_process_trailer(htc,\n\t\t\t\t\t\t trailer,\n\t\t\t\t\t\t htc_hdr->trailer_len,\n\t\t\t\t\t\t eid,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t NULL);\n\t\tif (ret)\n\t\t\tgoto out_free_skb;\n\n\t\tif (is_trailer_only_msg(htc_hdr))\n\t\t\tgoto out_free_skb;\n\n\t\t/* strip off the trailer from the skb since it should not\n\t\t * be passed on to upper layers\n\t\t */\n\t\tskb_trim(skb, skb->len - htc_hdr->trailer_len);\n\t}\n\n\tskb_pull(skb, sizeof(*htc_hdr));\n\tep->ep_ops.ep_rx_complete(ar, skb);\n\t/* The RX complete handler now owns the skb... */\n\n\treturn;\n\nout_free_skb:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_usb_io_comp_work(struct work_struct *work)\n{\n\tstruct ath10k_usb_pipe *pipe = container_of(work,\n\t\t\t\t\t\t    struct ath10k_usb_pipe,\n\t\t\t\t\t\t    io_complete_work);\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&pipe->io_comp_queue))) {\n\t\tif (pipe->flags & ATH10K_USB_PIPE_FLAG_TX)\n\t\t\tath10k_usb_tx_complete(ar, skb);\n\t\telse\n\t\t\tath10k_usb_rx_complete(ar, skb);\n\t}\n}\n\n#define ATH10K_USB_MAX_DIAG_CMD (sizeof(struct ath10k_usb_ctrl_diag_cmd_write))\n#define ATH10K_USB_MAX_DIAG_RESP (sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\nstatic void ath10k_usb_destroy(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_usb_flush_all(ar);\n\tath10k_usb_cleanup_pipe_resources(ar);\n\tusb_set_intfdata(ar_usb->interface, NULL);\n\n\tkfree(ar_usb->diag_cmd_buffer);\n\tkfree(ar_usb->diag_resp_buffer);\n}\n\nstatic int ath10k_usb_hif_start(struct ath10k *ar)\n{\n\tint i;\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_usb_start_recv_pipes(ar);\n\n\t/* set the TX resource avail threshold for each TX pipe */\n\tfor (i = ATH10K_USB_PIPE_TX_CTRL;\n\t     i <= ATH10K_USB_PIPE_TX_DATA_HP; i++) {\n\t\tar_usb->pipes[i].urb_cnt_thresh =\n\t\t    ar_usb->pipes[i].urb_alloc / 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\t/* hit a max packet boundary on this pipe */\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}\n\nstatic void ath10k_usb_hif_stop(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n}\n\nstatic u16 ath10k_usb_hif_get_free_queue_number(struct ath10k *ar, u8 pipe_id)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\treturn ar_usb->pipes[pipe_id].urb_cnt;\n}\n\nstatic int ath10k_usb_submit_ctrl_out(struct ath10k *ar,\n\t\t\t\t      u8 req, u16 value, u16 index, void *data,\n\t\t\t\t      u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* note: if successful returns number of bytes transferred */\n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_sndctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 1000);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to submit usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_submit_ctrl_in(struct ath10k *ar,\n\t\t\t\t     u8 req, u16 value, u16 index, void *data,\n\t\t\t\t     u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* note: if successful returns number of bytes transferred */\n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_rcvctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 2 * HZ);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to read usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tmemcpy((u8 *)data, buf, size);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_ctrl_msg_exchange(struct ath10k *ar,\n\t\t\t\t\tu8 req_val, u8 *req_buf, u32 req_len,\n\t\t\t\t\tu8 resp_val, u8 *resp_buf,\n\t\t\t\t\tu32 *resp_len)\n{\n\tint ret;\n\n\t/* send command */\n\tret = ath10k_usb_submit_ctrl_out(ar, req_val, 0, 0,\n\t\t\t\t\t req_buf, req_len);\n\tif (ret)\n\t\tgoto err;\n\n\t/* get response */\n\tif (resp_buf) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar, resp_val, 0, 0,\n\t\t\t\t\t\tresp_buf, *resp_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int ath10k_usb_hif_diag_read(struct ath10k *ar, u32 address, void *buf,\n\t\t\t\t    size_t buf_len)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_read *cmd;\n\tu32 resp_len;\n\tint ret;\n\n\tif (buf_len < sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_read *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = ATH10K_USB_CTRL_DIAG_CC_READ;\n\tcmd->address = cpu_to_le32(address);\n\tresp_len = sizeof(struct ath10k_usb_ctrl_diag_resp_read);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_RESP,\n\t\t\t\t\t   ar_usb->diag_resp_buffer, &resp_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (resp_len != sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(buf, ar_usb->diag_resp_buffer,\n\t       sizeof(struct ath10k_usb_ctrl_diag_resp_read));\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_diag_write(struct ath10k *ar, u32 address,\n\t\t\t\t     const void *data, int nbytes)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_write *cmd;\n\tint ret;\n\n\tif (nbytes != sizeof(cmd->value))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_write *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = cpu_to_le32(ATH10K_USB_CTRL_DIAG_CC_WRITE);\n\tcmd->address = cpu_to_le32(address);\n\tmemcpy(&cmd->value, data, nbytes);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   0, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_bmi_exchange_msg(struct ath10k *ar,\n\t\t\t\t       void *req, u32 req_len,\n\t\t\t\t       void *resp, u32 *resp_len)\n{\n\tint ret;\n\n\tif (req) {\n\t\tret = ath10k_usb_submit_ctrl_out(ar,\n\t\t\t\t\t\t ATH10K_USB_CONTROL_REQ_SEND_BMI_CMD,\n\t\t\t\t\t\t 0, 0, req, req_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"unable to send the bmi data to the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (resp) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar,\n\t\t\t\t\t\tATH10K_USB_CONTROL_REQ_RECV_BMI_RESP,\n\t\t\t\t\t\t0, 0, resp, *resp_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"Unable to read the bmi data from the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_get_default_pipe(struct ath10k *ar,\n\t\t\t\t\t    u8 *ul_pipe, u8 *dl_pipe)\n{\n\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t*dl_pipe = ATH10K_USB_PIPE_RX_CTRL;\n}\n\nstatic int ath10k_usb_hif_map_service_to_pipe(struct ath10k *ar, u16 svc_id,\n\t\t\t\t\t      u8 *ul_pipe, u8 *dl_pipe)\n{\n\tswitch (svc_id) {\n\tcase ATH10K_HTC_SVC_ID_RSVD_CTRL:\n\tcase ATH10K_HTC_SVC_ID_WMI_CONTROL:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t\t/* due to large control packets, shift to data pipe */\n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t/* Disable rxdata2 directly, it will be enabled\n\t\t * if FW enable rxdata2\n\t\t */\n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\n/* This op is currently only used by htc_wait_target if the HTC ready\n * message times out. It is not applicable for USB since there is nothing\n * we can do if the HTC ready message does not arrive in time.\n * TODO: Make this op non mandatory by introducing a NULL check in the\n * hif op wrapper.\n */\nstatic void ath10k_usb_hif_send_complete_check(struct ath10k *ar,\n\t\t\t\t\t       u8 pipe, int force)\n{\n}\n\nstatic int ath10k_usb_hif_power_up(struct ath10k *ar,\n\t\t\t\t   enum ath10k_firmware_mode fw_mode)\n{\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_power_down(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_hif_suspend(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ath10k_usb_hif_resume(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic const struct ath10k_hif_ops ath10k_usb_hif_ops = {\n\t.tx_sg\t\t\t= ath10k_usb_hif_tx_sg,\n\t.diag_read\t\t= ath10k_usb_hif_diag_read,\n\t.diag_write\t\t= ath10k_usb_hif_diag_write,\n\t.exchange_bmi_msg\t= ath10k_usb_bmi_exchange_msg,\n\t.start\t\t\t= ath10k_usb_hif_start,\n\t.stop\t\t\t= ath10k_usb_hif_stop,\n\t.map_service_to_pipe\t= ath10k_usb_hif_map_service_to_pipe,\n\t.get_default_pipe\t= ath10k_usb_hif_get_default_pipe,\n\t.send_complete_check\t= ath10k_usb_hif_send_complete_check,\n\t.get_free_queue_number\t= ath10k_usb_hif_get_free_queue_number,\n\t.power_up\t\t= ath10k_usb_hif_power_up,\n\t.power_down\t\t= ath10k_usb_hif_power_down,\n#ifdef CONFIG_PM\n\t.suspend\t\t= ath10k_usb_hif_suspend,\n\t.resume\t\t\t= ath10k_usb_hif_resume,\n#endif\n};\n\nstatic u8 ath10k_usb_get_logical_pipe_num(u8 ep_address, int *urb_count)\n{\n\tu8 pipe_num = ATH10K_USB_PIPE_INVALID;\n\n\tswitch (ep_address) {\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_CTRL;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_INT_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_INT;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA2_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA2;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_CTRL;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_LP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_MP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_MP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_HP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_HP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tdefault:\n\t\t/* note: there may be endpoints not currently used */\n\t\tbreak;\n\t}\n\n\treturn pipe_num;\n}\n\nstatic int ath10k_usb_alloc_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe,\n\t\t\t\t\t   int urb_cnt)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tint i;\n\n\tINIT_LIST_HEAD(&pipe->urb_list_head);\n\tinit_usb_anchor(&pipe->urb_submitted);\n\n\tfor (i = 0; i < urb_cnt; i++) {\n\t\turb_context = kzalloc(sizeof(*urb_context), GFP_KERNEL);\n\t\tif (!urb_context)\n\t\t\treturn -ENOMEM;\n\n\t\turb_context->pipe = pipe;\n\n\t\t/* we are only allocate the urb contexts here, the actual URB\n\t\t * is allocated from the kernel as needed to do a transaction\n\t\t */\n\t\tpipe->urb_alloc++;\n\t\tath10k_usb_free_urb_to_pipe(pipe, urb_context);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb alloc resources lpipe %d hpipe 0x%x urbs %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_setup_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_host_interface *iface_desc = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i, urbcount;\n\tu8 pipe_num;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB, \"usb setting up pipes using interface\\n\");\n\n\t/* walk decriptors and setup pipes */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s bulk ep 0x%2.2x maxpktsz %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize));\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s int ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t/* TODO for ISO */\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s isoc ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t}\n\t\turbcount = 0;\n\n\t\tpipe_num =\n\t\t    ath10k_usb_get_logical_pipe_num(endpoint->bEndpointAddress,\n\t\t\t\t\t\t    &urbcount);\n\t\tif (pipe_num == ATH10K_USB_PIPE_INVALID)\n\t\t\tcontinue;\n\n\t\tpipe = &ar_usb->pipes[pipe_num];\n\t\tif (pipe->ar_usb)\n\t\t\t/* hmmm..pipe was already setup */\n\t\t\tcontinue;\n\n\t\tpipe->ar_usb = ar_usb;\n\t\tpipe->logical_pipe_num = pipe_num;\n\t\tpipe->ep_address = endpoint->bEndpointAddress;\n\t\tpipe->max_packet_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t/* TODO for ISO */\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t}\n\n\t\tpipe->ep_desc = endpoint;\n\n\t\tif (!ATH10K_USB_IS_DIR_IN(pipe->ep_address))\n\t\t\tpipe->flags |= ATH10K_USB_PIPE_FLAG_TX;\n\n\t\tret = ath10k_usb_alloc_pipe_resources(ar, pipe, urbcount);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_create(struct ath10k *ar,\n\t\t\t     struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i;\n\n\tusb_set_intfdata(interface, ar_usb);\n\tspin_lock_init(&ar_usb->cs_lock);\n\tar_usb->udev = dev;\n\tar_usb->interface = interface;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tpipe = &ar_usb->pipes[i];\n\t\tINIT_WORK(&pipe->io_complete_work,\n\t\t\t  ath10k_usb_io_comp_work);\n\t\tskb_queue_head_init(&pipe->io_comp_queue);\n\t}\n\n\tar_usb->diag_cmd_buffer = kzalloc(ATH10K_USB_MAX_DIAG_CMD, GFP_KERNEL);\n\tif (!ar_usb->diag_cmd_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tar_usb->diag_resp_buffer = kzalloc(ATH10K_USB_MAX_DIAG_RESP,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ar_usb->diag_resp_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_usb_setup_pipe_resources(ar, interface);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tath10k_usb_destroy(ar);\n\treturn ret;\n}\n\n/* ath10k usb driver registered functions */\nstatic int ath10k_usb_probe(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_usb *ar_usb;\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tint ret, vendor_id, product_id;\n\tenum ath10k_hw_rev hw_rev;\n\tstruct ath10k_bus_params bus_params = {};\n\n\t/* Assumption: All USB based chipsets (so far) are QCA9377 based.\n\t * If there will be newer chipsets that does not use the hw reg\n\t * setup as defined in qca6174_regs and qca6174_values, this\n\t * assumption is no longer valid and hw_rev must be setup differently\n\t * depending on chipset.\n\t */\n\thw_rev = ATH10K_HW_QCA9377;\n\n\tar = ath10k_core_create(sizeof(*ar_usb), &dev->dev, ATH10K_BUS_USB,\n\t\t\t\thw_rev, &ath10k_usb_hif_ops);\n\tif (!ar) {\n\t\tdev_err(&dev->dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_get_dev(dev);\n\tvendor_id = le16_to_cpu(dev->descriptor.idVendor);\n\tproduct_id = le16_to_cpu(dev->descriptor.idProduct);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"usb new func vendor 0x%04x product 0x%04x\\n\",\n\t\t   vendor_id, product_id);\n\n\tar_usb = ath10k_usb_priv(ar);\n\tret = ath10k_usb_create(ar, interface);\n\tar_usb->ar = ar;\n\n\tar->dev_id = product_id;\n\tar->id.vendor = vendor_id;\n\tar->id.device = product_id;\n\n\tbus_params.dev_type = ATH10K_DEV_TYPE_HL;\n\t/* TODO: don't know yet how to get chip_id with USB */\n\tbus_params.chip_id = 0;\n\tret = ath10k_core_register(ar, &bus_params);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to register driver core: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t/* TODO: remove this once USB support is fully implemented */\n\tath10k_warn(ar, \"Warning: ath10k USB support is incomplete, don't expect anything to work!\\n\");\n\n\treturn 0;\n\nerr:\n\tath10k_core_destroy(ar);\n\n\tusb_put_dev(dev);\n\n\treturn ret;\n}\n\nstatic void ath10k_usb_remove(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb;\n\n\tar_usb = usb_get_intfdata(interface);\n\tif (!ar_usb)\n\t\treturn;\n\n\tath10k_core_unregister(ar_usb->ar);\n\tath10k_usb_destroy(ar_usb->ar);\n\tusb_put_dev(interface_to_usbdev(interface));\n\tath10k_core_destroy(ar_usb->ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_pm_suspend(struct usb_interface *interface,\n\t\t\t\t pm_message_t message)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\n\tath10k_usb_flush_all(ar_usb->ar);\n\treturn 0;\n}\n\nstatic int ath10k_usb_pm_resume(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\tstruct ath10k *ar = ar_usb->ar;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n\n\treturn 0;\n}\n\n#else\n\n#define ath10k_usb_pm_suspend NULL\n#define ath10k_usb_pm_resume NULL\n\n#endif\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id ath10k_usb_ids[] = {\n\t{USB_DEVICE(0x13b1, 0x0042)}, /* Linksys WUSB6100M */\n\t{ /* Terminating entry */ },\n};\n\nMODULE_DEVICE_TABLE(usb, ath10k_usb_ids);\n\nstatic struct usb_driver ath10k_usb_driver = {\n\t.name = \"ath10k_usb\",\n\t.probe = ath10k_usb_probe,\n\t.suspend = ath10k_usb_pm_suspend,\n\t.resume = ath10k_usb_pm_resume,\n\t.disconnect = ath10k_usb_remove,\n\t.id_table = ath10k_usb_ids,\n\t.supports_autosuspend = true,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ath10k_usb_driver);\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Atheros 802.11ac WLAN USB devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n"], "fixing_code": ["// SPDX-License-Identifier: ISC\n/*\n * Copyright (c) 2007-2011 Atheros Communications Inc.\n * Copyright (c) 2011-2012,2017 Qualcomm Atheros, Inc.\n * Copyright (c) 2016-2017 Erik Stromdahl <erik.stromdahl@gmail.com>\n */\n\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n#include \"bmi.h\"\n#include \"hif.h\"\n#include \"htc.h\"\n#include \"usb.h\"\n\nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe);\n\n/* inlined helper functions */\n\nstatic inline enum ath10k_htc_ep_id\neid_from_htc_hdr(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn (enum ath10k_htc_ep_id)htc_hdr->eid;\n}\n\nstatic inline bool is_trailer_only_msg(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn __le16_to_cpu(htc_hdr->len) == htc_hdr->trailer_len;\n}\n\n/* pipe/urb operations */\nstatic struct ath10k_urb_context *\nath10k_usb_alloc_urb_from_pipe(struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tif (!list_empty(&pipe->urb_list_head)) {\n\t\turb_context = list_first_entry(&pipe->urb_list_head,\n\t\t\t\t\t       struct ath10k_urb_context, link);\n\t\tlist_del(&urb_context->link);\n\t\tpipe->urb_cnt--;\n\t}\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n\n\treturn urb_context;\n}\n\nstatic void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}\n\nstatic void ath10k_usb_cleanup_recv_urb(struct ath10k_urb_context *urb_context)\n{\n\tdev_kfree_skb(urb_context->skb);\n\turb_context->skb = NULL;\n\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n}\n\nstatic void ath10k_usb_free_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\n\tif (!pipe->ar_usb) {\n\t\t/* nothing allocated for this pipe */\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb free resources lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\n\tif (pipe->urb_alloc != pipe->urb_cnt) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t   \"usb urb leak lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\t}\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\tkfree(urb_context);\n\t}\n}\n\nstatic void ath10k_usb_cleanup_pipe_resources(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++)\n\t\tath10k_usb_free_pipe_resources(ar, &ar_usb->pipes[i]);\n}\n\n/* hif usb rx/tx completion functions */\n\nstatic void ath10k_usb_recv_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\tint status = 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t   \"usb recv pipe %d stat %d len %d urb 0x%pK\\n\",\n\t\t   pipe->logical_pipe_num, urb->status, urb->actual_length,\n\t\t   urb);\n\n\tif (urb->status != 0) {\n\t\tstatus = -EIO;\n\t\tswitch (urb->status) {\n\t\tcase -ECONNRESET:\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\t/* no need to spew these errors when device\n\t\t\t * removed or urb killed due to driver shutdown\n\t\t\t */\n\t\t\tstatus = -ECANCELED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb recv pipe %d ep 0x%2.2x failed: %d\\n\",\n\t\t\t\t   pipe->logical_pipe_num,\n\t\t\t\t   pipe->ep_address, urb->status);\n\t\t\tbreak;\n\t\t}\n\t\tgoto cleanup_recv_urb;\n\t}\n\n\tif (urb->actual_length == 0)\n\t\tgoto cleanup_recv_urb;\n\n\tskb = urb_context->skb;\n\n\t/* we are going to pass it up */\n\turb_context->skb = NULL;\n\tskb_put(skb, urb->actual_length);\n\n\t/* note: queue implements a lock */\n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n\ncleanup_recv_urb:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n\n\tif (status == 0 &&\n\t    pipe->urb_cnt >= pipe->urb_cnt_thresh) {\n\t\t/* our free urbs are piling up, post more transfers */\n\t\tath10k_usb_post_recv_transfers(ar, pipe);\n\t}\n}\n\nstatic void ath10k_usb_transmit_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\tif (urb->status != 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"pipe: %d, failed:%d\\n\",\n\t\t\t   pipe->logical_pipe_num, urb->status);\n\t}\n\n\tskb = urb_context->skb;\n\turb_context->skb = NULL;\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n\n\t/* note: queue implements a lock */\n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n}\n\n/* pipe operations */\nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tstruct urb *urb;\n\tint usb_status;\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(recv_pipe);\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\turb_context->skb = dev_alloc_skb(ATH10K_USB_RX_BUFFER_SIZE);\n\t\tif (!urb_context->skb)\n\t\t\tgoto err;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\tgoto err;\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  recv_pipe->ar_usb->udev,\n\t\t\t\t  recv_pipe->usb_pipe_handle,\n\t\t\t\t  urb_context->skb->data,\n\t\t\t\t  ATH10K_USB_RX_BUFFER_SIZE,\n\t\t\t\t  ath10k_usb_recv_complete, urb_context);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"usb bulk recv submit %d 0x%x ep 0x%2.2x len %d buf 0x%pK\\n\",\n\t\t\t   recv_pipe->logical_pipe_num,\n\t\t\t   recv_pipe->usb_pipe_handle, recv_pipe->ep_address,\n\t\t\t   ATH10K_USB_RX_BUFFER_SIZE, urb_context->skb);\n\n\t\tusb_anchor_urb(urb, &recv_pipe->urb_submitted);\n\t\tusb_status = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t\tif (usb_status) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk recv failed: %d\\n\",\n\t\t\t\t   usb_status);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn;\n\nerr:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n}\n\nstatic void ath10k_usb_flush_all(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tif (ar_usb->pipes[i].ar_usb) {\n\t\t\tusb_kill_anchored_urbs(&ar_usb->pipes[i].urb_submitted);\n\t\t\tcancel_work_sync(&ar_usb->pipes[i].io_complete_work);\n\t\t}\n\t}\n}\n\nstatic void ath10k_usb_start_recv_pipes(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tar_usb->pipes[ATH10K_USB_PIPE_RX_DATA].urb_cnt_thresh = 1;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n}\n\nstatic void ath10k_usb_tx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tstruct ath10k_htc_ep *ep;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\tep = &ar->htc.endpoint[htc_hdr->eid];\n\tath10k_htc_notify_tx_completion(ep, skb);\n\t/* The TX complete handler now owns the skb... */\n}\n\nstatic void ath10k_usb_rx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tenum ath10k_htc_ep_id eid;\n\tstruct ath10k_htc_ep *ep;\n\tu16 payload_len;\n\tu8 *trailer;\n\tint ret;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\teid = eid_from_htc_hdr(htc_hdr);\n\tep = &ar->htc.endpoint[eid];\n\n\tif (ep->service_id == 0) {\n\t\tath10k_warn(ar, \"ep %d is not connected\\n\", eid);\n\t\tgoto out_free_skb;\n\t}\n\n\tpayload_len = le16_to_cpu(htc_hdr->len);\n\tif (!payload_len) {\n\t\tath10k_warn(ar, \"zero length frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (payload_len < htc_hdr->trailer_len) {\n\t\tath10k_warn(ar, \"malformed frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (htc_hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT) {\n\t\ttrailer = skb->data + sizeof(*htc_hdr) + payload_len -\n\t\t\t  htc_hdr->trailer_len;\n\n\t\tret = ath10k_htc_process_trailer(htc,\n\t\t\t\t\t\t trailer,\n\t\t\t\t\t\t htc_hdr->trailer_len,\n\t\t\t\t\t\t eid,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t NULL);\n\t\tif (ret)\n\t\t\tgoto out_free_skb;\n\n\t\tif (is_trailer_only_msg(htc_hdr))\n\t\t\tgoto out_free_skb;\n\n\t\t/* strip off the trailer from the skb since it should not\n\t\t * be passed on to upper layers\n\t\t */\n\t\tskb_trim(skb, skb->len - htc_hdr->trailer_len);\n\t}\n\n\tskb_pull(skb, sizeof(*htc_hdr));\n\tep->ep_ops.ep_rx_complete(ar, skb);\n\t/* The RX complete handler now owns the skb... */\n\n\treturn;\n\nout_free_skb:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_usb_io_comp_work(struct work_struct *work)\n{\n\tstruct ath10k_usb_pipe *pipe = container_of(work,\n\t\t\t\t\t\t    struct ath10k_usb_pipe,\n\t\t\t\t\t\t    io_complete_work);\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&pipe->io_comp_queue))) {\n\t\tif (pipe->flags & ATH10K_USB_PIPE_FLAG_TX)\n\t\t\tath10k_usb_tx_complete(ar, skb);\n\t\telse\n\t\t\tath10k_usb_rx_complete(ar, skb);\n\t}\n}\n\n#define ATH10K_USB_MAX_DIAG_CMD (sizeof(struct ath10k_usb_ctrl_diag_cmd_write))\n#define ATH10K_USB_MAX_DIAG_RESP (sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\nstatic void ath10k_usb_destroy(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_usb_flush_all(ar);\n\tath10k_usb_cleanup_pipe_resources(ar);\n\tusb_set_intfdata(ar_usb->interface, NULL);\n\n\tkfree(ar_usb->diag_cmd_buffer);\n\tkfree(ar_usb->diag_resp_buffer);\n}\n\nstatic int ath10k_usb_hif_start(struct ath10k *ar)\n{\n\tint i;\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_usb_start_recv_pipes(ar);\n\n\t/* set the TX resource avail threshold for each TX pipe */\n\tfor (i = ATH10K_USB_PIPE_TX_CTRL;\n\t     i <= ATH10K_USB_PIPE_TX_DATA_HP; i++) {\n\t\tar_usb->pipes[i].urb_cnt_thresh =\n\t\t    ar_usb->pipes[i].urb_alloc / 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\t/* hit a max packet boundary on this pipe */\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}\n\nstatic void ath10k_usb_hif_stop(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n}\n\nstatic u16 ath10k_usb_hif_get_free_queue_number(struct ath10k *ar, u8 pipe_id)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\treturn ar_usb->pipes[pipe_id].urb_cnt;\n}\n\nstatic int ath10k_usb_submit_ctrl_out(struct ath10k *ar,\n\t\t\t\t      u8 req, u16 value, u16 index, void *data,\n\t\t\t\t      u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* note: if successful returns number of bytes transferred */\n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_sndctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 1000);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to submit usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_submit_ctrl_in(struct ath10k *ar,\n\t\t\t\t     u8 req, u16 value, u16 index, void *data,\n\t\t\t\t     u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* note: if successful returns number of bytes transferred */\n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_rcvctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 2 * HZ);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to read usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tmemcpy((u8 *)data, buf, size);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_ctrl_msg_exchange(struct ath10k *ar,\n\t\t\t\t\tu8 req_val, u8 *req_buf, u32 req_len,\n\t\t\t\t\tu8 resp_val, u8 *resp_buf,\n\t\t\t\t\tu32 *resp_len)\n{\n\tint ret;\n\n\t/* send command */\n\tret = ath10k_usb_submit_ctrl_out(ar, req_val, 0, 0,\n\t\t\t\t\t req_buf, req_len);\n\tif (ret)\n\t\tgoto err;\n\n\t/* get response */\n\tif (resp_buf) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar, resp_val, 0, 0,\n\t\t\t\t\t\tresp_buf, *resp_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int ath10k_usb_hif_diag_read(struct ath10k *ar, u32 address, void *buf,\n\t\t\t\t    size_t buf_len)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_read *cmd;\n\tu32 resp_len;\n\tint ret;\n\n\tif (buf_len < sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_read *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = ATH10K_USB_CTRL_DIAG_CC_READ;\n\tcmd->address = cpu_to_le32(address);\n\tresp_len = sizeof(struct ath10k_usb_ctrl_diag_resp_read);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_RESP,\n\t\t\t\t\t   ar_usb->diag_resp_buffer, &resp_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (resp_len != sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(buf, ar_usb->diag_resp_buffer,\n\t       sizeof(struct ath10k_usb_ctrl_diag_resp_read));\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_diag_write(struct ath10k *ar, u32 address,\n\t\t\t\t     const void *data, int nbytes)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_write *cmd;\n\tint ret;\n\n\tif (nbytes != sizeof(cmd->value))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_write *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = cpu_to_le32(ATH10K_USB_CTRL_DIAG_CC_WRITE);\n\tcmd->address = cpu_to_le32(address);\n\tmemcpy(&cmd->value, data, nbytes);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   0, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_bmi_exchange_msg(struct ath10k *ar,\n\t\t\t\t       void *req, u32 req_len,\n\t\t\t\t       void *resp, u32 *resp_len)\n{\n\tint ret;\n\n\tif (req) {\n\t\tret = ath10k_usb_submit_ctrl_out(ar,\n\t\t\t\t\t\t ATH10K_USB_CONTROL_REQ_SEND_BMI_CMD,\n\t\t\t\t\t\t 0, 0, req, req_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"unable to send the bmi data to the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (resp) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar,\n\t\t\t\t\t\tATH10K_USB_CONTROL_REQ_RECV_BMI_RESP,\n\t\t\t\t\t\t0, 0, resp, *resp_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"Unable to read the bmi data from the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_get_default_pipe(struct ath10k *ar,\n\t\t\t\t\t    u8 *ul_pipe, u8 *dl_pipe)\n{\n\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t*dl_pipe = ATH10K_USB_PIPE_RX_CTRL;\n}\n\nstatic int ath10k_usb_hif_map_service_to_pipe(struct ath10k *ar, u16 svc_id,\n\t\t\t\t\t      u8 *ul_pipe, u8 *dl_pipe)\n{\n\tswitch (svc_id) {\n\tcase ATH10K_HTC_SVC_ID_RSVD_CTRL:\n\tcase ATH10K_HTC_SVC_ID_WMI_CONTROL:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t\t/* due to large control packets, shift to data pipe */\n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t/* Disable rxdata2 directly, it will be enabled\n\t\t * if FW enable rxdata2\n\t\t */\n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\n/* This op is currently only used by htc_wait_target if the HTC ready\n * message times out. It is not applicable for USB since there is nothing\n * we can do if the HTC ready message does not arrive in time.\n * TODO: Make this op non mandatory by introducing a NULL check in the\n * hif op wrapper.\n */\nstatic void ath10k_usb_hif_send_complete_check(struct ath10k *ar,\n\t\t\t\t\t       u8 pipe, int force)\n{\n}\n\nstatic int ath10k_usb_hif_power_up(struct ath10k *ar,\n\t\t\t\t   enum ath10k_firmware_mode fw_mode)\n{\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_power_down(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_hif_suspend(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ath10k_usb_hif_resume(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic const struct ath10k_hif_ops ath10k_usb_hif_ops = {\n\t.tx_sg\t\t\t= ath10k_usb_hif_tx_sg,\n\t.diag_read\t\t= ath10k_usb_hif_diag_read,\n\t.diag_write\t\t= ath10k_usb_hif_diag_write,\n\t.exchange_bmi_msg\t= ath10k_usb_bmi_exchange_msg,\n\t.start\t\t\t= ath10k_usb_hif_start,\n\t.stop\t\t\t= ath10k_usb_hif_stop,\n\t.map_service_to_pipe\t= ath10k_usb_hif_map_service_to_pipe,\n\t.get_default_pipe\t= ath10k_usb_hif_get_default_pipe,\n\t.send_complete_check\t= ath10k_usb_hif_send_complete_check,\n\t.get_free_queue_number\t= ath10k_usb_hif_get_free_queue_number,\n\t.power_up\t\t= ath10k_usb_hif_power_up,\n\t.power_down\t\t= ath10k_usb_hif_power_down,\n#ifdef CONFIG_PM\n\t.suspend\t\t= ath10k_usb_hif_suspend,\n\t.resume\t\t\t= ath10k_usb_hif_resume,\n#endif\n};\n\nstatic u8 ath10k_usb_get_logical_pipe_num(u8 ep_address, int *urb_count)\n{\n\tu8 pipe_num = ATH10K_USB_PIPE_INVALID;\n\n\tswitch (ep_address) {\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_CTRL;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_INT_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_INT;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA2_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA2;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_CTRL;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_LP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_MP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_MP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_HP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_HP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tdefault:\n\t\t/* note: there may be endpoints not currently used */\n\t\tbreak;\n\t}\n\n\treturn pipe_num;\n}\n\nstatic int ath10k_usb_alloc_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe,\n\t\t\t\t\t   int urb_cnt)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tint i;\n\n\tINIT_LIST_HEAD(&pipe->urb_list_head);\n\tinit_usb_anchor(&pipe->urb_submitted);\n\n\tfor (i = 0; i < urb_cnt; i++) {\n\t\turb_context = kzalloc(sizeof(*urb_context), GFP_KERNEL);\n\t\tif (!urb_context)\n\t\t\treturn -ENOMEM;\n\n\t\turb_context->pipe = pipe;\n\n\t\t/* we are only allocate the urb contexts here, the actual URB\n\t\t * is allocated from the kernel as needed to do a transaction\n\t\t */\n\t\tpipe->urb_alloc++;\n\t\tath10k_usb_free_urb_to_pipe(pipe, urb_context);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb alloc resources lpipe %d hpipe 0x%x urbs %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_setup_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_host_interface *iface_desc = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i, urbcount;\n\tu8 pipe_num;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB, \"usb setting up pipes using interface\\n\");\n\n\t/* walk decriptors and setup pipes */\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s bulk ep 0x%2.2x maxpktsz %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize));\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s int ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t/* TODO for ISO */\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s isoc ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t}\n\t\turbcount = 0;\n\n\t\tpipe_num =\n\t\t    ath10k_usb_get_logical_pipe_num(endpoint->bEndpointAddress,\n\t\t\t\t\t\t    &urbcount);\n\t\tif (pipe_num == ATH10K_USB_PIPE_INVALID)\n\t\t\tcontinue;\n\n\t\tpipe = &ar_usb->pipes[pipe_num];\n\t\tif (pipe->ar_usb)\n\t\t\t/* hmmm..pipe was already setup */\n\t\t\tcontinue;\n\n\t\tpipe->ar_usb = ar_usb;\n\t\tpipe->logical_pipe_num = pipe_num;\n\t\tpipe->ep_address = endpoint->bEndpointAddress;\n\t\tpipe->max_packet_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t/* TODO for ISO */\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t}\n\n\t\tpipe->ep_desc = endpoint;\n\n\t\tif (!ATH10K_USB_IS_DIR_IN(pipe->ep_address))\n\t\t\tpipe->flags |= ATH10K_USB_PIPE_FLAG_TX;\n\n\t\tret = ath10k_usb_alloc_pipe_resources(ar, pipe, urbcount);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_create(struct ath10k *ar,\n\t\t\t     struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i;\n\n\tusb_set_intfdata(interface, ar_usb);\n\tspin_lock_init(&ar_usb->cs_lock);\n\tar_usb->udev = dev;\n\tar_usb->interface = interface;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tpipe = &ar_usb->pipes[i];\n\t\tINIT_WORK(&pipe->io_complete_work,\n\t\t\t  ath10k_usb_io_comp_work);\n\t\tskb_queue_head_init(&pipe->io_comp_queue);\n\t}\n\n\tar_usb->diag_cmd_buffer = kzalloc(ATH10K_USB_MAX_DIAG_CMD, GFP_KERNEL);\n\tif (!ar_usb->diag_cmd_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tar_usb->diag_resp_buffer = kzalloc(ATH10K_USB_MAX_DIAG_RESP,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ar_usb->diag_resp_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_usb_setup_pipe_resources(ar, interface);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tath10k_usb_destroy(ar);\n\treturn ret;\n}\n\n/* ath10k usb driver registered functions */\nstatic int ath10k_usb_probe(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_usb *ar_usb;\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tint ret, vendor_id, product_id;\n\tenum ath10k_hw_rev hw_rev;\n\tstruct ath10k_bus_params bus_params = {};\n\n\t/* Assumption: All USB based chipsets (so far) are QCA9377 based.\n\t * If there will be newer chipsets that does not use the hw reg\n\t * setup as defined in qca6174_regs and qca6174_values, this\n\t * assumption is no longer valid and hw_rev must be setup differently\n\t * depending on chipset.\n\t */\n\thw_rev = ATH10K_HW_QCA9377;\n\n\tar = ath10k_core_create(sizeof(*ar_usb), &dev->dev, ATH10K_BUS_USB,\n\t\t\t\thw_rev, &ath10k_usb_hif_ops);\n\tif (!ar) {\n\t\tdev_err(&dev->dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_get_dev(dev);\n\tvendor_id = le16_to_cpu(dev->descriptor.idVendor);\n\tproduct_id = le16_to_cpu(dev->descriptor.idProduct);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"usb new func vendor 0x%04x product 0x%04x\\n\",\n\t\t   vendor_id, product_id);\n\n\tar_usb = ath10k_usb_priv(ar);\n\tret = ath10k_usb_create(ar, interface);\n\tar_usb->ar = ar;\n\n\tar->dev_id = product_id;\n\tar->id.vendor = vendor_id;\n\tar->id.device = product_id;\n\n\tbus_params.dev_type = ATH10K_DEV_TYPE_HL;\n\t/* TODO: don't know yet how to get chip_id with USB */\n\tbus_params.chip_id = 0;\n\tret = ath10k_core_register(ar, &bus_params);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to register driver core: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t/* TODO: remove this once USB support is fully implemented */\n\tath10k_warn(ar, \"Warning: ath10k USB support is incomplete, don't expect anything to work!\\n\");\n\n\treturn 0;\n\nerr:\n\tath10k_core_destroy(ar);\n\n\tusb_put_dev(dev);\n\n\treturn ret;\n}\n\nstatic void ath10k_usb_remove(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb;\n\n\tar_usb = usb_get_intfdata(interface);\n\tif (!ar_usb)\n\t\treturn;\n\n\tath10k_core_unregister(ar_usb->ar);\n\tath10k_usb_destroy(ar_usb->ar);\n\tusb_put_dev(interface_to_usbdev(interface));\n\tath10k_core_destroy(ar_usb->ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_pm_suspend(struct usb_interface *interface,\n\t\t\t\t pm_message_t message)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\n\tath10k_usb_flush_all(ar_usb->ar);\n\treturn 0;\n}\n\nstatic int ath10k_usb_pm_resume(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\tstruct ath10k *ar = ar_usb->ar;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n\n\treturn 0;\n}\n\n#else\n\n#define ath10k_usb_pm_suspend NULL\n#define ath10k_usb_pm_resume NULL\n\n#endif\n\n/* table of devices that work with this driver */\nstatic struct usb_device_id ath10k_usb_ids[] = {\n\t{USB_DEVICE(0x13b1, 0x0042)}, /* Linksys WUSB6100M */\n\t{ /* Terminating entry */ },\n};\n\nMODULE_DEVICE_TABLE(usb, ath10k_usb_ids);\n\nstatic struct usb_driver ath10k_usb_driver = {\n\t.name = \"ath10k_usb\",\n\t.probe = ath10k_usb_probe,\n\t.suspend = ath10k_usb_pm_suspend,\n\t.resume = ath10k_usb_pm_resume,\n\t.disconnect = ath10k_usb_remove,\n\t.id_table = ath10k_usb_ids,\n\t.supports_autosuspend = true,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ath10k_usb_driver);\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Atheros 802.11ac WLAN USB devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n"], "filenames": ["drivers/net/wireless/ath/ath10k/usb.c"], "buggy_code_start_loc": [437], "buggy_code_end_loc": [437], "fixing_code_start_loc": [438], "fixing_code_end_loc": [439], "type": "CWE-401", "message": "A memory leak in the ath10k_usb_hif_tx_sg() function in drivers/net/wireless/ath/ath10k/usb.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-b8d17e7d93d2.", "other": {"cve": {"id": "CVE-2019-19078", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.560", "lastModified": "2023-01-17T21:28:11.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the ath10k_usb_hif_tx_sg() function in drivers/net/wireless/ath/ath10k/usb.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-b8d17e7d93d2."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n ath10k_usb_hif_tx_sg() en el archivo drivers/net/wireless/ath/ath10k/usb.c en el kernel de Linux versiones hasta la versi\u00f3n  5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n usb_submit_urb(), tambi\u00e9n se conoce como CID-b8d17e7d93d2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.14", "versionEndExcluding": "4.14.165", "matchCriteriaId": "CC3A53E4-ED8D-4990-82FE-EEBA0093B2B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.96", "matchCriteriaId": "F9CE32D3-58DD-43FC-B9A9-3D218D2084E8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.12", "matchCriteriaId": "81529934-E2E4-4EDA-8787-54E9CB8B046D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D4ISVNIC44SOGXTUBCIZFSUNQJ5LRKNZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MN6MLCN7G7VFTSXSZYXKXEFCUMFBUAXQ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4258-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b8d17e7d93d2beb89e4f34c59996376b8b544792"}}