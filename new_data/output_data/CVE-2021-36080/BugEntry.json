{"buggy_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2021 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n//#define HAVE_COMPRESS_R2004_SECTION\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n#ifdef HAVE_CTYPE_H\n#  include <ctype.h>\n#endif\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n#include \"classes.h\"\n#include \"free.h\"\n\n// from dynapi\nbool is_dwg_object (const char *name);\nbool is_dwg_entity (const char *name);\nint dwg_dynapi_entity_size (const char *restrict name);\n// from dwg_api\nBITCODE_T dwg_add_u8_input (Dwg_Data *restrict dwg,\n                            const char *restrict u8str);\nDwg_Object_APPID *dwg_add_APPID (Dwg_Data *restrict dwg,\n                                 const char *restrict name);\nunsigned long dwg_obj_generic_handlevalue (void *_obj);\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\nstatic BITCODE_BL rcount1 = 0, rcount2 = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n\n#define LOG_POS                                                               \\\n  LOG_INSANE (\" @%lu.%u\", obj ? dat->byte - obj->address : dat->byte, dat->bit)\\\n  LOG_TRACE (\"\\n\")\n#define LOG_RPOS                                                              \\\n  LOG_INSANE (\" @%lu.%u\", dat->byte, dat->bit)                                \\\n  LOG_TRACE (\"\\n\")\n#define LOG_HPOS                                                              \\\n  LOG_INSANE (\" @%lu.%u\",                                                     \\\n              obj && hdl_dat->byte > obj->address                             \\\n                  ? hdl_dat->byte - obj->address                              \\\n                  : hdl_dat->byte,                                            \\\n              hdl_dat->bit)                                                   \\\n  LOG_TRACE (\"\\n\")\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\", (BITCODE_##type)value, dxf);  \\\n    LOG_POS                                                                   \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_BS(value, dxf) VALUE (value, BS, dxf)\n#define VALUE_BL(value, dxf) VALUE (value, BL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n#define VALUE_BD(value, dxf) VALUE (value, BD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type, _obj->nam)                              \\\n  LOG_POS\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\", _obj->nam) \\\n  LOG_POS\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxf \"]\",               \\\n               (BITCODE_##type)_obj->nam);                                    \\\n    LOG_POS                                                                   \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n#define SUB_FIELD_CAST(o, nam, type, cast, dxf)                               \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->o.nam);                      \\\n    FIELD_G_TRACE (o.nam, cast, dxf);                                         \\\n  }\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf) FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf) FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf) FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf) FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf) FIELD_CAST (nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf) FIELD_CAST (nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf) FIELD_CAST (nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf) FIELD_CAST (nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf) FIELD_CAST (nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf) FIELD_CAST (nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf) FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf) FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_RLLu(nam, dxf)                                            \\\n  {                                                                     \\\n    bit_write_RLL (dat, _obj->nam);                                     \\\n    FIELD_G_TRACE (nam, BLL, dxf);                                      \\\n  }\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER                                                    \\\n    {                                                                         \\\n      if (!_obj->nam)                                                         \\\n        _obj->nam = strdup (\"\");                                              \\\n    }                                                                         \\\n    bit_write_TV (dat, _obj->nam);                                            \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TV %d]\", _obj->nam, dxf);                      \\\n    LOG_POS                                                                   \\\n  }\n// may need to convert from/to TV<=>TU\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        bit_write_T (dat, _obj->nam);                                         \\\n        LOG_TRACE (#nam \": \\\"%s\\\" [T %d]\", _obj->nam, dxf);                   \\\n        LOG_POS                                                               \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        bit_write_T (str_dat, _obj->nam);                                     \\\n        LOG_TRACE_TU (#nam, _obj->nam, dxf);                                  \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    LOG_TRACE (#nam \": [TF %d %d]\\n\", (int)len, dxf);                         \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                   \\\n          }                                                                   \\\n      }                                                                       \\\n    LOG_TRACE_TF (FIELD_VALUE (nam), (int)len);                               \\\n  }\n#define FIELD_TFF(nam, len, dxf) FIELD_TF (nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (str_dat, (BITCODE_TU)_obj->nam);                          \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_TU16(nam, dxf)                                                  \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU16 (str_dat, _obj->nam);                                    \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_T32(nam, dxf)                                                   \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_T32 (str_dat, _obj->nam);                                     \\\n    if (dat->version < R_2007)                                                \\\n      LOG_TRACE (#nam \": \\\"%s\\\" [T32 %d]\\n\", _obj->nam, dxf)                  \\\n    else                                                                      \\\n      LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf)                         \\\n  }\n#define FIELD_TU32(nam, dxf)                                                  \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU32 (str_dat, _obj->nam);                                    \\\n    if (dat->version < R_2007)                                                \\\n      LOG_TRACE (#nam \": \\\"%s\\\" [TU32 %d]\\n\", _obj->nam, dxf)                 \\\n    else                                                                      \\\n      LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf)                         \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  {                                                                           \\\n    BITCODE_BB b1 = _FIELD_DD (nam, _default, dxf);                           \\\n    if (b1 == 3)                                                              \\\n      LOG_TRACE (#nam \": %f [DD %d]\", _obj->nam, dxf)                         \\\n    else                                                                      \\\n      LOG_TRACE (#nam \": %f [DD/%d %d]\", _obj->nam, b1, dxf)                  \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    BITCODE_BB b2, b1 = _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);          \\\n    b2 = _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                    \\\n    if (b1 == 3 && b2 == 3)                                                   \\\n      LOG_TRACE (#nam \": (%f, %f) [2DD %d]\", _obj->nam.x, _obj->nam.y, dxf)   \\\n    else                                                                      \\\n      LOG_TRACE (#nam \": (%f, %f) [2DD/%d%d %d]\", _obj->nam.x, _obj->nam.y,   \\\n                   b1, b2, dxf)                                               \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\", _obj->nam.x, _obj->nam.y, dxf)     \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\", _obj->nam.x, _obj->nam.y, dxf)     \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD (nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3BD_1(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\", _b & 8, _b & 4, _b & 2,         \\\n               _b & 1, dxf);                                                  \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \" [TIMEBLL %d]\",             \\\n               _obj->nam.days, _obj->nam.ms, dxf);                            \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_TIMERLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMERLL (dat, (BITCODE_TIMERLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_RL \".\" FORMAT_RL \" [TIMERLL %d]\",             \\\n               _obj->nam.days, _obj->nam.ms, dxf);                            \\\n    LOG_POS                                                                   \\\n  }\n\n#define FIELD_CMC(color, dxf)                                                 \\\n  {                                                                           \\\n    bit_write_CMC (dat, str_dat, &_obj->color);                               \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf);    \\\n    LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, dat->bit) \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%08x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf + 420 - 62);                \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.T]\\n\", _obj->color.name);         \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.T]\\n\",                        \\\n                     _obj->color.book_name);                                  \\\n        LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, dat->bit) \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, str_dat, &_obj->o.color);                             \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->o.color.index, dxf);  \\\n    LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte,     \\\n                dat->bit)                                                     \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->o.color.rgb, dxf + 420 - 62);              \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->o.color.flag);                             \\\n        if (_obj->o.color.flag & 1)                                           \\\n          LOG_TRACE (#color \".name: %s [CMC.T]\\n\", _obj->o.color.name);       \\\n        if (_obj->o.color.flag & 2)                                           \\\n          LOG_TRACE (#color \".bookname: %s [CMC.T]\\n\",                        \\\n                     _obj->o.color.book_name);                                \\\n        LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, \\\n                    dat->bit)                                                 \\\n      }                                                                       \\\n  }\n\n#define LOG_TF(level, var, len)                                               \\\n  if (var)                                                                    \\\n    {                                                                         \\\n      int _i;                                                                 \\\n      for (_i = 0; _i < (len); _i++)                                          \\\n        {                                                                     \\\n          LOG (level, \"%02X\", (unsigned char)((char *)var)[_i]);              \\\n        }                                                                     \\\n      LOG (level, \"\\n\");                                                      \\\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                \\\n        {                                                                     \\\n          for (_i = 0; _i < (len); _i++)                                      \\\n            {                                                                 \\\n              unsigned char c = ((unsigned char *)var)[_i];                   \\\n              LOG_INSANE (\"%-2c\", isprint (c) ? c : ' ');                     \\\n            }                                                                 \\\n          LOG_INSANE (\"\\n\");                                                  \\\n        }                                                                     \\\n    }\n#define LOG_TRACE_TF(var, len) LOG_TF (TRACE, var, len)\n#define LOG_INSANE_TF(var, len) LOG_TF (INSANE, var, len)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n#define OVERFLOW_CHECK(nam, size)                                             \\\n  if ((long)(size) > 0xff00L || (!_obj->nam && size) || (_obj->nam && !size)) \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                         \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define OVERFLOW_CHECK_LV(nam, size)                                          \\\n  if ((long)(size) > 0xff00L)                                                 \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);               \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define OVERFLOW_NULL_CHECK_LV(nam, size)                                     \\\n  if ((long)(size) > 0xff00L || (!_obj->nam && size) || (_obj->nam && !size)) \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);               \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], nam[vcount - 1], dxf);                          \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (num_reactors, obj->tio.object->num_reactors)         \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->is_xdic_missing)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->is_xdic_missing)                                    \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, 3,       \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, 3,         \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \" [%s %d]\\n\", (long)vcount, \\\n                     _obj->nam[vcount], #type, dxf)                           \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, type, size, dxf)                                  \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          if (dat->version != dat->from_version)                              \\\n            FIELD_##type (nam[vcount], dxf)                                   \\\n          else if (dat->version < R_2007)                                     \\\n          {                                                                   \\\n            bit_write_TV (dat, (BITCODE_TV)_obj->nam[vcount]);                \\\n            LOG_TRACE (#nam \"[%d]: \\\"%s\\\" [TV %d]\\n\", (int)vcount,            \\\n                       _obj->nam[vcount], dxf)                                \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_##type (dat, _obj->nam[vcount]);                        \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n#define FIELD_VECTOR_INL(nam, type, size, dxf)                                \\\n  FIELD_VECTOR_N (nam, type, size, dxf)\n\n#define SUB_FIELD_VECTOR_TYPESIZE(o, nam, size, typesize, dxf)                \\\n  if (_obj->o.size > 0 && _obj->o.nam)                                        \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, _obj->o.size)                                      \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)           \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          switch (typesize)                                                   \\\n            {                                                                 \\\n            case 0:                                                           \\\n              break;                                                          \\\n            case 1:                                                           \\\n              bit_write_RC (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 2:                                                           \\\n              bit_write_RS (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 4:                                                           \\\n              bit_write_RL (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 8:                                                           \\\n              bit_write_RLL (dat, _obj->o.name[vcount]);                      \\\n              break;                                                          \\\n            default:                                                          \\\n              LOG_ERROR (\"Unkown SUB_FIELD_VECTOR_TYPE \" #nam \" typesize %d\", \\\n                         typesize);                                           \\\n              break;                                                          \\\n            }                                                                 \\\n          LOG_TRACE (#nam \"[%u]: %d\\n\", vcount, _obj->nam[vcount])            \\\n        }                                                                     \\\n    }\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0UL, 0 };                            \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\", handle_code, dxf)          \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && (hdlptr)->handleref.code != handle_code \\\n            && (handle_code == 4 && (hdlptr)->handleref.code < 6))            \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      (hdlptr)->handleref.code);                              \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &(hdlptr)->handleref);                          \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\", ARGS_REF (hdlptr), dxf)    \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\", (int)vcount, handle_code,    \\\n                   dxf)                                                       \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\", (int)vcount,          \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\", FIELD_VALUE (num_inserts))            \\\n  LOG_POS\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n  }                                                                           \\\n  RESET_VER\n\n#define START_OBJECT_HANDLE_STREAM  START_HANDLE_STREAM\n#define CONTROL_HANDLE_STREAM       START_HANDLE_STREAM\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define ENCODE_COMMON_HANDLES                                                 \\\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT && dat->version >= R_13)         \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->ownerhandle, ownerhandle, 4, 330);       \\\n      REACTORS (4);                                                           \\\n      XDICOBJHANDLE (3);                                                      \\\n    }                                                                         \\\n else if (obj->supertype == DWG_SUPERTYPE_ENTITY && dat->version >= R_13)     \\\n   {                                                                          \\\n     error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);       \\\n   }\n\n#define START_HANDLE_STREAM                                                   \\\n  LOG_INSANE (\"HANDLE_STREAM @%lu.%u\\n\", dat->byte - obj->address, dat->bit)  \\\n  if (!obj->bitsize ||                                                        \\\n       /* DD sizes can vary, but let unknown_bits asis */                     \\\n      has_entity_DD (obj) ||                                                  \\\n       (dwg->header.version != dwg->header.from_version                       \\\n        && obj->fixedtype != DWG_TYPE_UNKNOWN_OBJ                             \\\n        && obj->fixedtype != DWG_TYPE_UNKNOWN_ENT))                           \\\n    {                                                                         \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM \" FORMAT_RL \" @%lu.%u (%lu)\\n\", \\\n                 obj->bitsize, dat->byte - obj->address, dat->bit, obj->address); \\\n      obj->was_bitsize_set = 1;                                               \\\n    }                                                                         \\\n  if (!obj->hdlpos)                                                           \\\n    obj->hdlpos = bit_position (dat);                                         \\\n  {                                                                           \\\n    unsigned long _hpos = bit_position (hdl_dat);                             \\\n    if (_hpos > 0)                                                            \\\n      {                                                                       \\\n        /* save away special accumulated hdls, need to write common first */  \\\n        Bit_Chain dat1 = *hdl_dat;                                            \\\n        Bit_Chain dat2;                                                       \\\n        bit_chain_init_dat (&dat2, 12, dat);                                  \\\n        hdl_dat = &dat2;                                                      \\\n        ENCODE_COMMON_HANDLES                                                 \\\n        obj_flush_hdlstream (obj, dat, hdl_dat); /* common */                 \\\n        obj_flush_hdlstream (obj, dat, &dat1); /* special accumulated */      \\\n        bit_chain_free (&dat1);                                               \\\n        bit_chain_free (&dat2);                                               \\\n        hdl_dat = dat;                                                        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (hdl_dat != dat)                                                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        hdl_dat = dat;                                                        \\\n        ENCODE_COMMON_HANDLES                                                 \\\n      }                                                                       \\\n  }                                                                           \\\n  RESET_VER\n\nstatic void\nobj_flush_hdlstream (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                     Bit_Chain *restrict hdl_dat)\n{\n  unsigned long datpos = bit_position (dat);\n  unsigned long hdlpos = bit_position (hdl_dat);\n  unsigned long objpos = obj->address * 8;\n  LOG_TRACE (\"Flush handle stream of size %lu (@%lu.%u) to @%lu.%lu\\n\", hdlpos,\n             hdl_dat->byte, hdl_dat->bit, (datpos - objpos) / 8,\n             (datpos - objpos) % 8);\n  bit_copy_chain (dat, hdl_dat);\n}\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0;                                 \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error;                                                                \\\n    Bit_Chain _hdl_dat = { 0 };                                               \\\n    Bit_Chain *hdl_dat = &_hdl_dat; /* a new copy */                          \\\n    Bit_Chain *str_dat = dat; /* a ref */                                     \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\");                                  \\\n    bit_chain_init_dat (hdl_dat, 128, dat);                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      {                                                                       \\\n        if (hdl_dat != dat)                                                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        return error;                                                         \\\n      }                                                                       \\\n    error = dwg_encode_##token##_private (dat, hdl_dat, str_dat, obj);        \\\n    if (error & DWG_ERR_VALUEOUTOFBOUNDS && hdl_dat != dat)                   \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_encode_##token##_private (                                   \\\n        Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,               \\\n        Dwg_Object *restrict obj)                                             \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;                               \\\n\n#define DWG_ENTITY_END                                                        \\\n    if (hdl_dat->byte > dat->byte)                                            \\\n      {                                                                       \\\n        dat->byte = hdl_dat->byte;                                            \\\n        dat->bit = hdl_dat->bit;                                              \\\n      }                                                                       \\\n    if (hdl_dat != dat)                                                       \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error;                                                                \\\n    Bit_Chain _hdl_dat = { 0 };                                               \\\n    Bit_Chain *hdl_dat = &_hdl_dat; /* a new copy */                          \\\n    Bit_Chain *str_dat = dat;       /* a ref */                               \\\n    LOG_INFO (\"Encode object \" #token \"\\n\");                                  \\\n    bit_chain_init_dat (hdl_dat, 128, dat);                                   \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      {                                                                       \\\n        if (hdl_dat != dat)                                                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        return error;                                                         \\\n      }                                                                       \\\n    error = dwg_encode_##token##_private (dat, hdl_dat, str_dat, obj);        \\\n    if (error & DWG_ERR_VALUEOUTOFBOUNDS && hdl_dat != dat)                   \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_encode_##token##_private (                                   \\\n        Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,               \\\n        Dwg_Object *restrict obj)                                             \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;\n\n// some objects specs forgot about the common streams, so add it here\n#define DWG_OBJECT_END                                                        \\\n    if (!obj->hdlpos)                                                         \\\n      {                                                                       \\\n        START_OBJECT_HANDLE_STREAM                                            \\\n      }                                                                       \\\n    if (hdl_dat->byte > dat->byte)                                            \\\n      {                                                                       \\\n        dat->byte = hdl_dat->byte;                                            \\\n        dat->bit = hdl_dat->bit;                                              \\\n      }                                                                       \\\n    if (hdl_dat != dat)                                                       \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_13 && _obj->num_reactors > 0x1000)                    \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid num_reactors: %ld\\n\", (long)_obj->num_reactors);    \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat,\n                                        Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat,\n                                     Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, unsigned size);\nstatic unsigned long add_LibreDWG_APPID (Dwg_Data *dwg);\nstatic BITCODE_BL add_DUMMY_eed (Dwg_Object *obj);\nstatic void fixup_NOD (Dwg_Data *restrict dwg, Dwg_Object *restrict obj);\n\n/* Imported */\nBITCODE_H\ndwg_find_tablehandle_silent (Dwg_Data *restrict dwg, const char *restrict name,\n                             const char *restrict table);\nvoid set_handle_size (Dwg_Handle *restrict hdl);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/* if an error in this section should immediately return with a critical error,\n * like INVALIDDWG */\n#if 0\nstatic bool\nis_section_critical (Dwg_Section_Type i)\n{\n  return (i == SECTION_OBJECTS || i == SECTION_HEADER || i == SECTION_CLASSES\n          || i == SECTION_HANDLES) ? true : false;\n}\n#endif\nstatic bool\nis_section_r13_critical (Dwg_Section_Type_R13 i)\n{\n  return i <= SECTION_HANDLES_R13 ? true : false;\n}\n\n/* Limitations: */\n\nstatic unsigned long\nadd_LibreDWG_APPID (Dwg_Data *dwg)\n{\n  BITCODE_H appid = dwg_find_tablehandle_silent (dwg, \"LibreDWG\", \"APPID\");\n  BITCODE_H appctl;\n  Dwg_Object *obj;\n  Dwg_Object_APPID *_obj;\n  Dwg_Object_APPID_CONTROL *o;\n  unsigned long absref;\n  //int error = 0;\n\n  if (appid)\n    return appid->absolute_ref;\n\n  // This breaks json.test roundtrips tests as it adds a new object.\n  // But sooner or later we want to delete yet unsupported objects\n  // (Dictionaries, MATERIAL, VISUALSTYLE, dynblocks, surfaces, assoc*, ...)\n\n  // add APPID\n#if 1\n\n  _obj = dwg_add_APPID (dwg, \"LibreDWG\");\n  return dwg_obj_generic_handlevalue (_obj);\n\n#else\n  if (!(appctl = dwg->header_vars.APPID_CONTROL_OBJECT))\n    appctl = dwg_find_table_control (dwg, \"APPID_CONTROL\");\n  if (!appctl)\n    {\n      LOG_ERROR (\"APPID_CONTROL not found\")\n      return 0;\n    }\n  absref = dwg->object[dwg->num_objects - 1].handle.value + 1;\n  dwg_add_object (dwg);\n  obj = &dwg->object[dwg->num_objects - 1];\n  if (dwg_setup_APPID (obj) >= DWG_ERR_CRITICAL)\n    return 0;\n  dwg_add_handle (&obj->handle, 0, absref, obj);\n  //obj->type = obj->fixedtype = DWG_TYPE_APPID;\n  _obj = obj->tio.object->tio.APPID;\n  // precise size, bitsize done by encode\n  obj->size = 25;\n  obj->bitsize = 164;\n  obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, appctl->absolute_ref, NULL);\n  obj->tio.object->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n\n  _obj->name = dwg_add_u8_input (dwg, \"LibreDWG\");\n  _obj->is_xref_ref = 1;\n  _obj->xref = dwg_add_handleref (dwg, 5, 0, NULL);\n\n  // add to APPID_CONTROL\n  obj = dwg_ref_object (dwg, appctl);\n  if (!obj)\n    {\n      LOG_ERROR (\"APPID_CONTROL not found\")\n      return 0;\n    }\n  o = obj->tio.object->tio.APPID_CONTROL;\n  PUSH_HV (o, num_entries, entries, dwg_add_handleref (dwg, 2, absref, NULL));\n  return absref;\n\n#endif\n\n  return 0x12; // APPID.ACAD\n}\n\nstatic BITCODE_BL\nadd_DUMMY_eed (Dwg_Object *obj)\n{\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  //const int is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n  const BITCODE_BL num_eed = ent->num_eed; // same offset for object\n  Dwg_Data *dwg = obj->parent;\n  char *name = obj->dxfname;\n  BITCODE_H appid;\n  Dwg_Eed_Data *data;\n  int i = 1, off = 0;\n  int len, size;\n  const bool is_tu = dwg->header.version >= R_2007;\n\n  // FIXME\n#ifdef _WIN\n\n  return 0;\n\n#else\n\n#ifdef HAVE_STDDEF_H /* windows (mingw32,cygwin) not */\n  assert (offsetof (Dwg_Object_Object, num_eed) == offsetof (Dwg_Object_Entity, num_eed));\n  assert (offsetof (Dwg_Object_Object, eed) == offsetof (Dwg_Object_Entity, eed));\n#endif\n\n  if (num_eed) // replace it\n    dwg_free_eed (obj);\n  appid = dwg_find_tablehandle_silent (dwg, \"LibreDWG\", \"APPID\");\n  if (!appid)\n    {\n      LOG_WARN (\"APPID LibreDWG not found, no EED added\");\n      ent->num_eed = 0;\n      return 0;\n    }\n  ent->num_eed = 1;\n  ent->eed = calloc (2, sizeof (Dwg_Eed));\n  len = strlen (name);\n  size = is_tu ? 1 + 2 + ((len + 1) * 2) // RC + RS_LE + wstr\n               : 1 + 3 + len + 1;        // RC + RC+RS_LE + str\n  data = ent->eed[0].data = (Dwg_Eed_Data *)calloc (size + 3, 1);\n  ent->eed[0].size = size;\n  dwg_add_handle (&ent->eed[0].handle, 5, appid->absolute_ref, NULL);\n  data->code = 0; // RC\n  if (is_tu) // probably never used, write DUMMY placeholder to R_2007\n    {\n      BITCODE_TU wstr = bit_utf8_to_TU (name, 0);\n      data->u.eed_0_r2007.is_tu = 1;\n      data->u.eed_0_r2007.length = len; // RS\n      memcpy (data->u.eed_0_r2007.string, wstr, len * 2);\n    }\n  else\n    {\n      data->u.eed_0.is_tu = 0;\n      data->u.eed_0.length = len;  // RC\n      data->u.eed_0.codepage = 30; // RS\n      memcpy (data->u.eed_0.string, name, len);\n    }\n  LOG_TRACE (\"-EED[0]: code: 0, string: %s (len: %d)\\n\", name, len);\n\n  if (!obj->num_unknown_bits)\n    return 1;\n  // unknown_bits in chunks of 256\n  len = obj->num_unknown_bits / 8;\n  if (obj->num_unknown_bits % 8)\n    len++;\n  size = (len / 256) + 1;\n  if (size > 1) // we already reserved for two eeds\n    {\n      ent->eed = realloc (ent->eed, (1 + size) * sizeof (Dwg_Eed));\n      memset (&ent->eed[1], 0, size * sizeof (Dwg_Eed));\n    }\n  do\n    {\n      int l = len > 255 ? 255 : len;\n      ent->num_eed++;\n      ent->eed[i].size = 0;\n      ent->eed[0].size += l + 2;\n      data = ent->eed[i].data = (Dwg_Eed_Data *)calloc (l + 2, 1);\n      data->code = 4;           // RC\n      data->u.eed_4.length = l; // also just an RC. max 256, how odd\n      memcpy (data->u.eed_4.data, &obj->unknown_bits[off], data->u.eed_4.length);\n      LOG_TRACE (\"-EED[%d]: code: 4, unknown_bits: %d\\n\", i, data->u.eed_4.length);\n      if (len > 255)\n        {\n          len -= 256;\n          off += 256;\n          i++;\n        }\n      else\n        break;\n    }\n  while (1);\n  return i;\n#endif\n}\n\n#ifdef ENCODE_UNKNOWN_AS_DUMMY\n\n/** We cannot write unknown bits into another version. Also with indxf we don't\n * have that luxury. Write a DUMMY/PLACEHOLDER or POINT instead. Later maybe\n * PROXY. This leaks and is controversial. But it silences many ACAD import\n * warnings, and preserves information.\n */\nstatic void\nencode_unknown_as_dummy (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                         BITCODE_BS placeholder_type)\n{\n  Dwg_Data *dwg = obj->parent;\n  int is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n  \n  obj->size = 0;\n  obj->bitsize = 0;\n\n  if (is_entity)\n    { // POINT is better than DUMMY to preserve the next_entity chain.\n      // TODO much better would be PROXY_ENTITY\n      Dwg_Entity_POINT *_obj = obj->tio.entity->tio.POINT;\n      LOG_WARN (\"fixup unsupported %s %lX as POINT\", obj->dxfname, obj->handle.value);\n      if (!obj->tio.entity->xdicobjhandle)\n        obj->tio.entity->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n      /*\n      if (obj->tio.entity->num_reactors)\n        {\n          free (obj->tio.entity->reactors);\n          obj->tio.entity->num_reactors = 0;\n          obj->tio.entity->reactors = NULL;\n        }\n      */\n      add_DUMMY_eed (obj); // broken on windows\n      dwg_free_object_private (obj);\n      free (obj->unknown_bits);\n      obj->tio.entity->tio.POINT = _obj\n          = realloc (_obj, sizeof (Dwg_Entity_POINT));\n      // memset (_obj, 0, sizeof (Dwg_Entity_POINT)); // asan cries\n      _obj->parent = obj->tio.entity;\n      _obj->x = 0.0;\n      _obj->y = 0.0;\n      _obj->z = 0.0;\n      _obj->thickness = 1e25; // let it stand out\n      _obj->extrusion.x = 0.0;\n      _obj->extrusion.y = 0.0;\n      _obj->extrusion.z = 1.0;\n      _obj->x_ang = 0.0;\n      obj->type = DWG_TYPE_POINT;\n      obj->fixedtype = DWG_TYPE_POINT;\n      if (dwg->opts & DWG_OPTS_INJSON)\n        {\n          free (obj->name);\n          obj->name = strdup (\"POINT\");\n        }\n      else\n        obj->name = (char *)\"POINT\";\n      if (dwg->opts & DWG_OPTS_IN)\n        {\n          free (obj->dxfname);\n          obj->dxfname = strdup (\"POINT\");\n        }\n      else\n        obj->dxfname = (char *)\"POINT\";\n    }\n  else\n    {\n      const char *name;\n      const char *dxfname;\n\n      add_DUMMY_eed (obj); // broken on windows\n      dwg_free_object_private (obj);\n      // if PLACEHOLDER is available, or even PROXY_OBJECT.\n      // PLOTSETTINGS uses PLACEHOLDER though\n      if (placeholder_type)\n        {\n          obj->type = placeholder_type;\n          obj->fixedtype = DWG_TYPE_PLACEHOLDER;\n          name = \"PLACEHOLDER\";\n          dxfname = \"ACDBPLACEHOLDER\";\n        }\n      else\n        {\n          obj->type = DWG_TYPE_DUMMY;\n          obj->fixedtype = DWG_TYPE_DUMMY;\n          name = \"DUMMY\";\n          dxfname = \"DUMMY\";\n        }\n      LOG_INFO (\"fixup unsupported %s %lX as %s, Type %d\\n\", obj->dxfname,\n                obj->handle.value, name, obj->type);\n      if (!obj->tio.object->xdicobjhandle)\n        obj->tio.object->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n      // keep owner, xdicobj, reactors\n      if (dwg->opts & DWG_OPTS_INJSON)\n        {\n          free (obj->name);\n          obj->name = strdup (name);\n        }\n      else\n        obj->name = (char *)name;\n      if (dwg->opts & DWG_OPTS_IN)\n        {\n          free (obj->dxfname);\n          obj->dxfname = strdup (dxfname);\n        }\n      else\n        obj->dxfname = (char *)dxfname;\n      free (obj->unknown_bits);\n    }\n  obj->hdlpos = 0;\n}\n#endif\n\n// delete this NOD entry\n// only needed until we can write all object types (at least the ones from the NOD)\nstatic void\nremove_NOD_item (Dwg_Object_DICTIONARY *_obj, const int i, const char *name)\n{\n  int last = _obj->numitems - 1;\n  LOG_TRACE (\"Disable link to \" FORMAT_REF \" for NOD.%s\\n\",\n             ARGS_REF (_obj->itemhandles[i]), name);\n  if (i < last)\n    {\n      free (_obj->texts[i]);\n      if (!_obj->itemhandles[i]->handleref.is_global)\n        free (_obj->itemhandles[i]);\n      memmove (&_obj->texts[i], &_obj->texts[i+1], (last - i) * sizeof (BITCODE_T));\n      memmove (&_obj->itemhandles[i], &_obj->itemhandles[i+1], (last - i) * sizeof (BITCODE_H));\n    }\n  _obj->numitems--;\n  return;\n}\n\n// NOD: ACAD_TABLESTYLE => DICT name[0] - itemhandles[0] => TABLESTYLE (Unstable)\n// AcDbVariableDictionary: CTABLESTYLE => DICTVAR str\n// only needed until we can write all object types (at least the ones from the NOD)\nstatic void\nfixup_NOD (Dwg_Data *restrict dwg, Dwg_Object *restrict obj) // named object dict\n{\n  Dwg_Object_DICTIONARY *_obj;\n  int is_tu = dwg->header.version >= R_2007;\n  if (obj->handle.value != 0xC)\n    return;\n  _obj = obj->tio.object->tio.DICTIONARY;\n  // => DICTIONARY with name of current style, and link to it.\n  // If the link target is disabled (unstable, unhandled or such), remove it from the NOD.\n#define DISABLE_NODSTYLE(name)                                                \\\n  if (!is_type_stable (DWG_TYPE_##name))                                      \\\n    {                                                                         \\\n      if (is_tu)                                                              \\\n        {                                                                     \\\n          char *u8 = bit_convert_TU ((BITCODE_TU)_obj->texts[i]);             \\\n          if (u8 && strEQc (u8, \"ACAD_\" #name))                               \\\n            remove_NOD_item (_obj, i, \"ACAD_\" #name);                         \\\n          free (u8);                                                          \\\n        }                                                                     \\\n      else if (_obj->texts[i] && strEQc (_obj->texts[i], \"ACAD_\" #name))      \\\n        remove_NOD_item (_obj, i, \"ACAD_\" #name);                             \\\n    }\n  \n  for (BITCODE_BL i = 0; i < _obj->numitems; i++)\n    {\n      DISABLE_NODSTYLE (ASSOCNETWORK)\n      else DISABLE_NODSTYLE (ASSOCPERSSUBENTMANAGER)\n      else DISABLE_NODSTYLE (DETAILVIEWSTYLE)\n      else DISABLE_NODSTYLE (MATERIAL)\n      else DISABLE_NODSTYLE (MLEADERSTYLE)\n      else DISABLE_NODSTYLE (MLINESTYLE)\n      else DISABLE_NODSTYLE (PERSUBENTMGR)\n      else DISABLE_NODSTYLE (PLOTSETTINGS)\n      // else DISABLE_NODSTYLE (PLOTSTYLENAME)\n      else DISABLE_NODSTYLE (SECTIONVIEWSTYLE)\n      else DISABLE_NODSTYLE (TABLESTYLE)\n      else DISABLE_NODSTYLE (VISUALSTYLE)\n    }\n#undef DISABLE_NODSTYLE\n}\n\n/* Copy the decomp buffer uncompressed into dat of a DWG r2004+ file. Sets comp_data_size. */\nstatic int copy_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                               uint32_t decomp_data_size, uint32_t *comp_data_size)\n{\n  if (dat->byte + decomp_data_size >= dat->size)\n    {\n      dat->size = dat->byte + decomp_data_size;\n      bit_chain_alloc (dat);\n    }\n  assert (!dat->bit);\n  memcpy (&dat->chain[dat->byte], decomp, decomp_data_size);\n  dat->byte += decomp_data_size;\n  *comp_data_size = decomp_data_size;\n  return 0;\n}\n\n/* 1 for yes, 0 for no */\nstatic int\nsection_encrypted (const Dwg_Data *dwg, const Dwg_Section_Type id)\n{\n  switch (id)\n    {\n    case SECTION_SECURITY: //??\n    case SECTION_FILEDEPLIST:\n    case SECTION_APPINFO:\n      return 1;\n    case SECTION_UNKNOWN:\n    case SECTION_HEADER:\n    case SECTION_REVHISTORY:\n    case SECTION_OBJECTS:\n    case SECTION_OBJFREESPACE:\n    case SECTION_TEMPLATE:\n    case SECTION_HANDLES:\n    case SECTION_CLASSES:\n    case SECTION_AUXHEADER:\n    case SECTION_SUMMARYINFO:\n    case SECTION_PREVIEW:\n    case SECTION_APPINFOHISTORY:\n    case SECTION_VBAPROJECT:\n    case SECTION_SIGNATURE:\n    case SECTION_ACDS:\n    case SECTION_SYSTEM_MAP:\n    case SECTION_INFO:\n    default:\n      return 0;\n    }\n}\n\n/* 1 for yes, 0 for no */\nstatic int\nsection_compressed (const Dwg_Data *dwg, const Dwg_Section_Type id)\n{\n  switch (id)\n    {\n    case SECTION_UNKNOWN:\n    case SECTION_HEADER:\n    case SECTION_REVHISTORY:\n    case SECTION_OBJECTS:\n    case SECTION_OBJFREESPACE:\n    case SECTION_TEMPLATE:\n    case SECTION_HANDLES:\n    case SECTION_CLASSES:\n    case SECTION_AUXHEADER:\n    case SECTION_SYSTEM_MAP:\n    case SECTION_INFO:\n      return 1;\n    case SECTION_SUMMARYINFO:\n    case SECTION_PREVIEW:\n    case SECTION_APPINFO:\n    case SECTION_APPINFOHISTORY:\n    case SECTION_FILEDEPLIST:\n    case SECTION_SECURITY:\n    case SECTION_VBAPROJECT:\n    case SECTION_SIGNATURE:\n    case SECTION_ACDS:\n    default:\n      return 0;\n    }\n}\n\n/* r2004 compressed sections, LZ77 WIP */\n\n#define MIN_COMPRESSED_SECTION 19\n#define COMPRESSION_BUFFER_SIZE 0x400\n#define COMPRESSION_WINDOW_SIZE 0x800\n\nstatic void\nwrite_length (Bit_Chain *dat, uint32_t u1, uint32_t match, uint32_t u2);\n\n/* R2004 Write literal length\n */\nstatic unsigned char\nwrite_literal_length (Bit_Chain *restrict dat, BITCODE_RC *restrict buf, uint32_t len)\n{\n#if 0\n  if (len <= (0x0F + 3)) // single byte, opcode 0\n    {\n      bit_write_RC (dat, len - 3);\n      return 0;\n    }\n  else if (len < 0xf0)\n    {\n      bit_write_RC (dat, len);\n      return length & 0xff;\n    }\n  else\n    {\n      uint32_t total = 0x0f;\n      while (leng >= 0xf0)\n        {\n          bit_write_RC (dat, 0);\n          len -= 0xFF;\n          total += 0xFF;\n        }\n      bit_write_RC (dat, len - 3); // ??\n      return 0;\n    }\n#else\n  if (len)\n    {\n      if (len > 3) {\n        write_length (dat, 0, len - 1, 0x11);\n      }\n      LOG_INSANE (\"LIT %x\\n\", len)\n      bit_write_TF (dat, buf, len);\n    }\n  return 0;\n#endif\n}\n\n/* R2004 Long Compression Offset\n */\nstatic void\nwrite_long_compression_offset (Bit_Chain *dat, uint32_t offset)\n{\n  while (offset > 0xff)\n    {\n      bit_write_RC (dat, 0);\n      offset -= 0xff;\n    }\n  LOG_INSANE (\">O 00 %x\", offset)\n  bit_write_RC (dat, (unsigned char)offset);\n}\n\nstatic void\nwrite_length (Bit_Chain *dat, uint32_t u1, uint32_t match, uint32_t u2)\n{\n  if (u2 < match)\n    {\n      LOG_INSANE (\">L %x \", u1 & 0xff)\n      bit_write_RC (dat, u1 & 0xff);\n      write_long_compression_offset (dat, match - u2);\n      LOG_INSANE (\"\\n\")\n    }\n  else\n    {\n      LOG_INSANE (\">L %x\\n\", (u1 | (match - 2)) & 0xff);\n      bit_write_RC (dat, (u1 | (match - 2)) & 0xff);\n    }\n}\n\n/* R2004 Two Byte Offset\n */\n#if 0\nstatic unsigned int\nwrite_two_byte_offset (Bit_Chain *restrict dat, uint32_t offset)\n{\n  BITCODE_RC b1, b2;\n  b1 = offset << 2;\n  b2 = offset >> 6;\n  //offset = (firstByte >> 2) | (secondByte << 6);\n  bit_write_RC (dat, b1);\n  bit_write_RC (dat, b2);\n  //*lit_length = (firstByte & 0x03);\n  return b1 & 0x03;\n}\n#endif\n\nstatic void\nwrite_two_byte_offset (Bit_Chain *restrict dat, uint32_t oldlen, uint32_t offset, uint32_t len)\n{\n  const unsigned lookahead_buffer_size = COMPRESSION_BUFFER_SIZE;\n  uint32_t b1, b2;\n\n  LOG_INSANE (\"2O %x %x %x: \", oldlen, offset, len)\n  if ((offset < 0xf) && (oldlen < 0x401))\n    {\n      b1 = (offset + 1) * 0x10 | ((oldlen - 1U) & 3) << 2;\n      b2 = (oldlen - 1U) >> 2;\n    }\n  else\n    {\n      if (oldlen <= lookahead_buffer_size)\n        {\n          b2 = oldlen - 1;\n          write_length (dat, 0x20, offset, 0x21);\n        }\n      else\n        {\n          b2 = oldlen - lookahead_buffer_size;\n          write_length (dat, ((b2 >> 0xb) & 8U) | 0x10, offset, 9);\n        }\n      b1 = (b2 & 0xff) << 2;\n      b2 = b2 >> 6;\n    }\n  if (len < 4)\n    b1 = b1 | len;\n  LOG_INSANE (\"> %x %x\\n\", b1, b2)\n  bit_write_RC (dat, b1 & 0xff);\n  bit_write_RC (dat, b2 & 0xff);\n}\n\n/* Finds the longest match to the substring starting at i\n   in the lookahead buffer (size ?) from the history window (size ?). */\nstatic int\nfind_longest_match (BITCODE_RC *restrict decomp, uint32_t decomp_data_size, uint32_t i, uint32_t *lenp)\n{\n  const unsigned lookahead_buffer_size = COMPRESSION_BUFFER_SIZE;\n  const unsigned window_size = COMPRESSION_WINDOW_SIZE;\n  int offset = 0;\n  uint32_t bufend = MIN (i + lookahead_buffer_size, decomp_data_size + 1);\n  *lenp = 0;\n  // only substring lengths >= 2, anything else compression is longer\n  for (uint32_t j = i + 2; j < bufend; j++)\n    {\n      int start = MAX (0, (int)(i - window_size));\n      BITCODE_RC *s = &decomp[i];\n      uint32_t slen = j - i;\n      for (int k = start; k < (int)i; k++)\n        {\n          int curr_offset = i - k;\n          //unsigned int repetitions = slen / curr_offset;\n          //unsigned int last = slen % curr_offset;\n          BITCODE_RC *match = &decomp[k]; // ...\n          //int matchlen = k + last;\n          if ((memcmp (s, match, slen) == 0)\n              && slen > *lenp)\n            {\n              offset = curr_offset;\n              *lenp = slen;\n            }\n        }\n    }\n  if (offset)\n    {\n      LOG_INSANE (\">M %u (%u)\\n\", offset, *lenp)\n    }\n  return offset;\n}\n\n/* Compress the decomp buffer into dat of a DWG r2004+ file. Sets comp_data_size.\n   Variant of the LZ77 algo. ODA section 4.7\n*/\nstatic int compress_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                                   uint32_t decomp_data_size, uint32_t *comp_data_size)\n{\n  uint32_t i = 0;\n  uint32_t match = 0, oldlen = 0;\n  uint32_t len = 0;\n  unsigned long pos = bit_position (dat);\n  LOG_WARN (\"compress_R2004_section %d\", decomp_data_size);\n  assert (decomp_data_size > MIN_COMPRESSED_SECTION);\n  while (i < decomp_data_size - MIN_COMPRESSED_SECTION)\n    {\n      int offset = find_longest_match (decomp, decomp_data_size, i, &len);\n      if (offset)\n        {\n          // encode offset + len\n          if (match)\n            write_two_byte_offset (dat, oldlen, match, len);\n          write_literal_length (dat, &decomp[i], len);\n          i += match;\n          match = offset;\n          oldlen = len;\n        }\n      else\n        {\n          i += 1; // no match found\n        }\n    }\n  len = decomp_data_size - i;\n  if (match)\n    write_two_byte_offset (dat, oldlen, match, len);\n  write_literal_length (dat, &decomp[i], len);\n  bit_write_RC (dat, 0x11);\n  bit_write_RC (dat, 0);\n  bit_write_RC (dat, 0);\n  *comp_data_size = bit_position (dat) - pos;\n  LOG_INSANE (\"> 11 0 => %u\\n\", *comp_data_size)\n  return 0;\n}\n\nstatic Dwg_Section_Info *\nfind_section_info_type (const Dwg_Data *restrict dwg, Dwg_Section_Type type)\n{\n  for (unsigned i = 0; i < dwg->header.section_infohdr.num_desc; i++)\n    {\n      Dwg_Section_Info *info = &dwg->header.section_info[i];\n      if (info->fixedtype == type)\n        return info;\n    }\n  return NULL;\n}\n\n/* header.section pointers changed, rebuild all info->sections */\nstatic void\nsection_info_rebuild (Dwg_Data *dwg, Dwg_Section_Type lasttype)\n{\n  Dwg_Section_Type type;\n  // we only need to rebuild sections up to the given type\n  for (type = 0; type <= lasttype; type++)\n    {\n      Dwg_Section_Info *info = find_section_info_type (dwg, type);\n      if (info)\n        {\n          unsigned ssi = 0;\n          for (unsigned i = 0; i < dwg->header.num_sections; i++)\n            {\n              Dwg_Section *sec = &dwg->header.section[i];\n              if (sec->type == type) // first section\n                {\n                  info->sections[ssi] = sec;\n                  ssi++;\n                }\n              else if (sec->type > type) // sorted by type\n                break;\n            }\n        }\n    }\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nAFL_GCC_TOOBIG\nEXPORT int\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  long unsigned int pvzadr;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *old_dat = NULL, *str_dat, *hdl_dat;\n  int sec_id;\n  Dwg_Version_Type orig_from_version = dwg->header.from_version;\n  Bit_Chain sec_dat[SECTION_SYSTEM_MAP + 1]; // to encode each r2004 section\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s (%s) from version %s (%s)\\n\",\n               version_codes[dwg->header.version],\n               dwg_version_type (dwg->header.version),\n               version_codes[dwg->header.from_version],\n               dwg_version_type (dwg->header.from_version))\n  else\n    LOG_TRACE (\"Encode version %s (%s)\\n\", version_codes[dwg->header.version],\n               dwg_version_type (dwg->header.version))\n\n#ifdef ENCODE_UNKNOWN_AS_DUMMY\n  // We cannot write unknown_bits into another version, or when it's coming\n  // from DXF. Write a PLACEHOLDER/DUMMY or POINT instead. Later maybe PROXY.\n  // This is controversial and breaks roundtrip tests, but helps\n  // ACAD imports.\n  if (dwg->header.version != dwg->header.from_version\n      || (dwg->opts & DWG_OPTS_IN))\n    {\n      int fixup = 0;\n      // Scan for invalid/unstable/unsupported objects and entities\n      // and eliminate or replace them with placeholders.\n      LOG_TRACE (\"Scan for unsupported objects\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        {\n          Dwg_Object *obj = &dwg->object[i];\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ\n              || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT\n              // WIPEOUT causes hang, TABLEGEOMETRY crash\n              || (dwg->opts & DWG_OPTS_IN &&\n                  (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n                   obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))\n            {\n              fixup++;\n              break;\n            }\n        }\n      if (fixup)\n        {\n          unsigned long new_appid;\n          BITCODE_BS placeholder_type = 0;\n          LOG_TRACE (\"Found unsupported objects, add APPID LibreDWG\\n\");\n          new_appid = add_LibreDWG_APPID (dwg);\n          if (new_appid)\n            {\n              fixup = 0;\n              // if not found leaves placeholder_type at 0 to use DUMMY\n              dwg_find_class (dwg, \"ACDBPLACEHOLDER\", &placeholder_type);\n              for (i = 0; i < dwg->num_objects; i++)\n                {\n                  Dwg_Object *obj = &dwg->object[i];\n                  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ\n                      || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT\n                      || (dwg->opts & DWG_OPTS_IN &&\n                          (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n                           obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))\n                    {\n                      fixup++;\n                      // replace entities with points, objects with\n                      // placeholders\n                      encode_unknown_as_dummy (dat, obj, placeholder_type);\n                    }\n                  // what to do with links to MATERIAL/...\n                  if (obj->handle.value == 0xC\n                      && obj->fixedtype == DWG_TYPE_DICTIONARY)\n                    fixup_NOD (dwg, obj); // named object dict\n                }\n              LOG_TRACE (\"Fixed %d unsupported objects\\n\\n\", fixup);\n            }\n        }\n    }\n#endif\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat; // splitted later in objects/entities\n  if (!dat->version)\n    {\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n      dat->opts = dwg->opts;\n    }\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  dat->byte += 6;\n\n  {\n    Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version) // ie from DXF\n      {\n        _obj->zero_one_or_three = 1;\n        _obj->dwg_version = 0x21;\n        _obj->is_maint = 0xf;\n        _obj->maint_version = 29;\n        if (dwg->header.version < R_13)\n          {\n            _obj->dwg_version = 0x14;\n          }\n        /*\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x0b;\n            break;\n          case R_10:\n            _obj->dwg_version = 0x0d;\n            break;\n          case R_11:\n            _obj->dwg_version = 0x10;\n            break;\n          case R_13:\n            _obj->dwg_version = 0x13;\n            break;\n          case R_13c3:\n            _obj->dwg_version = 0x14;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19; // or 0x18/0x1a\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x1d;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_3:\n          case R_1_4:\n          case R_1_402b:\n          case R_2_0:\n          case R_2_1:\n          case R_2_21:\n          case R_2_22:\n          case R_2_4:\n          case R_2_5:\n          case R_2_6:\n          case R_9c1:\n          case R_10c1:\n          case R_10c2:\n          case R_12:\n          case R_12c1:\n          default:\n            break;\n          }\n          */\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    /* Usually 3-5, max 6 */\n    if (!dwg->header.num_sections\n        || (dat->from_version >= R_2004 && dwg->header.num_sections > 6))\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            // hack to trigger IF_ENCODE_FROM_EARLIER defaults. undone after\n            // HEADER\n            dat->from_version = R_11;\n            if (dat->version <= dat->from_version)\n              dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section = (Dwg_Section*)calloc (dwg->header.num_sections,\n                                                  sizeof (Dwg_Section));\n    if (!dwg->header.section)\n      {\n        LOG_ERROR (\"Out of memory\");\n        return DWG_ERR_OUTOFMEM;\n      }\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        BITCODE_BL vcount;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version) // todo: needed?\n          {\n            BITCODE_RS def_unknown_6rs[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_6rs), def_unknown_6rs,\n                    sizeof (def_unknown_6rs));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\");\n    dat->version = dwg->header.version = R_2010; // rather do 2010\n    // return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    LOG_INFO (\"\\n\");\n    LOG_ERROR (WE_CAN \"Writing R2004 sections not yet finished\");\n\n    memset (&sec_dat, 0, (SECTION_SYSTEM_MAP + 1) * sizeof (Bit_Chain));\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = (Dwg_Section_Info *)calloc (\n          dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));\n    LOG_TRACE (\"\\n#### r2004 File Header ####\\n\");\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dwg->header.num_sections = 28; // room for some object pages\n        dwg->header.section = calloc (28, sizeof (Dwg_Section));\n      }\n    if (!dwg->header.section_info)\n      {\n        dwg->header.section_infohdr.num_desc = SECTION_SYSTEM_MAP + 1;\n        dwg->header.section_info\n            = calloc (SECTION_SYSTEM_MAP + 1, sizeof (Dwg_Section_Info));\n      }\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  old_dat = dat;\n  SINCE (R_2004)\n  {\n    bit_chain_init_dat (&sec_dat[SECTION_PREVIEW], dwg->thumbnail.size + 64, dat);\n    str_dat = hdl_dat = dat = &sec_dat[SECTION_PREVIEW];\n  }\n  else\n  {\n    if (!dwg->header.thumbnail_address)\n      dwg->header.thumbnail_address = dat->byte;\n  }\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL bmpsize;\n    dwg_bmp (dwg, &bmpsize);\n    if (bmpsize > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", bmpsize,\n                 dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_HEADER;\n    bit_chain_init_dat (&sec_dat[sec_id], sizeof (Dwg_Header) + 64, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Empty header.section\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  // undo minimal HEADER hack\n  if (dat->from_version != orig_from_version)\n    dat->from_version = orig_from_version;\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason.\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_CLASSES;\n    bit_chain_init_dat (&sec_dat[sec_id],\n                    (sizeof (Dwg_Class) * dwg->num_classes) + 32, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else sec_id = SECTION_CLASSES_R13;\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte,\n            dwg->num_classes);\n  if (dwg->num_classes > 5000)\n    {\n      LOG_ERROR (\"Invalid dwg->num_classes %d\", dwg->num_classes)\n      dwg->num_classes = 0;\n      error |= DWG_ERR_VALUEOUTOFBOUNDS | DWG_ERR_CLASSESNOTFOUND;\n    }\n  dwg->header.section[sec_id].number = 1;\n  dwg->header.section[sec_id].address = dat->byte; // FIXME\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      SINCE (R_2007) {\n        bit_write_T (dat, klass->appname);\n        bit_write_T (dat, klass->cppname);\n      } else {\n        bit_write_TV (dat, klass->appname);\n        bit_write_TV (dat, klass->cppname);\n      }\n      SINCE (R_2007) // only when we have it. like not for 2004 => 2007\n                     // conversions\n      {\n        if (klass->dxfname_u)\n          bit_write_TU (dat, klass->dxfname_u);\n        else\n          bit_write_T (dat, klass->dxfname);\n      }\n      else // we always have this one\n          bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->is_zombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->is_zombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        if (dat->from_version < R_2007 && !klass->dwg_version) {\n          // defaults\n          klass->dwg_version = (BITCODE_BL)dwg->header.dwg_version;\n          klass->maint_version = (BITCODE_BL)dwg->header.maint_version;\n          // TODO num_instances\n        }\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_OBJECTS;\n    bit_chain_alloc (&sec_dat[sec_id]);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n    bit_chain_set_version (dat, old_dat);\n  }\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n#ifndef NDEBUG\n      PRE (R_2004)\n        assert (dat->byte);\n#endif\n      if (!obj->parent)\n        obj->parent = dwg;\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0. but with r2004 it starts\n      // fresh.\n      if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)\n        {\n          if (dat->size < 6 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n            {\n              LOG_ERROR (\"Encode overwrite pos 0, invalid DWG magic\");\n              return DWG_ERR_INVALIDDWG;\n            }\n          assert (dat->size > 6);\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_HANDLES;\n    bit_chain_init_dat (&sec_dat[sec_id], (8 * dwg->num_objects) + 32, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else\n  {\n    sec_id = SECTION_HANDLES_R13;\n    dwg->header.section[sec_id].number = 2;\n    dwg->header.section[sec_id].address = dat->byte;\n    pvzadr = dat->byte; // Correct value of section size must be written later\n    dat->byte += 2;\n  }\n\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n#ifndef NDEBUG\n      PRE (R_2004)\n        assert (pvzadr);\n#endif\n      if (pvzadr + 1 >= dat->size)\n        bit_chain_alloc(dat);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n#ifndef NDEBUG\n  if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)\n    {\n      if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n        {\n          LOG_ERROR (\"Encode overwrite pos 0\");\n          return DWG_ERR_INVALIDDWG;\n        }\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  PRE (R_2004)\n    assert (dat->byte);\n#endif\n  pvzadr = dat->byte;\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[sec_id].size\n      = dat->byte - dwg->header.section[sec_id].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004. (TODO: under which name? AuxHeader?)\n   */\n  if (dwg->header.version >= R_13 && dwg->header.version < R_2004 // TODO\n      && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat,\n                          dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %u\\n\", (unsigned)pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n          // TODO handlers defaults\n        }\n      // always recomputed, even with dwgrewrite\n      if (dwg->header.version <= R_2000)\n        {\n          _obj->num_sections = dwg->header.num_sections;\n          for (i = 0; i < _obj->num_sections; i++)\n            {\n              _obj->section[i].nr = dwg->header.section[i].number;\n              _obj->section[i].address = dwg->header.section[i].address;\n              _obj->section[i].size = dwg->header.section[i].size;\n            }\n        }\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %u != %u\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n          dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n          dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n        }\n      FIELD_BL (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (BITCODE_TF)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BL (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13\n           && dwg->header.version < R_2004) // TODO\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT/Template Section 4\n   * In a DXF under header_vars\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_TEMPLATE;\n    bit_chain_init_dat (&sec_dat[sec_id], 16, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else sec_id = SECTION_MEASUREMENT_R13;\n\n  if (dwg->header.version >= R_2004 || (int)dwg->header.num_sections > sec_id)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[sec_id].number = 4;\n      dwg->header.section[sec_id].address = dat->byte;\n      dwg->header.section[sec_id].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL_LE (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT ? 256 : 0);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL_LE]\\n\",\n                 dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n  SINCE (R_2004)\n  {\n    Dwg_Section_Type type;\n    Dwg_Object *obj = NULL;\n    BITCODE_BL vcount, rcount3;\n    size_t size;\n    unsigned total_size = 0;\n\n    // write remaining section data\n    for (type = SECTION_OBJFREESPACE; type < SECTION_SYSTEM_MAP; type++)\n      {\n        if (type != SECTION_OBJECTS && type != SECTION_PREVIEW)\n          LOG_TRACE (\"\\n=== Section %s ===\\n\", dwg_section_name (dwg, type))\n        switch (type)\n          {\n          case SECTION_HEADER: // ignore, already done\n          case SECTION_AUXHEADER:\n          case SECTION_CLASSES:\n          case SECTION_HANDLES:\n          case SECTION_TEMPLATE:\n          case SECTION_PREVIEW:\n          case SECTION_OBJECTS:\n          case SECTION_UNKNOWN: // deferred\n          case SECTION_INFO:\n          case SECTION_SYSTEM_MAP:\n            break;\n          case SECTION_OBJFREESPACE:\n            {\n              Dwg_ObjFreeSpace *_obj = &dwg->objfreespace;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"objfreespace.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_REVHISTORY:\n            {\n              Dwg_RevHistory *_obj = &dwg->revhistory;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"revhistory.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SUMMARYINFO:\n            {\n              Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"summaryinfo.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_APPINFO:\n            {\n              Dwg_AppInfo *_obj = &dwg->appinfo;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"appinfo.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_APPINFOHISTORY:\n            {\n#if 0\n              Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#  include \"appinfohistory.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_FILEDEPLIST:\n            {\n              Dwg_FileDepList *_obj = &dwg->filedeplist;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"filedeplist.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SECURITY:\n            {\n              Dwg_Security *_obj = &dwg->security;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"security.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SIGNATURE:\n            {\n#if 0\n              Dwg_Signature *_obj = &dwg->signature;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n              {\n#  include \"signature.spec\"\n              }\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_ACDS:\n            {\n#if 0\n              Dwg_AcDs *_obj = &dwg->acds;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n              {\n#  include \"acds.spec\"\n              }\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_VBAPROJECT: // nyi\n          default:\n            break;\n          }\n      }\n    // and write system and data section maps.\n    dat = old_dat;\n\n    /*-------------------------------------------------------------------------\n     * Section map and info\n     */\n    // no gaps, so header->num_sections == r2004_header->numsections\n    // get together all the section sizes, and set the addresses\n    {\n      int ssize;\n      int si, info_id;\n      unsigned address;\n\n      const Dwg_Section_Type section_map_order[] = {\n        // R2004_Header\n        SECTION_UNKNOWN, // the empty section 128-256\n        SECTION_SECURITY,       SECTION_FILEDEPLIST, SECTION_ACDS,\n        SECTION_VBAPROJECT,\n        SECTION_APPINFOHISTORY, //? at least before AppInfo\n        SECTION_APPINFO,        SECTION_PREVIEW,\n        SECTION_SUMMARYINFO, // sometimes this is before Preview\n        SECTION_REVHISTORY,     SECTION_OBJECTS,     SECTION_OBJFREESPACE,\n        SECTION_TEMPLATE,       SECTION_HANDLES,     SECTION_CLASSES,\n        SECTION_AUXHEADER,      SECTION_HEADER,      SECTION_SIGNATURE,\n\n        SECTION_INFO,           SECTION_SYSTEM_MAP\n      };\n\n      // not the order in the system map, but the order in the dat stream.\n      const Dwg_Section_Type stream_order[]\n          = {                  // R2004_Header\n              SECTION_UNKNOWN, // the empty section 128-256\n              SECTION_SUMMARYINFO, SECTION_PREVIEW,        SECTION_VBAPROJECT,\n              SECTION_APPINFO,     SECTION_APPINFOHISTORY, SECTION_FILEDEPLIST,\n              SECTION_ACDS,        SECTION_REVHISTORY,     SECTION_SECURITY,\n              SECTION_OBJECTS,     SECTION_OBJFREESPACE,   SECTION_TEMPLATE,\n              SECTION_HANDLES,     SECTION_CLASSES,        SECTION_AUXHEADER,\n              SECTION_HEADER,\n\n              SECTION_SIGNATURE, //?\n\n              SECTION_INFO,        SECTION_SYSTEM_MAP\n            };\n\n      dwg->r2004_header.numsections = 0;\n      dwg->r2004_header.numgaps = 0;\n\n      //sec_dat[SECTION_UNKNOWN].byte = 0;\n      sec_dat[SECTION_INFO].byte = 10\n                                   + (dwg->header.section_infohdr.num_desc\n                                      * sizeof (Dwg_Section_Info));\n      // only a guess, reserve at least one page\n      sec_dat[SECTION_SYSTEM_MAP].byte = (4 * 20 * sizeof (Dwg_Section));\n\n      section_address = 0x100;\n      // first all the data pages, than a number gap of 1, and last the two\n      // system page maps, info and system_map the data_pages (system_map\n      // sections) can include multiple pages of the same type.\n      LOG_TRACE (\"\\n=== Section map and info page sizes ===\\n\");\n      for (si = 0, info_id = 0, type = 0; type <= SECTION_SYSTEM_MAP;\n           type++, i++)\n        {\n          if (sec_dat[type].byte)\n            {\n              const unsigned int max_decomp_size\n                  = section_max_decomp_size (dwg, type);\n              const char *name = dwg_section_name (dwg, type);\n              Dwg_Section_Info *info;\n              if (sec_dat[type].bit)\n                {\n                  LOG_WARN (\"Unpadded section %d\", type);\n                  sec_dat[type].byte++;\n                }\n              ssize = (int)sec_dat[type].byte;\n              sec_dat[type].size = ssize;\n              if (info_id >= (int)dwg->header.section_infohdr.num_desc)\n                {\n                  dwg->header.section_infohdr.num_desc = info_id + 1;\n                  dwg->header.section_info\n                      = realloc (dwg->header.section_info,\n                                 (info_id + 1) * sizeof (Dwg_Section));\n                }\n              info = &dwg->header.section_info[info_id];\n              info->fixedtype = type;\n              info->type = type;\n              info->unknown = 1;\n              if (name && si && type < SECTION_INFO) // not UNKNOWN and the last two\n                strcpy (info->name, name);\n              else\n                memset (info->name, 0, 64);\n              info->size = ssize;\n              info->max_decomp_size = max_decomp_size;\n              info->encrypted = section_encrypted (dwg, type);\n              info->compressed = 1 + section_compressed (dwg, type);\n#ifndef HAVE_COMPRESS_R2004_SECTION\n              info->compressed = 1;\n#endif\n              // pre-calc num_sections for both\n              if ((unsigned)ssize <= max_decomp_size)\n                info->num_sections = 1;\n              else\n                {\n                  info->num_sections = (unsigned)ssize / max_decomp_size;\n                  if ((unsigned)ssize % max_decomp_size)\n                    info->num_sections++;\n                }\n              info->sections\n                  = calloc (info->num_sections, sizeof (Dwg_Section*));\n              // enough sections?\n              if (si + info->num_sections > dwg->header.num_sections)\n                {\n                  Dwg_Section *oldsecs = dwg->header.section;\n                  dwg->header.num_sections = si + info->num_sections;\n                  dwg->header.section = realloc (dwg->header.section,\n                                                 dwg->header.num_sections\n                                                     * sizeof (Dwg_Section));\n                  if (dwg->header.section != oldsecs)\n                    // need to rebuild all info->sections\n                    section_info_rebuild (dwg, type);\n                }\n              {\n                int ssi = 0;\n                do\n                  {\n                    Dwg_Section *sec = &dwg->header.section[si];\n                    total_size += ssize;\n                    sec->number = si + 1; // index starting at 1\n                    sec->size = MIN (max_decomp_size, (unsigned)ssize);\n                    sec->decomp_data_size = sec->size;\n                    sec->type = type;\n                    sec->compression_type = info->compressed;\n                    info->sections[ssi] = sec;\n                    LOG_TRACE (\"section[%d] %s[%d].sections[%d]: number=%d \"\n                               \"size=%d\\n\", si,\n                               dwg_section_name (dwg, type), info_id, ssi,\n                               sec->number, (int)sec->size);\n                    ssize -= max_decomp_size;\n                    ssi++; // info->sections index\n                    si++;  // section index\n                  }\n                while (ssize > (int)max_decomp_size); // keep same type\n              }\n              info_id++;\n            }\n          else\n            LOG_TRACE (\"section_info %s is empty, skipped. size=0\\n\",\n                       dwg_section_name (dwg, type));\n        }\n      dwg->r2004_header.numsections = si;\n      // section_info [27] and section_map [28] as two last already added.\n      if ((unsigned)si > dwg->header.num_sections) // needed?\n        {\n          Dwg_Section *oldsecs = dwg->header.section;\n          dwg->header.num_sections = si;\n          dwg->header.section = realloc (dwg->header.section, si * sizeof (Dwg_Section));\n          if (dwg->header.section != oldsecs)\n            section_info_rebuild (dwg, SECTION_SYSTEM_MAP);\n        }\n      dwg->r2004_header.section_info_id = dwg->r2004_header.numsections + 1; // a gap of 3\n      dwg->r2004_header.section_map_id = dwg->r2004_header.numsections + 2;\n      dwg->r2004_header.section_array_size = dwg->r2004_header.numsections + 2;\n      dwg->r2004_header.last_section_id = dwg->r2004_header.section_map_id;\n      dwg->header.section[si - 2].number = dwg->r2004_header.section_info_id; \n      dwg->header.section[si - 1].number = dwg->r2004_header.section_map_id;\n\n      LOG_TRACE (\"\\n=== Section Info %d in map order ===\\n\",\n                 dwg->r2004_header.section_info_id);\n      // write into sec_dat[type] first, then compress\n      sec_id = SECTION_INFO;\n      sec_dat[sec_id].size = sec_dat[sec_id].byte;\n      bit_chain_alloc (&sec_dat[sec_id]);\n      dat = &sec_dat[sec_id];\n      bit_chain_set_version (dat, old_dat);\n      bit_set_position (dat, 0); // so far we faked the content. now write it\n\n      {\n        Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;\n        Dwg_Section *sec = &dwg->header.section[si - 2];\n        Dwg_Section_Info *info = find_section_info_type (dwg, sec_id);\n        // index starting at 1\n        sec->number = dwg->r2004_header.section_info_id;\n        sec->size = MIN (0x7400, sec->size);\n        sec->decomp_data_size = sec->size;\n        sec->type = type;\n        if (info)\n          {\n            sec->compression_type = info->compressed;\n            // very unlikely, more than 1 page\n            info->sections[0] = sec;\n          }\n        if (_obj->compressed == 2 && sec->size <= MIN_COMPRESSED_SECTION)\n          _obj->compressed = 1;\n#ifndef HAVE_COMPRESS_R2004_SECTION\n        _obj->compressed = 1;\n#endif\n        LOG_HANDLE (\"InfoHdr @%lu.0\\n\", dat->byte);\n        FIELD_RL (num_desc, 0);\n        FIELD_RL (compressed, 0);\n        FIELD_RL (max_size, 0);\n        FIELD_RL (encrypted, 0);\n        FIELD_RL (num_desc2, 0);\n      }\n      for (i = 0; i < ARRAY_SIZE (section_map_order); i++)\n        {\n          Dwg_Section_Info *_obj;\n          type = section_map_order[i];\n          _obj = find_section_info_type (dwg, type);\n          if (_obj)\n            {\n              assert (type == _obj->fixedtype);\n              LOG_TRACE (\"\\nSection_Info %s [%d]\\n\",\n                         dwg_section_name (dwg, type), i);\n              FIELD_RLLu (size, 0);\n              FIELD_RL (num_sections, 0);\n              FIELD_RL (max_decomp_size, 0);\n              FIELD_RL (unknown, 0);\n              FIELD_RL (compressed, 0);\n              FIELD_RL (type, 0);\n              FIELD_RL (encrypted, 0);\n              bit_write_TF (dat, (unsigned char *)_obj->name, 64);\n              LOG_TRACE (\"name: %s\\n\", *_obj->name ? _obj->name : \"\");\n            }\n        }\n\n      LOG_TRACE (\"\\n=== Section System Map %d in map order ===\\n\",\n                 dwg->r2004_header.section_map_id);\n      sec_id = type = SECTION_SYSTEM_MAP;\n      {\n        //Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;\n        Dwg_Section *sec = &dwg->header.section[si - 1];\n        Dwg_Section_Info *info = find_section_info_type (dwg, type);\n        if (!info || !info->sections)\n          {\n            LOG_ERROR (\"SECTION_SYSTEM_MAP not found\");\n            return DWG_ERR_SECTIONNOTFOUND;\n          }\n\n        sec_dat[sec_id].size = sec_dat[sec_id].byte;\n        bit_chain_alloc (&sec_dat[sec_id]);\n        str_dat = hdl_dat = dat = &sec_dat[sec_id];\n        bit_chain_set_version (dat, old_dat);\n        bit_set_position (dat, 0); // so far we faked the content. now write it\n\n        // index starting at 1\n        sec->number = dwg->r2004_header.section_map_id;\n        sec->size = MIN (0x7400, sec->size);\n        sec->decomp_data_size = sec->size;\n        sec->type = type;\n        sec->compression_type = info->compressed;\n        // very unlikely, more than 1 page\n        info->sections[0] = sec;\n      }\n      \n      address = 0x100;\n      for (i = 0; i < dwg->header.num_sections; i++)\n        {\n          Dwg_Section *_obj = &dwg->header.section[i];\n\n          FIELD_RL (number, 0);\n          FIELD_RL (size, 0);\n          _obj->address = address;\n          FIELD_RLL (address, 0);\n          address += _obj->size;\n          if (_obj->number < 0) // gap. unused. we deleted all gaps\n            {\n              FIELD_RL (parent, 0);\n              FIELD_RL (left, 0);\n              FIELD_RL (right, 0);\n              FIELD_RL (x00, 0);\n            }\n        }\n      dwg->r2004_header.decomp_data_size = dat->byte; // system_map_size\n      LOG_TRACE (\"-size: %lu\\n\", dat->byte);\n\n      dat = old_dat;\n#ifndef NDEBUG\n      if (dwg->header.version >= R_1_2)\n        {\n          if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n            {\n              LOG_ERROR (\"Encode overwrite pos 0\");\n              return DWG_ERR_INVALIDDWG;\n            }\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n          assert (dat->byte <= 0x100);\n        }\n#endif\n\n      // now write all the sections in the stream order\n      LOG_TRACE (\"\\n=== Write sections in stream order ===\\n\");\n      size = total_size\n             + (8 * ((dwg->r2004_header.numsections + 2) * 24)); // no gaps\n      dat->byte = section_address;\n      if (dat->byte + size >= dat->size)\n        {\n          dat->size = dat->byte + size;\n          bit_chain_alloc (dat);\n        }\n      LOG_HANDLE (\"@%lu.0\\n\", dat->byte);\n      for (i = 0; i < ARRAY_SIZE (stream_order); i++)\n        {\n          Dwg_Section_Info *info;\n          type = stream_order[i];\n          info = find_section_info_type (dwg, type);\n          if (info)\n            {\n              LOG_TRACE (\"Write %s pages @%lu (%u/%lu)\\n\",\n                         dwg_section_name (dwg, type), dat->byte,\n                         info->num_sections, sec_dat[type].size);\n              for (unsigned k = 0; k < info->num_sections; k++)\n                {\n                  Dwg_Section *sec = info->sections[k];\n                  if (!sec)\n                    {\n                      LOG_ERROR (\"empty info->sections[%u]\", k);\n                      continue;\n                    }\n                  if (!sec_dat[type].chain)\n                    {\n                      LOG_ERROR (\"empty %s.chain\", dwg_section_name (dwg, type));\n                      continue;\n                    }\n#ifndef NDEBUG\n                  if (info->fixedtype < SECTION_INFO)\n                    assert (info->fixedtype == sec->type);\n#endif\n                  if (info->fixedtype == SECTION_SUMMARYINFO)\n                    dwg->header.summaryinfo_address = dat->byte;\n                  else if (info->fixedtype == SECTION_PREVIEW)\n                    dwg->header.thumbnail_address = dat->byte;\n                  else if (info->fixedtype == SECTION_VBAPROJECT)\n                    dwg->header.vbaproj_address = dat->byte;\n                  else if (info->fixedtype == SECTION_SYSTEM_MAP)\n                    {\n                      dwg->r2004_header.section_map_address = dat->byte - 0x100;\n                      dwg->r2004_header.last_section_address = dat->byte + sec->size - 0x100;\n                      dwg->r2004_header.second_header_address = 0; // TODO\n                    }\n                  sec->address = dat->byte;\n\n                  if (info->encrypted)\n                    {\n                      BITCODE_RC *decr = calloc (sec->size, 1);\n                      LOG_HANDLE (\"Encrypt %s (%u/%d)\\n\", info->name, k,\n                                  sec->size);\n                      decrypt_R2004_header (decr, sec_dat[type].chain,\n                                            sec->size);\n                      free (sec_dat[type].chain);\n                      sec_dat[type].chain = decr;\n                    }\n                  assert (sec->size <= MIN_COMPRESSED_SECTION ? info->compressed == 1 : 1);\n                  if (info->compressed == 2)\n                    {\n                      LOG_HANDLE (\"Compress %s (%u/%d)\\n\", info->name, k,\n                                  sec->size);\n                      compress_R2004_section (dat, sec_dat[type].chain,\n                                              sec->size, &sec->comp_data_size);\n                      LOG_TRACE (\"sec->comp_data_size: \" FORMAT_RL \"\\n\", sec->comp_data_size);\n                    }\n                  else\n                    {\n                      LOG_HANDLE (\"Copy uncompressed %s (%u/%d)\\n\", info->name,\n                                  k, sec->size);\n                      copy_R2004_section (dat, sec_dat[type].chain, sec->size,\n                                          &sec->comp_data_size);\n                    }\n                }\n              bit_chain_free (&sec_dat[type]);\n            }\n        }\n    }\n\n    {\n      Dwg_R2004_Header *_obj = &dwg->r2004_header;\n      Bit_Chain file_dat = { NULL, sizeof (Dwg_R2004_Header), 0UL, 0, 0, 0, 0, NULL };\n      Bit_Chain *orig_dat = dat;\n      /* \"AcFssFcAJMB\" encrypted: 6840F8F7922AB5EF18DD0BF1 */\n      const unsigned char enc_file_ID_string[]\n          = { '\\x68', '\\x40', '\\xF8', '\\xF7', '\\x92', '\\x2A',\n              '\\xB5', '\\xEF', '\\x18', '\\xDD', '\\x0B', '\\xF1' };\n      uint32_t checksum;\n\n      file_dat.chain = calloc (1, sizeof (Dwg_R2004_Header));\n      dat = &file_dat;\n      LOG_TRACE (\"\\nSection R2004_Header @0x100\\n\");\n\n      checksum = _obj->crc32;\n      LOG_HANDLE (\"old crc32: 0x%x\\n\", _obj->crc32);\n      _obj->crc32 = 0;\n      // recalc the CRC32, without the padding, but the crc32 as 0\n      _obj->crc32\n          = bit_calc_CRC32 (0, (unsigned char *)&dwg->r2004_header, 0x6c);\n      LOG_HANDLE (\"calc crc32: 0x%x\\n\", _obj->crc32);\n\n      // clang-format off\n      #include \"r2004_file_header.spec\"\n      // clang-format on\n\n      // go back and encrypt it\n      dat = orig_dat;\n      decrypt_R2004_header (&dat->chain[0x80], file_dat.chain,\n                            sizeof (Dwg_R2004_Header));\n      bit_chain_free (&file_dat);\n      LOG_HANDLE (\"encrypted R2004_Header:\\n\");\n      LOG_TF (HANDLE, &dat->chain[0x80], (int)sizeof (Dwg_R2004_Header));\n      if (memcmp (&dat->chain[0x80], enc_file_ID_string,\n                  sizeof (enc_file_ID_string)))\n        {\n          LOG_ERROR (\"r2004_file_header encryption error\");\n          return error | DWG_ERR_INVALIDDWG;\n        }\n    } // R2004_Header\n  } // R_2004\n\n  assert (!dat->bit);\n  dat->size = dat->byte;\n  LOG_INFO (\"\\nFinal DWG size: %u\\n\", (unsigned)dat->size);\n\n  UNTIL (R_2000)\n  {\n    /* Patch section addresses\n     */\n    assert (section_address);\n    dat->byte = section_address;\n    dat->bit = 0;\n    LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n    for (j = 0; j < dwg->header.num_sections; j++)\n      {\n        LOG_TRACE (\"section[%u].number: %4d [RC] %s\\n\", j,\n                   (int)dwg->header.section[j].number,\n                   j < 6 ? dwg_section_name (dwg, j) : \"\");\n        LOG_TRACE (\"section[%u].offset: %4u [RL]\\n\", j,\n                   (unsigned)dwg->header.section[j].address);\n        LOG_TRACE (\"section[%u].size:   %4u [RL]\\n\", j,\n                   (int)dwg->header.section[j].size);\n        if ((unsigned long)dwg->header.section[j].address\n                + dwg->header.section[j].size\n            > dat->size)\n          {\n            if (is_section_r13_critical (j))\n              {\n                LOG_ERROR (\"section[%u] %s address or size overflow\", j,\n                           j < 6 ? dwg_section_name (dwg, j) : \"\");\n                return DWG_ERR_INVALIDDWG;\n              }\n            else\n              {\n                LOG_WARN (\"section[%u] %s address or size overflow, skipped\",\n                          j, j < 6 ? dwg_section_name (dwg, j) : \"\");\n                dwg->header.section[j].address = 0;\n                dwg->header.section[j].size = 0;\n              }\n          }\n        bit_write_RC (dat, dwg->header.section[j].number);\n        bit_write_RL (dat, dwg->header.section[j].address);\n        bit_write_RL (dat, dwg->header.section[j].size);\n      }\n\n    /* Write CRC's\n     */\n    bit_write_CRC (dat, 0, 0);\n    dat->byte -= 2;\n    ckr = bit_read_CRC (dat);\n    dat->byte -= 2;\n    // FIXME: r13-2000 only\n    switch (dwg->header.num_sections)\n      {\n      case 3:\n        ckr ^= 0xA598;\n        break;\n      case 4:\n        ckr ^= 0x8101;\n        break;\n      case 5:\n        ckr ^= 0x3CC4;\n        break;\n      case 6:\n        ckr ^= 0x8461;\n        break;\n      default:\n        break;\n      }\n    bit_write_RS (dat, ckr);\n    LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n  }\n\n  return 0;\n  }\n  AFL_GCC_POP\n\n  static int encode_preR13 (Dwg_Data * restrict dwg, Bit_Chain * restrict dat)\n  {\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  if (!dwg || !dwg->dwg_class)\n    return NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  // a static string, which cannot be free'd. important for\n                  // indxf\n                  if (dwg->opts & DWG_OPTS_IN)\n                    obj->dxfname = strdup ((char *)alias);\n                  else\n                    obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_IN))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat,\n                          Dwg_Object *restrict obj)\n{\n  //int error = 0;\n  int is_entity;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INVALIDTYPE;\n  is_entity = dwg_class_is_entity (klass);\n  // check if it really was an entity\n  if ((is_entity && obj->supertype == DWG_SUPERTYPE_OBJECT)\n      || (!is_entity && obj->supertype == DWG_SUPERTYPE_ENTITY))\n    {\n      if (is_dwg_object (obj->name))\n        {\n          if (is_entity)\n            {\n              LOG_INFO (\"Fixup Class %s item_class_id to %s for %s\\n\",\n                        klass->dxfname, \"OBJECT\", obj->name);\n              klass->item_class_id = 0x1f2;\n              if (!klass->dxfname || strNE (klass->dxfname, obj->dxfname))\n                {\n                  free (klass->dxfname);\n                  klass->dxfname = strdup (obj->dxfname);\n                }\n              is_entity = 0;\n            }\n          else\n            {\n              LOG_INFO (\"Fixup %s.supertype to %s\\n\", obj->name, \"OBJECT\");\n              obj->supertype = DWG_SUPERTYPE_OBJECT;\n            }\n        }\n      else if (is_dwg_entity (obj->name))\n        {\n          if (!is_entity)\n            {\n              LOG_INFO (\"Fixup Class %s item_class_id to %s for %s\\n\",\n                        klass->dxfname, \"ENTITY\", obj->name);\n              klass->item_class_id = 0x1f3;\n              if (!klass->dxfname || strNE (klass->dxfname, obj->dxfname))\n                {\n                  free (klass->dxfname);\n                  klass->dxfname = strdup (obj->dxfname);\n                }\n              is_entity = 1;\n            }\n          else\n            {\n              LOG_INFO (\"Fixup %s.supertype to %s\", obj->name, \"ENTITY\");\n              obj->supertype = DWG_SUPERTYPE_ENTITY;\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Illegal Class %s is_%s item_class_id for %s\",\n                     klass->dxfname, is_entity ? \"entity\" : \"object\",\n                     obj->name);\n          return DWG_ERR_INVALIDTYPE;\n        }\n    }\n\n  if (dwg->opts & DWG_OPTS_IN) // DXF or JSON import\n    {\n      unsigned long pos = bit_position (dat);\n\n      /* Should not be triggered. Only when undef ENCODE_UNKNOWN_AS_DUMMY */\n      if (is_type_unstable (obj->fixedtype) &&\n          (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n           obj->fixedtype == DWG_TYPE_TABLEGEOMETRY))\n        {\n          LOG_WARN (\"Skip broken %s\", obj->name); // acad crashes still\n          obj->type = is_entity ? DWG_TYPE_UNKNOWN_ENT : DWG_TYPE_PLACEHOLDER;\n          klass->dxfname = strdup (is_entity ? \"UNKNOWN_ENT\" : \"UNKNOWN_OBJ\");\n        }\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->is_zombie ? \"is_zombie\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  //unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n  Dwg_Data *dwg = obj->parent;\n\n  //oldpos = bit_position (dat);\n  PRE (R_2004)\n    {\n      if (!address)\n        return DWG_ERR_INVALIDDWG;\n      assert (address);\n    }\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  if (obj->size > 0x100000)\n    {\n      LOG_ERROR (\"Object size %u overflow\", obj->size);\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // First write an aproximate size here.\n  // Then calculate size from the fields. Either <0x7fff or more.\n  // Patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010)\n  {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS], Address: %lu\\n\", obj->size, obj->type, obj->address)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT], Address: %lu\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type, obj->address)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      error = dwg_encode_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      error = dwg_encode_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      //LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own AcDb::VBAProject section\");\n      error = dwg_encode_VBA_PROJECT (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (dwg && obj->type == dwg->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (dwg, obj);\n        }\n      else if (dwg != NULL\n               && (error = dwg_encode_variable_type (dwg, dat, obj))\n                      & DWG_ERR_UNHANDLEDCLASS)\n        {\n          int is_entity;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n          if (klass)\n            is_entity = klass->item_class_id == 0x1f2\n                        && obj->supertype == DWG_SUPERTYPE_ENTITY;\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          // from json and dwg can write to these. from dxf not.\n          if (is_entity)\n            {\n              if (obj->bitsize && dwg->header.version == dwg->header.from_version)\n                obj->was_bitsize_set = 1;\n              error = dwg_encode_UNKNOWN_ENT (dat, obj);\n            }\n          else\n            {\n              // skip START_OBJECT_HANDLE_STREAM (see DWG_OBJECT_END)\n              // unknown_bits already includes that.\n              if (!obj->hdlpos)\n                {\n                  if (obj->bitsize)\n                    {\n                      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n                      if (dwg->header.version == dwg->header.from_version)\n                        obj->was_bitsize_set = 1;\n                    }\n                  else\n                    obj->hdlpos = (obj->address * 8) + obj->num_unknown_bits;\n                }\n              error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n            }\n\n          if (dwg->header.version == dwg->header.from_version\n              && obj->unknown_bits && obj->num_unknown_bits) // cannot calculate\n            {\n              int len = obj->num_unknown_bits / 8;\n              const int mod = obj->num_unknown_bits % 8;\n              if (mod)\n                len++;\n              bit_write_TF (dat, obj->unknown_bits, len);\n              LOG_TRACE (\"unknown_bits: %d/%u [TF]\\n\", len, (unsigned)obj->num_unknown_bits);\n              LOG_TRACE_TF (obj->unknown_bits, len);\n              if (mod)\n                bit_advance_position (dat, mod - 8);\n              obj->was_bitsize_set = 1;\n            }\n        }\n    }\n\n  /* DXF/JSON/RW across versions: patchup size and bitsize */\n  /* Across versions size+bitsize must be recalculated.\n     Sizes are unreliable when changing versions. */\n  if (!obj->size || dwg->header.from_version != dwg->header.version\n      || obj->was_bitsize_set)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      BITCODE_RL old_size = obj->size;\n      if (dwg->header.version < R_2004 || obj->index)\n        {\n          if (!address)\n            return DWG_ERR_INVALIDDWG;\n          assert (address);\n        }\n      if (dat->byte > obj->address)\n        {\n          // The size and CRC fields are not included in the obj->size\n          obj->size = dat->byte - obj->address;\n          if (dat->bit)\n            obj->size++;\n        }\n      if (dat->byte >= dat->size)\n        bit_chain_alloc (dat);\n      // assert (obj->bitsize); // on errors\n      if (!obj->bitsize ||\n          (dwg->header.from_version != dwg->header.version\n           // and not calculated from HANDLE_STREAM or via unknown_bits already\n           && !obj->was_bitsize_set))\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte - obj->address, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff && old_size <= 0x7fff)\n        {\n          // with overlarge sizes >0x7fff memmove dat right by 2, one more RS added.\n          LOG_INFO (\"overlarge size %u > 0x7fff @%lu\\n\", (unsigned)obj->size, dat->byte);\n          if (dat->byte + obj->size + 2 >= dat->size)\n            bit_chain_alloc (dat);\n          memmove (&dat->chain[dat->byte + 2], &dat->chain[dat->byte], obj->size);\n          obj->size += 2;\n          obj->bitsize += 16;\n          obj->bitsize_pos += 16;\n          pos += 16;\n        }\n      if (obj->size <= 0x7fff && old_size > 0x7fff)\n        {\n          // with old overlarge sizes >0x7fff memmove dat left by 2, one RS removed.\n          LOG_INFO (\"was overlarge size %u < 0x7fff @%lu\\n\", (unsigned)old_size, dat->byte);\n          memmove (&dat->chain[dat->byte], &dat->chain[dat->byte + 2], obj->size);\n          obj->size -= 2;\n          obj->bitsize -= 16;\n          obj->bitsize_pos -= 16;\n          pos -= 16;\n        }\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = (obj->size * 8) - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\",\n                  address, obj->size, end_address, dat->byte,\n                  (long)(end_address - dat->byte));\n      //dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data, const int i)\n{\n  unsigned long pos = bit_position (dat);\n  unsigned long size;\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          // only if from r2007+ DWG, not JSON, DXF\n          if (data->u.eed_0.is_tu)\n            {\n              BITCODE_RS length = data->u.eed_0_r2007.length;\n              BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n              BITCODE_RS codepage = 30; //FIXME\n              char *dest;\n              if (length + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              if (length > 255)\n                {\n                  LOG_ERROR (\"eed: overlong string %d stripped\", (int)length);\n                  length = 255;\n                }\n              dest = bit_embed_TU_size (s, length);\n              bit_write_RC (dat, length);\n              bit_write_RS_LE (dat, codepage);\n              bit_write_TF (dat, (unsigned char *)dest, length);\n              LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\",\n                         length, codepage, dest);\n              free (dest);\n            }\n          else\n            {\n              if (!*data->u.eed_0.string)\n                data->u.eed_0.length = 0;\n              if (data->u.eed_0.length + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RC (dat, data->u.eed_0.length);\n              bit_write_RS_LE (dat, data->u.eed_0.codepage);\n              bit_write_TF (dat, (BITCODE_TF)data->u.eed_0.string, data->u.eed_0.length);\n              LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\",\n                         data->u.eed_0.length, data->u.eed_0.codepage,\n                         data->u.eed_0.string);\n            }\n        }\n        LATER_VERSIONS\n        {\n          // from ASCII DWG or JSON, DXF\n          if (!data->u.eed_0.is_tu)\n            {\n              BITCODE_RS length = data->u.eed_0.length;\n              BITCODE_TU dest = bit_utf8_to_TU (data->u.eed_0.string, 0);\n              if ((length * 2) + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RS (dat, length);\n              for (int j = 0; j < length; j++)\n                bit_write_RS (dat, *dest++);\n              data->u.eed_0_r2007.length = length;\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\",\n                         (int)length, data->u.eed_0.string);\n            }\n          else\n            {\n              BITCODE_RS length = data->u.eed_0_r2007.length;\n              BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n              if ((length * 2) + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RS (dat, length);\n              for (int j = 0; j < length; j++)\n                bit_write_RS (dat, *s++);\n#ifdef _WIN32\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\",\n                         (int)data->u.eed_0_r2007.length,\n                         data->u.eed_0_r2007.string);\n#else\n              if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n                {\n                  char *u8 = bit_TU_to_utf8_len (data->u.eed_0_r2007.string,\n                                                 data->u.eed_0_r2007.length);\n                  LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\",\n                             (int)data->u.eed_0_r2007.length, u8);\n                  free (u8);\n                }\n#endif\n            }\n        }\n      }\n      break;\n    case 2:\n      bit_write_RC (dat, data->u.eed_2.close);\n      LOG_TRACE (\"close: %d [RC]\", (int)data->u.eed_2.close);\n      break;\n    case 3:\n      bit_write_RLL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: 0x%lX [RLL]\", (unsigned long)data->u.eed_3.layer);\n      break;\n    case 4:\n      bit_write_RC (dat, data->u.eed_4.length);\n      bit_write_TF (dat, (BITCODE_TF)data->u.eed_4.data,\n                    data->u.eed_4.length);\n      LOG_TRACE (\"binary: \");\n      LOG_TRACE_TF (data->u.eed_4.data, data->u.eed_4.length);\n      break;\n    case 5:\n      bit_write_RLL (dat, (BITCODE_RLL)data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x%lX [ulong]\", data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      bit_write_RD (dat, data->u.eed_10.point.x);\n      bit_write_RD (dat, data->u.eed_10.point.y);\n      bit_write_RD (dat, data->u.eed_10.point.z);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\", data->u.eed_40.real);\n      break;\n    case 70:\n      bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\", data->u.eed_70.rs);\n      break;\n    case 71:\n      bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\", data->u.eed_71.rl);\n      break;\n    default:\n      dat->byte--;\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  size = bit_position (dat) - pos;\n  return (size % 8) ? (int)(size / 8) + 1 : (int)(size / 8);\n}\n\n#define dat_flush(orig, dat) bit_copy_chain (orig, dat)\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n    On does_cross_unicode_datversion skip raw, and recalc the sizes.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  //unsigned long off = obj->address;\n  //unsigned dat_size = 0;\n  Dwg_Handle *last_handle = NULL;\n  Bit_Chain dat1 = { 0 };\n  int i, num_eed = obj->tio.object->num_eed;\n  BITCODE_BS size = 0;\n  int last_size = 0;\n  int new_size = 0;\n  int did_raw = 0;\n  int need_recalc = does_cross_unicode_datversion (dat);\n\n  bit_chain_init (&dat1, 1024);\n  dat1.from_version = dat->from_version;\n  dat1.version = dat->version;\n  dat1.opts = dat->opts;\n\n  // Skip DICTIONARY AE3 AcDsRecords/AcDsSchemas 1070 . 2, wrong ACIS version\n  if (dat->opts & DWG_OPTS_INDXF &&\n      dat->version < R_2007 &&\n      obj->fixedtype == DWG_TYPE_DICTIONARY &&\n      num_eed == 1)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[0];\n      if (eed->handle.value == 0x12 &&\n          eed->data->code == 70 &&\n          eed->data->u.eed_70.rs > 1)\n        {\n          LOG_TRACE (\"skip AcDs DICTIONARY EED to use ACIS ver 2\\n\");\n          num_eed = 0;\n        }\n    }\n\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      if (eed->size) // start of a new EED appid section\n        {\n          size = eed->size;\n          if (eed->raw && !need_recalc)\n            {\n              did_raw = 1;\n              bit_write_BS (dat, size);\n              LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", i, size); LOG_POS\n              bit_write_H (dat, &eed->handle);\n              LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", i,\n                         ARGS_H (eed->handle)); LOG_POS\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n              LOG_TRACE_TF (eed->raw, size);\n              new_size = 0;\n            }\n          // indxf\n          else if (eed->data)\n            {\n              did_raw = 0;\n              if (new_size) // flush old\n                {\n\n// FIXME DXF import of ACAD EED crashes (GH #244)\n// on BLOCK_HEADER with 0 . \"DesignCenter Data\"\n#define EED_ALLOWED !(dat->opts & DWG_OPTS_INDXF) || last_handle->value != 0x12 \\\n                    || obj->fixedtype != DWG_TYPE_BLOCK_HEADER\n\n                  if (EED_ALLOWED)\n                    {\n                      eed->size = new_size;\n                      bit_write_BS (dat, new_size);\n                      LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", last_size, new_size); LOG_POS;\n                      bit_write_H (dat, last_handle);\n                      LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", last_size,\n                                 ARGS_H (*last_handle)); LOG_POS;\n                      LOG_TRACE (\"flush eed_data %lu.%d\\n\", dat1.byte, dat1.bit);\n                      dat_flush (dat, &dat1);\n                    }\n                  else\n                    {\n                      LOG_WARN (\"skip EED[%d] handle: \" FORMAT_H \" [H] for DesignCenter Data\", last_size,\n                                 ARGS_H (*last_handle)); LOG_POS;\n                      dat1.byte = 0;\n                    }\n                  new_size = 0;\n                }\n              new_size = dwg_encode_eed_data (&dat1, eed->data, i);\n              LOG_POS;\n            }\n          last_size = i;\n          last_handle = &eed->handle;\n        }\n      // and if not already written by the previous raw (this has size=0)\n      else if (!did_raw && eed->data)\n        {\n          new_size += dwg_encode_eed_data (&dat1, eed->data, i);\n          LOG_POS;\n        }\n    }\n  if (new_size && last_handle) // flush remaining rest\n    {\n      // FIXME HACK, see above\n      if (EED_ALLOWED)\n        {\n          bit_write_BS (dat, new_size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", last_size, new_size); LOG_POS;\n          bit_write_H (dat, last_handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", last_size,\n                     ARGS_H (*last_handle)); LOG_POS;\n          last_handle = NULL;\n        }\n      else\n        {\n          LOG_TRACE (\"skip EED[%d] handle: \" FORMAT_H \" [H] for DesignCenter Data\", last_size,\n                     ARGS_H (*last_handle)); LOG_POS;\n          dat1.byte = 0;\n        }\n    }\n  if (dat1.byte)\n    LOG_TRACE (\"flush eed_data %lu.%d\\n\", dat1.byte, dat1.bit);\n  dat_flush (dat, &dat1);\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_TRACE (\"num_eed: %d\\n\", num_eed);\n  bit_chain_free (&dat1);\n  return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat || !ent)\n    return DWG_ERR_INVALIDDWG;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  obj->was_bitsize_set = 0;\n  if (obj->bitsize)\n    {\n      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n    }\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\", ARGS_H (obj->handle))\n  LOG_INSANE (\" @%lu.%u\", dat->byte - obj->address, dat->bit)\n  LOG_TRACE (\"\\n\")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                      Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg,\n                                Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_DATA for objects, handles are deferred and flushed later.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  BITCODE_BL vcount;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  {\n    Dwg_Object *_obj = obj;\n    VERSIONS (R_2000, R_2007)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n    obj->was_bitsize_set = 0;\n    if (obj->bitsize)\n      // the handle stream offset\n      obj->hdlpos = bit_position (dat) + obj->bitsize;\n    SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n    if (!_obj || !obj->tio.object)\n      return DWG_ERR_INVALIDDWG;\n\n    bit_write_H (dat, &obj->handle);\n    LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n    error |= dwg_encode_eed (dat, obj);\n\n    VERSIONS (R_13, R_14)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n  }\n\n  SINCE (R_13) {\n    Dwg_Object_Object *_obj = obj->tio.object;\n    FIELD_BL (num_reactors, 0);\n    SINCE (R_2004) { FIELD_B (is_xdic_missing, 0); }\n    SINCE (R_2013) { FIELD_B (has_ds_data, 0); } // AcDs DATA\n  }\n  return error;\n}\n\nAFL_GCC_TOOBIG\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  Dwg_Version_Type old_from = dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      BITCODE_H last_hdl;\n      unsigned long seed = 0;\n      dwg->opts |= DWG_OPTS_MINIMAL;\n      dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n\n      _obj->HANDSEED = (Dwg_Object_Ref*)calloc (1, sizeof (Dwg_Object_Ref));\n      // check the object map for the next available handle\n      last_hdl = dwg->num_object_refs ? dwg->object_ref[ dwg->num_object_refs - 1] : NULL;\n      if (last_hdl)\n        {\n          // find the largest handle\n          seed = last_hdl->absolute_ref;\n          LOG_TRACE (\"compute HANDSEED %lu \", seed);\n          for (unsigned i = 0; i < dwg->num_object_refs; i++)\n            {\n              Dwg_Object_Ref *ref = dwg->object_ref[i];\n              if (ref->absolute_ref > seed)\n                seed = ref->absolute_ref;\n            }\n          _obj->HANDSEED->absolute_ref = seed + 1;\n          LOG_TRACE (\"-> %lu\\n\", seed);\n        }\n      else\n        _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n    // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\nAFL_GCC_POP\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict _obj,\n                  unsigned xdata_size)\n{\n  Dwg_Resbuf *rbuf = _obj->xdata;\n  enum RESBUF_VALUE_TYPE type;\n  int error = 0;\n  int i;\n  unsigned j = 0;\n  //BITCODE_BL num_xdata = _obj->num_xdata;\n  unsigned long start = dat->byte, end = start + xdata_size;\n  Dwg_Data *dwg = _obj->parent->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->parent->objid];\n\n  if (dat->opts & DWG_OPTS_IN) // loosen the overflow checks on dxf/json imports\n    end += xdata_size;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      LOG_INSANE (\"xdata[%u] type: \" FORMAT_RS \" [RS] @%lu.%u\\n\", j,\n                  rbuf->type, dat->byte - obj->address, dat->bit)\n      type = dwg_resbuf_value_type (rbuf->type);\n      switch (type)\n        {\n        case DWG_VT_STRING:\n          PRE (R_2007)\n          {\n            if (dat->byte + 3 + rbuf->value.str.size > end)\n              break;\n            // from TU DWG only\n            if (rbuf->value.str.size && rbuf->value.str.is_tu)\n              {\n                BITCODE_TV new = bit_embed_TU_size (rbuf->value.str.u.wdata,\n                                                    rbuf->value.str.size);\n                int len = strlen(new);\n                bit_write_RS (dat, len);\n                bit_write_RC (dat, rbuf->value.str.codepage);\n                if (rbuf->value.str.u.data)\n                  bit_write_TF (dat, (BITCODE_TF)new, len);\n                else\n                  bit_write_TF (dat, (BITCODE_TF)\"\", 0);\n                LOG_TRACE (\"xdata[%u]: \\\"%s\\\" [TF %d %d]\", j,\n                           rbuf->value.str.u.data, len, rbuf->type);\n                free (new);\n              }\n            else\n              {\n                bit_write_RS (dat, rbuf->value.str.size);\n                bit_write_RC (dat, rbuf->value.str.codepage);\n                if (rbuf->value.str.u.data)\n                  bit_write_TF (dat, (BITCODE_TF)rbuf->value.str.u.data, rbuf->value.str.size);\n                else\n                  bit_write_TF (dat, (BITCODE_TF)\"\", 0);\n                LOG_TRACE (\"xdata[%u]: \\\"%s\\\" [TF %d %d]\", j,\n                           rbuf->value.str.u.data, rbuf->value.str.size, rbuf->type);\n              }\n            LOG_POS;\n          }\n          LATER_VERSIONS\n          {\n            if (dat->byte + 2 + (2 * rbuf->value.str.size) > end)\n              break;\n            if (rbuf->value.str.size && !rbuf->value.str.is_tu)\n              {\n                // TODO: same len when converted to TU? normally yes\n                BITCODE_TU new = bit_utf8_to_TU (rbuf->value.str.u.data, 0);\n                bit_write_RS (dat, rbuf->value.str.size);\n                for (i = 0; i < rbuf->value.str.size; i++)\n                  bit_write_RS (dat, new[i]);\n                LOG_TRACE_TU (\"xdata\", new, rbuf->type);\n                free (new);\n              }\n            else\n              {\n                bit_write_RS (dat, rbuf->value.str.size);\n                for (i = 0; i < rbuf->value.str.size; i++)\n                  bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n                LOG_TRACE_TU (\"xdata\", rbuf->value.str.u.wdata, rbuf->type);\n              }\n            LOG_POS;\n          }\n          break;\n        case DWG_VT_REAL:\n          if (dat->byte + 8 > end)\n            break;\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%u]: %f [RD %d]\", j, rbuf->value.dbl,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_BOOL:\n        case DWG_VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%u]: %d [RC %d]\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT16:\n          if (dat->byte + 2 > end)\n            break;\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%u]: %d [RS %d]\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT32:\n          if (dat->byte + 4 > end)\n            break;\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT64:\n          if (dat->byte + 8 > end)\n            break;\n          bit_write_RLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%u]: \" FORMAT_RLL \" [RLL %d]\", j,\n                     rbuf->value.i64, rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_POINT3D:\n          if (dat->byte + 24 > end)\n            break;\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%u]: (%f,%f,%f) [3RD %d]\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_BINARY:\n          if (dat->byte + rbuf->value.str.size > end)\n            break;\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, (BITCODE_TF)rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%u]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_POS;\n          break;\n        case DWG_VT_HANDLE:\n        case DWG_VT_OBJECTID:\n          if (dat->byte + 8 > end)\n            break;\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%u]: \" FORMAT_H \" [H %d]\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type);\n          error = DWG_ERR_INVALIDEED;\n          break;\n        }\n      rbuf = rbuf->nextrb;\n      j++;\n      if (j >= _obj->num_xdata)\n        break;\n      if (dat->byte >= end)\n        {\n          LOG_WARN (\"xdata overflow %u\", xdata_size);\n          break;\n        }\n    }\n  if (_obj->xdata_size != dat->byte - start)\n    {\n      if (dat->opts & DWG_OPTS_IN) // imprecise xdata_size: calculate\n        {\n          _obj->xdata_size = dat->byte - start;\n          LOG_TRACE (\"-xdata_size: \" FORMAT_BL \" (calculated)\\n\", _obj->xdata_size);\n          return error;\n        }\n      else\n        {\n          LOG_WARN (\"xdata Written %lu, expected \" FORMAT_BL, dat->byte - start,\n                    _obj->xdata_size);\n          _obj->xdata_size = dat->byte - start;\n          return error ? error : 1;\n        }\n    }\n  return 0;\n}\n\n#undef IS_ENCODER\n"], "fixing_code": ["/*****************************************************************************/\n/*  LibreDWG - free implementation of the DWG file format                    */\n/*                                                                           */\n/*  Copyright (C) 2009-2010,2018-2021 Free Software Foundation, Inc.         */\n/*  Copyright (C) 2010 Thien-Thi Nguyen                                      */\n/*                                                                           */\n/*  This library is free software, licensed under the terms of the GNU       */\n/*  General Public License as published by the Free Software Foundation,     */\n/*  either version 3 of the License, or (at your option) any later version.  */\n/*  You should have received a copy of the GNU General Public License        */\n/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */\n/*****************************************************************************/\n\n/*\n * encode.c: encoding functions to write a DWG\n * written by Felipe Castro\n * modified by Felipe Corr\u00eaa da Silva Sances\n * modified by Rodrigo Rodrigues da Silva\n * modified by Thien-Thi Nguyen\n * modified by Till Heuschmann\n * modified by Anderson Pierre Cardoso\n * modified by Reini Urban\n */\n\n//#define HAVE_COMPRESS_R2004_SECTION\n\n#include \"config.h\"\n#ifdef __STDC_ALLOC_LIB__\n#  define __STDC_WANT_LIB_EXT2__ 1 /* for strdup */\n#else\n#  define _USE_BSD 1\n#endif\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <assert.h>\n#ifdef HAVE_CTYPE_H\n#  include <ctype.h>\n#endif\n\n#include \"common.h\"\n#include \"bits.h\"\n#include \"dwg.h\"\n#include \"encode.h\"\n#include \"decode.h\"\n#include \"classes.h\"\n#include \"free.h\"\n\n// from dynapi\nbool is_dwg_object (const char *name);\nbool is_dwg_entity (const char *name);\nint dwg_dynapi_entity_size (const char *restrict name);\n// from dwg_api\nBITCODE_T dwg_add_u8_input (Dwg_Data *restrict dwg,\n                            const char *restrict u8str);\nDwg_Object_APPID *dwg_add_APPID (Dwg_Data *restrict dwg,\n                                 const char *restrict name);\nunsigned long dwg_obj_generic_handlevalue (void *_obj);\n\n/* The logging level for the write (encode) path.  */\nstatic unsigned int loglevel;\n/* the current version per spec block */\nstatic unsigned int cur_ver = 0;\nstatic BITCODE_BL rcount1 = 0, rcount2 = 0;\n\n#ifdef USE_TRACING\n/* This flag means we have checked the environment variable\n   LIBREDWG_TRACE and set `loglevel' appropriately.  */\nstatic bool env_var_checked_p;\n#endif /* USE_TRACING */\n#define DWG_LOGLEVEL loglevel\n\n#include \"logging.h\"\n\n/*--------------------------------------------------------------------------------\n * spec MACROS\n */\n\n#define ACTION encode\n#define IS_ENCODER\n\n#define ANYCODE -1\n\n#define LOG_POS                                                               \\\n  LOG_INSANE (\" @%lu.%u\", obj ? dat->byte - obj->address : dat->byte, dat->bit)\\\n  LOG_TRACE (\"\\n\")\n#define LOG_RPOS                                                              \\\n  LOG_INSANE (\" @%lu.%u\", dat->byte, dat->bit)                                \\\n  LOG_TRACE (\"\\n\")\n#define LOG_HPOS                                                              \\\n  LOG_INSANE (\" @%lu.%u\",                                                     \\\n              obj && hdl_dat->byte > obj->address                             \\\n                  ? hdl_dat->byte - obj->address                              \\\n                  : hdl_dat->byte,                                            \\\n              hdl_dat->bit)                                                   \\\n  LOG_TRACE (\"\\n\")\n\n#define VALUE(value, type, dxf)                                               \\\n  {                                                                           \\\n    bit_write_##type (dat, value);                                            \\\n    LOG_TRACE (FORMAT_##type \" [\" #type \" %d]\", (BITCODE_##type)value, dxf);  \\\n    LOG_POS                                                                   \\\n  }\n#define VALUE_RC(value, dxf) VALUE (value, RC, dxf)\n#define VALUE_RS(value, dxf) VALUE (value, RS, dxf)\n#define VALUE_RL(value, dxf) VALUE (value, RL, dxf)\n#define VALUE_BS(value, dxf) VALUE (value, BS, dxf)\n#define VALUE_BL(value, dxf) VALUE (value, BL, dxf)\n#define VALUE_RD(value, dxf) VALUE (value, RD, dxf)\n#define VALUE_BD(value, dxf) VALUE (value, BD, dxf)\n\n#define FIELD(nam, type)                                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_TRACE (nam, type);                                                  \\\n  }\n#define FIELDG(nam, type, dxf)                                                \\\n  {                                                                           \\\n    bit_write_##type (dat, _obj->nam);                                        \\\n    FIELD_G_TRACE (nam, type, dxf);                                           \\\n  }\n#define FIELD_TRACE(nam, type)                                                \\\n  LOG_TRACE (#nam \": \" FORMAT_##type, _obj->nam)                              \\\n  LOG_POS\n#define FIELD_G_TRACE(nam, type, dxfgroup)                                    \\\n  LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxfgroup \"]\", _obj->nam) \\\n  LOG_POS\n#define FIELD_CAST(nam, type, cast, dxf)                                      \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->nam);                        \\\n    LOG_TRACE (#nam \": \" FORMAT_##type \" [\" #type \" \" #dxf \"]\",               \\\n               (BITCODE_##type)_obj->nam);                                    \\\n    LOG_POS                                                                   \\\n  }\n#define SUB_FIELD(o, nam, type, dxf) FIELD (o.nam, type)\n#define SUB_FIELD_CAST(o, nam, type, cast, dxf)                               \\\n  {                                                                           \\\n    bit_write_##type (dat, (BITCODE_##type)_obj->o.nam);                      \\\n    FIELD_G_TRACE (o.nam, cast, dxf);                                         \\\n  }\n\n#define FIELD_VALUE(nam) _obj->nam\n\n#define FIELD_B(nam, dxf) FIELDG (nam, B, dxf)\n#define FIELD_BB(nam, dxf) FIELDG (nam, BB, dxf)\n#define FIELD_3B(nam, dxf) FIELDG (nam, 3B, dxf)\n#define FIELD_BS(nam, dxf) FIELDG (nam, BS, dxf)\n#define FIELD_BSd(nam, dxf) FIELD_CAST (nam, BS, BSd, dxf)\n#define FIELD_RSx(nam, dxf) FIELD_CAST (nam, RS, RSx, dxf)\n#define FIELD_RLx(nam, dxf) FIELD_CAST (nam, RL, RLx, dxf)\n#define FIELD_BLx(nam, dxf) FIELD_CAST (nam, BL, BLx, dxf)\n#define FIELD_BLd(nam, dxf) FIELD_CAST (nam, BL, BLd, dxf)\n#define FIELD_RLd(nam, dxf) FIELD_CAST (nam, RL, RLd, dxf)\n#define FIELD_BL(nam, dxf) FIELDG (nam, BL, dxf)\n#define FIELD_BLL(nam, dxf) FIELDG (nam, BLL, dxf)\n#define FIELD_BD(nam, dxf) FIELDG (nam, BD, dxf)\n#define FIELD_RC(nam, dxf) FIELDG (nam, RC, dxf)\n#define FIELD_RS(nam, dxf) FIELDG (nam, RS, dxf)\n#define FIELD_RD(nam, dxf) FIELDG (nam, RD, dxf)\n#define FIELD_RL(nam, dxf) FIELDG (nam, RL, dxf)\n#define FIELD_RLL(nam, dxf) FIELDG (nam, RLL, dxf)\n#define FIELD_RLLu(nam, dxf)                                            \\\n  {                                                                     \\\n    bit_write_RLL (dat, _obj->nam);                                     \\\n    FIELD_G_TRACE (nam, BLL, dxf);                                      \\\n  }\n#define FIELD_MC(nam, dxf) FIELDG (nam, MC, dxf)\n#define FIELD_MS(nam, dxf) FIELDG (nam, MS, dxf)\n#define FIELD_TV(nam, dxf)                                                    \\\n  {                                                                           \\\n    IF_ENCODE_FROM_EARLIER                                                    \\\n    {                                                                         \\\n      if (!_obj->nam)                                                         \\\n        _obj->nam = strdup (\"\");                                              \\\n    }                                                                         \\\n    bit_write_TV (dat, _obj->nam);                                            \\\n    LOG_TRACE (#nam \": \\\"%s\\\" [TV %d]\", _obj->nam, dxf);                      \\\n    LOG_POS                                                                   \\\n  }\n// may need to convert from/to TV<=>TU\n#define FIELD_T(nam, dxf)                                                     \\\n  {                                                                           \\\n    if (dat->version < R_2007)                                                \\\n      {                                                                       \\\n        bit_write_T (dat, _obj->nam);                                         \\\n        LOG_TRACE (#nam \": \\\"%s\\\" [T %d]\", _obj->nam, dxf);                   \\\n        LOG_POS                                                               \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        bit_write_T (str_dat, _obj->nam);                                     \\\n        LOG_TRACE_TU (#nam, _obj->nam, dxf);                                  \\\n      }                                                                       \\\n  }\n#define FIELD_TF(nam, len, dxf)                                               \\\n  {                                                                           \\\n    LOG_TRACE (#nam \": [TF %d %d]\\n\", (int)len, dxf);                         \\\n    if (len > 0)                                                              \\\n      {                                                                       \\\n        if (!_obj->nam)                                                       \\\n          { /* empty field, write zeros */                                    \\\n            for (int _i = 0; _i < (int)(len); _i++)                           \\\n              bit_write_RC (dat, 0);                                          \\\n          }                                                                   \\\n        else                                                                  \\\n          {                                                                   \\\n            bit_write_TF (dat, (BITCODE_TF)_obj->nam, len);                   \\\n          }                                                                   \\\n      }                                                                       \\\n    LOG_TRACE_TF (FIELD_VALUE (nam), (int)len);                               \\\n  }\n#define FIELD_TFF(nam, len, dxf) FIELD_TF (nam, len, dxf)\n#define FIELD_TU(nam, dxf)                                                    \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU (str_dat, (BITCODE_TU)_obj->nam);                          \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_TU16(nam, dxf)                                                  \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU16 (str_dat, _obj->nam);                                    \\\n    LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf);                          \\\n  }\n#define FIELD_T32(nam, dxf)                                                   \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_T32 (str_dat, _obj->nam);                                     \\\n    if (dat->version < R_2007)                                                \\\n      LOG_TRACE (#nam \": \\\"%s\\\" [T32 %d]\\n\", _obj->nam, dxf)                  \\\n    else                                                                      \\\n      LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf)                         \\\n  }\n#define FIELD_TU32(nam, dxf)                                                  \\\n  {                                                                           \\\n    if (_obj->nam)                                                            \\\n      bit_write_TU32 (str_dat, _obj->nam);                                    \\\n    if (dat->version < R_2007)                                                \\\n      LOG_TRACE (#nam \": \\\"%s\\\" [TU32 %d]\\n\", _obj->nam, dxf)                 \\\n    else                                                                      \\\n      LOG_TRACE_TU (#nam, (BITCODE_TU)_obj->nam, dxf)                         \\\n  }\n#define FIELD_BT(nam, dxf) FIELDG (nam, BT, dxf);\n\n#define _FIELD_DD(nam, _default, dxf)                                         \\\n  bit_write_DD (dat, FIELD_VALUE (nam), _default);\n#define FIELD_DD(nam, _default, dxf)                                          \\\n  {                                                                           \\\n    BITCODE_BB b1 = _FIELD_DD (nam, _default, dxf);                           \\\n    if (b1 == 3)                                                              \\\n      LOG_TRACE (#nam \": %f [DD %d]\", _obj->nam, dxf)                         \\\n    else                                                                      \\\n      LOG_TRACE (#nam \": %f [DD/%d %d]\", _obj->nam, b1, dxf)                  \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    BITCODE_BB b2, b1 = _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);          \\\n    b2 = _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                    \\\n    if (b1 == 3 && b2 == 3)                                                   \\\n      LOG_TRACE (#nam \": (%f, %f) [2DD %d]\", _obj->nam.x, _obj->nam.y, dxf)   \\\n    else                                                                      \\\n      LOG_TRACE (#nam \": (%f, %f) [2DD/%d%d %d]\", _obj->nam.x, _obj->nam.y,   \\\n                   b1, b2, dxf)                                               \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3DD(nam, def, dxf)                                              \\\n  {                                                                           \\\n    _FIELD_DD (nam.x, FIELD_VALUE (def.x), dxf);                              \\\n    _FIELD_DD (nam.y, FIELD_VALUE (def.y), dxf + 10);                         \\\n    _FIELD_DD (nam.z, FIELD_VALUE (def.z), dxf + 20);                         \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3DD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3RD %d]\", _obj->nam.x, _obj->nam.y, dxf)     \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    LOG_TRACE (#nam \": (%f, %f) [3BD %d]\", _obj->nam.x, _obj->nam.y, dxf)     \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_2BD_1(nam, dxf) FIELD_2BD (nam, dxf)\n#define FIELD_3RD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_RD (dat, _obj->nam.x);                                          \\\n    bit_write_RD (dat, _obj->nam.y);                                          \\\n    bit_write_RD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3RD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3BD(nam, dxf)                                                   \\\n  {                                                                           \\\n    bit_write_BD (dat, _obj->nam.x);                                          \\\n    bit_write_BD (dat, _obj->nam.y);                                          \\\n    bit_write_BD (dat, _obj->nam.z);                                          \\\n    LOG_TRACE (#nam \": (%f, %f, %f) [3BD %d]\", _obj->nam.x, _obj->nam.y,      \\\n               _obj->nam.z, dxf)                                              \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_3BD_1(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_3DPOINT(nam, dxf) FIELD_3BD (nam, dxf)\n#define FIELD_4BITS(nam, dxf)                                                 \\\n  {                                                                           \\\n    unsigned char _b = (unsigned char)_obj->nam;                              \\\n    bit_write_4BITS (dat, _b);                                                \\\n    LOG_TRACE (#nam \": b%d%d%d%d [4BITS %d]\", _b & 8, _b & 4, _b & 2,         \\\n               _b & 1, dxf);                                                  \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_TIMEBLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMEBLL (dat, (BITCODE_TIMEBLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_BL \".\" FORMAT_BL \" [TIMEBLL %d]\",             \\\n               _obj->nam.days, _obj->nam.ms, dxf);                            \\\n    LOG_POS                                                                   \\\n  }\n#define FIELD_TIMERLL(nam, dxf)                                               \\\n  {                                                                           \\\n    bit_write_TIMERLL (dat, (BITCODE_TIMERLL)_obj->nam);                      \\\n    LOG_TRACE (#nam \": \" FORMAT_RL \".\" FORMAT_RL \" [TIMERLL %d]\",             \\\n               _obj->nam.days, _obj->nam.ms, dxf);                            \\\n    LOG_POS                                                                   \\\n  }\n\n#define FIELD_CMC(color, dxf)                                                 \\\n  {                                                                           \\\n    bit_write_CMC (dat, str_dat, &_obj->color);                               \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->color.index, dxf);    \\\n    LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, dat->bit) \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%08x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->color.rgb, dxf + 420 - 62);                \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->color.flag);                               \\\n        if (_obj->color.flag & 1)                                             \\\n          LOG_TRACE (#color \".name: %s [CMC.T]\\n\", _obj->color.name);         \\\n        if (_obj->color.flag & 2)                                             \\\n          LOG_TRACE (#color \".bookname: %s [CMC.T]\\n\",                        \\\n                     _obj->color.book_name);                                  \\\n        LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, dat->bit) \\\n      }                                                                       \\\n  }\n#define SUB_FIELD_CMC(o, color, dxf)                                          \\\n  {                                                                           \\\n    bit_write_CMC (dat, str_dat, &_obj->o.color);                             \\\n    LOG_TRACE (#color \".index: %d [CMC.BS %d]\\n\", _obj->o.color.index, dxf);  \\\n    LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte,     \\\n                dat->bit)                                                     \\\n    if (dat->version >= R_2004)                                               \\\n      {                                                                       \\\n        LOG_TRACE (#color \".rgb: 0x%06x [CMC.BL %d]\\n\",                       \\\n                   (unsigned)_obj->o.color.rgb, dxf + 420 - 62);              \\\n        LOG_TRACE (#color \".flag: 0x%x [CMC.RC]\\n\",                           \\\n                   (unsigned)_obj->o.color.flag);                             \\\n        if (_obj->o.color.flag & 1)                                           \\\n          LOG_TRACE (#color \".name: %s [CMC.T]\\n\", _obj->o.color.name);       \\\n        if (_obj->o.color.flag & 2)                                           \\\n          LOG_TRACE (#color \".bookname: %s [CMC.T]\\n\",                        \\\n                     _obj->o.color.book_name);                                \\\n        LOG_INSANE (\" @%lu.%u\\n\", obj ? dat->byte - obj->address : dat->byte, \\\n                    dat->bit)                                                 \\\n      }                                                                       \\\n  }\n\n#define LOG_TF(level, var, len)                                               \\\n  if (var)                                                                    \\\n    {                                                                         \\\n      int _i;                                                                 \\\n      for (_i = 0; _i < (len); _i++)                                          \\\n        {                                                                     \\\n          LOG (level, \"%02X\", (unsigned char)((char *)var)[_i]);              \\\n        }                                                                     \\\n      LOG (level, \"\\n\");                                                      \\\n      if (DWG_LOGLEVEL >= DWG_LOGLEVEL_INSANE)                                \\\n        {                                                                     \\\n          for (_i = 0; _i < (len); _i++)                                      \\\n            {                                                                 \\\n              unsigned char c = ((unsigned char *)var)[_i];                   \\\n              LOG_INSANE (\"%-2c\", isprint (c) ? c : ' ');                     \\\n            }                                                                 \\\n          LOG_INSANE (\"\\n\");                                                  \\\n        }                                                                     \\\n    }\n#define LOG_TRACE_TF(var, len) LOG_TF (TRACE, var, len)\n#define LOG_INSANE_TF(var, len) LOG_TF (INSANE, var, len)\n\n#define FIELD_BE(nam, dxf)                                                    \\\n  bit_write_BE (dat, FIELD_VALUE (nam.x), FIELD_VALUE (nam.y),                \\\n                FIELD_VALUE (nam.z));\n\n#define OVERFLOW_CHECK(nam, size)                                             \\\n  if ((long)(size) > 0xff00L || (!_obj->nam && size) || (_obj->nam && !size)) \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld\", (long)size);                         \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define OVERFLOW_CHECK_LV(nam, size)                                          \\\n  if ((long)(size) > 0xff00L)                                                 \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);               \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n#define OVERFLOW_NULL_CHECK_LV(nam, size)                                     \\\n  if ((long)(size) > 0xff00L || (!_obj->nam && size) || (_obj->nam && !size)) \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid \" #nam \" %ld, set to 0\", (long)size);               \\\n      size = 0;                                                               \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }\n\n#define FIELD_2RD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2RD (nam[vcount], dxf);                                           \\\n    }\n\n#define FIELD_2DD_VECTOR(nam, size, dxf)                                      \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  if (_obj->size)                                                             \\\n    FIELD_2RD (nam[0], dxf);                                                  \\\n  for (vcount = 1; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_2DD (nam[vcount], nam[vcount - 1], dxf);                          \\\n    }\n\n#define FIELD_3DPOINT_VECTOR(nam, size, dxf)                                  \\\n  OVERFLOW_NULL_CHECK_LV (nam, _obj->size)                                    \\\n  for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)                 \\\n    {                                                                         \\\n      FIELD_3DPOINT (nam[vcount], dxf);                                       \\\n    }\n\n#define REACTORS(code)                                                        \\\n  if (obj->tio.object->reactors)                                              \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (num_reactors, obj->tio.object->num_reactors)         \\\n      SINCE (R_13)                                                            \\\n      {                                                                       \\\n        for (vcount = 0; vcount < (BITCODE_BL)obj->tio.object->num_reactors;  \\\n             vcount++)                                                        \\\n          {                                                                   \\\n            VALUE_HANDLE (obj->tio.object->reactors[vcount], reactors, code,  \\\n                          330);                                               \\\n          }                                                                   \\\n      }                                                                       \\\n    }\n\n#define XDICOBJHANDLE(code)                                                   \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.object->is_xdic_missing)                                  \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,    \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->xdicobjhandle, xdicobjhandle, code,      \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n#define ENT_XDICOBJHANDLE(code)                                               \\\n  RESET_VER                                                                   \\\n  SINCE (R_2004)                                                              \\\n  {                                                                           \\\n    if (!obj->tio.entity->is_xdic_missing)                                    \\\n      {                                                                       \\\n        VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, 3,       \\\n                      360);                                                   \\\n      }                                                                       \\\n  }                                                                           \\\n  else                                                                        \\\n  {                                                                           \\\n    SINCE (R_13)                                                              \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.entity->xdicobjhandle, xdicobjhandle, 3,         \\\n                    360);                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  RESET_VER\n\n// FIELD_VECTOR_N(nam, type, size, dxf):\n// writes a 'size' elements vector of data of the type indicated by 'type'\n#define FIELD_VECTOR_N(nam, type, size, dxf)                                  \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          LOG_TRACE (#nam \"[%ld]: \" FORMAT_##type \" [%s %d]\\n\", (long)vcount, \\\n                     _obj->nam[vcount], #type, dxf)                           \\\n        }                                                                     \\\n    }\n#define FIELD_VECTOR_T(nam, type, size, dxf)                                  \\\n  if (_obj->size > 0 && _obj->nam)                                            \\\n    {                                                                         \\\n      OVERFLOW_CHECK_LV (nam, _obj->size)                                     \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->size; vcount++)             \\\n        {                                                                     \\\n          if (dat->version != dat->from_version)                              \\\n            FIELD_##type (nam[vcount], dxf)                                   \\\n          else if (dat->version < R_2007)                                     \\\n          {                                                                   \\\n            bit_write_TV (dat, (BITCODE_TV)_obj->nam[vcount]);                \\\n            LOG_TRACE (#nam \"[%d]: \\\"%s\\\" [TV %d]\\n\", (int)vcount,            \\\n                       _obj->nam[vcount], dxf)                                \\\n          }                                                                   \\\n          else                                                                \\\n          {                                                                   \\\n            bit_write_##type (dat, _obj->nam[vcount]);                        \\\n            LOG_TRACE_TU (#nam, _obj->nam[vcount], dxf)                       \\\n          }                                                                   \\\n        }                                                                     \\\n      RESET_VER                                                               \\\n    }\n\n#define FIELD_VECTOR(nam, type, size, dxf)                                    \\\n  FIELD_VECTOR_N (nam, type, _obj->size, dxf)\n#define FIELD_VECTOR_INL(nam, type, size, dxf)                                \\\n  FIELD_VECTOR_N (nam, type, size, dxf)\n\n#define SUB_FIELD_VECTOR_TYPESIZE(o, nam, size, typesize, dxf)                \\\n  if (_obj->o.size > 0 && _obj->o.nam)                                        \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, _obj->o.size)                                      \\\n      for (vcount = 0; vcount < (BITCODE_BL)_obj->o.size; vcount++)           \\\n        {                                                                     \\\n          bit_write_##type (dat, _obj->nam[vcount]);                          \\\n          switch (typesize)                                                   \\\n            {                                                                 \\\n            case 0:                                                           \\\n              break;                                                          \\\n            case 1:                                                           \\\n              bit_write_RC (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 2:                                                           \\\n              bit_write_RS (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 4:                                                           \\\n              bit_write_RL (dat, _obj->o.name[vcount]);                       \\\n              break;                                                          \\\n            case 8:                                                           \\\n              bit_write_RLL (dat, _obj->o.name[vcount]);                      \\\n              break;                                                          \\\n            default:                                                          \\\n              LOG_ERROR (\"Unkown SUB_FIELD_VECTOR_TYPE \" #nam \" typesize %d\", \\\n                         typesize);                                           \\\n              break;                                                          \\\n            }                                                                 \\\n          LOG_TRACE (#nam \"[%u]: %d\\n\", vcount, _obj->nam[vcount])            \\\n        }                                                                     \\\n    }\n\n#define VALUE_HANDLE(hdlptr, nam, handle_code, dxf)                           \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!hdlptr)                                                              \\\n      {                                                                       \\\n        Dwg_Handle null_handle = { 0, 0, 0UL, 0 };                            \\\n        null_handle.code = handle_code;                                       \\\n        bit_write_H (hdl_dat, &null_handle);                                  \\\n        LOG_TRACE (#nam \": (%d.0.0) abs:0 [H %d]\", handle_code, dxf)          \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE && (hdlptr)->handleref.code != handle_code \\\n            && (handle_code == 4 && (hdlptr)->handleref.code < 6))            \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %d handle, got a %d\", handle_code,     \\\n                      (hdlptr)->handleref.code);                              \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &(hdlptr)->handleref);                          \\\n        LOG_TRACE (#nam \": \" FORMAT_REF \" [H %d]\", ARGS_REF (hdlptr), dxf)    \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n  }\n\n#define FIELD_HANDLE(nam, handle_code, dxf)                                   \\\n  VALUE_HANDLE (_obj->nam, nam, handle_code, dxf)\n#define SUB_FIELD_HANDLE(o, nam, handle_code, dxf)                            \\\n  VALUE_HANDLE (_obj->o.nam, nam, handle_code, dxf)\n#define FIELD_DATAHANDLE(nam, handle_code, dxf)                               \\\n  {                                                                           \\\n    bit_write_H (dat, _obj->nam ? &_obj->nam->handleref : NULL);              \\\n  }\n\n#define FIELD_HANDLE_N(nam, vcount, handle_code, dxf)                         \\\n  IF_ENCODE_SINCE_R13                                                         \\\n  {                                                                           \\\n    RESET_VER                                                                 \\\n    if (!_obj->nam)                                                           \\\n      {                                                                       \\\n        bit_write_H (hdl_dat, NULL);                                          \\\n        LOG_TRACE (#nam \"[%d]: NULL %d [H* %d]\", (int)vcount, handle_code,    \\\n                   dxf)                                                       \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (handle_code != ANYCODE                                            \\\n            && _obj->nam->handleref.code != handle_code                       \\\n            && (handle_code == 4 && _obj->nam->handleref.code < 6))           \\\n          {                                                                   \\\n            LOG_WARN (\"Expected a CODE %x handle, got a %x\", handle_code,     \\\n                      _obj->nam->handleref.code);                             \\\n          }                                                                   \\\n        bit_write_H (hdl_dat, &_obj->nam->handleref);                         \\\n        LOG_TRACE (#nam \"[%d]: \" FORMAT_REF \" [H* %d]\", (int)vcount,          \\\n                   ARGS_REF (_obj->nam), dxf)                                 \\\n        LOG_HPOS                                                              \\\n      }                                                                       \\\n  }\n\n#define HANDLE_VECTOR_N(nam, size, code, dxf)                                 \\\n  if (size > 0 && _obj->nam)                                                  \\\n    {                                                                         \\\n      OVERFLOW_CHECK (nam, size)                                              \\\n      for (vcount = 0; vcount < (BITCODE_BL)size; vcount++)                   \\\n        {                                                                     \\\n          if (_obj->nam[vcount])                                              \\\n            {                                                                 \\\n              FIELD_HANDLE_N (nam[vcount], vcount, code, dxf);                \\\n            }                                                                 \\\n        }                                                                     \\\n    }\n\n#define FIELD_NUM_INSERTS(num_inserts, type, dxf)                             \\\n  for (vcount = 0; vcount < FIELD_VALUE (num_inserts); vcount++)              \\\n    {                                                                         \\\n      bit_write_RC (dat, 1);                                                  \\\n    }                                                                         \\\n  bit_write_RC (dat, 0);                                                      \\\n  LOG_TRACE (\"num_inserts: %d [RC* 0]\", FIELD_VALUE (num_inserts))            \\\n  LOG_POS\n\n#define HANDLE_VECTOR(nam, sizefield, code, dxf)                              \\\n  HANDLE_VECTOR_N (nam, FIELD_VALUE (sizefield), code, dxf)\n\n#define FIELD_XDATA(nam, size)                                                \\\n  error |= dwg_encode_xdata (dat, _obj, _obj->size)\n\n#define COMMON_ENTITY_HANDLE_DATA                                             \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    START_HANDLE_STREAM;                                                      \\\n  }                                                                           \\\n  RESET_VER\n\n#define START_OBJECT_HANDLE_STREAM  START_HANDLE_STREAM\n#define CONTROL_HANDLE_STREAM       START_HANDLE_STREAM\n\n#define SECTION_STRING_STREAM                                                 \\\n  {                                                                           \\\n    Bit_Chain sav_dat = *dat;                                                 \\\n    dat = str_dat;\n\n/* TODO: dump all TU strings here */\n#define START_STRING_STREAM                                                   \\\n  bit_write_B (dat, obj->has_strings);                                        \\\n  RESET_VER                                                                   \\\n  if (obj->has_strings)                                                       \\\n    {                                                                         \\\n      Bit_Chain sav_dat = *dat;                                               \\\n      obj_string_stream (dat, obj, dat);\n\n#define END_STRING_STREAM                                                     \\\n  *dat = sav_dat;                                                             \\\n  }\n#define ENCODE_COMMON_HANDLES                                                 \\\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT && dat->version >= R_13)         \\\n    {                                                                         \\\n      VALUE_HANDLE (obj->tio.object->ownerhandle, ownerhandle, 4, 330);       \\\n      REACTORS (4);                                                           \\\n      XDICOBJHANDLE (3);                                                      \\\n    }                                                                         \\\n else if (obj->supertype == DWG_SUPERTYPE_ENTITY && dat->version >= R_13)     \\\n   {                                                                          \\\n     error |= dwg_encode_common_entity_handle_data (dat, hdl_dat, obj);       \\\n   }\n\n#define START_HANDLE_STREAM                                                   \\\n  LOG_INSANE (\"HANDLE_STREAM @%lu.%u\\n\", dat->byte - obj->address, dat->bit)  \\\n  if (!obj->bitsize ||                                                        \\\n       /* DD sizes can vary, but let unknown_bits asis */                     \\\n      has_entity_DD (obj) ||                                                  \\\n       (dwg->header.version != dwg->header.from_version                       \\\n        && obj->fixedtype != DWG_TYPE_UNKNOWN_OBJ                             \\\n        && obj->fixedtype != DWG_TYPE_UNKNOWN_ENT))                           \\\n    {                                                                         \\\n      obj->bitsize = bit_position (dat) - (obj->address * 8);                 \\\n      LOG_TRACE (\"-bitsize calc from HANDLE_STREAM \" FORMAT_RL \" @%lu.%u (%lu)\\n\", \\\n                 obj->bitsize, dat->byte - obj->address, dat->bit, obj->address); \\\n      obj->was_bitsize_set = 1;                                               \\\n    }                                                                         \\\n  if (!obj->hdlpos)                                                           \\\n    obj->hdlpos = bit_position (dat);                                         \\\n  {                                                                           \\\n    unsigned long _hpos = bit_position (hdl_dat);                             \\\n    if (_hpos > 0)                                                            \\\n      {                                                                       \\\n        /* save away special accumulated hdls, need to write common first */  \\\n        Bit_Chain dat1 = *hdl_dat;                                            \\\n        Bit_Chain dat2;                                                       \\\n        bit_chain_init_dat (&dat2, 12, dat);                                  \\\n        hdl_dat = &dat2;                                                      \\\n        ENCODE_COMMON_HANDLES                                                 \\\n        obj_flush_hdlstream (obj, dat, hdl_dat); /* common */                 \\\n        obj_flush_hdlstream (obj, dat, &dat1); /* special accumulated */      \\\n        bit_chain_free (&dat1);                                               \\\n        bit_chain_free (&dat2);                                               \\\n        *hdl_dat = *dat;                                                      \\\n        hdl_dat = dat;                                                        \\\n      }                                                                       \\\n    else                                                                      \\\n      {                                                                       \\\n        if (hdl_dat != dat)                                                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        hdl_dat = dat;                                                        \\\n        ENCODE_COMMON_HANDLES                                                 \\\n      }                                                                       \\\n  }                                                                           \\\n  RESET_VER\n\nstatic void\nobj_flush_hdlstream (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                     Bit_Chain *restrict hdl_dat)\n{\n  unsigned long datpos = bit_position (dat);\n  unsigned long hdlpos = bit_position (hdl_dat);\n  unsigned long objpos = obj->address * 8;\n  LOG_TRACE (\"Flush handle stream of size %lu (@%lu.%u) to @%lu.%lu\\n\", hdlpos,\n             hdl_dat->byte, hdl_dat->bit, (datpos - objpos) / 8,\n             (datpos - objpos) % 8);\n  bit_copy_chain (dat, hdl_dat);\n}\n\n#if 0\n/** See dec_macro.h instead.\n   Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\nEXPORT long dwg_add_##token (Dwg_Data * dwg)    \\\n{                                               \\\n  Bit_Chain dat = { 0 };                        \\\n  BITCODE_BL num_objs  = dwg->num_objects;      \\\n  int error = 0;                                \\\n  dat.size = sizeof(Dwg_Entity_##token) + 40;   \\\n  LOG_INFO (\"Add entity \" #token \" \")           \\\n  dat.chain = calloc (dat.size, 1);             \\\n  dat.version = dwg->header.version;            \\\n  dat.from_version = dwg->header.from_version;  \\\n  bit_write_MS (&dat, dat.size);                \\\n  if (dat.version >= R_2010) {                  \\\n    /* FIXME: should be UMC handlestream_size */\\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Entity_##token)); \\\n    bit_write_BOT &dat, DWG_TYPE_##token);      \\\n  } else {                                      \\\n    bit_write_BS (&dat, DWG_TYPE_##token);      \\\n  }                                             \\\n  bit_set_position (&dat, 0);                   \\\n  error = dwg_decode_add_object (dwg, &dat, &dat, 0);\\\n  if (-1 == error)                              \\\n    dwg_resolve_objectrefs_silent (dwg);        \\\n  if (num_objs == dwg->num_objects)             \\\n    return -1;                                  \\\n  else                                          \\\n    return (long)dwg->num_objects;              \\\n}\n\nEXPORT long dwg_add_##token (Dwg_Data * dwg)     \\\n{                                                \\\n  Bit_Chain dat = { 0 };                         \\\n  int error = 0;                                 \\\n  BITCODE_BL num_objs  = dwg->num_objects;       \\\n  dat.size = sizeof(Dwg_Object_##token) + 40;    \\\n  LOG_INFO (\"Add object \" #token \" \")            \\\n  dat.chain = calloc (dat.size, 1);              \\\n  dat.version = dwg->header.version;             \\\n  dat.from_version = dwg->header.from_version;   \\\n  bit_write_MS (&dat, dat.size);                 \\\n  if (dat.version >= R_2010) {                   \\\n    /* FIXME: should be UMC handlestream_size */ \\\n    bit_write_UMC (&dat, 8*sizeof(Dwg_Object_##token)); \\\n    bit_write_BOT (&dat, DWG_TYPE_##token);      \\\n  } else {                                       \\\n    bit_write_BS (&dat, DWG_TYPE_##token);       \\\n  }                                              \\\n  bit_set_position(&dat, 0);                     \\\n  error = dwg_decode_add_object(dwg, &dat, &dat, 0);\\\n  if (-1 ==  error) \\\n    dwg_resolve_objectrefs_silent(dwg);          \\\n  if (num_objs == dwg->num_objects)              \\\n    return -1;                                   \\\n  else                                           \\\n    return (long)dwg->num_objects;               \\\n}\n\n#endif\n\n#define DWG_ENTITY(token)                                                     \\\n  static int dwg_encode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error;                                                                \\\n    Bit_Chain _hdl_dat = { 0 };                                               \\\n    Bit_Chain *hdl_dat = &_hdl_dat; /* a new copy */                          \\\n    Bit_Chain *str_dat = dat;       /* a ref */                               \\\n    LOG_INFO (\"Encode entity \" #token \"\\n\");                                  \\\n    bit_chain_init_dat (hdl_dat, 128, dat);                                   \\\n    error = dwg_encode_entity (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      {                                                                       \\\n        LOG_HANDLE (\"Early DWG_ENTITY exit\\n\");                               \\\n        if (hdl_dat != dat && hdl_dat->chain != dat->chain)                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        return error;                                                         \\\n      }                                                                       \\\n    error = dwg_encode_##token##_private (dat, hdl_dat, str_dat, obj);        \\\n    if (error & DWG_ERR_VALUEOUTOFBOUNDS && hdl_dat != dat                    \\\n        && hdl_dat->chain != dat->chain)                                      \\\n      {                                                                       \\\n        LOG_HANDLE (\"VALUEOUTOFBOUNDS bypassed DWG_ENTITY_END\\n\");            \\\n        /*bit_chain_free (hdl_dat);*/                                         \\\n      }                                                                       \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_encode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj)                                               \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_Entity *_ent = obj->tio.entity;                                \\\n    Dwg_Entity_##token *_obj = _ent->tio.token;\n\n#define DWG_ENTITY_END                                                        \\\n    if (hdl_dat->byte > dat->byte)                                            \\\n      {                                                                       \\\n        dat->byte = hdl_dat->byte;                                            \\\n        dat->bit = hdl_dat->bit;                                              \\\n      }                                                                       \\\n    if (hdl_dat != dat && hdl_dat->chain != dat->chain)                       \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }\n\n/** Returns -1 if not added, else returns the new objid.\n   Does a complete handleref rescan to invalidate and resolve\n   all internal obj pointers after a object[] realloc.\n*/\n#define DWG_OBJECT(token)                                                     \\\n  static int dwg_encode_##token##_private (                                   \\\n      Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,                 \\\n      Dwg_Object *restrict obj);                                              \\\n  static int dwg_encode_##token (Bit_Chain *restrict dat,                     \\\n                                 Dwg_Object *restrict obj)                    \\\n  {                                                                           \\\n    int error;                                                                \\\n    Bit_Chain _hdl_dat = { 0 };                                               \\\n    Bit_Chain *hdl_dat = &_hdl_dat; /* a new copy */                          \\\n    Bit_Chain *str_dat = dat;       /* a ref */                               \\\n    LOG_INFO (\"Encode object \" #token \"\\n\");                                  \\\n    bit_chain_init_dat (hdl_dat, 128, dat);                                   \\\n    error = dwg_encode_object (obj, dat, hdl_dat, str_dat);                   \\\n    if (error)                                                                \\\n      {                                                                       \\\n        if (hdl_dat != dat)                                                   \\\n          bit_chain_free (hdl_dat);                                           \\\n        return error;                                                         \\\n      }                                                                       \\\n    error = dwg_encode_##token##_private (dat, hdl_dat, str_dat, obj);        \\\n    if (error & DWG_ERR_VALUEOUTOFBOUNDS && hdl_dat != dat                    \\\n        && hdl_dat->chain != dat->chain)                                      \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }                                                                           \\\n  static int dwg_encode_##token##_private (                                   \\\n        Bit_Chain *dat, Bit_Chain *hdl_dat, Bit_Chain *str_dat,               \\\n        Dwg_Object *restrict obj)                                             \\\n  {                                                                           \\\n    int error = 0;                                                            \\\n    BITCODE_BL vcount, rcount3, rcount4;                                      \\\n    Dwg_Data *dwg = obj->parent;                                              \\\n    Dwg_Object_##token *_obj = obj->tio.object->tio.token;\n\n// some objects specs forgot about the common streams, so add it here\n#define DWG_OBJECT_END                                                        \\\n    if (!obj->hdlpos)                                                         \\\n      {                                                                       \\\n        START_OBJECT_HANDLE_STREAM                                            \\\n      }                                                                       \\\n    if (hdl_dat->byte > dat->byte)                                            \\\n      {                                                                       \\\n        dat->byte = hdl_dat->byte;                                            \\\n        dat->bit = hdl_dat->bit;                                              \\\n      }                                                                       \\\n    if (hdl_dat != dat && hdl_dat->chain != dat->chain)                       \\\n      bit_chain_free (hdl_dat);                                               \\\n    return error;                                                             \\\n  }\n\n#define ENT_REACTORS(code)                                                    \\\n  if (dat->version >= R_13 && _obj->num_reactors > 0x1000)                    \\\n    {                                                                         \\\n      LOG_ERROR (\"Invalid num_reactors: %ld\\n\", (long)_obj->num_reactors);    \\\n      return DWG_ERR_VALUEOUTOFBOUNDS;                                        \\\n    }                                                                         \\\n  SINCE (R_13)                                                                \\\n  {                                                                           \\\n    if (_obj->num_reactors && !_obj->reactors)                                \\\n      {                                                                       \\\n        LOG_ERROR (\"NULL entity.reactors\");                                   \\\n        return DWG_ERR_VALUEOUTOFBOUNDS;                                      \\\n      }                                                                       \\\n    for (vcount = 0; vcount < _obj->num_reactors; vcount++)                   \\\n      {                                                                       \\\n        FIELD_HANDLE_N (reactors[vcount], vcount, code, 330);                 \\\n      }                                                                       \\\n  }\n\n#undef DEBUG_POS\n#define DEBUG_POS                                                             \\\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)                                     \\\n    {                                                                         \\\n      LOG_TRACE (\"DEBUG_POS @%u.%u / 0x%x (%lu)\\n\", (unsigned int)dat->byte,  \\\n                 dat->bit, (unsigned int)dat->byte, bit_position (dat));      \\\n    }\n\n/*--------------------------------------------------------------------------------*/\ntypedef struct\n{\n  unsigned long handle;\n  long address;\n  BITCODE_BL index;\n} Object_Map;\n\n/*--------------------------------------------------------------------------------\n * Private functions prototypes\n */\nstatic int encode_preR13 (Dwg_Data *restrict dwg, Bit_Chain *restrict dat);\n\nstatic int dwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                              Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat);\nstatic int dwg_encode_common_entity_handle_data (Bit_Chain *dat,\n                                                 Bit_Chain *hdl_dat,\n                                                 Dwg_Object *restrict obj);\nstatic int dwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                        Bit_Chain *str_dat,\n                                        Dwg_Data *restrict dwg);\nstatic int dwg_encode_variable_type (Dwg_Data *restrict dwg,\n                                     Bit_Chain *restrict dat,\n                                     Dwg_Object *restrict obj);\nvoid dwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                           Dwg_Data *restrict dwg,\n                           Dwg_Object_Ref *restrict ref);\nvoid dwg_encode_handleref_with_code (Bit_Chain *hdl_dat,\n                                     Dwg_Object *restrict obj,\n                                     Dwg_Data *restrict dwg,\n                                     Dwg_Object_Ref *restrict ref,\n                                     unsigned int code);\nint dwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                           unsigned long address);\n\nstatic int dwg_encode_xdata (Bit_Chain *restrict dat,\n                             Dwg_Object_XRECORD *restrict obj, unsigned size);\nstatic unsigned long add_LibreDWG_APPID (Dwg_Data *dwg);\nstatic BITCODE_BL add_DUMMY_eed (Dwg_Object *obj);\nstatic void fixup_NOD (Dwg_Data *restrict dwg, Dwg_Object *restrict obj);\n\n/* Imported */\nBITCODE_H\ndwg_find_tablehandle_silent (Dwg_Data *restrict dwg, const char *restrict name,\n                             const char *restrict table);\nvoid set_handle_size (Dwg_Handle *restrict hdl);\n\n/*--------------------------------------------------------------------------------\n * Public functions\n */\n\nstatic BITCODE_RL\nencode_patch_RLsize (Bit_Chain *dat, long unsigned int pvzadr)\n{\n  unsigned long pos;\n  BITCODE_RL size;\n  if (dat->bit) // padding\n    {\n      dat->bit = 0;\n      dat->byte++;\n    }\n  size = dat->byte - pvzadr - 4; // minus the RL size\n  pos = bit_position (dat);\n  assert (pvzadr);\n  bit_set_position (dat, pvzadr * 8);\n  bit_write_RL (dat, size);\n  LOG_TRACE (\"size: \" FORMAT_RL \" [RL] @%lu\\n\", size, pvzadr);\n  bit_set_position (dat, pos);\n  return size;\n}\n\n/* if an error in this section should immediately return with a critical error,\n * like INVALIDDWG */\n#if 0\nstatic bool\nis_section_critical (Dwg_Section_Type i)\n{\n  return (i == SECTION_OBJECTS || i == SECTION_HEADER || i == SECTION_CLASSES\n          || i == SECTION_HANDLES) ? true : false;\n}\n#endif\nstatic bool\nis_section_r13_critical (Dwg_Section_Type_R13 i)\n{\n  return i <= SECTION_HANDLES_R13 ? true : false;\n}\n\n/* Limitations: */\n\nstatic unsigned long\nadd_LibreDWG_APPID (Dwg_Data *dwg)\n{\n  BITCODE_H appid = dwg_find_tablehandle_silent (dwg, \"LibreDWG\", \"APPID\");\n  BITCODE_H appctl;\n  Dwg_Object *obj;\n  Dwg_Object_APPID *_obj;\n  Dwg_Object_APPID_CONTROL *o;\n  unsigned long absref;\n  //int error = 0;\n\n  if (appid)\n    return appid->absolute_ref;\n\n  // This breaks json.test roundtrips tests as it adds a new object.\n  // But sooner or later we want to delete yet unsupported objects\n  // (Dictionaries, MATERIAL, VISUALSTYLE, dynblocks, surfaces, assoc*, ...)\n\n  // add APPID\n#if 1\n\n  _obj = dwg_add_APPID (dwg, \"LibreDWG\");\n  return dwg_obj_generic_handlevalue (_obj);\n\n#else\n  if (!(appctl = dwg->header_vars.APPID_CONTROL_OBJECT))\n    appctl = dwg_find_table_control (dwg, \"APPID_CONTROL\");\n  if (!appctl)\n    {\n      LOG_ERROR (\"APPID_CONTROL not found\")\n      return 0;\n    }\n  absref = dwg->object[dwg->num_objects - 1].handle.value + 1;\n  dwg_add_object (dwg);\n  obj = &dwg->object[dwg->num_objects - 1];\n  if (dwg_setup_APPID (obj) >= DWG_ERR_CRITICAL)\n    return 0;\n  dwg_add_handle (&obj->handle, 0, absref, obj);\n  //obj->type = obj->fixedtype = DWG_TYPE_APPID;\n  _obj = obj->tio.object->tio.APPID;\n  // precise size, bitsize done by encode\n  obj->size = 25;\n  obj->bitsize = 164;\n  obj->tio.object->ownerhandle = dwg_add_handleref (dwg, 4, appctl->absolute_ref, NULL);\n  obj->tio.object->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n\n  _obj->name = dwg_add_u8_input (dwg, \"LibreDWG\");\n  _obj->is_xref_ref = 1;\n  _obj->xref = dwg_add_handleref (dwg, 5, 0, NULL);\n\n  // add to APPID_CONTROL\n  obj = dwg_ref_object (dwg, appctl);\n  if (!obj)\n    {\n      LOG_ERROR (\"APPID_CONTROL not found\")\n      return 0;\n    }\n  o = obj->tio.object->tio.APPID_CONTROL;\n  PUSH_HV (o, num_entries, entries, dwg_add_handleref (dwg, 2, absref, NULL));\n  return absref;\n\n#endif\n\n  return 0x12; // APPID.ACAD\n}\n\nstatic BITCODE_BL\nadd_DUMMY_eed (Dwg_Object *obj)\n{\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  //const int is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n  const BITCODE_BL num_eed = ent->num_eed; // same offset for object\n  Dwg_Data *dwg = obj->parent;\n  char *name = obj->dxfname;\n  BITCODE_H appid;\n  Dwg_Eed_Data *data;\n  int i = 1, off = 0;\n  int len, size;\n  const bool is_tu = dwg->header.version >= R_2007;\n\n  // FIXME\n#ifdef _WIN\n\n  return 0;\n\n#else\n\n#ifdef HAVE_STDDEF_H /* windows (mingw32,cygwin) not */\n  assert (offsetof (Dwg_Object_Object, num_eed) == offsetof (Dwg_Object_Entity, num_eed));\n  assert (offsetof (Dwg_Object_Object, eed) == offsetof (Dwg_Object_Entity, eed));\n#endif\n\n  if (num_eed) // replace it\n    dwg_free_eed (obj);\n  appid = dwg_find_tablehandle_silent (dwg, \"LibreDWG\", \"APPID\");\n  if (!appid)\n    {\n      LOG_WARN (\"APPID LibreDWG not found, no EED added\");\n      ent->num_eed = 0;\n      return 0;\n    }\n  ent->num_eed = 1;\n  ent->eed = calloc (2, sizeof (Dwg_Eed));\n  len = strlen (name);\n  size = is_tu ? 1 + 2 + ((len + 1) * 2) // RC + RS_LE + wstr\n               : 1 + 3 + len + 1;        // RC + RC+RS_LE + str\n  data = ent->eed[0].data = (Dwg_Eed_Data *)calloc (size + 3, 1);\n  ent->eed[0].size = size;\n  dwg_add_handle (&ent->eed[0].handle, 5, appid->absolute_ref, NULL);\n  data->code = 0; // RC\n  if (is_tu) // probably never used, write DUMMY placeholder to R_2007\n    {\n      BITCODE_TU wstr = bit_utf8_to_TU (name, 0);\n      data->u.eed_0_r2007.is_tu = 1;\n      data->u.eed_0_r2007.length = len; // RS\n      memcpy (data->u.eed_0_r2007.string, wstr, len * 2);\n    }\n  else\n    {\n      data->u.eed_0.is_tu = 0;\n      data->u.eed_0.length = len;  // RC\n      data->u.eed_0.codepage = 30; // RS\n      memcpy (data->u.eed_0.string, name, len);\n    }\n  LOG_TRACE (\"-EED[0]: code: 0, string: %s (len: %d)\\n\", name, len);\n\n  if (!obj->num_unknown_bits)\n    return 1;\n  // unknown_bits in chunks of 256\n  len = obj->num_unknown_bits / 8;\n  if (obj->num_unknown_bits % 8)\n    len++;\n  size = (len / 256) + 1;\n  if (size > 1) // we already reserved for two eeds\n    {\n      ent->eed = realloc (ent->eed, (1 + size) * sizeof (Dwg_Eed));\n      memset (&ent->eed[1], 0, size * sizeof (Dwg_Eed));\n    }\n  do\n    {\n      int l = len > 255 ? 255 : len;\n      ent->num_eed++;\n      ent->eed[i].size = 0;\n      ent->eed[0].size += l + 2;\n      data = ent->eed[i].data = (Dwg_Eed_Data *)calloc (l + 2, 1);\n      data->code = 4;           // RC\n      data->u.eed_4.length = l; // also just an RC. max 256, how odd\n      memcpy (data->u.eed_4.data, &obj->unknown_bits[off], data->u.eed_4.length);\n      LOG_TRACE (\"-EED[%d]: code: 4, unknown_bits: %d\\n\", i, data->u.eed_4.length);\n      if (len > 255)\n        {\n          len -= 256;\n          off += 256;\n          i++;\n        }\n      else\n        break;\n    }\n  while (1);\n  return i;\n#endif\n}\n\n#ifdef ENCODE_UNKNOWN_AS_DUMMY\n\n/** We cannot write unknown bits into another version. Also with indxf we don't\n * have that luxury. Write a DUMMY/PLACEHOLDER or POINT instead. Later maybe\n * PROXY. This leaks and is controversial. But it silences many ACAD import\n * warnings, and preserves information.\n */\nstatic void\nencode_unknown_as_dummy (Bit_Chain *restrict dat, Dwg_Object *restrict obj,\n                         BITCODE_BS placeholder_type)\n{\n  Dwg_Data *dwg = obj->parent;\n  int is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n  \n  obj->size = 0;\n  obj->bitsize = 0;\n\n  if (is_entity)\n    { // POINT is better than DUMMY to preserve the next_entity chain.\n      // TODO much better would be PROXY_ENTITY\n      Dwg_Entity_POINT *_obj = obj->tio.entity->tio.POINT;\n      LOG_WARN (\"fixup unsupported %s %lX as POINT\", obj->dxfname, obj->handle.value);\n      if (!obj->tio.entity->xdicobjhandle)\n        obj->tio.entity->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n      /*\n      if (obj->tio.entity->num_reactors)\n        {\n          free (obj->tio.entity->reactors);\n          obj->tio.entity->num_reactors = 0;\n          obj->tio.entity->reactors = NULL;\n        }\n      */\n      add_DUMMY_eed (obj); // broken on windows\n      dwg_free_object_private (obj);\n      free (obj->unknown_bits);\n      obj->tio.entity->tio.POINT = _obj\n          = realloc (_obj, sizeof (Dwg_Entity_POINT));\n      // memset (_obj, 0, sizeof (Dwg_Entity_POINT)); // asan cries\n      _obj->parent = obj->tio.entity;\n      _obj->x = 0.0;\n      _obj->y = 0.0;\n      _obj->z = 0.0;\n      _obj->thickness = 1e25; // let it stand out\n      _obj->extrusion.x = 0.0;\n      _obj->extrusion.y = 0.0;\n      _obj->extrusion.z = 1.0;\n      _obj->x_ang = 0.0;\n      obj->type = DWG_TYPE_POINT;\n      obj->fixedtype = DWG_TYPE_POINT;\n      if (dwg->opts & DWG_OPTS_INJSON)\n        {\n          free (obj->name);\n          obj->name = strdup (\"POINT\");\n        }\n      else\n        obj->name = (char *)\"POINT\";\n      if (dwg->opts & DWG_OPTS_IN)\n        {\n          free (obj->dxfname);\n          obj->dxfname = strdup (\"POINT\");\n        }\n      else\n        obj->dxfname = (char *)\"POINT\";\n    }\n  else\n    {\n      const char *name;\n      const char *dxfname;\n\n      add_DUMMY_eed (obj); // broken on windows\n      dwg_free_object_private (obj);\n      // if PLACEHOLDER is available, or even PROXY_OBJECT.\n      // PLOTSETTINGS uses PLACEHOLDER though\n      if (placeholder_type)\n        {\n          obj->type = placeholder_type;\n          obj->fixedtype = DWG_TYPE_PLACEHOLDER;\n          name = \"PLACEHOLDER\";\n          dxfname = \"ACDBPLACEHOLDER\";\n        }\n      else\n        {\n          obj->type = DWG_TYPE_DUMMY;\n          obj->fixedtype = DWG_TYPE_DUMMY;\n          name = \"DUMMY\";\n          dxfname = \"DUMMY\";\n        }\n      LOG_INFO (\"fixup unsupported %s %lX as %s, Type %d\\n\", obj->dxfname,\n                obj->handle.value, name, obj->type);\n      if (!obj->tio.object->xdicobjhandle)\n        obj->tio.object->xdicobjhandle = dwg_add_handleref (dwg, 3, 0, NULL);\n      // keep owner, xdicobj, reactors\n      if (dwg->opts & DWG_OPTS_INJSON)\n        {\n          free (obj->name);\n          obj->name = strdup (name);\n        }\n      else\n        obj->name = (char *)name;\n      if (dwg->opts & DWG_OPTS_IN)\n        {\n          free (obj->dxfname);\n          obj->dxfname = strdup (dxfname);\n        }\n      else\n        obj->dxfname = (char *)dxfname;\n      free (obj->unknown_bits);\n    }\n  obj->hdlpos = 0;\n}\n#endif\n\n// delete this NOD entry\n// only needed until we can write all object types (at least the ones from the NOD)\nstatic void\nremove_NOD_item (Dwg_Object_DICTIONARY *_obj, const int i, const char *name)\n{\n  int last = _obj->numitems - 1;\n  LOG_TRACE (\"Disable link to \" FORMAT_REF \" for NOD.%s\\n\",\n             ARGS_REF (_obj->itemhandles[i]), name);\n  if (i < last)\n    {\n      free (_obj->texts[i]);\n      if (!_obj->itemhandles[i]->handleref.is_global)\n        free (_obj->itemhandles[i]);\n      memmove (&_obj->texts[i], &_obj->texts[i+1], (last - i) * sizeof (BITCODE_T));\n      memmove (&_obj->itemhandles[i], &_obj->itemhandles[i+1], (last - i) * sizeof (BITCODE_H));\n    }\n  _obj->numitems--;\n  return;\n}\n\n// NOD: ACAD_TABLESTYLE => DICT name[0] - itemhandles[0] => TABLESTYLE (Unstable)\n// AcDbVariableDictionary: CTABLESTYLE => DICTVAR str\n// only needed until we can write all object types (at least the ones from the NOD)\nstatic void\nfixup_NOD (Dwg_Data *restrict dwg, Dwg_Object *restrict obj) // named object dict\n{\n  Dwg_Object_DICTIONARY *_obj;\n  int is_tu = dwg->header.version >= R_2007;\n  if (obj->handle.value != 0xC)\n    return;\n  _obj = obj->tio.object->tio.DICTIONARY;\n  // => DICTIONARY with name of current style, and link to it.\n  // If the link target is disabled (unstable, unhandled or such), remove it from the NOD.\n#define DISABLE_NODSTYLE(name)                                                \\\n  if (!is_type_stable (DWG_TYPE_##name))                                      \\\n    {                                                                         \\\n      if (is_tu)                                                              \\\n        {                                                                     \\\n          char *u8 = bit_convert_TU ((BITCODE_TU)_obj->texts[i]);             \\\n          if (u8 && strEQc (u8, \"ACAD_\" #name))                               \\\n            remove_NOD_item (_obj, i, \"ACAD_\" #name);                         \\\n          free (u8);                                                          \\\n        }                                                                     \\\n      else if (_obj->texts[i] && strEQc (_obj->texts[i], \"ACAD_\" #name))      \\\n        remove_NOD_item (_obj, i, \"ACAD_\" #name);                             \\\n    }\n  \n  for (BITCODE_BL i = 0; i < _obj->numitems; i++)\n    {\n      DISABLE_NODSTYLE (ASSOCNETWORK)\n      else DISABLE_NODSTYLE (ASSOCPERSSUBENTMANAGER)\n      else DISABLE_NODSTYLE (DETAILVIEWSTYLE)\n      else DISABLE_NODSTYLE (MATERIAL)\n      else DISABLE_NODSTYLE (MLEADERSTYLE)\n      else DISABLE_NODSTYLE (MLINESTYLE)\n      else DISABLE_NODSTYLE (PERSUBENTMGR)\n      else DISABLE_NODSTYLE (PLOTSETTINGS)\n      // else DISABLE_NODSTYLE (PLOTSTYLENAME)\n      else DISABLE_NODSTYLE (SECTIONVIEWSTYLE)\n      else DISABLE_NODSTYLE (TABLESTYLE)\n      else DISABLE_NODSTYLE (VISUALSTYLE)\n    }\n#undef DISABLE_NODSTYLE\n}\n\n/* Copy the decomp buffer uncompressed into dat of a DWG r2004+ file. Sets comp_data_size. */\nstatic int copy_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                               uint32_t decomp_data_size, uint32_t *comp_data_size)\n{\n  if (dat->byte + decomp_data_size >= dat->size)\n    {\n      dat->size = dat->byte + decomp_data_size;\n      bit_chain_alloc (dat);\n    }\n  assert (!dat->bit);\n  memcpy (&dat->chain[dat->byte], decomp, decomp_data_size);\n  dat->byte += decomp_data_size;\n  *comp_data_size = decomp_data_size;\n  return 0;\n}\n\n/* 1 for yes, 0 for no */\nstatic int\nsection_encrypted (const Dwg_Data *dwg, const Dwg_Section_Type id)\n{\n  switch (id)\n    {\n    case SECTION_SECURITY: //??\n    case SECTION_FILEDEPLIST:\n    case SECTION_APPINFO:\n      return 1;\n    case SECTION_UNKNOWN:\n    case SECTION_HEADER:\n    case SECTION_REVHISTORY:\n    case SECTION_OBJECTS:\n    case SECTION_OBJFREESPACE:\n    case SECTION_TEMPLATE:\n    case SECTION_HANDLES:\n    case SECTION_CLASSES:\n    case SECTION_AUXHEADER:\n    case SECTION_SUMMARYINFO:\n    case SECTION_PREVIEW:\n    case SECTION_APPINFOHISTORY:\n    case SECTION_VBAPROJECT:\n    case SECTION_SIGNATURE:\n    case SECTION_ACDS:\n    case SECTION_SYSTEM_MAP:\n    case SECTION_INFO:\n    default:\n      return 0;\n    }\n}\n\n/* 1 for yes, 0 for no */\nstatic int\nsection_compressed (const Dwg_Data *dwg, const Dwg_Section_Type id)\n{\n  switch (id)\n    {\n    case SECTION_UNKNOWN:\n    case SECTION_HEADER:\n    case SECTION_REVHISTORY:\n    case SECTION_OBJECTS:\n    case SECTION_OBJFREESPACE:\n    case SECTION_TEMPLATE:\n    case SECTION_HANDLES:\n    case SECTION_CLASSES:\n    case SECTION_AUXHEADER:\n    case SECTION_SYSTEM_MAP:\n    case SECTION_INFO:\n      return 1;\n    case SECTION_SUMMARYINFO:\n    case SECTION_PREVIEW:\n    case SECTION_APPINFO:\n    case SECTION_APPINFOHISTORY:\n    case SECTION_FILEDEPLIST:\n    case SECTION_SECURITY:\n    case SECTION_VBAPROJECT:\n    case SECTION_SIGNATURE:\n    case SECTION_ACDS:\n    default:\n      return 0;\n    }\n}\n\n/* r2004 compressed sections, LZ77 WIP */\n\n#define MIN_COMPRESSED_SECTION 19\n#define COMPRESSION_BUFFER_SIZE 0x400\n#define COMPRESSION_WINDOW_SIZE 0x800\n\nstatic void\nwrite_length (Bit_Chain *dat, uint32_t u1, uint32_t match, uint32_t u2);\n\n/* R2004 Write literal length\n */\nstatic unsigned char\nwrite_literal_length (Bit_Chain *restrict dat, BITCODE_RC *restrict buf, uint32_t len)\n{\n#if 0\n  if (len <= (0x0F + 3)) // single byte, opcode 0\n    {\n      bit_write_RC (dat, len - 3);\n      return 0;\n    }\n  else if (len < 0xf0)\n    {\n      bit_write_RC (dat, len);\n      return length & 0xff;\n    }\n  else\n    {\n      uint32_t total = 0x0f;\n      while (leng >= 0xf0)\n        {\n          bit_write_RC (dat, 0);\n          len -= 0xFF;\n          total += 0xFF;\n        }\n      bit_write_RC (dat, len - 3); // ??\n      return 0;\n    }\n#else\n  if (len)\n    {\n      if (len > 3) {\n        write_length (dat, 0, len - 1, 0x11);\n      }\n      LOG_INSANE (\"LIT %x\\n\", len)\n      bit_write_TF (dat, buf, len);\n    }\n  return 0;\n#endif\n}\n\n/* R2004 Long Compression Offset\n */\nstatic void\nwrite_long_compression_offset (Bit_Chain *dat, uint32_t offset)\n{\n  while (offset > 0xff)\n    {\n      bit_write_RC (dat, 0);\n      offset -= 0xff;\n    }\n  LOG_INSANE (\">O 00 %x\", offset)\n  bit_write_RC (dat, (unsigned char)offset);\n}\n\nstatic void\nwrite_length (Bit_Chain *dat, uint32_t u1, uint32_t match, uint32_t u2)\n{\n  if (u2 < match)\n    {\n      LOG_INSANE (\">L %x \", u1 & 0xff)\n      bit_write_RC (dat, u1 & 0xff);\n      write_long_compression_offset (dat, match - u2);\n      LOG_INSANE (\"\\n\")\n    }\n  else\n    {\n      LOG_INSANE (\">L %x\\n\", (u1 | (match - 2)) & 0xff);\n      bit_write_RC (dat, (u1 | (match - 2)) & 0xff);\n    }\n}\n\n/* R2004 Two Byte Offset\n */\n#if 0\nstatic unsigned int\nwrite_two_byte_offset (Bit_Chain *restrict dat, uint32_t offset)\n{\n  BITCODE_RC b1, b2;\n  b1 = offset << 2;\n  b2 = offset >> 6;\n  //offset = (firstByte >> 2) | (secondByte << 6);\n  bit_write_RC (dat, b1);\n  bit_write_RC (dat, b2);\n  //*lit_length = (firstByte & 0x03);\n  return b1 & 0x03;\n}\n#endif\n\nstatic void\nwrite_two_byte_offset (Bit_Chain *restrict dat, uint32_t oldlen, uint32_t offset, uint32_t len)\n{\n  const unsigned lookahead_buffer_size = COMPRESSION_BUFFER_SIZE;\n  uint32_t b1, b2;\n\n  LOG_INSANE (\"2O %x %x %x: \", oldlen, offset, len)\n  if ((offset < 0xf) && (oldlen < 0x401))\n    {\n      b1 = (offset + 1) * 0x10 | ((oldlen - 1U) & 3) << 2;\n      b2 = (oldlen - 1U) >> 2;\n    }\n  else\n    {\n      if (oldlen <= lookahead_buffer_size)\n        {\n          b2 = oldlen - 1;\n          write_length (dat, 0x20, offset, 0x21);\n        }\n      else\n        {\n          b2 = oldlen - lookahead_buffer_size;\n          write_length (dat, ((b2 >> 0xb) & 8U) | 0x10, offset, 9);\n        }\n      b1 = (b2 & 0xff) << 2;\n      b2 = b2 >> 6;\n    }\n  if (len < 4)\n    b1 = b1 | len;\n  LOG_INSANE (\"> %x %x\\n\", b1, b2)\n  bit_write_RC (dat, b1 & 0xff);\n  bit_write_RC (dat, b2 & 0xff);\n}\n\n/* Finds the longest match to the substring starting at i\n   in the lookahead buffer (size ?) from the history window (size ?). */\nstatic int\nfind_longest_match (BITCODE_RC *restrict decomp, uint32_t decomp_data_size, uint32_t i, uint32_t *lenp)\n{\n  const unsigned lookahead_buffer_size = COMPRESSION_BUFFER_SIZE;\n  const unsigned window_size = COMPRESSION_WINDOW_SIZE;\n  int offset = 0;\n  uint32_t bufend = MIN (i + lookahead_buffer_size, decomp_data_size + 1);\n  *lenp = 0;\n  // only substring lengths >= 2, anything else compression is longer\n  for (uint32_t j = i + 2; j < bufend; j++)\n    {\n      int start = MAX (0, (int)(i - window_size));\n      BITCODE_RC *s = &decomp[i];\n      uint32_t slen = j - i;\n      for (int k = start; k < (int)i; k++)\n        {\n          int curr_offset = i - k;\n          //unsigned int repetitions = slen / curr_offset;\n          //unsigned int last = slen % curr_offset;\n          BITCODE_RC *match = &decomp[k]; // ...\n          //int matchlen = k + last;\n          if ((memcmp (s, match, slen) == 0)\n              && slen > *lenp)\n            {\n              offset = curr_offset;\n              *lenp = slen;\n            }\n        }\n    }\n  if (offset)\n    {\n      LOG_INSANE (\">M %u (%u)\\n\", offset, *lenp)\n    }\n  return offset;\n}\n\n/* Compress the decomp buffer into dat of a DWG r2004+ file. Sets comp_data_size.\n   Variant of the LZ77 algo. ODA section 4.7\n*/\nstatic int compress_R2004_section (Bit_Chain *restrict dat, BITCODE_RC *restrict decomp,\n                                   uint32_t decomp_data_size, uint32_t *comp_data_size)\n{\n  uint32_t i = 0;\n  uint32_t match = 0, oldlen = 0;\n  uint32_t len = 0;\n  unsigned long pos = bit_position (dat);\n  LOG_WARN (\"compress_R2004_section %d\", decomp_data_size);\n  assert (decomp_data_size > MIN_COMPRESSED_SECTION);\n  while (i < decomp_data_size - MIN_COMPRESSED_SECTION)\n    {\n      int offset = find_longest_match (decomp, decomp_data_size, i, &len);\n      if (offset)\n        {\n          // encode offset + len\n          if (match)\n            write_two_byte_offset (dat, oldlen, match, len);\n          write_literal_length (dat, &decomp[i], len);\n          i += match;\n          match = offset;\n          oldlen = len;\n        }\n      else\n        {\n          i += 1; // no match found\n        }\n    }\n  len = decomp_data_size - i;\n  if (match)\n    write_two_byte_offset (dat, oldlen, match, len);\n  write_literal_length (dat, &decomp[i], len);\n  bit_write_RC (dat, 0x11);\n  bit_write_RC (dat, 0);\n  bit_write_RC (dat, 0);\n  *comp_data_size = bit_position (dat) - pos;\n  LOG_INSANE (\"> 11 0 => %u\\n\", *comp_data_size)\n  return 0;\n}\n\nstatic Dwg_Section_Info *\nfind_section_info_type (const Dwg_Data *restrict dwg, Dwg_Section_Type type)\n{\n  for (unsigned i = 0; i < dwg->header.section_infohdr.num_desc; i++)\n    {\n      Dwg_Section_Info *info = &dwg->header.section_info[i];\n      if (info->fixedtype == type)\n        return info;\n    }\n  return NULL;\n}\n\n/* header.section pointers changed, rebuild all info->sections */\nstatic void\nsection_info_rebuild (Dwg_Data *dwg, Dwg_Section_Type lasttype)\n{\n  Dwg_Section_Type type;\n  // we only need to rebuild sections up to the given type\n  for (type = 0; type <= lasttype; type++)\n    {\n      Dwg_Section_Info *info = find_section_info_type (dwg, type);\n      if (info)\n        {\n          unsigned ssi = 0;\n          for (unsigned i = 0; i < dwg->header.num_sections; i++)\n            {\n              Dwg_Section *sec = &dwg->header.section[i];\n              if (sec->type == type) // first section\n                {\n                  info->sections[ssi] = sec;\n                  ssi++;\n                }\n              else if (sec->type > type) // sorted by type\n                break;\n            }\n        }\n    }\n}\n\n/**\n * dwg_encode(): the current generic encoder entry point.\n *\n * TODO: preR13 tables, 2007 maps.\n * 2010+ uses the 2004 format.\n * Returns a summary bitmask of all errors.\n */\nAFL_GCC_TOOBIG\nEXPORT int\ndwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)\n{\n  int ckr_missing = 1;\n  int error = 0;\n  BITCODE_BL i, j;\n  long unsigned int section_address;\n  long unsigned int pvzadr;\n  unsigned int ckr;\n  unsigned int sec_size = 0;\n  long unsigned int last_offset;\n  BITCODE_BL last_handle;\n  Object_Map *omap;\n  Bit_Chain *old_dat = NULL, *str_dat, *hdl_dat;\n  int sec_id;\n  Dwg_Version_Type orig_from_version = dwg->header.from_version;\n  Bit_Chain sec_dat[SECTION_SYSTEM_MAP + 1]; // to encode each r2004 section\n\n  if (dwg->opts)\n    loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;\n#ifdef USE_TRACING\n  /* Before starting, set the logging level, but only do so once.  */\n  if (!env_var_checked_p)\n    {\n      char *probe = getenv (\"LIBREDWG_TRACE\");\n      if (probe)\n        loglevel = atoi (probe);\n      env_var_checked_p = true;\n    }\n#endif /* USE_TRACING */\n\n  if (dwg->header.version != dwg->header.from_version)\n    LOG_TRACE (\"Encode version %s (%s) from version %s (%s)\\n\",\n               version_codes[dwg->header.version],\n               dwg_version_type (dwg->header.version),\n               version_codes[dwg->header.from_version],\n               dwg_version_type (dwg->header.from_version))\n  else\n    LOG_TRACE (\"Encode version %s (%s)\\n\", version_codes[dwg->header.version],\n               dwg_version_type (dwg->header.version))\n\n#ifdef ENCODE_UNKNOWN_AS_DUMMY\n  // We cannot write unknown_bits into another version, or when it's coming\n  // from DXF. Write a PLACEHOLDER/DUMMY or POINT instead. Later maybe PROXY.\n  // This is controversial and breaks roundtrip tests, but helps\n  // ACAD imports.\n  if (dwg->header.version != dwg->header.from_version\n      || (dwg->opts & DWG_OPTS_IN))\n    {\n      int fixup = 0;\n      // Scan for invalid/unstable/unsupported objects and entities\n      // and eliminate or replace them with placeholders.\n      LOG_TRACE (\"Scan for unsupported objects\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        {\n          Dwg_Object *obj = &dwg->object[i];\n          if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ\n              || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT\n              // WIPEOUT causes hang, TABLEGEOMETRY crash\n              || (dwg->opts & DWG_OPTS_IN &&\n                  (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n                   obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))\n            {\n              fixup++;\n              break;\n            }\n        }\n      if (fixup)\n        {\n          unsigned long new_appid;\n          BITCODE_BS placeholder_type = 0;\n          LOG_TRACE (\"Found unsupported objects, add APPID LibreDWG\\n\");\n          new_appid = add_LibreDWG_APPID (dwg);\n          if (new_appid)\n            {\n              fixup = 0;\n              // if not found leaves placeholder_type at 0 to use DUMMY\n              dwg_find_class (dwg, \"ACDBPLACEHOLDER\", &placeholder_type);\n              for (i = 0; i < dwg->num_objects; i++)\n                {\n                  Dwg_Object *obj = &dwg->object[i];\n                  if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ\n                      || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT\n                      || (dwg->opts & DWG_OPTS_IN &&\n                          (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n                           obj->fixedtype == DWG_TYPE_TABLEGEOMETRY)))\n                    {\n                      fixup++;\n                      // replace entities with points, objects with\n                      // placeholders\n                      encode_unknown_as_dummy (dat, obj, placeholder_type);\n                    }\n                  // what to do with links to MATERIAL/...\n                  if (obj->handle.value == 0xC\n                      && obj->fixedtype == DWG_TYPE_DICTIONARY)\n                    fixup_NOD (dwg, obj); // named object dict\n                }\n              LOG_TRACE (\"Fixed %d unsupported objects\\n\\n\", fixup);\n            }\n        }\n    }\n#endif\n\n  bit_chain_alloc (dat);\n  hdl_dat = dat; // splitted later in objects/entities\n  if (!dat->version)\n    {\n      dat->version = dwg->header.version;\n      dat->from_version = dwg->header.from_version;\n      dat->opts = dwg->opts;\n    }\n\n  /*------------------------------------------------------------\n   * Header\n   */\n  strcpy ((char *)dat->chain,\n          version_codes[dwg->header.version]); // Chain version\n  dat->byte += 6;\n\n  {\n    Dwg_Header *_obj = &dwg->header;\n    Dwg_Object *obj = NULL;\n    if (!_obj->dwg_version) // ie from DXF\n      {\n        _obj->zero_one_or_three = 1;\n        _obj->dwg_version = 0x21;\n        _obj->is_maint = 0xf;\n        _obj->maint_version = 29;\n        if (dwg->header.version < R_13)\n          {\n            _obj->dwg_version = 0x14;\n          }\n        /*\n        switch (dwg->header.version)\n          {\n          case R_9:\n            _obj->dwg_version = 0x0b;\n            break;\n          case R_10:\n            _obj->dwg_version = 0x0d;\n            break;\n          case R_11:\n            _obj->dwg_version = 0x10;\n            break;\n          case R_13:\n            _obj->dwg_version = 0x13;\n            break;\n          case R_13c3:\n            _obj->dwg_version = 0x14;\n            break;\n          case R_14:\n            _obj->dwg_version = 0x15;\n            break;\n          case R_2000:\n            _obj->dwg_version = 0x17;\n            _obj->is_maint = 0xf;\n            break;\n          case R_2004:\n            _obj->dwg_version = 0x19; // or 0x18/0x1a\n            _obj->is_maint = 0x68;\n            break;\n          case R_2007:\n            _obj->dwg_version = 0x1b;\n            _obj->is_maint = 0x32;\n            break;\n          case R_2010:\n            _obj->dwg_version = 0x1d;\n            _obj->is_maint = 0x6d;\n            break;\n          case R_2013:\n            _obj->dwg_version = 0x1f;\n            _obj->is_maint = 0x7d;\n            break;\n          case R_2018:\n            _obj->dwg_version = 0x21;\n            _obj->is_maint = 0x1d;\n            break;\n          case R_INVALID:\n          case R_AFTER:\n          case R_1_1:\n          case R_1_2:\n          case R_1_3:\n          case R_1_4:\n          case R_1_402b:\n          case R_2_0:\n          case R_2_1:\n          case R_2_21:\n          case R_2_22:\n          case R_2_4:\n          case R_2_5:\n          case R_2_6:\n          case R_9c1:\n          case R_10c1:\n          case R_10c2:\n          case R_12:\n          case R_12c1:\n          default:\n            break;\n          }\n          */\n        if (!_obj->app_dwg_version)\n          _obj->app_dwg_version = _obj->dwg_version;\n      }\n    if (!_obj->codepage)\n      _obj->codepage = 30;\n\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  section_address = dat->byte;\n\n#define WE_CAN                                                                \\\n  \"This version of LibreDWG is only capable of encoding \"                     \\\n  \"version R13-R2000 (code: AC1012-AC1015) DWG files.\\n\"\n\n  PRE (R_13)\n  {\n    // TODO: tables, entities, block entities\n    LOG_ERROR (WE_CAN \"We don't encode preR13 tables, entities, blocks yet\")\n#ifndef IS_RELEASE\n    return encode_preR13 (dwg, dat);\n#endif\n  }\n\n  PRE (R_2004)\n  {\n    /* section 0: header vars\n     *         1: class section\n     *         2: object map\n     *         3: (R13 c3 and later): 2nd header (special table no sentinels)\n     *         4: optional: MEASUREMENT\n     *         5: optional: AuxHeader\n     */\n    /* Usually 3-5, max 6 */\n    if (!dwg->header.num_sections\n        || (dat->from_version >= R_2004 && dwg->header.num_sections > 6))\n      {\n        dwg->header.num_sections = dwg->header.version < R_2000 ? 5 : 6;\n        // minimal DXF:\n        if (!dwg->header_vars.HANDSEED || !dwg->header_vars.TDCREATE.days)\n          {\n            dwg->header.num_sections = 5;\n            // hack to trigger IF_ENCODE_FROM_EARLIER defaults. undone after\n            // HEADER\n            dat->from_version = R_11;\n            if (dat->version <= dat->from_version)\n              dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);\n          }\n      }\n    LOG_TRACE (\"num_sections: \" FORMAT_RL \" [RL]\\n\", dwg->header.num_sections);\n    bit_write_RL (dat, dwg->header.num_sections);\n    if (!dwg->header.section)\n      dwg->header.section = (Dwg_Section*)calloc (dwg->header.num_sections,\n                                                  sizeof (Dwg_Section));\n    if (!dwg->header.section)\n      {\n        LOG_ERROR (\"Out of memory\");\n        return DWG_ERR_OUTOFMEM;\n      }\n    section_address = dat->byte;                 // save section address\n    dat->byte += (dwg->header.num_sections * 9); /* RC + 2*RL */\n    bit_write_CRC (dat, 0, 0xC0C1);\n    bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END));\n\n    /*------------------------------------------------------------\n     * AuxHeader section 5\n     * R2000+, mostly redundant file header information\n     */\n    if (dwg->header.num_sections > 5)\n      {\n        Dwg_AuxHeader *_obj = &dwg->auxheader;\n        Dwg_Object *obj = NULL;\n        BITCODE_BL vcount;\n        assert (!dat->bit);\n        LOG_INFO (\"\\n=======> AuxHeader: %8u\\n\",\n                  (unsigned)dat->byte); // size: 123\n\n        dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;\n        dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;\n\n        if (!_obj->dwg_version) // todo: needed?\n          {\n            BITCODE_RS def_unknown_6rs[] = { 4, 0x565, 0, 0, 2, 1 };\n            LOG_TRACE (\"Use AuxHeader defaults...\\n\");\n            FIELD_VALUE (aux_intro[0]) = 0xff;\n            FIELD_VALUE (aux_intro[1]) = 0x77;\n            FIELD_VALUE (aux_intro[2]) = 0x01;\n            FIELD_VALUE (minus_1) = -1;\n            FIELD_VALUE (dwg_version) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version) = dwg->header.maint_version;\n            FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;\n            FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;\n            FIELD_VALUE (maint_version_1) = dwg->header.maint_version;\n            FIELD_VALUE (maint_version_2) = dwg->header.maint_version;\n            memcpy (FIELD_VALUE (unknown_6rs), def_unknown_6rs,\n                    sizeof (def_unknown_6rs));\n            FIELD_VALUE (TDCREATE) = dwg->header_vars.TDCREATE.value;\n            FIELD_VALUE (TDUPDATE) = dwg->header_vars.TDUPDATE.value;\n            if (dwg->header_vars.HANDSEED)\n              FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;\n          }\n\n          // clang-format off\n        #include \"auxheader.spec\"\n        // clang-format on\n\n        assert (!dat->bit);\n        dwg->header.section[SECTION_AUXHEADER_R2000].size\n            = dat->byte - dwg->header.section[SECTION_AUXHEADER_R2000].address;\n      }\n  }\n\n  VERSION (R_2007)\n  {\n    LOG_ERROR (WE_CAN \"We don't encode R2007 sections yet\");\n    dat->version = dwg->header.version = R_2010; // rather do 2010\n    // return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n  /* r2004 file header (compressed + encrypted) */\n  SINCE (R_2004)\n  {\n    LOG_INFO (\"\\n\");\n    LOG_ERROR (WE_CAN \"Writing R2004 sections not yet finished\");\n\n    memset (&sec_dat, 0, (SECTION_SYSTEM_MAP + 1) * sizeof (Bit_Chain));\n    if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)\n      dwg->header.section_info = (Dwg_Section_Info *)calloc (\n          dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));\n    LOG_TRACE (\"\\n#### r2004 File Header ####\\n\");\n    if (dat->byte + 0x80 >= dat->size - 1)\n      {\n        dwg->header.num_sections = 28; // room for some object pages\n        dwg->header.section = calloc (28, sizeof (Dwg_Section));\n      }\n    if (!dwg->header.section_info)\n      {\n        dwg->header.section_infohdr.num_desc = SECTION_SYSTEM_MAP + 1;\n        dwg->header.section_info\n            = calloc (SECTION_SYSTEM_MAP + 1, sizeof (Dwg_Section_Info));\n      }\n  }\n\n  /*------------------------------------------------------------\n   * THUMBNAIL preview pictures\n   */\n  old_dat = dat;\n  SINCE (R_2004)\n  {\n    bit_chain_init_dat (&sec_dat[SECTION_PREVIEW], dwg->thumbnail.size + 64, dat);\n    str_dat = hdl_dat = dat = &sec_dat[SECTION_PREVIEW];\n  }\n  else\n  {\n    if (!dwg->header.thumbnail_address)\n      dwg->header.thumbnail_address = dat->byte;\n  }\n  dat->bit = 0;\n  LOG_TRACE (\"\\n=======> Thumbnail:       %4u\\n\", (unsigned)dat->byte);\n  // dwg->thumbnail.size = 0; // to disable\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN));\n  if (dwg->thumbnail.size == 0)\n    {\n      bit_write_RL (dat, 5); // overall size\n      LOG_TRACE (\"Thumbnail size: 5 [RL]\\n\");\n      bit_write_RC (dat, 0); // num_pictures\n      LOG_TRACE (\"Thumbnail num_pictures: 0 [RC]\\n\");\n    }\n  else\n    {\n      bit_write_TF (dat, dwg->thumbnail.chain, dwg->thumbnail.size);\n    }\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END));\n\n  {\n    BITCODE_RL bmpsize;\n    dwg_bmp (dwg, &bmpsize);\n    if (bmpsize > dwg->thumbnail.size)\n      LOG_ERROR (\"BMP size overflow: %i > %lu\\n\", bmpsize,\n                 dwg->thumbnail.size);\n  }\n  LOG_TRACE (\"         Thumbnail (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Header Variables\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_HEADER;\n    bit_chain_init_dat (&sec_dat[sec_id], sizeof (Dwg_Header) + 64, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  assert (!dat->bit);\n  LOG_INFO (\"\\n=======> Header Variables:   %4u\\n\", (unsigned)dat->byte);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Empty header.section\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.section[0].number = 0;\n  dwg->header.section[0].address = dat->byte;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_BEGIN));\n\n  pvzadr = dat->byte;      // Size position\n  bit_write_RL (dat, 540); // Size placeholder\n  // if (dat->version >= R_2007)\n  //  str_dat = dat;\n  dwg_encode_header_variables (dat, hdl_dat, dat, dwg);\n  // undo minimal HEADER hack\n  if (dat->from_version != orig_from_version)\n    dat->from_version = orig_from_version;\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n  // XXX trying to fix CRC 2-byte overflow. Must find actual reason.\n  // dat->byte -= 2;\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_VARIABLE_END));\n  assert ((long)dat->byte > (long)dwg->header.section[0].address);\n  dwg->header.section[0].size\n      = (BITCODE_RL) ((long)dat->byte - (long)dwg->header.section[0].address);\n  LOG_TRACE (\"         Header Variables (end): %4u\\n\", (unsigned)dat->byte);\n\n  /*------------------------------------------------------------\n   * Classes\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_CLASSES;\n    bit_chain_init_dat (&sec_dat[sec_id],\n                    (sizeof (Dwg_Class) * dwg->num_classes) + 32, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else sec_id = SECTION_CLASSES_R13;\n  LOG_INFO (\"\\n=======> Classes: %4u (%d)\\n\", (unsigned)dat->byte,\n            dwg->num_classes);\n  if (dwg->num_classes > 5000)\n    {\n      LOG_ERROR (\"Invalid dwg->num_classes %d\", dwg->num_classes)\n      dwg->num_classes = 0;\n      error |= DWG_ERR_VALUEOUTOFBOUNDS | DWG_ERR_CLASSESNOTFOUND;\n    }\n  dwg->header.section[sec_id].number = 1;\n  dwg->header.section[sec_id].address = dat->byte; // FIXME\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_BEGIN));\n  pvzadr = dat->byte;    // Size position\n  bit_write_RL (dat, 0); // Size placeholder\n\n  for (j = 0; j < dwg->num_classes; j++)\n    {\n      Dwg_Class *klass;\n      klass = &dwg->dwg_class[j];\n      bit_write_BS (dat, klass->number);\n      bit_write_BS (dat, klass->proxyflag);\n      SINCE (R_2007) {\n        bit_write_T (dat, klass->appname);\n        bit_write_T (dat, klass->cppname);\n      } else {\n        bit_write_TV (dat, klass->appname);\n        bit_write_TV (dat, klass->cppname);\n      }\n      SINCE (R_2007) // only when we have it. like not for 2004 => 2007\n                     // conversions\n      {\n        if (klass->dxfname_u)\n          bit_write_TU (dat, klass->dxfname_u);\n        else\n          bit_write_T (dat, klass->dxfname);\n      }\n      else // we always have this one\n          bit_write_TV (dat, klass->dxfname);\n      bit_write_B (dat, klass->is_zombie);\n      bit_write_BS (dat, klass->item_class_id);\n      LOG_TRACE (\"Class %d 0x%x %s\\n\"\n                 \" %s \\\"%s\\\" %d 0x%x\\n\",\n                 klass->number, klass->proxyflag, klass->dxfname,\n                 klass->cppname, klass->appname, klass->is_zombie,\n                 klass->item_class_id)\n\n      SINCE (R_2007)\n      {\n        if (dat->from_version < R_2007 && !klass->dwg_version) {\n          // defaults\n          klass->dwg_version = (BITCODE_BL)dwg->header.dwg_version;\n          klass->maint_version = (BITCODE_BL)dwg->header.maint_version;\n          // TODO num_instances\n        }\n        bit_write_BL (dat, klass->num_instances);\n        bit_write_BL (dat, klass->dwg_version);\n        bit_write_BL (dat, klass->maint_version);\n        bit_write_BL (dat, klass->unknown_1);\n        bit_write_BL (dat, klass->unknown_2);\n        LOG_TRACE (\" %d %d\\n\", (int)klass->num_instances,\n                   (int)klass->dwg_version);\n      }\n    }\n\n  /* Write the size of the section at its beginning\n   */\n  assert (pvzadr);\n  encode_patch_RLsize (dat, pvzadr);\n  bit_write_CRC (dat, pvzadr, 0xC0C1);\n  bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_CLASS_END));\n  dwg->header.section[SECTION_CLASSES_R13].size\n      = dat->byte - dwg->header.section[SECTION_CLASSES_R13].address;\n  LOG_TRACE (\"       Classes (end): %4u\\n\", (unsigned)dat->byte);\n\n  bit_write_RL (dat, 0x0DCA); // 0xDCA Unknown bitlong inter class and objects\n  LOG_TRACE (\"unknown: %04X [RL]\\n\", 0x0DCA);\n\n  /*------------------------------------------------------------\n   * Objects\n   */\n\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_OBJECTS;\n    bit_chain_alloc (&sec_dat[sec_id]);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n    bit_chain_set_version (dat, old_dat);\n  }\n  LOG_INFO (\"\\n=======> Objects: %4u\\n\", (unsigned)dat->byte);\n  pvzadr = dat->byte;\n\n  /* Sort object-map by ascending handles\n   */\n  LOG_TRACE (\"num_objects: %i\\n\", dwg->num_objects);\n  LOG_TRACE (\"num_object_refs: %i\\n\", dwg->num_object_refs);\n  omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));\n  if (!omap)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorting objects...\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Object(%3i): %4lX / idx: %u\\n\", i,\n                 dwg->object[i].handle.value, dwg->object[i].index);\n    }\n  // init unsorted\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      omap[i].index = i; // i.e. dwg->object[j].index\n      omap[i].handle = dwg->object[i].handle.value;\n    }\n  // insertion sort\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Object_Map tmap;\n      j = i;\n      tmap = omap[i];\n      while (j > 0 && omap[j - 1].handle > tmap.handle)\n        {\n          omap[j] = omap[j - 1];\n          j--;\n        }\n      omap[j] = tmap;\n    }\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted handles:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        fprintf (OUTPUT, \"Handle(%3i): %4lX / idx: %u\\n\", i, omap[i].handle,\n                 omap[i].index);\n    }\n\n  /* Write the sorted objects\n   */\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      Dwg_Object *obj;\n      BITCODE_BL index = omap[i].index;\n      unsigned long hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);\n      int off = dat->byte - (i ? omap[i - 1].address : 0);\n      unsigned long end_address;\n      LOG_TRACE (\"\\n> Next object: \" FORMAT_BL\n                 \" Handleoff: %lX [UMC] Offset: %d [MC] @%lu\\n\"\n                 \"==========================================\\n\",\n                 i, hdloff, off, dat->byte);\n      omap[i].address = dat->byte;\n      if (index > dwg->num_objects)\n        {\n          LOG_ERROR (\"Invalid object map index \" FORMAT_BL \", max \" FORMAT_BL\n                     \". Skipping\",\n                     index, dwg->num_objects)\n          error |= DWG_ERR_VALUEOUTOFBOUNDS;\n          continue;\n        }\n      obj = &dwg->object[index];\n      // change the address to the linearly sorted one\n#ifndef NDEBUG\n      PRE (R_2004)\n        assert (dat->byte);\n#endif\n      if (!obj->parent)\n        obj->parent = dwg;\n      error |= dwg_encode_add_object (obj, dat, dat->byte);\n\n#ifndef NDEBUG\n      // check if this object overwrote at address 0. but with r2004 it starts\n      // fresh.\n      if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)\n        {\n          if (dat->size < 6 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n            {\n              LOG_ERROR (\"Encode overwrite pos 0, invalid DWG magic\");\n              return DWG_ERR_INVALIDDWG;\n            }\n          assert (dat->size > 6);\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n        }\n#endif\n      end_address = omap[i].address + (unsigned long)obj->size; // from RL\n      if (end_address > dat->size)\n        {\n          dat->size = end_address;\n          bit_chain_alloc (dat);\n        }\n    }\n\n  if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)\n    {\n      LOG_HANDLE (\"\\nSorted objects:\\n\");\n      for (i = 0; i < dwg->num_objects; i++)\n        LOG_HANDLE (\"Object(%d): %lX / Address: %ld / Idx: %d\\n\", i,\n                    omap[i].handle, omap[i].address, omap[i].index);\n    }\n\n  /* Unknown CRC between objects and object map\n   */\n  bit_write_RS (dat, 0);\n  LOG_TRACE (\"unknown crc?: %04X [RS]\\n\", 0);\n\n  /*------------------------------------------------------------\n   * Object-map\n   * split into chunks of max. 2030\n   */\n  LOG_INFO (\"\\n=======> Object Map: %4u\\n\", (unsigned)dat->byte);\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_HANDLES;\n    bit_chain_init_dat (&sec_dat[sec_id], (8 * dwg->num_objects) + 32, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else\n  {\n    sec_id = SECTION_HANDLES_R13;\n    dwg->header.section[sec_id].number = 2;\n    dwg->header.section[sec_id].address = dat->byte;\n    pvzadr = dat->byte; // Correct value of section size must be written later\n    dat->byte += 2;\n  }\n\n  last_offset = 0;\n  last_handle = 0;\n  for (i = 0; i < dwg->num_objects; i++)\n    {\n      BITCODE_BL index;\n      BITCODE_UMC handleoff;\n      BITCODE_MC offset;\n\n      index = omap[i].index;\n      handleoff = omap[i].handle - last_handle;\n      bit_write_UMC (dat, handleoff);\n      LOG_HANDLE (\"Handleoff(%3i): %4lX [UMC] (%4lX), \", index, handleoff,\n                  omap[i].handle)\n      last_handle = omap[i].handle;\n\n      offset = omap[i].address - last_offset;\n      bit_write_MC (dat, offset);\n      last_offset = omap[i].address;\n      LOG_HANDLE (\"Offset: %8d [MC] @%lu\\n\", (int)offset, last_offset);\n\n      ckr_missing = 1;\n      if (dat->byte - pvzadr > 2030) // 2029\n        {\n          ckr_missing = 0;\n          sec_size = dat->byte - pvzadr;\n          assert (pvzadr);\n          // i.e. encode_patch_RS_LE_size\n          dat->chain[pvzadr] = sec_size >> 8;\n          dat->chain[pvzadr + 1] = sec_size & 0xFF;\n          LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n          bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n          pvzadr = dat->byte;\n          dat->byte += 2;\n          last_offset = 0;\n          last_handle = 0;\n        }\n    }\n  // printf (\"Obj size: %u\\n\", i);\n  if (ckr_missing)\n    {\n      sec_size = dat->byte - pvzadr;\n#ifndef NDEBUG\n      PRE (R_2004)\n        assert (pvzadr);\n#endif\n      if (pvzadr + 1 >= dat->size)\n        bit_chain_alloc(dat);\n      // i.e. encode_patch_RS_LE_size\n      dat->chain[pvzadr] = sec_size >> 8;\n      dat->chain[pvzadr + 1] = sec_size & 0xFF;\n      LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", sec_size, pvzadr);\n      bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n    }\n#ifndef NDEBUG\n  if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)\n    {\n      if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n        {\n          LOG_ERROR (\"Encode overwrite pos 0\");\n          return DWG_ERR_INVALIDDWG;\n        }\n      assert (dat->chain[0] == 'A');\n      assert (dat->chain[1] == 'C');\n    }\n  PRE (R_2004)\n    assert (dat->byte);\n#endif\n  pvzadr = dat->byte;\n  bit_write_RS_LE (dat, 2); // last section_size 2\n  LOG_TRACE (\"Handles page size: %u [RS_LE] @%lu\\n\", 2, pvzadr);\n  bit_write_CRC_LE (dat, pvzadr, 0xC0C1);\n\n  /* Calculate and write the size of the object map\n   */\n  dwg->header.section[sec_id].size\n      = dat->byte - dwg->header.section[sec_id].address;\n  free (omap);\n\n  /*------------------------------------------------------------\n   * Second header, section 3. R13-R2000 only.\n   * But partially also since r2004. (TODO: under which name? AuxHeader?)\n   */\n  if (dwg->header.version >= R_13 && dwg->header.version < R_2004 // TODO\n      && dwg->second_header.num_sections > 3)\n    {\n      struct _dwg_second_header *_obj = &dwg->second_header;\n      Dwg_Object *obj = NULL;\n      BITCODE_BL vcount;\n\n      assert (dat->byte);\n      if (!_obj->address)\n        _obj->address = dat->byte;\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n      LOG_INFO (\"\\n=======> Second Header: %4u\\n\", (unsigned)dat->byte);\n      bit_write_sentinel (dat,\n                          dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_BEGIN));\n\n      pvzadr = dat->byte; // Keep the first address of the section to write its\n                          // size later\n      LOG_TRACE (\"pvzadr: %u\\n\", (unsigned)pvzadr);\n      if (!_obj->size && !_obj->num_sections)\n        {\n          LOG_TRACE (\"Use second_header defaults...\\n\");\n          strcpy ((char *)&_obj->version[0],\n                  &version_codes[dwg->header.version][0]);\n          memset (&_obj->version[7], 0, 4);\n          _obj->version[11] = '\\n';\n          _obj->unknown_10 = 0x10;\n          _obj->unknown_rc4[0] = 0x84;\n          _obj->unknown_rc4[1] = 0x74;\n          _obj->unknown_rc4[2] = 0x78;\n          _obj->unknown_rc4[3] = 0x1;\n          _obj->junk_r14_1 = 1957593121; //?\n          _obj->junk_r14_2 = 2559919056; //?\n          // TODO handlers defaults\n        }\n      // always recomputed, even with dwgrewrite\n      if (dwg->header.version <= R_2000)\n        {\n          _obj->num_sections = dwg->header.num_sections;\n          for (i = 0; i < _obj->num_sections; i++)\n            {\n              _obj->section[i].nr = dwg->header.section[i].number;\n              _obj->section[i].address = dwg->header.section[i].address;\n              _obj->section[i].size = dwg->header.section[i].size;\n            }\n        }\n      FIELD_RL (size, 0);\n      if (FIELD_VALUE (address) != (BITCODE_RL) (pvzadr - 16))\n        {\n          LOG_WARN (\"second_header->address %u != %u\", FIELD_VALUE (address),\n                    (unsigned)(pvzadr - 16));\n          FIELD_VALUE (address) = pvzadr - 16;\n          dwg->header.section[SECTION_2NDHEADER_R13].address = _obj->address;\n          dwg->header.section[SECTION_2NDHEADER_R13].size = _obj->size;\n        }\n      FIELD_BL (address, 0);\n\n      // AC1012, AC1014 or AC1015. This is a char[11], zero padded.\n      // with \\n at 12.\n      bit_write_TF (dat, (BITCODE_TF)_obj->version, 12);\n      LOG_TRACE (\"version: %s [TFF 12]\\n\", _obj->version)\n\n      for (i = 0; i < 4; i++)\n        FIELD_B (null_b[i], 0);\n      FIELD_RC (unknown_10, 0); // 0x10\n      for (i = 0; i < 4; i++)\n        FIELD_RC (unknown_rc4[i], 0);\n\n      UNTIL (R_2000)\n      {\n        FIELD_RC (num_sections, 0); // r14: 5, r2000: 6 (auxheader)\n        for (i = 0; i < FIELD_VALUE (num_sections); i++)\n          {\n            FIELD_RC (section[i].nr, 0);\n            FIELD_BL (section[i].address, 0);\n            FIELD_BLd (section[i].size, 0);\n          }\n\n        FIELD_BS (num_handlers, 0); // 14, resp. 16 in r14\n        if (FIELD_VALUE (num_handlers) > 16)\n          {\n            LOG_ERROR (\"Second header num_handlers > 16: %d\\n\",\n                       FIELD_VALUE (num_handlers));\n            FIELD_VALUE (num_handlers) = 14;\n          }\n        for (i = 0; i < FIELD_VALUE (num_handlers); i++)\n          {\n            FIELD_RC (handlers[i].size, 0);\n            FIELD_RC (handlers[i].nr, 0);\n            FIELD_VECTOR (handlers[i].data, RC, handlers[i].size, 0);\n          }\n\n        _obj->size = encode_patch_RLsize (dat, pvzadr);\n        bit_write_CRC (dat, pvzadr, 0xC0C1);\n\n        VERSION (R_14)\n        {\n          FIELD_RL (junk_r14_1, 0);\n          FIELD_RL (junk_r14_2, 0);\n        }\n      }\n      bit_write_sentinel (dat, dwg_sentinel (DWG_SENTINEL_SECOND_HEADER_END));\n      dwg->header.section[SECTION_2NDHEADER_R13].size\n          = dat->byte - _obj->address;\n    }\n  else if (dwg->header.num_sections > SECTION_2NDHEADER_R13\n           && dwg->header.version < R_2004) // TODO\n    {\n      dwg->header.section[SECTION_2NDHEADER_R13].number = 3;\n      dwg->header.section[SECTION_2NDHEADER_R13].address = 0;\n      dwg->header.section[SECTION_2NDHEADER_R13].size = 0;\n    }\n\n  /*------------------------------------------------------------\n   * MEASUREMENT/Template Section 4\n   * In a DXF under header_vars\n   */\n  SINCE (R_2004)\n  {\n    sec_id = SECTION_TEMPLATE;\n    bit_chain_init_dat (&sec_dat[sec_id], 16, dat);\n    str_dat = hdl_dat = dat = &sec_dat[sec_id];\n  }\n  else sec_id = SECTION_MEASUREMENT_R13;\n\n  if (dwg->header.version >= R_2004 || (int)dwg->header.num_sections > sec_id)\n    {\n      LOG_INFO (\"\\n=======> MEASUREMENT: %4u\\n\", (unsigned)dat->byte);\n      dwg->header.section[sec_id].number = 4;\n      dwg->header.section[sec_id].address = dat->byte;\n      dwg->header.section[sec_id].size = 4;\n      // 0 - English, 1- Metric\n      bit_write_RL_LE (dat, (BITCODE_RL)dwg->header_vars.MEASUREMENT ? 256 : 0);\n      LOG_TRACE (\"HEADER.MEASUREMENT: %d [RL_LE]\\n\",\n                 dwg->header_vars.MEASUREMENT);\n    }\n\n  /* End of the file\n   */\n  dat->size = dat->byte;\n  SINCE (R_2004)\n  {\n    Dwg_Section_Type type;\n    Dwg_Object *obj = NULL;\n    BITCODE_BL vcount, rcount3;\n    size_t size;\n    unsigned total_size = 0;\n\n    // write remaining section data\n    for (type = SECTION_OBJFREESPACE; type < SECTION_SYSTEM_MAP; type++)\n      {\n        if (type != SECTION_OBJECTS && type != SECTION_PREVIEW)\n          LOG_TRACE (\"\\n=== Section %s ===\\n\", dwg_section_name (dwg, type))\n        switch (type)\n          {\n          case SECTION_HEADER: // ignore, already done\n          case SECTION_AUXHEADER:\n          case SECTION_CLASSES:\n          case SECTION_HANDLES:\n          case SECTION_TEMPLATE:\n          case SECTION_PREVIEW:\n          case SECTION_OBJECTS:\n          case SECTION_UNKNOWN: // deferred\n          case SECTION_INFO:\n          case SECTION_SYSTEM_MAP:\n            break;\n          case SECTION_OBJFREESPACE:\n            {\n              Dwg_ObjFreeSpace *_obj = &dwg->objfreespace;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"objfreespace.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_REVHISTORY:\n            {\n              Dwg_RevHistory *_obj = &dwg->revhistory;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"revhistory.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SUMMARYINFO:\n            {\n              Dwg_SummaryInfo *_obj = &dwg->summaryinfo;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"summaryinfo.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_APPINFO:\n            {\n              Dwg_AppInfo *_obj = &dwg->appinfo;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"appinfo.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_APPINFOHISTORY:\n            {\n#if 0\n              Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#  include \"appinfohistory.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_FILEDEPLIST:\n            {\n              Dwg_FileDepList *_obj = &dwg->filedeplist;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"filedeplist.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SECURITY:\n            {\n              Dwg_Security *_obj = &dwg->security;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n#include \"security.spec\"\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n            }\n            break;\n          case SECTION_SIGNATURE:\n            {\n#if 0\n              Dwg_Signature *_obj = &dwg->signature;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n              {\n#  include \"signature.spec\"\n              }\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_ACDS:\n            {\n#if 0\n              Dwg_AcDs *_obj = &dwg->acds;\n              bit_chain_alloc (&sec_dat[type]);\n              str_dat = hdl_dat = dat = &sec_dat[type];\n              bit_chain_set_version (dat, old_dat);\n              {\n#  include \"acds.spec\"\n              }\n              LOG_TRACE (\"-size: %lu\\n\", dat->byte)\n#endif\n            }\n            break;\n          case SECTION_VBAPROJECT: // nyi\n          default:\n            break;\n          }\n      }\n    // and write system and data section maps.\n    dat = old_dat;\n\n    /*-------------------------------------------------------------------------\n     * Section map and info\n     */\n    // no gaps, so header->num_sections == r2004_header->numsections\n    // get together all the section sizes, and set the addresses\n    {\n      int ssize;\n      int si, info_id;\n      unsigned address;\n\n      const Dwg_Section_Type section_map_order[] = {\n        // R2004_Header\n        SECTION_UNKNOWN, // the empty section 128-256\n        SECTION_SECURITY,       SECTION_FILEDEPLIST, SECTION_ACDS,\n        SECTION_VBAPROJECT,\n        SECTION_APPINFOHISTORY, //? at least before AppInfo\n        SECTION_APPINFO,        SECTION_PREVIEW,\n        SECTION_SUMMARYINFO, // sometimes this is before Preview\n        SECTION_REVHISTORY,     SECTION_OBJECTS,     SECTION_OBJFREESPACE,\n        SECTION_TEMPLATE,       SECTION_HANDLES,     SECTION_CLASSES,\n        SECTION_AUXHEADER,      SECTION_HEADER,      SECTION_SIGNATURE,\n\n        SECTION_INFO,           SECTION_SYSTEM_MAP\n      };\n\n      // not the order in the system map, but the order in the dat stream.\n      const Dwg_Section_Type stream_order[]\n          = {                  // R2004_Header\n              SECTION_UNKNOWN, // the empty section 128-256\n              SECTION_SUMMARYINFO, SECTION_PREVIEW,        SECTION_VBAPROJECT,\n              SECTION_APPINFO,     SECTION_APPINFOHISTORY, SECTION_FILEDEPLIST,\n              SECTION_ACDS,        SECTION_REVHISTORY,     SECTION_SECURITY,\n              SECTION_OBJECTS,     SECTION_OBJFREESPACE,   SECTION_TEMPLATE,\n              SECTION_HANDLES,     SECTION_CLASSES,        SECTION_AUXHEADER,\n              SECTION_HEADER,\n\n              SECTION_SIGNATURE, //?\n\n              SECTION_INFO,        SECTION_SYSTEM_MAP\n            };\n\n      dwg->r2004_header.numsections = 0;\n      dwg->r2004_header.numgaps = 0;\n\n      //sec_dat[SECTION_UNKNOWN].byte = 0;\n      sec_dat[SECTION_INFO].byte = 10\n                                   + (dwg->header.section_infohdr.num_desc\n                                      * sizeof (Dwg_Section_Info));\n      // only a guess, reserve at least one page\n      sec_dat[SECTION_SYSTEM_MAP].byte = (4 * 20 * sizeof (Dwg_Section));\n\n      section_address = 0x100;\n      // first all the data pages, than a number gap of 1, and last the two\n      // system page maps, info and system_map the data_pages (system_map\n      // sections) can include multiple pages of the same type.\n      LOG_TRACE (\"\\n=== Section map and info page sizes ===\\n\");\n      for (si = 0, info_id = 0, type = 0; type <= SECTION_SYSTEM_MAP;\n           type++, i++)\n        {\n          if (sec_dat[type].byte)\n            {\n              const unsigned int max_decomp_size\n                  = section_max_decomp_size (dwg, type);\n              const char *name = dwg_section_name (dwg, type);\n              Dwg_Section_Info *info;\n              if (sec_dat[type].bit)\n                {\n                  LOG_WARN (\"Unpadded section %d\", type);\n                  sec_dat[type].byte++;\n                }\n              ssize = (int)sec_dat[type].byte;\n              sec_dat[type].size = ssize;\n              if (info_id >= (int)dwg->header.section_infohdr.num_desc)\n                {\n                  dwg->header.section_infohdr.num_desc = info_id + 1;\n                  dwg->header.section_info\n                      = realloc (dwg->header.section_info,\n                                 (info_id + 1) * sizeof (Dwg_Section));\n                }\n              info = &dwg->header.section_info[info_id];\n              info->fixedtype = type;\n              info->type = type;\n              info->unknown = 1;\n              if (name && si && type < SECTION_INFO) // not UNKNOWN and the last two\n                strcpy (info->name, name);\n              else\n                memset (info->name, 0, 64);\n              info->size = ssize;\n              info->max_decomp_size = max_decomp_size;\n              info->encrypted = section_encrypted (dwg, type);\n              info->compressed = 1 + section_compressed (dwg, type);\n#ifndef HAVE_COMPRESS_R2004_SECTION\n              info->compressed = 1;\n#endif\n              // pre-calc num_sections for both\n              if ((unsigned)ssize <= max_decomp_size)\n                info->num_sections = 1;\n              else\n                {\n                  info->num_sections = (unsigned)ssize / max_decomp_size;\n                  if ((unsigned)ssize % max_decomp_size)\n                    info->num_sections++;\n                }\n              info->sections\n                  = calloc (info->num_sections, sizeof (Dwg_Section*));\n              // enough sections?\n              if (si + info->num_sections > dwg->header.num_sections)\n                {\n                  Dwg_Section *oldsecs = dwg->header.section;\n                  dwg->header.num_sections = si + info->num_sections;\n                  dwg->header.section = realloc (dwg->header.section,\n                                                 dwg->header.num_sections\n                                                     * sizeof (Dwg_Section));\n                  if (dwg->header.section != oldsecs)\n                    // need to rebuild all info->sections\n                    section_info_rebuild (dwg, type);\n                }\n              {\n                int ssi = 0;\n                do\n                  {\n                    Dwg_Section *sec = &dwg->header.section[si];\n                    total_size += ssize;\n                    sec->number = si + 1; // index starting at 1\n                    sec->size = MIN (max_decomp_size, (unsigned)ssize);\n                    sec->decomp_data_size = sec->size;\n                    sec->type = type;\n                    sec->compression_type = info->compressed;\n                    info->sections[ssi] = sec;\n                    LOG_TRACE (\"section[%d] %s[%d].sections[%d]: number=%d \"\n                               \"size=%d\\n\", si,\n                               dwg_section_name (dwg, type), info_id, ssi,\n                               sec->number, (int)sec->size);\n                    ssize -= max_decomp_size;\n                    ssi++; // info->sections index\n                    si++;  // section index\n                  }\n                while (ssize > (int)max_decomp_size); // keep same type\n              }\n              info_id++;\n            }\n          else\n            LOG_TRACE (\"section_info %s is empty, skipped. size=0\\n\",\n                       dwg_section_name (dwg, type));\n        }\n      dwg->r2004_header.numsections = si;\n      // section_info [27] and section_map [28] as two last already added.\n      if ((unsigned)si > dwg->header.num_sections) // needed?\n        {\n          Dwg_Section *oldsecs = dwg->header.section;\n          dwg->header.num_sections = si;\n          dwg->header.section = realloc (dwg->header.section, si * sizeof (Dwg_Section));\n          if (dwg->header.section != oldsecs)\n            section_info_rebuild (dwg, SECTION_SYSTEM_MAP);\n        }\n      dwg->r2004_header.section_info_id = dwg->r2004_header.numsections + 1; // a gap of 3\n      dwg->r2004_header.section_map_id = dwg->r2004_header.numsections + 2;\n      dwg->r2004_header.section_array_size = dwg->r2004_header.numsections + 2;\n      dwg->r2004_header.last_section_id = dwg->r2004_header.section_map_id;\n      dwg->header.section[si - 2].number = dwg->r2004_header.section_info_id; \n      dwg->header.section[si - 1].number = dwg->r2004_header.section_map_id;\n\n      LOG_TRACE (\"\\n=== Section Info %d in map order ===\\n\",\n                 dwg->r2004_header.section_info_id);\n      // write into sec_dat[type] first, then compress\n      sec_id = SECTION_INFO;\n      sec_dat[sec_id].size = sec_dat[sec_id].byte;\n      bit_chain_alloc (&sec_dat[sec_id]);\n      dat = &sec_dat[sec_id];\n      bit_chain_set_version (dat, old_dat);\n      bit_set_position (dat, 0); // so far we faked the content. now write it\n\n      {\n        Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;\n        Dwg_Section *sec = &dwg->header.section[si - 2];\n        Dwg_Section_Info *info = find_section_info_type (dwg, sec_id);\n        // index starting at 1\n        sec->number = dwg->r2004_header.section_info_id;\n        sec->size = MIN (0x7400, sec->size);\n        sec->decomp_data_size = sec->size;\n        sec->type = type;\n        if (info)\n          {\n            sec->compression_type = info->compressed;\n            // very unlikely, more than 1 page\n            info->sections[0] = sec;\n          }\n        if (_obj->compressed == 2 && sec->size <= MIN_COMPRESSED_SECTION)\n          _obj->compressed = 1;\n#ifndef HAVE_COMPRESS_R2004_SECTION\n        _obj->compressed = 1;\n#endif\n        LOG_HANDLE (\"InfoHdr @%lu.0\\n\", dat->byte);\n        FIELD_RL (num_desc, 0);\n        FIELD_RL (compressed, 0);\n        FIELD_RL (max_size, 0);\n        FIELD_RL (encrypted, 0);\n        FIELD_RL (num_desc2, 0);\n      }\n      for (i = 0; i < ARRAY_SIZE (section_map_order); i++)\n        {\n          Dwg_Section_Info *_obj;\n          type = section_map_order[i];\n          _obj = find_section_info_type (dwg, type);\n          if (_obj)\n            {\n              assert (type == _obj->fixedtype);\n              LOG_TRACE (\"\\nSection_Info %s [%d]\\n\",\n                         dwg_section_name (dwg, type), i);\n              FIELD_RLLu (size, 0);\n              FIELD_RL (num_sections, 0);\n              FIELD_RL (max_decomp_size, 0);\n              FIELD_RL (unknown, 0);\n              FIELD_RL (compressed, 0);\n              FIELD_RL (type, 0);\n              FIELD_RL (encrypted, 0);\n              bit_write_TF (dat, (unsigned char *)_obj->name, 64);\n              LOG_TRACE (\"name: %s\\n\", *_obj->name ? _obj->name : \"\");\n            }\n        }\n\n      LOG_TRACE (\"\\n=== Section System Map %d in map order ===\\n\",\n                 dwg->r2004_header.section_map_id);\n      sec_id = type = SECTION_SYSTEM_MAP;\n      {\n        //Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;\n        Dwg_Section *sec = &dwg->header.section[si - 1];\n        Dwg_Section_Info *info = find_section_info_type (dwg, type);\n        if (!info || !info->sections)\n          {\n            LOG_ERROR (\"SECTION_SYSTEM_MAP not found\");\n            return DWG_ERR_SECTIONNOTFOUND;\n          }\n\n        sec_dat[sec_id].size = sec_dat[sec_id].byte;\n        bit_chain_alloc (&sec_dat[sec_id]);\n        str_dat = hdl_dat = dat = &sec_dat[sec_id];\n        bit_chain_set_version (dat, old_dat);\n        bit_set_position (dat, 0); // so far we faked the content. now write it\n\n        // index starting at 1\n        sec->number = dwg->r2004_header.section_map_id;\n        sec->size = MIN (0x7400, sec->size);\n        sec->decomp_data_size = sec->size;\n        sec->type = type;\n        sec->compression_type = info->compressed;\n        // very unlikely, more than 1 page\n        info->sections[0] = sec;\n      }\n      \n      address = 0x100;\n      for (i = 0; i < dwg->header.num_sections; i++)\n        {\n          Dwg_Section *_obj = &dwg->header.section[i];\n\n          FIELD_RL (number, 0);\n          FIELD_RL (size, 0);\n          _obj->address = address;\n          FIELD_RLL (address, 0);\n          address += _obj->size;\n          if (_obj->number < 0) // gap. unused. we deleted all gaps\n            {\n              FIELD_RL (parent, 0);\n              FIELD_RL (left, 0);\n              FIELD_RL (right, 0);\n              FIELD_RL (x00, 0);\n            }\n        }\n      dwg->r2004_header.decomp_data_size = dat->byte; // system_map_size\n      LOG_TRACE (\"-size: %lu\\n\", dat->byte);\n\n      dat = old_dat;\n#ifndef NDEBUG\n      if (dwg->header.version >= R_1_2)\n        {\n          if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')\n            {\n              LOG_ERROR (\"Encode overwrite pos 0\");\n              return DWG_ERR_INVALIDDWG;\n            }\n          assert (dat->chain[0] == 'A');\n          assert (dat->chain[1] == 'C');\n          assert (dat->byte <= 0x100);\n        }\n#endif\n\n      // now write all the sections in the stream order\n      LOG_TRACE (\"\\n=== Write sections in stream order ===\\n\");\n      size = total_size\n             + (8 * ((dwg->r2004_header.numsections + 2) * 24)); // no gaps\n      dat->byte = section_address;\n      if (dat->byte + size >= dat->size)\n        {\n          dat->size = dat->byte + size;\n          bit_chain_alloc (dat);\n        }\n      LOG_HANDLE (\"@%lu.0\\n\", dat->byte);\n      for (i = 0; i < ARRAY_SIZE (stream_order); i++)\n        {\n          Dwg_Section_Info *info;\n          type = stream_order[i];\n          info = find_section_info_type (dwg, type);\n          if (info)\n            {\n              LOG_TRACE (\"Write %s pages @%lu (%u/%lu)\\n\",\n                         dwg_section_name (dwg, type), dat->byte,\n                         info->num_sections, sec_dat[type].size);\n              for (unsigned k = 0; k < info->num_sections; k++)\n                {\n                  Dwg_Section *sec = info->sections[k];\n                  if (!sec)\n                    {\n                      LOG_ERROR (\"empty info->sections[%u]\", k);\n                      continue;\n                    }\n                  if (!sec_dat[type].chain)\n                    {\n                      LOG_ERROR (\"empty %s.chain\", dwg_section_name (dwg, type));\n                      continue;\n                    }\n#ifndef NDEBUG\n                  if (info->fixedtype < SECTION_INFO)\n                    assert (info->fixedtype == sec->type);\n#endif\n                  if (info->fixedtype == SECTION_SUMMARYINFO)\n                    dwg->header.summaryinfo_address = dat->byte;\n                  else if (info->fixedtype == SECTION_PREVIEW)\n                    dwg->header.thumbnail_address = dat->byte;\n                  else if (info->fixedtype == SECTION_VBAPROJECT)\n                    dwg->header.vbaproj_address = dat->byte;\n                  else if (info->fixedtype == SECTION_SYSTEM_MAP)\n                    {\n                      dwg->r2004_header.section_map_address = dat->byte - 0x100;\n                      dwg->r2004_header.last_section_address = dat->byte + sec->size - 0x100;\n                      dwg->r2004_header.second_header_address = 0; // TODO\n                    }\n                  sec->address = dat->byte;\n\n                  if (info->encrypted)\n                    {\n                      BITCODE_RC *decr = calloc (sec->size, 1);\n                      LOG_HANDLE (\"Encrypt %s (%u/%d)\\n\", info->name, k,\n                                  sec->size);\n                      decrypt_R2004_header (decr, sec_dat[type].chain,\n                                            sec->size);\n                      free (sec_dat[type].chain);\n                      sec_dat[type].chain = decr;\n                    }\n                  assert (sec->size <= MIN_COMPRESSED_SECTION ? info->compressed == 1 : 1);\n                  if (info->compressed == 2)\n                    {\n                      LOG_HANDLE (\"Compress %s (%u/%d)\\n\", info->name, k,\n                                  sec->size);\n                      compress_R2004_section (dat, sec_dat[type].chain,\n                                              sec->size, &sec->comp_data_size);\n                      LOG_TRACE (\"sec->comp_data_size: \" FORMAT_RL \"\\n\", sec->comp_data_size);\n                    }\n                  else\n                    {\n                      LOG_HANDLE (\"Copy uncompressed %s (%u/%d)\\n\", info->name,\n                                  k, sec->size);\n                      copy_R2004_section (dat, sec_dat[type].chain, sec->size,\n                                          &sec->comp_data_size);\n                    }\n                }\n              bit_chain_free (&sec_dat[type]);\n            }\n        }\n    }\n\n    {\n      Dwg_R2004_Header *_obj = &dwg->r2004_header;\n      Bit_Chain file_dat = { NULL, sizeof (Dwg_R2004_Header), 0UL, 0, 0, 0, 0, NULL };\n      Bit_Chain *orig_dat = dat;\n      /* \"AcFssFcAJMB\" encrypted: 6840F8F7922AB5EF18DD0BF1 */\n      const unsigned char enc_file_ID_string[]\n          = { '\\x68', '\\x40', '\\xF8', '\\xF7', '\\x92', '\\x2A',\n              '\\xB5', '\\xEF', '\\x18', '\\xDD', '\\x0B', '\\xF1' };\n      uint32_t checksum;\n\n      file_dat.chain = calloc (1, sizeof (Dwg_R2004_Header));\n      dat = &file_dat;\n      LOG_TRACE (\"\\nSection R2004_Header @0x100\\n\");\n\n      checksum = _obj->crc32;\n      LOG_HANDLE (\"old crc32: 0x%x\\n\", _obj->crc32);\n      _obj->crc32 = 0;\n      // recalc the CRC32, without the padding, but the crc32 as 0\n      _obj->crc32\n          = bit_calc_CRC32 (0, (unsigned char *)&dwg->r2004_header, 0x6c);\n      LOG_HANDLE (\"calc crc32: 0x%x\\n\", _obj->crc32);\n\n      // clang-format off\n      #include \"r2004_file_header.spec\"\n      // clang-format on\n\n      // go back and encrypt it\n      dat = orig_dat;\n      decrypt_R2004_header (&dat->chain[0x80], file_dat.chain,\n                            sizeof (Dwg_R2004_Header));\n      bit_chain_free (&file_dat);\n      LOG_HANDLE (\"encrypted R2004_Header:\\n\");\n      LOG_TF (HANDLE, &dat->chain[0x80], (int)sizeof (Dwg_R2004_Header));\n      if (memcmp (&dat->chain[0x80], enc_file_ID_string,\n                  sizeof (enc_file_ID_string)))\n        {\n          LOG_ERROR (\"r2004_file_header encryption error\");\n          return error | DWG_ERR_INVALIDDWG;\n        }\n    } // R2004_Header\n  } // R_2004\n\n  assert (!dat->bit);\n  dat->size = dat->byte;\n  LOG_INFO (\"\\nFinal DWG size: %u\\n\", (unsigned)dat->size);\n\n  UNTIL (R_2000)\n  {\n    /* Patch section addresses\n     */\n    assert (section_address);\n    dat->byte = section_address;\n    dat->bit = 0;\n    LOG_INFO (\"\\n=======> section addresses: %4u\\n\", (unsigned)dat->byte);\n    for (j = 0; j < dwg->header.num_sections; j++)\n      {\n        LOG_TRACE (\"section[%u].number: %4d [RC] %s\\n\", j,\n                   (int)dwg->header.section[j].number,\n                   j < 6 ? dwg_section_name (dwg, j) : \"\");\n        LOG_TRACE (\"section[%u].offset: %4u [RL]\\n\", j,\n                   (unsigned)dwg->header.section[j].address);\n        LOG_TRACE (\"section[%u].size:   %4u [RL]\\n\", j,\n                   (int)dwg->header.section[j].size);\n        if ((unsigned long)dwg->header.section[j].address\n                + dwg->header.section[j].size\n            > dat->size)\n          {\n            if (is_section_r13_critical (j))\n              {\n                LOG_ERROR (\"section[%u] %s address or size overflow\", j,\n                           j < 6 ? dwg_section_name (dwg, j) : \"\");\n                return DWG_ERR_INVALIDDWG;\n              }\n            else\n              {\n                LOG_WARN (\"section[%u] %s address or size overflow, skipped\",\n                          j, j < 6 ? dwg_section_name (dwg, j) : \"\");\n                dwg->header.section[j].address = 0;\n                dwg->header.section[j].size = 0;\n              }\n          }\n        bit_write_RC (dat, dwg->header.section[j].number);\n        bit_write_RL (dat, dwg->header.section[j].address);\n        bit_write_RL (dat, dwg->header.section[j].size);\n      }\n\n    /* Write CRC's\n     */\n    bit_write_CRC (dat, 0, 0);\n    dat->byte -= 2;\n    ckr = bit_read_CRC (dat);\n    dat->byte -= 2;\n    // FIXME: r13-2000 only\n    switch (dwg->header.num_sections)\n      {\n      case 3:\n        ckr ^= 0xA598;\n        break;\n      case 4:\n        ckr ^= 0x8101;\n        break;\n      case 5:\n        ckr ^= 0x3CC4;\n        break;\n      case 6:\n        ckr ^= 0x8461;\n        break;\n      default:\n        break;\n      }\n    bit_write_RS (dat, ckr);\n    LOG_TRACE (\"crc: %04X (from 0)\\n\", ckr);\n  }\n\n  return 0;\n  }\n  AFL_GCC_POP\n\n  static int encode_preR13 (Dwg_Data * restrict dwg, Bit_Chain * restrict dat)\n  {\n    return DWG_ERR_NOTYETSUPPORTED;\n  }\n\n#include \"dwg.spec\"\n\n// expand aliases: name => CLASSES.dxfname\nstatic const char *\ndxf_encode_alias (char *restrict name)\n{\n  if (strEQc (name, \"DICTIONARYWDFLT\"))\n    return \"ACDBDICTIONARYWDFLT\";\n  else if (strEQc (name, \"SECTIONVIEWSTYLE\"))\n    return \"ACDBSECTIONVIEWSTYLE\";\n  else if (strEQc (name, \"PLACEHOLDER\"))\n    return \"ACDBPLACEHOLDER\";\n  else if (strEQc (name, \"DETAILVIEWSTYLE\"))\n    return \"ACDBDETAILVIEWSTYLE\";\n  else if (strEQc (name, \"ASSOCPERSSUBENTMANAGER\"))\n    return \"ACDBASSOCPERSSUBENTMANAGER\";\n  else if (strEQc (name, \"EVALUATION_GRAPH\"))\n    return \"ACAD_EVALUATION_GRAPH\";\n  else if (strEQc (name, \"ASSOCACTION\"))\n    return \"ACDBASSOCACTION\";\n  else if (strEQc (name, \"ASSOCALIGNEDDIMACTIONBODY\"))\n    return \"ACDBASSOCALIGNEDDIMACTIONBODY\";\n  else if (strEQc (name, \"ASSOCOSNAPPOINTREFACTIONPARAM\"))\n    return \"ACDBASSOCOSNAPPOINTREFACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCVERTEXACTIONPARAM\"))\n    return \"ACDBASSOCVERTEXACTIONPARAM\";\n  else if (strEQc (name, \"ASSOCGEOMDEPENDENCY\"))\n    return \"ACDBASSOCGEOMDEPENDENCY\";\n  else if (strEQc (name, \"ASSOCDEPENDENCY\"))\n    return \"ACDBASSOCDEPENDENCY\";\n  else if (strEQc (name, \"TABLE\"))\n    return \"ACAD_TABLE\";\n  else\n    return NULL;\n}\n\nDwg_Class *\ndwg_encode_get_class (Dwg_Data *dwg, Dwg_Object *obj)\n{\n  int i;\n  Dwg_Class *klass = NULL;\n  if (!dwg || !dwg->dwg_class)\n    return NULL;\n  // indxf has a different class order\n  if (obj->dxfname) // search class by name, not offset\n    {\n      int invalid_klass = 0;\n      for (i = 0; i < dwg->num_classes; i++)\n        {\n          klass = &dwg->dwg_class[i];\n          if (!klass->dxfname)\n            {\n              invalid_klass++;\n              continue;\n            }\n          if (strEQ (obj->dxfname, klass->dxfname))\n            {\n              obj->type = 500 + i;\n              break;\n            }\n          else\n            {\n              // alias DICTIONARYWDFLT => ACDBDICTIONARYWDFLT\n              const char *alias = dxf_encode_alias (obj->dxfname);\n              if (alias && klass->dxfname && strEQ (alias, klass->dxfname))\n                {\n                  // a static string, which cannot be free'd. important for\n                  // indxf\n                  if (dwg->opts & DWG_OPTS_IN)\n                    obj->dxfname = strdup ((char *)alias);\n                  else\n                    obj->dxfname = (char *)alias;\n                  obj->type = 500 + i;\n                  break;\n                }\n              klass = NULL; // inefficient\n\n              if (invalid_klass > 2 && !(dwg->opts & DWG_OPTS_IN))\n                goto search_by_index;\n            }\n        }\n    }\n  else // search by index\n    {\n    search_by_index:\n      i = obj->type - 500;\n      if (i < 0 || i >= (int)dwg->num_classes)\n        {\n          LOG_WARN (\"Invalid object type %d, only %u classes\", obj->type,\n                    dwg->num_classes);\n          return NULL;\n        }\n\n      klass = &dwg->dwg_class[i];\n      if (!klass->dxfname)\n        return NULL;\n      obj->dxfname = klass->dxfname;\n    }\n  return klass;\n}\n\n/** dwg_encode_variable_type\n * Encode object by class name, not type. if type > 500.\n * Returns 0 on success, else some Dwg_Error.\n */\nstatic int\ndwg_encode_variable_type (Dwg_Data *restrict dwg, Bit_Chain *restrict dat,\n                          Dwg_Object *restrict obj)\n{\n  //int error = 0;\n  int is_entity;\n  Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n\n  if (!klass)\n    return DWG_ERR_INVALIDTYPE;\n  is_entity = dwg_class_is_entity (klass);\n  // check if it really was an entity\n  if ((is_entity && obj->supertype == DWG_SUPERTYPE_OBJECT)\n      || (!is_entity && obj->supertype == DWG_SUPERTYPE_ENTITY))\n    {\n      if (is_dwg_object (obj->name))\n        {\n          if (is_entity)\n            {\n              LOG_INFO (\"Fixup Class %s item_class_id to %s for %s\\n\",\n                        klass->dxfname, \"OBJECT\", obj->name);\n              klass->item_class_id = 0x1f2;\n              if (!klass->dxfname || strNE (klass->dxfname, obj->dxfname))\n                {\n                  free (klass->dxfname);\n                  klass->dxfname = strdup (obj->dxfname);\n                }\n              is_entity = 0;\n            }\n          else\n            {\n              LOG_INFO (\"Fixup %s.supertype to %s\\n\", obj->name, \"OBJECT\");\n              obj->supertype = DWG_SUPERTYPE_OBJECT;\n            }\n        }\n      else if (is_dwg_entity (obj->name))\n        {\n          if (!is_entity)\n            {\n              LOG_INFO (\"Fixup Class %s item_class_id to %s for %s\\n\",\n                        klass->dxfname, \"ENTITY\", obj->name);\n              klass->item_class_id = 0x1f3;\n              if (!klass->dxfname || strNE (klass->dxfname, obj->dxfname))\n                {\n                  free (klass->dxfname);\n                  klass->dxfname = strdup (obj->dxfname);\n                }\n              is_entity = 1;\n            }\n          else\n            {\n              LOG_INFO (\"Fixup %s.supertype to %s\", obj->name, \"ENTITY\");\n              obj->supertype = DWG_SUPERTYPE_ENTITY;\n            }\n        }\n      else\n        {\n          LOG_ERROR (\"Illegal Class %s is_%s item_class_id for %s\",\n                     klass->dxfname, is_entity ? \"entity\" : \"object\",\n                     obj->name);\n          return DWG_ERR_INVALIDTYPE;\n        }\n    }\n\n  if (dwg->opts & DWG_OPTS_IN) // DXF or JSON import\n    {\n      unsigned long pos = bit_position (dat);\n\n      /* Should not be triggered. Only when undef ENCODE_UNKNOWN_AS_DUMMY */\n      if (is_type_unstable (obj->fixedtype) &&\n          (obj->fixedtype == DWG_TYPE_WIPEOUT ||\n           obj->fixedtype == DWG_TYPE_TABLEGEOMETRY))\n        {\n          LOG_WARN (\"Skip broken %s\", obj->name); // acad crashes still\n          obj->type = is_entity ? DWG_TYPE_UNKNOWN_ENT : DWG_TYPE_PLACEHOLDER;\n          klass->dxfname = strdup (is_entity ? \"UNKNOWN_ENT\" : \"UNKNOWN_OBJ\");\n        }\n      dat->byte = obj->address;\n      dat->bit = 0;\n      LOG_TRACE (\"fixup Type: %d [BS] @%lu\\n\", obj->type, obj->address);\n      bit_write_BS (dat, obj->type); // fixup wrong type\n      bit_set_position (dat, pos);\n    }\n\n  // clang-format off\n  #include \"classes.inc\"\n  // clang-format on\n\n  LOG_WARN (\"Unknown Class %s %d %s (0x%x%s)\", is_entity ? \"entity\" : \"object\",\n            klass->number, klass->dxfname, klass->proxyflag,\n            klass->is_zombie ? \"is_zombie\" : \"\")\n\n#undef WARN_UNHANDLED_CLASS\n#undef WARN_UNSTABLE_CLASS\n\n  return DWG_ERR_UNHANDLEDCLASS;\n}\n\nint\ndwg_encode_add_object (Dwg_Object *restrict obj, Bit_Chain *restrict dat,\n                       unsigned long address)\n{\n  int error = 0;\n  //unsigned long oldpos;\n  unsigned long end_address = address + obj->size;\n  Dwg_Data *dwg = obj->parent;\n\n  //oldpos = bit_position (dat);\n  PRE (R_2004)\n    {\n      if (!address)\n        return DWG_ERR_INVALIDDWG;\n      assert (address);\n    }\n  dat->byte = address;\n  dat->bit = 0;\n\n  LOG_INFO (\"Object number: %lu\", (unsigned long)obj->index);\n  if (obj->size > 0x100000)\n    {\n      LOG_ERROR (\"Object size %u overflow\", obj->size);\n      return DWG_ERR_VALUEOUTOFBOUNDS;\n    }\n  while (dat->byte + obj->size >= dat->size)\n    bit_chain_alloc (dat);\n\n  // First write an aproximate size here.\n  // Then calculate size from the fields. Either <0x7fff or more.\n  // Patch it afterwards and check old<>new size if enough space allocated.\n  bit_write_MS (dat, obj->size);\n  obj->address = dat->byte;\n  PRE (R_2010)\n  {\n    bit_write_BS (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Type: %d [BS], Address: %lu\\n\", obj->size, obj->type, obj->address)\n  }\n  LATER_VERSIONS\n  {\n    if (!obj->handlestream_size && obj->bitsize)\n      obj->handlestream_size = obj->size * 8 - obj->bitsize;\n    bit_write_UMC (dat, obj->handlestream_size);\n    obj->address = dat->byte;\n    bit_write_BOT (dat, obj->type);\n    LOG_INFO (\", Size: %d [MS], Hdlsize: %lu [UMC], Type: %d [BOT], Address: %lu\\n\",\n              obj->size, (unsigned long)obj->handlestream_size, obj->type, obj->address)\n  }\n\n  /* Write the specific type to dat */\n  switch (obj->type)\n    {\n    case DWG_TYPE_TEXT:\n      error = dwg_encode_TEXT (dat, obj);\n      break;\n    case DWG_TYPE_ATTRIB:\n      error = dwg_encode_ATTRIB (dat, obj);\n      break;\n    case DWG_TYPE_ATTDEF:\n      error = dwg_encode_ATTDEF (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK:\n      error = dwg_encode_BLOCK (dat, obj);\n      break;\n    case DWG_TYPE_ENDBLK:\n      error = dwg_encode_ENDBLK (dat, obj);\n      break;\n    case DWG_TYPE_SEQEND:\n      error = dwg_encode_SEQEND (dat, obj);\n      break;\n    case DWG_TYPE_INSERT:\n      error = dwg_encode_INSERT (dat, obj);\n      break;\n    case DWG_TYPE_MINSERT:\n      error = dwg_encode_MINSERT (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_2D:\n      error = dwg_encode_VERTEX_2D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_3D:\n      error = dwg_encode_VERTEX_3D (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_MESH:\n      error = dwg_encode_VERTEX_MESH (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE:\n      error = dwg_encode_VERTEX_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_VERTEX_PFACE_FACE:\n      error = dwg_encode_VERTEX_PFACE_FACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_2D:\n      error = dwg_encode_POLYLINE_2D (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_3D:\n      error = dwg_encode_POLYLINE_3D (dat, obj);\n      break;\n    case DWG_TYPE_ARC:\n      error = dwg_encode_ARC (dat, obj);\n      break;\n    case DWG_TYPE_CIRCLE:\n      error = dwg_encode_CIRCLE (dat, obj);\n      break;\n    case DWG_TYPE_LINE:\n      error = dwg_encode_LINE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ORDINATE:\n      error = dwg_encode_DIMENSION_ORDINATE (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_LINEAR:\n      error = dwg_encode_DIMENSION_LINEAR (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ALIGNED:\n      error = dwg_encode_DIMENSION_ALIGNED (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG3PT:\n      error = dwg_encode_DIMENSION_ANG3PT (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_ANG2LN:\n      error = dwg_encode_DIMENSION_ANG2LN (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_RADIUS:\n      error = dwg_encode_DIMENSION_RADIUS (dat, obj);\n      break;\n    case DWG_TYPE_DIMENSION_DIAMETER:\n      error = dwg_encode_DIMENSION_DIAMETER (dat, obj);\n      break;\n    case DWG_TYPE_POINT:\n      error = dwg_encode_POINT (dat, obj);\n      break;\n    case DWG_TYPE__3DFACE:\n      error = dwg_encode__3DFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_PFACE:\n      error = dwg_encode_POLYLINE_PFACE (dat, obj);\n      break;\n    case DWG_TYPE_POLYLINE_MESH:\n      error = dwg_encode_POLYLINE_MESH (dat, obj);\n      break;\n    case DWG_TYPE_SOLID:\n      error = dwg_encode_SOLID (dat, obj);\n      break;\n    case DWG_TYPE_TRACE:\n      error = dwg_encode_TRACE (dat, obj);\n      break;\n    case DWG_TYPE_SHAPE:\n      error = dwg_encode_SHAPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEWPORT:\n      error = dwg_encode_VIEWPORT (dat, obj);\n      break;\n    case DWG_TYPE_ELLIPSE:\n      error = dwg_encode_ELLIPSE (dat, obj);\n      break;\n    case DWG_TYPE_SPLINE:\n      error = dwg_encode_SPLINE (dat, obj);\n      break;\n    case DWG_TYPE_REGION:\n      error = dwg_encode_REGION (dat, obj);\n      break;\n    case DWG_TYPE__3DSOLID:\n      error = dwg_encode__3DSOLID (dat, obj);\n      break;\n    case DWG_TYPE_BODY:\n      error = dwg_encode_BODY (dat, obj);\n      break;\n    case DWG_TYPE_RAY:\n      error = dwg_encode_RAY (dat, obj);\n      break;\n    case DWG_TYPE_XLINE:\n      error = dwg_encode_XLINE (dat, obj);\n      break;\n    case DWG_TYPE_DICTIONARY:\n      error = dwg_encode_DICTIONARY (dat, obj);\n      break;\n    case DWG_TYPE_MTEXT:\n      error = dwg_encode_MTEXT (dat, obj);\n      break;\n    case DWG_TYPE_LEADER:\n      error = dwg_encode_LEADER (dat, obj);\n      break;\n    case DWG_TYPE_TOLERANCE:\n      error = dwg_encode_TOLERANCE (dat, obj);\n      break;\n    case DWG_TYPE_MLINE:\n      error = dwg_encode_MLINE (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_CONTROL:\n      error = dwg_encode_BLOCK_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_BLOCK_HEADER:\n      error = dwg_encode_BLOCK_HEADER (dat, obj);\n      break;\n    case DWG_TYPE_LAYER_CONTROL:\n      error = dwg_encode_LAYER_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LAYER:\n      error = dwg_encode_LAYER (dat, obj);\n      break;\n    case DWG_TYPE_STYLE_CONTROL:\n      error = dwg_encode_STYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_STYLE:\n      error = dwg_encode_STYLE (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE_CONTROL:\n      error = dwg_encode_LTYPE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_LTYPE:\n      error = dwg_encode_LTYPE (dat, obj);\n      break;\n    case DWG_TYPE_VIEW_CONTROL:\n      error = dwg_encode_VIEW_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VIEW:\n      error = dwg_encode_VIEW (dat, obj);\n      break;\n    case DWG_TYPE_UCS_CONTROL:\n      error = dwg_encode_UCS_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_UCS:\n      error = dwg_encode_UCS (dat, obj);\n      break;\n    case DWG_TYPE_VPORT_CONTROL:\n      error = dwg_encode_VPORT_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VPORT:\n      error = dwg_encode_VPORT (dat, obj);\n      break;\n    case DWG_TYPE_APPID_CONTROL:\n      error = dwg_encode_APPID_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_APPID:\n      error = dwg_encode_APPID (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE_CONTROL:\n      error = dwg_encode_DIMSTYLE_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_DIMSTYLE:\n      error = dwg_encode_DIMSTYLE (dat, obj);\n      break;\n    case DWG_TYPE_VX_CONTROL:\n      error = dwg_encode_VX_CONTROL (dat, obj);\n      break;\n    case DWG_TYPE_VX_TABLE_RECORD:\n      error = dwg_encode_VX_TABLE_RECORD (dat, obj);\n      break;\n    case DWG_TYPE_GROUP:\n      error = dwg_encode_GROUP (dat, obj);\n      break;\n    case DWG_TYPE_MLINESTYLE:\n      error = dwg_encode_MLINESTYLE (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_OLE2FRAME:\n      error = dwg_encode_OLE2FRAME (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_DUMMY:\n      error = dwg_encode_DUMMY (dat, obj);\n      break;\n    case DWG_TYPE_LONG_TRANSACTION:\n      error = dwg_encode_LONG_TRANSACTION (dat, obj);\n      break;\n    case DWG_TYPE_LWPOLYLINE:\n      error = dwg_encode_LWPOLYLINE (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_HATCH:\n      error = dwg_encode_HATCH (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_XRECORD:\n      error = dwg_encode_XRECORD (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_PLACEHOLDER:\n      error = dwg_encode_PLACEHOLDER (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_OLEFRAME:\n      error = dwg_encode_OLEFRAME (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_VBA_PROJECT:\n      //LOG_ERROR (\"Unhandled Object VBA_PROJECT. Has its own AcDb::VBAProject section\");\n      error = dwg_encode_VBA_PROJECT (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_LAYOUT:\n      error |= dwg_encode_LAYOUT (dat, obj);\n      (void)dwg_encode_get_class (dwg, obj);\n      break;\n    case DWG_TYPE_PROXY_ENTITY:\n      error = dwg_encode_PROXY_ENTITY (dat, obj);\n      break;\n    case DWG_TYPE_PROXY_OBJECT:\n      error = dwg_encode_PROXY_OBJECT (dat, obj);\n      break;\n    default:\n      if (dwg && obj->type == dwg->layout_type\n          && obj->fixedtype == DWG_TYPE_LAYOUT)\n        {\n          error = dwg_encode_LAYOUT (dat, obj);\n          (void)dwg_encode_get_class (dwg, obj);\n        }\n      else if (dwg != NULL\n               && (error = dwg_encode_variable_type (dwg, dat, obj))\n                      & DWG_ERR_UNHANDLEDCLASS)\n        {\n          int is_entity;\n          Dwg_Class *klass = dwg_encode_get_class (dwg, obj);\n          if (klass)\n            is_entity = klass->item_class_id == 0x1f2\n                        && obj->supertype == DWG_SUPERTYPE_ENTITY;\n          else\n            is_entity = obj->supertype == DWG_SUPERTYPE_ENTITY;\n\n          assert (address);\n          dat->byte = address; // restart and write into the UNKNOWN_OBJ object\n          dat->bit = 0;\n\n          bit_write_MS (dat, obj->size); // unknown blobs have a known size\n          if (dat->version >= R_2010)\n            {\n              bit_write_UMC (dat, obj->handlestream_size);\n              bit_write_BOT (dat, obj->type);\n            }\n          else\n            bit_write_BS (dat, obj->type);\n\n          // from json and dwg can write to these. from dxf not.\n          if (is_entity)\n            {\n              if (obj->bitsize && dwg->header.version == dwg->header.from_version)\n                obj->was_bitsize_set = 1;\n              error = dwg_encode_UNKNOWN_ENT (dat, obj);\n            }\n          else\n            {\n              // skip START_OBJECT_HANDLE_STREAM (see DWG_OBJECT_END)\n              // unknown_bits already includes that.\n              if (!obj->hdlpos)\n                {\n                  if (obj->bitsize)\n                    {\n                      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n                      if (dwg->header.version == dwg->header.from_version)\n                        obj->was_bitsize_set = 1;\n                    }\n                  else\n                    obj->hdlpos = (obj->address * 8) + obj->num_unknown_bits;\n                }\n              error = dwg_encode_UNKNOWN_OBJ (dat, obj);\n            }\n\n          if (dwg->header.version == dwg->header.from_version\n              && obj->unknown_bits && obj->num_unknown_bits) // cannot calculate\n            {\n              int len = obj->num_unknown_bits / 8;\n              const int mod = obj->num_unknown_bits % 8;\n              if (mod)\n                len++;\n              bit_write_TF (dat, obj->unknown_bits, len);\n              LOG_TRACE (\"unknown_bits: %d/%u [TF]\\n\", len, (unsigned)obj->num_unknown_bits);\n              LOG_TRACE_TF (obj->unknown_bits, len);\n              if (mod)\n                bit_advance_position (dat, mod - 8);\n              obj->was_bitsize_set = 1;\n            }\n        }\n    }\n\n  /* DXF/JSON/RW across versions: patchup size and bitsize */\n  /* Across versions size+bitsize must be recalculated.\n     Sizes are unreliable when changing versions. */\n  if (!obj->size || dwg->header.from_version != dwg->header.version\n      || obj->was_bitsize_set)\n    {\n      BITCODE_BL pos = bit_position (dat);\n      BITCODE_RL old_size = obj->size;\n      if (dwg->header.version < R_2004 || obj->index)\n        {\n          if (!address)\n            return DWG_ERR_INVALIDDWG;\n          assert (address);\n        }\n      if (dat->byte > obj->address)\n        {\n          // The size and CRC fields are not included in the obj->size\n          obj->size = dat->byte - obj->address;\n          if (dat->bit)\n            obj->size++;\n        }\n      if (dat->byte >= dat->size)\n        bit_chain_alloc (dat);\n      // assert (obj->bitsize); // on errors\n      if (!obj->bitsize ||\n          (dwg->header.from_version != dwg->header.version\n           // and not calculated from HANDLE_STREAM or via unknown_bits already\n           && !obj->was_bitsize_set))\n        {\n          LOG_TRACE (\"-bitsize calc from address (no handle) @%lu.%u\\n\",\n                     dat->byte - obj->address, dat->bit);\n          obj->bitsize = pos - (obj->address * 8);\n        }\n      bit_set_position (dat, address * 8);\n      if (obj->size > 0x7fff && old_size <= 0x7fff)\n        {\n          // with overlarge sizes >0x7fff memmove dat right by 2, one more RS added.\n          LOG_INFO (\"overlarge size %u > 0x7fff @%lu\\n\", (unsigned)obj->size, dat->byte);\n          if (dat->byte + obj->size + 2 >= dat->size)\n            bit_chain_alloc (dat);\n          memmove (&dat->chain[dat->byte + 2], &dat->chain[dat->byte], obj->size);\n          obj->size += 2;\n          obj->bitsize += 16;\n          obj->bitsize_pos += 16;\n          pos += 16;\n        }\n      if (obj->size <= 0x7fff && old_size > 0x7fff)\n        {\n          // with old overlarge sizes >0x7fff memmove dat left by 2, one RS removed.\n          LOG_INFO (\"was overlarge size %u < 0x7fff @%lu\\n\", (unsigned)old_size, dat->byte);\n          memmove (&dat->chain[dat->byte], &dat->chain[dat->byte + 2], obj->size);\n          obj->size -= 2;\n          obj->bitsize -= 16;\n          obj->bitsize_pos -= 16;\n          pos -= 16;\n        }\n      bit_write_MS (dat, obj->size);\n      LOG_TRACE (\"-size: %u [MS] @%lu\\n\", obj->size, address);\n      SINCE (R_2013)\n      {\n        if (!obj->handlestream_size && obj->bitsize)\n          obj->handlestream_size = (obj->size * 8) - obj->bitsize;\n        bit_write_UMC (dat, obj->handlestream_size);\n        LOG_TRACE (\"-handlestream_size: %lu [UMC]\\n\", obj->handlestream_size);\n      }\n      SINCE (R_2000)\n      {\n        if (obj->bitsize_pos && obj->bitsize)\n          {\n            bit_set_position (dat, obj->bitsize_pos);\n            bit_write_RL (dat, obj->bitsize);\n            LOG_TRACE (\"-bitsize: %u [RL] @%lu.%lu\\n\", obj->bitsize,\n                       obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n          }\n      }\n      bit_set_position (dat, pos);\n    }\n\n  /* Now 1 padding bits until next byte, and then a RS CRC */\n  if (dat->bit)\n    LOG_TRACE (\"padding: +%d [*B]\\n\", 8 - dat->bit)\n  while (dat->bit)\n    bit_write_B (dat, 1);\n  end_address = obj->address + obj->size;\n  if (end_address != dat->byte)\n    {\n      if (obj->size)\n        LOG_WARN (\"Wrong object size: %lu + %u = %lu != %lu: %ld off\",\n                  address, obj->size, end_address, dat->byte,\n                  (long)(end_address - dat->byte));\n      //dat->byte = end_address;\n    }\n  assert (!dat->bit);\n  bit_write_CRC (dat, address, 0xC0C1);\n  return error;\n}\n\n/** writes the data part, if there's no raw.\n */\nstatic int\ndwg_encode_eed_data (Bit_Chain *restrict dat, Dwg_Eed_Data *restrict data, const int i)\n{\n  unsigned long pos = bit_position (dat);\n  unsigned long size;\n  bit_write_RC (dat, data->code);\n  LOG_TRACE (\"EED[%d] code: %d [RC] \", i, data->code);\n  switch (data->code)\n    {\n    case 0:\n      {\n        PRE (R_2007)\n        {\n          // only if from r2007+ DWG, not JSON, DXF\n          if (data->u.eed_0.is_tu)\n            {\n              BITCODE_RS length = data->u.eed_0_r2007.length;\n              BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n              BITCODE_RS codepage = 30; //FIXME\n              char *dest;\n              if (length + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              if (length > 255)\n                {\n                  LOG_ERROR (\"eed: overlong string %d stripped\", (int)length);\n                  length = 255;\n                }\n              dest = bit_embed_TU_size (s, length);\n              bit_write_RC (dat, length);\n              bit_write_RS_LE (dat, codepage);\n              bit_write_TF (dat, (unsigned char *)dest, length);\n              LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\",\n                         length, codepage, dest);\n              free (dest);\n            }\n          else\n            {\n              if (!*data->u.eed_0.string)\n                data->u.eed_0.length = 0;\n              if (data->u.eed_0.length + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RC (dat, data->u.eed_0.length);\n              bit_write_RS_LE (dat, data->u.eed_0.codepage);\n              bit_write_TF (dat, (BITCODE_TF)data->u.eed_0.string, data->u.eed_0.length);\n              LOG_TRACE (\"string: len=%d [RC] cp=%d [RS_LE] \\\"%s\\\" [TF]\",\n                         data->u.eed_0.length, data->u.eed_0.codepage,\n                         data->u.eed_0.string);\n            }\n        }\n        LATER_VERSIONS\n        {\n          // from ASCII DWG or JSON, DXF\n          if (!data->u.eed_0.is_tu)\n            {\n              BITCODE_RS length = data->u.eed_0.length;\n              BITCODE_TU dest = bit_utf8_to_TU (data->u.eed_0.string, 0);\n              if ((length * 2) + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RS (dat, length);\n              for (int j = 0; j < length; j++)\n                bit_write_RS (dat, *dest++);\n              data->u.eed_0_r2007.length = length;\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\",\n                         (int)length, data->u.eed_0.string);\n            }\n          else\n            {\n              BITCODE_RS length = data->u.eed_0_r2007.length;\n              BITCODE_RS *s = (BITCODE_RS *)&data->u.eed_0_r2007.string;\n              if ((length * 2) + 5 + dat->byte >= dat->size)\n                bit_chain_alloc (dat);\n              bit_write_RS (dat, length);\n              for (int j = 0; j < length; j++)\n                bit_write_RS (dat, *s++);\n#ifdef _WIN32\n              LOG_TRACE (\"wstring: len=%d [RS] \\\"\" FORMAT_TU \"\\\" [TU]\",\n                         (int)data->u.eed_0_r2007.length,\n                         data->u.eed_0_r2007.string);\n#else\n              if (DWG_LOGLEVEL >= DWG_LOGLEVEL_TRACE)\n                {\n                  char *u8 = bit_TU_to_utf8_len (data->u.eed_0_r2007.string,\n                                                 data->u.eed_0_r2007.length);\n                  LOG_TRACE (\"wstring: len=%d [RS] \\\"%s\\\" [TU]\",\n                             (int)data->u.eed_0_r2007.length, u8);\n                  free (u8);\n                }\n#endif\n            }\n        }\n      }\n      break;\n    case 2:\n      bit_write_RC (dat, data->u.eed_2.close);\n      LOG_TRACE (\"close: %d [RC]\", (int)data->u.eed_2.close);\n      break;\n    case 3:\n      bit_write_RLL (dat, data->u.eed_3.layer);\n      LOG_TRACE (\"layer: 0x%lX [RLL]\", (unsigned long)data->u.eed_3.layer);\n      break;\n    case 4:\n      bit_write_RC (dat, data->u.eed_4.length);\n      bit_write_TF (dat, (BITCODE_TF)data->u.eed_4.data,\n                    data->u.eed_4.length);\n      LOG_TRACE (\"binary: \");\n      LOG_TRACE_TF (data->u.eed_4.data, data->u.eed_4.length);\n      break;\n    case 5:\n      bit_write_RLL (dat, (BITCODE_RLL)data->u.eed_5.entity);\n      LOG_TRACE (\"entity: 0x%lX [ulong]\", data->u.eed_5.entity);\n      break;\n    case 10:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      bit_write_RD (dat, data->u.eed_10.point.x);\n      bit_write_RD (dat, data->u.eed_10.point.y);\n      bit_write_RD (dat, data->u.eed_10.point.z);\n      LOG_TRACE (\"3dpoint: (%f, %f, %f) [3RD]\", data->u.eed_10.point.x,\n                 data->u.eed_10.point.y, data->u.eed_10.point.z);\n      break;\n    case 40:\n    case 41:\n    case 42:\n      bit_write_RD (dat, data->u.eed_40.real);\n      LOG_TRACE (\"real: %f [RD]\", data->u.eed_40.real);\n      break;\n    case 70:\n      bit_write_RS (dat, data->u.eed_70.rs);\n      LOG_TRACE (\"short: \" FORMAT_RS \" [RS]\", data->u.eed_70.rs);\n      break;\n    case 71:\n      bit_write_RL (dat, data->u.eed_71.rl);\n      LOG_TRACE (\"long: \" FORMAT_RL \" [RL]\", data->u.eed_71.rl);\n      break;\n    default:\n      dat->byte--;\n      LOG_ERROR (\"unknown EED code %d\", data->code);\n    }\n  size = bit_position (dat) - pos;\n  return (size % 8) ? (int)(size / 8) + 1 : (int)(size / 8);\n}\n\n#define dat_flush(orig, dat) bit_copy_chain (orig, dat)\n\n/** Either writes the raw part.\n    Only members with size have raw and a handle.\n    Otherwise (indxf) defer to dwg_encode_eed_data.\n    On does_cross_unicode_datversion skip raw, and recalc the sizes.\n */\nstatic int\ndwg_encode_eed (Bit_Chain *restrict dat, Dwg_Object *restrict obj)\n{\n  //unsigned long off = obj->address;\n  //unsigned dat_size = 0;\n  Dwg_Handle *last_handle = NULL;\n  Bit_Chain dat1 = { 0 };\n  int i, num_eed = obj->tio.object->num_eed;\n  BITCODE_BS size = 0;\n  int last_size = 0;\n  int new_size = 0;\n  int did_raw = 0;\n  int need_recalc = does_cross_unicode_datversion (dat);\n\n  bit_chain_init (&dat1, 1024);\n  dat1.from_version = dat->from_version;\n  dat1.version = dat->version;\n  dat1.opts = dat->opts;\n\n  // Skip DICTIONARY AE3 AcDsRecords/AcDsSchemas 1070 . 2, wrong ACIS version\n  if (dat->opts & DWG_OPTS_INDXF &&\n      dat->version < R_2007 &&\n      obj->fixedtype == DWG_TYPE_DICTIONARY &&\n      num_eed == 1)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[0];\n      if (eed->handle.value == 0x12 &&\n          eed->data->code == 70 &&\n          eed->data->u.eed_70.rs > 1)\n        {\n          LOG_TRACE (\"skip AcDs DICTIONARY EED to use ACIS ver 2\\n\");\n          num_eed = 0;\n        }\n    }\n\n  for (i = 0; i < num_eed; i++)\n    {\n      Dwg_Eed *eed = &obj->tio.object->eed[i];\n      if (eed->size) // start of a new EED appid section\n        {\n          size = eed->size;\n          if (eed->raw && !need_recalc)\n            {\n              did_raw = 1;\n              bit_write_BS (dat, size);\n              LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", i, size); LOG_POS\n              bit_write_H (dat, &eed->handle);\n              LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", i,\n                         ARGS_H (eed->handle)); LOG_POS\n              LOG_TRACE (\"EED[%d] raw [TF %d]\\n\", i, size);\n              bit_write_TF (dat, eed->raw, size);\n              LOG_TRACE_TF (eed->raw, size);\n              new_size = 0;\n            }\n          // indxf\n          else if (eed->data)\n            {\n              did_raw = 0;\n              if (new_size) // flush old\n                {\n\n// FIXME DXF import of ACAD EED crashes (GH #244)\n// on BLOCK_HEADER with 0 . \"DesignCenter Data\"\n#define EED_ALLOWED !(dat->opts & DWG_OPTS_INDXF) || last_handle->value != 0x12 \\\n                    || obj->fixedtype != DWG_TYPE_BLOCK_HEADER\n\n                  if (EED_ALLOWED)\n                    {\n                      eed->size = new_size;\n                      bit_write_BS (dat, new_size);\n                      LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", last_size, new_size); LOG_POS;\n                      bit_write_H (dat, last_handle);\n                      LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", last_size,\n                                 ARGS_H (*last_handle)); LOG_POS;\n                      LOG_TRACE (\"flush eed_data %lu.%d\\n\", dat1.byte, dat1.bit);\n                      dat_flush (dat, &dat1);\n                    }\n                  else\n                    {\n                      LOG_WARN (\"skip EED[%d] handle: \" FORMAT_H \" [H] for DesignCenter Data\", last_size,\n                                 ARGS_H (*last_handle)); LOG_POS;\n                      dat1.byte = 0;\n                    }\n                  new_size = 0;\n                }\n              new_size = dwg_encode_eed_data (&dat1, eed->data, i);\n              LOG_POS;\n            }\n          last_size = i;\n          last_handle = &eed->handle;\n        }\n      // and if not already written by the previous raw (this has size=0)\n      else if (!did_raw && eed->data)\n        {\n          new_size += dwg_encode_eed_data (&dat1, eed->data, i);\n          LOG_POS;\n        }\n    }\n  if (new_size && last_handle) // flush remaining rest\n    {\n      // FIXME HACK, see above\n      if (EED_ALLOWED)\n        {\n          bit_write_BS (dat, new_size);\n          LOG_TRACE (\"EED[%d] size: \" FORMAT_BS \" [BS]\", last_size, new_size); LOG_POS;\n          bit_write_H (dat, last_handle);\n          LOG_TRACE (\"EED[%d] handle: \" FORMAT_H \" [H]\", last_size,\n                     ARGS_H (*last_handle)); LOG_POS;\n          last_handle = NULL;\n        }\n      else\n        {\n          LOG_TRACE (\"skip EED[%d] handle: \" FORMAT_H \" [H] for DesignCenter Data\", last_size,\n                     ARGS_H (*last_handle)); LOG_POS;\n          dat1.byte = 0;\n        }\n    }\n  if (dat1.byte)\n    LOG_TRACE (\"flush eed_data %lu.%d\\n\", dat1.byte, dat1.bit);\n  dat_flush (dat, &dat1);\n  bit_write_BS (dat, 0);\n  if (i)\n    LOG_TRACE (\"EED[%d] size: 0 [BS] (end)\\n\", i);\n  LOG_TRACE (\"num_eed: %d\\n\", num_eed);\n  bit_chain_free (&dat1);\n  return 0;\n}\n\n/* The first common part of every entity.\n\n   The last common part is common_entity_handle_data.spec\n   which is read from the hdl stream.\n   See DWG_SUPERTYPE_ENTITY in dwg_encode().\n */\nstatic int\ndwg_encode_entity (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  Dwg_Object_Entity *ent = obj->tio.entity;\n  Dwg_Object_Entity *_obj = ent;\n  Dwg_Data *dwg = ent->dwg;\n\n  if (!obj || !dat || !ent)\n    return DWG_ERR_INVALIDDWG;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  PRE (R_13)\n  {\n\n    if (FIELD_VALUE (flag_r11) & 4 && FIELD_VALUE (kind_r11) > 2\n        && FIELD_VALUE (kind_r11) != 22)\n      FIELD_RD (elevation_r11, 30);\n    if (FIELD_VALUE (flag_r11) & 8)\n      FIELD_RD (thickness_r11, 39);\n    if (FIELD_VALUE (flag_r11) & 0x20)\n      {\n        Dwg_Object_Ref *hdl\n            = dwg_decode_handleref_with_code (dat, obj, dwg, 0);\n        if (hdl)\n          obj->handle = hdl->handleref;\n      }\n    if (FIELD_VALUE (extra_r11) & 4)\n      FIELD_RS (paper_r11, 0);\n  }\n\n  SINCE (R_2007) { *str_dat = *dat; }\n  VERSIONS (R_2000, R_2007)\n  {\n    obj->bitsize_pos = bit_position (dat);\n    bit_write_RL (dat, obj->bitsize);\n    LOG_TRACE (\"bitsize: %u [RL] (@%lu.%lu)\\n\", obj->bitsize,\n               obj->bitsize_pos / 8, obj->bitsize_pos % 8);\n  }\n  obj->was_bitsize_set = 0;\n  if (obj->bitsize)\n    {\n      obj->hdlpos = (obj->address * 8) + obj->bitsize;\n    }\n  SINCE (R_2007)\n  {\n    // The handle stream offset, i.e. end of the object, right after\n    // the has_strings bit.\n    SINCE (R_2010)\n    {\n      if (obj->bitsize)\n        {\n          obj->hdlpos += 8;\n          // LOG_HANDLE (\"(bitsize: \" FORMAT_RL \", \", obj->bitsize);\n          LOG_HANDLE (\"hdlpos: %lu\\n\", obj->hdlpos);\n        }\n    }\n    // and set the string stream (restricted to size)\n    error |= obj_string_stream (dat, obj, str_dat);\n  }\n\n  bit_write_H (dat, &obj->handle);\n  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\", ARGS_H (obj->handle))\n  LOG_INSANE (\" @%lu.%u\", dat->byte - obj->address, dat->bit)\n  LOG_TRACE (\"\\n\")\n  PRE (R_13) { return DWG_ERR_NOTYETSUPPORTED; }\n\n  error |= dwg_encode_eed (dat, obj);\n  // if (error & (DWG_ERR_INVALIDTYPE|DWG_ERR_VALUEOUTOFBOUNDS))\n  //  return error;\n\n  // clang-format off\n  #include \"common_entity_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\nstatic int\ndwg_encode_common_entity_handle_data (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                                      Dwg_Object *restrict obj)\n{\n  Dwg_Object_Entity *ent;\n  // Dwg_Data *dwg = obj->parent;\n  Dwg_Object_Entity *_obj;\n  BITCODE_BL vcount;\n  int error = 0;\n  ent = obj->tio.entity;\n  _obj = ent;\n\n  // clang-format off\n  #include \"common_entity_handle_data.spec\"\n  // clang-format on\n\n  return error;\n}\n\n\nvoid\ndwg_encode_handleref (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                      Dwg_Data *restrict dwg, Dwg_Object_Ref *restrict ref)\n{\n  // this function should receive a Object_Ref without an abs_ref, calculate it\n  // and return a Dwg_Handle this should be a higher level function not sure if\n  // the prototype is correct\n  assert (obj);\n}\n\n/**\n * code:\n *  TYPEDOBJHANDLE:\n *   2 Soft owner\n *   3 Hard owner\n *   4 Soft pointer\n *   5 Hard pointer\n *  OFFSETOBJHANDLE for soft owners or pointers:\n *   6 ref + 1\n *   8 ref - 1\n *   a ref + offset\n *   c ref - offset\n */\nvoid\ndwg_encode_handleref_with_code (Bit_Chain *hdl_dat, Dwg_Object *restrict obj,\n                                Dwg_Data *restrict dwg,\n                                Dwg_Object_Ref *restrict ref,\n                                unsigned int code)\n{\n  // XXX fixme. create the handle, then check the code. allow relative handle\n  // soft codes.\n  dwg_encode_handleref (hdl_dat, obj, dwg, ref);\n  if (ref->absolute_ref == 0 && ref->handleref.code != code)\n    {\n      /*\n       * With TYPEDOBJHANDLE 2-5 the code indicates the type of ownership.\n       * With OFFSETOBJHANDLE >5 the handle is stored as an offset from some\n       * other handle.\n       */\n      switch (ref->handleref.code)\n        {\n        case 0x06:\n          ref->absolute_ref = (obj->handle.value + 1);\n          break;\n        case 0x08:\n          ref->absolute_ref = (obj->handle.value - 1);\n          break;\n        case 0x0A:\n          ref->absolute_ref = (obj->handle.value + ref->handleref.value);\n          break;\n        case 0x0C:\n          ref->absolute_ref = (obj->handle.value - ref->handleref.value);\n          break;\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        case 0: // ignore (ANYCODE)\n          ref->absolute_ref = ref->handleref.value;\n          break;\n        default:\n          LOG_WARN (\"Invalid handle pointer code %d\", ref->handleref.code);\n          break;\n        }\n    }\n}\n\n/* The first common part of every object.\n\n   There is no COMMON_ENTITY_DATA for objects, handles are deferred and flushed later.\n   See DWG_SUPERTYPE_OBJECT in dwg_encode().\n*/\nstatic int\ndwg_encode_object (Dwg_Object *restrict obj, Bit_Chain *dat,\n                   Bit_Chain *restrict hdl_dat, Bit_Chain *str_dat)\n{\n  int error = 0;\n  BITCODE_BL vcount;\n\n  hdl_dat->from_version = dat->from_version;\n  hdl_dat->version = dat->version;\n  hdl_dat->opts = dat->opts;\n\n  {\n    Dwg_Object *_obj = obj;\n    VERSIONS (R_2000, R_2007)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n    obj->was_bitsize_set = 0;\n    if (obj->bitsize)\n      // the handle stream offset\n      obj->hdlpos = bit_position (dat) + obj->bitsize;\n    SINCE (R_2007) { obj_string_stream (dat, obj, str_dat); }\n    if (!_obj || !obj->tio.object)\n      return DWG_ERR_INVALIDDWG;\n\n    bit_write_H (dat, &obj->handle);\n    LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\", ARGS_H (obj->handle));\n    error |= dwg_encode_eed (dat, obj);\n\n    VERSIONS (R_13, R_14)\n    {\n      obj->bitsize_pos = bit_position (dat);\n      FIELD_RL (bitsize, 0);\n    }\n  }\n\n  SINCE (R_13) {\n    Dwg_Object_Object *_obj = obj->tio.object;\n    FIELD_BL (num_reactors, 0);\n    SINCE (R_2004) { FIELD_B (is_xdic_missing, 0); }\n    SINCE (R_2013) { FIELD_B (has_ds_data, 0); } // AcDs DATA\n  }\n  return error;\n}\n\nAFL_GCC_TOOBIG\nstatic int\ndwg_encode_header_variables (Bit_Chain *dat, Bit_Chain *hdl_dat,\n                             Bit_Chain *str_dat, Dwg_Data *restrict dwg)\n{\n  Dwg_Header_Variables *_obj = &dwg->header_vars;\n  Dwg_Object *obj = NULL;\n  Dwg_Version_Type old_from = dat->from_version;\n\n  if (!_obj->HANDSEED) // minimal or broken DXF\n    {\n      BITCODE_H last_hdl;\n      unsigned long seed = 0;\n      dwg->opts |= DWG_OPTS_MINIMAL;\n      dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);\n      LOG_TRACE (\"encode from minimal DXF\\n\");\n\n      _obj->HANDSEED = (Dwg_Object_Ref*)calloc (1, sizeof (Dwg_Object_Ref));\n      // check the object map for the next available handle\n      last_hdl = dwg->num_object_refs ? dwg->object_ref[ dwg->num_object_refs - 1] : NULL;\n      if (last_hdl)\n        {\n          // find the largest handle\n          seed = last_hdl->absolute_ref;\n          LOG_TRACE (\"compute HANDSEED %lu \", seed);\n          for (unsigned i = 0; i < dwg->num_object_refs; i++)\n            {\n              Dwg_Object_Ref *ref = dwg->object_ref[i];\n              if (ref->absolute_ref > seed)\n                seed = ref->absolute_ref;\n            }\n          _obj->HANDSEED->absolute_ref = seed + 1;\n          LOG_TRACE (\"-> %lu\\n\", seed);\n        }\n      else\n        _obj->HANDSEED->absolute_ref = 0x72E;\n    }\n\n    // clang-format off\n  #include \"header_variables.spec\"\n  // clang-format on\n\n  dat->from_version = old_from;\n  return 0;\n}\nAFL_GCC_POP\n\nstatic int\ndwg_encode_xdata (Bit_Chain *restrict dat, Dwg_Object_XRECORD *restrict _obj,\n                  unsigned xdata_size)\n{\n  Dwg_Resbuf *rbuf = _obj->xdata;\n  enum RESBUF_VALUE_TYPE type;\n  int error = 0;\n  int i;\n  unsigned j = 0;\n  //BITCODE_BL num_xdata = _obj->num_xdata;\n  unsigned long start = dat->byte, end = start + xdata_size;\n  Dwg_Data *dwg = _obj->parent->dwg;\n  Dwg_Object *obj = &dwg->object[_obj->parent->objid];\n\n  if (dat->opts & DWG_OPTS_IN) // loosen the overflow checks on dxf/json imports\n    end += xdata_size;\n\n  while (rbuf)\n    {\n      bit_write_RS (dat, rbuf->type);\n      LOG_INSANE (\"xdata[%u] type: \" FORMAT_RS \" [RS] @%lu.%u\\n\", j,\n                  rbuf->type, dat->byte - obj->address, dat->bit)\n      type = dwg_resbuf_value_type (rbuf->type);\n      switch (type)\n        {\n        case DWG_VT_STRING:\n          PRE (R_2007)\n          {\n            if (dat->byte + 3 + rbuf->value.str.size > end)\n              break;\n            // from TU DWG only\n            if (rbuf->value.str.size && rbuf->value.str.is_tu)\n              {\n                BITCODE_TV new = bit_embed_TU_size (rbuf->value.str.u.wdata,\n                                                    rbuf->value.str.size);\n                int len = strlen(new);\n                bit_write_RS (dat, len);\n                bit_write_RC (dat, rbuf->value.str.codepage);\n                if (rbuf->value.str.u.data)\n                  bit_write_TF (dat, (BITCODE_TF)new, len);\n                else\n                  bit_write_TF (dat, (BITCODE_TF)\"\", 0);\n                LOG_TRACE (\"xdata[%u]: \\\"%s\\\" [TF %d %d]\", j,\n                           rbuf->value.str.u.data, len, rbuf->type);\n                free (new);\n              }\n            else\n              {\n                bit_write_RS (dat, rbuf->value.str.size);\n                bit_write_RC (dat, rbuf->value.str.codepage);\n                if (rbuf->value.str.u.data)\n                  bit_write_TF (dat, (BITCODE_TF)rbuf->value.str.u.data, rbuf->value.str.size);\n                else\n                  bit_write_TF (dat, (BITCODE_TF)\"\", 0);\n                LOG_TRACE (\"xdata[%u]: \\\"%s\\\" [TF %d %d]\", j,\n                           rbuf->value.str.u.data, rbuf->value.str.size, rbuf->type);\n              }\n            LOG_POS;\n          }\n          LATER_VERSIONS\n          {\n            if (dat->byte + 2 + (2 * rbuf->value.str.size) > end)\n              break;\n            if (rbuf->value.str.size && !rbuf->value.str.is_tu)\n              {\n                // TODO: same len when converted to TU? normally yes\n                BITCODE_TU new = bit_utf8_to_TU (rbuf->value.str.u.data, 0);\n                bit_write_RS (dat, rbuf->value.str.size);\n                for (i = 0; i < rbuf->value.str.size; i++)\n                  bit_write_RS (dat, new[i]);\n                LOG_TRACE_TU (\"xdata\", new, rbuf->type);\n                free (new);\n              }\n            else\n              {\n                bit_write_RS (dat, rbuf->value.str.size);\n                for (i = 0; i < rbuf->value.str.size; i++)\n                  bit_write_RS (dat, rbuf->value.str.u.wdata[i]);\n                LOG_TRACE_TU (\"xdata\", rbuf->value.str.u.wdata, rbuf->type);\n              }\n            LOG_POS;\n          }\n          break;\n        case DWG_VT_REAL:\n          if (dat->byte + 8 > end)\n            break;\n          bit_write_RD (dat, rbuf->value.dbl);\n          LOG_TRACE (\"xdata[%u]: %f [RD %d]\", j, rbuf->value.dbl,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_BOOL:\n        case DWG_VT_INT8:\n          bit_write_RC (dat, rbuf->value.i8);\n          LOG_TRACE (\"xdata[%u]: %d [RC %d]\", j, (int)rbuf->value.i8,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT16:\n          if (dat->byte + 2 > end)\n            break;\n          bit_write_RS (dat, rbuf->value.i16);\n          LOG_TRACE (\"xdata[%u]: %d [RS %d]\", j, (int)rbuf->value.i16,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT32:\n          if (dat->byte + 4 > end)\n            break;\n          bit_write_RL (dat, rbuf->value.i32);\n          LOG_TRACE (\"xdata[%d]: %ld [RL %d]\", j, (long)rbuf->value.i32,\n                     rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INT64:\n          if (dat->byte + 8 > end)\n            break;\n          bit_write_RLL (dat, rbuf->value.i64);\n          LOG_TRACE (\"xdata[%u]: \" FORMAT_RLL \" [RLL %d]\", j,\n                     rbuf->value.i64, rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_POINT3D:\n          if (dat->byte + 24 > end)\n            break;\n          bit_write_RD (dat, rbuf->value.pt[0]);\n          bit_write_RD (dat, rbuf->value.pt[1]);\n          bit_write_RD (dat, rbuf->value.pt[2]);\n          LOG_TRACE (\"xdata[%u]: (%f,%f,%f) [3RD %d]\", j, rbuf->value.pt[0],\n                     rbuf->value.pt[1], rbuf->value.pt[2], rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_BINARY:\n          if (dat->byte + rbuf->value.str.size > end)\n            break;\n          bit_write_RC (dat, rbuf->value.str.size);\n          bit_write_TF (dat, (BITCODE_TF)rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_TRACE (\"xdata[%u]: [TF %d %d] \", j, rbuf->value.str.size,\n                     rbuf->type);\n          LOG_TRACE_TF (rbuf->value.str.u.data, rbuf->value.str.size);\n          LOG_POS;\n          break;\n        case DWG_VT_HANDLE:\n        case DWG_VT_OBJECTID:\n          if (dat->byte + 8 > end)\n            break;\n          for (i = 0; i < 8; i++)\n            bit_write_RC (dat, rbuf->value.hdl[i]);\n          LOG_TRACE (\"xdata[%u]: \" FORMAT_H \" [H %d]\", j,\n                     ARGS_H (rbuf->value.h), rbuf->type);\n          LOG_POS;\n          break;\n        case DWG_VT_INVALID:\n        default:\n          LOG_ERROR (\"Invalid group code in xdata: %d\", rbuf->type);\n          error = DWG_ERR_INVALIDEED;\n          break;\n        }\n      rbuf = rbuf->nextrb;\n      j++;\n      if (j >= _obj->num_xdata)\n        break;\n      if (dat->byte >= end)\n        {\n          LOG_WARN (\"xdata overflow %u\", xdata_size);\n          break;\n        }\n    }\n  if (_obj->xdata_size != dat->byte - start)\n    {\n      if (dat->opts & DWG_OPTS_IN) // imprecise xdata_size: calculate\n        {\n          _obj->xdata_size = dat->byte - start;\n          LOG_TRACE (\"-xdata_size: \" FORMAT_BL \" (calculated)\\n\", _obj->xdata_size);\n          return error;\n        }\n      else\n        {\n          LOG_WARN (\"xdata Written %lu, expected \" FORMAT_BL, dat->byte - start,\n                    _obj->xdata_size);\n          _obj->xdata_size = dat->byte - start;\n          return error ? error : 1;\n        }\n    }\n  return 0;\n}\n\n#undef IS_ENCODER\n"], "filenames": ["src/encode.c"], "buggy_code_start_loc": [733], "buggy_code_end_loc": [919], "fixing_code_start_loc": [734], "fixing_code_end_loc": [926], "type": "CWE-415", "message": "GNU LibreDWG 0.12.3.4163 through 0.12.3.4191 has a double-free in bit_chain_free (called from dwg_encode_MTEXT and dwg_encode_add_object).", "other": {"cve": {"id": "CVE-2021-36080", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-01T03:15:08.573", "lastModified": "2021-07-08T15:54:42.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GNU LibreDWG 0.12.3.4163 through 0.12.3.4191 has a double-free in bit_chain_free (called from dwg_encode_MTEXT and dwg_encode_add_object)."}, {"lang": "es", "value": "GNU LibreDWG versiones 0.12.3.4163 hasta 0.12.3.4191 presenta un double-free en la funci\u00f3n bit_chain_free (llamado desde dwg_encode_MTEXT y dwg_encode_add_object)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:libredwg:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.12.3.4163", "versionEndIncluding": "0.12.3.4191", "matchCriteriaId": "95BC2628-BB92-4505-9BE8-31FAB1B315AD"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=31724", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibreDWG/libredwg/commit/9b6e0ff9ef02818df034fc42c3bd149a5ff89342", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/libredwg/OSV-2021-495.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibreDWG/libredwg/commit/9b6e0ff9ef02818df034fc42c3bd149a5ff89342"}}