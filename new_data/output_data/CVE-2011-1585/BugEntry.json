{"buggy_code": ["/*\n *   fs/cifs/cifsglob.h\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *              Jeremy Allison (jra@samba.org)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n */\n#ifndef _CIFS_GLOB_H\n#define _CIFS_GLOB_H\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <linux/slow-work.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifsacl.h\"\n/*\n * The sizes of various internal tables and strings\n */\n#define MAX_UID_INFO 16\n#define MAX_SES_INFO 2\n#define MAX_TCON_INFO 4\n\n#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)\n#define MAX_SERVER_SIZE 15\n#define MAX_SHARE_SIZE  64\t/* used to be 20, this should still be enough */\n#define MAX_USERNAME_SIZE 32\t/* 32 is to allow for 15 char names + null\n\t\t\t\t   termination then *2 for unicode versions */\n#define MAX_PASSWORD_SIZE 16\n\n#define CIFS_MIN_RCV_POOL 4\n\n/*\n * MAX_REQ is the maximum number of requests that WE will send\n * on one socket concurrently. It also matches the most common\n * value of max multiplex returned by servers.  We may\n * eventually want to use the negotiated value (in case\n * future servers can handle more) when we are more confident that\n * we will not have problems oveloading the socket with pending\n * write data.\n */\n#define CIFS_MAX_REQ 50\n\n#define RFC1001_NAME_LEN 15\n#define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)\n\n/* currently length of NIP6_FMT */\n#define SERVER_NAME_LENGTH 40\n#define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)\n\n/* used to define string lengths for reversing unicode strings */\n/*         (256+1)*2 = 514                                     */\n/*           (max path length + 1 for null) * 2 for unicode    */\n#define MAX_NAME 514\n\n#include \"cifspdu.h\"\n\n#ifndef XATTR_DOS_ATTRIB\n#define XATTR_DOS_ATTRIB \"user.DOSATTRIB\"\n#endif\n\n/*\n * CIFS vfs client Status information (based on what we know.)\n */\n\n /* associated with each tcp and smb session */\nenum statusEnum {\n\tCifsNew = 0,\n\tCifsGood,\n\tCifsExiting,\n\tCifsNeedReconnect\n};\n\nenum securityEnum {\n\tLANMAN = 0,\t\t\t/* Legacy LANMAN auth */\n\tNTLM,\t\t\t/* Legacy NTLM012 auth with NTLM hash */\n\tNTLMv2,\t\t\t/* Legacy NTLM auth with NTLMv2 hash */\n\tRawNTLMSSP,\t\t/* NTLMSSP without SPNEGO, NTLMv2 hash */\n/*\tNTLMSSP, */ /* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */\n\tKerberos,\t\t/* Kerberos via SPNEGO */\n};\n\nenum protocolEnum {\n\tTCP = 0,\n\tSCTP\n\t/* Netbios frames protocol not supported at this time */\n};\n\nstruct mac_key {\n\tunsigned int len;\n\tunion {\n\t\tchar ntlm[CIFS_SESS_KEY_SIZE + 16];\n\t\tchar krb5[CIFS_SESS_KEY_SIZE + 16]; /* BB: length correct? */\n\t\tstruct {\n\t\t\tchar key[16];\n\t\t\tstruct ntlmv2_resp resp;\n\t\t} ntlmv2;\n\t} data;\n};\n\nstruct cifs_cred {\n\tint uid;\n\tint gid;\n\tint mode;\n\tint cecount;\n\tstruct cifs_sid osid;\n\tstruct cifs_sid gsid;\n\tstruct cifs_ntace *ntaces;\n\tstruct cifs_ace *aces;\n};\n\n/*\n *****************************************************************\n * Except the CIFS PDUs themselves all the\n * globally interesting structs should go here\n *****************************************************************\n */\n\nstruct TCP_Server_Info {\n\tstruct list_head tcp_ses_list;\n\tstruct list_head smb_ses_list;\n\tint srv_count; /* reference counter */\n\t/* 15 character server name + 0x20 16th byte indicating type = srv */\n\tchar server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\tchar *hostname; /* hostname portion of UNC string */\n\tstruct socket *ssocket;\n\tunion {\n\t\tstruct sockaddr_in sockAddr;\n\t\tstruct sockaddr_in6 sockAddr6;\n\t} addr;\n\twait_queue_head_t response_q;\n\twait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/\n\tstruct list_head pending_mid_q;\n\tvoid *Server_NlsInfo;\t/* BB - placeholder for future NLS info  */\n\tunsigned short server_codepage;\t/* codepage for the server    */\n\tenum protocolEnum protocolType;\n\tchar versionMajor;\n\tchar versionMinor;\n\tbool svlocal:1;\t\t\t/* local server or remote */\n\tbool noblocksnd;\t\t/* use blocking sendmsg */\n\tbool noautotune;\t\t/* do not autotune send buf sizes */\n\tbool tcp_nodelay;\n\tatomic_t inFlight;  /* number of requests on the wire to server */\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_t inSend; /* requests trying to send */\n\tatomic_t num_waiters;   /* blocked waiting to get in sendrecv */\n#endif\n\tenum statusEnum tcpStatus; /* what we think the status is */\n\tstruct mutex srv_mutex;\n\tstruct task_struct *tsk;\n\tchar server_GUID[16];\n\tchar secMode;\n\tenum securityEnum secType;\n\tunsigned int maxReq;\t/* Clients should submit no more */\n\t/* than maxReq distinct unanswered SMBs to the server when using  */\n\t/* multiplexed reads or writes */\n\tunsigned int maxBuf;\t/* maxBuf specifies the maximum */\n\t/* message size the server can send or receive for non-raw SMBs */\n\tunsigned int max_rw;\t/* maxRw specifies the maximum */\n\t/* message size the server can send or receive for */\n\t/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */\n\tunsigned int max_vcs;\t/* maximum number of smb sessions, at least\n\t\t\t\t   those that can be specified uniquely with\n\t\t\t\t   vcnumbers */\n\tchar sessid[4];\t\t/* unique token id for this session */\n\t/* (returned on Negotiate */\n\tint capabilities; /* allow selective disabling of caps by smb sess */\n\tint timeAdj;  /* Adjust for difference in server time zone in sec */\n\t__u16 CurrentMid;         /* multiplex id - rotating counter */\n\tchar cryptKey[CIFS_CRYPTO_KEY_SIZE];\n\t/* 16th byte of RFC1001 workstation name is always null */\n\tchar workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\t__u32 sequence_number; /* needed for CIFS PDU signature */\n\tstruct mac_key mac_signing_key;\n\tchar ntlmv2_hash[16];\n\tunsigned long lstrp; /* when we got last response from this server */\n\tu16 dialect; /* dialect index that server chose */\n\t/* extended security flavors that server supports */\n\tbool\tsec_kerberos;\t\t/* supports plain Kerberos */\n\tbool\tsec_mskerberos;\t\t/* supports legacy MS Kerberos */\n\tbool\tsec_kerberosu2u;\t/* supports U2U Kerberos */\n\tbool\tsec_ntlmssp;\t\t/* supports NTLMSSP */\n#ifdef CONFIG_CIFS_FSCACHE\n\tstruct fscache_cookie   *fscache; /* client index cache cookie */\n#endif\n};\n\n/*\n * The following is our shortcut to user information.  We surface the uid,\n * and name. We always get the password on the fly in case it\n * has changed. We also hang a list of sessions owned by this user off here.\n */\nstruct cifsUidInfo {\n\tstruct list_head userList;\n\tstruct list_head sessionList; /* SMB sessions for this user */\n\tuid_t linux_uid;\n\tchar user[MAX_USERNAME_SIZE + 1];\t/* ascii name of user */\n\t/* BB may need ptr or callback for PAM or WinBind info */\n};\n\n/*\n * Session structure.  One of these for each uid session with a particular host\n */\nstruct cifsSesInfo {\n\tstruct list_head smb_ses_list;\n\tstruct list_head tcon_list;\n\tstruct mutex session_mutex;\n#if 0\n\tstruct cifsUidInfo *uidInfo;\t/* pointer to user info */\n#endif\n\tstruct TCP_Server_Info *server;\t/* pointer to server info */\n\tint ses_count;\t\t/* reference counter */\n\tenum statusEnum status;\n\tunsigned overrideSecFlg;  /* if non-zero override global sec flags */\n\t__u16 ipc_tid;\t\t/* special tid for connection to IPC share */\n\t__u16 flags;\n\t__u16 vcnum;\n\tchar *serverOS;\t\t/* name of operating system underlying server */\n\tchar *serverNOS;\t/* name of network operating system of server */\n\tchar *serverDomain;\t/* security realm of server */\n\tint Suid;\t\t/* remote smb uid  */\n\tuid_t linux_uid;        /* local Linux uid */\n\tint capabilities;\n\tchar serverName[SERVER_NAME_LEN_WITH_NULL * 2];\t/* BB make bigger for\n\t\t\t\tTCP names - will ipv6 and sctp addresses fit? */\n\tchar userName[MAX_USERNAME_SIZE + 1];\n\tchar *domainName;\n\tchar *password;\n\tbool need_reconnect:1; /* connection reset, uid now invalid */\n};\n/* no more than one of the following three session flags may be set */\n#define CIFS_SES_NT4 1\n#define CIFS_SES_OS2 2\n#define CIFS_SES_W9X 4\n/* following flag is set for old servers such as OS2 (and Win95?)\n   which do not negotiate NTLM or POSIX dialects, but instead\n   negotiate one of the older LANMAN dialects */\n#define CIFS_SES_LANMAN 8\n/*\n * there is one of these for each connection to a resource on a particular\n * session\n */\nstruct cifsTconInfo {\n\tstruct list_head tcon_list;\n\tint tc_count;\n\tstruct list_head openFileList;\n\tstruct cifsSesInfo *ses;\t/* pointer to session associated with */\n\tchar treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */\n\tchar *nativeFileSystem;\n\tchar *password;\t\t/* for share-level security */\n\t__u16 tid;\t\t/* The 2 byte tree id */\n\t__u16 Flags;\t\t/* optional support bits */\n\tenum statusEnum tidStatus;\n#ifdef CONFIG_CIFS_STATS\n\tatomic_t num_smbs_sent;\n\tatomic_t num_writes;\n\tatomic_t num_reads;\n\tatomic_t num_flushes;\n\tatomic_t num_oplock_brks;\n\tatomic_t num_opens;\n\tatomic_t num_closes;\n\tatomic_t num_deletes;\n\tatomic_t num_mkdirs;\n\tatomic_t num_posixopens;\n\tatomic_t num_posixmkdirs;\n\tatomic_t num_rmdirs;\n\tatomic_t num_renames;\n\tatomic_t num_t2renames;\n\tatomic_t num_ffirst;\n\tatomic_t num_fnext;\n\tatomic_t num_fclose;\n\tatomic_t num_hardlinks;\n\tatomic_t num_symlinks;\n\tatomic_t num_locks;\n\tatomic_t num_acl_get;\n\tatomic_t num_acl_set;\n#ifdef CONFIG_CIFS_STATS2\n\tunsigned long long time_writes;\n\tunsigned long long time_reads;\n\tunsigned long long time_opens;\n\tunsigned long long time_deletes;\n\tunsigned long long time_closes;\n\tunsigned long long time_mkdirs;\n\tunsigned long long time_rmdirs;\n\tunsigned long long time_renames;\n\tunsigned long long time_t2renames;\n\tunsigned long long time_ffirst;\n\tunsigned long long time_fnext;\n\tunsigned long long time_fclose;\n#endif /* CONFIG_CIFS_STATS2 */\n\t__u64    bytes_read;\n\t__u64    bytes_written;\n\tspinlock_t stat_lock;\n#endif /* CONFIG_CIFS_STATS */\n\tFILE_SYSTEM_DEVICE_INFO fsDevInfo;\n\tFILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */\n\tFILE_SYSTEM_UNIX_INFO fsUnixInfo;\n\tbool ipc:1;\t\t/* set if connection to IPC$ eg for RPC/PIPES */\n\tbool retry:1;\n\tbool nocase:1;\n\tbool seal:1;      /* transport encryption for this mounted share */\n\tbool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol\n\t\t\t\tfor this mount even if server would support */\n\tbool local_lease:1; /* check leases (only) on local system not remote */\n\tbool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */\n\tbool need_reconnect:1; /* connection reset, tid now invalid */\n\t/* BB add field for back pointer to sb struct(s)? */\n};\n\n/*\n * This info hangs off the cifsFileInfo structure, pointed to by llist.\n * This is used to track byte stream locks on the file\n */\nstruct cifsLockInfo {\n\tstruct list_head llist;\t/* pointer to next cifsLockInfo */\n\t__u64 offset;\n\t__u64 length;\n\t__u8 type;\n};\n\n/*\n * One of these for each open instance of a file\n */\nstruct cifs_search_info {\n\tloff_t index_of_last_entry;\n\t__u16 entries_in_buffer;\n\t__u16 info_level;\n\t__u32 resume_key;\n\tchar *ntwrk_buf_start;\n\tchar *srch_entries_start;\n\tchar *last_entry;\n\tchar *presume_name;\n\tunsigned int resume_name_len;\n\tbool endOfSearch:1;\n\tbool emptyDir:1;\n\tbool unicode:1;\n\tbool smallBuf:1; /* so we know which buf_release function to call */\n};\n\nstruct cifsFileInfo {\n\tstruct list_head tlist;\t/* pointer to next fid owned by tcon */\n\tstruct list_head flist;\t/* next fid (file instance) for this inode */\n\tunsigned int uid;\t/* allows finding which FileInfo structure */\n\t__u32 pid;\t\t/* process id who opened file */\n\t__u16 netfid;\t\t/* file id from remote */\n\t/* BB add lock scope info here if needed */ ;\n\t/* lock scope id (0 if none) */\n\tstruct file *pfile; /* needed for writepage */\n\tstruct inode *pInode; /* needed for oplock break */\n\tstruct vfsmount *mnt;\n\tstruct mutex lock_mutex;\n\tstruct list_head llist; /* list of byte range locks we have. */\n\tbool closePend:1;\t/* file is marked to close */\n\tbool invalidHandle:1;\t/* file closed via session abend */\n\tbool oplock_break_cancelled:1;\n\tatomic_t count;\t\t/* reference count */\n\tstruct mutex fh_mutex; /* prevents reopen race after dead ses*/\n\tstruct cifs_search_info srch_inf;\n\tstruct slow_work oplock_break; /* slow_work job for oplock breaks */\n};\n\n/* Take a reference on the file private data */\nstatic inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tatomic_inc(&cifs_file->count);\n}\n\n/* Release a reference on the file private data */\nstatic inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tif (atomic_dec_and_test(&cifs_file->count)) {\n\t\tiput(cifs_file->pInode);\n\t\tkfree(cifs_file);\n\t}\n}\n\n/*\n * One of these for each file inode\n */\n\nstruct cifsInodeInfo {\n\tstruct list_head lockList;\n\t/* BB add in lists for dirty pages i.e. write caching info for oplock */\n\tstruct list_head openFileList;\n\tint write_behind_rc;\n\t__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */\n\tunsigned long time;\t/* jiffies of last update/check of inode */\n\tbool clientCanCacheRead:1;\t/* read oplock */\n\tbool clientCanCacheAll:1;\t/* read and writebehind oplock */\n\tbool delete_pending:1;\t\t/* DELETE_ON_CLOSE is set */\n\tbool invalid_mapping:1;\t\t/* pagecache is invalid */\n\tu64  server_eof;\t\t/* current file size on server */\n\tu64  uniqueid;\t\t\t/* server inode number */\n\tstruct inode vfs_inode;\n};\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}\n\n#ifdef CONFIG_CIFS_STATS\n#define cifs_stats_inc atomic_inc\n\nstatic inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}\n\nstatic inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}\n#else\n\n#define  cifs_stats_inc(field) do {} while (0)\n#define  cifs_stats_bytes_written(tcon, bytes) do {} while (0)\n#define  cifs_stats_bytes_read(tcon, bytes) do {} while (0)\n\n#endif\n\n/* one of these for every pending CIFS request to the server */\nstruct mid_q_entry {\n\tstruct list_head qhead;\t/* mids waiting on reply from this server */\n\t__u16 mid;\t\t/* multiplex id */\n\t__u16 pid;\t\t/* process id */\n\t__u32 sequence_number;  /* for CIFS signing */\n\tunsigned long when_alloc;  /* when mid was created */\n#ifdef CONFIG_CIFS_STATS2\n\tunsigned long when_sent; /* time when smb send finished */\n\tunsigned long when_received; /* when demux complete (taken off wire) */\n#endif\n\tstruct task_struct *tsk;\t/* task waiting for response */\n\tstruct smb_hdr *resp_buf;\t/* response buffer */\n\tint midState;\t/* wish this were enum but can not pass to wait_event */\n\t__u8 command;\t/* smb command code */\n\tbool largeBuf:1;\t/* if valid response, is pointer to large buf */\n\tbool multiRsp:1;\t/* multiple trans2 responses for one request  */\n\tbool multiEnd:1;\t/* both received */\n};\n\nstruct oplock_q_entry {\n\tstruct list_head qhead;\n\tstruct inode *pinode;\n\tstruct cifsTconInfo *tcon;\n\t__u16 netfid;\n};\n\n/* for pending dnotify requests */\nstruct dir_notify_req {\n       struct list_head lhead;\n       __le16 Pid;\n       __le16 PidHigh;\n       __u16 Mid;\n       __u16 Tid;\n       __u16 Uid;\n       __u16 netfid;\n       __u32 filter; /* CompletionFilter (for multishot) */\n       int multishot;\n       struct file *pfile;\n};\n\nstruct dfs_info3_param {\n\tint flags; /* DFSREF_REFERRAL_SERVER, DFSREF_STORAGE_SERVER*/\n\tint path_consumed;\n\tint server_type;\n\tint ref_flag;\n\tchar *path_name;\n\tchar *node_name;\n};\n\n/*\n * common struct for holding inode info when searching for or updating an\n * inode with new info\n */\n\n#define CIFS_FATTR_DFS_REFERRAL\t\t0x1\n#define CIFS_FATTR_DELETE_PENDING\t0x2\n#define CIFS_FATTR_NEED_REVAL\t\t0x4\n#define CIFS_FATTR_INO_COLLISION\t0x8\n\nstruct cifs_fattr {\n\tu32\t\tcf_flags;\n\tu32\t\tcf_cifsattrs;\n\tu64\t\tcf_uniqueid;\n\tu64\t\tcf_eof;\n\tu64\t\tcf_bytes;\n\tuid_t\t\tcf_uid;\n\tgid_t\t\tcf_gid;\n\tumode_t\t\tcf_mode;\n\tdev_t\t\tcf_rdev;\n\tunsigned int\tcf_nlink;\n\tunsigned int\tcf_dtype;\n\tstruct timespec\tcf_atime;\n\tstruct timespec\tcf_mtime;\n\tstruct timespec\tcf_ctime;\n};\n\nstatic inline void free_dfs_info_param(struct dfs_info3_param *param)\n{\n\tif (param) {\n\t\tkfree(param->path_name);\n\t\tkfree(param->node_name);\n\t\tkfree(param);\n\t}\n}\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}\n\n#define   MID_FREE 0\n#define   MID_REQUEST_ALLOCATED 1\n#define   MID_REQUEST_SUBMITTED 2\n#define   MID_RESPONSE_RECEIVED 4\n#define   MID_RETRY_NEEDED      8 /* session closed while this request out */\n#define   MID_NO_RESP_NEEDED 0x10\n\n/* Types of response buffer returned from SendReceive2 */\n#define   CIFS_NO_BUFFER        0    /* Response buffer not returned */\n#define   CIFS_SMALL_BUFFER     1\n#define   CIFS_LARGE_BUFFER     2\n#define   CIFS_IOVEC            4    /* array of response buffers */\n\n/* Type of Request to SendReceive2 */\n#define   CIFS_STD_OP\t        0    /* normal request timeout */\n#define   CIFS_LONG_OP          1    /* long op (up to 45 sec, oplock time) */\n#define   CIFS_VLONG_OP         2    /* sloow op - can take up to 180 seconds */\n#define   CIFS_BLOCKING_OP      4    /* operation can block */\n#define   CIFS_ASYNC_OP         8    /* do not wait for response */\n#define   CIFS_TIMEOUT_MASK 0x00F    /* only one of 5 above set in req */\n#define   CIFS_LOG_ERROR    0x010    /* log NT STATUS if non-zero */\n#define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */\n#define   CIFS_NO_RESP      0x040    /* no response buffer required */\n\n/* Security Flags: indicate type of session setup needed */\n#define   CIFSSEC_MAY_SIGN\t0x00001\n#define   CIFSSEC_MAY_NTLM\t0x00002\n#define   CIFSSEC_MAY_NTLMV2\t0x00004\n#define   CIFSSEC_MAY_KRB5\t0x00008\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define   CIFSSEC_MAY_LANMAN\t0x00010\n#define   CIFSSEC_MAY_PLNTXT\t0x00020\n#else\n#define   CIFSSEC_MAY_LANMAN    0\n#define   CIFSSEC_MAY_PLNTXT    0\n#endif /* weak passwords */\n#define   CIFSSEC_MAY_SEAL\t0x00040 /* not supported yet */\n#define   CIFSSEC_MAY_NTLMSSP\t0x00080 /* raw ntlmssp with ntlmv2 */\n\n#define   CIFSSEC_MUST_SIGN\t0x01001\n/* note that only one of the following can be set so the\nresult of setting MUST flags more than once will be to\nrequire use of the stronger protocol */\n#define   CIFSSEC_MUST_NTLM\t0x02002\n#define   CIFSSEC_MUST_NTLMV2\t0x04004\n#define   CIFSSEC_MUST_KRB5\t0x08008\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define   CIFSSEC_MUST_LANMAN\t0x10010\n#define   CIFSSEC_MUST_PLNTXT\t0x20020\n#ifdef CONFIG_CIFS_UPCALL\n#define   CIFSSEC_MASK          0xBF0BF /* allows weak security but also krb5 */\n#else\n#define   CIFSSEC_MASK          0xB70B7 /* current flags supported if weak */\n#endif /* UPCALL */\n#else /* do not allow weak pw hash */\n#ifdef CONFIG_CIFS_UPCALL\n#define   CIFSSEC_MASK          0x8F08F /* flags supported if no weak allowed */\n#else\n#define\t  CIFSSEC_MASK          0x87087 /* flags supported if no weak allowed */\n#endif /* UPCALL */\n#endif /* WEAK_PW_HASH */\n#define   CIFSSEC_MUST_SEAL\t0x40040 /* not supported yet */\n#define   CIFSSEC_MUST_NTLMSSP\t0x80080 /* raw ntlmssp with ntlmv2 */\n\n#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)\n#define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)\n#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)\n/*\n *****************************************************************\n * All constants go here\n *****************************************************************\n */\n\n#define UID_HASH (16)\n\n/*\n * Note that ONE module should define _DECLARE_GLOBALS_HERE to cause the\n * following to be declared.\n */\n\n/****************************************************************************\n *  Locking notes.  All updates to global variables and lists should be\n *                  protected by spinlocks or semaphores.\n *\n *  Spinlocks\n *  ---------\n *  GlobalMid_Lock protects:\n *\tlist operations on pending_mid_q and oplockQ\n *      updates to XID counters, multiplex id  and SMB sequence numbers\n *  GlobalSMBSesLock protects:\n *\tlist operations on tcp and SMB session lists and tCon lists\n *  f_owner.lock protects certain per file struct operations\n *  mapping->page_lock protects certain per page operations\n *\n *  Semaphores\n *  ----------\n *  sesSem     operations on smb session\n *  tconSem    operations on tree connection\n *  fh_sem      file handle reconnection operations\n *\n ****************************************************************************/\n\n#ifdef DECLARE_GLOBALS_HERE\n#define GLOBAL_EXTERN\n#else\n#define GLOBAL_EXTERN extern\n#endif\n\n/*\n * the list of TCP_Server_Info structures, ie each of the sockets\n * connecting our client to a distinct server (ip address), is\n * chained together by cifs_tcp_ses_list. The list of all our SMB\n * sessions (and from that the tree connections) can be found\n * by iterating over cifs_tcp_ses_list\n */\nGLOBAL_EXTERN struct list_head\t\tcifs_tcp_ses_list;\n\n/*\n * This lock protects the cifs_tcp_ses_list, the list of smb sessions per\n * tcp session, and the list of tcon's per smb session. It also protects\n * the reference counters for the server, smb session, and tcon. Finally,\n * changes to the tcon->tidStatus should be done while holding this lock.\n */\nGLOBAL_EXTERN rwlock_t\t\tcifs_tcp_ses_lock;\n\n/*\n * This lock protects the cifs_file->llist and cifs_file->flist\n * list operations, and updates to some flags (cifs_file->invalidHandle)\n * It will be moved to either use the tcon->stat_lock or equivalent later.\n * If cifs_tcp_ses_lock and the lock below are both needed to be held, then\n * the cifs_tcp_ses_lock must be grabbed first and released last.\n */\nGLOBAL_EXTERN rwlock_t GlobalSMBSeslock;\n\n/* Outstanding dir notify requests */\nGLOBAL_EXTERN struct list_head GlobalDnotifyReqList;\n/* DirNotify response queue */\nGLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;\n\n/*\n * Global transaction id (XID) information\n */\nGLOBAL_EXTERN unsigned int GlobalCurrentXid;\t/* protected by GlobalMid_Sem */\nGLOBAL_EXTERN unsigned int GlobalTotalActiveXid; /* prot by GlobalMid_Sem */\nGLOBAL_EXTERN unsigned int GlobalMaxActiveXid;\t/* prot by GlobalMid_Sem */\nGLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above & list operations */\n\t\t\t\t\t  /* on midQ entries */\nGLOBAL_EXTERN char Local_System_Name[15];\n\n/*\n *  Global counters, updated atomically\n */\nGLOBAL_EXTERN atomic_t sesInfoAllocCount;\nGLOBAL_EXTERN atomic_t tconInfoAllocCount;\nGLOBAL_EXTERN atomic_t tcpSesAllocCount;\nGLOBAL_EXTERN atomic_t tcpSesReconnectCount;\nGLOBAL_EXTERN atomic_t tconInfoReconnectCount;\n\n/* Various Debug counters */\nGLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */\n#ifdef CONFIG_CIFS_STATS2\nGLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */\nGLOBAL_EXTERN atomic_t totSmBufAllocCount;\n#endif\nGLOBAL_EXTERN atomic_t smBufAllocCount;\nGLOBAL_EXTERN atomic_t midCount;\n\n/* Misc globals */\nGLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions\n\t\t\t\tto be established on existing mount if we\n\t\t\t\thave the uid/password or Kerberos credential\n\t\t\t\tor equivalent for current user */\nGLOBAL_EXTERN unsigned int oplockEnabled;\nGLOBAL_EXTERN unsigned int experimEnabled;\nGLOBAL_EXTERN unsigned int lookupCacheEnabled;\nGLOBAL_EXTERN unsigned int global_secflags;\t/* if on, session setup sent\n\t\t\t\twith more secure ntlmssp2 challenge/resp */\nGLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */\nGLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/\nGLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */\nGLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */\nGLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */\nGLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/\n\nextern const struct slow_work_ops cifs_oplock_break_ops;\n\n#endif\t/* _CIFS_GLOB_H */\n", "/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <net/ipv6.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"cn_cifs.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\nextern void SMBNTencrypt(unsigned char *passwd, unsigned char *c8,\n\t\t\t unsigned char *p24);\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_vol {\n\tchar *username;\n\tchar *password;\n\tchar *domainname;\n\tchar *UNC;\n\tchar *UNCip;\n\tchar *iocharset;  /* local code page for mapping to and from Unicode */\n\tchar source_rfc1001_name[16]; /* netbios name of client */\n\tchar target_rfc1001_name[16]; /* netbios name of server for Win9x/ME */\n\tuid_t linux_uid;\n\tgid_t linux_gid;\n\tmode_t file_mode;\n\tmode_t dir_mode;\n\tunsigned secFlg;\n\tbool retry:1;\n\tbool intr:1;\n\tbool setuids:1;\n\tbool override_uid:1;\n\tbool override_gid:1;\n\tbool dynperm:1;\n\tbool noperm:1;\n\tbool no_psx_acl:1; /* set if posix acl support should be disabled */\n\tbool cifs_acl:1;\n\tbool no_xattr:1;   /* set if xattr (EA) support should be disabled*/\n\tbool server_ino:1; /* use inode numbers from server ie UniqueId */\n\tbool direct_io:1;\n\tbool remap:1;      /* set to remap seven reserved chars in filenames */\n\tbool posix_paths:1; /* unset to not ask for posix pathnames. */\n\tbool no_linux_ext:1;\n\tbool sfu_emul:1;\n\tbool nullauth:1;   /* attempt to authenticate with null user */\n\tbool nocase:1;     /* request case insensitive filenames */\n\tbool nobrl:1;      /* disable sending byte range locks to srv */\n\tbool mand_lock:1;  /* send mandatory not posix byte range lock reqs */\n\tbool seal:1;       /* request transport encryption on share */\n\tbool nodfs:1;      /* Do not request DFS, even if available */\n\tbool local_lease:1; /* check leases only on local system, not remote */\n\tbool noblocksnd:1;\n\tbool noautotune:1;\n\tbool nostrictsync:1; /* do not force expensive SMBflush on every sync */\n\tunsigned int rsize;\n\tunsigned int wsize;\n\tbool sockopt_tcp_nodelay:1;\n\tunsigned short int port;\n\tchar *prepath;\n\tstruct nls_table *local_nls;\n};\n\nstatic int ipv4_connect(struct TCP_Server_Info *server);\nstatic int ipv6_connect(struct TCP_Server_Info *server);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nstatic int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon;\n\tstruct mid_q_entry *mid_entry;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n\n\tcFYI(1, \"Reconnecting tcp session\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tread_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifsTconInfo, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tread_unlock(&cifs_tcp_ses_lock);\n\t/* do not want to be sending data on a socket we are freeing */\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcFYI(1, \"State: 0x%x Flags: 0x%lx\", server->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcFYI(1, \"Post shutdown state: 0x%x Flags: 0x%lx\",\n\t\t\tserver->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct\n\t\t\t\t\tmid_q_entry,\n\t\t\t\t\tqhead);\n\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* Mark other intransit requests as needing\n\t\t\t\t   retry so we do not immediately mark the\n\t\t\t\t   session bad again (ie after we reconnect\n\t\t\t\t   below) as they timeout too */\n\t\t\tmid_entry->midState = MID_RETRY_NEEDED;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\tmutex_unlock(&server->srv_mutex);\n\n\twhile ((server->tcpStatus != CifsExiting) &&\n\t       (server->tcpStatus != CifsGood)) {\n\t\ttry_to_freeze();\n\t\tif (server->addr.sockAddr6.sin6_family == AF_INET6)\n\t\t\trc = ipv6_connect(server);\n\t\telse\n\t\t\trc = ipv4_connect(server);\n\t\tif (rc) {\n\t\t\tcFYI(1, \"reconnect error %d\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsGood;\n\t\t\tserver->sequence_number = 0;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t/*\t\tatomic_set(&server->inFlight,0);*/\n\t\t\twake_up(&server->response_q);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/*\n\treturn codes:\n\t\t0 \tnot a transact2, or all data present\n\t\t>0 \ttransact2 with that much data missing\n\t\t-EINVAL = invalid transact2\n\n */\nstatic int check2ndT2(struct smb_hdr *pSMB, unsigned int maxBufSize)\n{\n\tstruct smb_t2_rsp *pSMBt;\n\tint total_data_size;\n\tint data_in_this_rsp;\n\tint remaining;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcFYI(1, \"invalid transact2 word count\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = le16_to_cpu(pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = le16_to_cpu(pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tif (remaining == 0)\n\t\treturn 0;\n\telse if (remaining < 0) {\n\t\tcFYI(1, \"total data %d smaller than data in frame %d\",\n\t\t\ttotal_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t} else {\n\t\tcFYI(1, \"missing %d bytes from transact2, check next response\",\n\t\t\tremaining);\n\t\tif (total_data_size > maxBufSize) {\n\t\t\tcERROR(1, \"TotalDataSize %d is over maximum buffer %d\",\n\t\t\t\ttotal_data_size, maxBufSize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn remaining;\n\t}\n}\n\nstatic int coalesce_t2(struct smb_hdr *psecond, struct smb_hdr *pTargetSMB)\n{\n\tstruct smb_t2_rsp *pSMB2 = (struct smb_t2_rsp *)psecond;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)pTargetSMB;\n\tint total_data_size;\n\tint total_in_buf;\n\tint remaining;\n\tint total_in_buf2;\n\tchar *data_area_of_target;\n\tchar *data_area_of_buf2;\n\t__u16 byte_count;\n\n\ttotal_data_size = le16_to_cpu(pSMBt->t2_rsp.TotalDataCount);\n\n\tif (total_data_size != le16_to_cpu(pSMB2->t2_rsp.TotalDataCount)) {\n\t\tcFYI(1, \"total data size of primary and secondary t2 differ\");\n\t}\n\n\ttotal_in_buf = le16_to_cpu(pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - total_in_buf;\n\n\tif (remaining < 0)\n\t\treturn -EINVAL;\n\n\tif (remaining == 0) /* nothing to do, ignore */\n\t\treturn 0;\n\n\ttotal_in_buf2 = le16_to_cpu(pSMB2->t2_rsp.DataCount);\n\tif (remaining < total_in_buf2) {\n\t\tcFYI(1, \"transact2 2nd response contains too much data\");\n\t}\n\n\t/* find end of first SMB data area */\n\tdata_area_of_target = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBt->t2_rsp.DataOffset);\n\t/* validate target area */\n\n\tdata_area_of_buf2 = (char *) &pSMB2->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMB2->t2_rsp.DataOffset);\n\n\tdata_area_of_target += total_in_buf;\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_target, data_area_of_buf2, total_in_buf2);\n\ttotal_in_buf += total_in_buf2;\n\tpSMBt->t2_rsp.DataCount = cpu_to_le16(total_in_buf);\n\tbyte_count = le16_to_cpu(BCC_LE(pTargetSMB));\n\tbyte_count += total_in_buf2;\n\tBCC_LE(pTargetSMB) = cpu_to_le16(byte_count);\n\n\tbyte_count = pTargetSMB->smb_buf_length;\n\tbyte_count += total_in_buf2;\n\n\t/* BB also add check that we are not beyond maximum buffer size */\n\n\tpTargetSMB->smb_buf_length = byte_count;\n\n\tif (remaining == total_in_buf2) {\n\t\tcFYI(1, \"found the last secondary response\");\n\t\treturn 0; /* we are done */\n\t} else /* more responses to go */\n\t\treturn 1;\n\n}\n\nstatic int\ncifs_demultiplex_thread(struct TCP_Server_Info *server)\n{\n\tint length;\n\tunsigned int pdu_length, total_read;\n\tstruct smb_hdr *smb_buffer = NULL;\n\tstruct smb_hdr *bigbuf = NULL;\n\tstruct smb_hdr *smallbuf = NULL;\n\tstruct msghdr smb_msg;\n\tstruct kvec iov;\n\tstruct socket *csocket = server->ssocket;\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\tchar temp;\n\tbool isLargeBuf = false;\n\tbool isMultiRsp;\n\tint reconnect;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcFYI(1, \"Demultiplex PID: %d\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (bigbuf == NULL) {\n\t\t\tbigbuf = cifs_buf_get();\n\t\t\tif (!bigbuf) {\n\t\t\t\tcERROR(1, \"No memory for large SMB response\");\n\t\t\t\tmsleep(3000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (isLargeBuf) {\n\t\t\t/* we are reusing a dirty large buf, clear its start */\n\t\t\tmemset(bigbuf, 0, sizeof(struct smb_hdr));\n\t\t}\n\n\t\tif (smallbuf == NULL) {\n\t\t\tsmallbuf = cifs_small_buf_get();\n\t\t\tif (!smallbuf) {\n\t\t\t\tcERROR(1, \"No memory for SMB response\");\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t\t} else /* if existing small buf clear beginning */\n\t\t\tmemset(smallbuf, 0, sizeof(struct smb_hdr));\n\n\t\tisLargeBuf = false;\n\t\tisMultiRsp = false;\n\t\tsmb_buffer = smallbuf;\n\t\tiov.iov_base = smb_buffer;\n\t\tiov.iov_len = 4;\n\t\tsmb_msg.msg_control = NULL;\n\t\tsmb_msg.msg_controllen = 0;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\nincomplete_rcv:\n\t\tlength =\n\t\t    kernel_recvmsg(csocket, &smb_msg,\n\t\t\t\t&iov, 1, pdu_length, 0 /* BB other flags? */);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcFYI(1, \"Reconnect after server stopped responding\");\n\t\t\tcifs_reconnect(server);\n\t\t\tcFYI(1, \"call to reconnect done\");\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t} else if ((length == -ERESTARTSYS) || (length == -EAGAIN)) {\n\t\t\tmsleep(1); /* minimum sleep to prevent looping\n\t\t\t\tallowing socket to clear and app threads to set\n\t\t\t\ttcpStatus CifsNeedReconnect if server hung */\n\t\t\tif (pdu_length < 4) {\n\t\t\t\tiov.iov_base = (4 - pdu_length) +\n\t\t\t\t\t\t\t(char *)smb_buffer;\n\t\t\t\tiov.iov_len = pdu_length;\n\t\t\t\tsmb_msg.msg_control = NULL;\n\t\t\t\tsmb_msg.msg_controllen = 0;\n\t\t\t\tgoto incomplete_rcv;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tif (server->tcpStatus == CifsNew) {\n\t\t\t\tcFYI(1, \"tcp session abend after SMBnegprot\");\n\t\t\t\t/* some servers kill the TCP session rather than\n\t\t\t\t   returning an SMB negprot error, in which\n\t\t\t\t   case reconnecting here is not going to help,\n\t\t\t\t   and so simply return error to mount */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!try_to_freeze() && (length == -EINTR)) {\n\t\t\t\tcFYI(1, \"cifsd thread killed\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcFYI(1, \"Reconnect after unexpected peek error %d\",\n\t\t\t\tlength);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (length < pdu_length) {\n\t\t\tcFYI(1, \"requested %d bytes but only got %d bytes\",\n\t\t\t\t  pdu_length, length);\n\t\t\tpdu_length -= length;\n\t\t\tmsleep(1);\n\t\t\tgoto incomplete_rcv;\n\t\t}\n\n\t\t/* The right amount was read from socket - 4 bytes */\n\t\t/* so we can now interpret the length field */\n\n\t\t/* the first byte big endian of the length field,\n\t\tis actually not part of the length but the type\n\t\twith the most common, zero, as regular data */\n\t\ttemp = *((char *) smb_buffer);\n\n\t\t/* Note that FC 1001 length is big endian on the wire,\n\t\tbut we convert it here so it is always manipulated\n\t\tas host byte order */\n\t\tpdu_length = be32_to_cpu((__force __be32)smb_buffer->smb_buf_length);\n\t\tsmb_buffer->smb_buf_length = pdu_length;\n\n\t\tcFYI(1, \"rfc1002 length 0x%x\", pdu_length+4);\n\n\t\tif (temp == (char) RFC1002_SESSION_KEEP_ALIVE) {\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_POSITIVE_SESSION_RESPONSE) {\n\t\t\tcFYI(1, \"Good RFC 1002 session rsp\");\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_NEGATIVE_SESSION_RESPONSE) {\n\t\t\t/* we get this from Windows 98 instead of\n\t\t\t   an error on SMB negprot response */\n\t\t\tcFYI(1, \"Negative RFC1002 Session Response Error 0x%x)\",\n\t\t\t\tpdu_length);\n\t\t\tif (server->tcpStatus == CifsNew) {\n\t\t\t\t/* if nack on negprot (rather than\n\t\t\t\tret of smb negprot error) reconnecting\n\t\t\t\tnot going to help, ret error to mount */\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* give server a second to\n\t\t\t\tclean up before reconnect attempt */\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* always try 445 first on reconnect\n\t\t\t\tsince we get NACK on some if we ever\n\t\t\t\tconnected to port 139 (the NACK is\n\t\t\t\tsince we do not begin with RFC1001\n\t\t\t\tsession initialize frame) */\n\t\t\t\tserver->addr.sockAddr.sin_port =\n\t\t\t\t\thtons(CIFS_PORT);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\twake_up(&server->response_q);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (temp != (char) 0) {\n\t\t\tcERROR(1, \"Unknown RFC 1002 frame\");\n\t\t\tcifs_dump_mem(\" Received Data: \", (char *)smb_buffer,\n\t\t\t\t      length);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else we have an SMB response */\n\t\tif ((pdu_length > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) ||\n\t\t\t    (pdu_length < sizeof(struct smb_hdr) - 1 - 4)) {\n\t\t\tcERROR(1, \"Invalid size SMB length %d pdu_length %d\",\n\t\t\t\t\tlength, pdu_length+4);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else length ok */\n\t\treconnect = 0;\n\n\t\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\t\tisLargeBuf = true;\n\t\t\tmemcpy(bigbuf, smallbuf, 4);\n\t\t\tsmb_buffer = bigbuf;\n\t\t}\n\t\tlength = 0;\n\t\tiov.iov_base = 4 + (char *)smb_buffer;\n\t\tiov.iov_len = pdu_length;\n\t\tfor (total_read = 0; total_read < pdu_length;\n\t\t     total_read += length) {\n\t\t\tlength = kernel_recvmsg(csocket, &smb_msg, &iov, 1,\n\t\t\t\t\t\tpdu_length - total_read, 0);\n\t\t\tif ((server->tcpStatus == CifsExiting) ||\n\t\t\t    (length == -EINTR)) {\n\t\t\t\t/* then will exit */\n\t\t\t\treconnect = 2;\n\t\t\t\tbreak;\n\t\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\t/* Reconnect wakes up rspns q */\n\t\t\t\t/* Now we will reread sock */\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t} else if ((length == -ERESTARTSYS) ||\n\t\t\t\t   (length == -EAGAIN)) {\n\t\t\t\tmsleep(1); /* minimum sleep to prevent looping,\n\t\t\t\t\t      allowing socket to clear and app\n\t\t\t\t\t      threads to set tcpStatus\n\t\t\t\t\t      CifsNeedReconnect if server hung*/\n\t\t\t\tlength = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (length <= 0) {\n\t\t\t\tcERROR(1, \"Received no data, expecting %d\",\n\t\t\t\t\t      pdu_length - total_read);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reconnect == 2)\n\t\t\tbreak;\n\t\telse if (reconnect == 1)\n\t\t\tcontinue;\n\n\t\tlength += 4; /* account for rfc1002 hdr */\n\n\n\t\tdump_smb(smb_buffer, length);\n\t\tif (checkSMB(smb_buffer, smb_buffer->Mid, total_read+4)) {\n\t\t\tcifs_dump_mem(\"Bad SMB: \", smb_buffer, 48);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\ttask_to_wake = NULL;\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\n\t\t\tif ((mid_entry->mid == smb_buffer->Mid) &&\n\t\t\t    (mid_entry->midState == MID_REQUEST_SUBMITTED) &&\n\t\t\t    (mid_entry->command == smb_buffer->Command)) {\n\t\t\t\tif (check2ndT2(smb_buffer,server->maxBuf) > 0) {\n\t\t\t\t\t/* We have a multipart transact2 resp */\n\t\t\t\t\tisMultiRsp = true;\n\t\t\t\t\tif (mid_entry->resp_buf) {\n\t\t\t\t\t\t/* merge response - fix up 1st*/\n\t\t\t\t\t\tif (coalesce_t2(smb_buffer,\n\t\t\t\t\t\t\tmid_entry->resp_buf)) {\n\t\t\t\t\t\t\tmid_entry->multiRsp =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* all parts received */\n\t\t\t\t\t\t\tmid_entry->multiEnd =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tgoto multi_t2_fnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!isLargeBuf) {\n\t\t\t\t\t\t\tcERROR(1, \"1st trans2 resp needs bigbuf\");\n\t\t\t\t\t/* BB maybe we can fix this up,  switch\n\t\t\t\t\t   to already allocated large buffer? */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Have first buffer */\n\t\t\t\t\t\t\tmid_entry->resp_buf =\n\t\t\t\t\t\t\t\t smb_buffer;\n\t\t\t\t\t\t\tmid_entry->largeBuf =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbigbuf = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmid_entry->resp_buf = smb_buffer;\n\t\t\t\tmid_entry->largeBuf = isLargeBuf;\nmulti_t2_fnd:\n\t\t\t\ttask_to_wake = mid_entry->tsk;\n\t\t\t\tmid_entry->midState = MID_RESPONSE_RECEIVED;\n#ifdef CONFIG_CIFS_STATS2\n\t\t\t\tmid_entry->when_received = jiffies;\n#endif\n\t\t\t\t/* so we do not time out requests to  server\n\t\t\t\twhich is still responding (since server could\n\t\t\t\tbe busy but not dead) */\n\t\t\t\tserver->lstrp = jiffies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\tif (task_to_wake) {\n\t\t\t/* Was previous buf put in mpx struct for multi-rsp? */\n\t\t\tif (!isMultiRsp) {\n\t\t\t\t/* smb buffer will be freed by user thread */\n\t\t\t\tif (isLargeBuf)\n\t\t\t\t\tbigbuf = NULL;\n\t\t\t\telse\n\t\t\t\t\tsmallbuf = NULL;\n\t\t\t}\n\t\t\twake_up_process(task_to_wake);\n\t\t} else if (!is_valid_oplock_break(smb_buffer, server) &&\n\t\t\t   !isMultiRsp) {\n\t\t\tcERROR(1, \"No task to wake, unknown frame received! \"\n\t\t\t\t   \"NumMids %d\", midCount.counter);\n\t\t\tcifs_dump_mem(\"Received Data is: \", (char *)smb_buffer,\n\t\t\t\t      sizeof(struct smb_hdr));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tcifs_dump_detail(smb_buffer);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* take it off the list, if it's not already */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\t/* Note that cifs_max_pending is normally 50, but\n\tcan be set at module install time to as little as two */\n\tspin_lock(&GlobalMid_Lock);\n\tif (atomic_read(&server->inFlight) >= cifs_max_pending)\n\t\tatomic_set(&server->inFlight, cifs_max_pending - 1);\n\t/* We do not want to set the max_pending too low or we\n\tcould end up with the counter going negative */\n\tspin_unlock(&GlobalMid_Lock);\n\t/* Although there should not be any requests blocked on\n\tthis queue it can not hurt to be paranoid and try to wake up requests\n\tthat may haven been blocked when more than 50 at time were on the wire\n\tto the same server - they now will see the session is in exit state\n\tand get out of SendReceive.  */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(csocket);\n\t\tserver->ssocket = NULL;\n\t}\n\t/* buffer usuallly freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(bigbuf);\n\tif (smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(smallbuf);\n\n\t/*\n\t * BB: we shouldn't have to do any of this. It shouldn't be\n\t * possible to exit from the thread with active SMB sessions\n\t */\n\tread_lock(&cifs_tcp_ses_lock);\n\tif (list_empty(&server->pending_mid_q)) {\n\t\t/* loop through server session structures attached to this and\n\t\t    mark them dead */\n\t\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp, struct cifsSesInfo,\n\t\t\t\t\t smb_ses_list);\n\t\t\tses->status = CifsExiting;\n\t\t\tses->server = NULL;\n\t\t}\n\t\tread_unlock(&cifs_tcp_ses_lock);\n\t} else {\n\t\t/* although we can not zero the server struct pointer yet,\n\t\tsince there are active requests which may depnd on them,\n\t\tmark the corresponding SMB sessions as exiting too */\n\t\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp, struct cifsSesInfo,\n\t\t\t\t\t smb_ses_list);\n\t\t\tses->status = CifsExiting;\n\t\t}\n\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED) {\n\t\t\t\tcFYI(1, \"Clearing Mid 0x%x - waking up \",\n\t\t\t\t\t mid_entry->mid);\n\t\t\t\ttask_to_wake = mid_entry->tsk;\n\t\t\t\tif (task_to_wake)\n\t\t\t\t\twake_up_process(task_to_wake);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\tread_unlock(&cifs_tcp_ses_lock);\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/* mpx threads have not exited yet give them\n\t\tat least the smb send timeout time for long ops */\n\t\t/* due to delays on oplock break requests, we need\n\t\tto wait at least 45 seconds before giving up\n\t\ton a request getting a response and going ahead\n\t\tand killing cifsd */\n\t\tcFYI(1, \"Wait for exit from demultiplex thread\");\n\t\tmsleep(46000);\n\t\t/* if threads still have not exited they are probably never\n\t\tcoming home not much else we can do but free the memory */\n\t}\n\n\t/* last chance to mark ses pointers invalid\n\tif there are any pointing to this (e.g\n\tif a crazy root user tried to kill cifsd\n\tkernel thread explicitly this might happen) */\n\t/* BB: This shouldn't be necessary, see above */\n\tread_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->server = NULL;\n\t}\n\tread_unlock(&cifs_tcp_ses_lock);\n\n\tkfree(server->hostname);\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length  > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int\ncifs_parse_mount_options(char *options, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *value;\n\tchar *data;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\n\tif (Local_System_Name[0] != 0)\n\t\tmemcpy(vol->source_rfc1001_name, Local_System_Name, 15);\n\telse {\n\t\tchar *nodename = utsname()->nodename;\n\t\tint n = strnlen(nodename, 15);\n\t\tmemset(vol->source_rfc1001_name, 0x20, 15);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* does not have to be perfect mapping since field is\n\t\t\tinformational, only used for servers that do not support\n\t\t\tport 445 and it can be overridden at mount time */\n\t\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\t\t}\n\t}\n\tvol->source_rfc1001_name[15] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->linux_uid = current_uid();  /* use current_euid() instead? */\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\tif (!options)\n\t\treturn 1;\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcFYI(1, \"Null separator not allowed\");\n\t\t}\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tif (!*data)\n\t\t\tcontinue;\n\t\tif ((value = strchr(data, '=')) != NULL)\n\t\t\t*value++ = '\\0';\n\n\t\t/* Have to parse this before we parse for \"user\" */\n\t\tif (strnicmp(data, \"user_xattr\", 10) == 0) {\n\t\t\tvol->no_xattr = 0;\n\t\t} else if (strnicmp(data, \"nouser_xattr\", 12) == 0) {\n\t\t\tvol->no_xattr = 1;\n\t\t} else if (strnicmp(data, \"user\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"CIFS: invalid or missing username\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t} else if (!*value) {\n\t\t\t\t/* null user, ie anonymous, authentication */\n\t\t\t\tvol->nullauth = 1;\n\t\t\t}\n\t\t\tif (strnlen(value, 200) < 200) {\n\t\t\t\tvol->username = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"pass\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tvol->password = NULL;\n\t\t\t\tcontinue;\n\t\t\t} else if (value[0] == 0) {\n\t\t\t\t/* check if string begins with double comma\n\t\t\t\t   since that would mean the password really\n\t\t\t\t   does start with a comma, and would not\n\t\t\t\t   indicate an empty string */\n\t\t\t\tif (value[1] != separator[0]) {\n\t\t\t\t\tvol->password = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp_len = strlen(value);\n\t\t\t/* removed password length check, NTLM passwords\n\t\t\t\tcan be arbitrarily long */\n\n\t\t\t/* if comma in password, the string will be\n\t\t\tprematurely null terminated.  Commas in password are\n\t\t\tspecified across the cifs mount interface by a double\n\t\t\tcomma ie ,, and a comma used as in other cases ie ','\n\t\t\tas a parameter delimiter/separator is single and due\n\t\t\tto the strsep above is temporarily zeroed. */\n\n\t\t\t/* NB: password legally can have multiple commas and\n\t\t\tthe only illegal character in a password is null */\n\n\t\t\tif ((value[temp_len] == 0) &&\n\t\t\t    (value[temp_len+1] == separator[0])) {\n\t\t\t\t/* reinsert comma */\n\t\t\t\tvalue[temp_len] = separator[0];\n\t\t\t\ttemp_len += 2;  /* move after second comma */\n\t\t\t\twhile (value[temp_len] != 0)  {\n\t\t\t\t\tif (value[temp_len] == separator[0]) {\n\t\t\t\t\t\tif (value[temp_len+1] ==\n\t\t\t\t\t\t     separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\t\ttemp_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t/* single comma indicating start\n\t\t\t\t\t\t\t of next parm */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp_len++;\n\t\t\t\t}\n\t\t\t\tif (value[temp_len] == 0) {\n\t\t\t\t\toptions = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tvalue[temp_len] = 0;\n\t\t\t\t\t/* point option to start of next parm */\n\t\t\t\t\toptions = value + temp_len + 1;\n\t\t\t\t}\n\t\t\t\t/* go from value to value + temp_len condensing\n\t\t\t\tdouble commas to singles. Note that this ends up\n\t\t\t\tallocating a few bytes too many, which is ok */\n\t\t\t\tvol->password = kzalloc(temp_len, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\t\tvol->password[j] = value[i];\n\t\t\t\t\tif (value[i] == separator[0]\n\t\t\t\t\t\t&& value[i+1] == separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvol->password[j] = 0;\n\t\t\t} else {\n\t\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstrcpy(vol->password, value);\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"ip\", 2) ||\n\t\t\t   !strnicmp(data, \"addr\", 4)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tvol->UNCip = NULL;\n\t\t\t} else if (strnlen(value, INET6_ADDRSTRLEN) <\n\t\t\t\t\t\t\tINET6_ADDRSTRLEN) {\n\t\t\t\tvol->UNCip = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: ip address \"\n\t\t\t\t\t\t    \"too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sec\", 3) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no security value specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"krb5i\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"krb5p\", 5) == 0) {\n\t\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL |\n\t\t\t\t\tCIFSSEC_MAY_KRB5; */\n\t\t\t\tcERROR(1, \"Krb5 cifs privacy not supported\");\n\t\t\t\treturn 1;\n\t\t\t} else if (strnicmp(value, \"krb5\", 4) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5;\n#ifdef CONFIG_CIFS_EXPERIMENTAL\n\t\t\t} else if (strnicmp(value, \"ntlmsspi\", 8) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmssp\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n#endif\n\t\t\t} else if (strnicmp(value, \"ntlmv2i\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmv2\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\t\t} else if (strnicmp(value, \"ntlmi\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlm\", 4) == 0) {\n\t\t\t\t/* ntlm is default so can be turned off too */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\t\t} else if (strnicmp(value, \"nontlm\", 6) == 0) {\n\t\t\t\t/* BB is there a better way to do this? */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\t\t} else if (strnicmp(value, \"lanman\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n#endif\n\t\t\t} else if (strnicmp(value, \"none\", 4) == 0) {\n\t\t\t\tvol->nullauth = 1;\n\t\t\t} else {\n\t\t\t\tcERROR(1, \"bad security option: %s\", value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"unc\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"target\", 6) == 0)\n\t\t\t   || (strnicmp(data, \"path\", 4) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid path to \"\n\t\t\t\t\t\t    \"network resource\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 300)) < 300) {\n\t\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->UNC == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tstrcpy(vol->UNC, value);\n\t\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"CIFS: UNC Path does not begin \"\n\t\t\t\t\t       \"with // or \\\\\\\\ \\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"domain\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"workgroup\", 5) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid domain name\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\t/* BB are there cases in which a comma can be valid in\n\t\t\ta domain name and need special handling? */\n\t\t\tif (strnlen(value, 256) < 256) {\n\t\t\t\tvol->domainname = value;\n\t\t\t\tcFYI(1, \"Domain name set\");\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too \"\n\t\t\t\t\t\t    \"long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"prefixpath\", 10) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"CIFS: invalid path prefix\\n\");\n\t\t\t\treturn 1;       /* needs_argument */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 1024)) < 1024) {\n\t\t\t\tif (value[0] != '/')\n\t\t\t\t\ttemp_len++;  /* missing leading slash */\n\t\t\t\tvol->prepath = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->prepath == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tvol->prepath[0] = '/';\n\t\t\t\t\tstrcpy(vol->prepath+1, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(vol->prepath, value);\n\t\t\t\tcFYI(1, \"prefix path %s\", vol->prepath);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: prefix too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"iocharset\", 9) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid iocharset \"\n\t\t\t\t\t\t    \"specified\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif (strnlen(value, 65) < 65) {\n\t\t\t\tif (strnicmp(value, \"default\", 7))\n\t\t\t\t\tvol->iocharset = value;\n\t\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t\t   is used by caller */\n\t\t\t\tcFYI(1, \"iocharset set to %s\", value);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"uid\", 3) && value && *value) {\n\t\t\tvol->linux_uid = simple_strtoul(value, &value, 0);\n\t\t\tuid_specified = true;\n\t\t} else if (!strnicmp(data, \"forceuid\", 8)) {\n\t\t\toverride_uid = 1;\n\t\t} else if (!strnicmp(data, \"noforceuid\", 10)) {\n\t\t\toverride_uid = 0;\n\t\t} else if (!strnicmp(data, \"gid\", 3) && value && *value) {\n\t\t\tvol->linux_gid = simple_strtoul(value, &value, 0);\n\t\t\tgid_specified = true;\n\t\t} else if (!strnicmp(data, \"forcegid\", 8)) {\n\t\t\toverride_gid = 1;\n\t\t} else if (!strnicmp(data, \"noforcegid\", 10)) {\n\t\t\toverride_gid = 0;\n\t\t} else if (strnicmp(data, \"file_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->file_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dir_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dirmode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"port\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->port =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"rsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->rsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"wsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->wsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sockopt\", 5) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no socket option specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"TCP_NODELAY\", 11) == 0) {\n\t\t\t\tvol->sockopt_tcp_nodelay = 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"netbiosname\", 4) == 0) {\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"invalid (empty) netbiosname\");\n\t\t\t} else {\n\t\t\t\tmemset(vol->source_rfc1001_name, 0x20, 15);\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\tvalid in this workstation netbios name (and need\n\t\t\t\tspecial handling)? */\n\n\t\t\t\t/* We do not uppercase netbiosname for user */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->source_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\tset at top of the function  */\n\t\t\t\tif ((i == 15) && (value[i] != 0))\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t\t\t\" longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"servern\", 7) == 0) {\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"empty server netbiosname specified\");\n\t\t\t} else {\n\t\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\t\tmemset(vol->target_rfc1001_name, 0x20, 16);\n\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\t   valid in this workstation netbios name\n\t\t\t\t   (and need special handling)? */\n\n\t\t\t\t/* user or mount helper must uppercase\n\t\t\t\t   the netbiosname */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->target_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\t   set at top of the function  */\n\t\t\t\tif ((i == 15) && (value[i] != 0))\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t\t\"biosname longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"credentials\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"version\", 3) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"guest\", 5) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"rw\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"ro\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"noblocksend\", 11) == 0) {\n\t\t\tvol->noblocksnd = 1;\n\t\t} else if (strnicmp(data, \"noautotune\", 10) == 0) {\n\t\t\tvol->noautotune = 1;\n\t\t} else if ((strnicmp(data, \"suid\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nosuid\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"exec\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noexec\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nodev\", 5) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noauto\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"dev\", 3) == 0)) {\n\t\t\t/*  The mount tool or mount.cifs helper (if present)\n\t\t\t    uses these opts to set flags, and the flags are read\n\t\t\t    by the kernel vfs layer before we get here (ie\n\t\t\t    before read super) so there is no point trying to\n\t\t\t    parse these options again and set anything and it\n\t\t\t    is ok to just ignore them */\n\t\t\tcontinue;\n\t\t} else if (strnicmp(data, \"hard\", 4) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"soft\", 4) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"perm\", 4) == 0) {\n\t\t\tvol->noperm = 0;\n\t\t} else if (strnicmp(data, \"noperm\", 6) == 0) {\n\t\t\tvol->noperm = 1;\n\t\t} else if (strnicmp(data, \"mapchars\", 8) == 0) {\n\t\t\tvol->remap = 1;\n\t\t} else if (strnicmp(data, \"nomapchars\", 10) == 0) {\n\t\t\tvol->remap = 0;\n\t\t} else if (strnicmp(data, \"sfu\", 3) == 0) {\n\t\t\tvol->sfu_emul = 1;\n\t\t} else if (strnicmp(data, \"nosfu\", 5) == 0) {\n\t\t\tvol->sfu_emul = 0;\n\t\t} else if (strnicmp(data, \"nodfs\", 5) == 0) {\n\t\t\tvol->nodfs = 1;\n\t\t} else if (strnicmp(data, \"posixpaths\", 10) == 0) {\n\t\t\tvol->posix_paths = 1;\n\t\t} else if (strnicmp(data, \"noposixpaths\", 12) == 0) {\n\t\t\tvol->posix_paths = 0;\n\t\t} else if (strnicmp(data, \"nounix\", 6) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if (strnicmp(data, \"nolinux\", 7) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if ((strnicmp(data, \"nocase\", 6) == 0) ||\n\t\t\t   (strnicmp(data, \"ignorecase\", 10)  == 0)) {\n\t\t\tvol->nocase = 1;\n\t\t} else if (strnicmp(data, \"brl\", 3) == 0) {\n\t\t\tvol->nobrl =  0;\n\t\t} else if ((strnicmp(data, \"nobrl\", 5) == 0) ||\n\t\t\t   (strnicmp(data, \"nolock\", 6) == 0)) {\n\t\t\tvol->nobrl =  1;\n\t\t\t/* turn off mandatory locking in mode\n\t\t\tif remote locking is turned off since the\n\t\t\tlocal vfs will do advisory */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t} else if (strnicmp(data, \"forcemandatorylock\", 9) == 0) {\n\t\t\t/* will take the shorter form \"forcemand\" as well */\n\t\t\t/* This mount option will force use of mandatory\n\t\t\t  (DOS/Windows style) byte range locks, instead of\n\t\t\t  using posix advisory byte range locks, even if the\n\t\t\t  Unix extensions are available and posix locks would\n\t\t\t  be supported otherwise. If Unix extensions are not\n\t\t\t  negotiated this has no effect since mandatory locks\n\t\t\t  would be used (mandatory locks is all that those\n\t\t\t  those servers support) */\n\t\t\tvol->mand_lock = 1;\n\t\t} else if (strnicmp(data, \"setuids\", 7) == 0) {\n\t\t\tvol->setuids = 1;\n\t\t} else if (strnicmp(data, \"nosetuids\", 9) == 0) {\n\t\t\tvol->setuids = 0;\n\t\t} else if (strnicmp(data, \"dynperm\", 7) == 0) {\n\t\t\tvol->dynperm = true;\n\t\t} else if (strnicmp(data, \"nodynperm\", 9) == 0) {\n\t\t\tvol->dynperm = false;\n\t\t} else if (strnicmp(data, \"nohard\", 6) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"nosoft\", 6) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"nointr\", 6) == 0) {\n\t\t\tvol->intr = 0;\n\t\t} else if (strnicmp(data, \"intr\", 4) == 0) {\n\t\t\tvol->intr = 1;\n\t\t} else if (strnicmp(data, \"nostrictsync\", 12) == 0) {\n\t\t\tvol->nostrictsync = 1;\n\t\t} else if (strnicmp(data, \"strictsync\", 10) == 0) {\n\t\t\tvol->nostrictsync = 0;\n\t\t} else if (strnicmp(data, \"serverino\", 7) == 0) {\n\t\t\tvol->server_ino = 1;\n\t\t} else if (strnicmp(data, \"noserverino\", 9) == 0) {\n\t\t\tvol->server_ino = 0;\n\t\t} else if (strnicmp(data, \"cifsacl\", 7) == 0) {\n\t\t\tvol->cifs_acl = 1;\n\t\t} else if (strnicmp(data, \"nocifsacl\", 9) == 0) {\n\t\t\tvol->cifs_acl = 0;\n\t\t} else if (strnicmp(data, \"acl\", 3) == 0) {\n\t\t\tvol->no_psx_acl = 0;\n\t\t} else if (strnicmp(data, \"noacl\", 5) == 0) {\n\t\t\tvol->no_psx_acl = 1;\n#ifdef CONFIG_CIFS_EXPERIMENTAL\n\t\t} else if (strnicmp(data, \"locallease\", 6) == 0) {\n\t\t\tvol->local_lease = 1;\n#endif\n\t\t} else if (strnicmp(data, \"sign\", 4) == 0) {\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t} else if (strnicmp(data, \"seal\", 4) == 0) {\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t   is a per tree connection (mount) not a per socket\n\t\t\t   or per-smb connection option in the protocol */\n\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL; */\n\t\t\tvol->seal = 1;\n\t\t} else if (strnicmp(data, \"direct\", 6) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"forcedirectio\", 13) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"noac\", 4) == 0) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"CIFS: Unknown mount option %s\\n\",\n\t\t\t\t\t\tdata);\n\t}\n\tif (vol->UNC == NULL) {\n\t\tif (devname == NULL) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Missing UNC name for mount \"\n\t\t\t\t\t\t\"target\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((temp_len = strnlen(devname, 300)) < 300) {\n\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->UNC == NULL)\n\t\t\t\treturn 1;\n\t\t\tstrcpy(vol->UNC, devname);\n\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC Path does not \"\n\t\t\t\t\t\t    \"begin with // or \\\\\\\\ \\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tvalue = strpbrk(vol->UNC+2, \"/\\\\\");\n\t\t\tif (value)\n\t\t\t\t*value = '\\\\';\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (vol->UNCip == NULL)\n\t\tvol->UNCip = &vol->UNC[2];\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\treturn 0;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (addr4->sin_addr.s_addr !=\n\t\t    server->addr.sockAddr.sin_addr.s_addr)\n\t\t\treturn false;\n\t\tif (addr4->sin_port &&\n\t\t    addr4->sin_port != server->addr.sockAddr.sin_port)\n\t\t\treturn false;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &server->addr.sockAddr6.sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id !=\n\t\t    server->addr.sockAddr6.sin6_scope_id)\n\t\t\treturn false;\n\t\tif (addr6->sin6_port &&\n\t\t    addr6->sin6_port != server->addr.sockAddr6.sin6_port)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptible */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->secMode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->secMode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t/*\n\t\t * the demux thread can exit on its own while still in CifsNew\n\t\t * so don't accept any sockets in that state. Since the\n\t\t * tcpStatus never changes back to CifsNew it's safe to check\n\t\t * for this without a lock.\n\t\t */\n\t\tif (server->tcpStatus == CifsNew)\n\t\t\tcontinue;\n\n\t\tif (!match_address(server, addr))\n\t\t\tcontinue;\n\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&server->tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_fscache_release_client_cookie(server);\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *sin_server = (struct sockaddr_in *) &addr;\n\tstruct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;\n\tint rc;\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\n\tcFYI(1, \"UNC: %s ip: %s\", volume_info->UNC, volume_info->UNCip);\n\n\tif (volume_info->UNCip && volume_info->UNC) {\n\t\trc = cifs_fill_sockaddr((struct sockaddr *)&addr,\n\t\t\t\t\tvolume_info->UNCip,\n\t\t\t\t\tvolume_info->port);\n\t\tif (!rc) {\n\t\t\t/* we failed translating address */\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (volume_info->UNCip) {\n\t\t/* BB using ip addr as tcp_ses name to connect to the\n\t\t   DFS root below */\n\t\tcERROR(1, \"Connecting to DFS root not implemented yet\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t} else /* which tcp_sess DFS root would we conect to */ {\n\t\tcERROR(1, \"CIFS mount error: No UNC path (e.g. -o \"\n\t\t\t\"unc=//192.168.1.100/public) specified\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session((struct sockaddr *)&addr, volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\tatomic_set(&tcp_ses->inFlight, 0);\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->sequence_number = 0;\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\tif (addr.ss_family == AF_INET6) {\n\t\tcFYI(1, \"attempting ipv6 connect\");\n\t\t/* BB should we allow ipv6 on port 139? */\n\t\t/* other OS never observed in Wild doing 139 with v6 */\n\t\tmemcpy(&tcp_ses->addr.sockAddr6, sin_server6,\n\t\t\tsizeof(struct sockaddr_in6));\n\t\trc = ipv6_connect(tcp_ses);\n\t} else {\n\t\tmemcpy(&tcp_ses->addr.sockAddr, sin_server,\n\t\t\tsizeof(struct sockaddr_in));\n\t\trc = ipv4_connect(tcp_ses);\n\t}\n\tif (rc < 0) {\n\t\tcERROR(1, \"Error connecting to socket. Aborting operation\");\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run((void *)(void *)cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcERROR(1, \"error %d create cifsd thread\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err;\n\t}\n\n\t/* thread spawned, put it on the list */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\treturn tcp_ses;\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsSesInfo *\ncifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifsSesInfo *ses)\n{\n\tint xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcFYI(1, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood) {\n\t\txid = GetXid();\n\t\tCIFSSMBLogoff(xid, ses);\n\t\t_FreeXid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\nstatic struct cifsSesInfo *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM, xid;\n\tstruct cifsSesInfo *ses;\n\n\txid = GetXid();\n\n\tses = cifs_find_smb_ses(server, volume_info->username);\n\tif (ses) {\n\t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tFreeXid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcFYI(1, \"Session needs reconnect\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tFreeXid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tFreeXid(xid);\n\t\treturn ses;\n\t}\n\n\tcFYI(1, \"Existing smb sess not found\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->addr.sockAddr6.sin6_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\",\n\t\t\t&server->addr.sockAddr6.sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\",\n\t\t\t&server->addr.sockAddr.sin_addr.s_addr);\n\n\tif (volume_info->username)\n\t\tstrncpy(ses->userName, volume_info->username,\n\t\t\tMAX_USERNAME_SIZE);\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tint len = strlen(volume_info->domainname);\n\t\tses->domainName = kmalloc(len + 1, GFP_KERNEL);\n\t\tif (ses->domainName)\n\t\t\tstrcpy(ses->domainName, volume_info->domainname);\n\t}\n\tses->linux_uid = volume_info->linux_uid;\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tFreeXid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsTconInfo *\ncifs_find_tcon(struct cifsSesInfo *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifsTconInfo *tcon;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifsTconInfo, tcon_list);\n\t\tif (tcon->tidStatus == CifsExiting)\n\t\t\tcontinue;\n\t\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\t\tcontinue;\n\n\t\t++tcon->tc_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifsTconInfo *tcon)\n{\n\tint xid;\n\tstruct cifsSesInfo *ses = tcon->ses;\n\n\tcFYI(1, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\txid = GetXid();\n\tCIFSSMBTDis(xid, tcon);\n\t_FreeXid(xid);\n\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifsTconInfo *\ncifs_get_tcon(struct cifsSesInfo *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifsTconInfo *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcFYI(1, \"Found match on UNC path\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcERROR(1, \"transport encryption setting \"\n\t\t\t\t   \"conflicts with existing tid\");\n\t\treturn tcon;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (strchr(volume_info->UNC + 3, '\\\\') == NULL\n\t    && strchr(volume_info->UNC + 3, '/') == NULL) {\n\t\tcERROR(1, \"Missing share name\");\n\t\trc = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\t/* BB Do we need to wrap session_mutex around\n\t * this TCon call and Unix SetFS as\n\t * we do on SessSetup and reconnect? */\n\txid = GetXid();\n\trc = CIFSTCon(xid, ses, volume_info->UNC, tcon, volume_info->local_nls);\n\tFreeXid(xid);\n\tcFYI(1, \"CIFS Tcon rc = %d\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcFYI(1, \"DFS disabled (%d)\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/* we can have only one retry value for a connection\n\t   to a share so for resources mounted more than once\n\t   to the same server share the last value passed in\n\t   for the retry flag is used */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\n\nint\nget_dfs_path(int xid, struct cifsSesInfo *pSesInfo, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *pnum_referrals,\n\t     struct dfs_info3_param **preferrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\t*pnum_referrals = 0;\n\t*preferrals = NULL;\n\n\tif (pSesInfo->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(pSesInfo->serverName,\n\t\t\t\tSERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t + 1 + 4 /* slash IPC$ */  + 2,\n\t\t\t\tGFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, pSesInfo->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(pSesInfo->serverName), \"\\\\IPC$\");\n\t\trc = CIFSTCon(xid, pSesInfo, temp_unc, NULL, nls_codepage);\n\t\tcFYI(1, \"CIFS Tcon rc = %d ipc_tid = %d\", rc, pSesInfo->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = CIFSGetDFSRefer(xid, pSesInfo, old_path, preferrals,\n\t\t\t\t     pnum_referrals, nls_codepage, remap);\n\t/* BB map targetUNCs to dfs_info3 structures, here or\n\t\tin CIFSGetDFSRefer BB */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\n\nstatic int\nipv4_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tint val;\n\tbool connected = false;\n\t__be16 orig_port = 0;\n\tstruct socket *socket = server->ssocket;\n\n\tif (socket == NULL) {\n\t\trc = sock_create_kern(PF_INET, SOCK_STREAM,\n\t\t\t\t      IPPROTO_TCP, &socket);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating socket\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\t/* user overrode default port */\n\tif (server->addr.sockAddr.sin_port) {\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t  &server->addr.sockAddr,\n\t\t\t\t\t  sizeof(struct sockaddr_in), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\t/* save original port so we can retry user specified port\n\t\t\tlater if fall back ports fail this time  */\n\t\torig_port = server->addr.sockAddr.sin_port;\n\n\t\t/* do not retry on the same port we just failed on */\n\t\tif (server->addr.sockAddr.sin_port != htons(CIFS_PORT)) {\n\t\t\tserver->addr.sockAddr.sin_port = htons(CIFS_PORT);\n\t\t\trc = socket->ops->connect(socket,\n\t\t\t\t\t\t(struct sockaddr *)\n\t\t\t\t\t\t&server->addr.sockAddr,\n\t\t\t\t\t\tsizeof(struct sockaddr_in), 0);\n\t\t\tif (rc >= 0)\n\t\t\t\tconnected = true;\n\t\t}\n\t}\n\tif (!connected) {\n\t\tserver->addr.sockAddr.sin_port = htons(RFC1001_PORT);\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t      &server->addr.sockAddr,\n\t\t\t\t\t      sizeof(struct sockaddr_in), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\t/* give up here - unless we want to retry on different\n\t\tprotocol families some day */\n\tif (!connected) {\n\t\tif (orig_port)\n\t\t\tserver->addr.sockAddr.sin_port = orig_port;\n\t\tcFYI(1, \"Error %d connecting to server via ipv4\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t *  the default. sock_setsockopt not used because it expects\n\t *  user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tval = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\t cFYI(1, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\t/* send RFC1001 sessinit */\n\tif (server->addr.sockAddr.sin_port == htons(RFC1001_PORT)) {\n\t\t/* some servers require RFC1001 sessinit before sending\n\t\tnegprot - BB check reconnection in case where second\n\t\tsessinit is sent but no second negprot */\n\t\tstruct rfc1002_session_packet *ses_init_buf;\n\t\tstruct smb_hdr *smb_buf;\n\t\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ses_init_buf) {\n\t\t\tses_init_buf->trailer.session_req.called_len = 32;\n\t\t\tif (server->server_RFC1001_name &&\n\t\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.called_name,\n\t\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\t\telse\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.called_name,\n\t\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t\t/* calling name ends in null (byte 16) from old smb\n\t\t\tconvention. */\n\t\t\tif (server->workstation_RFC1001_name &&\n\t\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.calling_name,\n\t\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\t\telse\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.calling_name,\n\t\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\t\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\t\tsmb_buf->smb_buf_length = 0x81000044;\n\t\t\trc = smb_send(server, smb_buf, 0x44);\n\t\t\tkfree(ses_init_buf);\n\t\t\tmsleep(1); /* RFC1001 layer in at least one server\n\t\t\t\t      requires very short break before negprot\n\t\t\t\t      presumably because not expecting negprot\n\t\t\t\t      to follow so fast.  This is a simple\n\t\t\t\t      solution that works without\n\t\t\t\t      complicating the code and causes no\n\t\t\t\t      significant slowing down on mount\n\t\t\t\t      for everyone else */\n\t\t}\n\t\t/* else the negprot may still work without this\n\t\teven though malloc failed */\n\n\t}\n\n\treturn rc;\n}\n\nstatic int\nipv6_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tint val;\n\tbool connected = false;\n\t__be16 orig_port = 0;\n\tstruct socket *socket = server->ssocket;\n\n\tif (socket == NULL) {\n\t\trc = sock_create_kern(PF_INET6, SOCK_STREAM,\n\t\t\t\t      IPPROTO_TCP, &socket);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating ipv6 socket\", rc);\n\t\t\tsocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"ipv6 Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tcifs_reclassify_socket6(socket);\n\t}\n\n\t/* user overrode default port */\n\tif (server->addr.sockAddr6.sin6_port) {\n\t\trc = socket->ops->connect(socket,\n\t\t\t\t(struct sockaddr *) &server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\t/* save original port so we can retry user specified port\n\t\t\tlater if fall back ports fail this time  */\n\n\t\torig_port = server->addr.sockAddr6.sin6_port;\n\t\t/* do not retry on the same port we just failed on */\n\t\tif (server->addr.sockAddr6.sin6_port != htons(CIFS_PORT)) {\n\t\t\tserver->addr.sockAddr6.sin6_port = htons(CIFS_PORT);\n\t\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\t\tif (rc >= 0)\n\t\t\t\tconnected = true;\n\t\t}\n\t}\n\tif (!connected) {\n\t\tserver->addr.sockAddr6.sin6_port = htons(RFC1001_PORT);\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\t/* give up here - unless we want to retry on different\n\t\tprotocol families some day */\n\tif (!connected) {\n\t\tif (orig_port)\n\t\t\tserver->addr.sockAddr6.sin6_port = orig_port;\n\t\tcFYI(1, \"Error %d connecting to server via ipv6\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\tif (server->tcp_nodelay) {\n\t\tval = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\tserver->ssocket = socket;\n\n\treturn rc;\n}\n\nvoid reset_cifs_unix_caps(int xid, struct cifsTconInfo *tcon,\n\t\t\t  struct super_block *sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcFYI(1, \"Linux protocol extensions disabled\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcFYI(1, \"Unix extensions disabled so not set on reconnect\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcERROR(1, \"POSIXPATH support change\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcERROR(1, \"possible reconnect error\");\n\t\t\t\tcERROR(1, \"server disabled POSIX path support\");\n\t\t\t}\n\t\t}\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcFYI(1, \"negotiated posix acl support\");\n\t\t\tif (sb)\n\t\t\t\tsb->s_flags |= MS_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcFYI(1, \"negotiate posix pathnames\");\n\t\t\tif (sb)\n\t\t\t\tCIFS_SB(sb)->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\t/* We might be setting the path sep back to a different\n\t\tform if we are reconnecting and the server switched its\n\t\tposix path capability for this share */\n\t\tif (sb && (CIFS_SB(sb)->prepathlen > 0))\n\t\t\tCIFS_SB(sb)->prepath[0] = CIFS_DIR_SEP(CIFS_SB(sb));\n\n\t\tif (sb && (CIFS_SB(sb)->rsize > 127 * 1024)) {\n\t\t\tif ((cap & CIFS_UNIX_LARGE_READ_CAP) == 0) {\n\t\t\t\tCIFS_SB(sb)->rsize = 127 * 1024;\n\t\t\t\tcFYI(DBG2, \"larger reads not supported by srv\");\n\t\t\t}\n\t\t}\n\n\n\t\tcFYI(1, \"Negotiate caps 0x%x\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcFYI(1, \"FCNTL cap\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcFYI(1, \"EXTATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcFYI(1, \"POSIX path cap\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcFYI(1, \"XATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcFYI(1, \"POSIX ACL cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcFYI(1, \"very large read cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcFYI(1, \"very large write cap\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcFYI(1, \"resetting capabilities failed\");\n\t\t\t} else\n\t\t\t\tcERROR(1, \"Negotiating Unix capabilities \"\n\t\t\t\t\t   \"with the server failed.  Consider \"\n\t\t\t\t\t   \"mounting with the Unix Extensions\\n\"\n\t\t\t\t\t   \"disabled, if problems are found, \"\n\t\t\t\t\t   \"by specifying the nounix mount \"\n\t\t\t\t\t   \"option.\");\n\n\t\t}\n\t}\n}\n\nstatic void\nconvert_delimiter(char *path, char delim)\n{\n\tint i;\n\tchar old_delim;\n\n\tif (path == NULL)\n\t\treturn;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == old_delim)\n\t\t\tpath[i] = delim;\n\t}\n}\n\nstatic void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}\n\nstatic int\nis_path_accessible(int xid, struct cifsTconInfo *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *pfile_info;\n\n\tpfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (pfile_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, pfile_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_sb->mnt_cifs_flags &\n\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tkfree(pfile_info);\n\treturn rc;\n}\n\nstatic void\ncleanup_volume_info(struct smb_vol **pvolume_info)\n{\n\tstruct smb_vol *volume_info;\n\n\tif (!pvolume_info || !*pvolume_info)\n\t\treturn;\n\n\tvolume_info = *pvolume_info;\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->prepath);\n\tkfree(volume_info);\n\t*pvolume_info = NULL;\n\treturn;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* build_path_to_root returns full path to root when\n * we do not have an exiting connection (tcon) */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *volume_info,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path;\n\n\tint unc_len = strnlen(volume_info->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + cifs_sb->prepathlen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, volume_info->UNC, unc_len);\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\tint i;\n\t\tfor (i = 0; i < unc_len; i++) {\n\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\tfull_path[i] = '/';\n\t\t}\n\t}\n\n\tif (cifs_sb->prepathlen)\n\t\tstrncpy(full_path + unc_len, cifs_sb->prepath,\n\t\t\t\tcifs_sb->prepathlen);\n\n\tfull_path[unc_len + cifs_sb->prepathlen] = 0; /* add trailing null */\n\treturn full_path;\n}\n#endif\n\nint\ncifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\tcifs_sb->tcon = tcon;\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidently freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint\nCIFSTCon(unsigned int xid, struct cifsSesInfo *ses,\n\t const char *tree, struct cifsTconInfo *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length, bytes_left;\n\t__u16 count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = GetNextMid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif ((ses->server->secMode) & SECMODE_USER) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_SESS_KEY_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptKey,\n\t\t\t\t\t ses->server->secMode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\tSMBNTencrypt(tcon->password, ses->server->cryptKey,\n\t\t\t     bcc_ptr);\n\n\t\tbcc_ptr += CIFS_SESS_KEY_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->secMode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUCS((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length += count;\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t CIFS_STD_OP);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = BCC(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcFYI(1, \"IPC connection\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcFYI(1, \"disk share connection\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_ucs(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcFYI(1, \"nativeFileSystem=%s\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcFYI(1, \"Tcon flags: 0x%x \", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nint\ncifs_umount(struct super_block *sb, struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tchar *tmp;\n\n\tif (cifs_sb->tcon)\n\t\tcifs_put_tcon(cifs_sb->tcon);\n\n\tcifs_sb->tcon = NULL;\n\ttmp = cifs_sb->prepath;\n\tcifs_sb->prepathlen = 0;\n\tcifs_sb->prepath = NULL;\n\tkfree(tmp);\n\n\treturn rc;\n}\n\nint cifs_negotiate_protocol(unsigned int xid, struct cifsSesInfo *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/* only send once per connect */\n\tif (server->maxBuf != 0)\n\t\treturn 0;\n\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t}\n\n\treturn rc;\n}\n\n\nint cifs_setup_session(unsigned int xid, struct cifsSesInfo *ses,\n\t\t\tstruct nls_table *nls_info)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~CAP_UNIX);\n\n\tcFYI(1, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\",\n\t\t server->secMode, server->capabilities, server->timeAdj);\n\n\trc = CIFS_SessSetup(xid, ses, nls_info);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SessSetup = %d\", rc);\n\t} else {\n\t\tcFYI(1, \"CIFS Session Established successfully\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}\n\n"], "fixing_code": ["/*\n *   fs/cifs/cifsglob.h\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2008\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *              Jeremy Allison (jra@samba.org)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n */\n#ifndef _CIFS_GLOB_H\n#define _CIFS_GLOB_H\n\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/slab.h>\n#include <linux/slow-work.h>\n#include \"cifs_fs_sb.h\"\n#include \"cifsacl.h\"\n/*\n * The sizes of various internal tables and strings\n */\n#define MAX_UID_INFO 16\n#define MAX_SES_INFO 2\n#define MAX_TCON_INFO 4\n\n#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)\n#define MAX_SERVER_SIZE 15\n#define MAX_SHARE_SIZE  64\t/* used to be 20, this should still be enough */\n#define MAX_USERNAME_SIZE 32\t/* 32 is to allow for 15 char names + null\n\t\t\t\t   termination then *2 for unicode versions */\n#define MAX_PASSWORD_SIZE 512  /* max for windows seems to be 256 wide chars */\n\n#define CIFS_MIN_RCV_POOL 4\n\n/*\n * MAX_REQ is the maximum number of requests that WE will send\n * on one socket concurrently. It also matches the most common\n * value of max multiplex returned by servers.  We may\n * eventually want to use the negotiated value (in case\n * future servers can handle more) when we are more confident that\n * we will not have problems oveloading the socket with pending\n * write data.\n */\n#define CIFS_MAX_REQ 50\n\n#define RFC1001_NAME_LEN 15\n#define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)\n\n/* currently length of NIP6_FMT */\n#define SERVER_NAME_LENGTH 40\n#define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)\n\n/* used to define string lengths for reversing unicode strings */\n/*         (256+1)*2 = 514                                     */\n/*           (max path length + 1 for null) * 2 for unicode    */\n#define MAX_NAME 514\n\n#include \"cifspdu.h\"\n\n#ifndef XATTR_DOS_ATTRIB\n#define XATTR_DOS_ATTRIB \"user.DOSATTRIB\"\n#endif\n\n/*\n * CIFS vfs client Status information (based on what we know.)\n */\n\n /* associated with each tcp and smb session */\nenum statusEnum {\n\tCifsNew = 0,\n\tCifsGood,\n\tCifsExiting,\n\tCifsNeedReconnect\n};\n\nenum securityEnum {\n\tLANMAN = 0,\t\t\t/* Legacy LANMAN auth */\n\tNTLM,\t\t\t/* Legacy NTLM012 auth with NTLM hash */\n\tNTLMv2,\t\t\t/* Legacy NTLM auth with NTLMv2 hash */\n\tRawNTLMSSP,\t\t/* NTLMSSP without SPNEGO, NTLMv2 hash */\n/*\tNTLMSSP, */ /* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */\n\tKerberos,\t\t/* Kerberos via SPNEGO */\n};\n\nenum protocolEnum {\n\tTCP = 0,\n\tSCTP\n\t/* Netbios frames protocol not supported at this time */\n};\n\nstruct mac_key {\n\tunsigned int len;\n\tunion {\n\t\tchar ntlm[CIFS_SESS_KEY_SIZE + 16];\n\t\tchar krb5[CIFS_SESS_KEY_SIZE + 16]; /* BB: length correct? */\n\t\tstruct {\n\t\t\tchar key[16];\n\t\t\tstruct ntlmv2_resp resp;\n\t\t} ntlmv2;\n\t} data;\n};\n\nstruct cifs_cred {\n\tint uid;\n\tint gid;\n\tint mode;\n\tint cecount;\n\tstruct cifs_sid osid;\n\tstruct cifs_sid gsid;\n\tstruct cifs_ntace *ntaces;\n\tstruct cifs_ace *aces;\n};\n\n/*\n *****************************************************************\n * Except the CIFS PDUs themselves all the\n * globally interesting structs should go here\n *****************************************************************\n */\n\nstruct TCP_Server_Info {\n\tstruct list_head tcp_ses_list;\n\tstruct list_head smb_ses_list;\n\tint srv_count; /* reference counter */\n\t/* 15 character server name + 0x20 16th byte indicating type = srv */\n\tchar server_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\tchar *hostname; /* hostname portion of UNC string */\n\tstruct socket *ssocket;\n\tunion {\n\t\tstruct sockaddr_in sockAddr;\n\t\tstruct sockaddr_in6 sockAddr6;\n\t} addr;\n\twait_queue_head_t response_q;\n\twait_queue_head_t request_q; /* if more than maxmpx to srvr must block*/\n\tstruct list_head pending_mid_q;\n\tvoid *Server_NlsInfo;\t/* BB - placeholder for future NLS info  */\n\tunsigned short server_codepage;\t/* codepage for the server    */\n\tenum protocolEnum protocolType;\n\tchar versionMajor;\n\tchar versionMinor;\n\tbool svlocal:1;\t\t\t/* local server or remote */\n\tbool noblocksnd;\t\t/* use blocking sendmsg */\n\tbool noautotune;\t\t/* do not autotune send buf sizes */\n\tbool tcp_nodelay;\n\tatomic_t inFlight;  /* number of requests on the wire to server */\n#ifdef CONFIG_CIFS_STATS2\n\tatomic_t inSend; /* requests trying to send */\n\tatomic_t num_waiters;   /* blocked waiting to get in sendrecv */\n#endif\n\tenum statusEnum tcpStatus; /* what we think the status is */\n\tstruct mutex srv_mutex;\n\tstruct task_struct *tsk;\n\tchar server_GUID[16];\n\tchar secMode;\n\tenum securityEnum secType;\n\tunsigned int maxReq;\t/* Clients should submit no more */\n\t/* than maxReq distinct unanswered SMBs to the server when using  */\n\t/* multiplexed reads or writes */\n\tunsigned int maxBuf;\t/* maxBuf specifies the maximum */\n\t/* message size the server can send or receive for non-raw SMBs */\n\tunsigned int max_rw;\t/* maxRw specifies the maximum */\n\t/* message size the server can send or receive for */\n\t/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */\n\tunsigned int max_vcs;\t/* maximum number of smb sessions, at least\n\t\t\t\t   those that can be specified uniquely with\n\t\t\t\t   vcnumbers */\n\tchar sessid[4];\t\t/* unique token id for this session */\n\t/* (returned on Negotiate */\n\tint capabilities; /* allow selective disabling of caps by smb sess */\n\tint timeAdj;  /* Adjust for difference in server time zone in sec */\n\t__u16 CurrentMid;         /* multiplex id - rotating counter */\n\tchar cryptKey[CIFS_CRYPTO_KEY_SIZE];\n\t/* 16th byte of RFC1001 workstation name is always null */\n\tchar workstation_RFC1001_name[RFC1001_NAME_LEN_WITH_NULL];\n\t__u32 sequence_number; /* needed for CIFS PDU signature */\n\tstruct mac_key mac_signing_key;\n\tchar ntlmv2_hash[16];\n\tunsigned long lstrp; /* when we got last response from this server */\n\tu16 dialect; /* dialect index that server chose */\n\t/* extended security flavors that server supports */\n\tbool\tsec_kerberos;\t\t/* supports plain Kerberos */\n\tbool\tsec_mskerberos;\t\t/* supports legacy MS Kerberos */\n\tbool\tsec_kerberosu2u;\t/* supports U2U Kerberos */\n\tbool\tsec_ntlmssp;\t\t/* supports NTLMSSP */\n#ifdef CONFIG_CIFS_FSCACHE\n\tstruct fscache_cookie   *fscache; /* client index cache cookie */\n#endif\n};\n\n/*\n * The following is our shortcut to user information.  We surface the uid,\n * and name. We always get the password on the fly in case it\n * has changed. We also hang a list of sessions owned by this user off here.\n */\nstruct cifsUidInfo {\n\tstruct list_head userList;\n\tstruct list_head sessionList; /* SMB sessions for this user */\n\tuid_t linux_uid;\n\tchar user[MAX_USERNAME_SIZE + 1];\t/* ascii name of user */\n\t/* BB may need ptr or callback for PAM or WinBind info */\n};\n\n/*\n * Session structure.  One of these for each uid session with a particular host\n */\nstruct cifsSesInfo {\n\tstruct list_head smb_ses_list;\n\tstruct list_head tcon_list;\n\tstruct mutex session_mutex;\n#if 0\n\tstruct cifsUidInfo *uidInfo;\t/* pointer to user info */\n#endif\n\tstruct TCP_Server_Info *server;\t/* pointer to server info */\n\tint ses_count;\t\t/* reference counter */\n\tenum statusEnum status;\n\tunsigned overrideSecFlg;  /* if non-zero override global sec flags */\n\t__u16 ipc_tid;\t\t/* special tid for connection to IPC share */\n\t__u16 flags;\n\t__u16 vcnum;\n\tchar *serverOS;\t\t/* name of operating system underlying server */\n\tchar *serverNOS;\t/* name of network operating system of server */\n\tchar *serverDomain;\t/* security realm of server */\n\tint Suid;\t\t/* remote smb uid  */\n\tuid_t linux_uid;        /* local Linux uid */\n\tint capabilities;\n\tchar serverName[SERVER_NAME_LEN_WITH_NULL * 2];\t/* BB make bigger for\n\t\t\t\tTCP names - will ipv6 and sctp addresses fit? */\n\tchar userName[MAX_USERNAME_SIZE + 1];\n\tchar *domainName;\n\tchar *password;\n\tbool need_reconnect:1; /* connection reset, uid now invalid */\n};\n/* no more than one of the following three session flags may be set */\n#define CIFS_SES_NT4 1\n#define CIFS_SES_OS2 2\n#define CIFS_SES_W9X 4\n/* following flag is set for old servers such as OS2 (and Win95?)\n   which do not negotiate NTLM or POSIX dialects, but instead\n   negotiate one of the older LANMAN dialects */\n#define CIFS_SES_LANMAN 8\n/*\n * there is one of these for each connection to a resource on a particular\n * session\n */\nstruct cifsTconInfo {\n\tstruct list_head tcon_list;\n\tint tc_count;\n\tstruct list_head openFileList;\n\tstruct cifsSesInfo *ses;\t/* pointer to session associated with */\n\tchar treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */\n\tchar *nativeFileSystem;\n\tchar *password;\t\t/* for share-level security */\n\t__u16 tid;\t\t/* The 2 byte tree id */\n\t__u16 Flags;\t\t/* optional support bits */\n\tenum statusEnum tidStatus;\n#ifdef CONFIG_CIFS_STATS\n\tatomic_t num_smbs_sent;\n\tatomic_t num_writes;\n\tatomic_t num_reads;\n\tatomic_t num_flushes;\n\tatomic_t num_oplock_brks;\n\tatomic_t num_opens;\n\tatomic_t num_closes;\n\tatomic_t num_deletes;\n\tatomic_t num_mkdirs;\n\tatomic_t num_posixopens;\n\tatomic_t num_posixmkdirs;\n\tatomic_t num_rmdirs;\n\tatomic_t num_renames;\n\tatomic_t num_t2renames;\n\tatomic_t num_ffirst;\n\tatomic_t num_fnext;\n\tatomic_t num_fclose;\n\tatomic_t num_hardlinks;\n\tatomic_t num_symlinks;\n\tatomic_t num_locks;\n\tatomic_t num_acl_get;\n\tatomic_t num_acl_set;\n#ifdef CONFIG_CIFS_STATS2\n\tunsigned long long time_writes;\n\tunsigned long long time_reads;\n\tunsigned long long time_opens;\n\tunsigned long long time_deletes;\n\tunsigned long long time_closes;\n\tunsigned long long time_mkdirs;\n\tunsigned long long time_rmdirs;\n\tunsigned long long time_renames;\n\tunsigned long long time_t2renames;\n\tunsigned long long time_ffirst;\n\tunsigned long long time_fnext;\n\tunsigned long long time_fclose;\n#endif /* CONFIG_CIFS_STATS2 */\n\t__u64    bytes_read;\n\t__u64    bytes_written;\n\tspinlock_t stat_lock;\n#endif /* CONFIG_CIFS_STATS */\n\tFILE_SYSTEM_DEVICE_INFO fsDevInfo;\n\tFILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */\n\tFILE_SYSTEM_UNIX_INFO fsUnixInfo;\n\tbool ipc:1;\t\t/* set if connection to IPC$ eg for RPC/PIPES */\n\tbool retry:1;\n\tbool nocase:1;\n\tbool seal:1;      /* transport encryption for this mounted share */\n\tbool unix_ext:1;  /* if false disable Linux extensions to CIFS protocol\n\t\t\t\tfor this mount even if server would support */\n\tbool local_lease:1; /* check leases (only) on local system not remote */\n\tbool broken_posix_open; /* e.g. Samba server versions < 3.3.2, 3.2.9 */\n\tbool need_reconnect:1; /* connection reset, tid now invalid */\n\t/* BB add field for back pointer to sb struct(s)? */\n};\n\n/*\n * This info hangs off the cifsFileInfo structure, pointed to by llist.\n * This is used to track byte stream locks on the file\n */\nstruct cifsLockInfo {\n\tstruct list_head llist;\t/* pointer to next cifsLockInfo */\n\t__u64 offset;\n\t__u64 length;\n\t__u8 type;\n};\n\n/*\n * One of these for each open instance of a file\n */\nstruct cifs_search_info {\n\tloff_t index_of_last_entry;\n\t__u16 entries_in_buffer;\n\t__u16 info_level;\n\t__u32 resume_key;\n\tchar *ntwrk_buf_start;\n\tchar *srch_entries_start;\n\tchar *last_entry;\n\tchar *presume_name;\n\tunsigned int resume_name_len;\n\tbool endOfSearch:1;\n\tbool emptyDir:1;\n\tbool unicode:1;\n\tbool smallBuf:1; /* so we know which buf_release function to call */\n};\n\nstruct cifsFileInfo {\n\tstruct list_head tlist;\t/* pointer to next fid owned by tcon */\n\tstruct list_head flist;\t/* next fid (file instance) for this inode */\n\tunsigned int uid;\t/* allows finding which FileInfo structure */\n\t__u32 pid;\t\t/* process id who opened file */\n\t__u16 netfid;\t\t/* file id from remote */\n\t/* BB add lock scope info here if needed */ ;\n\t/* lock scope id (0 if none) */\n\tstruct file *pfile; /* needed for writepage */\n\tstruct inode *pInode; /* needed for oplock break */\n\tstruct vfsmount *mnt;\n\tstruct mutex lock_mutex;\n\tstruct list_head llist; /* list of byte range locks we have. */\n\tbool closePend:1;\t/* file is marked to close */\n\tbool invalidHandle:1;\t/* file closed via session abend */\n\tbool oplock_break_cancelled:1;\n\tatomic_t count;\t\t/* reference count */\n\tstruct mutex fh_mutex; /* prevents reopen race after dead ses*/\n\tstruct cifs_search_info srch_inf;\n\tstruct slow_work oplock_break; /* slow_work job for oplock breaks */\n};\n\n/* Take a reference on the file private data */\nstatic inline void cifsFileInfo_get(struct cifsFileInfo *cifs_file)\n{\n\tatomic_inc(&cifs_file->count);\n}\n\n/* Release a reference on the file private data */\nstatic inline void cifsFileInfo_put(struct cifsFileInfo *cifs_file)\n{\n\tif (atomic_dec_and_test(&cifs_file->count)) {\n\t\tiput(cifs_file->pInode);\n\t\tkfree(cifs_file);\n\t}\n}\n\n/*\n * One of these for each file inode\n */\n\nstruct cifsInodeInfo {\n\tstruct list_head lockList;\n\t/* BB add in lists for dirty pages i.e. write caching info for oplock */\n\tstruct list_head openFileList;\n\tint write_behind_rc;\n\t__u32 cifsAttrs; /* e.g. DOS archive bit, sparse, compressed, system */\n\tunsigned long time;\t/* jiffies of last update/check of inode */\n\tbool clientCanCacheRead:1;\t/* read oplock */\n\tbool clientCanCacheAll:1;\t/* read and writebehind oplock */\n\tbool delete_pending:1;\t\t/* DELETE_ON_CLOSE is set */\n\tbool invalid_mapping:1;\t\t/* pagecache is invalid */\n\tu64  server_eof;\t\t/* current file size on server */\n\tu64  uniqueid;\t\t\t/* server inode number */\n\tstruct inode vfs_inode;\n};\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}\n\n#ifdef CONFIG_CIFS_STATS\n#define cifs_stats_inc atomic_inc\n\nstatic inline void cifs_stats_bytes_written(struct cifsTconInfo *tcon,\n\t\t\t\t\t    unsigned int bytes)\n{\n\tif (bytes) {\n\t\tspin_lock(&tcon->stat_lock);\n\t\ttcon->bytes_written += bytes;\n\t\tspin_unlock(&tcon->stat_lock);\n\t}\n}\n\nstatic inline void cifs_stats_bytes_read(struct cifsTconInfo *tcon,\n\t\t\t\t\t unsigned int bytes)\n{\n\tspin_lock(&tcon->stat_lock);\n\ttcon->bytes_read += bytes;\n\tspin_unlock(&tcon->stat_lock);\n}\n#else\n\n#define  cifs_stats_inc(field) do {} while (0)\n#define  cifs_stats_bytes_written(tcon, bytes) do {} while (0)\n#define  cifs_stats_bytes_read(tcon, bytes) do {} while (0)\n\n#endif\n\n/* one of these for every pending CIFS request to the server */\nstruct mid_q_entry {\n\tstruct list_head qhead;\t/* mids waiting on reply from this server */\n\t__u16 mid;\t\t/* multiplex id */\n\t__u16 pid;\t\t/* process id */\n\t__u32 sequence_number;  /* for CIFS signing */\n\tunsigned long when_alloc;  /* when mid was created */\n#ifdef CONFIG_CIFS_STATS2\n\tunsigned long when_sent; /* time when smb send finished */\n\tunsigned long when_received; /* when demux complete (taken off wire) */\n#endif\n\tstruct task_struct *tsk;\t/* task waiting for response */\n\tstruct smb_hdr *resp_buf;\t/* response buffer */\n\tint midState;\t/* wish this were enum but can not pass to wait_event */\n\t__u8 command;\t/* smb command code */\n\tbool largeBuf:1;\t/* if valid response, is pointer to large buf */\n\tbool multiRsp:1;\t/* multiple trans2 responses for one request  */\n\tbool multiEnd:1;\t/* both received */\n};\n\nstruct oplock_q_entry {\n\tstruct list_head qhead;\n\tstruct inode *pinode;\n\tstruct cifsTconInfo *tcon;\n\t__u16 netfid;\n};\n\n/* for pending dnotify requests */\nstruct dir_notify_req {\n       struct list_head lhead;\n       __le16 Pid;\n       __le16 PidHigh;\n       __u16 Mid;\n       __u16 Tid;\n       __u16 Uid;\n       __u16 netfid;\n       __u32 filter; /* CompletionFilter (for multishot) */\n       int multishot;\n       struct file *pfile;\n};\n\nstruct dfs_info3_param {\n\tint flags; /* DFSREF_REFERRAL_SERVER, DFSREF_STORAGE_SERVER*/\n\tint path_consumed;\n\tint server_type;\n\tint ref_flag;\n\tchar *path_name;\n\tchar *node_name;\n};\n\n/*\n * common struct for holding inode info when searching for or updating an\n * inode with new info\n */\n\n#define CIFS_FATTR_DFS_REFERRAL\t\t0x1\n#define CIFS_FATTR_DELETE_PENDING\t0x2\n#define CIFS_FATTR_NEED_REVAL\t\t0x4\n#define CIFS_FATTR_INO_COLLISION\t0x8\n\nstruct cifs_fattr {\n\tu32\t\tcf_flags;\n\tu32\t\tcf_cifsattrs;\n\tu64\t\tcf_uniqueid;\n\tu64\t\tcf_eof;\n\tu64\t\tcf_bytes;\n\tuid_t\t\tcf_uid;\n\tgid_t\t\tcf_gid;\n\tumode_t\t\tcf_mode;\n\tdev_t\t\tcf_rdev;\n\tunsigned int\tcf_nlink;\n\tunsigned int\tcf_dtype;\n\tstruct timespec\tcf_atime;\n\tstruct timespec\tcf_mtime;\n\tstruct timespec\tcf_ctime;\n};\n\nstatic inline void free_dfs_info_param(struct dfs_info3_param *param)\n{\n\tif (param) {\n\t\tkfree(param->path_name);\n\t\tkfree(param->node_name);\n\t\tkfree(param);\n\t}\n}\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}\n\n#define   MID_FREE 0\n#define   MID_REQUEST_ALLOCATED 1\n#define   MID_REQUEST_SUBMITTED 2\n#define   MID_RESPONSE_RECEIVED 4\n#define   MID_RETRY_NEEDED      8 /* session closed while this request out */\n#define   MID_NO_RESP_NEEDED 0x10\n\n/* Types of response buffer returned from SendReceive2 */\n#define   CIFS_NO_BUFFER        0    /* Response buffer not returned */\n#define   CIFS_SMALL_BUFFER     1\n#define   CIFS_LARGE_BUFFER     2\n#define   CIFS_IOVEC            4    /* array of response buffers */\n\n/* Type of Request to SendReceive2 */\n#define   CIFS_STD_OP\t        0    /* normal request timeout */\n#define   CIFS_LONG_OP          1    /* long op (up to 45 sec, oplock time) */\n#define   CIFS_VLONG_OP         2    /* sloow op - can take up to 180 seconds */\n#define   CIFS_BLOCKING_OP      4    /* operation can block */\n#define   CIFS_ASYNC_OP         8    /* do not wait for response */\n#define   CIFS_TIMEOUT_MASK 0x00F    /* only one of 5 above set in req */\n#define   CIFS_LOG_ERROR    0x010    /* log NT STATUS if non-zero */\n#define   CIFS_LARGE_BUF_OP 0x020    /* large request buffer */\n#define   CIFS_NO_RESP      0x040    /* no response buffer required */\n\n/* Security Flags: indicate type of session setup needed */\n#define   CIFSSEC_MAY_SIGN\t0x00001\n#define   CIFSSEC_MAY_NTLM\t0x00002\n#define   CIFSSEC_MAY_NTLMV2\t0x00004\n#define   CIFSSEC_MAY_KRB5\t0x00008\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define   CIFSSEC_MAY_LANMAN\t0x00010\n#define   CIFSSEC_MAY_PLNTXT\t0x00020\n#else\n#define   CIFSSEC_MAY_LANMAN    0\n#define   CIFSSEC_MAY_PLNTXT    0\n#endif /* weak passwords */\n#define   CIFSSEC_MAY_SEAL\t0x00040 /* not supported yet */\n#define   CIFSSEC_MAY_NTLMSSP\t0x00080 /* raw ntlmssp with ntlmv2 */\n\n#define   CIFSSEC_MUST_SIGN\t0x01001\n/* note that only one of the following can be set so the\nresult of setting MUST flags more than once will be to\nrequire use of the stronger protocol */\n#define   CIFSSEC_MUST_NTLM\t0x02002\n#define   CIFSSEC_MUST_NTLMV2\t0x04004\n#define   CIFSSEC_MUST_KRB5\t0x08008\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n#define   CIFSSEC_MUST_LANMAN\t0x10010\n#define   CIFSSEC_MUST_PLNTXT\t0x20020\n#ifdef CONFIG_CIFS_UPCALL\n#define   CIFSSEC_MASK          0xBF0BF /* allows weak security but also krb5 */\n#else\n#define   CIFSSEC_MASK          0xB70B7 /* current flags supported if weak */\n#endif /* UPCALL */\n#else /* do not allow weak pw hash */\n#ifdef CONFIG_CIFS_UPCALL\n#define   CIFSSEC_MASK          0x8F08F /* flags supported if no weak allowed */\n#else\n#define\t  CIFSSEC_MASK          0x87087 /* flags supported if no weak allowed */\n#endif /* UPCALL */\n#endif /* WEAK_PW_HASH */\n#define   CIFSSEC_MUST_SEAL\t0x40040 /* not supported yet */\n#define   CIFSSEC_MUST_NTLMSSP\t0x80080 /* raw ntlmssp with ntlmv2 */\n\n#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)\n#define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)\n#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)\n/*\n *****************************************************************\n * All constants go here\n *****************************************************************\n */\n\n#define UID_HASH (16)\n\n/*\n * Note that ONE module should define _DECLARE_GLOBALS_HERE to cause the\n * following to be declared.\n */\n\n/****************************************************************************\n *  Locking notes.  All updates to global variables and lists should be\n *                  protected by spinlocks or semaphores.\n *\n *  Spinlocks\n *  ---------\n *  GlobalMid_Lock protects:\n *\tlist operations on pending_mid_q and oplockQ\n *      updates to XID counters, multiplex id  and SMB sequence numbers\n *  GlobalSMBSesLock protects:\n *\tlist operations on tcp and SMB session lists and tCon lists\n *  f_owner.lock protects certain per file struct operations\n *  mapping->page_lock protects certain per page operations\n *\n *  Semaphores\n *  ----------\n *  sesSem     operations on smb session\n *  tconSem    operations on tree connection\n *  fh_sem      file handle reconnection operations\n *\n ****************************************************************************/\n\n#ifdef DECLARE_GLOBALS_HERE\n#define GLOBAL_EXTERN\n#else\n#define GLOBAL_EXTERN extern\n#endif\n\n/*\n * the list of TCP_Server_Info structures, ie each of the sockets\n * connecting our client to a distinct server (ip address), is\n * chained together by cifs_tcp_ses_list. The list of all our SMB\n * sessions (and from that the tree connections) can be found\n * by iterating over cifs_tcp_ses_list\n */\nGLOBAL_EXTERN struct list_head\t\tcifs_tcp_ses_list;\n\n/*\n * This lock protects the cifs_tcp_ses_list, the list of smb sessions per\n * tcp session, and the list of tcon's per smb session. It also protects\n * the reference counters for the server, smb session, and tcon. Finally,\n * changes to the tcon->tidStatus should be done while holding this lock.\n */\nGLOBAL_EXTERN rwlock_t\t\tcifs_tcp_ses_lock;\n\n/*\n * This lock protects the cifs_file->llist and cifs_file->flist\n * list operations, and updates to some flags (cifs_file->invalidHandle)\n * It will be moved to either use the tcon->stat_lock or equivalent later.\n * If cifs_tcp_ses_lock and the lock below are both needed to be held, then\n * the cifs_tcp_ses_lock must be grabbed first and released last.\n */\nGLOBAL_EXTERN rwlock_t GlobalSMBSeslock;\n\n/* Outstanding dir notify requests */\nGLOBAL_EXTERN struct list_head GlobalDnotifyReqList;\n/* DirNotify response queue */\nGLOBAL_EXTERN struct list_head GlobalDnotifyRsp_Q;\n\n/*\n * Global transaction id (XID) information\n */\nGLOBAL_EXTERN unsigned int GlobalCurrentXid;\t/* protected by GlobalMid_Sem */\nGLOBAL_EXTERN unsigned int GlobalTotalActiveXid; /* prot by GlobalMid_Sem */\nGLOBAL_EXTERN unsigned int GlobalMaxActiveXid;\t/* prot by GlobalMid_Sem */\nGLOBAL_EXTERN spinlock_t GlobalMid_Lock;  /* protects above & list operations */\n\t\t\t\t\t  /* on midQ entries */\nGLOBAL_EXTERN char Local_System_Name[15];\n\n/*\n *  Global counters, updated atomically\n */\nGLOBAL_EXTERN atomic_t sesInfoAllocCount;\nGLOBAL_EXTERN atomic_t tconInfoAllocCount;\nGLOBAL_EXTERN atomic_t tcpSesAllocCount;\nGLOBAL_EXTERN atomic_t tcpSesReconnectCount;\nGLOBAL_EXTERN atomic_t tconInfoReconnectCount;\n\n/* Various Debug counters */\nGLOBAL_EXTERN atomic_t bufAllocCount;    /* current number allocated  */\n#ifdef CONFIG_CIFS_STATS2\nGLOBAL_EXTERN atomic_t totBufAllocCount; /* total allocated over all time */\nGLOBAL_EXTERN atomic_t totSmBufAllocCount;\n#endif\nGLOBAL_EXTERN atomic_t smBufAllocCount;\nGLOBAL_EXTERN atomic_t midCount;\n\n/* Misc globals */\nGLOBAL_EXTERN unsigned int multiuser_mount; /* if enabled allows new sessions\n\t\t\t\tto be established on existing mount if we\n\t\t\t\thave the uid/password or Kerberos credential\n\t\t\t\tor equivalent for current user */\nGLOBAL_EXTERN unsigned int oplockEnabled;\nGLOBAL_EXTERN unsigned int experimEnabled;\nGLOBAL_EXTERN unsigned int lookupCacheEnabled;\nGLOBAL_EXTERN unsigned int global_secflags;\t/* if on, session setup sent\n\t\t\t\twith more secure ntlmssp2 challenge/resp */\nGLOBAL_EXTERN unsigned int sign_CIFS_PDUs;  /* enable smb packet signing */\nGLOBAL_EXTERN unsigned int linuxExtEnabled;/*enable Linux/Unix CIFS extensions*/\nGLOBAL_EXTERN unsigned int CIFSMaxBufSize;  /* max size not including hdr */\nGLOBAL_EXTERN unsigned int cifs_min_rcv;    /* min size of big ntwrk buf pool */\nGLOBAL_EXTERN unsigned int cifs_min_small;  /* min size of small buf pool */\nGLOBAL_EXTERN unsigned int cifs_max_pending; /* MAX requests at once to server*/\n\nextern const struct slow_work_ops cifs_oplock_break_ops;\n\n#endif\t/* _CIFS_GLOB_H */\n", "/*\n *   fs/cifs/connect.c\n *\n *   Copyright (C) International Business Machines  Corp., 2002,2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n#include <linux/fs.h>\n#include <linux/net.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/ctype.h>\n#include <linux/utsname.h>\n#include <linux/mempool.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/pagevec.h>\n#include <linux/freezer.h>\n#include <linux/namei.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/inet.h>\n#include <net/ipv6.h>\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_fs_sb.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include \"rfc1002pdu.h\"\n#include \"cn_cifs.h\"\n#include \"fscache.h\"\n\n#define CIFS_PORT 445\n#define RFC1001_PORT 139\n\nextern void SMBNTencrypt(unsigned char *passwd, unsigned char *c8,\n\t\t\t unsigned char *p24);\n\nextern mempool_t *cifs_req_poolp;\n\nstruct smb_vol {\n\tchar *username;\n\tchar *password;\n\tchar *domainname;\n\tchar *UNC;\n\tchar *UNCip;\n\tchar *iocharset;  /* local code page for mapping to and from Unicode */\n\tchar source_rfc1001_name[16]; /* netbios name of client */\n\tchar target_rfc1001_name[16]; /* netbios name of server for Win9x/ME */\n\tuid_t linux_uid;\n\tgid_t linux_gid;\n\tmode_t file_mode;\n\tmode_t dir_mode;\n\tunsigned secFlg;\n\tbool retry:1;\n\tbool intr:1;\n\tbool setuids:1;\n\tbool override_uid:1;\n\tbool override_gid:1;\n\tbool dynperm:1;\n\tbool noperm:1;\n\tbool no_psx_acl:1; /* set if posix acl support should be disabled */\n\tbool cifs_acl:1;\n\tbool no_xattr:1;   /* set if xattr (EA) support should be disabled*/\n\tbool server_ino:1; /* use inode numbers from server ie UniqueId */\n\tbool direct_io:1;\n\tbool remap:1;      /* set to remap seven reserved chars in filenames */\n\tbool posix_paths:1; /* unset to not ask for posix pathnames. */\n\tbool no_linux_ext:1;\n\tbool sfu_emul:1;\n\tbool nullauth:1;   /* attempt to authenticate with null user */\n\tbool nocase:1;     /* request case insensitive filenames */\n\tbool nobrl:1;      /* disable sending byte range locks to srv */\n\tbool mand_lock:1;  /* send mandatory not posix byte range lock reqs */\n\tbool seal:1;       /* request transport encryption on share */\n\tbool nodfs:1;      /* Do not request DFS, even if available */\n\tbool local_lease:1; /* check leases only on local system, not remote */\n\tbool noblocksnd:1;\n\tbool noautotune:1;\n\tbool nostrictsync:1; /* do not force expensive SMBflush on every sync */\n\tunsigned int rsize;\n\tunsigned int wsize;\n\tbool sockopt_tcp_nodelay:1;\n\tunsigned short int port;\n\tchar *prepath;\n\tstruct nls_table *local_nls;\n};\n\nstatic int ipv4_connect(struct TCP_Server_Info *server);\nstatic int ipv6_connect(struct TCP_Server_Info *server);\n\n/*\n * cifs tcp session reconnection\n *\n * mark tcp session as reconnecting so temporarily locked\n * mark all smb sessions as reconnecting for tcp session\n * reconnect tcp session\n * wake up waiters on reconnection? - (not needed currently)\n */\nstatic int\ncifs_reconnect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tstruct list_head *tmp, *tmp2;\n\tstruct cifsSesInfo *ses;\n\tstruct cifsTconInfo *tcon;\n\tstruct mid_q_entry *mid_entry;\n\n\tspin_lock(&GlobalMid_Lock);\n\tif (server->tcpStatus == CifsExiting) {\n\t\t/* the demux thread will exit normally\n\t\tnext time through the loop */\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\treturn rc;\n\t} else\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\tspin_unlock(&GlobalMid_Lock);\n\tserver->maxBuf = 0;\n\n\tcFYI(1, \"Reconnecting tcp session\");\n\n\t/* before reconnecting the tcp session, mark the smb session (uid)\n\t\tand the tid bad so they are not used until reconnected */\n\tread_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->need_reconnect = true;\n\t\tses->ipc_tid = 0;\n\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp2, struct cifsTconInfo, tcon_list);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t}\n\tread_unlock(&cifs_tcp_ses_lock);\n\t/* do not want to be sending data on a socket we are freeing */\n\tmutex_lock(&server->srv_mutex);\n\tif (server->ssocket) {\n\t\tcFYI(1, \"State: 0x%x Flags: 0x%lx\", server->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tkernel_sock_shutdown(server->ssocket, SHUT_WR);\n\t\tcFYI(1, \"Post shutdown state: 0x%x Flags: 0x%lx\",\n\t\t\tserver->ssocket->state,\n\t\t\tserver->ssocket->flags);\n\t\tsock_release(server->ssocket);\n\t\tserver->ssocket = NULL;\n\t}\n\n\tspin_lock(&GlobalMid_Lock);\n\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct\n\t\t\t\t\tmid_q_entry,\n\t\t\t\t\tqhead);\n\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED) {\n\t\t\t\t/* Mark other intransit requests as needing\n\t\t\t\t   retry so we do not immediately mark the\n\t\t\t\t   session bad again (ie after we reconnect\n\t\t\t\t   below) as they timeout too */\n\t\t\tmid_entry->midState = MID_RETRY_NEEDED;\n\t\t}\n\t}\n\tspin_unlock(&GlobalMid_Lock);\n\tmutex_unlock(&server->srv_mutex);\n\n\twhile ((server->tcpStatus != CifsExiting) &&\n\t       (server->tcpStatus != CifsGood)) {\n\t\ttry_to_freeze();\n\t\tif (server->addr.sockAddr6.sin6_family == AF_INET6)\n\t\t\trc = ipv6_connect(server);\n\t\telse\n\t\t\trc = ipv4_connect(server);\n\t\tif (rc) {\n\t\t\tcFYI(1, \"reconnect error %d\", rc);\n\t\t\tmsleep(3000);\n\t\t} else {\n\t\t\tatomic_inc(&tcpSesReconnectCount);\n\t\t\tspin_lock(&GlobalMid_Lock);\n\t\t\tif (server->tcpStatus != CifsExiting)\n\t\t\t\tserver->tcpStatus = CifsGood;\n\t\t\tserver->sequence_number = 0;\n\t\t\tspin_unlock(&GlobalMid_Lock);\n\t/*\t\tatomic_set(&server->inFlight,0);*/\n\t\t\twake_up(&server->response_q);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/*\n\treturn codes:\n\t\t0 \tnot a transact2, or all data present\n\t\t>0 \ttransact2 with that much data missing\n\t\t-EINVAL = invalid transact2\n\n */\nstatic int check2ndT2(struct smb_hdr *pSMB, unsigned int maxBufSize)\n{\n\tstruct smb_t2_rsp *pSMBt;\n\tint total_data_size;\n\tint data_in_this_rsp;\n\tint remaining;\n\n\tif (pSMB->Command != SMB_COM_TRANSACTION2)\n\t\treturn 0;\n\n\t/* check for plausible wct, bcc and t2 data and parm sizes */\n\t/* check for parm and data offset going beyond end of smb */\n\tif (pSMB->WordCount != 10) { /* coalesce_t2 depends on this */\n\t\tcFYI(1, \"invalid transact2 word count\");\n\t\treturn -EINVAL;\n\t}\n\n\tpSMBt = (struct smb_t2_rsp *)pSMB;\n\n\ttotal_data_size = le16_to_cpu(pSMBt->t2_rsp.TotalDataCount);\n\tdata_in_this_rsp = le16_to_cpu(pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - data_in_this_rsp;\n\n\tif (remaining == 0)\n\t\treturn 0;\n\telse if (remaining < 0) {\n\t\tcFYI(1, \"total data %d smaller than data in frame %d\",\n\t\t\ttotal_data_size, data_in_this_rsp);\n\t\treturn -EINVAL;\n\t} else {\n\t\tcFYI(1, \"missing %d bytes from transact2, check next response\",\n\t\t\tremaining);\n\t\tif (total_data_size > maxBufSize) {\n\t\t\tcERROR(1, \"TotalDataSize %d is over maximum buffer %d\",\n\t\t\t\ttotal_data_size, maxBufSize);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn remaining;\n\t}\n}\n\nstatic int coalesce_t2(struct smb_hdr *psecond, struct smb_hdr *pTargetSMB)\n{\n\tstruct smb_t2_rsp *pSMB2 = (struct smb_t2_rsp *)psecond;\n\tstruct smb_t2_rsp *pSMBt  = (struct smb_t2_rsp *)pTargetSMB;\n\tint total_data_size;\n\tint total_in_buf;\n\tint remaining;\n\tint total_in_buf2;\n\tchar *data_area_of_target;\n\tchar *data_area_of_buf2;\n\t__u16 byte_count;\n\n\ttotal_data_size = le16_to_cpu(pSMBt->t2_rsp.TotalDataCount);\n\n\tif (total_data_size != le16_to_cpu(pSMB2->t2_rsp.TotalDataCount)) {\n\t\tcFYI(1, \"total data size of primary and secondary t2 differ\");\n\t}\n\n\ttotal_in_buf = le16_to_cpu(pSMBt->t2_rsp.DataCount);\n\n\tremaining = total_data_size - total_in_buf;\n\n\tif (remaining < 0)\n\t\treturn -EINVAL;\n\n\tif (remaining == 0) /* nothing to do, ignore */\n\t\treturn 0;\n\n\ttotal_in_buf2 = le16_to_cpu(pSMB2->t2_rsp.DataCount);\n\tif (remaining < total_in_buf2) {\n\t\tcFYI(1, \"transact2 2nd response contains too much data\");\n\t}\n\n\t/* find end of first SMB data area */\n\tdata_area_of_target = (char *)&pSMBt->hdr.Protocol +\n\t\t\t\tle16_to_cpu(pSMBt->t2_rsp.DataOffset);\n\t/* validate target area */\n\n\tdata_area_of_buf2 = (char *) &pSMB2->hdr.Protocol +\n\t\t\t\t\tle16_to_cpu(pSMB2->t2_rsp.DataOffset);\n\n\tdata_area_of_target += total_in_buf;\n\n\t/* copy second buffer into end of first buffer */\n\tmemcpy(data_area_of_target, data_area_of_buf2, total_in_buf2);\n\ttotal_in_buf += total_in_buf2;\n\tpSMBt->t2_rsp.DataCount = cpu_to_le16(total_in_buf);\n\tbyte_count = le16_to_cpu(BCC_LE(pTargetSMB));\n\tbyte_count += total_in_buf2;\n\tBCC_LE(pTargetSMB) = cpu_to_le16(byte_count);\n\n\tbyte_count = pTargetSMB->smb_buf_length;\n\tbyte_count += total_in_buf2;\n\n\t/* BB also add check that we are not beyond maximum buffer size */\n\n\tpTargetSMB->smb_buf_length = byte_count;\n\n\tif (remaining == total_in_buf2) {\n\t\tcFYI(1, \"found the last secondary response\");\n\t\treturn 0; /* we are done */\n\t} else /* more responses to go */\n\t\treturn 1;\n\n}\n\nstatic int\ncifs_demultiplex_thread(struct TCP_Server_Info *server)\n{\n\tint length;\n\tunsigned int pdu_length, total_read;\n\tstruct smb_hdr *smb_buffer = NULL;\n\tstruct smb_hdr *bigbuf = NULL;\n\tstruct smb_hdr *smallbuf = NULL;\n\tstruct msghdr smb_msg;\n\tstruct kvec iov;\n\tstruct socket *csocket = server->ssocket;\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\tstruct task_struct *task_to_wake = NULL;\n\tstruct mid_q_entry *mid_entry;\n\tchar temp;\n\tbool isLargeBuf = false;\n\tbool isMultiRsp;\n\tint reconnect;\n\n\tcurrent->flags |= PF_MEMALLOC;\n\tcFYI(1, \"Demultiplex PID: %d\", task_pid_nr(current));\n\n\tlength = atomic_inc_return(&tcpSesAllocCount);\n\tif (length > 1)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\tset_freezable();\n\twhile (server->tcpStatus != CifsExiting) {\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (bigbuf == NULL) {\n\t\t\tbigbuf = cifs_buf_get();\n\t\t\tif (!bigbuf) {\n\t\t\t\tcERROR(1, \"No memory for large SMB response\");\n\t\t\t\tmsleep(3000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (isLargeBuf) {\n\t\t\t/* we are reusing a dirty large buf, clear its start */\n\t\t\tmemset(bigbuf, 0, sizeof(struct smb_hdr));\n\t\t}\n\n\t\tif (smallbuf == NULL) {\n\t\t\tsmallbuf = cifs_small_buf_get();\n\t\t\tif (!smallbuf) {\n\t\t\t\tcERROR(1, \"No memory for SMB response\");\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* retry will check if exiting */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* beginning of smb buffer is cleared in our buf_get */\n\t\t} else /* if existing small buf clear beginning */\n\t\t\tmemset(smallbuf, 0, sizeof(struct smb_hdr));\n\n\t\tisLargeBuf = false;\n\t\tisMultiRsp = false;\n\t\tsmb_buffer = smallbuf;\n\t\tiov.iov_base = smb_buffer;\n\t\tiov.iov_len = 4;\n\t\tsmb_msg.msg_control = NULL;\n\t\tsmb_msg.msg_controllen = 0;\n\t\tpdu_length = 4; /* enough to get RFC1001 header */\nincomplete_rcv:\n\t\tlength =\n\t\t    kernel_recvmsg(csocket, &smb_msg,\n\t\t\t\t&iov, 1, pdu_length, 0 /* BB other flags? */);\n\n\t\tif (server->tcpStatus == CifsExiting) {\n\t\t\tbreak;\n\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\tcFYI(1, \"Reconnect after server stopped responding\");\n\t\t\tcifs_reconnect(server);\n\t\t\tcFYI(1, \"call to reconnect done\");\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t} else if ((length == -ERESTARTSYS) || (length == -EAGAIN)) {\n\t\t\tmsleep(1); /* minimum sleep to prevent looping\n\t\t\t\tallowing socket to clear and app threads to set\n\t\t\t\ttcpStatus CifsNeedReconnect if server hung */\n\t\t\tif (pdu_length < 4) {\n\t\t\t\tiov.iov_base = (4 - pdu_length) +\n\t\t\t\t\t\t\t(char *)smb_buffer;\n\t\t\t\tiov.iov_len = pdu_length;\n\t\t\t\tsmb_msg.msg_control = NULL;\n\t\t\t\tsmb_msg.msg_controllen = 0;\n\t\t\t\tgoto incomplete_rcv;\n\t\t\t} else\n\t\t\t\tcontinue;\n\t\t} else if (length <= 0) {\n\t\t\tif (server->tcpStatus == CifsNew) {\n\t\t\t\tcFYI(1, \"tcp session abend after SMBnegprot\");\n\t\t\t\t/* some servers kill the TCP session rather than\n\t\t\t\t   returning an SMB negprot error, in which\n\t\t\t\t   case reconnecting here is not going to help,\n\t\t\t\t   and so simply return error to mount */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!try_to_freeze() && (length == -EINTR)) {\n\t\t\t\tcFYI(1, \"cifsd thread killed\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcFYI(1, \"Reconnect after unexpected peek error %d\",\n\t\t\t\tlength);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t} else if (length < pdu_length) {\n\t\t\tcFYI(1, \"requested %d bytes but only got %d bytes\",\n\t\t\t\t  pdu_length, length);\n\t\t\tpdu_length -= length;\n\t\t\tmsleep(1);\n\t\t\tgoto incomplete_rcv;\n\t\t}\n\n\t\t/* The right amount was read from socket - 4 bytes */\n\t\t/* so we can now interpret the length field */\n\n\t\t/* the first byte big endian of the length field,\n\t\tis actually not part of the length but the type\n\t\twith the most common, zero, as regular data */\n\t\ttemp = *((char *) smb_buffer);\n\n\t\t/* Note that FC 1001 length is big endian on the wire,\n\t\tbut we convert it here so it is always manipulated\n\t\tas host byte order */\n\t\tpdu_length = be32_to_cpu((__force __be32)smb_buffer->smb_buf_length);\n\t\tsmb_buffer->smb_buf_length = pdu_length;\n\n\t\tcFYI(1, \"rfc1002 length 0x%x\", pdu_length+4);\n\n\t\tif (temp == (char) RFC1002_SESSION_KEEP_ALIVE) {\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_POSITIVE_SESSION_RESPONSE) {\n\t\t\tcFYI(1, \"Good RFC 1002 session rsp\");\n\t\t\tcontinue;\n\t\t} else if (temp == (char)RFC1002_NEGATIVE_SESSION_RESPONSE) {\n\t\t\t/* we get this from Windows 98 instead of\n\t\t\t   an error on SMB negprot response */\n\t\t\tcFYI(1, \"Negative RFC1002 Session Response Error 0x%x)\",\n\t\t\t\tpdu_length);\n\t\t\tif (server->tcpStatus == CifsNew) {\n\t\t\t\t/* if nack on negprot (rather than\n\t\t\t\tret of smb negprot error) reconnecting\n\t\t\t\tnot going to help, ret error to mount */\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* give server a second to\n\t\t\t\tclean up before reconnect attempt */\n\t\t\t\tmsleep(1000);\n\t\t\t\t/* always try 445 first on reconnect\n\t\t\t\tsince we get NACK on some if we ever\n\t\t\t\tconnected to port 139 (the NACK is\n\t\t\t\tsince we do not begin with RFC1001\n\t\t\t\tsession initialize frame) */\n\t\t\t\tserver->addr.sockAddr.sin_port =\n\t\t\t\t\thtons(CIFS_PORT);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\twake_up(&server->response_q);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (temp != (char) 0) {\n\t\t\tcERROR(1, \"Unknown RFC 1002 frame\");\n\t\t\tcifs_dump_mem(\" Received Data: \", (char *)smb_buffer,\n\t\t\t\t      length);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else we have an SMB response */\n\t\tif ((pdu_length > CIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4) ||\n\t\t\t    (pdu_length < sizeof(struct smb_hdr) - 1 - 4)) {\n\t\t\tcERROR(1, \"Invalid size SMB length %d pdu_length %d\",\n\t\t\t\t\tlength, pdu_length+4);\n\t\t\tcifs_reconnect(server);\n\t\t\tcsocket = server->ssocket;\n\t\t\twake_up(&server->response_q);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* else length ok */\n\t\treconnect = 0;\n\n\t\tif (pdu_length > MAX_CIFS_SMALL_BUFFER_SIZE - 4) {\n\t\t\tisLargeBuf = true;\n\t\t\tmemcpy(bigbuf, smallbuf, 4);\n\t\t\tsmb_buffer = bigbuf;\n\t\t}\n\t\tlength = 0;\n\t\tiov.iov_base = 4 + (char *)smb_buffer;\n\t\tiov.iov_len = pdu_length;\n\t\tfor (total_read = 0; total_read < pdu_length;\n\t\t     total_read += length) {\n\t\t\tlength = kernel_recvmsg(csocket, &smb_msg, &iov, 1,\n\t\t\t\t\t\tpdu_length - total_read, 0);\n\t\t\tif ((server->tcpStatus == CifsExiting) ||\n\t\t\t    (length == -EINTR)) {\n\t\t\t\t/* then will exit */\n\t\t\t\treconnect = 2;\n\t\t\t\tbreak;\n\t\t\t} else if (server->tcpStatus == CifsNeedReconnect) {\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\t/* Reconnect wakes up rspns q */\n\t\t\t\t/* Now we will reread sock */\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t} else if ((length == -ERESTARTSYS) ||\n\t\t\t\t   (length == -EAGAIN)) {\n\t\t\t\tmsleep(1); /* minimum sleep to prevent looping,\n\t\t\t\t\t      allowing socket to clear and app\n\t\t\t\t\t      threads to set tcpStatus\n\t\t\t\t\t      CifsNeedReconnect if server hung*/\n\t\t\t\tlength = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (length <= 0) {\n\t\t\t\tcERROR(1, \"Received no data, expecting %d\",\n\t\t\t\t\t      pdu_length - total_read);\n\t\t\t\tcifs_reconnect(server);\n\t\t\t\tcsocket = server->ssocket;\n\t\t\t\treconnect = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (reconnect == 2)\n\t\t\tbreak;\n\t\telse if (reconnect == 1)\n\t\t\tcontinue;\n\n\t\tlength += 4; /* account for rfc1002 hdr */\n\n\n\t\tdump_smb(smb_buffer, length);\n\t\tif (checkSMB(smb_buffer, smb_buffer->Mid, total_read+4)) {\n\t\t\tcifs_dump_mem(\"Bad SMB: \", smb_buffer, 48);\n\t\t\tcontinue;\n\t\t}\n\n\n\t\ttask_to_wake = NULL;\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\n\t\t\tif ((mid_entry->mid == smb_buffer->Mid) &&\n\t\t\t    (mid_entry->midState == MID_REQUEST_SUBMITTED) &&\n\t\t\t    (mid_entry->command == smb_buffer->Command)) {\n\t\t\t\tif (check2ndT2(smb_buffer,server->maxBuf) > 0) {\n\t\t\t\t\t/* We have a multipart transact2 resp */\n\t\t\t\t\tisMultiRsp = true;\n\t\t\t\t\tif (mid_entry->resp_buf) {\n\t\t\t\t\t\t/* merge response - fix up 1st*/\n\t\t\t\t\t\tif (coalesce_t2(smb_buffer,\n\t\t\t\t\t\t\tmid_entry->resp_buf)) {\n\t\t\t\t\t\t\tmid_entry->multiRsp =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* all parts received */\n\t\t\t\t\t\t\tmid_entry->multiEnd =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tgoto multi_t2_fnd;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!isLargeBuf) {\n\t\t\t\t\t\t\tcERROR(1, \"1st trans2 resp needs bigbuf\");\n\t\t\t\t\t/* BB maybe we can fix this up,  switch\n\t\t\t\t\t   to already allocated large buffer? */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Have first buffer */\n\t\t\t\t\t\t\tmid_entry->resp_buf =\n\t\t\t\t\t\t\t\t smb_buffer;\n\t\t\t\t\t\t\tmid_entry->largeBuf =\n\t\t\t\t\t\t\t\t true;\n\t\t\t\t\t\t\tbigbuf = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmid_entry->resp_buf = smb_buffer;\n\t\t\t\tmid_entry->largeBuf = isLargeBuf;\nmulti_t2_fnd:\n\t\t\t\ttask_to_wake = mid_entry->tsk;\n\t\t\t\tmid_entry->midState = MID_RESPONSE_RECEIVED;\n#ifdef CONFIG_CIFS_STATS2\n\t\t\t\tmid_entry->when_received = jiffies;\n#endif\n\t\t\t\t/* so we do not time out requests to  server\n\t\t\t\twhich is still responding (since server could\n\t\t\t\tbe busy but not dead) */\n\t\t\t\tserver->lstrp = jiffies;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\tif (task_to_wake) {\n\t\t\t/* Was previous buf put in mpx struct for multi-rsp? */\n\t\t\tif (!isMultiRsp) {\n\t\t\t\t/* smb buffer will be freed by user thread */\n\t\t\t\tif (isLargeBuf)\n\t\t\t\t\tbigbuf = NULL;\n\t\t\t\telse\n\t\t\t\t\tsmallbuf = NULL;\n\t\t\t}\n\t\t\twake_up_process(task_to_wake);\n\t\t} else if (!is_valid_oplock_break(smb_buffer, server) &&\n\t\t\t   !isMultiRsp) {\n\t\t\tcERROR(1, \"No task to wake, unknown frame received! \"\n\t\t\t\t   \"NumMids %d\", midCount.counter);\n\t\t\tcifs_dump_mem(\"Received Data is: \", (char *)smb_buffer,\n\t\t\t\t      sizeof(struct smb_hdr));\n#ifdef CONFIG_CIFS_DEBUG2\n\t\t\tcifs_dump_detail(smb_buffer);\n\t\t\tcifs_dump_mids(server);\n#endif /* CIFS_DEBUG2 */\n\n\t\t}\n\t} /* end while !EXITING */\n\n\t/* take it off the list, if it's not already */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_del_init(&server->tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\twake_up_all(&server->response_q);\n\n\t/* check if we have blocked requests that need to free */\n\t/* Note that cifs_max_pending is normally 50, but\n\tcan be set at module install time to as little as two */\n\tspin_lock(&GlobalMid_Lock);\n\tif (atomic_read(&server->inFlight) >= cifs_max_pending)\n\t\tatomic_set(&server->inFlight, cifs_max_pending - 1);\n\t/* We do not want to set the max_pending too low or we\n\tcould end up with the counter going negative */\n\tspin_unlock(&GlobalMid_Lock);\n\t/* Although there should not be any requests blocked on\n\tthis queue it can not hurt to be paranoid and try to wake up requests\n\tthat may haven been blocked when more than 50 at time were on the wire\n\tto the same server - they now will see the session is in exit state\n\tand get out of SendReceive.  */\n\twake_up_all(&server->request_q);\n\t/* give those requests time to exit */\n\tmsleep(125);\n\n\tif (server->ssocket) {\n\t\tsock_release(csocket);\n\t\tserver->ssocket = NULL;\n\t}\n\t/* buffer usuallly freed in free_mid - need to free it here on exit */\n\tcifs_buf_release(bigbuf);\n\tif (smallbuf) /* no sense logging a debug message if NULL */\n\t\tcifs_small_buf_release(smallbuf);\n\n\t/*\n\t * BB: we shouldn't have to do any of this. It shouldn't be\n\t * possible to exit from the thread with active SMB sessions\n\t */\n\tread_lock(&cifs_tcp_ses_lock);\n\tif (list_empty(&server->pending_mid_q)) {\n\t\t/* loop through server session structures attached to this and\n\t\t    mark them dead */\n\t\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp, struct cifsSesInfo,\n\t\t\t\t\t smb_ses_list);\n\t\t\tses->status = CifsExiting;\n\t\t\tses->server = NULL;\n\t\t}\n\t\tread_unlock(&cifs_tcp_ses_lock);\n\t} else {\n\t\t/* although we can not zero the server struct pointer yet,\n\t\tsince there are active requests which may depnd on them,\n\t\tmark the corresponding SMB sessions as exiting too */\n\t\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp, struct cifsSesInfo,\n\t\t\t\t\t smb_ses_list);\n\t\t\tses->status = CifsExiting;\n\t\t}\n\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tlist_for_each(tmp, &server->pending_mid_q) {\n\t\tmid_entry = list_entry(tmp, struct mid_q_entry, qhead);\n\t\t\tif (mid_entry->midState == MID_REQUEST_SUBMITTED) {\n\t\t\t\tcFYI(1, \"Clearing Mid 0x%x - waking up \",\n\t\t\t\t\t mid_entry->mid);\n\t\t\t\ttask_to_wake = mid_entry->tsk;\n\t\t\t\tif (task_to_wake)\n\t\t\t\t\twake_up_process(task_to_wake);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&GlobalMid_Lock);\n\t\tread_unlock(&cifs_tcp_ses_lock);\n\t\t/* 1/8th of sec is more than enough time for them to exit */\n\t\tmsleep(125);\n\t}\n\n\tif (!list_empty(&server->pending_mid_q)) {\n\t\t/* mpx threads have not exited yet give them\n\t\tat least the smb send timeout time for long ops */\n\t\t/* due to delays on oplock break requests, we need\n\t\tto wait at least 45 seconds before giving up\n\t\ton a request getting a response and going ahead\n\t\tand killing cifsd */\n\t\tcFYI(1, \"Wait for exit from demultiplex thread\");\n\t\tmsleep(46000);\n\t\t/* if threads still have not exited they are probably never\n\t\tcoming home not much else we can do but free the memory */\n\t}\n\n\t/* last chance to mark ses pointers invalid\n\tif there are any pointing to this (e.g\n\tif a crazy root user tried to kill cifsd\n\tkernel thread explicitly this might happen) */\n\t/* BB: This shouldn't be necessary, see above */\n\tread_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tses->server = NULL;\n\t}\n\tread_unlock(&cifs_tcp_ses_lock);\n\n\tkfree(server->hostname);\n\ttask_to_wake = xchg(&server->tsk, NULL);\n\tkfree(server);\n\n\tlength = atomic_dec_return(&tcpSesAllocCount);\n\tif (length  > 0)\n\t\tmempool_resize(cifs_req_poolp, length + cifs_min_rcv,\n\t\t\t\tGFP_KERNEL);\n\n\t/* if server->tsk was NULL then wait for a signal before exiting */\n\tif (!task_to_wake) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\t\tset_current_state(TASK_RUNNING);\n\t}\n\n\tmodule_put_and_exit(0);\n}\n\n/* extract the host portion of the UNC string */\nstatic char *\nextract_hostname(const char *unc)\n{\n\tconst char *src;\n\tchar *dst, *delim;\n\tunsigned int len;\n\n\t/* skip double chars at beginning of string */\n\t/* BB: check validity of these bytes? */\n\tsrc = unc + 2;\n\n\t/* delimiter between hostname and sharename is always '\\\\' now */\n\tdelim = strchr(src, '\\\\');\n\tif (!delim)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = delim - src;\n\tdst = kmalloc((len + 1), GFP_KERNEL);\n\tif (dst == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemcpy(dst, src, len);\n\tdst[len] = '\\0';\n\n\treturn dst;\n}\n\nstatic int\ncifs_parse_mount_options(char *options, const char *devname,\n\t\t\t struct smb_vol *vol)\n{\n\tchar *value;\n\tchar *data;\n\tunsigned int  temp_len, i, j;\n\tchar separator[2];\n\tshort int override_uid = -1;\n\tshort int override_gid = -1;\n\tbool uid_specified = false;\n\tbool gid_specified = false;\n\n\tseparator[0] = ',';\n\tseparator[1] = 0;\n\n\tif (Local_System_Name[0] != 0)\n\t\tmemcpy(vol->source_rfc1001_name, Local_System_Name, 15);\n\telse {\n\t\tchar *nodename = utsname()->nodename;\n\t\tint n = strnlen(nodename, 15);\n\t\tmemset(vol->source_rfc1001_name, 0x20, 15);\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t/* does not have to be perfect mapping since field is\n\t\t\tinformational, only used for servers that do not support\n\t\t\tport 445 and it can be overridden at mount time */\n\t\t\tvol->source_rfc1001_name[i] = toupper(nodename[i]);\n\t\t}\n\t}\n\tvol->source_rfc1001_name[15] = 0;\n\t/* null target name indicates to use *SMBSERVR default called name\n\t   if we end up sending RFC1001 session initialize */\n\tvol->target_rfc1001_name[0] = 0;\n\tvol->linux_uid = current_uid();  /* use current_euid() instead? */\n\tvol->linux_gid = current_gid();\n\n\t/* default to only allowing write access to owner of the mount */\n\tvol->dir_mode = vol->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;\n\n\t/* vol->retry default is 0 (i.e. \"soft\" limited retry not hard retry) */\n\t/* default is always to request posix paths. */\n\tvol->posix_paths = 1;\n\t/* default to using server inode numbers where available */\n\tvol->server_ino = 1;\n\n\tif (!options)\n\t\treturn 1;\n\n\tif (strncmp(options, \"sep=\", 4) == 0) {\n\t\tif (options[4] != 0) {\n\t\t\tseparator[0] = options[4];\n\t\t\toptions += 5;\n\t\t} else {\n\t\t\tcFYI(1, \"Null separator not allowed\");\n\t\t}\n\t}\n\n\twhile ((data = strsep(&options, separator)) != NULL) {\n\t\tif (!*data)\n\t\t\tcontinue;\n\t\tif ((value = strchr(data, '=')) != NULL)\n\t\t\t*value++ = '\\0';\n\n\t\t/* Have to parse this before we parse for \"user\" */\n\t\tif (strnicmp(data, \"user_xattr\", 10) == 0) {\n\t\t\tvol->no_xattr = 0;\n\t\t} else if (strnicmp(data, \"nouser_xattr\", 12) == 0) {\n\t\t\tvol->no_xattr = 1;\n\t\t} else if (strnicmp(data, \"user\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"CIFS: invalid or missing username\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t} else if (!*value) {\n\t\t\t\t/* null user, ie anonymous, authentication */\n\t\t\t\tvol->nullauth = 1;\n\t\t\t}\n\t\t\tif (strnlen(value, 200) < 200) {\n\t\t\t\tvol->username = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: username too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"pass\", 4) == 0) {\n\t\t\tif (!value) {\n\t\t\t\tvol->password = NULL;\n\t\t\t\tcontinue;\n\t\t\t} else if (value[0] == 0) {\n\t\t\t\t/* check if string begins with double comma\n\t\t\t\t   since that would mean the password really\n\t\t\t\t   does start with a comma, and would not\n\t\t\t\t   indicate an empty string */\n\t\t\t\tif (value[1] != separator[0]) {\n\t\t\t\t\tvol->password = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp_len = strlen(value);\n\t\t\t/* removed password length check, NTLM passwords\n\t\t\t\tcan be arbitrarily long */\n\n\t\t\t/* if comma in password, the string will be\n\t\t\tprematurely null terminated.  Commas in password are\n\t\t\tspecified across the cifs mount interface by a double\n\t\t\tcomma ie ,, and a comma used as in other cases ie ','\n\t\t\tas a parameter delimiter/separator is single and due\n\t\t\tto the strsep above is temporarily zeroed. */\n\n\t\t\t/* NB: password legally can have multiple commas and\n\t\t\tthe only illegal character in a password is null */\n\n\t\t\tif ((value[temp_len] == 0) &&\n\t\t\t    (value[temp_len+1] == separator[0])) {\n\t\t\t\t/* reinsert comma */\n\t\t\t\tvalue[temp_len] = separator[0];\n\t\t\t\ttemp_len += 2;  /* move after second comma */\n\t\t\t\twhile (value[temp_len] != 0)  {\n\t\t\t\t\tif (value[temp_len] == separator[0]) {\n\t\t\t\t\t\tif (value[temp_len+1] ==\n\t\t\t\t\t\t     separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\t\ttemp_len++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t/* single comma indicating start\n\t\t\t\t\t\t\t of next parm */\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp_len++;\n\t\t\t\t}\n\t\t\t\tif (value[temp_len] == 0) {\n\t\t\t\t\toptions = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tvalue[temp_len] = 0;\n\t\t\t\t\t/* point option to start of next parm */\n\t\t\t\t\toptions = value + temp_len + 1;\n\t\t\t\t}\n\t\t\t\t/* go from value to value + temp_len condensing\n\t\t\t\tdouble commas to singles. Note that this ends up\n\t\t\t\tallocating a few bytes too many, which is ok */\n\t\t\t\tvol->password = kzalloc(temp_len, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = 0; i < temp_len; i++, j++) {\n\t\t\t\t\tvol->password[j] = value[i];\n\t\t\t\t\tif (value[i] == separator[0]\n\t\t\t\t\t\t&& value[i+1] == separator[0]) {\n\t\t\t\t\t\t/* skip second comma */\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvol->password[j] = 0;\n\t\t\t} else {\n\t\t\t\tvol->password = kzalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->password == NULL) {\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: no memory \"\n\t\t\t\t\t\t\t    \"for password\\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tstrcpy(vol->password, value);\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"ip\", 2) ||\n\t\t\t   !strnicmp(data, \"addr\", 4)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tvol->UNCip = NULL;\n\t\t\t} else if (strnlen(value, INET6_ADDRSTRLEN) <\n\t\t\t\t\t\t\tINET6_ADDRSTRLEN) {\n\t\t\t\tvol->UNCip = value;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: ip address \"\n\t\t\t\t\t\t    \"too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sec\", 3) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no security value specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"krb5i\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"krb5p\", 5) == 0) {\n\t\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL |\n\t\t\t\t\tCIFSSEC_MAY_KRB5; */\n\t\t\t\tcERROR(1, \"Krb5 cifs privacy not supported\");\n\t\t\t\treturn 1;\n\t\t\t} else if (strnicmp(value, \"krb5\", 4) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_KRB5;\n#ifdef CONFIG_CIFS_EXPERIMENTAL\n\t\t\t} else if (strnicmp(value, \"ntlmsspi\", 8) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmssp\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMSSP;\n#endif\n\t\t\t} else if (strnicmp(value, \"ntlmv2i\", 7) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2 |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlmv2\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n\t\t\t} else if (strnicmp(value, \"ntlmi\", 5) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM |\n\t\t\t\t\tCIFSSEC_MUST_SIGN;\n\t\t\t} else if (strnicmp(value, \"ntlm\", 4) == 0) {\n\t\t\t\t/* ntlm is default so can be turned off too */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLM;\n\t\t\t} else if (strnicmp(value, \"nontlm\", 6) == 0) {\n\t\t\t\t/* BB is there a better way to do this? */\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_NTLMV2;\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\t\t} else if (strnicmp(value, \"lanman\", 6) == 0) {\n\t\t\t\tvol->secFlg |= CIFSSEC_MAY_LANMAN;\n#endif\n\t\t\t} else if (strnicmp(value, \"none\", 4) == 0) {\n\t\t\t\tvol->nullauth = 1;\n\t\t\t} else {\n\t\t\t\tcERROR(1, \"bad security option: %s\", value);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"unc\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"target\", 6) == 0)\n\t\t\t   || (strnicmp(data, \"path\", 4) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid path to \"\n\t\t\t\t\t\t    \"network resource\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 300)) < 300) {\n\t\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->UNC == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tstrcpy(vol->UNC, value);\n\t\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t       \"CIFS: UNC Path does not begin \"\n\t\t\t\t\t       \"with // or \\\\\\\\ \\n\");\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if ((strnicmp(data, \"domain\", 3) == 0)\n\t\t\t   || (strnicmp(data, \"workgroup\", 5) == 0)) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid domain name\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\t/* BB are there cases in which a comma can be valid in\n\t\t\ta domain name and need special handling? */\n\t\t\tif (strnlen(value, 256) < 256) {\n\t\t\t\tvol->domainname = value;\n\t\t\t\tcFYI(1, \"Domain name set\");\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: domain name too \"\n\t\t\t\t\t\t    \"long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"prefixpath\", 10) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t\t\"CIFS: invalid path prefix\\n\");\n\t\t\t\treturn 1;       /* needs_argument */\n\t\t\t}\n\t\t\tif ((temp_len = strnlen(value, 1024)) < 1024) {\n\t\t\t\tif (value[0] != '/')\n\t\t\t\t\ttemp_len++;  /* missing leading slash */\n\t\t\t\tvol->prepath = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\t\tif (vol->prepath == NULL)\n\t\t\t\t\treturn 1;\n\t\t\t\tif (value[0] != '/') {\n\t\t\t\t\tvol->prepath[0] = '/';\n\t\t\t\t\tstrcpy(vol->prepath+1, value);\n\t\t\t\t} else\n\t\t\t\t\tstrcpy(vol->prepath, value);\n\t\t\t\tcFYI(1, \"prefix path %s\", vol->prepath);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: prefix too long\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"iocharset\", 9) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: invalid iocharset \"\n\t\t\t\t\t\t    \"specified\\n\");\n\t\t\t\treturn 1;\t/* needs_arg; */\n\t\t\t}\n\t\t\tif (strnlen(value, 65) < 65) {\n\t\t\t\tif (strnicmp(value, \"default\", 7))\n\t\t\t\t\tvol->iocharset = value;\n\t\t\t\t/* if iocharset not set then load_nls_default\n\t\t\t\t   is used by caller */\n\t\t\t\tcFYI(1, \"iocharset set to %s\", value);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: iocharset name \"\n\t\t\t\t\t\t    \"too long.\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else if (!strnicmp(data, \"uid\", 3) && value && *value) {\n\t\t\tvol->linux_uid = simple_strtoul(value, &value, 0);\n\t\t\tuid_specified = true;\n\t\t} else if (!strnicmp(data, \"forceuid\", 8)) {\n\t\t\toverride_uid = 1;\n\t\t} else if (!strnicmp(data, \"noforceuid\", 10)) {\n\t\t\toverride_uid = 0;\n\t\t} else if (!strnicmp(data, \"gid\", 3) && value && *value) {\n\t\t\tvol->linux_gid = simple_strtoul(value, &value, 0);\n\t\t\tgid_specified = true;\n\t\t} else if (!strnicmp(data, \"forcegid\", 8)) {\n\t\t\toverride_gid = 1;\n\t\t} else if (!strnicmp(data, \"noforcegid\", 10)) {\n\t\t\toverride_gid = 0;\n\t\t} else if (strnicmp(data, \"file_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->file_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dir_mode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"dirmode\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->dir_mode =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"port\", 4) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->port =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"rsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->rsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"wsize\", 5) == 0) {\n\t\t\tif (value && *value) {\n\t\t\t\tvol->wsize =\n\t\t\t\t\tsimple_strtoul(value, &value, 0);\n\t\t\t}\n\t\t} else if (strnicmp(data, \"sockopt\", 5) == 0) {\n\t\t\tif (!value || !*value) {\n\t\t\t\tcERROR(1, \"no socket option specified\");\n\t\t\t\tcontinue;\n\t\t\t} else if (strnicmp(value, \"TCP_NODELAY\", 11) == 0) {\n\t\t\t\tvol->sockopt_tcp_nodelay = 1;\n\t\t\t}\n\t\t} else if (strnicmp(data, \"netbiosname\", 4) == 0) {\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"invalid (empty) netbiosname\");\n\t\t\t} else {\n\t\t\t\tmemset(vol->source_rfc1001_name, 0x20, 15);\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\tvalid in this workstation netbios name (and need\n\t\t\t\tspecial handling)? */\n\n\t\t\t\t/* We do not uppercase netbiosname for user */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->source_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\tset at top of the function  */\n\t\t\t\tif ((i == 15) && (value[i] != 0))\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: netbiosname\"\n\t\t\t\t\t\t\" longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"servern\", 7) == 0) {\n\t\t\t/* servernetbiosname specified override *SMBSERVER */\n\t\t\tif (!value || !*value || (*value == ' ')) {\n\t\t\t\tcFYI(1, \"empty server netbiosname specified\");\n\t\t\t} else {\n\t\t\t\t/* last byte, type, is 0x20 for servr type */\n\t\t\t\tmemset(vol->target_rfc1001_name, 0x20, 16);\n\n\t\t\t\tfor (i = 0; i < 15; i++) {\n\t\t\t\t/* BB are there cases in which a comma can be\n\t\t\t\t   valid in this workstation netbios name\n\t\t\t\t   (and need special handling)? */\n\n\t\t\t\t/* user or mount helper must uppercase\n\t\t\t\t   the netbiosname */\n\t\t\t\t\tif (value[i] == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse\n\t\t\t\t\t\tvol->target_rfc1001_name[i] =\n\t\t\t\t\t\t\t\tvalue[i];\n\t\t\t\t}\n\t\t\t\t/* The string has 16th byte zero still from\n\t\t\t\t   set at top of the function  */\n\t\t\t\tif ((i == 15) && (value[i] != 0))\n\t\t\t\t\tprintk(KERN_WARNING \"CIFS: server net\"\n\t\t\t\t\t\"biosname longer than 15 truncated.\\n\");\n\t\t\t}\n\t\t} else if (strnicmp(data, \"credentials\", 4) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"version\", 3) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"guest\", 5) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"rw\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"ro\", 2) == 0) {\n\t\t\t/* ignore */\n\t\t} else if (strnicmp(data, \"noblocksend\", 11) == 0) {\n\t\t\tvol->noblocksnd = 1;\n\t\t} else if (strnicmp(data, \"noautotune\", 10) == 0) {\n\t\t\tvol->noautotune = 1;\n\t\t} else if ((strnicmp(data, \"suid\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nosuid\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"exec\", 4) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noexec\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"nodev\", 5) == 0) ||\n\t\t\t\t   (strnicmp(data, \"noauto\", 6) == 0) ||\n\t\t\t\t   (strnicmp(data, \"dev\", 3) == 0)) {\n\t\t\t/*  The mount tool or mount.cifs helper (if present)\n\t\t\t    uses these opts to set flags, and the flags are read\n\t\t\t    by the kernel vfs layer before we get here (ie\n\t\t\t    before read super) so there is no point trying to\n\t\t\t    parse these options again and set anything and it\n\t\t\t    is ok to just ignore them */\n\t\t\tcontinue;\n\t\t} else if (strnicmp(data, \"hard\", 4) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"soft\", 4) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"perm\", 4) == 0) {\n\t\t\tvol->noperm = 0;\n\t\t} else if (strnicmp(data, \"noperm\", 6) == 0) {\n\t\t\tvol->noperm = 1;\n\t\t} else if (strnicmp(data, \"mapchars\", 8) == 0) {\n\t\t\tvol->remap = 1;\n\t\t} else if (strnicmp(data, \"nomapchars\", 10) == 0) {\n\t\t\tvol->remap = 0;\n\t\t} else if (strnicmp(data, \"sfu\", 3) == 0) {\n\t\t\tvol->sfu_emul = 1;\n\t\t} else if (strnicmp(data, \"nosfu\", 5) == 0) {\n\t\t\tvol->sfu_emul = 0;\n\t\t} else if (strnicmp(data, \"nodfs\", 5) == 0) {\n\t\t\tvol->nodfs = 1;\n\t\t} else if (strnicmp(data, \"posixpaths\", 10) == 0) {\n\t\t\tvol->posix_paths = 1;\n\t\t} else if (strnicmp(data, \"noposixpaths\", 12) == 0) {\n\t\t\tvol->posix_paths = 0;\n\t\t} else if (strnicmp(data, \"nounix\", 6) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if (strnicmp(data, \"nolinux\", 7) == 0) {\n\t\t\tvol->no_linux_ext = 1;\n\t\t} else if ((strnicmp(data, \"nocase\", 6) == 0) ||\n\t\t\t   (strnicmp(data, \"ignorecase\", 10)  == 0)) {\n\t\t\tvol->nocase = 1;\n\t\t} else if (strnicmp(data, \"brl\", 3) == 0) {\n\t\t\tvol->nobrl =  0;\n\t\t} else if ((strnicmp(data, \"nobrl\", 5) == 0) ||\n\t\t\t   (strnicmp(data, \"nolock\", 6) == 0)) {\n\t\t\tvol->nobrl =  1;\n\t\t\t/* turn off mandatory locking in mode\n\t\t\tif remote locking is turned off since the\n\t\t\tlocal vfs will do advisory */\n\t\t\tif (vol->file_mode ==\n\t\t\t\t(S_IALLUGO & ~(S_ISUID | S_IXGRP)))\n\t\t\t\tvol->file_mode = S_IALLUGO;\n\t\t} else if (strnicmp(data, \"forcemandatorylock\", 9) == 0) {\n\t\t\t/* will take the shorter form \"forcemand\" as well */\n\t\t\t/* This mount option will force use of mandatory\n\t\t\t  (DOS/Windows style) byte range locks, instead of\n\t\t\t  using posix advisory byte range locks, even if the\n\t\t\t  Unix extensions are available and posix locks would\n\t\t\t  be supported otherwise. If Unix extensions are not\n\t\t\t  negotiated this has no effect since mandatory locks\n\t\t\t  would be used (mandatory locks is all that those\n\t\t\t  those servers support) */\n\t\t\tvol->mand_lock = 1;\n\t\t} else if (strnicmp(data, \"setuids\", 7) == 0) {\n\t\t\tvol->setuids = 1;\n\t\t} else if (strnicmp(data, \"nosetuids\", 9) == 0) {\n\t\t\tvol->setuids = 0;\n\t\t} else if (strnicmp(data, \"dynperm\", 7) == 0) {\n\t\t\tvol->dynperm = true;\n\t\t} else if (strnicmp(data, \"nodynperm\", 9) == 0) {\n\t\t\tvol->dynperm = false;\n\t\t} else if (strnicmp(data, \"nohard\", 6) == 0) {\n\t\t\tvol->retry = 0;\n\t\t} else if (strnicmp(data, \"nosoft\", 6) == 0) {\n\t\t\tvol->retry = 1;\n\t\t} else if (strnicmp(data, \"nointr\", 6) == 0) {\n\t\t\tvol->intr = 0;\n\t\t} else if (strnicmp(data, \"intr\", 4) == 0) {\n\t\t\tvol->intr = 1;\n\t\t} else if (strnicmp(data, \"nostrictsync\", 12) == 0) {\n\t\t\tvol->nostrictsync = 1;\n\t\t} else if (strnicmp(data, \"strictsync\", 10) == 0) {\n\t\t\tvol->nostrictsync = 0;\n\t\t} else if (strnicmp(data, \"serverino\", 7) == 0) {\n\t\t\tvol->server_ino = 1;\n\t\t} else if (strnicmp(data, \"noserverino\", 9) == 0) {\n\t\t\tvol->server_ino = 0;\n\t\t} else if (strnicmp(data, \"cifsacl\", 7) == 0) {\n\t\t\tvol->cifs_acl = 1;\n\t\t} else if (strnicmp(data, \"nocifsacl\", 9) == 0) {\n\t\t\tvol->cifs_acl = 0;\n\t\t} else if (strnicmp(data, \"acl\", 3) == 0) {\n\t\t\tvol->no_psx_acl = 0;\n\t\t} else if (strnicmp(data, \"noacl\", 5) == 0) {\n\t\t\tvol->no_psx_acl = 1;\n#ifdef CONFIG_CIFS_EXPERIMENTAL\n\t\t} else if (strnicmp(data, \"locallease\", 6) == 0) {\n\t\t\tvol->local_lease = 1;\n#endif\n\t\t} else if (strnicmp(data, \"sign\", 4) == 0) {\n\t\t\tvol->secFlg |= CIFSSEC_MUST_SIGN;\n\t\t} else if (strnicmp(data, \"seal\", 4) == 0) {\n\t\t\t/* we do not do the following in secFlags because seal\n\t\t\t   is a per tree connection (mount) not a per socket\n\t\t\t   or per-smb connection option in the protocol */\n\t\t\t/* vol->secFlg |= CIFSSEC_MUST_SEAL; */\n\t\t\tvol->seal = 1;\n\t\t} else if (strnicmp(data, \"direct\", 6) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"forcedirectio\", 13) == 0) {\n\t\t\tvol->direct_io = 1;\n\t\t} else if (strnicmp(data, \"noac\", 4) == 0) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Mount option noac not \"\n\t\t\t\t\"supported. Instead set \"\n\t\t\t\t\"/proc/fs/cifs/LookupCacheEnabled to 0\\n\");\n\t\t} else\n\t\t\tprintk(KERN_WARNING \"CIFS: Unknown mount option %s\\n\",\n\t\t\t\t\t\tdata);\n\t}\n\tif (vol->UNC == NULL) {\n\t\tif (devname == NULL) {\n\t\t\tprintk(KERN_WARNING \"CIFS: Missing UNC name for mount \"\n\t\t\t\t\t\t\"target\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif ((temp_len = strnlen(devname, 300)) < 300) {\n\t\t\tvol->UNC = kmalloc(temp_len+1, GFP_KERNEL);\n\t\t\tif (vol->UNC == NULL)\n\t\t\t\treturn 1;\n\t\t\tstrcpy(vol->UNC, devname);\n\t\t\tif (strncmp(vol->UNC, \"//\", 2) == 0) {\n\t\t\t\tvol->UNC[0] = '\\\\';\n\t\t\t\tvol->UNC[1] = '\\\\';\n\t\t\t} else if (strncmp(vol->UNC, \"\\\\\\\\\", 2) != 0) {\n\t\t\t\tprintk(KERN_WARNING \"CIFS: UNC Path does not \"\n\t\t\t\t\t\t    \"begin with // or \\\\\\\\ \\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tvalue = strpbrk(vol->UNC+2, \"/\\\\\");\n\t\t\tif (value)\n\t\t\t\t*value = '\\\\';\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"CIFS: UNC name too long\\n\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif (vol->UNCip == NULL)\n\t\tvol->UNCip = &vol->UNC[2];\n\n\tif (uid_specified)\n\t\tvol->override_uid = override_uid;\n\telse if (override_uid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forceuid mount option \"\n\t\t\t\t   \"specified with no uid= option.\\n\");\n\n\tif (gid_specified)\n\t\tvol->override_gid = override_gid;\n\telse if (override_gid == 1)\n\t\tprintk(KERN_NOTICE \"CIFS: ignoring forcegid mount option \"\n\t\t\t\t   \"specified with no gid= option.\\n\");\n\n\treturn 0;\n}\n\nstatic bool\nmatch_address(struct TCP_Server_Info *server, struct sockaddr *addr)\n{\n\tstruct sockaddr_in *addr4 = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)addr;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tif (addr4->sin_addr.s_addr !=\n\t\t    server->addr.sockAddr.sin_addr.s_addr)\n\t\t\treturn false;\n\t\tif (addr4->sin_port &&\n\t\t    addr4->sin_port != server->addr.sockAddr.sin_port)\n\t\t\treturn false;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (!ipv6_addr_equal(&addr6->sin6_addr,\n\t\t\t\t     &server->addr.sockAddr6.sin6_addr))\n\t\t\treturn false;\n\t\tif (addr6->sin6_scope_id !=\n\t\t    server->addr.sockAddr6.sin6_scope_id)\n\t\t\treturn false;\n\t\tif (addr6->sin6_port &&\n\t\t    addr6->sin6_port != server->addr.sockAddr6.sin6_port)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nmatch_security(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tunsigned int secFlags;\n\n\tif (vol->secFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\n\t\tsecFlags = vol->secFlg;\n\telse\n\t\tsecFlags = global_secflags | vol->secFlg;\n\n\tswitch (server->secType) {\n\tcase LANMAN:\n\t\tif (!(secFlags & (CIFSSEC_MAY_LANMAN|CIFSSEC_MAY_PLNTXT)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMV2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NTLM:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLM))\n\t\t\treturn false;\n\t\tbreak;\n\tcase Kerberos:\n\t\tif (!(secFlags & CIFSSEC_MAY_KRB5))\n\t\t\treturn false;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tif (!(secFlags & CIFSSEC_MAY_NTLMSSP))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\t/* shouldn't happen */\n\t\treturn false;\n\t}\n\n\t/* now check if signing mode is acceptible */\n\tif ((secFlags & CIFSSEC_MAY_SIGN) == 0 &&\n\t    (server->secMode & SECMODE_SIGN_REQUIRED))\n\t\t\treturn false;\n\telse if (((secFlags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) &&\n\t\t (server->secMode &\n\t\t  (SECMODE_SIGN_ENABLED|SECMODE_SIGN_REQUIRED)) == 0)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct TCP_Server_Info *\ncifs_find_tcp_session(struct sockaddr *addr, struct smb_vol *vol)\n{\n\tstruct TCP_Server_Info *server;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(server, &cifs_tcp_ses_list, tcp_ses_list) {\n\t\t/*\n\t\t * the demux thread can exit on its own while still in CifsNew\n\t\t * so don't accept any sockets in that state. Since the\n\t\t * tcpStatus never changes back to CifsNew it's safe to check\n\t\t * for this without a lock.\n\t\t */\n\t\tif (server->tcpStatus == CifsNew)\n\t\t\tcontinue;\n\n\t\tif (!match_address(server, addr))\n\t\t\tcontinue;\n\n\t\tif (!match_security(server, vol))\n\t\t\tcontinue;\n\n\t\t++server->srv_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\tcFYI(1, \"Existing tcp session with server found\");\n\t\treturn server;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcp_session(struct TCP_Server_Info *server)\n{\n\tstruct task_struct *task;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&server->tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tspin_lock(&GlobalMid_Lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&GlobalMid_Lock);\n\n\tcifs_fscache_release_client_cookie(server);\n\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tforce_sig(SIGKILL, task);\n}\n\nstatic struct TCP_Server_Info *\ncifs_get_tcp_session(struct smb_vol *volume_info)\n{\n\tstruct TCP_Server_Info *tcp_ses = NULL;\n\tstruct sockaddr_storage addr;\n\tstruct sockaddr_in *sin_server = (struct sockaddr_in *) &addr;\n\tstruct sockaddr_in6 *sin_server6 = (struct sockaddr_in6 *) &addr;\n\tint rc;\n\n\tmemset(&addr, 0, sizeof(struct sockaddr_storage));\n\n\tcFYI(1, \"UNC: %s ip: %s\", volume_info->UNC, volume_info->UNCip);\n\n\tif (volume_info->UNCip && volume_info->UNC) {\n\t\trc = cifs_fill_sockaddr((struct sockaddr *)&addr,\n\t\t\t\t\tvolume_info->UNCip,\n\t\t\t\t\tvolume_info->port);\n\t\tif (!rc) {\n\t\t\t/* we failed translating address */\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (volume_info->UNCip) {\n\t\t/* BB using ip addr as tcp_ses name to connect to the\n\t\t   DFS root below */\n\t\tcERROR(1, \"Connecting to DFS root not implemented yet\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t} else /* which tcp_sess DFS root would we conect to */ {\n\t\tcERROR(1, \"CIFS mount error: No UNC path (e.g. -o \"\n\t\t\t\"unc=//192.168.1.100/public) specified\");\n\t\trc = -EINVAL;\n\t\tgoto out_err;\n\t}\n\n\t/* see if we already have a matching tcp_ses */\n\ttcp_ses = cifs_find_tcp_session((struct sockaddr *)&addr, volume_info);\n\tif (tcp_ses)\n\t\treturn tcp_ses;\n\n\ttcp_ses = kzalloc(sizeof(struct TCP_Server_Info), GFP_KERNEL);\n\tif (!tcp_ses) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->hostname = extract_hostname(volume_info->UNC);\n\tif (IS_ERR(tcp_ses->hostname)) {\n\t\trc = PTR_ERR(tcp_ses->hostname);\n\t\tgoto out_err;\n\t}\n\n\ttcp_ses->noblocksnd = volume_info->noblocksnd;\n\ttcp_ses->noautotune = volume_info->noautotune;\n\ttcp_ses->tcp_nodelay = volume_info->sockopt_tcp_nodelay;\n\tatomic_set(&tcp_ses->inFlight, 0);\n\tinit_waitqueue_head(&tcp_ses->response_q);\n\tinit_waitqueue_head(&tcp_ses->request_q);\n\tINIT_LIST_HEAD(&tcp_ses->pending_mid_q);\n\tmutex_init(&tcp_ses->srv_mutex);\n\tmemcpy(tcp_ses->workstation_RFC1001_name,\n\t\tvolume_info->source_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\tmemcpy(tcp_ses->server_RFC1001_name,\n\t\tvolume_info->target_rfc1001_name, RFC1001_NAME_LEN_WITH_NULL);\n\ttcp_ses->sequence_number = 0;\n\tINIT_LIST_HEAD(&tcp_ses->tcp_ses_list);\n\tINIT_LIST_HEAD(&tcp_ses->smb_ses_list);\n\n\t/*\n\t * at this point we are the only ones with the pointer\n\t * to the struct since the kernel thread not created yet\n\t * no need to spinlock this init of tcpStatus or srv_count\n\t */\n\ttcp_ses->tcpStatus = CifsNew;\n\t++tcp_ses->srv_count;\n\n\tif (addr.ss_family == AF_INET6) {\n\t\tcFYI(1, \"attempting ipv6 connect\");\n\t\t/* BB should we allow ipv6 on port 139? */\n\t\t/* other OS never observed in Wild doing 139 with v6 */\n\t\tmemcpy(&tcp_ses->addr.sockAddr6, sin_server6,\n\t\t\tsizeof(struct sockaddr_in6));\n\t\trc = ipv6_connect(tcp_ses);\n\t} else {\n\t\tmemcpy(&tcp_ses->addr.sockAddr, sin_server,\n\t\t\tsizeof(struct sockaddr_in));\n\t\trc = ipv4_connect(tcp_ses);\n\t}\n\tif (rc < 0) {\n\t\tcERROR(1, \"Error connecting to socket. Aborting operation\");\n\t\tgoto out_err;\n\t}\n\n\t/*\n\t * since we're in a cifs function already, we know that\n\t * this will succeed. No need for try_module_get().\n\t */\n\t__module_get(THIS_MODULE);\n\ttcp_ses->tsk = kthread_run((void *)(void *)cifs_demultiplex_thread,\n\t\t\t\t  tcp_ses, \"cifsd\");\n\tif (IS_ERR(tcp_ses->tsk)) {\n\t\trc = PTR_ERR(tcp_ses->tsk);\n\t\tcERROR(1, \"error %d create cifsd thread\", rc);\n\t\tmodule_put(THIS_MODULE);\n\t\tgoto out_err;\n\t}\n\n\t/* thread spawned, put it on the list */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcp_ses->tcp_ses_list, &cifs_tcp_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tcifs_fscache_get_client_cookie(tcp_ses);\n\n\treturn tcp_ses;\n\nout_err:\n\tif (tcp_ses) {\n\t\tif (!IS_ERR(tcp_ses->hostname))\n\t\t\tkfree(tcp_ses->hostname);\n\t\tif (tcp_ses->ssocket)\n\t\t\tsock_release(tcp_ses->ssocket);\n\t\tkfree(tcp_ses);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsSesInfo *\ncifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->linux_uid != ses->linux_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* anything else takes username/password */\n\t\t\tif (strncmp(ses->userName, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    strncmp(ses->password, vol->password,\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_smb_ses(struct cifsSesInfo *ses)\n{\n\tint xid;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tcFYI(1, \"%s: ses_count=%d\\n\", __func__, ses->ses_count);\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--ses->ses_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&ses->smb_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tif (ses->status == CifsGood) {\n\t\txid = GetXid();\n\t\tCIFSSMBLogoff(xid, ses);\n\t\t_FreeXid(xid);\n\t}\n\tsesInfoFree(ses);\n\tcifs_put_tcp_session(server);\n}\n\nstatic struct cifsSesInfo *\ncifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n{\n\tint rc = -ENOMEM, xid;\n\tstruct cifsSesInfo *ses;\n\n\txid = GetXid();\n\n\tses = cifs_find_smb_ses(server, volume_info);\n\tif (ses) {\n\t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n\n\t\t/* existing SMB ses has a server reference already */\n\t\tcifs_put_tcp_session(server);\n\n\t\tmutex_lock(&ses->session_mutex);\n\t\trc = cifs_negotiate_protocol(xid, ses);\n\t\tif (rc) {\n\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t/* problem -- put our ses reference */\n\t\t\tcifs_put_smb_ses(ses);\n\t\t\tFreeXid(xid);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (ses->need_reconnect) {\n\t\t\tcFYI(1, \"Session needs reconnect\");\n\t\t\trc = cifs_setup_session(xid, ses,\n\t\t\t\t\t\tvolume_info->local_nls);\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&ses->session_mutex);\n\t\t\t\t/* problem -- put our reference */\n\t\t\t\tcifs_put_smb_ses(ses);\n\t\t\t\tFreeXid(xid);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ses->session_mutex);\n\t\tFreeXid(xid);\n\t\treturn ses;\n\t}\n\n\tcFYI(1, \"Existing smb sess not found\");\n\tses = sesInfoAlloc();\n\tif (ses == NULL)\n\t\tgoto get_ses_fail;\n\n\t/* new SMB session uses our server ref */\n\tses->server = server;\n\tif (server->addr.sockAddr6.sin6_family == AF_INET6)\n\t\tsprintf(ses->serverName, \"%pI6\",\n\t\t\t&server->addr.sockAddr6.sin6_addr);\n\telse\n\t\tsprintf(ses->serverName, \"%pI4\",\n\t\t\t&server->addr.sockAddr.sin_addr.s_addr);\n\n\tif (volume_info->username)\n\t\tstrncpy(ses->userName, volume_info->username,\n\t\t\tMAX_USERNAME_SIZE);\n\n\t/* volume_info->password freed at unmount */\n\tif (volume_info->password) {\n\t\tses->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!ses->password)\n\t\t\tgoto get_ses_fail;\n\t}\n\tif (volume_info->domainname) {\n\t\tint len = strlen(volume_info->domainname);\n\t\tses->domainName = kmalloc(len + 1, GFP_KERNEL);\n\t\tif (ses->domainName)\n\t\t\tstrcpy(ses->domainName, volume_info->domainname);\n\t}\n\tses->linux_uid = volume_info->linux_uid;\n\tses->overrideSecFlg = volume_info->secFlg;\n\n\tmutex_lock(&ses->session_mutex);\n\trc = cifs_negotiate_protocol(xid, ses);\n\tif (!rc)\n\t\trc = cifs_setup_session(xid, ses, volume_info->local_nls);\n\tmutex_unlock(&ses->session_mutex);\n\tif (rc)\n\t\tgoto get_ses_fail;\n\n\t/* success, put it on the list */\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&ses->smb_ses_list, &server->smb_ses_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\tFreeXid(xid);\n\treturn ses;\n\nget_ses_fail:\n\tsesInfoFree(ses);\n\tFreeXid(xid);\n\treturn ERR_PTR(rc);\n}\n\nstatic struct cifsTconInfo *\ncifs_find_tcon(struct cifsSesInfo *ses, const char *unc)\n{\n\tstruct list_head *tmp;\n\tstruct cifsTconInfo *tcon;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &ses->tcon_list) {\n\t\ttcon = list_entry(tmp, struct cifsTconInfo, tcon_list);\n\t\tif (tcon->tidStatus == CifsExiting)\n\t\t\tcontinue;\n\t\tif (strncmp(tcon->treeName, unc, MAX_TREE_SIZE))\n\t\t\tcontinue;\n\n\t\t++tcon->tc_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn tcon;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}\n\nstatic void\ncifs_put_tcon(struct cifsTconInfo *tcon)\n{\n\tint xid;\n\tstruct cifsSesInfo *ses = tcon->ses;\n\n\tcFYI(1, \"%s: tc_count=%d\\n\", __func__, tcon->tc_count);\n\twrite_lock(&cifs_tcp_ses_lock);\n\tif (--tcon->tc_count > 0) {\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\n\tlist_del_init(&tcon->tcon_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\txid = GetXid();\n\tCIFSSMBTDis(xid, tcon);\n\t_FreeXid(xid);\n\n\ttconInfoFree(tcon);\n\tcifs_put_smb_ses(ses);\n}\n\nstatic struct cifsTconInfo *\ncifs_get_tcon(struct cifsSesInfo *ses, struct smb_vol *volume_info)\n{\n\tint rc, xid;\n\tstruct cifsTconInfo *tcon;\n\n\ttcon = cifs_find_tcon(ses, volume_info->UNC);\n\tif (tcon) {\n\t\tcFYI(1, \"Found match on UNC path\");\n\t\t/* existing tcon already has a reference */\n\t\tcifs_put_smb_ses(ses);\n\t\tif (tcon->seal != volume_info->seal)\n\t\t\tcERROR(1, \"transport encryption setting \"\n\t\t\t\t   \"conflicts with existing tid\");\n\t\treturn tcon;\n\t}\n\n\ttcon = tconInfoAlloc();\n\tif (tcon == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out_fail;\n\t}\n\n\ttcon->ses = ses;\n\tif (volume_info->password) {\n\t\ttcon->password = kstrdup(volume_info->password, GFP_KERNEL);\n\t\tif (!tcon->password) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (strchr(volume_info->UNC + 3, '\\\\') == NULL\n\t    && strchr(volume_info->UNC + 3, '/') == NULL) {\n\t\tcERROR(1, \"Missing share name\");\n\t\trc = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\t/* BB Do we need to wrap session_mutex around\n\t * this TCon call and Unix SetFS as\n\t * we do on SessSetup and reconnect? */\n\txid = GetXid();\n\trc = CIFSTCon(xid, ses, volume_info->UNC, tcon, volume_info->local_nls);\n\tFreeXid(xid);\n\tcFYI(1, \"CIFS Tcon rc = %d\", rc);\n\tif (rc)\n\t\tgoto out_fail;\n\n\tif (volume_info->nodfs) {\n\t\ttcon->Flags &= ~SMB_SHARE_IS_IN_DFS;\n\t\tcFYI(1, \"DFS disabled (%d)\", tcon->Flags);\n\t}\n\ttcon->seal = volume_info->seal;\n\t/* we can have only one retry value for a connection\n\t   to a share so for resources mounted more than once\n\t   to the same server share the last value passed in\n\t   for the retry flag is used */\n\ttcon->retry = volume_info->retry;\n\ttcon->nocase = volume_info->nocase;\n\ttcon->local_lease = volume_info->local_lease;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_add(&tcon->tcon_list, &ses->tcon_list);\n\twrite_unlock(&cifs_tcp_ses_lock);\n\n\treturn tcon;\n\nout_fail:\n\ttconInfoFree(tcon);\n\treturn ERR_PTR(rc);\n}\n\n\nint\nget_dfs_path(int xid, struct cifsSesInfo *pSesInfo, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *pnum_referrals,\n\t     struct dfs_info3_param **preferrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\t*pnum_referrals = 0;\n\t*preferrals = NULL;\n\n\tif (pSesInfo->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(pSesInfo->serverName,\n\t\t\t\tSERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t + 1 + 4 /* slash IPC$ */  + 2,\n\t\t\t\tGFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, pSesInfo->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(pSesInfo->serverName), \"\\\\IPC$\");\n\t\trc = CIFSTCon(xid, pSesInfo, temp_unc, NULL, nls_codepage);\n\t\tcFYI(1, \"CIFS Tcon rc = %d ipc_tid = %d\", rc, pSesInfo->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = CIFSGetDFSRefer(xid, pSesInfo, old_path, preferrals,\n\t\t\t\t     pnum_referrals, nls_codepage, remap);\n\t/* BB map targetUNCs to dfs_info3 structures, here or\n\t\tin CIFSGetDFSRefer BB */\n\n\treturn rc;\n}\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\nstatic struct lock_class_key cifs_key[2];\nstatic struct lock_class_key cifs_slock_key[2];\n\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET-CIFS\",\n\t\t&cifs_slock_key[0], \"sk_lock-AF_INET-CIFS\", &cifs_key[0]);\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tBUG_ON(sock_owned_by_user(sk));\n\tsock_lock_init_class_and_name(sk, \"slock-AF_INET6-CIFS\",\n\t\t&cifs_slock_key[1], \"sk_lock-AF_INET6-CIFS\", &cifs_key[1]);\n}\n#else\nstatic inline void\ncifs_reclassify_socket4(struct socket *sock)\n{\n}\n\nstatic inline void\ncifs_reclassify_socket6(struct socket *sock)\n{\n}\n#endif\n\n/* See RFC1001 section 14 on representation of Netbios names */\nstatic void rfc1002mangle(char *target, char *source, unsigned int length)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0, j = 0; i < (length); i++) {\n\t\t/* mask a nibble at a time and encode */\n\t\ttarget[j] = 'A' + (0x0F & (source[i] >> 4));\n\t\ttarget[j+1] = 'A' + (0x0F & source[i]);\n\t\tj += 2;\n\t}\n\n}\n\n\nstatic int\nipv4_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tint val;\n\tbool connected = false;\n\t__be16 orig_port = 0;\n\tstruct socket *socket = server->ssocket;\n\n\tif (socket == NULL) {\n\t\trc = sock_create_kern(PF_INET, SOCK_STREAM,\n\t\t\t\t      IPPROTO_TCP, &socket);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating socket\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tcifs_reclassify_socket4(socket);\n\t}\n\n\t/* user overrode default port */\n\tif (server->addr.sockAddr.sin_port) {\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t  &server->addr.sockAddr,\n\t\t\t\t\t  sizeof(struct sockaddr_in), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\t/* save original port so we can retry user specified port\n\t\t\tlater if fall back ports fail this time  */\n\t\torig_port = server->addr.sockAddr.sin_port;\n\n\t\t/* do not retry on the same port we just failed on */\n\t\tif (server->addr.sockAddr.sin_port != htons(CIFS_PORT)) {\n\t\t\tserver->addr.sockAddr.sin_port = htons(CIFS_PORT);\n\t\t\trc = socket->ops->connect(socket,\n\t\t\t\t\t\t(struct sockaddr *)\n\t\t\t\t\t\t&server->addr.sockAddr,\n\t\t\t\t\t\tsizeof(struct sockaddr_in), 0);\n\t\t\tif (rc >= 0)\n\t\t\t\tconnected = true;\n\t\t}\n\t}\n\tif (!connected) {\n\t\tserver->addr.sockAddr.sin_port = htons(RFC1001_PORT);\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t      &server->addr.sockAddr,\n\t\t\t\t\t      sizeof(struct sockaddr_in), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\t/* give up here - unless we want to retry on different\n\t\tprotocol families some day */\n\tif (!connected) {\n\t\tif (orig_port)\n\t\t\tserver->addr.sockAddr.sin_port = orig_port;\n\t\tcFYI(1, \"Error %d connecting to server via ipv4\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t *  the default. sock_setsockopt not used because it expects\n\t *  user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\t/* make the bufsizes depend on wsize/rsize and max requests */\n\tif (server->noautotune) {\n\t\tif (socket->sk->sk_sndbuf < (200 * 1024))\n\t\t\tsocket->sk->sk_sndbuf = 200 * 1024;\n\t\tif (socket->sk->sk_rcvbuf < (140 * 1024))\n\t\t\tsocket->sk->sk_rcvbuf = 140 * 1024;\n\t}\n\n\tif (server->tcp_nodelay) {\n\t\tval = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\t cFYI(1, \"sndbuf %d rcvbuf %d rcvtimeo 0x%lx\",\n\t\t socket->sk->sk_sndbuf,\n\t\t socket->sk->sk_rcvbuf, socket->sk->sk_rcvtimeo);\n\n\t/* send RFC1001 sessinit */\n\tif (server->addr.sockAddr.sin_port == htons(RFC1001_PORT)) {\n\t\t/* some servers require RFC1001 sessinit before sending\n\t\tnegprot - BB check reconnection in case where second\n\t\tsessinit is sent but no second negprot */\n\t\tstruct rfc1002_session_packet *ses_init_buf;\n\t\tstruct smb_hdr *smb_buf;\n\t\tses_init_buf = kzalloc(sizeof(struct rfc1002_session_packet),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (ses_init_buf) {\n\t\t\tses_init_buf->trailer.session_req.called_len = 32;\n\t\t\tif (server->server_RFC1001_name &&\n\t\t\t    server->server_RFC1001_name[0] != 0)\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.called_name,\n\t\t\t\t\t      server->server_RFC1001_name,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\t\telse\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.called_name,\n\t\t\t\t\t      DEFAULT_CIFS_CALLED_NAME,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\tses_init_buf->trailer.session_req.calling_len = 32;\n\n\t\t\t/* calling name ends in null (byte 16) from old smb\n\t\t\tconvention. */\n\t\t\tif (server->workstation_RFC1001_name &&\n\t\t\t    server->workstation_RFC1001_name[0] != 0)\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.calling_name,\n\t\t\t\t\t      server->workstation_RFC1001_name,\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\t\t\telse\n\t\t\t\trfc1002mangle(ses_init_buf->trailer.\n\t\t\t\t\t\tsession_req.calling_name,\n\t\t\t\t\t      \"LINUX_CIFS_CLNT\",\n\t\t\t\t\t      RFC1001_NAME_LEN_WITH_NULL);\n\n\t\t\tses_init_buf->trailer.session_req.scope1 = 0;\n\t\t\tses_init_buf->trailer.session_req.scope2 = 0;\n\t\t\tsmb_buf = (struct smb_hdr *)ses_init_buf;\n\t\t\t/* sizeof RFC1002_SESSION_REQUEST with no scope */\n\t\t\tsmb_buf->smb_buf_length = 0x81000044;\n\t\t\trc = smb_send(server, smb_buf, 0x44);\n\t\t\tkfree(ses_init_buf);\n\t\t\tmsleep(1); /* RFC1001 layer in at least one server\n\t\t\t\t      requires very short break before negprot\n\t\t\t\t      presumably because not expecting negprot\n\t\t\t\t      to follow so fast.  This is a simple\n\t\t\t\t      solution that works without\n\t\t\t\t      complicating the code and causes no\n\t\t\t\t      significant slowing down on mount\n\t\t\t\t      for everyone else */\n\t\t}\n\t\t/* else the negprot may still work without this\n\t\teven though malloc failed */\n\n\t}\n\n\treturn rc;\n}\n\nstatic int\nipv6_connect(struct TCP_Server_Info *server)\n{\n\tint rc = 0;\n\tint val;\n\tbool connected = false;\n\t__be16 orig_port = 0;\n\tstruct socket *socket = server->ssocket;\n\n\tif (socket == NULL) {\n\t\trc = sock_create_kern(PF_INET6, SOCK_STREAM,\n\t\t\t\t      IPPROTO_TCP, &socket);\n\t\tif (rc < 0) {\n\t\t\tcERROR(1, \"Error %d creating ipv6 socket\", rc);\n\t\t\tsocket = NULL;\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* BB other socket options to set KEEPALIVE, NODELAY? */\n\t\tcFYI(1, \"ipv6 Socket created\");\n\t\tserver->ssocket = socket;\n\t\tsocket->sk->sk_allocation = GFP_NOFS;\n\t\tcifs_reclassify_socket6(socket);\n\t}\n\n\t/* user overrode default port */\n\tif (server->addr.sockAddr6.sin6_port) {\n\t\trc = socket->ops->connect(socket,\n\t\t\t\t(struct sockaddr *) &server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\tif (!connected) {\n\t\t/* save original port so we can retry user specified port\n\t\t\tlater if fall back ports fail this time  */\n\n\t\torig_port = server->addr.sockAddr6.sin6_port;\n\t\t/* do not retry on the same port we just failed on */\n\t\tif (server->addr.sockAddr6.sin6_port != htons(CIFS_PORT)) {\n\t\t\tserver->addr.sockAddr6.sin6_port = htons(CIFS_PORT);\n\t\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\t\tif (rc >= 0)\n\t\t\t\tconnected = true;\n\t\t}\n\t}\n\tif (!connected) {\n\t\tserver->addr.sockAddr6.sin6_port = htons(RFC1001_PORT);\n\t\trc = socket->ops->connect(socket, (struct sockaddr *)\n\t\t\t\t&server->addr.sockAddr6,\n\t\t\t\tsizeof(struct sockaddr_in6), 0);\n\t\tif (rc >= 0)\n\t\t\tconnected = true;\n\t}\n\n\t/* give up here - unless we want to retry on different\n\t\tprotocol families some day */\n\tif (!connected) {\n\t\tif (orig_port)\n\t\t\tserver->addr.sockAddr6.sin6_port = orig_port;\n\t\tcFYI(1, \"Error %d connecting to server via ipv6\", rc);\n\t\tsock_release(socket);\n\t\tserver->ssocket = NULL;\n\t\treturn rc;\n\t}\n\n\t/*\n\t * Eventually check for other socket options to change from\n\t * the default. sock_setsockopt not used because it expects\n\t * user space buffer\n\t */\n\tsocket->sk->sk_rcvtimeo = 7 * HZ;\n\tsocket->sk->sk_sndtimeo = 5 * HZ;\n\n\tif (server->tcp_nodelay) {\n\t\tval = 1;\n\t\trc = kernel_setsockopt(socket, SOL_TCP, TCP_NODELAY,\n\t\t\t\t(char *)&val, sizeof(val));\n\t\tif (rc)\n\t\t\tcFYI(1, \"set TCP_NODELAY socket option error %d\", rc);\n\t}\n\n\tserver->ssocket = socket;\n\n\treturn rc;\n}\n\nvoid reset_cifs_unix_caps(int xid, struct cifsTconInfo *tcon,\n\t\t\t  struct super_block *sb, struct smb_vol *vol_info)\n{\n\t/* if we are reconnecting then should we check to see if\n\t * any requested capabilities changed locally e.g. via\n\t * remount but we can not do much about it here\n\t * if they have (even if we could detect it by the following)\n\t * Perhaps we could add a backpointer to array of sb from tcon\n\t * or if we change to make all sb to same share the same\n\t * sb as NFS - then we only have one backpointer to sb.\n\t * What if we wanted to mount the server share twice once with\n\t * and once without posixacls or posix paths? */\n\t__u64 saved_cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\tif (vol_info && vol_info->no_linux_ext) {\n\t\ttcon->fsUnixInfo.Capability = 0;\n\t\ttcon->unix_ext = 0; /* Unix Extensions disabled */\n\t\tcFYI(1, \"Linux protocol extensions disabled\");\n\t\treturn;\n\t} else if (vol_info)\n\t\ttcon->unix_ext = 1; /* Unix Extensions supported */\n\n\tif (tcon->unix_ext == 0) {\n\t\tcFYI(1, \"Unix extensions disabled so not set on reconnect\");\n\t\treturn;\n\t}\n\n\tif (!CIFSSMBQFSUnixInfo(xid, tcon)) {\n\t\t__u64 cap = le64_to_cpu(tcon->fsUnixInfo.Capability);\n\n\t\t/* check for reconnect case in which we do not\n\t\t   want to change the mount behavior if we can avoid it */\n\t\tif (vol_info == NULL) {\n\t\t\t/* turn off POSIX ACL and PATHNAMES if not set\n\t\t\t   originally at mount time */\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_ACL_CAP) == 0)\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\t\tif ((saved_cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\t\t\tcERROR(1, \"POSIXPATH support change\");\n\t\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\t\t} else if ((cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) == 0) {\n\t\t\t\tcERROR(1, \"possible reconnect error\");\n\t\t\t\tcERROR(1, \"server disabled POSIX path support\");\n\t\t\t}\n\t\t}\n\n\t\tcap &= CIFS_UNIX_CAP_MASK;\n\t\tif (vol_info && vol_info->no_psx_acl)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_ACL_CAP;\n\t\telse if (CIFS_UNIX_POSIX_ACL_CAP & cap) {\n\t\t\tcFYI(1, \"negotiated posix acl support\");\n\t\t\tif (sb)\n\t\t\t\tsb->s_flags |= MS_POSIXACL;\n\t\t}\n\n\t\tif (vol_info && vol_info->posix_paths == 0)\n\t\t\tcap &= ~CIFS_UNIX_POSIX_PATHNAMES_CAP;\n\t\telse if (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP) {\n\t\t\tcFYI(1, \"negotiate posix pathnames\");\n\t\t\tif (sb)\n\t\t\t\tCIFS_SB(sb)->mnt_cifs_flags |=\n\t\t\t\t\tCIFS_MOUNT_POSIX_PATHS;\n\t\t}\n\n\t\t/* We might be setting the path sep back to a different\n\t\tform if we are reconnecting and the server switched its\n\t\tposix path capability for this share */\n\t\tif (sb && (CIFS_SB(sb)->prepathlen > 0))\n\t\t\tCIFS_SB(sb)->prepath[0] = CIFS_DIR_SEP(CIFS_SB(sb));\n\n\t\tif (sb && (CIFS_SB(sb)->rsize > 127 * 1024)) {\n\t\t\tif ((cap & CIFS_UNIX_LARGE_READ_CAP) == 0) {\n\t\t\t\tCIFS_SB(sb)->rsize = 127 * 1024;\n\t\t\t\tcFYI(DBG2, \"larger reads not supported by srv\");\n\t\t\t}\n\t\t}\n\n\n\t\tcFYI(1, \"Negotiate caps 0x%x\", (int)cap);\n#ifdef CONFIG_CIFS_DEBUG2\n\t\tif (cap & CIFS_UNIX_FCNTL_CAP)\n\t\t\tcFYI(1, \"FCNTL cap\");\n\t\tif (cap & CIFS_UNIX_EXTATTR_CAP)\n\t\t\tcFYI(1, \"EXTATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_PATHNAMES_CAP)\n\t\t\tcFYI(1, \"POSIX path cap\");\n\t\tif (cap & CIFS_UNIX_XATTR_CAP)\n\t\t\tcFYI(1, \"XATTR cap\");\n\t\tif (cap & CIFS_UNIX_POSIX_ACL_CAP)\n\t\t\tcFYI(1, \"POSIX ACL cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_READ_CAP)\n\t\t\tcFYI(1, \"very large read cap\");\n\t\tif (cap & CIFS_UNIX_LARGE_WRITE_CAP)\n\t\t\tcFYI(1, \"very large write cap\");\n#endif /* CIFS_DEBUG2 */\n\t\tif (CIFSSMBSetFSUnixInfo(xid, tcon, cap)) {\n\t\t\tif (vol_info == NULL) {\n\t\t\t\tcFYI(1, \"resetting capabilities failed\");\n\t\t\t} else\n\t\t\t\tcERROR(1, \"Negotiating Unix capabilities \"\n\t\t\t\t\t   \"with the server failed.  Consider \"\n\t\t\t\t\t   \"mounting with the Unix Extensions\\n\"\n\t\t\t\t\t   \"disabled, if problems are found, \"\n\t\t\t\t\t   \"by specifying the nounix mount \"\n\t\t\t\t\t   \"option.\");\n\n\t\t}\n\t}\n}\n\nstatic void\nconvert_delimiter(char *path, char delim)\n{\n\tint i;\n\tchar old_delim;\n\n\tif (path == NULL)\n\t\treturn;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tfor (i = 0; path[i] != '\\0'; i++) {\n\t\tif (path[i] == old_delim)\n\t\t\tpath[i] = delim;\n\t}\n}\n\nstatic void setup_cifs_sb(struct smb_vol *pvolume_info,\n\t\t\t  struct cifs_sb_info *cifs_sb)\n{\n\tif (pvolume_info->rsize > CIFSMaxBufSize) {\n\t\tcERROR(1, \"rsize %d too large, using MaxBufSize\",\n\t\t\tpvolume_info->rsize);\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\t} else if ((pvolume_info->rsize) &&\n\t\t\t(pvolume_info->rsize <= CIFSMaxBufSize))\n\t\tcifs_sb->rsize = pvolume_info->rsize;\n\telse /* default */\n\t\tcifs_sb->rsize = CIFSMaxBufSize;\n\n\tif (pvolume_info->wsize > PAGEVEC_SIZE * PAGE_CACHE_SIZE) {\n\t\tcERROR(1, \"wsize %d too large, using 4096 instead\",\n\t\t\t  pvolume_info->wsize);\n\t\tcifs_sb->wsize = 4096;\n\t} else if (pvolume_info->wsize)\n\t\tcifs_sb->wsize = pvolume_info->wsize;\n\telse\n\t\tcifs_sb->wsize = min_t(const int,\n\t\t\t\t\tPAGEVEC_SIZE * PAGE_CACHE_SIZE,\n\t\t\t\t\t127*1024);\n\t\t/* old default of CIFSMaxBufSize was too small now\n\t\t   that SMB Write2 can send multiple pages in kvec.\n\t\t   RFC1001 does not describe what happens when frame\n\t\t   bigger than 128K is sent so use that as max in\n\t\t   conjunction with 52K kvec constraint on arch with 4K\n\t\t   page size  */\n\n\tif (cifs_sb->rsize < 2048) {\n\t\tcifs_sb->rsize = 2048;\n\t\t/* Windows ME may prefer this */\n\t\tcFYI(1, \"readsize set to minimum: 2048\");\n\t}\n\t/* calculate prepath */\n\tcifs_sb->prepath = pvolume_info->prepath;\n\tif (cifs_sb->prepath) {\n\t\tcifs_sb->prepathlen = strlen(cifs_sb->prepath);\n\t\t/* we can not convert the / to \\ in the path\n\t\tseparators in the prefixpath yet because we do not\n\t\tknow (until reset_cifs_unix_caps is called later)\n\t\twhether POSIX PATH CAP is available. We normalize\n\t\tthe / to \\ after reset_cifs_unix_caps is called */\n\t\tpvolume_info->prepath = NULL;\n\t} else\n\t\tcifs_sb->prepathlen = 0;\n\tcifs_sb->mnt_uid = pvolume_info->linux_uid;\n\tcifs_sb->mnt_gid = pvolume_info->linux_gid;\n\tcifs_sb->mnt_file_mode = pvolume_info->file_mode;\n\tcifs_sb->mnt_dir_mode = pvolume_info->dir_mode;\n\tcFYI(1, \"file mode: 0x%x  dir mode: 0x%x\",\n\t\tcifs_sb->mnt_file_mode, cifs_sb->mnt_dir_mode);\n\n\tif (pvolume_info->noperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_PERM;\n\tif (pvolume_info->setuids)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SET_UID;\n\tif (pvolume_info->server_ino)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_SERVER_INUM;\n\tif (pvolume_info->remap)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_MAP_SPECIAL_CHR;\n\tif (pvolume_info->no_xattr)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_XATTR;\n\tif (pvolume_info->sfu_emul)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_UNX_EMUL;\n\tif (pvolume_info->nobrl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_BRL;\n\tif (pvolume_info->nostrictsync)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOSSYNC;\n\tif (pvolume_info->mand_lock)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NOPOSIXBRL;\n\tif (pvolume_info->cifs_acl)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_CIFS_ACL;\n\tif (pvolume_info->override_uid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_UID;\n\tif (pvolume_info->override_gid)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_OVERR_GID;\n\tif (pvolume_info->dynperm)\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DYNPERM;\n\tif (pvolume_info->direct_io) {\n\t\tcFYI(1, \"mounting share using direct i/o\");\n\t\tcifs_sb->mnt_cifs_flags |= CIFS_MOUNT_DIRECT_IO;\n\t}\n\n\tif ((pvolume_info->cifs_acl) && (pvolume_info->dynperm))\n\t\tcERROR(1, \"mount option dynperm ignored if cifsacl \"\n\t\t\t   \"mount option supported\");\n}\n\nstatic int\nis_path_accessible(int xid, struct cifsTconInfo *tcon,\n\t\t   struct cifs_sb_info *cifs_sb, const char *full_path)\n{\n\tint rc;\n\tFILE_ALL_INFO *pfile_info;\n\n\tpfile_info = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (pfile_info == NULL)\n\t\treturn -ENOMEM;\n\n\trc = CIFSSMBQPathInfo(xid, tcon, full_path, pfile_info,\n\t\t\t      0 /* not legacy */, cifs_sb->local_nls,\n\t\t\t      cifs_sb->mnt_cifs_flags &\n\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tkfree(pfile_info);\n\treturn rc;\n}\n\nstatic void\ncleanup_volume_info(struct smb_vol **pvolume_info)\n{\n\tstruct smb_vol *volume_info;\n\n\tif (!pvolume_info || !*pvolume_info)\n\t\treturn;\n\n\tvolume_info = *pvolume_info;\n\tkzfree(volume_info->password);\n\tkfree(volume_info->UNC);\n\tkfree(volume_info->prepath);\n\tkfree(volume_info);\n\t*pvolume_info = NULL;\n\treturn;\n}\n\n#ifdef CONFIG_CIFS_DFS_UPCALL\n/* build_path_to_root returns full path to root when\n * we do not have an exiting connection (tcon) */\nstatic char *\nbuild_unc_path_to_root(const struct smb_vol *volume_info,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path;\n\n\tint unc_len = strnlen(volume_info->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + cifs_sb->prepathlen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, volume_info->UNC, unc_len);\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\tint i;\n\t\tfor (i = 0; i < unc_len; i++) {\n\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\tfull_path[i] = '/';\n\t\t}\n\t}\n\n\tif (cifs_sb->prepathlen)\n\t\tstrncpy(full_path + unc_len, cifs_sb->prepath,\n\t\t\t\tcifs_sb->prepathlen);\n\n\tfull_path[unc_len + cifs_sb->prepathlen] = 0; /* add trailing null */\n\treturn full_path;\n}\n#endif\n\nint\ncifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n\t\tchar *mount_data_global, const char *devname)\n{\n\tint rc;\n\tint xid;\n\tstruct smb_vol *volume_info;\n\tstruct cifsSesInfo *pSesInfo;\n\tstruct cifsTconInfo *tcon;\n\tstruct TCP_Server_Info *srvTcp;\n\tchar   *full_path;\n\tchar *mount_data = mount_data_global;\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tint referral_walks_count = 0;\ntry_mount_again:\n#endif\n\trc = 0;\n\ttcon = NULL;\n\tpSesInfo = NULL;\n\tsrvTcp = NULL;\n\tfull_path = NULL;\n\n\txid = GetXid();\n\n\tvolume_info = kzalloc(sizeof(struct smb_vol), GFP_KERNEL);\n\tif (!volume_info) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (cifs_parse_mount_options(mount_data, devname, volume_info)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (volume_info->nullauth) {\n\t\tcFYI(1, \"null user\");\n\t\tvolume_info->username = \"\";\n\t} else if (volume_info->username) {\n\t\t/* BB fixme parse for domain name here */\n\t\tcFYI(1, \"Username: %s\", volume_info->username);\n\t} else {\n\t\tcifserror(\"No username specified\");\n\t/* In userspace mount helper we can get user name from alternate\n\t   locations such as env variables and files on disk */\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* this is needed for ASCII cp to Unicode converts */\n\tif (volume_info->iocharset == NULL) {\n\t\t/* load_nls_default cannot return null */\n\t\tvolume_info->local_nls = load_nls_default();\n\t} else {\n\t\tvolume_info->local_nls = load_nls(volume_info->iocharset);\n\t\tif (volume_info->local_nls == NULL) {\n\t\t\tcERROR(1, \"CIFS mount error: iocharset %s not found\",\n\t\t\t\t volume_info->iocharset);\n\t\t\trc = -ELIBACC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tcifs_sb->local_nls = volume_info->local_nls;\n\n\t/* get a reference to a tcp session */\n\tsrvTcp = cifs_get_tcp_session(volume_info);\n\tif (IS_ERR(srvTcp)) {\n\t\trc = PTR_ERR(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* get a reference to a SMB session */\n\tpSesInfo = cifs_get_smb_ses(srvTcp, volume_info);\n\tif (IS_ERR(pSesInfo)) {\n\t\trc = PTR_ERR(pSesInfo);\n\t\tpSesInfo = NULL;\n\t\tgoto mount_fail_check;\n\t}\n\n\tsetup_cifs_sb(volume_info, cifs_sb);\n\tif (pSesInfo->capabilities & CAP_LARGE_FILES)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\telse\n\t\tsb->s_maxbytes = MAX_NON_LFS;\n\n\t/* BB FIXME fix time_gran to be larger for LANMAN sessions */\n\tsb->s_time_gran = 100;\n\n\t/* search for existing tcon to this server share */\n\ttcon = cifs_get_tcon(pSesInfo, volume_info);\n\tif (IS_ERR(tcon)) {\n\t\trc = PTR_ERR(tcon);\n\t\ttcon = NULL;\n\t\tgoto remote_path_check;\n\t}\n\n\tcifs_sb->tcon = tcon;\n\n\t/* do not care if following two calls succeed - informational */\n\tif (!tcon->ipc) {\n\t\tCIFSSMBQFSDeviceInfo(xid, tcon);\n\t\tCIFSSMBQFSAttributeInfo(xid, tcon);\n\t}\n\n\t/* tell server which Unix caps we support */\n\tif (tcon->ses->capabilities & CAP_UNIX)\n\t\t/* reset of caps checks mount to see if unix extensions\n\t\t   disabled for just this mount */\n\t\treset_cifs_unix_caps(xid, tcon, sb, volume_info);\n\telse\n\t\ttcon->unix_ext = 0; /* server does not support them */\n\n\t/* convert forward to back slashes in prepath here if needed */\n\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\tconvert_delimiter(cifs_sb->prepath, CIFS_DIR_SEP(cifs_sb));\n\n\tif ((tcon->unix_ext == 0) && (cifs_sb->rsize > (1024 * 127))) {\n\t\tcifs_sb->rsize = 1024 * 127;\n\t\tcFYI(DBG2, \"no very large read support, rsize now 127K\");\n\t}\n\tif (!(tcon->ses->capabilities & CAP_LARGE_WRITE_X))\n\t\tcifs_sb->wsize = min(cifs_sb->wsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\tif (!(tcon->ses->capabilities & CAP_LARGE_READ_X))\n\t\tcifs_sb->rsize = min(cifs_sb->rsize,\n\t\t\t       (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE));\n\nremote_path_check:\n\t/* check if a whole path (including prepath) is not remote */\n\tif (!rc && cifs_sb->prepathlen && tcon) {\n\t\t/* build_path_to_root works only when we have a valid tcon */\n\t\tfull_path = cifs_build_path_to_root(cifs_sb);\n\t\tif (full_path == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\trc = is_path_accessible(xid, tcon, cifs_sb, full_path);\n\t\tif (rc != -EREMOTE) {\n\t\t\tkfree(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\tkfree(full_path);\n\t}\n\n\t/* get referral if needed */\n\tif (rc == -EREMOTE) {\n#ifdef CONFIG_CIFS_DFS_UPCALL\n\t\tif (referral_walks_count > MAX_NESTED_LINKS) {\n\t\t\t/*\n\t\t\t * BB: when we implement proper loop detection,\n\t\t\t *     we will remove this check. But now we need it\n\t\t\t *     to prevent an indefinite loop if 'DFS tree' is\n\t\t\t *     misconfigured (i.e. has loops).\n\t\t\t */\n\t\t\trc = -ELOOP;\n\t\t\tgoto mount_fail_check;\n\t\t}\n\t\t/* convert forward to back slashes in prepath here if needed */\n\t\tif ((cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) == 0)\n\t\t\tconvert_delimiter(cifs_sb->prepath,\n\t\t\t\t\tCIFS_DIR_SEP(cifs_sb));\n\t\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\t\tif (IS_ERR(full_path)) {\n\t\t\trc = PTR_ERR(full_path);\n\t\t\tgoto mount_fail_check;\n\t\t}\n\n\t\tcFYI(1, \"Getting referral for: %s\", full_path);\n\t\trc = get_dfs_path(xid, pSesInfo , full_path + 1,\n\t\t\tcifs_sb->local_nls, &num_referrals, &referrals,\n\t\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (!rc && num_referrals > 0) {\n\t\t\tchar *fake_devname = NULL;\n\n\t\t\tif (mount_data != mount_data_global)\n\t\t\t\tkfree(mount_data);\n\n\t\t\tmount_data = cifs_compose_mount_options(\n\t\t\t\t\tcifs_sb->mountdata, full_path + 1,\n\t\t\t\t\treferrals, &fake_devname);\n\n\t\t\tfree_dfs_info_array(referrals, num_referrals);\n\t\t\tkfree(fake_devname);\n\t\t\tkfree(full_path);\n\n\t\t\tif (IS_ERR(mount_data)) {\n\t\t\t\trc = PTR_ERR(mount_data);\n\t\t\t\tmount_data = NULL;\n\t\t\t\tgoto mount_fail_check;\n\t\t\t}\n\n\t\t\tif (tcon)\n\t\t\t\tcifs_put_tcon(tcon);\n\t\t\telse if (pSesInfo)\n\t\t\t\tcifs_put_smb_ses(pSesInfo);\n\n\t\t\tcleanup_volume_info(&volume_info);\n\t\t\treferral_walks_count++;\n\t\t\tFreeXid(xid);\n\t\t\tgoto try_mount_again;\n\t\t}\n#else /* No DFS support, return error on mount */\n\t\trc = -EOPNOTSUPP;\n#endif\n\t}\n\nmount_fail_check:\n\t/* on error free sesinfo and tcon struct if needed */\n\tif (rc) {\n\t\tif (mount_data != mount_data_global)\n\t\t\tkfree(mount_data);\n\t\t/* If find_unc succeeded then rc == 0 so we can not end */\n\t\t/* up accidently freeing someone elses tcon struct */\n\t\tif (tcon)\n\t\t\tcifs_put_tcon(tcon);\n\t\telse if (pSesInfo)\n\t\t\tcifs_put_smb_ses(pSesInfo);\n\t\telse\n\t\t\tcifs_put_tcp_session(srvTcp);\n\t\tgoto out;\n\t}\n\n\t/* volume_info->password is freed above when existing session found\n\t(in which case it is not needed anymore) but when new sesion is created\n\tthe password ptr is put in the new session structure (in which case the\n\tpassword will be freed at unmount time) */\nout:\n\t/* zero out password before freeing */\n\tcleanup_volume_info(&volume_info);\n\tFreeXid(xid);\n\treturn rc;\n}\n\nint\nCIFSTCon(unsigned int xid, struct cifsSesInfo *ses,\n\t const char *tree, struct cifsTconInfo *tcon,\n\t const struct nls_table *nls_codepage)\n{\n\tstruct smb_hdr *smb_buffer;\n\tstruct smb_hdr *smb_buffer_response;\n\tTCONX_REQ *pSMB;\n\tTCONX_RSP *pSMBr;\n\tunsigned char *bcc_ptr;\n\tint rc = 0;\n\tint length, bytes_left;\n\t__u16 count;\n\n\tif (ses == NULL)\n\t\treturn -EIO;\n\n\tsmb_buffer = cifs_buf_get();\n\tif (smb_buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tsmb_buffer_response = smb_buffer;\n\n\theader_assemble(smb_buffer, SMB_COM_TREE_CONNECT_ANDX,\n\t\t\tNULL /*no tid */ , 4 /*wct */ );\n\n\tsmb_buffer->Mid = GetNextMid(ses->server);\n\tsmb_buffer->Uid = ses->Suid;\n\tpSMB = (TCONX_REQ *) smb_buffer;\n\tpSMBr = (TCONX_RSP *) smb_buffer_response;\n\n\tpSMB->AndXCommand = 0xFF;\n\tpSMB->Flags = cpu_to_le16(TCON_EXTENDED_SECINFO);\n\tbcc_ptr = &pSMB->Password[0];\n\tif ((ses->server->secMode) & SECMODE_USER) {\n\t\tpSMB->PasswordLength = cpu_to_le16(1);\t/* minimum */\n\t\t*bcc_ptr = 0; /* password is null byte */\n\t\tbcc_ptr++;              /* skip password */\n\t\t/* already aligned so no need to do it below */\n\t} else {\n\t\tpSMB->PasswordLength = cpu_to_le16(CIFS_SESS_KEY_SIZE);\n\t\t/* BB FIXME add code to fail this if NTLMv2 or Kerberos\n\t\t   specified as required (when that support is added to\n\t\t   the vfs in the future) as only NTLM or the much\n\t\t   weaker LANMAN (which we do not send by default) is accepted\n\t\t   by Samba (not sure whether other servers allow\n\t\t   NTLMv2 password here) */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tif ((global_secflags & CIFSSEC_MAY_LANMAN) &&\n\t\t    (ses->server->secType == LANMAN))\n\t\t\tcalc_lanman_hash(tcon->password, ses->server->cryptKey,\n\t\t\t\t\t ses->server->secMode &\n\t\t\t\t\t    SECMODE_PW_ENCRYPT ? true : false,\n\t\t\t\t\t bcc_ptr);\n\t\telse\n#endif /* CIFS_WEAK_PW_HASH */\n\t\tSMBNTencrypt(tcon->password, ses->server->cryptKey,\n\t\t\t     bcc_ptr);\n\n\t\tbcc_ptr += CIFS_SESS_KEY_SIZE;\n\t\tif (ses->capabilities & CAP_UNICODE) {\n\t\t\t/* must align unicode strings */\n\t\t\t*bcc_ptr = 0; /* null byte password */\n\t\t\tbcc_ptr++;\n\t\t}\n\t}\n\n\tif (ses->server->secMode &\n\t\t\t(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))\n\t\tsmb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tsmb_buffer->Flags2 |= SMBFLG2_UNICODE;\n\t\tlength =\n\t\t    cifs_strtoUCS((__le16 *) bcc_ptr, tree,\n\t\t\t6 /* max utf8 char length in bytes */ *\n\t\t\t(/* server len*/ + 256 /* share len */), nls_codepage);\n\t\tbcc_ptr += 2 * length;\t/* convert num 16 bit words to bytes */\n\t\tbcc_ptr += 2;\t/* skip trailing null */\n\t} else {\t\t/* ASCII */\n\t\tstrcpy(bcc_ptr, tree);\n\t\tbcc_ptr += strlen(tree) + 1;\n\t}\n\tstrcpy(bcc_ptr, \"?????\");\n\tbcc_ptr += strlen(\"?????\");\n\tbcc_ptr += 1;\n\tcount = bcc_ptr - &pSMB->Password[0];\n\tpSMB->hdr.smb_buf_length += count;\n\tpSMB->ByteCount = cpu_to_le16(count);\n\n\trc = SendReceive(xid, ses, smb_buffer, smb_buffer_response, &length,\n\t\t\t CIFS_STD_OP);\n\n\t/* above now done in SendReceive */\n\tif ((rc == 0) && (tcon != NULL)) {\n\t\tbool is_unicode;\n\n\t\ttcon->tidStatus = CifsGood;\n\t\ttcon->need_reconnect = false;\n\t\ttcon->tid = smb_buffer_response->Tid;\n\t\tbcc_ptr = pByteArea(smb_buffer_response);\n\t\tbytes_left = BCC(smb_buffer_response);\n\t\tlength = strnlen(bcc_ptr, bytes_left - 2);\n\t\tif (smb_buffer->Flags2 & SMBFLG2_UNICODE)\n\t\t\tis_unicode = true;\n\t\telse\n\t\t\tis_unicode = false;\n\n\n\t\t/* skip service field (NB: this field is always ASCII) */\n\t\tif (length == 3) {\n\t\t\tif ((bcc_ptr[0] == 'I') && (bcc_ptr[1] == 'P') &&\n\t\t\t    (bcc_ptr[2] == 'C')) {\n\t\t\t\tcFYI(1, \"IPC connection\");\n\t\t\t\ttcon->ipc = 1;\n\t\t\t}\n\t\t} else if (length == 2) {\n\t\t\tif ((bcc_ptr[0] == 'A') && (bcc_ptr[1] == ':')) {\n\t\t\t\t/* the most common case */\n\t\t\t\tcFYI(1, \"disk share connection\");\n\t\t\t}\n\t\t}\n\t\tbcc_ptr += length + 1;\n\t\tbytes_left -= (length + 1);\n\t\tstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\n\n\t\t/* mostly informational -- no need to fail on error here */\n\t\tkfree(tcon->nativeFileSystem);\n\t\ttcon->nativeFileSystem = cifs_strndup_from_ucs(bcc_ptr,\n\t\t\t\t\t\t      bytes_left, is_unicode,\n\t\t\t\t\t\t      nls_codepage);\n\n\t\tcFYI(1, \"nativeFileSystem=%s\", tcon->nativeFileSystem);\n\n\t\tif ((smb_buffer_response->WordCount == 3) ||\n\t\t\t (smb_buffer_response->WordCount == 7))\n\t\t\t/* field is in same location */\n\t\t\ttcon->Flags = le16_to_cpu(pSMBr->OptionalSupport);\n\t\telse\n\t\t\ttcon->Flags = 0;\n\t\tcFYI(1, \"Tcon flags: 0x%x \", tcon->Flags);\n\t} else if ((rc == 0) && tcon == NULL) {\n\t\t/* all we need to save for IPC$ connection */\n\t\tses->ipc_tid = smb_buffer_response->Tid;\n\t}\n\n\tcifs_buf_release(smb_buffer);\n\treturn rc;\n}\n\nint\ncifs_umount(struct super_block *sb, struct cifs_sb_info *cifs_sb)\n{\n\tint rc = 0;\n\tchar *tmp;\n\n\tif (cifs_sb->tcon)\n\t\tcifs_put_tcon(cifs_sb->tcon);\n\n\tcifs_sb->tcon = NULL;\n\ttmp = cifs_sb->prepath;\n\tcifs_sb->prepathlen = 0;\n\tcifs_sb->prepath = NULL;\n\tkfree(tmp);\n\n\treturn rc;\n}\n\nint cifs_negotiate_protocol(unsigned int xid, struct cifsSesInfo *ses)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\t/* only send once per connect */\n\tif (server->maxBuf != 0)\n\t\treturn 0;\n\n\trc = CIFSSMBNegotiate(xid, ses);\n\tif (rc == -EAGAIN) {\n\t\t/* retry only once on 1st time connection */\n\t\trc = CIFSSMBNegotiate(xid, ses);\n\t\tif (rc == -EAGAIN)\n\t\t\trc = -EHOSTDOWN;\n\t}\n\tif (rc == 0) {\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tif (server->tcpStatus != CifsExiting)\n\t\t\tserver->tcpStatus = CifsGood;\n\t\telse\n\t\t\trc = -EHOSTDOWN;\n\t\tspin_unlock(&GlobalMid_Lock);\n\n\t}\n\n\treturn rc;\n}\n\n\nint cifs_setup_session(unsigned int xid, struct cifsSesInfo *ses,\n\t\t\tstruct nls_table *nls_info)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\tses->flags = 0;\n\tses->capabilities = server->capabilities;\n\tif (linuxExtEnabled == 0)\n\t\tses->capabilities &= (~CAP_UNIX);\n\n\tcFYI(1, \"Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\",\n\t\t server->secMode, server->capabilities, server->timeAdj);\n\n\trc = CIFS_SessSetup(xid, ses, nls_info);\n\tif (rc) {\n\t\tcERROR(1, \"Send error in SessSetup = %d\", rc);\n\t} else {\n\t\tcFYI(1, \"CIFS Session Established successfully\");\n\t\tspin_lock(&GlobalMid_Lock);\n\t\tses->status = CifsGood;\n\t\tses->need_reconnect = false;\n\t\tspin_unlock(&GlobalMid_Lock);\n\t}\n\n\treturn rc;\n}\n\n"], "filenames": ["fs/cifs/cifsglob.h", "fs/cifs/connect.c"], "buggy_code_start_loc": [40, 1647], "buggy_code_end_loc": [41, 1700], "fixing_code_start_loc": [40, 1647], "fixing_code_end_loc": [41, 1710], "type": "CWE-264", "message": "The cifs_find_smb_ses function in fs/cifs/connect.c in the Linux kernel before 2.6.36 does not properly determine the associations between users and sessions, which allows local users to bypass CIFS share authentication by leveraging a mount of a share by a different user.", "other": {"cve": {"id": "CVE-2011-1585", "sourceIdentifier": "secalert@redhat.com", "published": "2013-06-08T13:05:55.053", "lastModified": "2023-02-13T00:17:09.467", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The cifs_find_smb_ses function in fs/cifs/connect.c in the Linux kernel before 2.6.36 does not properly determine the associations between users and sessions, which allows local users to bypass CIFS share authentication by leveraging a mount of a share by a different user."}, {"lang": "es", "value": "La funci\u00f3n cifs_find_smb_ses en fs/cifs/connect.c en el Linux kernel anterior a v2.6.36 no determina correctamente las asociaciones entre usuarios y sesiones, lo que permite a usuarios locales eludir la autenticaci\u00f3n CIFS mediante el aprovechamiento de un punto de montaje compartido por un usuario diferente."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.36", "matchCriteriaId": "C8DCE5E2-B055-4F05-8F0F-F19D1B7BA8D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:10:sp4:*:*:*:*:*:*", "matchCriteriaId": "EA2807B4-C30A-4C95-98E8-2AA9F5723684"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.36", "source": "secalert@redhat.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=4ff67b720c02c36e54d55b88c2931879b7db1cd2", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/04/15/8", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=697394", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4ff67b720c02c36e54d55b88c2931879b7db1cd2"}}