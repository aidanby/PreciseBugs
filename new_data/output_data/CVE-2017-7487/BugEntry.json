{"buggy_code": ["/*\n *\tImplements an IPX socket layer.\n *\n *\tThis code is derived from work by\n *\t\tRoss Biro\t: \tWriting the original IP stack\n *\t\tFred Van Kempen :\tTidying up the TCP/IP\n *\n *\tMany thanks go to Keith Baker, Institute For Industrial Information\n *\tTechnology Ltd, Swansea University for allowing me to work on this\n *\tin my own time even though it was in some ways related to commercial\n *\twork I am currently employed to do there.\n *\n *\tAll the material in this file is subject to the Gnu license version 2.\n *\tNeither Alan Cox nor the Swansea University Computer Society admit\n *\tliability nor provide warranty for any of this software. This material\n *\tis provided as is and at no charge.\n *\n *\tPortions Copyright (c) 2000-2003 Conectiva, Inc. <acme@conectiva.com.br>\n *\tNeither Arnaldo Carvalho de Melo nor Conectiva, Inc. admit liability nor\n *\tprovide warranty for any of this software. This material is provided\n *\t\"AS-IS\" and at no charge.\n *\n * \tPortions Copyright (c) 1995 Caldera, Inc. <greg@caldera.com>\n *\tNeither Greg Page nor Caldera, Inc. admit liability nor provide\n *\twarranty for any of this software. This material is provided\n *\t\"AS-IS\" and at no charge.\n *\n *\tSee net/ipx/ChangeLog.\n */\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/ipx.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/termios.h>\n\n#include <net/ipx.h>\n#include <net/p8022.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/datalink.h>\n#include <net/tcp_states.h>\n#include <net/net_namespace.h>\n\n#include <linux/uaccess.h>\n\n/* Configuration Variables */\nstatic unsigned char ipxcfg_max_hops = 16;\nstatic char ipxcfg_auto_select_primary;\nstatic char ipxcfg_auto_create_interfaces;\nint sysctl_ipx_pprop_broadcasting = 1;\n\n/* Global Variables */\nstatic struct datalink_proto *p8022_datalink;\nstatic struct datalink_proto *pEII_datalink;\nstatic struct datalink_proto *p8023_datalink;\nstatic struct datalink_proto *pSNAP_datalink;\n\nstatic const struct proto_ops ipx_dgram_ops;\n\nLIST_HEAD(ipx_interfaces);\nDEFINE_SPINLOCK(ipx_interfaces_lock);\n\nstruct ipx_interface *ipx_primary_net;\nstruct ipx_interface *ipx_internal_net;\n\nstruct ipx_interface *ipx_interfaces_head(void)\n{\n\tstruct ipx_interface *rc = NULL;\n\n\tif (!list_empty(&ipx_interfaces))\n\t\trc = list_entry(ipx_interfaces.next,\n\t\t\t\tstruct ipx_interface, node);\n\treturn rc;\n}\n\nstatic void ipxcfg_set_auto_select(char val)\n{\n\tipxcfg_auto_select_primary = val;\n\tif (val && !ipx_primary_net)\n\t\tipx_primary_net = ipx_interfaces_head();\n}\n\nstatic int ipxcfg_get_config_data(struct ipx_config_data __user *arg)\n{\n\tstruct ipx_config_data vals;\n\n\tvals.ipxcfg_auto_create_interfaces = ipxcfg_auto_create_interfaces;\n\tvals.ipxcfg_auto_select_primary\t   = ipxcfg_auto_select_primary;\n\n\treturn copy_to_user(arg, &vals, sizeof(vals)) ? -EFAULT : 0;\n}\n\n/*\n * Note: Sockets may not be removed _during_ an interrupt or inet_bh\n * handler using this technique. They can be added although we do not\n * use this facility.\n */\n\nstatic void ipx_remove_socket(struct sock *sk)\n{\n\t/* Determine interface with which socket is associated */\n\tstruct ipx_interface *intrfc = ipx_sk(sk)->intrfc;\n\n\tif (!intrfc)\n\t\tgoto out;\n\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\nout:\n\treturn;\n}\n\nstatic void ipx_destroy_socket(struct sock *sk)\n{\n\tipx_remove_socket(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tsk_refcnt_debug_dec(sk);\n}\n\n/*\n * The following code is used to support IPX Interfaces (IPXITF).  An\n * IPX interface is defined by a physical device and a frame type.\n */\n\n/* ipxitf_clear_primary_net has to be called with ipx_interfaces_lock held */\n\nstatic void ipxitf_clear_primary_net(void)\n{\n\tipx_primary_net = NULL;\n\tif (ipxcfg_auto_select_primary)\n\t\tipx_primary_net = ipx_interfaces_head();\n}\n\nstatic struct ipx_interface *__ipxitf_find_using_phys(struct net_device *dev,\n\t\t\t\t\t\t      __be16 datalink)\n{\n\tstruct ipx_interface *i;\n\n\tlist_for_each_entry(i, &ipx_interfaces, node)\n\t\tif (i->if_dev == dev && i->if_dlink_type == datalink)\n\t\t\tgoto out;\n\ti = NULL;\nout:\n\treturn i;\n}\n\nstatic struct ipx_interface *ipxitf_find_using_phys(struct net_device *dev,\n\t\t\t\t\t\t    __be16 datalink)\n{\n\tstruct ipx_interface *i;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\ti = __ipxitf_find_using_phys(dev, datalink);\n\tif (i)\n\t\tipxitf_hold(i);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn i;\n}\n\nstruct ipx_interface *ipxitf_find_using_net(__be32 net)\n{\n\tstruct ipx_interface *i;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tif (net) {\n\t\tlist_for_each_entry(i, &ipx_interfaces, node)\n\t\t\tif (i->if_netnum == net)\n\t\t\t\tgoto hold;\n\t\ti = NULL;\n\t\tgoto unlock;\n\t}\n\n\ti = ipx_primary_net;\n\tif (i)\nhold:\n\t\tipxitf_hold(i);\nunlock:\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn i;\n}\n\n/* Sockets are bound to a particular IPX interface. */\nstatic void ipxitf_insert_socket(struct ipx_interface *intrfc, struct sock *sk)\n{\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\tipx_sk(sk)->intrfc = intrfc;\n\tsk_add_node(sk, &intrfc->if_sklist);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\n}\n\n/* caller must hold intrfc->if_sklist_lock */\nstatic struct sock *__ipxitf_find_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t __be16 port)\n{\n\tstruct sock *s;\n\n\tsk_for_each(s, &intrfc->if_sklist)\n\t\tif (ipx_sk(s)->port == port)\n\t\t\tgoto found;\n\ts = NULL;\nfound:\n\treturn s;\n}\n\n/* caller must hold a reference to intrfc */\nstatic struct sock *ipxitf_find_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t__be16 port)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\ts = __ipxitf_find_socket(intrfc, port);\n\tif (s)\n\t\tsock_hold(s);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\n\treturn s;\n}\n\n#ifdef CONFIG_IPX_INTERN\nstatic struct sock *ipxitf_find_internal_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t\tunsigned char *ipx_node,\n\t\t\t\t\t\t__be16 port)\n{\n\tstruct sock *s;\n\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tsk_for_each(s, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\tif (ipxs->port == port &&\n\t\t    !memcmp(ipx_node, ipxs->node, IPX_NODE_LEN))\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\n\treturn s;\n}\n#endif\n\nstatic void __ipxitf_down(struct ipx_interface *intrfc)\n{\n\tstruct sock *s;\n\tstruct hlist_node *t;\n\n\t/* Delete all routes associated with this interface */\n\tipxrtr_del_routes(intrfc);\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\t/* error sockets */\n\tsk_for_each_safe(s, t, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\ts->sk_err = ENOLINK;\n\t\ts->sk_error_report(s);\n\t\tipxs->intrfc = NULL;\n\t\tipxs->port   = 0;\n\t\tsock_set_flag(s, SOCK_ZAPPED); /* Indicates it is no longer bound */\n\t\tsk_del_node_init(s);\n\t}\n\tINIT_HLIST_HEAD(&intrfc->if_sklist);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\n\t/* remove this interface from list */\n\tlist_del(&intrfc->node);\n\n\t/* remove this interface from *special* networks */\n\tif (intrfc == ipx_primary_net)\n\t\tipxitf_clear_primary_net();\n\tif (intrfc == ipx_internal_net)\n\t\tipx_internal_net = NULL;\n\n\tif (intrfc->if_dev)\n\t\tdev_put(intrfc->if_dev);\n\tkfree(intrfc);\n}\n\nvoid ipxitf_down(struct ipx_interface *intrfc)\n{\n\tspin_lock_bh(&ipx_interfaces_lock);\n\t__ipxitf_down(intrfc);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n}\n\nstatic void __ipxitf_put(struct ipx_interface *intrfc)\n{\n\tif (atomic_dec_and_test(&intrfc->refcnt))\n\t\t__ipxitf_down(intrfc);\n}\n\nstatic int ipxitf_device_event(struct notifier_block *notifier,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ipx_interface *i, *tmp;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN && event != NETDEV_UP)\n\t\tgoto out;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\n\t\tif (i->if_dev == dev) {\n\t\t\tif (event == NETDEV_UP)\n\t\t\t\tipxitf_hold(i);\n\t\t\telse\n\t\t\t\t__ipxitf_put(i);\n\t\t}\n\tspin_unlock_bh(&ipx_interfaces_lock);\nout:\n\treturn NOTIFY_DONE;\n}\n\n\nstatic __exit void ipxitf_cleanup(void)\n{\n\tstruct ipx_interface *i, *tmp;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\n\t\t__ipxitf_put(i);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n}\n\nstatic void ipxitf_def_skb_handler(struct sock *sock, struct sk_buff *skb)\n{\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tkfree_skb(skb);\n}\n\n/*\n * On input skb->sk is NULL. Nobody is charged for the memory.\n */\n\n/* caller must hold a reference to intrfc */\n\n#ifdef CONFIG_IPX_INTERN\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\n\t\t\t       struct sk_buff *skb, int copy)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint is_broadcast = !memcmp(ipx->ipx_dest.node, ipx_broadcast_node,\n\t\t\t\t   IPX_NODE_LEN);\n\tstruct sock *s;\n\tint rc;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tsk_for_each(s, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\tif (ipxs->port == ipx->ipx_dest.sock &&\n\t\t    (is_broadcast || !memcmp(ipx->ipx_dest.node,\n\t\t\t\t\t     ipxs->node, IPX_NODE_LEN))) {\n\t\t\t/* We found a socket to which to send */\n\t\t\tstruct sk_buff *skb1;\n\n\t\t\tif (copy) {\n\t\t\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tif (!skb1)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tskb1 = skb;\n\t\t\t\tcopy = 1; /* skb may only be used once */\n\t\t\t}\n\t\t\tipxitf_def_skb_handler(s, skb1);\n\n\t\t\t/* On an external interface, one socket can listen */\n\t\t\tif (intrfc != ipx_internal_net)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* skb was solely for us, and we did not make a copy, so free it. */\n\tif (!copy)\n\t\tkfree_skb(skb);\n\n\trc = 0;\nout:\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\treturn rc;\n}\n#else\nstatic struct sock *ncp_connection_hack(struct ipx_interface *intrfc,\n\t\t\t\t\tstruct ipxhdr *ipx)\n{\n\t/* The packet's target is a NCP connection handler. We want to hand it\n\t * to the correct socket directly within the kernel, so that the\n\t * mars_nwe packet distribution process does not have to do it. Here we\n\t * only care about NCP and BURST packets.\n\t *\n\t * You might call this a hack, but believe me, you do not want a\n\t * complete NCP layer in the kernel, and this is VERY fast as well. */\n\tstruct sock *sk = NULL;\n\tint connection = 0;\n\tu8 *ncphdr = (u8 *)(ipx + 1);\n\n\tif (*ncphdr == 0x22 && *(ncphdr + 1) == 0x22) /* NCP request */\n\t\tconnection = (((int) *(ncphdr + 5)) << 8) | (int) *(ncphdr + 3);\n\telse if (*ncphdr == 0x77 && *(ncphdr + 1) == 0x77) /* BURST packet */\n\t\tconnection = (((int) *(ncphdr + 9)) << 8) | (int) *(ncphdr + 8);\n\n\tif (connection) {\n\t\t/* Now we have to look for a special NCP connection handling\n\t\t * socket. Only these sockets have ipx_ncp_conn != 0, set by\n\t\t * SIOCIPXNCPCONN. */\n\t\tspin_lock_bh(&intrfc->if_sklist_lock);\n\t\tsk_for_each(sk, &intrfc->if_sklist)\n\t\t\tif (ipx_sk(sk)->ipx_ncp_conn == connection) {\n\t\t\t\tsock_hold(sk);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tsk = NULL;\n\tfound:\n\t\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\t}\n\treturn sk;\n}\n\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\n\t\t\t       struct sk_buff *skb, int copy)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tstruct sock *sock1 = NULL, *sock2 = NULL;\n\tstruct sk_buff *skb1 = NULL, *skb2 = NULL;\n\tint rc;\n\n\tif (intrfc == ipx_primary_net && ntohs(ipx->ipx_dest.sock) == 0x451)\n\t\tsock1 = ncp_connection_hack(intrfc, ipx);\n\tif (!sock1)\n\t\t/* No special socket found, forward the packet the normal way */\n\t\tsock1 = ipxitf_find_socket(intrfc, ipx->ipx_dest.sock);\n\n\t/*\n\t * We need to check if there is a primary net and if\n\t * this is addressed to one of the *SPECIAL* sockets because\n\t * these need to be propagated to the primary net.\n\t * The *SPECIAL* socket list contains: 0x452(SAP), 0x453(RIP) and\n\t * 0x456(Diagnostic).\n\t */\n\n\tif (ipx_primary_net && intrfc != ipx_primary_net) {\n\t\tconst int dsock = ntohs(ipx->ipx_dest.sock);\n\n\t\tif (dsock == 0x452 || dsock == 0x453 || dsock == 0x456)\n\t\t\t/* The appropriate thing to do here is to dup the\n\t\t\t * packet and route to the primary net interface via\n\t\t\t * ipxitf_send; however, we'll cheat and just demux it\n\t\t\t * here. */\n\t\t\tsock2 = ipxitf_find_socket(ipx_primary_net,\n\t\t\t\t\t\t\tipx->ipx_dest.sock);\n\t}\n\n\t/*\n\t * If there is nothing to do return. The kfree will cancel any charging.\n\t */\n\trc = 0;\n\tif (!sock1 && !sock2) {\n\t\tif (!copy)\n\t\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This next segment of code is a little awkward, but it sets it up\n\t * so that the appropriate number of copies of the SKB are made and\n\t * that skb1 and skb2 point to it (them) so that it (they) can be\n\t * demuxed to sock1 and/or sock2.  If we are unable to make enough\n\t * copies, we do as much as is possible.\n\t */\n\n\tif (copy)\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\telse\n\t\tskb1 = skb;\n\n\trc = -ENOMEM;\n\tif (!skb1)\n\t\tgoto out_put;\n\n\t/* Do we need 2 SKBs? */\n\tif (sock1 && sock2)\n\t\tskb2 = skb_clone(skb1, GFP_ATOMIC);\n\telse\n\t\tskb2 = skb1;\n\n\tif (sock1)\n\t\tipxitf_def_skb_handler(sock1, skb1);\n\n\tif (!skb2)\n\t\tgoto out_put;\n\n\tif (sock2)\n\t\tipxitf_def_skb_handler(sock2, skb2);\n\n\trc = 0;\nout_put:\n\tif (sock1)\n\t\tsock_put(sock1);\n\tif (sock2)\n\t\tsock_put(sock2);\nout:\n\treturn rc;\n}\n#endif\t/* CONFIG_IPX_INTERN */\n\nstatic struct sk_buff *ipxitf_adjust_skbuff(struct ipx_interface *intrfc,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tint in_offset = (unsigned char *)ipx_hdr(skb) - skb->head;\n\tint out_offset = intrfc->if_ipx_offset;\n\tint len;\n\n\t/* Hopefully, most cases */\n\tif (in_offset >= out_offset)\n\t\treturn skb;\n\n\t/* Need new SKB */\n\tlen  = skb->len + out_offset;\n\tskb2 = alloc_skb(len, GFP_ATOMIC);\n\tif (skb2) {\n\t\tskb_reserve(skb2, out_offset);\n\t\tskb_reset_network_header(skb2);\n\t\tskb_reset_transport_header(skb2);\n\t\tskb_put(skb2, skb->len);\n\t\tmemcpy(ipx_hdr(skb2), ipx_hdr(skb), skb->len);\n\t\tmemcpy(skb2->cb, skb->cb, sizeof(skb->cb));\n\t}\n\tkfree_skb(skb);\n\treturn skb2;\n}\n\n/* caller must hold a reference to intrfc and the skb has to be unshared */\nint ipxitf_send(struct ipx_interface *intrfc, struct sk_buff *skb, char *node)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tstruct net_device *dev = intrfc->if_dev;\n\tstruct datalink_proto *dl = intrfc->if_dlink;\n\tchar dest_node[IPX_NODE_LEN];\n\tint send_to_wire = 1;\n\tint addr_len;\n\n\tipx->ipx_tctrl = IPX_SKB_CB(skb)->ipx_tctrl;\n\tipx->ipx_dest.net = IPX_SKB_CB(skb)->ipx_dest_net;\n\tipx->ipx_source.net = IPX_SKB_CB(skb)->ipx_source_net;\n\n\t/* see if we need to include the netnum in the route list */\n\tif (IPX_SKB_CB(skb)->last_hop.index >= 0) {\n\t\t__be32 *last_hop = (__be32 *)(((u8 *) skb->data) +\n\t\t\t\tsizeof(struct ipxhdr) +\n\t\t\t\tIPX_SKB_CB(skb)->last_hop.index *\n\t\t\t\tsizeof(__be32));\n\t\t*last_hop = IPX_SKB_CB(skb)->last_hop.netnum;\n\t\tIPX_SKB_CB(skb)->last_hop.index = -1;\n\t}\n\n\t/*\n\t * We need to know how many skbuffs it will take to send out this\n\t * packet to avoid unnecessary copies.\n\t */\n\n\tif (!dl || !dev || dev->flags & IFF_LOOPBACK)\n\t\tsend_to_wire = 0;\t/* No non looped */\n\n\t/*\n\t * See if this should be demuxed to sockets on this interface\n\t *\n\t * We want to ensure the original was eaten or that we only use\n\t * up clones.\n\t */\n\n\tif (ipx->ipx_dest.net == intrfc->if_netnum) {\n\t\t/*\n\t\t * To our own node, loop and free the original.\n\t\t * The internal net will receive on all node address.\n\t\t */\n\t\tif (intrfc == ipx_internal_net ||\n\t\t    !memcmp(intrfc->if_node, node, IPX_NODE_LEN)) {\n\t\t\t/* Don't charge sender */\n\t\t\tskb_orphan(skb);\n\n\t\t\t/* Will charge receiver */\n\t\t\treturn ipxitf_demux_socket(intrfc, skb, 0);\n\t\t}\n\n\t\t/* Broadcast, loop and possibly keep to send on. */\n\t\tif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN)) {\n\t\t\tif (!send_to_wire)\n\t\t\t\tskb_orphan(skb);\n\t\t\tipxitf_demux_socket(intrfc, skb, send_to_wire);\n\t\t\tif (!send_to_wire)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the originating net is not equal to our net; this is routed\n\t * We are still charging the sender. Which is right - the driver\n\t * free will handle this fairly.\n\t */\n\tif (ipx->ipx_source.net != intrfc->if_netnum) {\n\t\t/*\n\t\t * Unshare the buffer before modifying the count in\n\t\t * case it's a flood or tcpdump\n\t\t */\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tif (++ipx->ipx_tctrl > ipxcfg_max_hops)\n\t\t\tsend_to_wire = 0;\n\t}\n\n\tif (!send_to_wire) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/* Determine the appropriate hardware address */\n\taddr_len = dev->addr_len;\n\tif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN))\n\t\tmemcpy(dest_node, dev->broadcast, addr_len);\n\telse\n\t\tmemcpy(dest_node, &(node[IPX_NODE_LEN-addr_len]), addr_len);\n\n\t/* Make any compensation for differing physical/data link size */\n\tskb = ipxitf_adjust_skbuff(intrfc, skb);\n\tif (!skb)\n\t\tgoto out;\n\n\t/* set up data link and physical headers */\n\tskb->dev\t= dev;\n\tskb->protocol\t= htons(ETH_P_IPX);\n\n\t/* Send it out */\n\tdl->request(dl, skb, dest_node);\nout:\n\treturn 0;\n}\n\nstatic int ipxitf_add_local_route(struct ipx_interface *intrfc)\n{\n\treturn ipxrtr_add_route(intrfc->if_netnum, intrfc, NULL);\n}\n\nstatic void ipxitf_discover_netnum(struct ipx_interface *intrfc,\n\t\t\t\t   struct sk_buff *skb);\nstatic int ipxitf_pprop(struct ipx_interface *intrfc, struct sk_buff *skb);\n\nstatic int ipxitf_rcv(struct ipx_interface *intrfc, struct sk_buff *skb)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint rc = 0;\n\n\tipxitf_hold(intrfc);\n\n\t/* See if we should update our network number */\n\tif (!intrfc->if_netnum) /* net number of intrfc not known yet */\n\t\tipxitf_discover_netnum(intrfc, skb);\n\n\tIPX_SKB_CB(skb)->last_hop.index = -1;\n\tif (ipx->ipx_type == IPX_TYPE_PPROP) {\n\t\trc = ipxitf_pprop(intrfc, skb);\n\t\tif (rc)\n\t\t\tgoto out_free_skb;\n\t}\n\n\t/* local processing follows */\n\tif (!IPX_SKB_CB(skb)->ipx_dest_net)\n\t\tIPX_SKB_CB(skb)->ipx_dest_net = intrfc->if_netnum;\n\tif (!IPX_SKB_CB(skb)->ipx_source_net)\n\t\tIPX_SKB_CB(skb)->ipx_source_net = intrfc->if_netnum;\n\n\t/* it doesn't make sense to route a pprop packet, there's no meaning\n\t * in the ipx_dest_net for such packets */\n\tif (ipx->ipx_type != IPX_TYPE_PPROP &&\n\t    intrfc->if_netnum != IPX_SKB_CB(skb)->ipx_dest_net) {\n\t\t/* We only route point-to-point packets. */\n\t\tif (skb->pkt_type == PACKET_HOST) {\n\t\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\t\tif (skb)\n\t\t\t\trc = ipxrtr_route_skb(skb);\n\t\t\tgoto out_intrfc;\n\t\t}\n\n\t\tgoto out_free_skb;\n\t}\n\n\t/* see if we should keep it */\n\tif (!memcmp(ipx_broadcast_node, ipx->ipx_dest.node, IPX_NODE_LEN) ||\n\t    !memcmp(intrfc->if_node, ipx->ipx_dest.node, IPX_NODE_LEN)) {\n\t\trc = ipxitf_demux_socket(intrfc, skb, 0);\n\t\tgoto out_intrfc;\n\t}\n\n\t/* we couldn't pawn it off so unload it */\nout_free_skb:\n\tkfree_skb(skb);\nout_intrfc:\n\tipxitf_put(intrfc);\n\treturn rc;\n}\n\nstatic void ipxitf_discover_netnum(struct ipx_interface *intrfc,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tconst struct ipx_cb *cb = IPX_SKB_CB(skb);\n\n\t/* see if this is an intra packet: source_net == dest_net */\n\tif (cb->ipx_source_net == cb->ipx_dest_net && cb->ipx_source_net) {\n\t\tstruct ipx_interface *i =\n\t\t\t\tipxitf_find_using_net(cb->ipx_source_net);\n\t\t/* NB: NetWare servers lie about their hop count so we\n\t\t * dropped the test based on it. This is the best way\n\t\t * to determine this is a 0 hop count packet. */\n\t\tif (!i) {\n\t\t\tintrfc->if_netnum = cb->ipx_source_net;\n\t\t\tipxitf_add_local_route(intrfc);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"IPX: Network number collision \"\n\t\t\t\t\"%lx\\n        %s %s and %s %s\\n\",\n\t\t\t\t(unsigned long) ntohl(cb->ipx_source_net),\n\t\t\t\tipx_device_name(i),\n\t\t\t\tipx_frame_name(i->if_dlink_type),\n\t\t\t\tipx_device_name(intrfc),\n\t\t\t\tipx_frame_name(intrfc->if_dlink_type));\n\t\t\tipxitf_put(i);\n\t\t}\n\t}\n}\n\n/**\n * ipxitf_pprop - Process packet propagation IPX packet type 0x14, used for\n * \t\t  NetBIOS broadcasts\n * @intrfc: IPX interface receiving this packet\n * @skb: Received packet\n *\n * Checks if packet is valid: if its more than %IPX_MAX_PPROP_HOPS hops or if it\n * is smaller than a IPX header + the room for %IPX_MAX_PPROP_HOPS hops we drop\n * it, not even processing it locally, if it has exact %IPX_MAX_PPROP_HOPS we\n * don't broadcast it, but process it locally. See chapter 5 of Novell's \"IPX\n * RIP and SAP Router Specification\", Part Number 107-000029-001.\n *\n * If it is valid, check if we have pprop broadcasting enabled by the user,\n * if not, just return zero for local processing.\n *\n * If it is enabled check the packet and don't broadcast it if we have already\n * seen this packet.\n *\n * Broadcast: send it to the interfaces that aren't on the packet visited nets\n * array, just after the IPX header.\n *\n * Returns -EINVAL for invalid packets, so that the calling function drops\n * the packet without local processing. 0 if packet is to be locally processed.\n */\nstatic int ipxitf_pprop(struct ipx_interface *intrfc, struct sk_buff *skb)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint i, rc = -EINVAL;\n\tstruct ipx_interface *ifcs;\n\tchar *c;\n\t__be32 *l;\n\n\t/* Illegal packet - too many hops or too short */\n\t/* We decide to throw it away: no broadcasting, no local processing.\n\t * NetBIOS unaware implementations route them as normal packets -\n\t * tctrl <= 15, any data payload... */\n\tif (IPX_SKB_CB(skb)->ipx_tctrl > IPX_MAX_PPROP_HOPS ||\n\t    ntohs(ipx->ipx_pktsize) < sizeof(struct ipxhdr) +\n\t\t\t\t\tIPX_MAX_PPROP_HOPS * sizeof(u32))\n\t\tgoto out;\n\t/* are we broadcasting this damn thing? */\n\trc = 0;\n\tif (!sysctl_ipx_pprop_broadcasting)\n\t\tgoto out;\n\t/* We do broadcast packet on the IPX_MAX_PPROP_HOPS hop, but we\n\t * process it locally. All previous hops broadcasted it, and process it\n\t * locally. */\n\tif (IPX_SKB_CB(skb)->ipx_tctrl == IPX_MAX_PPROP_HOPS)\n\t\tgoto out;\n\n\tc = ((u8 *) ipx) + sizeof(struct ipxhdr);\n\tl = (__be32 *) c;\n\n\t/* Don't broadcast packet if already seen this net */\n\tfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\n\t\tif (*l++ == intrfc->if_netnum)\n\t\t\tgoto out;\n\n\t/* < IPX_MAX_PPROP_HOPS hops && input interface not in list. Save the\n\t * position where we will insert recvd netnum into list, later on,\n\t * in ipxitf_send */\n\tIPX_SKB_CB(skb)->last_hop.index = i;\n\tIPX_SKB_CB(skb)->last_hop.netnum = intrfc->if_netnum;\n\t/* xmit on all other interfaces... */\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry(ifcs, &ipx_interfaces, node) {\n\t\t/* Except unconfigured interfaces */\n\t\tif (!ifcs->if_netnum)\n\t\t\tcontinue;\n\n\t\t/* That aren't in the list */\n\t\tif (ifcs == intrfc)\n\t\t\tcontinue;\n\t\tl = (__be32 *) c;\n\t\t/* don't consider the last entry in the packet list,\n\t\t * it is our netnum, and it is not there yet */\n\t\tfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\n\t\t\tif (ifcs->if_netnum == *l++)\n\t\t\t\tbreak;\n\t\tif (i == IPX_SKB_CB(skb)->ipx_tctrl) {\n\t\t\tstruct sk_buff *s = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\tif (s) {\n\t\t\t\tIPX_SKB_CB(s)->ipx_dest_net = ifcs->if_netnum;\n\t\t\t\tipxrtr_route_skb(s);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&ipx_interfaces_lock);\nout:\n\treturn rc;\n}\n\nstatic void ipxitf_insert(struct ipx_interface *intrfc)\n{\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_add_tail(&intrfc->node, &ipx_interfaces);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\n\tif (ipxcfg_auto_select_primary && !ipx_primary_net)\n\t\tipx_primary_net = intrfc;\n}\n\nstatic struct ipx_interface *ipxitf_alloc(struct net_device *dev, __be32 netnum,\n\t\t\t\t\t  __be16 dlink_type,\n\t\t\t\t\t  struct datalink_proto *dlink,\n\t\t\t\t\t  unsigned char internal,\n\t\t\t\t\t  int ipx_offset)\n{\n\tstruct ipx_interface *intrfc = kmalloc(sizeof(*intrfc), GFP_ATOMIC);\n\n\tif (intrfc) {\n\t\tintrfc->if_dev\t\t= dev;\n\t\tintrfc->if_netnum\t= netnum;\n\t\tintrfc->if_dlink_type \t= dlink_type;\n\t\tintrfc->if_dlink \t= dlink;\n\t\tintrfc->if_internal \t= internal;\n\t\tintrfc->if_ipx_offset \t= ipx_offset;\n\t\tintrfc->if_sknum \t= IPX_MIN_EPHEMERAL_SOCKET;\n\t\tINIT_HLIST_HEAD(&intrfc->if_sklist);\n\t\tatomic_set(&intrfc->refcnt, 1);\n\t\tspin_lock_init(&intrfc->if_sklist_lock);\n\t}\n\n\treturn intrfc;\n}\n\nstatic int ipxitf_create_internal(struct ipx_interface_definition *idef)\n{\n\tstruct ipx_interface *intrfc;\n\tint rc = -EEXIST;\n\n\t/* Only one primary network allowed */\n\tif (ipx_primary_net)\n\t\tgoto out;\n\n\t/* Must have a valid network number */\n\trc = -EADDRNOTAVAIL;\n\tif (!idef->ipx_network)\n\t\tgoto out;\n\tintrfc = ipxitf_find_using_net(idef->ipx_network);\n\trc = -EADDRINUSE;\n\tif (intrfc) {\n\t\tipxitf_put(intrfc);\n\t\tgoto out;\n\t}\n\tintrfc = ipxitf_alloc(NULL, idef->ipx_network, 0, NULL, 1, 0);\n\trc = -EAGAIN;\n\tif (!intrfc)\n\t\tgoto out;\n\tmemcpy((char *)&(intrfc->if_node), idef->ipx_node, IPX_NODE_LEN);\n\tipx_internal_net = ipx_primary_net = intrfc;\n\tipxitf_hold(intrfc);\n\tipxitf_insert(intrfc);\n\n\trc = ipxitf_add_local_route(intrfc);\n\tipxitf_put(intrfc);\nout:\n\treturn rc;\n}\n\nstatic __be16 ipx_map_frame_type(unsigned char type)\n{\n\t__be16 rc = 0;\n\n\tswitch (type) {\n\tcase IPX_FRAME_ETHERII:\trc = htons(ETH_P_IPX);\t\tbreak;\n\tcase IPX_FRAME_8022:\trc = htons(ETH_P_802_2);\tbreak;\n\tcase IPX_FRAME_SNAP:\trc = htons(ETH_P_SNAP);\t\tbreak;\n\tcase IPX_FRAME_8023:\trc = htons(ETH_P_802_3);\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ipxitf_create(struct ipx_interface_definition *idef)\n{\n\tstruct net_device *dev;\n\t__be16 dlink_type = 0;\n\tstruct datalink_proto *datalink = NULL;\n\tstruct ipx_interface *intrfc;\n\tint rc;\n\n\tif (idef->ipx_special == IPX_INTERNAL) {\n\t\trc = ipxitf_create_internal(idef);\n\t\tgoto out;\n\t}\n\n\trc = -EEXIST;\n\tif (idef->ipx_special == IPX_PRIMARY && ipx_primary_net)\n\t\tgoto out;\n\n\tintrfc = ipxitf_find_using_net(idef->ipx_network);\n\trc = -EADDRINUSE;\n\tif (idef->ipx_network && intrfc) {\n\t\tipxitf_put(intrfc);\n\t\tgoto out;\n\t}\n\n\tif (intrfc)\n\t\tipxitf_put(intrfc);\n\n\tdev = dev_get_by_name(&init_net, idef->ipx_device);\n\trc = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tswitch (idef->ipx_dlink_type) {\n\tcase IPX_FRAME_8022:\n\t\tdlink_type \t= htons(ETH_P_802_2);\n\t\tdatalink \t= p8022_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_ETHERII:\n\t\tif (dev->type != ARPHRD_IEEE802) {\n\t\t\tdlink_type \t= htons(ETH_P_IPX);\n\t\t\tdatalink \t= pEII_datalink;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase IPX_FRAME_SNAP:\n\t\tdlink_type \t= htons(ETH_P_SNAP);\n\t\tdatalink \t= pSNAP_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_8023:\n\t\tdlink_type \t= htons(ETH_P_802_3);\n\t\tdatalink \t= p8023_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_NONE:\n\tdefault:\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto out_dev;\n\t}\n\n\trc = -ENETDOWN;\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out_dev;\n\n\t/* Check addresses are suitable */\n\trc = -EINVAL;\n\tif (dev->addr_len > IPX_NODE_LEN)\n\t\tgoto out_dev;\n\n\tintrfc = ipxitf_find_using_phys(dev, dlink_type);\n\tif (!intrfc) {\n\t\t/* Ok now create */\n\t\tintrfc = ipxitf_alloc(dev, idef->ipx_network, dlink_type,\n\t\t\t\t      datalink, 0, dev->hard_header_len +\n\t\t\t\t\tdatalink->header_length);\n\t\trc = -EAGAIN;\n\t\tif (!intrfc)\n\t\t\tgoto out_dev;\n\t\t/* Setup primary if necessary */\n\t\tif (idef->ipx_special == IPX_PRIMARY)\n\t\t\tipx_primary_net = intrfc;\n\t\tif (!memcmp(idef->ipx_node, \"\\000\\000\\000\\000\\000\\000\",\n\t\t\t    IPX_NODE_LEN)) {\n\t\t\tmemset(intrfc->if_node, 0, IPX_NODE_LEN);\n\t\t\tmemcpy(intrfc->if_node + IPX_NODE_LEN - dev->addr_len,\n\t\t\t\tdev->dev_addr, dev->addr_len);\n\t\t} else\n\t\t\tmemcpy(intrfc->if_node, idef->ipx_node, IPX_NODE_LEN);\n\t\tipxitf_hold(intrfc);\n\t\tipxitf_insert(intrfc);\n\t}\n\n\n\t/* If the network number is known, add a route */\n\trc = 0;\n\tif (!intrfc->if_netnum)\n\t\tgoto out_intrfc;\n\n\trc = ipxitf_add_local_route(intrfc);\nout_intrfc:\n\tipxitf_put(intrfc);\n\tgoto out;\nout_dev:\n\tdev_put(dev);\nout:\n\treturn rc;\n}\n\nstatic int ipxitf_delete(struct ipx_interface_definition *idef)\n{\n\tstruct net_device *dev = NULL;\n\t__be16 dlink_type = 0;\n\tstruct ipx_interface *intrfc;\n\tint rc = 0;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tif (idef->ipx_special == IPX_INTERNAL) {\n\t\tif (ipx_internal_net) {\n\t\t\t__ipxitf_put(ipx_internal_net);\n\t\t\tgoto out;\n\t\t}\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdlink_type = ipx_map_frame_type(idef->ipx_dlink_type);\n\trc = -EPROTONOSUPPORT;\n\tif (!dlink_type)\n\t\tgoto out;\n\n\tdev = __dev_get_by_name(&init_net, idef->ipx_device);\n\trc = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tintrfc = __ipxitf_find_using_phys(dev, dlink_type);\n\trc = -EINVAL;\n\tif (!intrfc)\n\t\tgoto out;\n\t__ipxitf_put(intrfc);\n\n\trc = 0;\nout:\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn rc;\n}\n\nstatic struct ipx_interface *ipxitf_auto_create(struct net_device *dev,\n\t\t\t\t\t\t__be16 dlink_type)\n{\n\tstruct ipx_interface *intrfc = NULL;\n\tstruct datalink_proto *datalink;\n\n\tif (!dev)\n\t\tgoto out;\n\n\t/* Check addresses are suitable */\n\tif (dev->addr_len > IPX_NODE_LEN)\n\t\tgoto out;\n\n\tswitch (ntohs(dlink_type)) {\n\tcase ETH_P_IPX:\t\tdatalink = pEII_datalink;\tbreak;\n\tcase ETH_P_802_2:\tdatalink = p8022_datalink;\tbreak;\n\tcase ETH_P_SNAP:\tdatalink = pSNAP_datalink;\tbreak;\n\tcase ETH_P_802_3:\tdatalink = p8023_datalink;\tbreak;\n\tdefault:\t\tgoto out;\n\t}\n\n\tintrfc = ipxitf_alloc(dev, 0, dlink_type, datalink, 0,\n\t\t\t\tdev->hard_header_len + datalink->header_length);\n\n\tif (intrfc) {\n\t\tmemset(intrfc->if_node, 0, IPX_NODE_LEN);\n\t\tmemcpy((char *)&(intrfc->if_node[IPX_NODE_LEN-dev->addr_len]),\n\t\t\tdev->dev_addr, dev->addr_len);\n\t\tspin_lock_init(&intrfc->if_sklist_lock);\n\t\tatomic_set(&intrfc->refcnt, 1);\n\t\tipxitf_insert(intrfc);\n\t\tdev_hold(dev);\n\t}\n\nout:\n\treturn intrfc;\n}\n\nstatic int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = -EFAULT;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\tbreak;\n\t\tipxitf_put(ipxif);\n\t\trc = 0;\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/*\n *\tChecksum routine for IPX\n */\n\n/* Note: We assume ipx_tctrl==0 and htons(length)==ipx_pktsize */\n/* This functions should *not* mess with packet contents */\n\n__be16 ipx_cksum(struct ipxhdr *packet, int length)\n{\n\t/*\n\t *\tNOTE: sum is a net byte order quantity, which optimizes the\n\t *\tloop. This only works on big and little endian machines. (I\n\t *\tdon't know of a machine that isn't.)\n\t */\n\t/* handle the first 3 words separately; checksum should be skipped\n\t * and ipx_tctrl masked out */\n\t__u16 *p = (__u16 *)packet;\n\t__u32 sum = p[1] + (p[2] & (__force u16)htons(0x00ff));\n\t__u32 i = (length >> 1) - 3; /* Number of remaining complete words */\n\n\t/* Loop through them */\n\tp += 3;\n\twhile (i--)\n\t\tsum += *p++;\n\n\t/* Add on the last part word if it exists */\n\tif (packet->ipx_pktsize & htons(1))\n\t\tsum += (__force u16)htons(0xff00) & *p;\n\n\t/* Do final fixup */\n\tsum = (sum & 0xffff) + (sum >> 16);\n\n\t/* It's a pity there's no concept of carry in C */\n\tif (sum >= 0x10000)\n\t\tsum++;\n\n\t/*\n\t * Leave 0 alone; we don't want 0xffff here.  Note that we can't get\n\t * here with 0x10000, so this check is the same as ((__u16)sum)\n\t */\n\tif (sum)\n\t\tsum = ~sum;\n\n\treturn (__force __be16)sum;\n}\n\nconst char *ipx_frame_name(__be16 frame)\n{\n\tchar* rc = \"None\";\n\n\tswitch (ntohs(frame)) {\n\tcase ETH_P_IPX:\t\trc = \"EtherII\";\tbreak;\n\tcase ETH_P_802_2:\trc = \"802.2\";\tbreak;\n\tcase ETH_P_SNAP:\trc = \"SNAP\";\tbreak;\n\tcase ETH_P_802_3:\trc = \"802.3\";\tbreak;\n\t}\n\n\treturn rc;\n}\n\nconst char *ipx_device_name(struct ipx_interface *intrfc)\n{\n\treturn intrfc->if_internal ? \"Internal\" :\n\t\tintrfc->if_dev ? intrfc->if_dev->name : \"Unknown\";\n}\n\n/* Handling for system calls applied via the various interfaces to an IPX\n * socket object. */\n\nstatic int ipx_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint opt;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (optlen != sizeof(int))\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (get_user(opt, (unsigned int __user *)optval))\n\t\tgoto out;\n\n\trc = -ENOPROTOOPT;\n\tif (!(level == SOL_IPX && optname == IPX_TYPE))\n\t\tgoto out;\n\n\tipx_sk(sk)->type = opt;\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int ipx_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val = 0;\n\tint len;\n\tint rc = -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\tif (!(level == SOL_IPX && optname == IPX_TYPE))\n\t\tgoto out;\n\n\tval = ipx_sk(sk)->type;\n\n\trc = -EFAULT;\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\trc = -EINVAL;\n\tif(len < 0)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\tgoto out;\n\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic struct proto ipx_proto = {\n\t.name\t  = \"IPX\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct ipx_sock),\n};\n\nstatic int ipx_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tint rc = -ESOCKTNOSUPPORT;\n\tstruct sock *sk;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * SPX support is not anymore in the kernel sources. If you want to\n\t * ressurrect it, completing it and making it understand shared skbs,\n\t * be fully multithreaded, etc, grab the sources in an early 2.5 kernel\n\t * tree.\n\t */\n\tif (sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IPX, GFP_KERNEL, &ipx_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsk_refcnt_debug_inc(sk);\n\tsock_init_data(sock, sk);\n\tsk->sk_no_check_tx = 1;\t\t/* Checksum off by default */\n\tsock->ops = &ipx_dgram_ops;\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int ipx_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\tgoto out;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock->sk = NULL;\n\tsk_refcnt_debug_release(sk);\n\tipx_destroy_socket(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\nout:\n\treturn 0;\n}\n\n/* caller must hold a reference to intrfc */\n\nstatic __be16 ipx_first_free_socketnum(struct ipx_interface *intrfc)\n{\n\tunsigned short socketNum = intrfc->if_sknum;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tif (socketNum < IPX_MIN_EPHEMERAL_SOCKET)\n\t\tsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\n\n\twhile (__ipxitf_find_socket(intrfc, htons(socketNum)))\n\t\tif (socketNum > IPX_MAX_EPHEMERAL_SOCKET)\n\t\t\tsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\n\t\telse\n\t\t\tsocketNum++;\n\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tintrfc->if_sknum = socketNum;\n\n\treturn htons(socketNum);\n}\n\nstatic int __ipx_bind(struct socket *sock,\n\t\t\tstruct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct ipx_interface *intrfc;\n\tstruct sockaddr_ipx *addr = (struct sockaddr_ipx *)uaddr;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED) || addr_len != sizeof(struct sockaddr_ipx))\n\t\tgoto out;\n\n\tintrfc = ipxitf_find_using_net(addr->sipx_network);\n\trc = -EADDRNOTAVAIL;\n\tif (!intrfc)\n\t\tgoto out;\n\n\tif (!addr->sipx_port) {\n\t\taddr->sipx_port = ipx_first_free_socketnum(intrfc);\n\t\trc = -EINVAL;\n\t\tif (!addr->sipx_port)\n\t\t\tgoto out_put;\n\t}\n\n\t/* protect IPX system stuff like routing/sap */\n\trc = -EACCES;\n\tif (ntohs(addr->sipx_port) < IPX_MIN_EPHEMERAL_SOCKET &&\n\t    !capable(CAP_NET_ADMIN))\n\t\tgoto out_put;\n\n\tipxs->port = addr->sipx_port;\n\n#ifdef CONFIG_IPX_INTERN\n\tif (intrfc == ipx_internal_net) {\n\t\t/* The source address is to be set explicitly if the\n\t\t * socket is to be bound on the internal network. If a\n\t\t * node number 0 was specified, the default is used.\n\t\t */\n\n\t\trc = -EINVAL;\n\t\tif (!memcmp(addr->sipx_node, ipx_broadcast_node, IPX_NODE_LEN))\n\t\t\tgoto out_put;\n\t\tif (!memcmp(addr->sipx_node, ipx_this_node, IPX_NODE_LEN))\n\t\t\tmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\n\t\telse\n\t\t\tmemcpy(ipxs->node, addr->sipx_node, IPX_NODE_LEN);\n\n\t\trc = -EADDRINUSE;\n\t\tif (ipxitf_find_internal_socket(intrfc, ipxs->node,\n\t\t\t\t\t\tipxs->port)) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs(addr->sipx_port));\n\t\t\tgoto out_put;\n\t\t}\n\t} else {\n\t\t/* Source addresses are easy. It must be our\n\t\t * network:node pair for an interface routed to IPX\n\t\t * with the ipx routing ioctl()\n\t\t */\n\n\t\tmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\n\n\t\trc = -EADDRINUSE;\n\t\tif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs(addr->sipx_port));\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n#else\t/* !def CONFIG_IPX_INTERN */\n\n\t/* Source addresses are easy. It must be our network:node pair for\n\t   an interface routed to IPX with the ipx routing ioctl() */\n\n\trc = -EADDRINUSE;\n\tif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\n\t\tSOCK_DEBUG(sk, \"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs((int)addr->sipx_port));\n\t\tgoto out_put;\n\t}\n\n#endif\t/* CONFIG_IPX_INTERN */\n\n\tipxitf_insert_socket(intrfc, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\trc = 0;\nout_put:\n\tipxitf_put(intrfc);\nout:\n\treturn rc;\n}\n\nstatic int ipx_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc;\n\n\tlock_sock(sk);\n\trc = __ipx_bind(sock, uaddr, addr_len);\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int ipx_connect(struct socket *sock, struct sockaddr *uaddr,\n\tint addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *addr;\n\tint rc = -EINVAL;\n\tstruct ipx_route *rt;\n\n\tsk->sk_state\t= TCP_CLOSE;\n\tsock->state \t= SS_UNCONNECTED;\n\n\tlock_sock(sk);\n\tif (addr_len != sizeof(*addr))\n\t\tgoto out;\n\taddr = (struct sockaddr_ipx *)uaddr;\n\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\n\t\t\tIPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t/* We can either connect to primary network or somewhere\n\t * we can route to */\n\trt = ipxrtr_lookup(addr->sipx_network);\n\trc = -ENETUNREACH;\n\tif (!rt && !(!addr->sipx_network && ipx_primary_net))\n\t\tgoto out;\n\n\tipxs->dest_addr.net  = addr->sipx_network;\n\tipxs->dest_addr.sock = addr->sipx_port;\n\tmemcpy(ipxs->dest_addr.node, addr->sipx_node, IPX_NODE_LEN);\n\tipxs->type = addr->sipx_type;\n\n\tif (sock->type == SOCK_DGRAM) {\n\t\tsock->state \t= SS_CONNECTED;\n\t\tsk->sk_state \t= TCP_ESTABLISHED;\n\t}\n\n\tif (rt)\n\t\tipxrtr_put(rt);\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct ipx_address *addr;\n\tstruct sockaddr_ipx sipx;\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tint rc;\n\n\t*uaddr_len = sizeof(struct sockaddr_ipx);\n\n\tlock_sock(sk);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\taddr = &ipxs->dest_addr;\n\t\tsipx.sipx_network\t= addr->net;\n\t\tsipx.sipx_port\t\t= addr->sock;\n\t\tmemcpy(sipx.sipx_node, addr->node, IPX_NODE_LEN);\n\t} else {\n\t\tif (ipxs->intrfc) {\n\t\t\tsipx.sipx_network = ipxs->intrfc->if_netnum;\n#ifdef CONFIG_IPX_INTERN\n\t\t\tmemcpy(sipx.sipx_node, ipxs->node, IPX_NODE_LEN);\n#else\n\t\t\tmemcpy(sipx.sipx_node, ipxs->intrfc->if_node,\n\t\t\t\tIPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\t} else {\n\t\t\tsipx.sipx_network = 0;\n\t\t\tmemset(sipx.sipx_node, '\\0', IPX_NODE_LEN);\n\t\t}\n\n\t\tsipx.sipx_port = ipxs->port;\n\t}\n\n\tsipx.sipx_family = AF_IPX;\n\tsipx.sipx_type\t = ipxs->type;\n\tsipx.sipx_zero\t = 0;\n\tmemcpy(uaddr, &sipx, sizeof(sipx));\n\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int ipx_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\n{\n\t/* NULL here for pt means the packet was looped back */\n\tstruct ipx_interface *intrfc;\n\tstruct ipxhdr *ipx;\n\tu16 ipx_pktsize;\n\tint rc = 0;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Not ours */\n\tif (skb->pkt_type == PACKET_OTHERHOST)\n\t\tgoto drop;\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipxhdr)))\n\t\tgoto drop;\n\n\tipx_pktsize = ntohs(ipx_hdr(skb)->ipx_pktsize);\n\n\t/* Too small or invalid header? */\n\tif (ipx_pktsize < sizeof(struct ipxhdr) ||\n\t    !pskb_may_pull(skb, ipx_pktsize))\n\t\tgoto drop;\n\n\tipx = ipx_hdr(skb);\n\tif (ipx->ipx_checksum != IPX_NO_CHECKSUM &&\n\t   ipx->ipx_checksum != ipx_cksum(ipx, ipx_pktsize))\n\t\tgoto drop;\n\n\tIPX_SKB_CB(skb)->ipx_tctrl\t= ipx->ipx_tctrl;\n\tIPX_SKB_CB(skb)->ipx_dest_net\t= ipx->ipx_dest.net;\n\tIPX_SKB_CB(skb)->ipx_source_net = ipx->ipx_source.net;\n\n\t/* Determine what local ipx endpoint this is */\n\tintrfc = ipxitf_find_using_phys(dev, pt->type);\n\tif (!intrfc) {\n\t\tif (ipxcfg_auto_create_interfaces &&\n\t\t   IPX_SKB_CB(skb)->ipx_dest_net) {\n\t\t\tintrfc = ipxitf_auto_create(dev, pt->type);\n\t\t\tif (intrfc)\n\t\t\t\tipxitf_hold(intrfc);\n\t\t}\n\n\t\tif (!intrfc)\t/* Not one of ours */\n\t\t\t\t/* or invalid packet for auto creation */\n\t\t\tgoto drop;\n\t}\n\n\trc = ipxitf_rcv(intrfc, skb);\n\tipxitf_put(intrfc);\n\tgoto out;\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn rc;\n}\n\nstatic int ipx_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ipx *, usipx, msg->msg_name);\n\tstruct sockaddr_ipx local_sipx;\n\tint rc = -EINVAL;\n\tint flags = msg->msg_flags;\n\n\tlock_sock(sk);\n\t/* Socket gets bound below anyway */\n/*\tif (sk->sk_zapped)\n\t\treturn -EIO; */\t/* Socket not bound */\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\t/* Max possible packet size limited by 16 bit pktsize in header */\n\tif (len >= 65535 - sizeof(struct ipxhdr))\n\t\tgoto out;\n\n\tif (usipx) {\n\t\tif (!ipxs->port) {\n\t\t\tstruct sockaddr_ipx uaddr;\n\n\t\t\tuaddr.sipx_port\t\t= 0;\n\t\t\tuaddr.sipx_network\t= 0;\n#ifdef CONFIG_IPX_INTERN\n\t\t\trc = -ENETDOWN;\n\t\t\tif (!ipxs->intrfc)\n\t\t\t\tgoto out; /* Someone zonked the iface */\n\t\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\n\t\t\t\tIPX_NODE_LEN);\n#endif\n\t\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t\t\tsizeof(struct sockaddr_ipx));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usipx) ||\n\t\t    usipx->sipx_family != AF_IPX)\n\t\t\tgoto out;\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tusipx = &local_sipx;\n\t\tusipx->sipx_family \t= AF_IPX;\n\t\tusipx->sipx_type \t= ipxs->type;\n\t\tusipx->sipx_port \t= ipxs->dest_addr.sock;\n\t\tusipx->sipx_network \t= ipxs->dest_addr.net;\n\t\tmemcpy(usipx->sipx_node, ipxs->dest_addr.node, IPX_NODE_LEN);\n\t}\n\n\trc = ipxrtr_route_packet(sk, usipx, msg, len, flags & MSG_DONTWAIT);\n\tif (rc >= 0)\n\t\trc = len;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ipx *, sipx, msg->msg_name);\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\tbool locked = true;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\trelease_sock(sk);\n\tlocked = false;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\tif (rc == -EAGAIN && (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, sizeof(struct ipxhdr), msg, copied);\n\tif (rc)\n\t\tgoto out_free;\n\tif (skb->tstamp)\n\t\tsk->sk_stamp = skb->tstamp;\n\n\tif (sipx) {\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n\t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n\t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n\t\tsipx->sipx_type \t= ipx->ipx_type;\n\t\tsipx->sipx_zero\t\t= 0;\n\t\tmsg->msg_namelen\t= sizeof(*sipx);\n\t}\n\trc = copied;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (locked)\n\t\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = 0;\n\tlong amount = 0;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tlock_sock(sk);\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\t/* These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here */\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ipxhdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = ipxrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCSIFADDR:\n\tcase SIOCAIPXITFCRT:\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\tcase SIOCGIFADDR:\n\t\trc = ipxitf_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCIPXCFGDATA:\n\t\trc = ipxcfg_get_config_data(argp);\n\t\tbreak;\n\tcase SIOCIPXNCPCONN:\n\t\t/*\n\t\t * This socket wants to take care of the NCP connection\n\t\t * handed to us in arg.\n\t\t */\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = get_user(ipx_sk(sk)->ipx_ncp_conn,\n\t\t\t      (const unsigned short __user *)argp);\n\t\tbreak;\n\tcase SIOCGSTAMP:\n\t\trc = sock_get_timestamp(sk, argp);\n\t\tbreak;\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_COMPAT\nstatic int ipx_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\t/*\n\t * These 4 commands use same structure on 32bit and 64bit.  Rest of IPX\n\t * commands is handled by generic ioctl code.  As these commands are\n\t * SIOCPROTOPRIVATE..SIOCPROTOPRIVATE+3, they cannot be handled by generic\n\t * code.\n\t */\n\tswitch (cmd) {\n\tcase SIOCAIPXITFCRT:\n\tcase SIOCAIPXPRISLT:\n\tcase SIOCIPXCFGDATA:\n\tcase SIOCIPXNCPCONN:\n\t\treturn ipx_ioctl(sock, cmd, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic int ipx_shutdown(struct socket *sock, int mode)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (mode < SHUT_RD || mode > SHUT_RDWR)\n\t\treturn -EINVAL;\n\t/* This maps:\n\t * SHUT_RD   (0) -> RCV_SHUTDOWN  (1)\n\t * SHUT_WR   (1) -> SEND_SHUTDOWN (2)\n\t * SHUT_RDWR (2) -> SHUTDOWN_MASK (3)\n\t */\n\t++mode;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown |= mode;\n\trelease_sock(sk);\n\tsk->sk_state_change(sk);\n\n\treturn 0;\n}\n\n/*\n * Socket family declarations\n */\n\nstatic const struct net_proto_family ipx_family_ops = {\n\t.family\t\t= PF_IPX,\n\t.create\t\t= ipx_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops ipx_dgram_ops = {\n\t.family\t\t= PF_IPX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= ipx_release,\n\t.bind\t\t= ipx_bind,\n\t.connect\t= ipx_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= ipx_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= ipx_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ipx_compat_ioctl,\n#endif\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= ipx_shutdown,\n\t.setsockopt\t= ipx_setsockopt,\n\t.getsockopt\t= ipx_getsockopt,\n\t.sendmsg\t= ipx_sendmsg,\n\t.recvmsg\t= ipx_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.sendpage\t= sock_no_sendpage,\n};\n\nstatic struct packet_type ipx_8023_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_802_3),\n\t.func\t\t= ipx_rcv,\n};\n\nstatic struct packet_type ipx_dix_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_IPX),\n\t.func\t\t= ipx_rcv,\n};\n\nstatic struct notifier_block ipx_dev_notifier = {\n\t.notifier_call\t= ipxitf_device_event,\n};\n\nstatic const unsigned char ipx_8022_type = 0xE0;\nstatic const unsigned char ipx_snap_id[5] = { 0x0, 0x0, 0x0, 0x81, 0x37 };\nstatic const char ipx_EII_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with Ethernet II\\n\";\nstatic const char ipx_8023_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with 802.3\\n\";\nstatic const char ipx_llc_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with 802.2\\n\";\nstatic const char ipx_snap_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with SNAP\\n\";\n\nstatic int __init ipx_init(void)\n{\n\tint rc = proto_register(&ipx_proto, 1);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ipx_family_ops);\n\n\tpEII_datalink = make_EII_client();\n\tif (pEII_datalink)\n\t\tdev_add_pack(&ipx_dix_packet_type);\n\telse\n\t\tprintk(ipx_EII_err_msg);\n\n\tp8023_datalink = make_8023_client();\n\tif (p8023_datalink)\n\t\tdev_add_pack(&ipx_8023_packet_type);\n\telse\n\t\tprintk(ipx_8023_err_msg);\n\n\tp8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\n\tif (!p8022_datalink)\n\t\tprintk(ipx_llc_err_msg);\n\n\tpSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\n\tif (!pSNAP_datalink)\n\t\tprintk(ipx_snap_err_msg);\n\n\tregister_netdevice_notifier(&ipx_dev_notifier);\n\tipx_register_sysctl();\n\tipx_proc_init();\nout:\n\treturn rc;\n}\n\nstatic void __exit ipx_proto_finito(void)\n{\n\tipx_proc_exit();\n\tipx_unregister_sysctl();\n\n\tunregister_netdevice_notifier(&ipx_dev_notifier);\n\n\tipxitf_cleanup();\n\n\tif (pSNAP_datalink) {\n\t\tunregister_snap_client(pSNAP_datalink);\n\t\tpSNAP_datalink = NULL;\n\t}\n\n\tif (p8022_datalink) {\n\t\tunregister_8022_client(p8022_datalink);\n\t\tp8022_datalink = NULL;\n\t}\n\n\tdev_remove_pack(&ipx_8023_packet_type);\n\tif (p8023_datalink) {\n\t\tdestroy_8023_client(p8023_datalink);\n\t\tp8023_datalink = NULL;\n\t}\n\n\tdev_remove_pack(&ipx_dix_packet_type);\n\tif (pEII_datalink) {\n\t\tdestroy_EII_client(pEII_datalink);\n\t\tpEII_datalink = NULL;\n\t}\n\n\tproto_unregister(&ipx_proto);\n\tsock_unregister(ipx_family_ops.family);\n}\n\nmodule_init(ipx_init);\nmodule_exit(ipx_proto_finito);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_IPX);\n"], "fixing_code": ["/*\n *\tImplements an IPX socket layer.\n *\n *\tThis code is derived from work by\n *\t\tRoss Biro\t: \tWriting the original IP stack\n *\t\tFred Van Kempen :\tTidying up the TCP/IP\n *\n *\tMany thanks go to Keith Baker, Institute For Industrial Information\n *\tTechnology Ltd, Swansea University for allowing me to work on this\n *\tin my own time even though it was in some ways related to commercial\n *\twork I am currently employed to do there.\n *\n *\tAll the material in this file is subject to the Gnu license version 2.\n *\tNeither Alan Cox nor the Swansea University Computer Society admit\n *\tliability nor provide warranty for any of this software. This material\n *\tis provided as is and at no charge.\n *\n *\tPortions Copyright (c) 2000-2003 Conectiva, Inc. <acme@conectiva.com.br>\n *\tNeither Arnaldo Carvalho de Melo nor Conectiva, Inc. admit liability nor\n *\tprovide warranty for any of this software. This material is provided\n *\t\"AS-IS\" and at no charge.\n *\n * \tPortions Copyright (c) 1995 Caldera, Inc. <greg@caldera.com>\n *\tNeither Greg Page nor Caldera, Inc. admit liability nor provide\n *\twarranty for any of this software. This material is provided\n *\t\"AS-IS\" and at no charge.\n *\n *\tSee net/ipx/ChangeLog.\n */\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/ipx.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/netdevice.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/termios.h>\n\n#include <net/ipx.h>\n#include <net/p8022.h>\n#include <net/psnap.h>\n#include <net/sock.h>\n#include <net/datalink.h>\n#include <net/tcp_states.h>\n#include <net/net_namespace.h>\n\n#include <linux/uaccess.h>\n\n/* Configuration Variables */\nstatic unsigned char ipxcfg_max_hops = 16;\nstatic char ipxcfg_auto_select_primary;\nstatic char ipxcfg_auto_create_interfaces;\nint sysctl_ipx_pprop_broadcasting = 1;\n\n/* Global Variables */\nstatic struct datalink_proto *p8022_datalink;\nstatic struct datalink_proto *pEII_datalink;\nstatic struct datalink_proto *p8023_datalink;\nstatic struct datalink_proto *pSNAP_datalink;\n\nstatic const struct proto_ops ipx_dgram_ops;\n\nLIST_HEAD(ipx_interfaces);\nDEFINE_SPINLOCK(ipx_interfaces_lock);\n\nstruct ipx_interface *ipx_primary_net;\nstruct ipx_interface *ipx_internal_net;\n\nstruct ipx_interface *ipx_interfaces_head(void)\n{\n\tstruct ipx_interface *rc = NULL;\n\n\tif (!list_empty(&ipx_interfaces))\n\t\trc = list_entry(ipx_interfaces.next,\n\t\t\t\tstruct ipx_interface, node);\n\treturn rc;\n}\n\nstatic void ipxcfg_set_auto_select(char val)\n{\n\tipxcfg_auto_select_primary = val;\n\tif (val && !ipx_primary_net)\n\t\tipx_primary_net = ipx_interfaces_head();\n}\n\nstatic int ipxcfg_get_config_data(struct ipx_config_data __user *arg)\n{\n\tstruct ipx_config_data vals;\n\n\tvals.ipxcfg_auto_create_interfaces = ipxcfg_auto_create_interfaces;\n\tvals.ipxcfg_auto_select_primary\t   = ipxcfg_auto_select_primary;\n\n\treturn copy_to_user(arg, &vals, sizeof(vals)) ? -EFAULT : 0;\n}\n\n/*\n * Note: Sockets may not be removed _during_ an interrupt or inet_bh\n * handler using this technique. They can be added although we do not\n * use this facility.\n */\n\nstatic void ipx_remove_socket(struct sock *sk)\n{\n\t/* Determine interface with which socket is associated */\n\tstruct ipx_interface *intrfc = ipx_sk(sk)->intrfc;\n\n\tif (!intrfc)\n\t\tgoto out;\n\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\nout:\n\treturn;\n}\n\nstatic void ipx_destroy_socket(struct sock *sk)\n{\n\tipx_remove_socket(sk);\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tsk_refcnt_debug_dec(sk);\n}\n\n/*\n * The following code is used to support IPX Interfaces (IPXITF).  An\n * IPX interface is defined by a physical device and a frame type.\n */\n\n/* ipxitf_clear_primary_net has to be called with ipx_interfaces_lock held */\n\nstatic void ipxitf_clear_primary_net(void)\n{\n\tipx_primary_net = NULL;\n\tif (ipxcfg_auto_select_primary)\n\t\tipx_primary_net = ipx_interfaces_head();\n}\n\nstatic struct ipx_interface *__ipxitf_find_using_phys(struct net_device *dev,\n\t\t\t\t\t\t      __be16 datalink)\n{\n\tstruct ipx_interface *i;\n\n\tlist_for_each_entry(i, &ipx_interfaces, node)\n\t\tif (i->if_dev == dev && i->if_dlink_type == datalink)\n\t\t\tgoto out;\n\ti = NULL;\nout:\n\treturn i;\n}\n\nstatic struct ipx_interface *ipxitf_find_using_phys(struct net_device *dev,\n\t\t\t\t\t\t    __be16 datalink)\n{\n\tstruct ipx_interface *i;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\ti = __ipxitf_find_using_phys(dev, datalink);\n\tif (i)\n\t\tipxitf_hold(i);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn i;\n}\n\nstruct ipx_interface *ipxitf_find_using_net(__be32 net)\n{\n\tstruct ipx_interface *i;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tif (net) {\n\t\tlist_for_each_entry(i, &ipx_interfaces, node)\n\t\t\tif (i->if_netnum == net)\n\t\t\t\tgoto hold;\n\t\ti = NULL;\n\t\tgoto unlock;\n\t}\n\n\ti = ipx_primary_net;\n\tif (i)\nhold:\n\t\tipxitf_hold(i);\nunlock:\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn i;\n}\n\n/* Sockets are bound to a particular IPX interface. */\nstatic void ipxitf_insert_socket(struct ipx_interface *intrfc, struct sock *sk)\n{\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\tipx_sk(sk)->intrfc = intrfc;\n\tsk_add_node(sk, &intrfc->if_sklist);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\n}\n\n/* caller must hold intrfc->if_sklist_lock */\nstatic struct sock *__ipxitf_find_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t __be16 port)\n{\n\tstruct sock *s;\n\n\tsk_for_each(s, &intrfc->if_sklist)\n\t\tif (ipx_sk(s)->port == port)\n\t\t\tgoto found;\n\ts = NULL;\nfound:\n\treturn s;\n}\n\n/* caller must hold a reference to intrfc */\nstatic struct sock *ipxitf_find_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t__be16 port)\n{\n\tstruct sock *s;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\ts = __ipxitf_find_socket(intrfc, port);\n\tif (s)\n\t\tsock_hold(s);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\n\treturn s;\n}\n\n#ifdef CONFIG_IPX_INTERN\nstatic struct sock *ipxitf_find_internal_socket(struct ipx_interface *intrfc,\n\t\t\t\t\t\tunsigned char *ipx_node,\n\t\t\t\t\t\t__be16 port)\n{\n\tstruct sock *s;\n\n\tipxitf_hold(intrfc);\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tsk_for_each(s, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\tif (ipxs->port == port &&\n\t\t    !memcmp(ipx_node, ipxs->node, IPX_NODE_LEN))\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tipxitf_put(intrfc);\n\treturn s;\n}\n#endif\n\nstatic void __ipxitf_down(struct ipx_interface *intrfc)\n{\n\tstruct sock *s;\n\tstruct hlist_node *t;\n\n\t/* Delete all routes associated with this interface */\n\tipxrtr_del_routes(intrfc);\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\t/* error sockets */\n\tsk_for_each_safe(s, t, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\ts->sk_err = ENOLINK;\n\t\ts->sk_error_report(s);\n\t\tipxs->intrfc = NULL;\n\t\tipxs->port   = 0;\n\t\tsock_set_flag(s, SOCK_ZAPPED); /* Indicates it is no longer bound */\n\t\tsk_del_node_init(s);\n\t}\n\tINIT_HLIST_HEAD(&intrfc->if_sklist);\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\n\t/* remove this interface from list */\n\tlist_del(&intrfc->node);\n\n\t/* remove this interface from *special* networks */\n\tif (intrfc == ipx_primary_net)\n\t\tipxitf_clear_primary_net();\n\tif (intrfc == ipx_internal_net)\n\t\tipx_internal_net = NULL;\n\n\tif (intrfc->if_dev)\n\t\tdev_put(intrfc->if_dev);\n\tkfree(intrfc);\n}\n\nvoid ipxitf_down(struct ipx_interface *intrfc)\n{\n\tspin_lock_bh(&ipx_interfaces_lock);\n\t__ipxitf_down(intrfc);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n}\n\nstatic void __ipxitf_put(struct ipx_interface *intrfc)\n{\n\tif (atomic_dec_and_test(&intrfc->refcnt))\n\t\t__ipxitf_down(intrfc);\n}\n\nstatic int ipxitf_device_event(struct notifier_block *notifier,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ipx_interface *i, *tmp;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN && event != NETDEV_UP)\n\t\tgoto out;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\n\t\tif (i->if_dev == dev) {\n\t\t\tif (event == NETDEV_UP)\n\t\t\t\tipxitf_hold(i);\n\t\t\telse\n\t\t\t\t__ipxitf_put(i);\n\t\t}\n\tspin_unlock_bh(&ipx_interfaces_lock);\nout:\n\treturn NOTIFY_DONE;\n}\n\n\nstatic __exit void ipxitf_cleanup(void)\n{\n\tstruct ipx_interface *i, *tmp;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry_safe(i, tmp, &ipx_interfaces, node)\n\t\t__ipxitf_put(i);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n}\n\nstatic void ipxitf_def_skb_handler(struct sock *sock, struct sk_buff *skb)\n{\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tkfree_skb(skb);\n}\n\n/*\n * On input skb->sk is NULL. Nobody is charged for the memory.\n */\n\n/* caller must hold a reference to intrfc */\n\n#ifdef CONFIG_IPX_INTERN\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\n\t\t\t       struct sk_buff *skb, int copy)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint is_broadcast = !memcmp(ipx->ipx_dest.node, ipx_broadcast_node,\n\t\t\t\t   IPX_NODE_LEN);\n\tstruct sock *s;\n\tint rc;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tsk_for_each(s, &intrfc->if_sklist) {\n\t\tstruct ipx_sock *ipxs = ipx_sk(s);\n\n\t\tif (ipxs->port == ipx->ipx_dest.sock &&\n\t\t    (is_broadcast || !memcmp(ipx->ipx_dest.node,\n\t\t\t\t\t     ipxs->node, IPX_NODE_LEN))) {\n\t\t\t/* We found a socket to which to send */\n\t\t\tstruct sk_buff *skb1;\n\n\t\t\tif (copy) {\n\t\t\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tif (!skb1)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tskb1 = skb;\n\t\t\t\tcopy = 1; /* skb may only be used once */\n\t\t\t}\n\t\t\tipxitf_def_skb_handler(s, skb1);\n\n\t\t\t/* On an external interface, one socket can listen */\n\t\t\tif (intrfc != ipx_internal_net)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* skb was solely for us, and we did not make a copy, so free it. */\n\tif (!copy)\n\t\tkfree_skb(skb);\n\n\trc = 0;\nout:\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\treturn rc;\n}\n#else\nstatic struct sock *ncp_connection_hack(struct ipx_interface *intrfc,\n\t\t\t\t\tstruct ipxhdr *ipx)\n{\n\t/* The packet's target is a NCP connection handler. We want to hand it\n\t * to the correct socket directly within the kernel, so that the\n\t * mars_nwe packet distribution process does not have to do it. Here we\n\t * only care about NCP and BURST packets.\n\t *\n\t * You might call this a hack, but believe me, you do not want a\n\t * complete NCP layer in the kernel, and this is VERY fast as well. */\n\tstruct sock *sk = NULL;\n\tint connection = 0;\n\tu8 *ncphdr = (u8 *)(ipx + 1);\n\n\tif (*ncphdr == 0x22 && *(ncphdr + 1) == 0x22) /* NCP request */\n\t\tconnection = (((int) *(ncphdr + 5)) << 8) | (int) *(ncphdr + 3);\n\telse if (*ncphdr == 0x77 && *(ncphdr + 1) == 0x77) /* BURST packet */\n\t\tconnection = (((int) *(ncphdr + 9)) << 8) | (int) *(ncphdr + 8);\n\n\tif (connection) {\n\t\t/* Now we have to look for a special NCP connection handling\n\t\t * socket. Only these sockets have ipx_ncp_conn != 0, set by\n\t\t * SIOCIPXNCPCONN. */\n\t\tspin_lock_bh(&intrfc->if_sklist_lock);\n\t\tsk_for_each(sk, &intrfc->if_sklist)\n\t\t\tif (ipx_sk(sk)->ipx_ncp_conn == connection) {\n\t\t\t\tsock_hold(sk);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\tsk = NULL;\n\tfound:\n\t\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\t}\n\treturn sk;\n}\n\nstatic int ipxitf_demux_socket(struct ipx_interface *intrfc,\n\t\t\t       struct sk_buff *skb, int copy)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tstruct sock *sock1 = NULL, *sock2 = NULL;\n\tstruct sk_buff *skb1 = NULL, *skb2 = NULL;\n\tint rc;\n\n\tif (intrfc == ipx_primary_net && ntohs(ipx->ipx_dest.sock) == 0x451)\n\t\tsock1 = ncp_connection_hack(intrfc, ipx);\n\tif (!sock1)\n\t\t/* No special socket found, forward the packet the normal way */\n\t\tsock1 = ipxitf_find_socket(intrfc, ipx->ipx_dest.sock);\n\n\t/*\n\t * We need to check if there is a primary net and if\n\t * this is addressed to one of the *SPECIAL* sockets because\n\t * these need to be propagated to the primary net.\n\t * The *SPECIAL* socket list contains: 0x452(SAP), 0x453(RIP) and\n\t * 0x456(Diagnostic).\n\t */\n\n\tif (ipx_primary_net && intrfc != ipx_primary_net) {\n\t\tconst int dsock = ntohs(ipx->ipx_dest.sock);\n\n\t\tif (dsock == 0x452 || dsock == 0x453 || dsock == 0x456)\n\t\t\t/* The appropriate thing to do here is to dup the\n\t\t\t * packet and route to the primary net interface via\n\t\t\t * ipxitf_send; however, we'll cheat and just demux it\n\t\t\t * here. */\n\t\t\tsock2 = ipxitf_find_socket(ipx_primary_net,\n\t\t\t\t\t\t\tipx->ipx_dest.sock);\n\t}\n\n\t/*\n\t * If there is nothing to do return. The kfree will cancel any charging.\n\t */\n\trc = 0;\n\tif (!sock1 && !sock2) {\n\t\tif (!copy)\n\t\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * This next segment of code is a little awkward, but it sets it up\n\t * so that the appropriate number of copies of the SKB are made and\n\t * that skb1 and skb2 point to it (them) so that it (they) can be\n\t * demuxed to sock1 and/or sock2.  If we are unable to make enough\n\t * copies, we do as much as is possible.\n\t */\n\n\tif (copy)\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\telse\n\t\tskb1 = skb;\n\n\trc = -ENOMEM;\n\tif (!skb1)\n\t\tgoto out_put;\n\n\t/* Do we need 2 SKBs? */\n\tif (sock1 && sock2)\n\t\tskb2 = skb_clone(skb1, GFP_ATOMIC);\n\telse\n\t\tskb2 = skb1;\n\n\tif (sock1)\n\t\tipxitf_def_skb_handler(sock1, skb1);\n\n\tif (!skb2)\n\t\tgoto out_put;\n\n\tif (sock2)\n\t\tipxitf_def_skb_handler(sock2, skb2);\n\n\trc = 0;\nout_put:\n\tif (sock1)\n\t\tsock_put(sock1);\n\tif (sock2)\n\t\tsock_put(sock2);\nout:\n\treturn rc;\n}\n#endif\t/* CONFIG_IPX_INTERN */\n\nstatic struct sk_buff *ipxitf_adjust_skbuff(struct ipx_interface *intrfc,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\tint in_offset = (unsigned char *)ipx_hdr(skb) - skb->head;\n\tint out_offset = intrfc->if_ipx_offset;\n\tint len;\n\n\t/* Hopefully, most cases */\n\tif (in_offset >= out_offset)\n\t\treturn skb;\n\n\t/* Need new SKB */\n\tlen  = skb->len + out_offset;\n\tskb2 = alloc_skb(len, GFP_ATOMIC);\n\tif (skb2) {\n\t\tskb_reserve(skb2, out_offset);\n\t\tskb_reset_network_header(skb2);\n\t\tskb_reset_transport_header(skb2);\n\t\tskb_put(skb2, skb->len);\n\t\tmemcpy(ipx_hdr(skb2), ipx_hdr(skb), skb->len);\n\t\tmemcpy(skb2->cb, skb->cb, sizeof(skb->cb));\n\t}\n\tkfree_skb(skb);\n\treturn skb2;\n}\n\n/* caller must hold a reference to intrfc and the skb has to be unshared */\nint ipxitf_send(struct ipx_interface *intrfc, struct sk_buff *skb, char *node)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tstruct net_device *dev = intrfc->if_dev;\n\tstruct datalink_proto *dl = intrfc->if_dlink;\n\tchar dest_node[IPX_NODE_LEN];\n\tint send_to_wire = 1;\n\tint addr_len;\n\n\tipx->ipx_tctrl = IPX_SKB_CB(skb)->ipx_tctrl;\n\tipx->ipx_dest.net = IPX_SKB_CB(skb)->ipx_dest_net;\n\tipx->ipx_source.net = IPX_SKB_CB(skb)->ipx_source_net;\n\n\t/* see if we need to include the netnum in the route list */\n\tif (IPX_SKB_CB(skb)->last_hop.index >= 0) {\n\t\t__be32 *last_hop = (__be32 *)(((u8 *) skb->data) +\n\t\t\t\tsizeof(struct ipxhdr) +\n\t\t\t\tIPX_SKB_CB(skb)->last_hop.index *\n\t\t\t\tsizeof(__be32));\n\t\t*last_hop = IPX_SKB_CB(skb)->last_hop.netnum;\n\t\tIPX_SKB_CB(skb)->last_hop.index = -1;\n\t}\n\n\t/*\n\t * We need to know how many skbuffs it will take to send out this\n\t * packet to avoid unnecessary copies.\n\t */\n\n\tif (!dl || !dev || dev->flags & IFF_LOOPBACK)\n\t\tsend_to_wire = 0;\t/* No non looped */\n\n\t/*\n\t * See if this should be demuxed to sockets on this interface\n\t *\n\t * We want to ensure the original was eaten or that we only use\n\t * up clones.\n\t */\n\n\tif (ipx->ipx_dest.net == intrfc->if_netnum) {\n\t\t/*\n\t\t * To our own node, loop and free the original.\n\t\t * The internal net will receive on all node address.\n\t\t */\n\t\tif (intrfc == ipx_internal_net ||\n\t\t    !memcmp(intrfc->if_node, node, IPX_NODE_LEN)) {\n\t\t\t/* Don't charge sender */\n\t\t\tskb_orphan(skb);\n\n\t\t\t/* Will charge receiver */\n\t\t\treturn ipxitf_demux_socket(intrfc, skb, 0);\n\t\t}\n\n\t\t/* Broadcast, loop and possibly keep to send on. */\n\t\tif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN)) {\n\t\t\tif (!send_to_wire)\n\t\t\t\tskb_orphan(skb);\n\t\t\tipxitf_demux_socket(intrfc, skb, send_to_wire);\n\t\t\tif (!send_to_wire)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * If the originating net is not equal to our net; this is routed\n\t * We are still charging the sender. Which is right - the driver\n\t * free will handle this fairly.\n\t */\n\tif (ipx->ipx_source.net != intrfc->if_netnum) {\n\t\t/*\n\t\t * Unshare the buffer before modifying the count in\n\t\t * case it's a flood or tcpdump\n\t\t */\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto out;\n\t\tif (++ipx->ipx_tctrl > ipxcfg_max_hops)\n\t\t\tsend_to_wire = 0;\n\t}\n\n\tif (!send_to_wire) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t/* Determine the appropriate hardware address */\n\taddr_len = dev->addr_len;\n\tif (!memcmp(ipx_broadcast_node, node, IPX_NODE_LEN))\n\t\tmemcpy(dest_node, dev->broadcast, addr_len);\n\telse\n\t\tmemcpy(dest_node, &(node[IPX_NODE_LEN-addr_len]), addr_len);\n\n\t/* Make any compensation for differing physical/data link size */\n\tskb = ipxitf_adjust_skbuff(intrfc, skb);\n\tif (!skb)\n\t\tgoto out;\n\n\t/* set up data link and physical headers */\n\tskb->dev\t= dev;\n\tskb->protocol\t= htons(ETH_P_IPX);\n\n\t/* Send it out */\n\tdl->request(dl, skb, dest_node);\nout:\n\treturn 0;\n}\n\nstatic int ipxitf_add_local_route(struct ipx_interface *intrfc)\n{\n\treturn ipxrtr_add_route(intrfc->if_netnum, intrfc, NULL);\n}\n\nstatic void ipxitf_discover_netnum(struct ipx_interface *intrfc,\n\t\t\t\t   struct sk_buff *skb);\nstatic int ipxitf_pprop(struct ipx_interface *intrfc, struct sk_buff *skb);\n\nstatic int ipxitf_rcv(struct ipx_interface *intrfc, struct sk_buff *skb)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint rc = 0;\n\n\tipxitf_hold(intrfc);\n\n\t/* See if we should update our network number */\n\tif (!intrfc->if_netnum) /* net number of intrfc not known yet */\n\t\tipxitf_discover_netnum(intrfc, skb);\n\n\tIPX_SKB_CB(skb)->last_hop.index = -1;\n\tif (ipx->ipx_type == IPX_TYPE_PPROP) {\n\t\trc = ipxitf_pprop(intrfc, skb);\n\t\tif (rc)\n\t\t\tgoto out_free_skb;\n\t}\n\n\t/* local processing follows */\n\tif (!IPX_SKB_CB(skb)->ipx_dest_net)\n\t\tIPX_SKB_CB(skb)->ipx_dest_net = intrfc->if_netnum;\n\tif (!IPX_SKB_CB(skb)->ipx_source_net)\n\t\tIPX_SKB_CB(skb)->ipx_source_net = intrfc->if_netnum;\n\n\t/* it doesn't make sense to route a pprop packet, there's no meaning\n\t * in the ipx_dest_net for such packets */\n\tif (ipx->ipx_type != IPX_TYPE_PPROP &&\n\t    intrfc->if_netnum != IPX_SKB_CB(skb)->ipx_dest_net) {\n\t\t/* We only route point-to-point packets. */\n\t\tif (skb->pkt_type == PACKET_HOST) {\n\t\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\t\tif (skb)\n\t\t\t\trc = ipxrtr_route_skb(skb);\n\t\t\tgoto out_intrfc;\n\t\t}\n\n\t\tgoto out_free_skb;\n\t}\n\n\t/* see if we should keep it */\n\tif (!memcmp(ipx_broadcast_node, ipx->ipx_dest.node, IPX_NODE_LEN) ||\n\t    !memcmp(intrfc->if_node, ipx->ipx_dest.node, IPX_NODE_LEN)) {\n\t\trc = ipxitf_demux_socket(intrfc, skb, 0);\n\t\tgoto out_intrfc;\n\t}\n\n\t/* we couldn't pawn it off so unload it */\nout_free_skb:\n\tkfree_skb(skb);\nout_intrfc:\n\tipxitf_put(intrfc);\n\treturn rc;\n}\n\nstatic void ipxitf_discover_netnum(struct ipx_interface *intrfc,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tconst struct ipx_cb *cb = IPX_SKB_CB(skb);\n\n\t/* see if this is an intra packet: source_net == dest_net */\n\tif (cb->ipx_source_net == cb->ipx_dest_net && cb->ipx_source_net) {\n\t\tstruct ipx_interface *i =\n\t\t\t\tipxitf_find_using_net(cb->ipx_source_net);\n\t\t/* NB: NetWare servers lie about their hop count so we\n\t\t * dropped the test based on it. This is the best way\n\t\t * to determine this is a 0 hop count packet. */\n\t\tif (!i) {\n\t\t\tintrfc->if_netnum = cb->ipx_source_net;\n\t\t\tipxitf_add_local_route(intrfc);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"IPX: Network number collision \"\n\t\t\t\t\"%lx\\n        %s %s and %s %s\\n\",\n\t\t\t\t(unsigned long) ntohl(cb->ipx_source_net),\n\t\t\t\tipx_device_name(i),\n\t\t\t\tipx_frame_name(i->if_dlink_type),\n\t\t\t\tipx_device_name(intrfc),\n\t\t\t\tipx_frame_name(intrfc->if_dlink_type));\n\t\t\tipxitf_put(i);\n\t\t}\n\t}\n}\n\n/**\n * ipxitf_pprop - Process packet propagation IPX packet type 0x14, used for\n * \t\t  NetBIOS broadcasts\n * @intrfc: IPX interface receiving this packet\n * @skb: Received packet\n *\n * Checks if packet is valid: if its more than %IPX_MAX_PPROP_HOPS hops or if it\n * is smaller than a IPX header + the room for %IPX_MAX_PPROP_HOPS hops we drop\n * it, not even processing it locally, if it has exact %IPX_MAX_PPROP_HOPS we\n * don't broadcast it, but process it locally. See chapter 5 of Novell's \"IPX\n * RIP and SAP Router Specification\", Part Number 107-000029-001.\n *\n * If it is valid, check if we have pprop broadcasting enabled by the user,\n * if not, just return zero for local processing.\n *\n * If it is enabled check the packet and don't broadcast it if we have already\n * seen this packet.\n *\n * Broadcast: send it to the interfaces that aren't on the packet visited nets\n * array, just after the IPX header.\n *\n * Returns -EINVAL for invalid packets, so that the calling function drops\n * the packet without local processing. 0 if packet is to be locally processed.\n */\nstatic int ipxitf_pprop(struct ipx_interface *intrfc, struct sk_buff *skb)\n{\n\tstruct ipxhdr *ipx = ipx_hdr(skb);\n\tint i, rc = -EINVAL;\n\tstruct ipx_interface *ifcs;\n\tchar *c;\n\t__be32 *l;\n\n\t/* Illegal packet - too many hops or too short */\n\t/* We decide to throw it away: no broadcasting, no local processing.\n\t * NetBIOS unaware implementations route them as normal packets -\n\t * tctrl <= 15, any data payload... */\n\tif (IPX_SKB_CB(skb)->ipx_tctrl > IPX_MAX_PPROP_HOPS ||\n\t    ntohs(ipx->ipx_pktsize) < sizeof(struct ipxhdr) +\n\t\t\t\t\tIPX_MAX_PPROP_HOPS * sizeof(u32))\n\t\tgoto out;\n\t/* are we broadcasting this damn thing? */\n\trc = 0;\n\tif (!sysctl_ipx_pprop_broadcasting)\n\t\tgoto out;\n\t/* We do broadcast packet on the IPX_MAX_PPROP_HOPS hop, but we\n\t * process it locally. All previous hops broadcasted it, and process it\n\t * locally. */\n\tif (IPX_SKB_CB(skb)->ipx_tctrl == IPX_MAX_PPROP_HOPS)\n\t\tgoto out;\n\n\tc = ((u8 *) ipx) + sizeof(struct ipxhdr);\n\tl = (__be32 *) c;\n\n\t/* Don't broadcast packet if already seen this net */\n\tfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\n\t\tif (*l++ == intrfc->if_netnum)\n\t\t\tgoto out;\n\n\t/* < IPX_MAX_PPROP_HOPS hops && input interface not in list. Save the\n\t * position where we will insert recvd netnum into list, later on,\n\t * in ipxitf_send */\n\tIPX_SKB_CB(skb)->last_hop.index = i;\n\tIPX_SKB_CB(skb)->last_hop.netnum = intrfc->if_netnum;\n\t/* xmit on all other interfaces... */\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_for_each_entry(ifcs, &ipx_interfaces, node) {\n\t\t/* Except unconfigured interfaces */\n\t\tif (!ifcs->if_netnum)\n\t\t\tcontinue;\n\n\t\t/* That aren't in the list */\n\t\tif (ifcs == intrfc)\n\t\t\tcontinue;\n\t\tl = (__be32 *) c;\n\t\t/* don't consider the last entry in the packet list,\n\t\t * it is our netnum, and it is not there yet */\n\t\tfor (i = 0; i < IPX_SKB_CB(skb)->ipx_tctrl; i++)\n\t\t\tif (ifcs->if_netnum == *l++)\n\t\t\t\tbreak;\n\t\tif (i == IPX_SKB_CB(skb)->ipx_tctrl) {\n\t\t\tstruct sk_buff *s = skb_copy(skb, GFP_ATOMIC);\n\n\t\t\tif (s) {\n\t\t\t\tIPX_SKB_CB(s)->ipx_dest_net = ifcs->if_netnum;\n\t\t\t\tipxrtr_route_skb(s);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&ipx_interfaces_lock);\nout:\n\treturn rc;\n}\n\nstatic void ipxitf_insert(struct ipx_interface *intrfc)\n{\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tlist_add_tail(&intrfc->node, &ipx_interfaces);\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\n\tif (ipxcfg_auto_select_primary && !ipx_primary_net)\n\t\tipx_primary_net = intrfc;\n}\n\nstatic struct ipx_interface *ipxitf_alloc(struct net_device *dev, __be32 netnum,\n\t\t\t\t\t  __be16 dlink_type,\n\t\t\t\t\t  struct datalink_proto *dlink,\n\t\t\t\t\t  unsigned char internal,\n\t\t\t\t\t  int ipx_offset)\n{\n\tstruct ipx_interface *intrfc = kmalloc(sizeof(*intrfc), GFP_ATOMIC);\n\n\tif (intrfc) {\n\t\tintrfc->if_dev\t\t= dev;\n\t\tintrfc->if_netnum\t= netnum;\n\t\tintrfc->if_dlink_type \t= dlink_type;\n\t\tintrfc->if_dlink \t= dlink;\n\t\tintrfc->if_internal \t= internal;\n\t\tintrfc->if_ipx_offset \t= ipx_offset;\n\t\tintrfc->if_sknum \t= IPX_MIN_EPHEMERAL_SOCKET;\n\t\tINIT_HLIST_HEAD(&intrfc->if_sklist);\n\t\tatomic_set(&intrfc->refcnt, 1);\n\t\tspin_lock_init(&intrfc->if_sklist_lock);\n\t}\n\n\treturn intrfc;\n}\n\nstatic int ipxitf_create_internal(struct ipx_interface_definition *idef)\n{\n\tstruct ipx_interface *intrfc;\n\tint rc = -EEXIST;\n\n\t/* Only one primary network allowed */\n\tif (ipx_primary_net)\n\t\tgoto out;\n\n\t/* Must have a valid network number */\n\trc = -EADDRNOTAVAIL;\n\tif (!idef->ipx_network)\n\t\tgoto out;\n\tintrfc = ipxitf_find_using_net(idef->ipx_network);\n\trc = -EADDRINUSE;\n\tif (intrfc) {\n\t\tipxitf_put(intrfc);\n\t\tgoto out;\n\t}\n\tintrfc = ipxitf_alloc(NULL, idef->ipx_network, 0, NULL, 1, 0);\n\trc = -EAGAIN;\n\tif (!intrfc)\n\t\tgoto out;\n\tmemcpy((char *)&(intrfc->if_node), idef->ipx_node, IPX_NODE_LEN);\n\tipx_internal_net = ipx_primary_net = intrfc;\n\tipxitf_hold(intrfc);\n\tipxitf_insert(intrfc);\n\n\trc = ipxitf_add_local_route(intrfc);\n\tipxitf_put(intrfc);\nout:\n\treturn rc;\n}\n\nstatic __be16 ipx_map_frame_type(unsigned char type)\n{\n\t__be16 rc = 0;\n\n\tswitch (type) {\n\tcase IPX_FRAME_ETHERII:\trc = htons(ETH_P_IPX);\t\tbreak;\n\tcase IPX_FRAME_8022:\trc = htons(ETH_P_802_2);\tbreak;\n\tcase IPX_FRAME_SNAP:\trc = htons(ETH_P_SNAP);\t\tbreak;\n\tcase IPX_FRAME_8023:\trc = htons(ETH_P_802_3);\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int ipxitf_create(struct ipx_interface_definition *idef)\n{\n\tstruct net_device *dev;\n\t__be16 dlink_type = 0;\n\tstruct datalink_proto *datalink = NULL;\n\tstruct ipx_interface *intrfc;\n\tint rc;\n\n\tif (idef->ipx_special == IPX_INTERNAL) {\n\t\trc = ipxitf_create_internal(idef);\n\t\tgoto out;\n\t}\n\n\trc = -EEXIST;\n\tif (idef->ipx_special == IPX_PRIMARY && ipx_primary_net)\n\t\tgoto out;\n\n\tintrfc = ipxitf_find_using_net(idef->ipx_network);\n\trc = -EADDRINUSE;\n\tif (idef->ipx_network && intrfc) {\n\t\tipxitf_put(intrfc);\n\t\tgoto out;\n\t}\n\n\tif (intrfc)\n\t\tipxitf_put(intrfc);\n\n\tdev = dev_get_by_name(&init_net, idef->ipx_device);\n\trc = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tswitch (idef->ipx_dlink_type) {\n\tcase IPX_FRAME_8022:\n\t\tdlink_type \t= htons(ETH_P_802_2);\n\t\tdatalink \t= p8022_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_ETHERII:\n\t\tif (dev->type != ARPHRD_IEEE802) {\n\t\t\tdlink_type \t= htons(ETH_P_IPX);\n\t\t\tdatalink \t= pEII_datalink;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\tcase IPX_FRAME_SNAP:\n\t\tdlink_type \t= htons(ETH_P_SNAP);\n\t\tdatalink \t= pSNAP_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_8023:\n\t\tdlink_type \t= htons(ETH_P_802_3);\n\t\tdatalink \t= p8023_datalink;\n\t\tbreak;\n\tcase IPX_FRAME_NONE:\n\tdefault:\n\t\trc = -EPROTONOSUPPORT;\n\t\tgoto out_dev;\n\t}\n\n\trc = -ENETDOWN;\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out_dev;\n\n\t/* Check addresses are suitable */\n\trc = -EINVAL;\n\tif (dev->addr_len > IPX_NODE_LEN)\n\t\tgoto out_dev;\n\n\tintrfc = ipxitf_find_using_phys(dev, dlink_type);\n\tif (!intrfc) {\n\t\t/* Ok now create */\n\t\tintrfc = ipxitf_alloc(dev, idef->ipx_network, dlink_type,\n\t\t\t\t      datalink, 0, dev->hard_header_len +\n\t\t\t\t\tdatalink->header_length);\n\t\trc = -EAGAIN;\n\t\tif (!intrfc)\n\t\t\tgoto out_dev;\n\t\t/* Setup primary if necessary */\n\t\tif (idef->ipx_special == IPX_PRIMARY)\n\t\t\tipx_primary_net = intrfc;\n\t\tif (!memcmp(idef->ipx_node, \"\\000\\000\\000\\000\\000\\000\",\n\t\t\t    IPX_NODE_LEN)) {\n\t\t\tmemset(intrfc->if_node, 0, IPX_NODE_LEN);\n\t\t\tmemcpy(intrfc->if_node + IPX_NODE_LEN - dev->addr_len,\n\t\t\t\tdev->dev_addr, dev->addr_len);\n\t\t} else\n\t\t\tmemcpy(intrfc->if_node, idef->ipx_node, IPX_NODE_LEN);\n\t\tipxitf_hold(intrfc);\n\t\tipxitf_insert(intrfc);\n\t}\n\n\n\t/* If the network number is known, add a route */\n\trc = 0;\n\tif (!intrfc->if_netnum)\n\t\tgoto out_intrfc;\n\n\trc = ipxitf_add_local_route(intrfc);\nout_intrfc:\n\tipxitf_put(intrfc);\n\tgoto out;\nout_dev:\n\tdev_put(dev);\nout:\n\treturn rc;\n}\n\nstatic int ipxitf_delete(struct ipx_interface_definition *idef)\n{\n\tstruct net_device *dev = NULL;\n\t__be16 dlink_type = 0;\n\tstruct ipx_interface *intrfc;\n\tint rc = 0;\n\n\tspin_lock_bh(&ipx_interfaces_lock);\n\tif (idef->ipx_special == IPX_INTERNAL) {\n\t\tif (ipx_internal_net) {\n\t\t\t__ipxitf_put(ipx_internal_net);\n\t\t\tgoto out;\n\t\t}\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tdlink_type = ipx_map_frame_type(idef->ipx_dlink_type);\n\trc = -EPROTONOSUPPORT;\n\tif (!dlink_type)\n\t\tgoto out;\n\n\tdev = __dev_get_by_name(&init_net, idef->ipx_device);\n\trc = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tintrfc = __ipxitf_find_using_phys(dev, dlink_type);\n\trc = -EINVAL;\n\tif (!intrfc)\n\t\tgoto out;\n\t__ipxitf_put(intrfc);\n\n\trc = 0;\nout:\n\tspin_unlock_bh(&ipx_interfaces_lock);\n\treturn rc;\n}\n\nstatic struct ipx_interface *ipxitf_auto_create(struct net_device *dev,\n\t\t\t\t\t\t__be16 dlink_type)\n{\n\tstruct ipx_interface *intrfc = NULL;\n\tstruct datalink_proto *datalink;\n\n\tif (!dev)\n\t\tgoto out;\n\n\t/* Check addresses are suitable */\n\tif (dev->addr_len > IPX_NODE_LEN)\n\t\tgoto out;\n\n\tswitch (ntohs(dlink_type)) {\n\tcase ETH_P_IPX:\t\tdatalink = pEII_datalink;\tbreak;\n\tcase ETH_P_802_2:\tdatalink = p8022_datalink;\tbreak;\n\tcase ETH_P_SNAP:\tdatalink = pSNAP_datalink;\tbreak;\n\tcase ETH_P_802_3:\tdatalink = p8023_datalink;\tbreak;\n\tdefault:\t\tgoto out;\n\t}\n\n\tintrfc = ipxitf_alloc(dev, 0, dlink_type, datalink, 0,\n\t\t\t\tdev->hard_header_len + datalink->header_length);\n\n\tif (intrfc) {\n\t\tmemset(intrfc->if_node, 0, IPX_NODE_LEN);\n\t\tmemcpy((char *)&(intrfc->if_node[IPX_NODE_LEN-dev->addr_len]),\n\t\t\tdev->dev_addr, dev->addr_len);\n\t\tspin_lock_init(&intrfc->if_sklist_lock);\n\t\tatomic_set(&intrfc->refcnt, 1);\n\t\tipxitf_insert(intrfc);\n\t\tdev_hold(dev);\n\t}\n\nout:\n\treturn intrfc;\n}\n\nstatic int ipxitf_ioctl(unsigned int cmd, void __user *arg)\n{\n\tint rc = -EINVAL;\n\tstruct ifreq ifr;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SIOCSIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface_definition f;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\trc = -EINVAL;\n\t\tif (sipx->sipx_family != AF_IPX)\n\t\t\tbreak;\n\t\tf.ipx_network = sipx->sipx_network;\n\t\tmemcpy(f.ipx_device, ifr.ifr_name,\n\t\t\tsizeof(f.ipx_device));\n\t\tmemcpy(f.ipx_node, sipx->sipx_node, IPX_NODE_LEN);\n\t\tf.ipx_dlink_type = sipx->sipx_type;\n\t\tf.ipx_special = sipx->sipx_special;\n\n\t\tif (sipx->sipx_action == IPX_DLTITF)\n\t\t\trc = ipxitf_delete(&f);\n\t\telse\n\t\t\trc = ipxitf_create(&f);\n\t\tbreak;\n\t}\n\tcase SIOCGIFADDR: {\n\t\tstruct sockaddr_ipx *sipx;\n\t\tstruct ipx_interface *ipxif;\n\t\tstruct net_device *dev;\n\n\t\trc = -EFAULT;\n\t\tif (copy_from_user(&ifr, arg, sizeof(ifr)))\n\t\t\tbreak;\n\t\tsipx = (struct sockaddr_ipx *)&ifr.ifr_addr;\n\t\tdev  = __dev_get_by_name(&init_net, ifr.ifr_name);\n\t\trc   = -ENODEV;\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tipxif = ipxitf_find_using_phys(dev,\n\t\t\t\t\t   ipx_map_frame_type(sipx->sipx_type));\n\t\trc = -EADDRNOTAVAIL;\n\t\tif (!ipxif)\n\t\t\tbreak;\n\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_network\t= ipxif->if_netnum;\n\t\tmemcpy(sipx->sipx_node, ipxif->if_node,\n\t\t\tsizeof(sipx->sipx_node));\n\t\trc = 0;\n\t\tif (copy_to_user(arg, &ifr, sizeof(ifr)))\n\t\t\trc = -EFAULT;\n\t\tipxitf_put(ipxif);\n\t\tbreak;\n\t}\n\tcase SIOCAIPXITFCRT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_auto_create_interfaces = val;\n\t\tbreak;\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EFAULT;\n\t\tif (get_user(val, (unsigned char __user *) arg))\n\t\t\tbreak;\n\t\trc = 0;\n\t\tipxcfg_set_auto_select(val);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\n/*\n *\tChecksum routine for IPX\n */\n\n/* Note: We assume ipx_tctrl==0 and htons(length)==ipx_pktsize */\n/* This functions should *not* mess with packet contents */\n\n__be16 ipx_cksum(struct ipxhdr *packet, int length)\n{\n\t/*\n\t *\tNOTE: sum is a net byte order quantity, which optimizes the\n\t *\tloop. This only works on big and little endian machines. (I\n\t *\tdon't know of a machine that isn't.)\n\t */\n\t/* handle the first 3 words separately; checksum should be skipped\n\t * and ipx_tctrl masked out */\n\t__u16 *p = (__u16 *)packet;\n\t__u32 sum = p[1] + (p[2] & (__force u16)htons(0x00ff));\n\t__u32 i = (length >> 1) - 3; /* Number of remaining complete words */\n\n\t/* Loop through them */\n\tp += 3;\n\twhile (i--)\n\t\tsum += *p++;\n\n\t/* Add on the last part word if it exists */\n\tif (packet->ipx_pktsize & htons(1))\n\t\tsum += (__force u16)htons(0xff00) & *p;\n\n\t/* Do final fixup */\n\tsum = (sum & 0xffff) + (sum >> 16);\n\n\t/* It's a pity there's no concept of carry in C */\n\tif (sum >= 0x10000)\n\t\tsum++;\n\n\t/*\n\t * Leave 0 alone; we don't want 0xffff here.  Note that we can't get\n\t * here with 0x10000, so this check is the same as ((__u16)sum)\n\t */\n\tif (sum)\n\t\tsum = ~sum;\n\n\treturn (__force __be16)sum;\n}\n\nconst char *ipx_frame_name(__be16 frame)\n{\n\tchar* rc = \"None\";\n\n\tswitch (ntohs(frame)) {\n\tcase ETH_P_IPX:\t\trc = \"EtherII\";\tbreak;\n\tcase ETH_P_802_2:\trc = \"802.2\";\tbreak;\n\tcase ETH_P_SNAP:\trc = \"SNAP\";\tbreak;\n\tcase ETH_P_802_3:\trc = \"802.3\";\tbreak;\n\t}\n\n\treturn rc;\n}\n\nconst char *ipx_device_name(struct ipx_interface *intrfc)\n{\n\treturn intrfc->if_internal ? \"Internal\" :\n\t\tintrfc->if_dev ? intrfc->if_dev->name : \"Unknown\";\n}\n\n/* Handling for system calls applied via the various interfaces to an IPX\n * socket object. */\n\nstatic int ipx_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t  char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint opt;\n\tint rc = -EINVAL;\n\n\tlock_sock(sk);\n\tif (optlen != sizeof(int))\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (get_user(opt, (unsigned int __user *)optval))\n\t\tgoto out;\n\n\trc = -ENOPROTOOPT;\n\tif (!(level == SOL_IPX && optname == IPX_TYPE))\n\t\tgoto out;\n\n\tipx_sk(sk)->type = opt;\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int ipx_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint val = 0;\n\tint len;\n\tint rc = -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\tif (!(level == SOL_IPX && optname == IPX_TYPE))\n\t\tgoto out;\n\n\tval = ipx_sk(sk)->type;\n\n\trc = -EFAULT;\n\tif (get_user(len, optlen))\n\t\tgoto out;\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\trc = -EINVAL;\n\tif(len < 0)\n\t\tgoto out;\n\n\trc = -EFAULT;\n\tif (put_user(len, optlen) || copy_to_user(optval, &val, len))\n\t\tgoto out;\n\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic struct proto ipx_proto = {\n\t.name\t  = \"IPX\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct ipx_sock),\n};\n\nstatic int ipx_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tint rc = -ESOCKTNOSUPPORT;\n\tstruct sock *sk;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * SPX support is not anymore in the kernel sources. If you want to\n\t * ressurrect it, completing it and making it understand shared skbs,\n\t * be fully multithreaded, etc, grab the sources in an early 2.5 kernel\n\t * tree.\n\t */\n\tif (sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IPX, GFP_KERNEL, &ipx_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsk_refcnt_debug_inc(sk);\n\tsock_init_data(sock, sk);\n\tsk->sk_no_check_tx = 1;\t\t/* Checksum off by default */\n\tsock->ops = &ipx_dgram_ops;\n\trc = 0;\nout:\n\treturn rc;\n}\n\nstatic int ipx_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (!sk)\n\t\tgoto out;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_state_change(sk);\n\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock->sk = NULL;\n\tsk_refcnt_debug_release(sk);\n\tipx_destroy_socket(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\nout:\n\treturn 0;\n}\n\n/* caller must hold a reference to intrfc */\n\nstatic __be16 ipx_first_free_socketnum(struct ipx_interface *intrfc)\n{\n\tunsigned short socketNum = intrfc->if_sknum;\n\n\tspin_lock_bh(&intrfc->if_sklist_lock);\n\n\tif (socketNum < IPX_MIN_EPHEMERAL_SOCKET)\n\t\tsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\n\n\twhile (__ipxitf_find_socket(intrfc, htons(socketNum)))\n\t\tif (socketNum > IPX_MAX_EPHEMERAL_SOCKET)\n\t\t\tsocketNum = IPX_MIN_EPHEMERAL_SOCKET;\n\t\telse\n\t\t\tsocketNum++;\n\n\tspin_unlock_bh(&intrfc->if_sklist_lock);\n\tintrfc->if_sknum = socketNum;\n\n\treturn htons(socketNum);\n}\n\nstatic int __ipx_bind(struct socket *sock,\n\t\t\tstruct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct ipx_interface *intrfc;\n\tstruct sockaddr_ipx *addr = (struct sockaddr_ipx *)uaddr;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED) || addr_len != sizeof(struct sockaddr_ipx))\n\t\tgoto out;\n\n\tintrfc = ipxitf_find_using_net(addr->sipx_network);\n\trc = -EADDRNOTAVAIL;\n\tif (!intrfc)\n\t\tgoto out;\n\n\tif (!addr->sipx_port) {\n\t\taddr->sipx_port = ipx_first_free_socketnum(intrfc);\n\t\trc = -EINVAL;\n\t\tif (!addr->sipx_port)\n\t\t\tgoto out_put;\n\t}\n\n\t/* protect IPX system stuff like routing/sap */\n\trc = -EACCES;\n\tif (ntohs(addr->sipx_port) < IPX_MIN_EPHEMERAL_SOCKET &&\n\t    !capable(CAP_NET_ADMIN))\n\t\tgoto out_put;\n\n\tipxs->port = addr->sipx_port;\n\n#ifdef CONFIG_IPX_INTERN\n\tif (intrfc == ipx_internal_net) {\n\t\t/* The source address is to be set explicitly if the\n\t\t * socket is to be bound on the internal network. If a\n\t\t * node number 0 was specified, the default is used.\n\t\t */\n\n\t\trc = -EINVAL;\n\t\tif (!memcmp(addr->sipx_node, ipx_broadcast_node, IPX_NODE_LEN))\n\t\t\tgoto out_put;\n\t\tif (!memcmp(addr->sipx_node, ipx_this_node, IPX_NODE_LEN))\n\t\t\tmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\n\t\telse\n\t\t\tmemcpy(ipxs->node, addr->sipx_node, IPX_NODE_LEN);\n\n\t\trc = -EADDRINUSE;\n\t\tif (ipxitf_find_internal_socket(intrfc, ipxs->node,\n\t\t\t\t\t\tipxs->port)) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs(addr->sipx_port));\n\t\t\tgoto out_put;\n\t\t}\n\t} else {\n\t\t/* Source addresses are easy. It must be our\n\t\t * network:node pair for an interface routed to IPX\n\t\t * with the ipx routing ioctl()\n\t\t */\n\n\t\tmemcpy(ipxs->node, intrfc->if_node, IPX_NODE_LEN);\n\n\t\trc = -EADDRINUSE;\n\t\tif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\n\t\t\tSOCK_DEBUG(sk,\n\t\t\t\t\"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs(addr->sipx_port));\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\n#else\t/* !def CONFIG_IPX_INTERN */\n\n\t/* Source addresses are easy. It must be our network:node pair for\n\t   an interface routed to IPX with the ipx routing ioctl() */\n\n\trc = -EADDRINUSE;\n\tif (ipxitf_find_socket(intrfc, addr->sipx_port)) {\n\t\tSOCK_DEBUG(sk, \"IPX: bind failed because port %X in use.\\n\",\n\t\t\t\tntohs((int)addr->sipx_port));\n\t\tgoto out_put;\n\t}\n\n#endif\t/* CONFIG_IPX_INTERN */\n\n\tipxitf_insert_socket(intrfc, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\trc = 0;\nout_put:\n\tipxitf_put(intrfc);\nout:\n\treturn rc;\n}\n\nstatic int ipx_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tint rc;\n\n\tlock_sock(sk);\n\trc = __ipx_bind(sock, uaddr, addr_len);\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\nstatic int ipx_connect(struct socket *sock, struct sockaddr *uaddr,\n\tint addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tstruct sockaddr_ipx *addr;\n\tint rc = -EINVAL;\n\tstruct ipx_route *rt;\n\n\tsk->sk_state\t= TCP_CLOSE;\n\tsock->state \t= SS_UNCONNECTED;\n\n\tlock_sock(sk);\n\tif (addr_len != sizeof(*addr))\n\t\tgoto out;\n\taddr = (struct sockaddr_ipx *)uaddr;\n\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\n\t\t\tIPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\t/* We can either connect to primary network or somewhere\n\t * we can route to */\n\trt = ipxrtr_lookup(addr->sipx_network);\n\trc = -ENETUNREACH;\n\tif (!rt && !(!addr->sipx_network && ipx_primary_net))\n\t\tgoto out;\n\n\tipxs->dest_addr.net  = addr->sipx_network;\n\tipxs->dest_addr.sock = addr->sipx_port;\n\tmemcpy(ipxs->dest_addr.node, addr->sipx_node, IPX_NODE_LEN);\n\tipxs->type = addr->sipx_type;\n\n\tif (sock->type == SOCK_DGRAM) {\n\t\tsock->state \t= SS_CONNECTED;\n\t\tsk->sk_state \t= TCP_ESTABLISHED;\n\t}\n\n\tif (rt)\n\t\tipxrtr_put(rt);\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct ipx_address *addr;\n\tstruct sockaddr_ipx sipx;\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tint rc;\n\n\t*uaddr_len = sizeof(struct sockaddr_ipx);\n\n\tlock_sock(sk);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\taddr = &ipxs->dest_addr;\n\t\tsipx.sipx_network\t= addr->net;\n\t\tsipx.sipx_port\t\t= addr->sock;\n\t\tmemcpy(sipx.sipx_node, addr->node, IPX_NODE_LEN);\n\t} else {\n\t\tif (ipxs->intrfc) {\n\t\t\tsipx.sipx_network = ipxs->intrfc->if_netnum;\n#ifdef CONFIG_IPX_INTERN\n\t\t\tmemcpy(sipx.sipx_node, ipxs->node, IPX_NODE_LEN);\n#else\n\t\t\tmemcpy(sipx.sipx_node, ipxs->intrfc->if_node,\n\t\t\t\tIPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\t} else {\n\t\t\tsipx.sipx_network = 0;\n\t\t\tmemset(sipx.sipx_node, '\\0', IPX_NODE_LEN);\n\t\t}\n\n\t\tsipx.sipx_port = ipxs->port;\n\t}\n\n\tsipx.sipx_family = AF_IPX;\n\tsipx.sipx_type\t = ipxs->type;\n\tsipx.sipx_zero\t = 0;\n\tmemcpy(uaddr, &sipx, sizeof(sipx));\n\n\trc = 0;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\nstatic int ipx_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)\n{\n\t/* NULL here for pt means the packet was looped back */\n\tstruct ipx_interface *intrfc;\n\tstruct ipxhdr *ipx;\n\tu16 ipx_pktsize;\n\tint rc = 0;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Not ours */\n\tif (skb->pkt_type == PACKET_OTHERHOST)\n\t\tgoto drop;\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ipxhdr)))\n\t\tgoto drop;\n\n\tipx_pktsize = ntohs(ipx_hdr(skb)->ipx_pktsize);\n\n\t/* Too small or invalid header? */\n\tif (ipx_pktsize < sizeof(struct ipxhdr) ||\n\t    !pskb_may_pull(skb, ipx_pktsize))\n\t\tgoto drop;\n\n\tipx = ipx_hdr(skb);\n\tif (ipx->ipx_checksum != IPX_NO_CHECKSUM &&\n\t   ipx->ipx_checksum != ipx_cksum(ipx, ipx_pktsize))\n\t\tgoto drop;\n\n\tIPX_SKB_CB(skb)->ipx_tctrl\t= ipx->ipx_tctrl;\n\tIPX_SKB_CB(skb)->ipx_dest_net\t= ipx->ipx_dest.net;\n\tIPX_SKB_CB(skb)->ipx_source_net = ipx->ipx_source.net;\n\n\t/* Determine what local ipx endpoint this is */\n\tintrfc = ipxitf_find_using_phys(dev, pt->type);\n\tif (!intrfc) {\n\t\tif (ipxcfg_auto_create_interfaces &&\n\t\t   IPX_SKB_CB(skb)->ipx_dest_net) {\n\t\t\tintrfc = ipxitf_auto_create(dev, pt->type);\n\t\t\tif (intrfc)\n\t\t\t\tipxitf_hold(intrfc);\n\t\t}\n\n\t\tif (!intrfc)\t/* Not one of ours */\n\t\t\t\t/* or invalid packet for auto creation */\n\t\t\tgoto drop;\n\t}\n\n\trc = ipxitf_rcv(intrfc, skb);\n\tipxitf_put(intrfc);\n\tgoto out;\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn rc;\n}\n\nstatic int ipx_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ipx *, usipx, msg->msg_name);\n\tstruct sockaddr_ipx local_sipx;\n\tint rc = -EINVAL;\n\tint flags = msg->msg_flags;\n\n\tlock_sock(sk);\n\t/* Socket gets bound below anyway */\n/*\tif (sk->sk_zapped)\n\t\treturn -EIO; */\t/* Socket not bound */\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\n\t/* Max possible packet size limited by 16 bit pktsize in header */\n\tif (len >= 65535 - sizeof(struct ipxhdr))\n\t\tgoto out;\n\n\tif (usipx) {\n\t\tif (!ipxs->port) {\n\t\t\tstruct sockaddr_ipx uaddr;\n\n\t\t\tuaddr.sipx_port\t\t= 0;\n\t\t\tuaddr.sipx_network\t= 0;\n#ifdef CONFIG_IPX_INTERN\n\t\t\trc = -ENETDOWN;\n\t\t\tif (!ipxs->intrfc)\n\t\t\t\tgoto out; /* Someone zonked the iface */\n\t\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node,\n\t\t\t\tIPX_NODE_LEN);\n#endif\n\t\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t\t\tsizeof(struct sockaddr_ipx));\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\trc = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(*usipx) ||\n\t\t    usipx->sipx_family != AF_IPX)\n\t\t\tgoto out;\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\n\t\tusipx = &local_sipx;\n\t\tusipx->sipx_family \t= AF_IPX;\n\t\tusipx->sipx_type \t= ipxs->type;\n\t\tusipx->sipx_port \t= ipxs->dest_addr.sock;\n\t\tusipx->sipx_network \t= ipxs->dest_addr.net;\n\t\tmemcpy(usipx->sipx_node, ipxs->dest_addr.node, IPX_NODE_LEN);\n\t}\n\n\trc = ipxrtr_route_packet(sk, usipx, msg, len, flags & MSG_DONTWAIT);\n\tif (rc >= 0)\n\t\trc = len;\nout:\n\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t       int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct ipx_sock *ipxs = ipx_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_ipx *, sipx, msg->msg_name);\n\tstruct ipxhdr *ipx = NULL;\n\tstruct sk_buff *skb;\n\tint copied, rc;\n\tbool locked = true;\n\n\tlock_sock(sk);\n\t/* put the autobinding in */\n\tif (!ipxs->port) {\n\t\tstruct sockaddr_ipx uaddr;\n\n\t\tuaddr.sipx_port\t\t= 0;\n\t\tuaddr.sipx_network \t= 0;\n\n#ifdef CONFIG_IPX_INTERN\n\t\trc = -ENETDOWN;\n\t\tif (!ipxs->intrfc)\n\t\t\tgoto out; /* Someone zonked the iface */\n\t\tmemcpy(uaddr.sipx_node, ipxs->intrfc->if_node, IPX_NODE_LEN);\n#endif\t/* CONFIG_IPX_INTERN */\n\n\t\trc = __ipx_bind(sock, (struct sockaddr *)&uaddr,\n\t\t\t      sizeof(struct sockaddr_ipx));\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = -ENOTCONN;\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\n\trelease_sock(sk);\n\tlocked = false;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &rc);\n\tif (!skb) {\n\t\tif (rc == -EAGAIN && (sk->sk_shutdown & RCV_SHUTDOWN))\n\t\t\trc = 0;\n\t\tgoto out;\n\t}\n\n\tipx \t= ipx_hdr(skb);\n\tcopied \t= ntohs(ipx->ipx_pktsize) - sizeof(struct ipxhdr);\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\trc = skb_copy_datagram_msg(skb, sizeof(struct ipxhdr), msg, copied);\n\tif (rc)\n\t\tgoto out_free;\n\tif (skb->tstamp)\n\t\tsk->sk_stamp = skb->tstamp;\n\n\tif (sipx) {\n\t\tsipx->sipx_family\t= AF_IPX;\n\t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n\t\tmemcpy(sipx->sipx_node, ipx->ipx_source.node, IPX_NODE_LEN);\n\t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n\t\tsipx->sipx_type \t= ipx->ipx_type;\n\t\tsipx->sipx_zero\t\t= 0;\n\t\tmsg->msg_namelen\t= sizeof(*sipx);\n\t}\n\trc = copied;\n\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (locked)\n\t\trelease_sock(sk);\n\treturn rc;\n}\n\n\nstatic int ipx_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = 0;\n\tlong amount = 0;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\n\tlock_sock(sk);\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\t/* These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here */\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ipxhdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = ipxrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCSIFADDR:\n\tcase SIOCAIPXITFCRT:\n\tcase SIOCAIPXPRISLT:\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\tcase SIOCGIFADDR:\n\t\trc = ipxitf_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCIPXCFGDATA:\n\t\trc = ipxcfg_get_config_data(argp);\n\t\tbreak;\n\tcase SIOCIPXNCPCONN:\n\t\t/*\n\t\t * This socket wants to take care of the NCP connection\n\t\t * handed to us in arg.\n\t\t */\n\t\trc = -EPERM;\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\tbreak;\n\t\trc = get_user(ipx_sk(sk)->ipx_ncp_conn,\n\t\t\t      (const unsigned short __user *)argp);\n\t\tbreak;\n\tcase SIOCGSTAMP:\n\t\trc = sock_get_timestamp(sk, argp);\n\t\tbreak;\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\treturn rc;\n}\n\n\n#ifdef CONFIG_COMPAT\nstatic int ipx_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\t/*\n\t * These 4 commands use same structure on 32bit and 64bit.  Rest of IPX\n\t * commands is handled by generic ioctl code.  As these commands are\n\t * SIOCPROTOPRIVATE..SIOCPROTOPRIVATE+3, they cannot be handled by generic\n\t * code.\n\t */\n\tswitch (cmd) {\n\tcase SIOCAIPXITFCRT:\n\tcase SIOCAIPXPRISLT:\n\tcase SIOCIPXCFGDATA:\n\tcase SIOCIPXNCPCONN:\n\t\treturn ipx_ioctl(sock, cmd, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic int ipx_shutdown(struct socket *sock, int mode)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (mode < SHUT_RD || mode > SHUT_RDWR)\n\t\treturn -EINVAL;\n\t/* This maps:\n\t * SHUT_RD   (0) -> RCV_SHUTDOWN  (1)\n\t * SHUT_WR   (1) -> SEND_SHUTDOWN (2)\n\t * SHUT_RDWR (2) -> SHUTDOWN_MASK (3)\n\t */\n\t++mode;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown |= mode;\n\trelease_sock(sk);\n\tsk->sk_state_change(sk);\n\n\treturn 0;\n}\n\n/*\n * Socket family declarations\n */\n\nstatic const struct net_proto_family ipx_family_ops = {\n\t.family\t\t= PF_IPX,\n\t.create\t\t= ipx_create,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const struct proto_ops ipx_dgram_ops = {\n\t.family\t\t= PF_IPX,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= ipx_release,\n\t.bind\t\t= ipx_bind,\n\t.connect\t= ipx_connect,\n\t.socketpair\t= sock_no_socketpair,\n\t.accept\t\t= sock_no_accept,\n\t.getname\t= ipx_getname,\n\t.poll\t\t= datagram_poll,\n\t.ioctl\t\t= ipx_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ipx_compat_ioctl,\n#endif\n\t.listen\t\t= sock_no_listen,\n\t.shutdown\t= ipx_shutdown,\n\t.setsockopt\t= ipx_setsockopt,\n\t.getsockopt\t= ipx_getsockopt,\n\t.sendmsg\t= ipx_sendmsg,\n\t.recvmsg\t= ipx_recvmsg,\n\t.mmap\t\t= sock_no_mmap,\n\t.sendpage\t= sock_no_sendpage,\n};\n\nstatic struct packet_type ipx_8023_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_802_3),\n\t.func\t\t= ipx_rcv,\n};\n\nstatic struct packet_type ipx_dix_packet_type __read_mostly = {\n\t.type\t\t= cpu_to_be16(ETH_P_IPX),\n\t.func\t\t= ipx_rcv,\n};\n\nstatic struct notifier_block ipx_dev_notifier = {\n\t.notifier_call\t= ipxitf_device_event,\n};\n\nstatic const unsigned char ipx_8022_type = 0xE0;\nstatic const unsigned char ipx_snap_id[5] = { 0x0, 0x0, 0x0, 0x81, 0x37 };\nstatic const char ipx_EII_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with Ethernet II\\n\";\nstatic const char ipx_8023_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with 802.3\\n\";\nstatic const char ipx_llc_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with 802.2\\n\";\nstatic const char ipx_snap_err_msg[] __initconst =\n\tKERN_CRIT \"IPX: Unable to register with SNAP\\n\";\n\nstatic int __init ipx_init(void)\n{\n\tint rc = proto_register(&ipx_proto, 1);\n\n\tif (rc != 0)\n\t\tgoto out;\n\n\tsock_register(&ipx_family_ops);\n\n\tpEII_datalink = make_EII_client();\n\tif (pEII_datalink)\n\t\tdev_add_pack(&ipx_dix_packet_type);\n\telse\n\t\tprintk(ipx_EII_err_msg);\n\n\tp8023_datalink = make_8023_client();\n\tif (p8023_datalink)\n\t\tdev_add_pack(&ipx_8023_packet_type);\n\telse\n\t\tprintk(ipx_8023_err_msg);\n\n\tp8022_datalink = register_8022_client(ipx_8022_type, ipx_rcv);\n\tif (!p8022_datalink)\n\t\tprintk(ipx_llc_err_msg);\n\n\tpSNAP_datalink = register_snap_client(ipx_snap_id, ipx_rcv);\n\tif (!pSNAP_datalink)\n\t\tprintk(ipx_snap_err_msg);\n\n\tregister_netdevice_notifier(&ipx_dev_notifier);\n\tipx_register_sysctl();\n\tipx_proc_init();\nout:\n\treturn rc;\n}\n\nstatic void __exit ipx_proto_finito(void)\n{\n\tipx_proc_exit();\n\tipx_unregister_sysctl();\n\n\tunregister_netdevice_notifier(&ipx_dev_notifier);\n\n\tipxitf_cleanup();\n\n\tif (pSNAP_datalink) {\n\t\tunregister_snap_client(pSNAP_datalink);\n\t\tpSNAP_datalink = NULL;\n\t}\n\n\tif (p8022_datalink) {\n\t\tunregister_8022_client(p8022_datalink);\n\t\tp8022_datalink = NULL;\n\t}\n\n\tdev_remove_pack(&ipx_8023_packet_type);\n\tif (p8023_datalink) {\n\t\tdestroy_8023_client(p8023_datalink);\n\t\tp8023_datalink = NULL;\n\t}\n\n\tdev_remove_pack(&ipx_dix_packet_type);\n\tif (pEII_datalink) {\n\t\tdestroy_EII_client(pEII_datalink);\n\t\tpEII_datalink = NULL;\n\t}\n\n\tproto_unregister(&ipx_proto);\n\tsock_unregister(ipx_family_ops.family);\n}\n\nmodule_init(ipx_init);\nmodule_exit(ipx_proto_finito);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_IPX);\n"], "filenames": ["net/ipx/af_ipx.c"], "buggy_code_start_loc": [1171], "buggy_code_end_loc": [1176], "fixing_code_start_loc": [1171], "fixing_code_end_loc": [1174], "type": "CWE-416", "message": "The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface.", "other": {"cve": {"id": "CVE-2017-7487", "sourceIdentifier": "secalert@redhat.com", "published": "2017-05-14T22:29:00.163", "lastModified": "2023-02-14T21:37:47.413", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface."}, {"lang": "es", "value": "La funci\u00f3n ipxitf_ioctl en el archivo net/ipx/af_ipx.c en el kernel de Linux hasta la versi\u00f3n 4.11.1, maneja inapropiadamente conteos de referencias, lo que permite a los usuarios locales causar una denegaci\u00f3n de servicio (uso de memoria previamente liberada) o posiblemente tener otro impacto no especificado por medio de una llamada ioctl SIOCGIFADDR fallida para una interfaz de IPX."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.89", "matchCriteriaId": "9A5C1F01-214B-4477-A3A1-F6DF10181D3C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.44", "matchCriteriaId": "8C1901E2-6C4D-488B-A7CE-F7E14A38418F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.55", "matchCriteriaId": "92A95C1A-1941-4789-B2F3-687F85106E9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.1.41", "matchCriteriaId": "9019BEC9-FE77-4506-A019-B8B4D8BCEBAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.70", "matchCriteriaId": "6B6B892D-2153-4B26-A53A-2757488ABBCD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.30", "matchCriteriaId": "05FA3C9C-F982-4407-89BC-F8936979C1D4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.11.3", "matchCriteriaId": "24D5182D-708B-4C85-9FFA-591A649330A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=ee0d8d8482345ff97a75a7d747efc309f13b0d80", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.debian.org/security/2017/dsa-3886", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98439", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1039237", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1447734", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "https://patchwork.ozlabs.org/patch/757549/", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://source.android.com/security/bulletin/2017-09-01", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80"}}