{"buggy_code": ["\"\"\"Admin API.\"\"\"\n\nfrom django import http\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext as _\n\nfrom django_filters import rest_framework as dj_filters\nfrom drf_spectacular.utils import extend_schema, extend_schema_view\nfrom rest_framework import filters, renderers, status, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.permissions import DjangoModelPermissions, IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom modoboa.core import models as core_models\nfrom modoboa.core import sms_backends\nfrom modoboa.lib import renderers as lib_renderers\nfrom modoboa.lib import viewsets as lib_viewsets\nfrom modoboa.lib.throttle import GetThrottleViewsetMixin, PasswordResetRequestThrottle\n\nfrom ... import lib, models\nfrom . import serializers\n\n\n@extend_schema_view(\n    retrieve=extend_schema(\n        description=\"Retrieve a particular domain\",\n        summary=\"Retrieve a particular domain\"\n    ),\n    list=extend_schema(\n        description=\"Retrieve a list of domains\",\n        summary=\"Retrieve a list of domains\"\n    ),\n    create=extend_schema(\n        description=\"Create a new domain\",\n        summary=\"Create a new domain\"\n    )\n)\nclass DomainViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"Domain viewset.\"\"\"\n\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.DomainSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        return models.Domain.objects.get_for_admin(self.request.user)\n\n    def perform_destroy(self, instance):\n        \"\"\"Add custom args to delete call.\"\"\"\n        instance.delete(self.request.user)\n\n\nclass DomainAliasFilterSet(dj_filters.FilterSet):\n    \"\"\"Custom FilterSet for DomainAlias.\"\"\"\n\n    domain = dj_filters.CharFilter(field_name=\"target__name\")\n\n    class Meta:\n        model = models.DomainAlias\n        fields = [\"domain\"]\n\n\nclass DomainAliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,\n                         viewsets.ModelViewSet):\n    \"\"\"ViewSet for DomainAlias.\"\"\"\n\n    filter_backends = (dj_filters.DjangoFilterBackend, )\n    filterset_class = DomainAliasFilterSet\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    renderer_classes = (renderers.JSONRenderer, lib_renderers.CSVRenderer)\n    serializer_class = serializers.DomainAliasSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        return models.DomainAlias.objects.get_for_admin(self.request.user)\n\n    def get_renderer_context(self):\n        context = super().get_renderer_context()\n        context[\"headers\"] = [\"name\", \"target__name\", \"enabled\"]\n        return context\n\n\nclass AccountViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"ViewSet for User/Mailbox.\"\"\"\n\n    filter_backends = (filters.SearchFilter, )\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    search_fields = (\"^first_name\", \"^last_name\", \"^email\")\n\n    def get_throttles(self):\n\n        throttles = super().get_throttles()\n        if self.action == \"reset_password\":\n            throttles.append(PasswordResetRequestThrottle())\n        \n        return throttles\n\n    def get_serializer_class(self):\n        \"\"\"Return a serializer.\"\"\"\n        action_dict = {\n            \"list\": serializers.AccountSerializer,\n            \"retrieve\": serializers.AccountSerializer,\n            \"password\": serializers.AccountPasswordSerializer,\n            \"reset_password\": serializers.ResetPasswordSerializer,\n        }\n        return action_dict.get(\n            self.action, serializers.WritableAccountSerializer)\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        ids = user.objectaccess_set \\\n            .filter(content_type=ContentType.objects.get_for_model(user)) \\\n            .values_list(\"object_id\", flat=True)\n        queryset = core_models.User.objects.filter(pk__in=ids)\n        domain = self.request.query_params.get(\"domain\")\n        if domain:\n            queryset = queryset.filter(mailbox__domain__name=domain)\n        return queryset\n\n    @action(methods=[\"put\"], detail=True)\n    def password(self, request, pk=None):\n        \"\"\"Change account password.\"\"\"\n        try:\n            user = core_models.User.objects.get(pk=pk)\n        except core_models.User.DoesNotExist:\n            raise http.Http404\n        serializer = self.get_serializer(user, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response()\n        return Response(\n            serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    @action(detail=False)\n    def exists(self, request):\n        \"\"\"Check if account exists.\n\n        Requires a valid email address as argument. Example:\n\n        GET /exists/?email=user@test.com\n\n        \"\"\"\n        email = request.GET.get(\"email\")\n        if not email:\n            raise ParseError(\"email not provided\")\n        if not core_models.User.objects.filter(email=email).exists():\n            data = {\"exists\": False}\n        else:\n            data = {\"exists\": True}\n        serializer = serializers.AccountExistsSerializer(data)\n        return Response(serializer.data)\n\n    @action(methods=[\"post\"], detail=False)\n    def reset_password(self, request):\n        \"\"\"Reset account password and send a new one by SMS.\"\"\"\n        sms_password_recovery = (\n            request.localconfig.parameters\n            .get_value(\"sms_password_recovery\", app=\"core\")\n        )\n        if not sms_password_recovery:\n            return Response(status=404)\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = core_models.User.objects.filter(\n            email=serializer.validated_data[\"email\"]).first()\n        if not user or not user.phone_number:\n            return Response(status=404)\n        backend = sms_backends.get_active_backend(\n            request.localconfig.parameters)\n        if not backend:\n            return Response(status=404)\n        password = lib.make_password()\n        content = _(\"Here is your new Modoboa password: {}\").format(\n            password)\n        if not backend.send(content, [str(user.phone_number)]):\n            body = {\"status\": \"ko\"}\n        else:\n            # SMS was sent, now we can set the new password.\n            body = {\"status\": \"ok\"}\n            user.set_password(password)\n            user.save(update_fields=[\"password\"])\n        return Response(body)\n\n\nclass AliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"\n    create:\n    Create a new alias instance.\n    \"\"\"\n\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.AliasSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        ids = (\n            user.objectaccess_set.filter(\n                content_type=ContentType.objects.get_for_model(models.Alias))\n            .values_list(\"object_id\", flat=True)\n        )\n        queryset = models.Alias.objects.filter(pk__in=ids)\n        domain = self.request.query_params.get(\"domain\")\n        if domain:\n            queryset = queryset.filter(domain__name=domain)\n        return queryset\n\n\nclass SenderAddressFilterSet(dj_filters.FilterSet):\n    \"\"\"Custom FilterSet for SenderAddress.\"\"\"\n\n    class Meta:\n        model = models.SenderAddress\n        fields = [\"mailbox\"]\n\n\nclass SenderAddressViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,\n                           viewsets.ModelViewSet):\n    \"\"\"View set for SenderAddress model.\"\"\"\n\n    filter_backends = (dj_filters.DjangoFilterBackend, )\n    filterset_class = SenderAddressFilterSet\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.SenderAddressSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        mb_ids = (\n            user.objectaccess_set.filter(\n                content_type=ContentType.objects.get_for_model(models.Mailbox))\n            .values_list(\"object_id\", flat=True)\n        )\n        return models.SenderAddress.objects.filter(mailbox__pk__in=mb_ids)\n", "\"\"\"Core API v2 views.\"\"\"\n\nimport logging\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\nfrom django.utils.datastructures import MultiValueDictKeyError\n\nfrom django.contrib.auth import login\n\nfrom drf_spectacular.utils import extend_schema\nfrom rest_framework import response, status\nfrom rest_framework.exceptions import AuthenticationFailed\nfrom rest_framework_simplejwt import views as jwt_views\nfrom rest_framework_simplejwt.exceptions import InvalidToken\nfrom rest_framework.views import APIView\n\nfrom modoboa.core.password_hashers import get_password_hasher\nfrom modoboa.core.utils import check_for_updates\nfrom modoboa.lib.throttle import UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle, PasswordResetRequestThrottle, PasswordResetTotpThrottle\nfrom modoboa.parameters import tools as param_tools\n\nfrom smtplib import SMTPException\n\nfrom . import serializers\n\nlogger = logging.getLogger(\"modoboa.auth\")\n\n\ndef delete_cache_key(class_target, throttles, request):\n    \"\"\"Attempt to delete cache key from throttling on login/password reset success.\"\"\"\n\n    for throttle in throttles:\n        if type(throttle) == class_target:\n            throttle.reset_cache(request)\n            return\n\n\nclass TokenObtainPairView(jwt_views.TokenObtainPairView):\n    \"\"\"We overwrite this view to deal with password scheme update.\"\"\"\n\n    throttle_classes = [LoginThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        try:\n            serializer.is_valid(raise_exception=True)\n        except AuthenticationFailed as e:\n            logger.warning(\n                _(\"Failed connection attempt from '%s' as user '%s'\"),\n                request.META[\"REMOTE_ADDR\"],\n                escape(serializer.initial_data[\"username\"])\n            )\n            raise InvalidToken(e.args[0])\n\n        user = serializer.user\n        login(request, user)\n\n        # Reset login throttle\n        delete_cache_key(LoginThrottle, self.get_throttles(), request)\n\n        logger.info(\n            _(\"User '%s' successfully logged in\"), user.username\n        )\n        if user and user.is_active:\n            condition = (\n                user.is_local and\n                param_tools.get_global_parameter(\n                    \"update_scheme\", raise_exception=False)\n            )\n            if condition:\n                # check if password scheme is correct\n                scheme = param_tools.get_global_parameter(\n                    \"password_scheme\", raise_exception=False)\n                # use SHA512CRYPT as default fallback\n                if scheme is None:\n                    pwhash = get_password_hasher(\"sha512crypt\")()\n                else:\n                    pwhash = get_password_hasher(scheme)()\n                if not user.password.startswith(pwhash.scheme):\n                    logger.info(\n                        _(\"Password scheme mismatch. Updating %s password\"),\n                        user.username\n                    )\n                    user.set_password(request.data[\"password\"])\n                    user.save()\n                if pwhash.needs_rehash(user.password):\n                    logger.info(\n                        _(\"Password hash parameter missmatch. \"\n                          \"Updating %s password\"),\n                        user.username\n                    )\n                    user.set_password(serializer.data[\"password\"])\n                    user.save()\n\n        return response.Response(\n            serializer.validated_data, status=status.HTTP_200_OK)\n\n\nclass EmailPasswordResetView(APIView):\n    \"\"\"\n    An Api View which provides a method to request a password reset token based on an e-mail address.\n    \"\"\"\n\n    throttle_classes = [PasswordResetRequestThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = serializers.PasswordRecoveryEmailSerializer(\n            data=request.data, context={'request': request})\n        serializer.is_valid(raise_exception=True)\n        try:\n            serializer.save()\n        except SMTPException:\n            return response.Response({\n                \"type\": \"email\",\n                \"reason\": \"Error while sending the email. Please contact an administrator.\"\n            }, 503)\n\n        # Email response\n        return response.Response({\"type\": \"email\"}, 200)\n\n\nclass DefaultPasswordResetView(EmailPasswordResetView):\n    \"\"\"\n    Works with PasswordRecoveryForm.vue.\n    First checks if SMS recovery is available, else switch to super (Email recovery [with secondary email]).\n    \"\"\"\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"Recover password.\"\"\"\n        serializer = serializers.PasswordRecoverySmsSerializer(\n            data=request.data, context={'request': request})\n        try:\n            serializer.is_valid(raise_exception=True)\n        except serializers.NoSMSAvailable:\n            return super().post(request, *args, **kwargs)\n\n        # SMS response\n        return response.Response({\"type\": \"sms\"}, 200)\n\n\nclass PasswordResetSmsTOTP(APIView):\n    \"\"\" Check SMS Totp code. \"\"\"\n\n    throttle_classes = [PasswordResetTotpThrottle]\n\n    def post(self, request, *args, **kwargs):\n        try:\n            if request.data[\"type\"] == \"confirm\":\n                klass = serializers.PasswordRecoverySmsConfirmSerializer\n            elif request.data[\"type\"] == \"resend\":\n                klass = serializers.PasswordRecoverySmsResendSerializer\n            serializer = klass(data=request.data, context={'request': request})\n        except (MultiValueDictKeyError, KeyError):\n            return response.Response({\"reason\": \"No type provided.\"}, 400)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        payload = {\"type\": \"resend\"}\n        if request.data[\"type\"] == \"confirm\":\n            serializer_response = serializer.context[\"response\"]\n            payload.update({\n                \"token\": serializer_response[0],\n                \"id\": serializer_response[1],\n                \"type\": \"confirm\"\n            })\n        delete_cache_key(PasswordResetTotpThrottle, self.get_throttles(), request)\n        return response.Response(payload, 200)\n\n\nclass PasswordResetConfirmView(APIView):\n    \"\"\" Get and set new user password. \"\"\"\n\n    throttle_classes = [PasswordResetApplyThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = serializers.PasswordRecoveryConfirmSerializer(\n            data=request.data)\n        try:\n            serializer.is_valid(raise_exception=True)\n        except serializers.PasswordRequirementsFailure as e:\n            data = {\"type\": \"password_requirement\"}\n            errors = []\n            for element in e.message_list:\n                errors.append(element)\n            data.update({\"errors\": errors})\n            return response.Response(data, 400)\n        serializer.save()\n        delete_cache_key(PasswordResetApplyThrottle, self.get_throttles(), request)\n        return response.Response(status=200)\n\n\nclass ComponentsInformationAPIView(APIView):\n    \"\"\"Retrieve information about installed components.\"\"\"\n\n    throttle_classes = [UserLesserDdosUser]\n\n    @extend_schema(responses=serializers.ModoboaComponentSerializer(many=True))\n    def get(self, request, *args, **kwargs):\n        status, extensions = check_for_updates()\n        serializer = serializers.ModoboaComponentSerializer(\n            extensions, many=True\n        )\n        return response.Response(serializer.data)\n", "\"\"\"Object level permissions.\"\"\"\n\nfrom django.contrib.auth.models import Group, Permission\nfrom django.contrib.contenttypes.models import ContentType\n\nfrom modoboa.core import constants as core_constants, signals as core_signals\nfrom modoboa.core.models import ObjectAccess, User\n\n\ndef get_account_roles(user, account=None):\n    \"\"\"Return the list of available account roles.\n\n    This function is used to create or modify an account.\n\n    :param ``User`` user: connected user\n    :param ``User`` account: account beeing modified (None on creation)\n    :return: list of strings\n    \"\"\"\n    result = [core_constants.SIMPLEUSERS_ROLE]\n    filters = core_signals.user_can_set_role.send(\n        sender=\"get_account_roles\", user=user, role=\"DomainAdmins\",\n        account=account)\n    condition = (\n        user.has_perm(\"admin.add_domain\") and\n        (not filters or True in [flt[1] for flt in filters]))\n    if condition:\n        result += [core_constants.DOMAINADMINS_ROLE]\n    if user.is_superuser:\n        result += [\n            core_constants.RESELLERS_ROLE, core_constants.SUPERADMINS_ROLE]\n    return sorted(result, key=lambda role: role[1])\n\n\ndef grant_access_to_object(user, obj, is_owner=False):\n    \"\"\"Grant access to an object for a given user\n\n    There are two different cases where we want to grant access to an\n    object for a specific user:\n\n    * He is the owner (he's just created the object)\n    * He is going to administrate the object (but he is not the owner)\n\n    If the user is the owner, we also grant access to this object to\n    all super users.\n\n    :param user: a ``User`` object\n    :param obj: an admin. object (Domain, Mailbox, ...)\n    :param is_owner: the user is the unique object's owner\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    entry, created = ObjectAccess.objects.get_or_create(\n        user=user, content_type=ct, object_id=obj.id)\n    entry.is_owner = is_owner\n    entry.save()\n    if not created or not is_owner:\n        return\n    for su in User.objects.filter(is_superuser=True):\n        if su == user:\n            continue\n        ObjectAccess.objects.get_or_create(\n            user=su, content_type=ct, object_id=obj.id\n        )\n\n\ndef grant_access_to_objects(user, objects, ct):\n    \"\"\"Grant access to a collection of objects\n\n    All objects in the collection must share the same type (ie. ``ct``\n    applies to all objects).\n\n    :param user: a ``User`` object\n    :param objects: a list of objects\n    :param ct: the content type\n    \"\"\"\n    for obj in objects:\n        ObjectAccess.objects.get_or_create(\n            user=user, content_type=ct, object_id=obj.id)\n\n\ndef ungrant_access_to_object(obj, user=None):\n    \"\"\"Ungrant access to an object for a specific user\n\n    If no user is provided, all entries referencing this object are\n    deleted from the database.\n\n    If a user is provided, we only remove his access. If it was the\n    owner, we give the ownership to the first super admin we find.\n\n    :param obj: an object inheriting from ``models.Model``\n    :param user: a ``User`` object\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    if user is not None:\n        try:\n            ObjectAccess.objects.get(\n                user=user, content_type=ct, object_id=obj.id\n            ).delete()\n        except ObjectAccess.DoesNotExist:\n            pass\n        try:\n            ObjectAccess.objects.get(\n                content_type=ct, object_id=obj.id, is_owner=True\n            )\n        except ObjectAccess.DoesNotExist:\n            grant_access_to_object(\n                User.objects.filter(is_superuser=True)[0], obj, True\n            )\n    else:\n        ObjectAccess.objects.filter(\n            content_type=ct, object_id=obj.id\n        ).delete()\n\n\ndef ungrant_access_to_objects(objects):\n    \"\"\"Cancel all accesses for a given object list.\n\n    :param objects: a list of objects inheriting from ``models.Model``\n    \"\"\"\n    for obj in objects:\n        ct = ContentType.objects.get_for_model(obj)\n        ObjectAccess.objects.filter(content_type=ct, object_id=obj.id).delete()\n\n\ndef get_object_owner(obj):\n    \"\"\"Return the unique owner of this object\n\n    :param obj: an object inheriting from ``model.Model``\n    :return: a ``User`` object\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    try:\n        entry = ObjectAccess.objects.get(\n            content_type=ct, object_id=obj.id, is_owner=True\n        )\n    except ObjectAccess.DoesNotExist:\n        return None\n    return entry.user\n\n\ndef add_permissions_to_group(group, permissions):\n    \"\"\"Add the specified permissions to a django group.\"\"\"\n    if isinstance(group, str):\n        group = Group.objects.get(name=group)\n\n    for appname, modelname, permname in permissions:\n        ct = ContentType.objects.get_by_natural_key(appname, modelname)\n        if group.permissions.filter(\n                content_type=ct, codename=permname).exists():\n            continue\n        group.permissions.add(\n            Permission.objects.get(content_type=ct, codename=permname)\n        )\n", "\"\"\"Parameters viewsets.\"\"\"\n\nfrom drf_spectacular.utils import extend_schema, OpenApiParameter\nfrom rest_framework import response, viewsets\nfrom rest_framework.decorators import action\n\nfrom modoboa.lib.throttle import GetThrottleViewsetMixin\n\nfrom . import serializers\nfrom ... import tools\n\n\nclass ParametersViewSet(GetThrottleViewsetMixin, viewsets.ViewSet):\n    \"\"\"Parameter viewset.\"\"\"\n\n    lookup_value_regex = r\"\\w+\"\n    serializer_class = None\n\n    @extend_schema(responses=serializers.ApplicationSerializer(many=True))\n    @action(methods=[\"get\"], detail=False)\n    def applications(self, request):\n        \"\"\"Return the list of registered applications.\"\"\"\n        applications = tools.registry.get_applications(\"global\")\n        return response.Response(applications)\n\n    @extend_schema(responses=serializers.ParameterSerializer(many=True))\n    @action(methods=[\"get\"], detail=False)\n    def structure(self, request):\n        \"\"\"Return parameter schema.\"\"\"\n        app = request.GET.get(\"app\")\n        data = tools.registry.get_structure(\"global\", app)\n        return response.Response(data)\n\n    @extend_schema(\n        parameters=[\n            OpenApiParameter(\n                name='id', location=OpenApiParameter.PATH,\n                description='A registered application name',\n                type=str, required=True\n            ),\n        ],\n        responses=serializers.AppParametersSerializer\n    )\n    def retrieve(self, request, pk: str):\n        \"\"\"Return all parameters for given app.\"\"\"\n        parameters = request.localconfig.parameters.get_values_dict(pk)\n        serializer = tools.registry.get_serializer_class(\"global\", pk)(\n            parameters)\n        result = serializers.AppParametersSerializer({\n            \"label\": tools.registry.get_label(\"global\", pk),\n            \"params\": serializer.data\n        })\n        return response.Response(result.data)\n\n    @extend_schema(\n        parameters=[\n            OpenApiParameter(\n                name='id', location=OpenApiParameter.PATH,\n                description='A registered application name',\n                type=str, required=True\n            ),\n        ]\n    )\n    def update(self, request, pk: str):\n        \"\"\"Save parameters for given app.\"\"\"\n        serializer = tools.registry.get_serializer_class(\"global\", pk)(\n            data=request.data)\n        serializer.is_valid(raise_exception=True)\n        request.localconfig.parameters.set_values(\n            serializer.validated_data, app=pk)\n        request.localconfig.save(update_fields=[\"_parameters\"])\n        return response.Response()\n"], "fixing_code": ["\"\"\"Admin API.\"\"\"\n\nfrom django import http\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.utils.translation import ugettext as _\n\nfrom django_filters import rest_framework as dj_filters\nfrom drf_spectacular.utils import extend_schema, extend_schema_view\nfrom rest_framework import filters, renderers, status, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.exceptions import ParseError\nfrom rest_framework.permissions import DjangoModelPermissions, IsAuthenticated\nfrom rest_framework.response import Response\n\nfrom modoboa.core import models as core_models\nfrom modoboa.core import sms_backends\nfrom modoboa.lib import renderers as lib_renderers\nfrom modoboa.lib import viewsets as lib_viewsets\nfrom modoboa.lib.throttle import GetThrottleViewsetMixin, PasswordResetRequestThrottle\n\nfrom ... import lib, models\nfrom . import serializers\n\n\n@extend_schema_view(\n    retrieve=extend_schema(\n        description=\"Retrieve a particular domain\",\n        summary=\"Retrieve a particular domain\"\n    ),\n    list=extend_schema(\n        description=\"Retrieve a list of domains\",\n        summary=\"Retrieve a list of domains\"\n    ),\n    create=extend_schema(\n        description=\"Create a new domain\",\n        summary=\"Create a new domain\"\n    )\n)\nclass DomainViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"Domain viewset.\"\"\"\n\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.DomainSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        return models.Domain.objects.get_for_admin(self.request.user)\n\n    def perform_destroy(self, instance):\n        \"\"\"Add custom args to delete call.\"\"\"\n        instance.delete(self.request.user)\n\n\nclass DomainAliasFilterSet(dj_filters.FilterSet):\n    \"\"\"Custom FilterSet for DomainAlias.\"\"\"\n\n    domain = dj_filters.CharFilter(field_name=\"target__name\")\n\n    class Meta:\n        model = models.DomainAlias\n        fields = [\"domain\"]\n\n\nclass DomainAliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,\n                         viewsets.ModelViewSet):\n    \"\"\"ViewSet for DomainAlias.\"\"\"\n\n    filter_backends = (dj_filters.DjangoFilterBackend, )\n    filterset_class = DomainAliasFilterSet\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    renderer_classes = (renderers.JSONRenderer, lib_renderers.CSVRenderer)\n    serializer_class = serializers.DomainAliasSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        return models.DomainAlias.objects.get_for_admin(self.request.user)\n\n    def get_renderer_context(self):\n        context = super().get_renderer_context()\n        context[\"headers\"] = [\"name\", \"target__name\", \"enabled\"]\n        return context\n\n\nclass AccountViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"ViewSet for User/Mailbox.\"\"\"\n\n    filter_backends = (filters.SearchFilter, )\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    search_fields = (\"^first_name\", \"^last_name\", \"^email\")\n\n    def get_throttles(self):\n\n        throttles = super().get_throttles()\n        if self.action == \"reset_password\":\n            throttles.append(PasswordResetRequestThrottle())\n        return throttles\n\n    def get_serializer_class(self):\n        \"\"\"Return a serializer.\"\"\"\n        action_dict = {\n            \"list\": serializers.AccountSerializer,\n            \"retrieve\": serializers.AccountSerializer,\n            \"password\": serializers.AccountPasswordSerializer,\n            \"reset_password\": serializers.ResetPasswordSerializer,\n        }\n        return action_dict.get(\n            self.action, serializers.WritableAccountSerializer)\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        ids = user.objectaccess_set \\\n            .filter(content_type=ContentType.objects.get_for_model(user)) \\\n            .values_list(\"object_id\", flat=True)\n        queryset = core_models.User.objects.filter(pk__in=ids)\n        domain = self.request.query_params.get(\"domain\")\n        if domain:\n            queryset = queryset.filter(mailbox__domain__name=domain)\n        return queryset\n\n    @action(methods=[\"put\"], detail=True)\n    def password(self, request, pk=None):\n        \"\"\"Change account password.\"\"\"\n        try:\n            user = core_models.User.objects.get(pk=pk)\n        except core_models.User.DoesNotExist:\n            raise http.Http404\n        serializer = self.get_serializer(user, data=request.data)\n        if serializer.is_valid():\n            serializer.save()\n            return Response()\n        return Response(\n            serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n    @action(detail=False)\n    def exists(self, request):\n        \"\"\"Check if account exists.\n\n        Requires a valid email address as argument. Example:\n\n        GET /exists/?email=user@test.com\n\n        \"\"\"\n        email = request.GET.get(\"email\")\n        if not email:\n            raise ParseError(\"email not provided\")\n        if not core_models.User.objects.filter(email=email).exists():\n            data = {\"exists\": False}\n        else:\n            data = {\"exists\": True}\n        serializer = serializers.AccountExistsSerializer(data)\n        return Response(serializer.data)\n\n    @action(methods=[\"post\"], detail=False)\n    def reset_password(self, request):\n        \"\"\"Reset account password and send a new one by SMS.\"\"\"\n        sms_password_recovery = (\n            request.localconfig.parameters\n            .get_value(\"sms_password_recovery\", app=\"core\")\n        )\n        if not sms_password_recovery:\n            return Response(status=404)\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        user = core_models.User.objects.filter(\n            email=serializer.validated_data[\"email\"]).first()\n        if not user or not user.phone_number:\n            return Response(status=404)\n        backend = sms_backends.get_active_backend(\n            request.localconfig.parameters)\n        if not backend:\n            return Response(status=404)\n        password = lib.make_password()\n        content = _(\"Here is your new Modoboa password: {}\").format(\n            password)\n        if not backend.send(content, [str(user.phone_number)]):\n            body = {\"status\": \"ko\"}\n        else:\n            # SMS was sent, now we can set the new password.\n            body = {\"status\": \"ok\"}\n            user.set_password(password)\n            user.save(update_fields=[\"password\"])\n        return Response(body)\n\n\nclass AliasViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin, viewsets.ModelViewSet):\n    \"\"\"\n    create:\n    Create a new alias instance.\n    \"\"\"\n\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.AliasSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        ids = (\n            user.objectaccess_set.filter(\n                content_type=ContentType.objects.get_for_model(models.Alias))\n            .values_list(\"object_id\", flat=True)\n        )\n        queryset = models.Alias.objects.filter(pk__in=ids)\n        domain = self.request.query_params.get(\"domain\")\n        if domain:\n            queryset = queryset.filter(domain__name=domain)\n        return queryset\n\n\nclass SenderAddressFilterSet(dj_filters.FilterSet):\n    \"\"\"Custom FilterSet for SenderAddress.\"\"\"\n\n    class Meta:\n        model = models.SenderAddress\n        fields = [\"mailbox\"]\n\n\nclass SenderAddressViewSet(GetThrottleViewsetMixin, lib_viewsets.RevisionModelMixin,\n                           viewsets.ModelViewSet):\n    \"\"\"View set for SenderAddress model.\"\"\"\n\n    filter_backends = (dj_filters.DjangoFilterBackend, )\n    filterset_class = SenderAddressFilterSet\n    permission_classes = [IsAuthenticated, DjangoModelPermissions, ]\n    serializer_class = serializers.SenderAddressSerializer\n\n    def get_queryset(self):\n        \"\"\"Filter queryset based on current user.\"\"\"\n        user = self.request.user\n        mb_ids = (\n            user.objectaccess_set.filter(\n                content_type=ContentType.objects.get_for_model(models.Mailbox))\n            .values_list(\"object_id\", flat=True)\n        )\n        return models.SenderAddress.objects.filter(mailbox__pk__in=mb_ids)\n", "\"\"\"Core API v2 views.\"\"\"\n\nimport logging\n\nfrom django.utils.html import escape\nfrom django.utils.translation import ugettext as _\nfrom django.utils.datastructures import MultiValueDictKeyError\n\nfrom django.contrib.auth import login\n\nfrom drf_spectacular.utils import extend_schema\nfrom rest_framework import permissions, response, status\nfrom rest_framework.exceptions import AuthenticationFailed\nfrom rest_framework_simplejwt import views as jwt_views\nfrom rest_framework_simplejwt.exceptions import InvalidToken\nfrom rest_framework.views import APIView\n\nfrom modoboa.core.password_hashers import get_password_hasher\nfrom modoboa.core.utils import check_for_updates\nfrom modoboa.lib.permissions import IsSuperUser\nfrom modoboa.lib.throttle import (\n    UserLesserDdosUser, LoginThrottle, PasswordResetApplyThrottle,\n    PasswordResetRequestThrottle, PasswordResetTotpThrottle\n)\nfrom modoboa.parameters import tools as param_tools\n\nfrom smtplib import SMTPException\n\nfrom . import serializers\n\nlogger = logging.getLogger(\"modoboa.auth\")\n\n\ndef delete_cache_key(class_target, throttles, request):\n    \"\"\"Attempt to delete cache key from throttling on login/password reset success.\"\"\"\n\n    for throttle in throttles:\n        if type(throttle) == class_target:\n            throttle.reset_cache(request)\n            return\n\n\nclass TokenObtainPairView(jwt_views.TokenObtainPairView):\n    \"\"\"We overwrite this view to deal with password scheme update.\"\"\"\n\n    throttle_classes = [LoginThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        try:\n            serializer.is_valid(raise_exception=True)\n        except AuthenticationFailed as e:\n            logger.warning(\n                _(\"Failed connection attempt from '%s' as user '%s'\"),\n                request.META[\"REMOTE_ADDR\"],\n                escape(serializer.initial_data[\"username\"])\n            )\n            raise InvalidToken(e.args[0])\n\n        user = serializer.user\n        login(request, user)\n\n        # Reset login throttle\n        delete_cache_key(LoginThrottle, self.get_throttles(), request)\n\n        logger.info(\n            _(\"User '%s' successfully logged in\"), user.username\n        )\n        if user and user.is_active:\n            condition = (\n                user.is_local and\n                param_tools.get_global_parameter(\n                    \"update_scheme\", raise_exception=False)\n            )\n            if condition:\n                # check if password scheme is correct\n                scheme = param_tools.get_global_parameter(\n                    \"password_scheme\", raise_exception=False)\n                # use SHA512CRYPT as default fallback\n                if scheme is None:\n                    pwhash = get_password_hasher(\"sha512crypt\")()\n                else:\n                    pwhash = get_password_hasher(scheme)()\n                if not user.password.startswith(pwhash.scheme):\n                    logger.info(\n                        _(\"Password scheme mismatch. Updating %s password\"),\n                        user.username\n                    )\n                    user.set_password(request.data[\"password\"])\n                    user.save()\n                if pwhash.needs_rehash(user.password):\n                    logger.info(\n                        _(\"Password hash parameter missmatch. \"\n                          \"Updating %s password\"),\n                        user.username\n                    )\n                    user.set_password(serializer.data[\"password\"])\n                    user.save()\n\n        return response.Response(\n            serializer.validated_data, status=status.HTTP_200_OK)\n\n\nclass EmailPasswordResetView(APIView):\n    \"\"\"\n    An Api View which provides a method to request a password reset token based on an e-mail address.\n    \"\"\"\n\n    throttle_classes = [PasswordResetRequestThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = serializers.PasswordRecoveryEmailSerializer(\n            data=request.data, context={'request': request})\n        serializer.is_valid(raise_exception=True)\n        try:\n            serializer.save()\n        except SMTPException:\n            return response.Response({\n                \"type\": \"email\",\n                \"reason\": \"Error while sending the email. Please contact an administrator.\"\n            }, 503)\n\n        # Email response\n        return response.Response({\"type\": \"email\"}, 200)\n\n\nclass DefaultPasswordResetView(EmailPasswordResetView):\n    \"\"\"\n    Works with PasswordRecoveryForm.vue.\n    First checks if SMS recovery is available, else switch to super (Email recovery [with secondary email]).\n    \"\"\"\n\n    def post(self, request, *args, **kwargs):\n        \"\"\"Recover password.\"\"\"\n        serializer = serializers.PasswordRecoverySmsSerializer(\n            data=request.data, context={'request': request})\n        try:\n            serializer.is_valid(raise_exception=True)\n        except serializers.NoSMSAvailable:\n            return super().post(request, *args, **kwargs)\n\n        # SMS response\n        return response.Response({\"type\": \"sms\"}, 200)\n\n\nclass PasswordResetSmsTOTP(APIView):\n    \"\"\" Check SMS Totp code. \"\"\"\n\n    throttle_classes = [PasswordResetTotpThrottle]\n\n    def post(self, request, *args, **kwargs):\n        try:\n            if request.data[\"type\"] == \"confirm\":\n                klass = serializers.PasswordRecoverySmsConfirmSerializer\n            elif request.data[\"type\"] == \"resend\":\n                klass = serializers.PasswordRecoverySmsResendSerializer\n            serializer = klass(data=request.data, context={'request': request})\n        except (MultiValueDictKeyError, KeyError):\n            return response.Response({\"reason\": \"No type provided.\"}, 400)\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n        payload = {\"type\": \"resend\"}\n        if request.data[\"type\"] == \"confirm\":\n            serializer_response = serializer.context[\"response\"]\n            payload.update({\n                \"token\": serializer_response[0],\n                \"id\": serializer_response[1],\n                \"type\": \"confirm\"\n            })\n        delete_cache_key(PasswordResetTotpThrottle, self.get_throttles(), request)\n        return response.Response(payload, 200)\n\n\nclass PasswordResetConfirmView(APIView):\n    \"\"\" Get and set new user password. \"\"\"\n\n    throttle_classes = [PasswordResetApplyThrottle]\n\n    def post(self, request, *args, **kwargs):\n        serializer = serializers.PasswordRecoveryConfirmSerializer(\n            data=request.data)\n        try:\n            serializer.is_valid(raise_exception=True)\n        except serializers.PasswordRequirementsFailure as e:\n            data = {\"type\": \"password_requirement\"}\n            errors = []\n            for element in e.message_list:\n                errors.append(element)\n            data.update({\"errors\": errors})\n            return response.Response(data, 400)\n        serializer.save()\n        delete_cache_key(PasswordResetApplyThrottle, self.get_throttles(), request)\n        return response.Response(status=200)\n\n\nclass ComponentsInformationAPIView(APIView):\n    \"\"\"Retrieve information about installed components.\"\"\"\n\n    permission_classes = [permissions.IsAuthenticated, IsSuperUser]\n    throttle_classes = [UserLesserDdosUser]\n\n    @extend_schema(responses=serializers.ModoboaComponentSerializer(many=True))\n    def get(self, request, *args, **kwargs):\n        status, extensions = check_for_updates()\n        serializer = serializers.ModoboaComponentSerializer(\n            extensions, many=True\n        )\n        return response.Response(serializer.data)\n", "\"\"\"Object level permissions.\"\"\"\n\nfrom django.contrib.auth.models import Group, Permission\nfrom django.contrib.contenttypes.models import ContentType\n\nfrom rest_framework import permissions\n\nfrom modoboa.core import constants as core_constants, signals as core_signals\nfrom modoboa.core.models import ObjectAccess, User\n\n\ndef get_account_roles(user, account=None):\n    \"\"\"Return the list of available account roles.\n\n    This function is used to create or modify an account.\n\n    :param ``User`` user: connected user\n    :param ``User`` account: account beeing modified (None on creation)\n    :return: list of strings\n    \"\"\"\n    result = [core_constants.SIMPLEUSERS_ROLE]\n    filters = core_signals.user_can_set_role.send(\n        sender=\"get_account_roles\", user=user, role=\"DomainAdmins\",\n        account=account)\n    condition = (\n        user.has_perm(\"admin.add_domain\") and\n        (not filters or True in [flt[1] for flt in filters]))\n    if condition:\n        result += [core_constants.DOMAINADMINS_ROLE]\n    if user.is_superuser:\n        result += [\n            core_constants.RESELLERS_ROLE, core_constants.SUPERADMINS_ROLE]\n    return sorted(result, key=lambda role: role[1])\n\n\ndef grant_access_to_object(user, obj, is_owner=False):\n    \"\"\"Grant access to an object for a given user\n\n    There are two different cases where we want to grant access to an\n    object for a specific user:\n\n    * He is the owner (he's just created the object)\n    * He is going to administrate the object (but he is not the owner)\n\n    If the user is the owner, we also grant access to this object to\n    all super users.\n\n    :param user: a ``User`` object\n    :param obj: an admin. object (Domain, Mailbox, ...)\n    :param is_owner: the user is the unique object's owner\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    entry, created = ObjectAccess.objects.get_or_create(\n        user=user, content_type=ct, object_id=obj.id)\n    entry.is_owner = is_owner\n    entry.save()\n    if not created or not is_owner:\n        return\n    for su in User.objects.filter(is_superuser=True):\n        if su == user:\n            continue\n        ObjectAccess.objects.get_or_create(\n            user=su, content_type=ct, object_id=obj.id\n        )\n\n\ndef grant_access_to_objects(user, objects, ct):\n    \"\"\"Grant access to a collection of objects\n\n    All objects in the collection must share the same type (ie. ``ct``\n    applies to all objects).\n\n    :param user: a ``User`` object\n    :param objects: a list of objects\n    :param ct: the content type\n    \"\"\"\n    for obj in objects:\n        ObjectAccess.objects.get_or_create(\n            user=user, content_type=ct, object_id=obj.id)\n\n\ndef ungrant_access_to_object(obj, user=None):\n    \"\"\"Ungrant access to an object for a specific user\n\n    If no user is provided, all entries referencing this object are\n    deleted from the database.\n\n    If a user is provided, we only remove his access. If it was the\n    owner, we give the ownership to the first super admin we find.\n\n    :param obj: an object inheriting from ``models.Model``\n    :param user: a ``User`` object\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    if user is not None:\n        try:\n            ObjectAccess.objects.get(\n                user=user, content_type=ct, object_id=obj.id\n            ).delete()\n        except ObjectAccess.DoesNotExist:\n            pass\n        try:\n            ObjectAccess.objects.get(\n                content_type=ct, object_id=obj.id, is_owner=True\n            )\n        except ObjectAccess.DoesNotExist:\n            grant_access_to_object(\n                User.objects.filter(is_superuser=True)[0], obj, True\n            )\n    else:\n        ObjectAccess.objects.filter(\n            content_type=ct, object_id=obj.id\n        ).delete()\n\n\ndef ungrant_access_to_objects(objects):\n    \"\"\"Cancel all accesses for a given object list.\n\n    :param objects: a list of objects inheriting from ``models.Model``\n    \"\"\"\n    for obj in objects:\n        ct = ContentType.objects.get_for_model(obj)\n        ObjectAccess.objects.filter(content_type=ct, object_id=obj.id).delete()\n\n\ndef get_object_owner(obj):\n    \"\"\"Return the unique owner of this object\n\n    :param obj: an object inheriting from ``model.Model``\n    :return: a ``User`` object\n    \"\"\"\n    ct = ContentType.objects.get_for_model(obj)\n    try:\n        entry = ObjectAccess.objects.get(\n            content_type=ct, object_id=obj.id, is_owner=True\n        )\n    except ObjectAccess.DoesNotExist:\n        return None\n    return entry.user\n\n\ndef add_permissions_to_group(group, permissions):\n    \"\"\"Add the specified permissions to a django group.\"\"\"\n    if isinstance(group, str):\n        group = Group.objects.get(name=group)\n\n    for appname, modelname, permname in permissions:\n        ct = ContentType.objects.get_by_natural_key(appname, modelname)\n        if group.permissions.filter(\n                content_type=ct, codename=permname).exists():\n            continue\n        group.permissions.add(\n            Permission.objects.get(content_type=ct, codename=permname)\n        )\n\n\nclass IsSuperUser(permissions.BasePermission):\n    \"\"\"Permission class to allow only super users.\"\"\"\n\n    def has_permission(self, request, view):\n        return request.user.is_superuser\n", "\"\"\"Parameters viewsets.\"\"\"\n\nfrom drf_spectacular.utils import extend_schema, OpenApiParameter\nfrom rest_framework import permissions, response, viewsets\nfrom rest_framework.decorators import action\n\nfrom modoboa.lib.permissions import IsSuperUser\nfrom modoboa.lib.throttle import GetThrottleViewsetMixin\n\nfrom . import serializers\nfrom ... import tools\n\n\nclass ParametersViewSet(GetThrottleViewsetMixin, viewsets.ViewSet):\n    \"\"\"Parameter viewset.\"\"\"\n\n    lookup_value_regex = r\"\\w+\"\n    permission_classes = [permissions.IsAuthenticated, IsSuperUser]\n    serializer_class = None\n\n    @extend_schema(responses=serializers.ApplicationSerializer(many=True))\n    @action(methods=[\"get\"], detail=False)\n    def applications(self, request):\n        \"\"\"Return the list of registered applications.\"\"\"\n        applications = tools.registry.get_applications(\"global\")\n        return response.Response(applications)\n\n    @extend_schema(responses=serializers.ParameterSerializer(many=True))\n    @action(methods=[\"get\"], detail=False)\n    def structure(self, request):\n        \"\"\"Return parameter schema.\"\"\"\n        app = request.GET.get(\"app\")\n        data = tools.registry.get_structure(\"global\", app)\n        return response.Response(data)\n\n    @extend_schema(\n        parameters=[\n            OpenApiParameter(\n                name='id', location=OpenApiParameter.PATH,\n                description='A registered application name',\n                type=str, required=True\n            ),\n        ],\n        responses=serializers.AppParametersSerializer\n    )\n    def retrieve(self, request, pk: str):\n        \"\"\"Return all parameters for given app.\"\"\"\n        parameters = request.localconfig.parameters.get_values_dict(pk)\n        serializer = tools.registry.get_serializer_class(\"global\", pk)(\n            parameters)\n        result = serializers.AppParametersSerializer({\n            \"label\": tools.registry.get_label(\"global\", pk),\n            \"params\": serializer.data\n        })\n        return response.Response(result.data)\n\n    @extend_schema(\n        parameters=[\n            OpenApiParameter(\n                name='id', location=OpenApiParameter.PATH,\n                description='A registered application name',\n                type=str, required=True\n            ),\n        ]\n    )\n    def update(self, request, pk: str):\n        \"\"\"Save parameters for given app.\"\"\"\n        serializer = tools.registry.get_serializer_class(\"global\", pk)(\n            data=request.data)\n        serializer.is_valid(raise_exception=True)\n        request.localconfig.parameters.set_values(\n            serializer.validated_data, app=pk)\n        request.localconfig.save(update_fields=[\"_parameters\"])\n        return response.Response()\n"], "filenames": ["modoboa/admin/api/v1/viewsets.py", "modoboa/core/api/v2/views.py", "modoboa/lib/permissions.py", "modoboa/parameters/api/v2/viewsets.py"], "buggy_code_start_loc": [96, 12, 4, 4], "buggy_code_end_loc": [97, 194, 152, 16], "fixing_code_start_loc": [95, 12, 5, 4], "fixing_code_end_loc": [95, 200, 162, 19], "type": "CWE-285", "message": "Improper Authorization in GitHub repository modoboa/modoboa prior to 2.1.0.", "other": {"cve": {"id": "CVE-2023-2227", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-21T13:15:07.120", "lastModified": "2023-05-03T14:53:27.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Authorization in GitHub repository modoboa/modoboa prior to 2.1.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "EDF096DF-1D51-43ED-9F11-D69473204DEE"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/7bcd3f6eb264d4e3e01071c97c2bac51cdd6fe97", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/351f9055-2008-4af0-b820-01ff66678bf3", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/7bcd3f6eb264d4e3e01071c97c2bac51cdd6fe97"}}