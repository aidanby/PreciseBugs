{"buggy_code": ["import {\n  Body,\n  Delete,\n  ExpressMiddlewareInterface,\n  Get,\n  JsonController,\n  Middleware,\n  Param,\n  Params,\n  Patch,\n  Post,\n  Put,\n  Req,\n  Res,\n  UseBefore\n} from \"routing-controllers\"\nimport { Service } from \"typedi\"\nimport { Auth, authSystem } from \"@app/lib/auth\"\nimport { User } from \"@app/models/user.model\"\nimport { CoreService } from \"@app/services/core.service\"\nimport { CacheService } from \"@app/services/cache.service\"\nimport { Request, Response } from \"express\"\nimport Errors from \"@app/lib/errors\"\nimport { CacheType } from \"@app/enums/admin/CacheType\"\nimport { AdminService } from \"@app/services/admin.service\"\nimport { UserUtilsService } from \"@app/services/userUtils.service\"\nimport { Badge } from \"@app/models/badge.model\"\nimport { RequestAuth } from \"@app/types/express\"\nimport { Domain } from \"@app/models/domain.model\"\nimport { PulseService } from \"@app/services/pulse.service\"\nimport { TpuConfigValidator } from \"@app/validators/setup\"\nimport { SetupControllerV3 } from \"@app/controllers/v3/setup.controller\"\nimport { mergeDeep } from \"@app/lib/deepMerge\"\nimport { OauthApp } from \"@app/models/oauthApp.model\"\n\n@Service()\n@Middleware({ type: \"before\" })\n@UseBefore(Auth(\"*\"))\nclass HighLevel implements ExpressMiddlewareInterface {\n  async use(\n    request: RequestAuth,\n    response: Response,\n    next: (err?: any) => any\n  ) {\n    await authSystem(\"admin\", false, request, response, next)\n    if (!request.user || !request.user.administrator) throw Errors.ADMIN_ONLY\n  }\n}\n\n@Service()\n@Middleware({ type: \"before\" })\nclass LowLevel implements ExpressMiddlewareInterface {\n  async use(\n    request: RequestAuth,\n    response: Response,\n    next: (err?: any) => any\n  ) {\n    await authSystem(\"admin\", false, request, response, next)\n    if (\n      !request.user ||\n      (!request.user?.administrator && !request.user?.moderator)\n    )\n      throw Errors.ADMIN_ONLY\n  }\n}\n\n@Service()\n@JsonController(\"/admin\")\nexport class AdminControllerV3 {\n  constructor(\n    private readonly adminService: AdminService,\n    private readonly cacheService: CacheService,\n    private readonly userUtilsService: UserUtilsService,\n    private readonly coreService: CoreService,\n    private readonly pulseService: PulseService,\n    private readonly setupController: SetupControllerV3\n  ) {}\n\n  @Get(\"/dashboard\")\n  @UseBefore(LowLevel)\n  async getDashboard(@Auth(\"*\") user: User, @Req() req: Request) {\n    return {}\n  }\n\n  @Delete(\"/communications/message/:messageId\")\n  @UseBefore(HighLevel)\n  async deleteCommunicationsMessage(\n    @Auth(\"*\") user: User,\n    @Param(\"messageId\") messageId: number\n  ) {\n    await this.adminService.deleteCommunicationsMessage(messageId)\n    return\n  }\n\n  @Delete(\"/cache/:key\")\n  @Delete(\"/cache/:key/:uid?\")\n  @UseBefore(LowLevel)\n  async deleteCache(\n    @Auth(\"*\") user: User,\n    @Param(\"key\") key: CacheType,\n    @Params() { uid }: { uid?: number }\n  ) {\n    if (uid) {\n      this.adminService.purgeUserCache(uid)\n      return\n    } else {\n      this.adminService.purgeCache(key)\n      return\n    }\n  }\n\n  @Get(\"/users\")\n  @UseBefore(LowLevel)\n  async getUsers(@Auth(\"*\") user: User) {\n    return await this.adminService.getUsers()\n  }\n\n  @Get(\"/invites\")\n  @UseBefore(LowLevel)\n  async getInvites(@Auth(\"*\") user: User) {\n    return await this.adminService.getInvites()\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/invites/:inviteKey\")\n  async updateInvite(\n    @Auth(\"*\") user: User,\n    @Param(\"inviteKey\") inviteKey: string,\n    @Body()\n    body: {\n      type: \"accepted\" | \"rejected\"\n    }\n  ) {\n    const invite = await this.adminService.actOnInvite(inviteKey, body.type)\n    if (!invite) throw Errors.INVITE_NOT_FOUND\n    this.cacheService.purgeInvite(inviteKey)\n    if (body.type === \"accepted\") {\n      this.adminService.sendEmail(\n        {\n          body: {\n            intro: `Your friend ${invite.user.username} has invited you to join TPU.`,\n            action: [\n              {\n                instructions: `TPU is a free invite-only image and file hosting service.`,\n                button: {\n                  color: \"#0190ea\", // Optional action button color\n                  text: \"Create your account\",\n                  link:\n                    config.hostnameWithProtocol + \"/invite/\" + invite.inviteKey\n                }\n              },\n              {\n                instructions: \"Want to learn more about the advantages of TPU?\",\n                button: {\n                  color: \"#0190ea\", // Optional action button color\n                  text: \"Learn more\",\n                  link: \"https://images.flowinity.com\"\n                }\n              }\n            ],\n            outro:\n              \"If you do not intend to create an account, you can ignore this email.\"\n          }\n        },\n        invite.email,\n        `Your friend ${invite.user.username} has invited you to join TPU`\n      )\n      return\n    }\n    this.adminService.sendEmail(\n      {\n        body: {\n          intro: `Your invite request has been ${body.type}.`,\n          action: [\n            {\n              instructions: `The invite request to your friend ${invite.email} has been ${body.type}.`,\n              button: {\n                color: \"#0190ea\", // Optional action button color\n                text: \"Go to TPU\",\n                link: config.hostnameWithProtocol\n              }\n            }\n          ]\n        }\n      },\n      invite.user.email,\n      `Your TPU invite request has been ${body.type}.`\n    )\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/feedback\")\n  async getFeedback(@Auth(\"*\") user: User) {\n    return await this.adminService.getFeedback()\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/csv/uploads\")\n  async getUploadsCSV(@Auth(\"*\") user: User, @Res() res: Response) {\n    const csv = await this.adminService.exportCSVUploads()\n    res.setHeader(\"Content-Type\", \"text/csv\")\n    res.setHeader(\"Content-Disposition\", \"attachment; filename=uploads.csv\")\n    res.send(csv)\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/ban\")\n  async banUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      banned: boolean\n    }\n  ) {\n    if (!body.id) throw Errors.INVALID_PARAMETERS\n    await this.adminService.updateBanned(body.id, body.banned)\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge\")\n  async createBadge(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Badge\n  ) {\n    await this.adminService.createBadge(\n      body.name,\n      body.description,\n      body.icon,\n      body.color,\n      body.tooltip,\n      body.image\n    )\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge/users\")\n  async createBadgeUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      userIds: number[]\n    }\n  ) {\n    await this.adminService.addUsersToBadge(body.userIds, body.id)\n  }\n\n  @UseBefore(LowLevel)\n  @Put(\"/badge\")\n  async updateBadge(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Badge\n  ) {\n    await this.adminService.updateBadge(body)\n  }\n\n  @UseBefore(LowLevel)\n  @Delete(\"/badge/:id\")\n  async deleteBadge(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteBadge(id)\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/badges\")\n  async getBadges(@Auth(\"*\") user: User) {\n    return await this.adminService.getBadges()\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge/users/delete\")\n  async deleteBadgeUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      userIds: number[]\n    }\n  ) {\n    await this.adminService.removeUsersFromBadge(body.userIds, body.id)\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/verify\")\n  async verifyUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      emailVerified: boolean\n    }\n  ) {\n    if (!body.id) throw Errors.INVALID_PARAMETERS\n    await this.adminService.verify(body.id, body.emailVerified)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/announcement\")\n  async createAnnouncement(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      content: string\n    }\n  ) {\n    const announcement = await this.adminService.createAnnouncement(\n      body.content,\n      user.id\n    )\n    this.cacheService.refreshState()\n    return announcement\n  }\n\n  @UseBefore(HighLevel)\n  @Patch(\"/announcement\")\n  async editAnnouncement(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      content: string\n      id: number\n    }\n  ) {\n    const announcement = await this.adminService.editAnnouncement(\n      body.id,\n      body.content,\n      user.id\n    )\n    this.cacheService.refreshState()\n    return announcement\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/announcement/:id\")\n  async deleteAnnouncement(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteAnnouncement(id)\n    this.cacheService.refreshState()\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/notification\")\n  async createNotification(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      username: string\n      content: string\n      link: string\n    }\n  ) {\n    if (body.username === \"allOfThem\") {\n      // todo: optimize\n      const users = await User.findAll()\n      for (const user of users) {\n        await this.userUtilsService.createNotification(\n          user.id,\n          body.content,\n          body.link\n        )\n      }\n      return\n    }\n    const rUser = await User.findOne({\n      where: {\n        username: body.username\n      }\n    })\n\n    if (!rUser) {\n      throw Errors.USER_NOT_FOUND\n    }\n\n    await this.userUtilsService.createNotification(\n      rUser.id,\n      body.content,\n      body.link\n    )\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/experiments/:userId\")\n  async getExperiments(@Auth(\"*\") user: User, @Param(\"userId\") userId: number) {\n    const rUser = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n    if (!rUser) throw Errors.USER_NOT_FOUND\n    const dev = user ? rUser.administrator || rUser.moderator : false\n    const experiment = await this.coreService.getUserExperiments(rUser.id, dev)\n    return {\n      ...experiment,\n      defaults: this.coreService.getExperiments(dev)\n    }\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/experiments/:userId\")\n  async setExperiments(\n    @Auth(\"*\") user: User,\n    @Param(\"userId\") userId: number,\n    @Body()\n    body: Record<string, boolean | number | undefined | null>\n  ) {\n    const rUser = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n    if (!rUser) throw Errors.USER_NOT_FOUND\n    const dev = user ? rUser.administrator || rUser.moderator : false\n    const currentExperiments = await this.coreService.getUserExperiments(\n      userId,\n      dev\n    )\n    return await this.adminService.createExperimentOverrides(\n      currentExperiments,\n      body,\n      user.id,\n      dev\n    )\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/restart\")\n  async restartTPUCluster(@Auth(\"admin.ci\") user: User) {\n    if (!process.send) throw Errors.UNKNOWN\n    console.log(\"Restarting TPU\")\n    process.send(\"TPU_RESTART\")\n  }\n\n  @UseBefore(HighLevel)\n  @Patch(\"/gold\")\n  async updateUserGold(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      planId: number\n    }\n  ) {\n    if (!body.id || !body.planId) throw Errors.INVALID_PARAMETERS\n    await this.adminService.updatePlanId(body.id, body.planId)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/domain\")\n  async updateDomain(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Domain\n  ) {\n    await this.adminService.updateDomain(body)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/domain\")\n  async createDomain(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Domain\n  ) {\n    await this.adminService.createDomain(body.domain, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/domain/:id\")\n  async deleteDomain(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteDomain(id)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/insights/regenerate\")\n  async regenerateInsights(@Auth(\"*\") user: User) {\n    this.pulseService.regenerateAll()\n  }\n\n  redactConfig(tpuConfig: any, deleteRedacted = false) {\n    const loop = Object.entries(tpuConfig)\n    for (let [key, value] of loop) {\n      if (\n        typeof tpuConfig[key] === \"object\" &&\n        !Array.isArray(tpuConfig[key])\n      ) {\n        value = this.redactConfig(tpuConfig[key], deleteRedacted)\n      }\n      if (\n        [\"password\", \"token\", \"secret\", \"key\", \"tenor\", \"webhook\"].some((s) =>\n          key.toLowerCase().includes(s)\n        ) &&\n        !deleteRedacted\n      ) {\n        if (typeof tpuConfig[key] === \"string\" && !deleteRedacted) {\n          tpuConfig[key] = \"[REDACTED]\"\n        }\n      } else if (deleteRedacted && tpuConfig[key] === \"[REDACTED]\") {\n        console.log(\"deleting\", key)\n        delete tpuConfig[key]\n      }\n    }\n    return tpuConfig\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/config\")\n  async getConfig(@Auth(\"*\") user: User) {\n    let tpuConfig: Partial<TpuConfig> = structuredClone(global.config)\n    delete tpuConfig.mediaProxySecret\n    delete tpuConfig.jitsiToken\n    tpuConfig = this.redactConfig(tpuConfig)\n    return tpuConfig\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/config\")\n  async updateConfig(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: TpuConfig\n  ) {\n    const tpuConfig = mergeDeep(\n      structuredClone(global.config),\n      this.redactConfig(body, true)\n    )\n    console.log(tpuConfig)\n    TpuConfigValidator.parse(tpuConfig)\n    await this.setupController.writeTPUConfig(tpuConfig)\n    this.cacheService.refreshState()\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/oauth\")\n  async getOauth(@Auth(\"*\") user: User) {\n    return await this.adminService.getOauth()\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/oauth\")\n  async createOauth(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Partial<OauthApp>\n  ) {\n    return await this.adminService.createOauth(body, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/oauth/:id\")\n  async getOauthById(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.getOauthById(id)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/oauth/:id\")\n  async updateOauth(\n    @Auth(\"*\") user: User,\n    @Param(\"id\") id: string,\n    @Body()\n    body: Partial<OauthApp>\n  ) {\n    return await this.adminService.updateOauth(body, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/oauth/:id/user\")\n  async createOauthUser(\n    @Auth(\"*\") user: User,\n    @Param(\"id\") id: string,\n    @Body()\n    body: {\n      username: string\n    }\n  ) {\n    return await this.adminService.createOauthUser(id, body.username, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/oauth/:id/secret\")\n  async resetOauthSecret(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.resetOauthSecret(id, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/oauth/:id\")\n  async deleteOauth(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.deleteOauth(id, user.id)\n  }\n}\n", "import {\n  Body,\n  Controller,\n  Delete,\n  Get,\n  JsonController,\n  Param,\n  Patch,\n  Post,\n  QueryParam,\n  Res\n} from \"routing-controllers\"\nimport { Service } from \"typedi\"\nimport { Auth } from \"@app/lib/auth\"\nimport Errors from \"@app/lib/errors\"\nimport { User } from \"@app/models/user.model\"\nimport { NoteDataV2, NoteService } from \"@app/services/note.service\"\nimport { Response } from \"express\"\nimport JSZip from \"jszip\"\n\n@Service()\n@JsonController(\"/notes\")\nexport class WorkspaceControllerV3 {\n  constructor(private readonly noteService: NoteService) {}\n\n  @Get(\"/workspaces\")\n  async getWorkspaces(@Auth(\"workspaces.view\") user: User) {\n    return await this.noteService.getWorkspaces(user.id)\n  }\n\n  @Post(\"/workspaces\")\n  async createWorkspace(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.createWorkspace(body.name, user.id)\n  }\n\n  @Get(\"/workspace/:workspaceId\")\n  async getWorkspace(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"workspaceId\") workspaceId: number\n  ) {\n    return await this.noteService.getWorkspace(\n      workspaceId,\n      user.id,\n      \"workspace\"\n    )\n  }\n\n  @Get(\"/recent\")\n  async getRecentNotes(@Auth(\"workspaces.view\") user: User) {\n    return await this.noteService.getRecent(user.id)\n  }\n\n  @Get(\"/:noteId\")\n  async getNote(\n    @Auth(\"workspaces.view\", false) user: User,\n    @Param(\"noteId\") noteId: number | string\n  ) {\n    return await this.noteService.getNote(noteId, user?.id)\n  }\n\n  @Patch(\"/:noteId\")\n  async updateNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @Body()\n    body: {\n      name?: string\n      data?: NoteDataV2\n      manualSave?: boolean\n    }\n  ) {\n    if (body.name && !body.data) {\n      return await this.noteService.renameNote(noteId, body.name, user.id)\n    }\n\n    if (body.data) {\n      return await this.noteService.saveNote(\n        noteId,\n        body.data,\n        user.id,\n        body.manualSave,\n        body.name\n      )\n    }\n\n    throw Errors.INVALID_PARAMETERS\n  }\n\n  @Patch(\"/workspaces/:workspaceId\")\n  async updateWorkspace(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"workspaceId\") workspaceId: number,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.renameWorkspace(\n      workspaceId,\n      body.name,\n      user.id\n    )\n  }\n\n  @Post(\"\")\n  async createNote(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n      workspaceFolderId: number\n    }\n  ) {\n    return await this.noteService.createNote(\n      body.name,\n      body.workspaceFolderId,\n      user.id\n    )\n  }\n\n  @Patch(\"/:id/share\")\n  async shareNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.toggleShareLink(id, user.id)\n  }\n\n  @Post(\"/folder\")\n  async createFolder(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n      workspaceId: number\n    }\n  ) {\n    return await this.noteService.createFolder(\n      body.name,\n      body.workspaceId,\n      user.id\n    )\n  }\n\n  @Delete(\"/:id\")\n  async deleteNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteNote(id, user.id)\n  }\n\n  @Delete(\"/workspace/:id\")\n  async deleteWorkspace(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteWorkspace(id, user.id)\n  }\n\n  @Delete(\"/folder/:id\")\n  async deleteFolder(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteFolder(id, user.id)\n  }\n\n  @Patch(\"/folder/:id\")\n  async updateFolder(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.renameFolder(id, body.name, user.id)\n  }\n\n  @Get(\"/folder/:id/download\")\n  async downloadFolder(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"id\") id: number,\n    @QueryParam(\"type\") type: \"tpudoc\" | \"html\" | \"docx\",\n    @Res() res: Response\n  ) {\n    const folder = await this.noteService.getFolder(id, user.id)\n    const zip: JSZip = new JSZip()\n    for (const { dataValues } of folder.children) {\n      try {\n        console.log(type)\n        const data = await this.noteService.downloadNote(dataValues, type)\n        zip.file(`${dataValues.name.replaceAll(\"/\", \"-\")}.${type}`, data)\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    const data = await zip.generateAsync({ type: \"nodebuffer\" })\n    return res.contentType(\"application/octet-stream\").send(data)\n  }\n\n  @Patch(\"/:noteId/restore/:versionId\")\n  async restoreNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @Param(\"versionId\") versionId: string\n  ) {\n    await this.noteService.restoreVersion(noteId, versionId, user.id)\n  }\n\n  @Get(\"/:noteId/download\")\n  async downloadNote(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @QueryParam(\"type\") type: \"tpudoc\" | \"html\" | \"docx\",\n    @Res() res: Response\n  ) {\n    const note = await this.getNote(user, noteId)\n    if (!note?.permissions?.read) throw Errors.NOT_FOUND\n\n    const data = await this.noteService.downloadNote(note, type)\n    return res.contentType(\"application/octet-stream\").send(data)\n  }\n\n  // TPU Workspaces collaboration sharing code -- to port from v2 to v3\n  /*\n      this.router.all(\n      \"/workspace/:id/*\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          if (!req.user.administrator) throw Errors.COMING_SOON\n          const id = parseInt(req.params.id)\n          const check = await this.noteService.getWorkspacePermissions(\n            id,\n            req.user.id,\n            \"configure\"\n          )\n          if (!check) throw Errors.WORKSPACE_NO_PERMISSION\n          next()\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.post(\n      \"/workspace/:id/user\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const { username } = req.body\n          await this.noteService.addUserToWorkspace(\n            id,\n            req.user.id,\n            username,\n            req.body.write,\n            req.body.configure,\n            true\n          )\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.delete(\n      \"/workspace/:id/user/:userId\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const userId = parseInt(req.params.userId)\n          await this.noteService.removeUserFromWorkspace(id, userId)\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.patch(\n      \"/workspace/:id/user\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const userId = req.body.id\n          await this.noteService.updateUser(\n            id,\n            userId,\n            req.body.write,\n            req.body.configure,\n            true\n          )\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n   */\n}\n", "import { Container, Service } from \"typedi\"\nimport { CacheService } from \"@app/services/cache.service\"\nimport { User } from \"@app/models/user.model\"\nimport { Invite } from \"@app/models/invite.model\"\nimport Mailgen from \"mailgen\"\nimport nodemailer from \"nodemailer\"\nimport { Announcement } from \"@app/models/announcement.model\"\nimport { Experiment } from \"@app/models/experiment.model\"\nimport { CoreService } from \"@app/services/core.service\"\nimport { Feedback } from \"@app/models/feedback.model\"\nimport { Upload } from \"@app/models/upload.model\"\nimport path from \"path\"\nimport * as fs from \"fs\"\nimport { Friend } from \"@app/models/friend.model\"\nimport Errors from \"@app/lib/errors\"\nimport { Collection } from \"@app/models/collection.model\"\nimport { AutoCollectApproval } from \"@app/models/autoCollectApproval.model\"\nimport { Op } from \"sequelize\"\nimport { Chat } from \"@app/models/chat.model\"\nimport { Badge } from \"@app/models/badge.model\"\nimport { BadgeAssociation } from \"@app/models/badgeAssociation.model\"\nimport { AutoCollectRule } from \"@app/models/autoCollectRule.model\"\nimport { ChatAssociation } from \"@app/models/chatAssociation.model\"\nimport { LegacyUser } from \"@app/models/legacyUser.model\"\nimport { Message } from \"@app/models/message.model\"\nimport { CacheType } from \"@app/enums/admin/CacheType\"\nimport { Domain } from \"@app/models/domain.model\"\nimport { OauthApp } from \"@app/models/oauthApp.model\"\nimport cryptoRandomString from \"crypto-random-string\"\nimport utils from \"@app/lib/utils\"\nimport { OauthUser } from \"@app/models/oauthUser.model\"\nimport { Session } from \"@app/models/session.model\"\nimport { OauthSave } from \"@app/models/oauthSave.model\"\n\nconst inviteParams = {\n  include: [\n    {\n      model: User,\n      as: \"user\",\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    },\n    {\n      model: User,\n      as: \"invited\",\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    }\n  ],\n  attributes: [\n    \"id\",\n    \"email\",\n    \"adminId\",\n    \"inviteKey\",\n    \"status\",\n    \"userId\",\n    \"registerUserId\",\n    \"createdAt\",\n    \"updatedAt\"\n  ]\n}\n\n@Service()\nexport class AdminService {\n  constructor(private readonly cacheService: CacheService) {}\n\n  async getFeedback() {\n    return await Feedback.findAll({\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ],\n      order: [[\"createdAt\", \"DESC\"]]\n    })\n  }\n\n  async createAnnouncement(\n    content: string,\n    userId: number\n  ): Promise<Announcement> {\n    return await Announcement.create({\n      content,\n      userId\n    })\n  }\n\n  async editAnnouncement(\n    id: number,\n    content: string,\n    userId: number\n  ): Promise<Announcement> {\n    const announcement = await Announcement.findOne({\n      where: {\n        id\n      }\n    })\n    if (!announcement || announcement.userId !== userId) throw Errors.NOT_FOUND\n    await announcement.update({\n      content\n    })\n    return announcement\n  }\n\n  async deleteAnnouncement(id: number): Promise<boolean> {\n    const announcement = await Announcement.findOne({\n      where: {\n        id\n      }\n    })\n    if (!announcement) throw Errors.NOT_FOUND\n    await announcement.destroy()\n    return true\n  }\n\n  async getInvites() {\n    return Invite.findAll({\n      ...inviteParams\n    })\n  }\n\n  async actOnInvite(\n    inviteKey: string,\n    action: \"accepted\" | \"rejected\"\n  ): Promise<Invite | null> {\n    await Invite.update(\n      {\n        status: action\n      },\n      {\n        where: {\n          inviteKey\n        }\n      }\n    )\n    return await Invite.findOne({\n      where: {\n        inviteKey\n      },\n      ...inviteParams\n    })\n  }\n\n  async getUsers() {\n    return User.findAll({\n      attributes: {\n        exclude: [\"emailToken\", \"storedStatus\"]\n      }\n    })\n  }\n\n  async getStats() {\n    //TODO\n    return {\n      tpu: {\n        users: await User.count(),\n        uploads: await Upload.count(),\n        friends: await Friend.count(),\n        invites: await Invite.count(),\n        feedback: await Feedback.count(),\n        announcements: await Announcement.count(),\n        experiments: await Experiment.count(),\n        collections: await Collection.count(),\n        shareLinks: await Collection.count({\n          where: {\n            shareLink: {\n              [Op.ne]: null\n            }\n          }\n        }),\n        autoCollects: await AutoCollectApproval.count(),\n        chats: await Chat.count(),\n        uploadsSize: await Upload.sum(\"fileSize\")\n      },\n      system: {\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        cpu: process.cpuUsage()\n      }\n    }\n  }\n\n  async purgeCache(type: CacheType) {\n    switch (type) {\n      case CacheType.everything:\n        await this.cacheService.refreshState()\n        await this.cacheService.generateCollectionCache()\n        await this.cacheService.generateShareLinkCache()\n        return true\n      case CacheType.state:\n        await this.cacheService.refreshState()\n        return true\n      case CacheType.collections:\n        await this.cacheService.generateCollectionCache()\n        return true\n      case CacheType.sharelinks:\n        await this.cacheService.generateShareLinkCache()\n        return true\n      case CacheType.autocollects:\n        await this.cacheService.generateAutoCollectCache()\n        return true\n      case CacheType.invites:\n        await redis.del(\"invites\")\n        return true\n      case CacheType.chats:\n        await this.cacheService.generateChatsCache()\n        return true\n      case CacheType.insights:\n        await this.cacheService.generateInsightsCache()\n        return true\n      case CacheType.userstats:\n        await this.cacheService.generateUserStatsCache()\n        return true\n      case CacheType.lastfm:\n        console.log(\"[AdminService] Purging lastfm cache\")\n        await redis.del(\"providers:lastfm:*\")\n        return true\n      case CacheType.mal:\n        console.log(\"[AdminService] Purging mal cache\")\n        await redis.del(\"providers:mal:*\")\n        return true\n      default:\n        return false\n    }\n  }\n\n  async purgeUserCache(id: number) {\n    await this.cacheService.generateCollectionCacheForUser(id)\n    return true\n  }\n\n  async sendEmail(\n    mail: Mailgen.Content,\n    email: string,\n    subject: string,\n    customConfig?: {\n      host: string\n      port: number\n      secure: boolean\n      username: string\n      password: string\n      from: string\n    }\n  ) {\n    console.log(\"[AdminService] Sending email to\", email)\n    let mailGenerator = new Mailgen({\n      theme: \"cerberus\",\n      product: {\n        name: config.siteName,\n        link: config.hostnameWithProtocol\n      }\n    })\n    let emailBody = mailGenerator.generate(mail)\n    let emailText = mailGenerator.generatePlaintext(mail)\n    let transporter = nodemailer.createTransport({\n      host: customConfig?.host || config.email.host,\n      port: customConfig?.port || config.email.port,\n      secure: customConfig?.secure || config.email.secure,\n      auth: {\n        user: customConfig?.username || config.email.username,\n        pass: customConfig?.password || config.email.password\n      }\n    })\n    return await transporter.sendMail({\n      from: customConfig?.from || config.email.from,\n      to: email,\n      subject: subject,\n      text: emailText,\n      html: emailBody\n    })\n  }\n\n  async createExperimentOverrides(\n    currentExperiments: Record<\n      string,\n      string | number | boolean | undefined | null\n    >,\n    overrides: { [key: string]: string | number | boolean | undefined | null },\n    userId: number,\n    dev: boolean = false\n  ) {\n    const experiments = Object.entries(overrides).reduce(\n      (acc: Record<string, any>, [name, value]: any) => {\n        try {\n          if (name === \"meta\") return acc\n          const val = JSON.parse(<string>value)\n          if (val !== currentExperiments[name] && value !== \"destroy\") {\n            acc[name] = val\n          }\n          return acc\n        } catch {\n          if (value !== currentExperiments[name] && value !== \"destroy\") {\n            acc[name] = value\n          }\n          return acc\n        }\n      },\n      {}\n    )\n    const experimentsToDelete = Object.entries(overrides).reduce(\n      (acc, [name, value]) => {\n        if (value === \"destroy\") {\n          acc.push(name)\n        }\n        return acc\n      }\n    )\n    for (const experiment of experimentsToDelete) {\n      await Experiment.destroy({\n        where: {\n          key: experiment,\n          userId\n        }\n      })\n    }\n\n    for (const [key, value] of Object.entries(experiments)) {\n      await Experiment.create({\n        key,\n        value: JSON.stringify(value),\n        userId\n      })\n    }\n    const coreService = Container.get(CoreService)\n    return await coreService.getUserExperiments(userId, dev)\n  }\n\n  async exportCSVUploads() {\n    let uploads = await Upload.findAll({\n      attributes: [\"createdAt\", \"id\"],\n      order: [[\"createdAt\", \"DESC\"]],\n      raw: true\n    })\n\n    let data = uploads.reduce((acc: any, upload) => {\n      const date = dayjs(upload.createdAt).format(\"YYYY-MM-DD\")\n      if (date === \"Invalid Date\") return acc\n      if (!acc[date]) {\n        acc[date] = 1\n      } else {\n        acc[date]++\n      }\n      return acc\n    })\n\n    return Object.entries(data)\n      .map(([date, count]) => `${date},${count}`)\n      .join(\"\\n\")\n  }\n\n  async getServices() {\n    // get all typedi service functions\n    const container = Container as any\n    const services = container?.globalInstance?.services\n    if (!services) return []\n    const serviceNames = Object.keys(services)\n    const serviceFunctions = serviceNames.map((name) => {\n      return services[name]\n    })\n    // get all typedi service names\n    let serviceNamesWithTypes = serviceFunctions.map((service) => {\n      return {\n        name: service.type.name,\n        functions: [] as (string[] | null)[]\n      }\n    })\n    for (const service of serviceNamesWithTypes) {\n      // contains controller, application or server\n      if (\n        service.name.toLowerCase().includes(\"controller\") ||\n        service.name.toLowerCase().includes(\"application\") ||\n        service.name.toLowerCase().includes(\"server\")\n      )\n        continue\n      const name =\n        service.name.charAt(0).toLowerCase() +\n        service.name.slice(1).replace(\"Service\", \".service\")\n      const file = fs.readFileSync(\n        path.join(__dirname, `../../app/services/${name}.ts`),\n        \"utf8\"\n      )\n      // get the function names and also provide the parameters like {\"name\": \"yes\", \"params\": {\"id\": \"number\"}}]}\n      let functionNames\n      try {\n        functionNames = file\n          .split(\"\\n\")\n          .filter((line) => line.includes(\"async\"))\n          .map((line) => {\n            const functionName = line.split(\"async \")[1].split(\"(\")[0]\n            const params = line\n              .split(\"(\")[1]\n              .split(\")\")[0]\n              .split(\",\")\n              .map((param) => {\n                const name = param.split(\":\")[0]?.trim()\n                const type = param.split(\":\")[1]?.trim()\n                return {\n                  name,\n                  type\n                }\n              })\n            return {\n              name: functionName,\n              params\n            }\n          })\n      } catch {}\n      if (!functionNames) continue\n      // @ts-ignore\n      service.functions = functionNames\n    }\n    return serviceNamesWithTypes\n  }\n\n  //dev\n  async devAcceptFriends() {\n    await Friend.update(\n      {\n        status: \"accepted\"\n      },\n      {\n        where: {}\n      }\n    )\n  }\n\n  async updatePlanId(userId: number, planId: number) {\n    const user = await User.findByPk(userId)\n    if (!user) throw Errors.USER_NOT_FOUND\n    if (userId === 6 && planId === 6) {\n      throw Errors.HANDLED_BY_PAYMENT_PROVIDER\n    }\n    await User.update(\n      {\n        planId\n      },\n      {\n        where: {\n          id: userId\n        }\n      }\n    )\n    return true\n  }\n\n  async updateBanned(userId: number, banned: boolean) {\n    const user = await User.findByPk(userId)\n    if (!user) throw Errors.USER_NOT_FOUND\n    if (user.administrator || user.moderator) throw Errors.MANUAL_BAN_REQUIRED\n    await User.update(\n      {\n        banned\n      },\n      {\n        where: {\n          id: userId\n        }\n      }\n    )\n    return true\n  }\n\n  async createBadge(\n    name: string,\n    description: string,\n    icon: string,\n    color: string,\n    tooltip: string,\n    image: string\n  ) {\n    return await Badge.create({\n      name,\n      description,\n      icon,\n      color,\n      tooltip,\n      image\n    })\n  }\n\n  async addUsersToBadge(userIds: number[], badgeId: number) {\n    for (const userId of userIds) {\n      await BadgeAssociation.create({\n        userId,\n        badgeId\n      })\n    }\n    return true\n  }\n\n  async getBadges() {\n    return await Badge.findAll({\n      include: [\n        {\n          model: User,\n          as: \"users\",\n          attributes: [\"id\", \"username\", \"avatar\"]\n        }\n      ]\n    })\n  }\n\n  async updateBadge(badge: Badge) {\n    await Badge.update(\n      {\n        ...badge\n      },\n      {\n        where: {\n          id: badge.id\n        }\n      }\n    )\n    return true\n  }\n\n  async deleteBadge(badgeId: number) {\n    await Badge.destroy({\n      where: {\n        id: badgeId\n      }\n    })\n    await BadgeAssociation.destroy({\n      where: {\n        badgeId\n      }\n    })\n    return true\n  }\n\n  async removeUsersFromBadge(userIds: number[], badgeId: number) {\n    for (const userId of userIds) {\n      await BadgeAssociation.destroy({\n        where: {\n          userId,\n          badgeId\n        }\n      })\n    }\n    return true\n  }\n\n  // AutoCollect\n  async getAutoCollectRules() {\n    return await User.findAll({\n      attributes: [\"id\", \"username\", \"avatar\"],\n      include: [\n        {\n          model: AutoCollectRule,\n          as: \"autoCollectRules\"\n        }\n      ]\n    })\n  }\n\n  // --SCRIPTS--\n  async scriptFindChats(\n    type: undefined | \"group\" | \"direct\" | \"channel\" = undefined\n  ) {\n    return await Chat.findAll({\n      where: {\n        type\n      },\n      include: [\n        {\n          model: ChatAssociation,\n          as: \"users\",\n          attributes: [\n            \"id\",\n            \"userId\",\n            \"user\",\n            \"rank\",\n            \"legacyUserId\",\n            \"lastRead\",\n            \"createdAt\",\n            \"updatedAt\"\n          ],\n          include: [\n            {\n              model: User,\n              as: \"tpuUser\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            },\n            {\n              model: LegacyUser,\n              as: \"legacyUser\",\n              attributes: [\"id\", \"username\", \"createdAt\", \"updatedAt\", \"avatar\"]\n            }\n          ]\n        }\n      ]\n    })\n  }\n\n  async scriptColubrinaGroupOwner() {\n    const chats = await this.scriptFindChats(\"group\")\n    for (const chat of chats) {\n      // if the chat has no owners\n      if (!chat.users.find((user) => user.rank === \"owner\")) {\n        // get the owner\n        const owner = chat.users.find(\n          (user) => user.tpuUser?.id === chat.userId\n        )\n        if (owner?.tpuUser) {\n          await ChatAssociation.update(\n            {\n              rank: \"owner\"\n            },\n            {\n              where: {\n                id: owner.id\n              }\n            }\n          )\n        } else {\n          // make a random admin the owner\n          const admin = chat.users.find((user) => user.rank === \"admin\")\n          if (admin?.tpuUser) {\n            await ChatAssociation.update(\n              {\n                rank: \"owner\"\n              },\n              {\n                where: {\n                  id: admin.id\n                }\n              }\n            )\n          } else {\n            const user = chat.users.find((user) => user.rank === \"member\")\n            if (user?.tpuUser) {\n              await ChatAssociation.update(\n                {\n                  rank: \"owner\"\n                },\n                {\n                  where: {\n                    id: user.id\n                  }\n                }\n              )\n            } else {\n              console.log(\"no users in chat\", chat.id)\n            }\n          }\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMOwners() {\n    const chats = await this.scriptFindChats(\"direct\")\n    for (const chat of chats) {\n      // if any of the chats have users of rank admin or owner, set them to member\n      for (const user of chat.users) {\n        if (user.rank === \"admin\" || user.rank === \"owner\") {\n          console.log(`changing ${user.user?.username} to member`)\n          await ChatAssociation.update(\n            {\n              rank: \"member\"\n            },\n            {\n              where: {\n                id: user.id\n              }\n            }\n          )\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMMerge() {\n    const chats = await this.scriptFindChats(\"direct\")\n    // if any of the chats have the same users, merge them\n    for (const chat of chats) {\n      for (const chat2 of chats) {\n        if (chat.id === chat2.id) continue\n        const users = chat.users.map((user) => user.tpuUser?.id)\n        const users2 = chat2.users.map((user) => user.tpuUser?.id)\n        if (users.length === users2.length) {\n          if (users.every((user) => users2.includes(user))) {\n            // if the users or users2 contains undefined, skip\n            if (users.includes(undefined) || users2.includes(undefined))\n              continue\n            if (users.length !== 2 || users2.length !== 2) continue\n            // delete the other chat from array\n            chats.splice(chats.indexOf(chat2), 1)\n            // merge the chats\n            console.log(\n              `merging ${chat.id} and ${chat2.id}, Users: ${users}, Users2: ${users2}`\n            )\n            await ChatAssociation.destroy({\n              where: {\n                chatId: chat2.id\n              }\n            })\n            await Message.update(\n              {\n                chatId: chat.id\n              },\n              {\n                where: {\n                  chatId: chat2.id\n                }\n              }\n            )\n            await Chat.destroy({\n              where: {\n                id: chat2.id\n              }\n            })\n          }\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMIntents() {\n    const chats = await this.scriptFindChats(\"direct\")\n    for (const chat of chats) {\n      if (chat.intent?.length) continue\n      const users = chat.users.map((user) => user.tpuUser?.id)\n      if (users.length !== 2 || users.includes(undefined)) continue\n      users.sort((a, b) => a - b)\n      console.log(`setting intent for ${chat.id} to ${users}`)\n      // set the intent\n      await Chat.update(\n        {\n          intent: users.join(\"-\")\n        },\n        {\n          where: {\n            id: chat.id\n          }\n        }\n      )\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async deleteCommunicationsMessage(messageId: number) {\n    const message = await Message.findOne({\n      where: {\n        id: messageId\n      }\n    })\n\n    if (!message) throw Errors.MESSAGE_NOT_FOUND\n\n    await message.destroy()\n  }\n\n  async updateDomain(domain: Partial<Domain>) {\n    const domainInstance = await Domain.findOne({\n      where: {\n        id: domain.id\n      }\n    })\n\n    if (!domainInstance) throw Errors.DOMAIN_NOT_FOUND\n\n    await domainInstance.update({\n      domain: domain.domain\n    })\n  }\n\n  async createDomain(name: string, userId: number) {\n    return await Domain.create({\n      domain: name,\n      active: true,\n      DNSProvisioned: true,\n      userId\n    })\n  }\n\n  async deleteDomain(domainId: number) {\n    if (domainId === 1) throw Errors.CANNOT_DELETE_DEFAULT\n    return await Domain.destroy({\n      where: {\n        id: domainId\n      }\n    })\n  }\n\n  async verify(userId: number, emailVerified: boolean) {\n    const user = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n\n    if (!user || user.administrator || user.moderator)\n      throw Errors.USER_NOT_FOUND\n\n    await user.update({\n      emailVerified\n    })\n  }\n\n  async getOauth() {\n    return await OauthApp.findAll({\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ],\n      order: [[\"createdAt\", \"DESC\"]]\n    })\n  }\n\n  async createOauth(body: Partial<OauthApp>, userId: number) {\n    return await OauthApp.create({\n      name: body.name,\n      icon: body.icon,\n      // convert the name to a slug shortcode\n      shortCode:\n        body.name?.toLowerCase().replace(/ /g, \"-\") +\n        \"-\" +\n        cryptoRandomString({ length: 5 }),\n      verified: body.verified,\n      redirectUri: body.redirectUri,\n      secret: await utils.generateAPIKey(\"oauth\"),\n      description: body.description,\n      scopes: body.scopes,\n      userId: userId,\n      private: body.private\n    })\n  }\n\n  async getOauthById(id: string, userId?: number) {\n    return await OauthApp.findOne({\n      where: {\n        id,\n        ...(userId ? { userId } : {})\n      },\n      // include secret override\n      attributes: {\n        include: [\"secret\"]\n      },\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        },\n        {\n          model: OauthUser,\n          as: \"oauthUsers\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        }\n      ]\n    })\n  }\n\n  async updateOauth(body: Partial<OauthApp>, userId: number) {\n    const app = await this.getOauthById(body.id || \"\")\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.update({\n      name: body.name,\n      icon: body.icon,\n      verified: body.verified,\n      redirectUri: body.redirectUri,\n      description: body.description,\n      scopes: body.scopes,\n      private: body.private\n    })\n  }\n\n  async createOauthUser(appId: string, username: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    const user = await User.findOne({\n      where: {\n        username\n      }\n    })\n    if (!user || user.id === userId) throw Errors.USER_NOT_FOUND\n    const existence = await OauthUser.findOne({\n      where: {\n        userId: user.id,\n        oauthAppId: app.id\n      }\n    })\n    if (existence) {\n      await existence.destroy()\n      await Session.destroy({\n        where: {\n          oauthAppId: app.id,\n          userId: user.id,\n          type: \"oauth\"\n        }\n      })\n      return\n    }\n    await OauthUser.create({\n      userId: user.id,\n      oauthAppId: app.id,\n      active: true\n    })\n  }\n\n  async resetOauthSecret(appId: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.update({\n      secret: await utils.generateAPIKey(\"oauth\")\n    })\n  }\n\n  async deleteOauth(appId: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.destroy()\n    await OauthUser.destroy({\n      where: {\n        oauthAppId: app.id\n      }\n    })\n    await Session.destroy({\n      where: {\n        oauthAppId: app.id,\n        type: \"oauth\"\n      }\n    })\n    await OauthSave.destroy({\n      where: {\n        oauthAppId: app.id\n      }\n    })\n  }\n}\n", "import { Service } from \"typedi\"\nimport { Workspace } from \"@app/models/workspace.model\"\nimport { WorkspaceFolder } from \"@app/models/workspaceFolder.model\"\nimport { Note } from \"@app/models/note.model\"\nimport Errors from \"@app/lib/errors\"\nimport cryptoRandomString from \"crypto-random-string\"\nimport { NoteVersion } from \"@app/models/noteVersion.model\"\nimport { WorkspaceUser } from \"@app/models/workspaceUser.model\"\nimport { User } from \"@app/models/user.model\"\nimport { Friend } from \"@app/models/friend.model\"\nimport { WorkspacesDownloadService } from \"@app/services/workspaces/download.service\"\nimport { BadRequestError } from \"routing-controllers\"\n\n//create class of NoteData\nexport class NoteField {\n  type:\n    | \"h1\"\n    | \"h2\"\n    | \"h3\"\n    | \"h4\"\n    | \"h5\"\n    | \"h6\"\n    | \"p\"\n    | \"textarea\"\n    | \"input\"\n    | \"image\"\n    | \"checkbox\"\n    | \"radio\"\n    | \"button\"\n  value: string | number | boolean | object\n  styles: string\n  creatorId: number\n  lastEditorId: number\n  locked: boolean\n}\n\nexport class NoteData {\n  fields: NoteField[]\n  styles: string\n  creatorId: number\n  lastEditorId: number\n\n  constructor(userId: number) {\n    this.fields = [\n      {\n        type: \"h1\",\n        value: \"My new TPUDOC\",\n        styles: \"\",\n        creatorId: userId,\n        lastEditorId: userId,\n        locked: false\n      }\n    ]\n    this.styles = \"\"\n    this.creatorId = userId\n    this.lastEditorId = userId\n  }\n}\n\nexport class NoteDataV2 {\n  blocks: object[]\n}\n\n@Service()\nexport class NoteService {\n  constructor(private readonly downloadService: WorkspacesDownloadService) {}\n\n  async renameWorkspace(id: number, name: string, userId: number) {\n    const workspace = await this.getWorkspace(id, userId, \"workspace\")\n    if (!workspace) throw Errors.NOT_FOUND\n    await Workspace.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return true\n  }\n\n  async getRecent(userId: number) {\n    return await Workspace.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"notes\",\n              attributes: {\n                exclude: [\"data\"]\n              },\n              include: [\n                {\n                  model: WorkspaceFolder,\n                  as: \"folder\",\n                  attributes: [\"id\", \"name\"]\n                }\n              ],\n              order: [[\"updatedAt\", \"DESC\"]]\n            }\n          ],\n          limit: 12\n        }\n      ],\n      where: {\n        userId\n      },\n      order: [[\"updatedAt\", \"DESC\"]]\n    })\n  }\n\n  async restoreVersion(id: number, version: string, userId: number) {\n    const note = await this.getNote(id, userId)\n    if (!note?.permissions?.modify) throw Errors.NOT_FOUND\n\n    const versionData = note.versions.find((v: Note) => v.id === version)\n    if (!versionData) throw Errors.NOT_FOUND\n\n    await Note.update(\n      {\n        data: versionData.data\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n\n    return true\n  }\n\n  async renameFolder(id: number, name: string, userId: number) {\n    const folder = await this.getWorkspace(id, userId, \"folder\")\n    if (!folder) throw Errors.NOT_FOUND\n    await WorkspaceFolder.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return true\n  }\n\n  async deleteFolder(id: number, userId: number) {\n    const folder = await this.getWorkspace(id, userId, \"folder\")\n    if (!folder) throw Errors.NOT_FOUND\n    await Note.destroy({\n      where: {\n        workspaceFolderId: id\n      }\n    })\n    await WorkspaceFolder.destroy({\n      where: {\n        id\n      }\n    })\n    return true\n  }\n\n  async deleteNote(id: number, userId: number) {\n    const note = await this.getNote(id, userId)\n    if (!note?.permissions?.configure) throw Errors.NOT_FOUND\n    await Note.destroy({\n      where: {\n        id\n      }\n    })\n    return true\n  }\n\n  async deleteWorkspace(id: number, userId: number) {\n    const workspace = await this.getWorkspace(id, userId, \"workspace\")\n    console.log(workspace)\n    if (!workspace?.permissionsMetadata?.configure) throw Errors.NOT_FOUND\n    const notes = await Note.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folder\",\n          required: true,\n          where: {\n            workspaceId: id\n          }\n        }\n      ]\n    })\n\n    await Note.destroy({\n      where: {\n        id: notes.map((n) => n.id)\n      }\n    })\n\n    await WorkspaceFolder.destroy({\n      where: {\n        workspaceId: id\n      }\n    })\n\n    await Workspace.destroy({\n      where: {\n        id\n      }\n    })\n\n    return true\n  }\n\n  async createFolder(name: string, id: number, userId: number) {\n    const workspace = await Workspace.findOne({\n      where: {\n        id,\n        userId\n      }\n    })\n    if (!workspace) throw Errors.NOT_FOUND\n    return await WorkspaceFolder.create({\n      name,\n      workspaceId: id\n    })\n  }\n\n  async getWorkspaces(userId: number) {\n    const workspaces = await Workspace.findAll({\n      where: {\n        userId\n      },\n      include: [\n        {\n          model: WorkspaceUser,\n          as: \"users\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"children\",\n              attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ]\n    })\n\n    const shared = await Workspace.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"children\",\n              attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceUser,\n          as: \"users\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceUser,\n          as: \"recipient\",\n          required: true,\n          where: {\n            recipientId: userId\n          },\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ]\n    })\n\n    return [\n      ...workspaces.map((workspace) => workspace.toJSON()),\n      ...shared.map((workspace) => {\n        return {\n          ...workspace.toJSON(),\n          shared: true,\n          permissionsMetadata: {\n            write: workspace.dataValues.recipient.dataValues.write,\n            configure: workspace.dataValues.recipient.dataValues.configure,\n            read: workspace.dataValues.recipient.dataValues.read\n          }\n        }\n      })\n    ]\n  }\n\n  async getWorkspace(id: number, userId: number, type: \"workspace\" | \"folder\") {\n    const include = [\n      {\n        model: WorkspaceUser,\n        as: \"users\",\n        include: [\n          {\n            model: User,\n            as: \"user\",\n            attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n          }\n        ]\n      },\n      {\n        model: WorkspaceFolder,\n        as: \"folders\",\n        include: [\n          {\n            model: Note,\n            as: \"children\",\n            attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n          }\n        ]\n      },\n      {\n        model: User,\n        as: \"user\",\n        attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n      }\n    ]\n    const workspace = await Workspace.findOne({\n      where: {\n        id,\n        userId\n      },\n      include\n    })\n    if (type === \"folder\") {\n      const workspace = await Workspace.findOne({\n        where: {\n          userId\n        },\n        include: [\n          ...include,\n          {\n            model: WorkspaceFolder,\n            as: \"folder\",\n            where: {\n              id\n            },\n            required: true\n          }\n        ]\n      })\n      if (!workspace) {\n        const workspace = await Workspace.findOne({\n          include: [\n            ...include,\n            {\n              model: WorkspaceFolder,\n              as: \"folder\",\n              where: {\n                id\n              },\n              required: true\n            },\n            {\n              model: WorkspaceUser,\n              as: \"recipient\",\n              required: true,\n              where: {\n                recipientId: userId\n              }\n            }\n          ]\n        })\n        if (!workspace) throw Errors.NOT_FOUND\n        return {\n          ...workspace.toJSON(),\n          shared: true,\n          permissionsMetadata: {\n            write: workspace.dataValues.recipient.dataValues.write,\n            configure: workspace.dataValues.recipient.dataValues.configure,\n            read: workspace.dataValues.recipient.dataValues.read\n          }\n        }\n      }\n      return {\n        ...workspace.toJSON(),\n        shared: false,\n        permissionsMetadata: {\n          write: true,\n          configure: true,\n          read: true\n        }\n      }\n    }\n    if (!workspace) {\n      const workspace = await Workspace.findOne({\n        where: {\n          id\n        },\n        include: [\n          ...include,\n          {\n            model: WorkspaceUser,\n            as: \"recipient\",\n            required: true,\n            where: {\n              recipientId: userId\n            }\n          }\n        ]\n      })\n      if (!workspace) throw Errors.NOT_FOUND\n      return {\n        ...workspace.toJSON(),\n        shared: true,\n        permissionsMetadata: {\n          write: workspace.dataValues.recipient.dataValues.write,\n          configure: workspace.dataValues.recipient.dataValues.configure,\n          read: workspace.dataValues.recipient.dataValues.read\n        }\n      }\n    }\n    return {\n      ...workspace.toJSON(),\n      shared: false,\n      permissionsMetadata: {\n        write: true,\n        configure: true,\n        read: true\n      }\n    }\n  }\n\n  async getFolder(id: number, userId: number) {\n    const folder = await WorkspaceFolder.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: Note,\n          as: \"children\",\n          attributes: [\n            \"id\",\n            \"name\",\n            \"createdAt\",\n            \"updatedAt\",\n            \"data\",\n            \"shareLink\"\n          ]\n        }\n      ]\n    })\n    if (!folder) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      folder.workspaceId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return folder\n  }\n\n  async createWorkspace(name: string, userId: number) {\n    const workspace = await Workspace.create({\n      name,\n      userId\n    })\n\n    const folder = await WorkspaceFolder.create({\n      name: \"Documents\",\n      workspaceId: workspace.id\n    })\n\n    await Note.create({\n      name: `Document 1`,\n      workspaceFolderId: folder.id,\n      data: {}\n    })\n\n    return workspace\n  }\n\n  async getNote(id: number | string, userId: number | undefined) {\n    const note = await Note.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: NoteVersion,\n          as: \"versions\",\n          limit: 50,\n          order: [[\"createdAt\", \"DESC\"]]\n        }\n      ]\n    })\n    if (!note || !userId || id.toString().length === 64) {\n      const note = await Note.findOne({\n        where: {\n          shareLink: id\n        },\n        attributes: {\n          exclude: [\"versions\"]\n        }\n      })\n      if (!note) throw Errors.NOT_FOUND\n      return {\n        ...note.toJSON(),\n        permissions: {\n          modify: false,\n          configure: false,\n          read: true\n        }\n      }\n    }\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return {\n      ...note.toJSON(),\n      permissions: {\n        modify: true,\n        configure: true,\n        read: true\n      }\n    }\n  }\n\n  async renameNote(id: number, name: string, userId: number) {\n    const note = await Note.findOne({\n      where: {\n        id\n      }\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace?.permissionsMetadata?.write) throw Errors.NOT_FOUND\n    await Note.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return note\n  }\n\n  async saveNote(\n    id: number,\n    data: NoteDataV2,\n    userId: number,\n    manualSave: boolean = false,\n    name?: string\n  ) {\n    let note = await Note.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: NoteVersion,\n          as: \"versions\",\n          limit: 50,\n          order: [[\"createdAt\", \"DESC\"]]\n        }\n      ]\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace?.permissionsMetadata?.write) throw Errors.NOT_FOUND\n    if (!note.versions) note.versions = []\n\n    const latestSave = note.versions[0]\n    let versions = note.versions\n    if (\n      !latestSave ||\n      new Date().getTime() - new Date(latestSave?.createdAt).getTime() >\n        5 * 60 * 1000 ||\n      (manualSave &&\n        new Date().getTime() - new Date(latestSave?.createdAt).getTime() >\n          30 * 1000)\n    ) {\n      const version = await NoteVersion.create({\n        noteId: note.id,\n        data,\n        userId\n      })\n      versions = [version, ...versions]\n    }\n    await Note.update(\n      {\n        data,\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return {\n      ...note.toJSON(),\n      versions: versions.slice(0, 50)\n    }\n  }\n\n  async createNote(name: string, workspaceFolderId: number, userId: number) {\n    const workspace = await this.getWorkspace(\n      workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return await Note.create({\n      name,\n      workspaceFolderId,\n      data: {}\n    })\n  }\n\n  async toggleShareLink(id: number, userId: number) {\n    const note = await Note.findOne({\n      where: {\n        id\n      }\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    const shareLink = note.shareLink\n      ? null\n      : await cryptoRandomString({ length: 64 })\n    await note.update({\n      shareLink\n    })\n    return {\n      shareLink\n    }\n  }\n\n  async removeUserFromWorkspace(workspaceId: number, recipientId: number) {\n    const result = await WorkspaceUser.destroy({\n      where: {\n        workspaceId,\n        recipientId\n      }\n    })\n\n    if (!result) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n    return result\n  }\n\n  async addUserToWorkspace(\n    workspaceId: number,\n    senderId: number,\n    username: string,\n    write: boolean,\n    configure: boolean,\n    read: boolean\n  ) {\n    const workspace = await Workspace.findOne({\n      where: {\n        id: workspaceId\n      }\n    })\n\n    if (!workspace) {\n      throw Errors.WORKSPACE_NOT_FOUND\n    }\n\n    const user = await User.findOne({\n      where: {\n        username\n      },\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    })\n\n    if (!user) {\n      throw Errors.USER_NOT_FOUND\n    }\n\n    if (workspace.userId === user.id) {\n      throw Errors.CANNOT_ADD_OWNER\n    }\n\n    const friend = await Friend.findOne({\n      where: {\n        userId: senderId,\n        friendId: user.id,\n        status: \"accepted\"\n      }\n    })\n\n    if (!friend) {\n      throw Errors.NOT_FRIENDS_WITH_USER_COLLECTION\n    }\n\n    return {\n      ...(\n        await WorkspaceUser.create({\n          workspaceId,\n          recipientId: user.id,\n          senderId: senderId,\n          write,\n          configure,\n          read,\n          identifier: workspaceId + \"-\" + user.id\n        })\n      ).dataValues,\n      user,\n      workspace: {\n        id: workspace.id,\n        name: workspace.name\n      }\n    }\n  }\n\n  async updateUser(\n    workspaceId: number,\n    recipientId: number,\n    write: boolean,\n    configure: boolean,\n    read: boolean\n  ) {\n    const result = await WorkspaceUser.update(\n      {\n        write,\n        configure,\n        read\n      },\n      {\n        where: {\n          workspaceId,\n          recipientId\n        }\n      }\n    )\n\n    if (!result) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n    return result\n  }\n\n  async getWorkspacePermissions(\n    workspaceId: number,\n    userId: number,\n    permission: \"read\" | \"write\" | \"configure\"\n  ) {\n    const workspace = await WorkspaceUser.findOne({\n      where: {\n        workspaceId,\n        recipientId: userId\n      }\n    })\n\n    if (!workspace) {\n      const workspace = await Workspace.findOne({\n        where: {\n          id: workspaceId,\n          userId\n        }\n      })\n\n      if (!workspace) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n      return true\n    }\n\n    return workspace[permission]\n  }\n\n  async downloadNote(note: Note, type: \"tpudoc\" | \"html\" | \"docx\") {\n    console.log(note.data, type)\n    switch (type) {\n      case \"tpudoc\": {\n        return note.data\n      }\n      case \"html\": {\n        return await this.downloadService.html(<NoteDataV2>note.data)\n      }\n      case \"docx\": {\n        return await this.downloadService.docx(<NoteDataV2>note.data)\n      }\n      default: {\n        throw new BadRequestError(\"Invalid type, must be tpudoc, html or docx\")\n      }\n    }\n  }\n}\n", "import { z } from \"zod\"\n\nexport const HostnameValidator = z.string().refine((value) => {\n  if (value === \"localhost\" || value === \"tpu\") return true\n  // Regular expression pattern for valid hostnames\n  const hostnameRegex = /^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n\n  // Check if the value matches the pattern and does not contain a protocol\n  return hostnameRegex.test(value) && !value.includes(\"://\")\n}, \"Invalid hostname\")\n\nexport const TpuConfigValidator = z.object({\n  hostnameWithProtocol: z.string().url(),\n  hostname: HostnameValidator,\n  maintenance: z.boolean(),\n  siteName: z.string(),\n  release: z.string(),\n  storage: z.string(),\n  jitsiToken: z.string().nullable().optional(),\n  registrations: z.boolean(),\n  mediaProxySecret: z.string(),\n  weatherApiKey: z.string().nullable().optional(),\n  providers: z.object({\n    tenor: z.string().nullable().optional(),\n    lastfm: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional(),\n    mal: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional(),\n    anilist: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional()\n  }),\n  redis: z.object({\n    username: z.string().nullable().optional(),\n    password: z.string().nullable().optional(),\n    host: z.string(),\n    db: z.number(),\n    port: z.number()\n  }),\n  email: z.object({\n    secure: z.boolean(),\n    username: z.string(),\n    password: z.string(),\n    from: z.string(),\n    host: z.string(),\n    port: z.number()\n  }),\n  discord: z.object({\n    webhook: z.string().nullable().optional(),\n    token: z.string().nullable().optional()\n  }),\n  officialInstance: z.boolean(),\n  port: z.union([z.number(), z.string().nullable().optional()]),\n  finishedSetup: z.boolean(),\n  threads: z.number(),\n  features: z.object({\n    communications: z.boolean(),\n    collections: z.boolean(),\n    autoCollects: z.boolean(),\n    workspaces: z.boolean(),\n    insights: z.boolean()\n  }),\n  defaultPlanId: z.number().nullable().optional(),\n  privacyNoteId: z.string().nullable().optional(),\n  termsNoteId: z.string().nullable().optional(),\n  inviteAFriend: z.boolean(),\n  hostnames: z.array(z.string()).optional(),\n  preTrustedDomains: z.array(z.string()).optional()\n})\n\nexport const TpuConfigValidatorPartial = TpuConfigValidator.partial()\n", "{\n  \"name\": \"tpu-frontend\",\n  \"version\": \"3.2.48\",\n  \"private\": true,\n  \"author\": \"Troplo <troplo@troplo.com>\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"serve\": \"vite\",\n    \"build-prod\": \"vue-tsc --noEmit && vite build && cp -r dist/* /var/www/html/tpu\",\n    \"build\": \"vue-tsc --noEmit && vite build\",\n    \"preview\": \"vite preview\",\n    \"lint\": \"eslint . --fix --ignore-path .gitignore\",\n    \"build-mobile\": \"CORDOVA=true vite build && rm -rf ./mobile/www && cp -r ./dist ./mobile/www\"\n  },\n  \"dependencies\": {\n    \"@codemirror/autocomplete\": \"^6.4.2\",\n    \"@codemirror/basic-setup\": \"^0.20.0\",\n    \"@codemirror/lang-css\": \"^6.1.1\",\n    \"@codemirror/view\": \"^6.9.3\",\n    \"@editorjs/attaches\": \"^1.3.0\",\n    \"@editorjs/checklist\": \"^1.4.0\",\n    \"@editorjs/code\": \"^2.8.0\",\n    \"@editorjs/delimiter\": \"^1.3.0\",\n    \"@editorjs/editorjs\": \"^2.26.5\",\n    \"@editorjs/embed\": \"^2.5.3\",\n    \"@editorjs/header\": \"^2.7.0\",\n    \"@editorjs/image\": \"^2.8.1\",\n    \"@editorjs/inline-code\": \"^1.4.0\",\n    \"@editorjs/link\": \"^2.5.0\",\n    \"@editorjs/list\": \"^1.8.0\",\n    \"@editorjs/marker\": \"^1.3.0\",\n    \"@editorjs/paragraph\": \"^2.9.0\",\n    \"@editorjs/quote\": \"^2.5.0\",\n    \"@editorjs/raw\": \"^2.4.0\",\n    \"@editorjs/table\": \"^2.2.0\",\n    \"@editorjs/warning\": \"^1.3.0\",\n    \"@guolao/vue-monaco-editor\": \"^1.1.2\",\n    \"@highlightjs/vue-plugin\": \"1.0.2\",\n    \"@mdi/font\": \"7.1.96\",\n    \"@svgmoji/noto\": \"^3.2.0\",\n    \"@troplo/tpu-editorjs-nested-list\": \"^1.3.0-troplo1\",\n    \"@troplo/tpu-simple-image\": \"^1.5.1-troplo1\",\n    \"@troplo/vite-version\": \"^1.0.3\",\n    \"@types/codeflask\": \"^1.4.3\",\n    \"@types/cypress\": \"^1.1.3\",\n    \"@types/dompurify\": \"^2.4.0\",\n    \"@types/markdown-it\": \"^12.2.3\",\n    \"@types/node\": \"^18.11.9\",\n    \"@types/textarea-caret\": \"^3.0.1\",\n    \"@types/vue-cropperjs\": \"^4.1.2\",\n    \"@types/webfontloader\": \"^1.6.35\",\n    \"@vitejs/plugin-vue\": \"^4.1.0\",\n    \"@vue/eslint-config-typescript\": \"^11.0.0\",\n    \"@vuetify/nightly\": \"npm:@vuetify/nightly@4.0.0-dev-20230512.0\",\n    \"apexcharts\": \"^3.37.0\",\n    \"axios\": \"^1.3.2\",\n    \"chart.js\": \"^4.2.1\",\n    \"codeflask\": \"^1.4.1\",\n    \"codemirror\": \"^6.0.1\",\n    \"core-js\": \"^3.8.3\",\n    \"cropperjs\": \"^1.5.13\",\n    \"dayjs\": \"^1.11.7\",\n    \"dompurify\": \"^3.0.0\",\n    \"editorjs-header-with-anchor\": \"^2.6.0\",\n    \"editorjs-html\": \"^3.4.3\",\n    \"editorjs-text-alignment-blocktune\": \"^1.0.3\",\n    \"editorjs-text-color-plugin\": \"^2.0.2\",\n    \"editorjs-undo\": \"^2.0.18\",\n    \"floating-vue\": \"^2.0.0-beta.20\",\n    \"markdown-it\": \"^13.0.1\",\n    \"markdown-it-emoji\": \"^2.0.2\",\n    \"markdown-it-unicode-emoji\": \"https://github.com/Troplo/markdown-it-unicode-emoji\",\n    \"monaco-editor\": \"^0.36.1\",\n    \"pinia\": \"^2.0.23\",\n    \"qrcode.vue\": \"^3.3.3\",\n    \"sass\": \"^1.55.0\",\n    \"socket.io-client\": \"^4.6.0\",\n    \"svgmoji\": \"^3.2.0\",\n    \"textarea-caret\": \"^3.1.0\",\n    \"typescript\": \"^4\",\n    \"vite\": \"^4.2.0\",\n    \"vite-plugin-pwa\": \"^0.14.4\",\n    \"vite-plugin-vuetify\": \"^1.0.2\",\n    \"vite-plugin-warmup\": \"^0.1.0\",\n    \"vue\": \"^3.2.13\",\n    \"vue-axios\": \"^3.5.2\",\n    \"vue-chartjs\": \"^5.2.0\",\n    \"vue-codemirror\": \"^6.1.1\",\n    \"vue-cropperjs\": \"^5.0.0\",\n    \"vue-draggable-plus\": \"^0.1.6\",\n    \"vue-i18n\": \"9\",\n    \"vue-matomo\": \"^4.2.0\",\n    \"vue-mention\": \"^2.0.0-alpha.3\",\n    \"vue-router\": \"^4.0.0\",\n    \"vue-toastification\": \"^2.0.0-rc.5\",\n    \"vue-tsc\": \"^1.0.9\",\n    \"vue3-apexcharts\": \"^1.4.1\",\n    \"vuetify\": \"^3.2.2\",\n    \"webfontloader\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"cypress\": \"^12.7.0\",\n    \"eslint\": \"^8.43.0\",\n    \"eslint-plugin-vue\": \"^9.3.0\",\n    \"rollup-plugin-visualizer\": \"^5.9.0\"\n  }\n}\n"], "fixing_code": ["import {\n  Body,\n  Delete,\n  ExpressMiddlewareInterface,\n  Get,\n  JsonController,\n  Middleware,\n  Param,\n  Params,\n  Patch,\n  Post,\n  Put,\n  Req,\n  Res,\n  UseBefore\n} from \"routing-controllers\"\nimport { Service } from \"typedi\"\nimport { Auth, authSystem } from \"@app/lib/auth\"\nimport { User } from \"@app/models/user.model\"\nimport { CoreService } from \"@app/services/core.service\"\nimport { CacheService } from \"@app/services/cache.service\"\nimport { Request, Response } from \"express\"\nimport Errors from \"@app/lib/errors\"\nimport { CacheType } from \"@app/enums/admin/CacheType\"\nimport { AdminService } from \"@app/services/admin.service\"\nimport { UserUtilsService } from \"@app/services/userUtils.service\"\nimport { Badge } from \"@app/models/badge.model\"\nimport { RequestAuth } from \"@app/types/express\"\nimport { Domain } from \"@app/models/domain.model\"\nimport { PulseService } from \"@app/services/pulse.service\"\nimport { TpuConfigValidator } from \"@app/validators/setup\"\nimport { SetupControllerV3 } from \"@app/controllers/v3/setup.controller\"\nimport { mergeDeep } from \"@app/lib/deepMerge\"\nimport { OauthApp } from \"@app/models/oauthApp.model\"\n\n@Service()\n@Middleware({ type: \"before\" })\nclass HighLevel implements ExpressMiddlewareInterface {\n  async use(\n    request: RequestAuth,\n    response: Response,\n    next: (err?: any) => any\n  ) {\n    const session = await authSystem(\n      \"admin\",\n      false,\n      request,\n      response,\n      () => {}\n    )\n    if (!session || !session.user?.administrator) {\n      throw Errors.ADMIN_ONLY\n    } else {\n      next()\n    }\n  }\n}\n\n@Service()\n@Middleware({ type: \"before\" })\nclass LowLevel implements ExpressMiddlewareInterface {\n  async use(\n    request: RequestAuth,\n    response: Response,\n    next: (err?: any) => any\n  ) {\n    await authSystem(\"admin\", false, request, response, () => {})\n    if (\n      !request.user ||\n      (!request.user?.administrator && !request.user?.moderator)\n    ) {\n      throw Errors.ADMIN_ONLY\n    } else {\n      next()\n    }\n  }\n}\n\n@Service()\n@JsonController(\"/admin\")\nexport class AdminControllerV3 {\n  constructor(\n    private readonly adminService: AdminService,\n    private readonly cacheService: CacheService,\n    private readonly userUtilsService: UserUtilsService,\n    private readonly coreService: CoreService,\n    private readonly pulseService: PulseService,\n    private readonly setupController: SetupControllerV3\n  ) {}\n\n  @Get(\"/dashboard\")\n  @UseBefore(LowLevel)\n  async getDashboard(@Auth(\"*\") user: User, @Req() req: Request) {\n    return {}\n  }\n\n  @Delete(\"/communications/message/:messageId\")\n  @UseBefore(HighLevel)\n  async deleteCommunicationsMessage(\n    @Auth(\"*\") user: User,\n    @Param(\"messageId\") messageId: number\n  ) {\n    await this.adminService.deleteCommunicationsMessage(messageId)\n    return\n  }\n\n  @Delete(\"/cache/:key\")\n  @Delete(\"/cache/:key/:uid?\")\n  @UseBefore(LowLevel)\n  async deleteCache(\n    @Auth(\"*\") user: User,\n    @Param(\"key\") key: CacheType,\n    @Params() { uid }: { uid?: number }\n  ) {\n    if (uid) {\n      this.adminService.purgeUserCache(uid)\n      return\n    } else {\n      this.adminService.purgeCache(key)\n      return\n    }\n  }\n\n  @Get(\"/users\")\n  @UseBefore(LowLevel)\n  async getUsers(@Auth(\"*\") user: User) {\n    return await this.adminService.getUsers()\n  }\n\n  @Get(\"/invites\")\n  @UseBefore(LowLevel)\n  async getInvites(@Auth(\"*\") user: User) {\n    return await this.adminService.getInvites()\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/invites/:inviteKey\")\n  async updateInvite(\n    @Auth(\"*\") user: User,\n    @Param(\"inviteKey\") inviteKey: string,\n    @Body()\n    body: {\n      type: \"accepted\" | \"rejected\"\n    }\n  ) {\n    const invite = await this.adminService.actOnInvite(inviteKey, body.type)\n    if (!invite) throw Errors.INVITE_NOT_FOUND\n    this.cacheService.purgeInvite(inviteKey)\n    if (body.type === \"accepted\") {\n      this.adminService.sendEmail(\n        {\n          body: {\n            intro: `Your friend ${invite.user.username} has invited you to join TPU.`,\n            action: [\n              {\n                instructions: `TPU is a free invite-only image and file hosting service.`,\n                button: {\n                  color: \"#0190ea\", // Optional action button color\n                  text: \"Create your account\",\n                  link:\n                    config.hostnameWithProtocol + \"/invite/\" + invite.inviteKey\n                }\n              },\n              {\n                instructions: \"Want to learn more about the advantages of TPU?\",\n                button: {\n                  color: \"#0190ea\", // Optional action button color\n                  text: \"Learn more\",\n                  link: \"https://images.flowinity.com\"\n                }\n              }\n            ],\n            outro:\n              \"If you do not intend to create an account, you can ignore this email.\"\n          }\n        },\n        invite.email,\n        `Your friend ${invite.user.username} has invited you to join TPU`\n      )\n      return\n    }\n    this.adminService.sendEmail(\n      {\n        body: {\n          intro: `Your invite request has been ${body.type}.`,\n          action: [\n            {\n              instructions: `The invite request to your friend ${invite.email} has been ${body.type}.`,\n              button: {\n                color: \"#0190ea\", // Optional action button color\n                text: \"Go to TPU\",\n                link: config.hostnameWithProtocol\n              }\n            }\n          ]\n        }\n      },\n      invite.user.email,\n      `Your TPU invite request has been ${body.type}.`\n    )\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/feedback\")\n  async getFeedback(@Auth(\"*\") user: User) {\n    return await this.adminService.getFeedback()\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/csv/uploads\")\n  async getUploadsCSV(@Auth(\"*\") user: User, @Res() res: Response) {\n    const csv = await this.adminService.exportCSVUploads()\n    res.setHeader(\"Content-Type\", \"text/csv\")\n    res.setHeader(\"Content-Disposition\", \"attachment; filename=uploads.csv\")\n    res.send(csv)\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/ban\")\n  async banUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      banned: boolean\n    }\n  ) {\n    if (!body.id) throw Errors.INVALID_PARAMETERS\n    await this.adminService.updateBanned(body.id, body.banned)\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge\")\n  async createBadge(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Badge\n  ) {\n    await this.adminService.createBadge(\n      body.name,\n      body.description,\n      body.icon,\n      body.color,\n      body.tooltip,\n      body.image\n    )\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge/users\")\n  async createBadgeUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      userIds: number[]\n    }\n  ) {\n    await this.adminService.addUsersToBadge(body.userIds, body.id)\n  }\n\n  @UseBefore(LowLevel)\n  @Put(\"/badge\")\n  async updateBadge(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Badge\n  ) {\n    await this.adminService.updateBadge(body)\n  }\n\n  @UseBefore(LowLevel)\n  @Delete(\"/badge/:id\")\n  async deleteBadge(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteBadge(id)\n  }\n\n  @UseBefore(LowLevel)\n  @Get(\"/badges\")\n  async getBadges(@Auth(\"*\") user: User) {\n    return await this.adminService.getBadges()\n  }\n\n  @UseBefore(LowLevel)\n  @Post(\"/badge/users/delete\")\n  async deleteBadgeUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      userIds: number[]\n    }\n  ) {\n    await this.adminService.removeUsersFromBadge(body.userIds, body.id)\n  }\n\n  @UseBefore(LowLevel)\n  @Patch(\"/verify\")\n  async verifyUser(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      emailVerified: boolean\n    }\n  ) {\n    if (!body.id) throw Errors.INVALID_PARAMETERS\n    await this.adminService.verify(body.id, body.emailVerified)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/announcement\")\n  async createAnnouncement(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      content: string\n    }\n  ) {\n    const announcement = await this.adminService.createAnnouncement(\n      body.content,\n      user.id\n    )\n    this.cacheService.refreshState()\n    return announcement\n  }\n\n  @UseBefore(HighLevel)\n  @Patch(\"/announcement\")\n  async editAnnouncement(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      content: string\n      id: number\n    }\n  ) {\n    const announcement = await this.adminService.editAnnouncement(\n      body.id,\n      body.content,\n      user.id\n    )\n    this.cacheService.refreshState()\n    return announcement\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/announcement/:id\")\n  async deleteAnnouncement(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteAnnouncement(id)\n    this.cacheService.refreshState()\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/notification\")\n  async createNotification(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      username: string\n      content: string\n      link: string\n    }\n  ) {\n    if (body.username === \"allOfThem\") {\n      // todo: optimize\n      const users = await User.findAll()\n      for (const user of users) {\n        await this.userUtilsService.createNotification(\n          user.id,\n          body.content,\n          body.link\n        )\n      }\n      return\n    }\n    const rUser = await User.findOne({\n      where: {\n        username: body.username\n      }\n    })\n\n    if (!rUser) {\n      throw Errors.USER_NOT_FOUND\n    }\n\n    await this.userUtilsService.createNotification(\n      rUser.id,\n      body.content,\n      body.link\n    )\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/experiments/:userId\")\n  async getExperiments(@Auth(\"*\") user: User, @Param(\"userId\") userId: number) {\n    const rUser = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n    if (!rUser) throw Errors.USER_NOT_FOUND\n    const dev = user ? rUser.administrator || rUser.moderator : false\n    const experiment = await this.coreService.getUserExperiments(rUser.id, dev)\n    return {\n      ...experiment,\n      defaults: this.coreService.getExperiments(dev)\n    }\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/experiments/:userId\")\n  async setExperiments(\n    @Auth(\"*\") user: User,\n    @Param(\"userId\") userId: number,\n    @Body()\n    body: Record<string, boolean | number | undefined | null>\n  ) {\n    const rUser = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n    if (!rUser) throw Errors.USER_NOT_FOUND\n    const dev = user ? rUser.administrator || rUser.moderator : false\n    const currentExperiments = await this.coreService.getUserExperiments(\n      userId,\n      dev\n    )\n    return await this.adminService.createExperimentOverrides(\n      currentExperiments,\n      body,\n      user.id,\n      dev\n    )\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/restart\")\n  async restartTPUCluster(@Auth(\"admin.ci\") user: User) {\n    if (!process.send) throw Errors.UNKNOWN\n    console.log(\"Restarting TPU\")\n    process.send(\"TPU_RESTART\")\n  }\n\n  @UseBefore(HighLevel)\n  @Patch(\"/gold\")\n  async updateUserGold(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: {\n      id: number\n      planId: number\n    }\n  ) {\n    if (!body.id || !body.planId) throw Errors.INVALID_PARAMETERS\n    await this.adminService.updatePlanId(body.id, body.planId)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/domain\")\n  async updateDomain(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Domain\n  ) {\n    await this.adminService.updateDomain(body)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/domain\")\n  async createDomain(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Domain\n  ) {\n    await this.adminService.createDomain(body.domain, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/domain/:id\")\n  async deleteDomain(@Auth(\"*\") user: User, @Param(\"id\") id: number) {\n    await this.adminService.deleteDomain(id)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/insights/regenerate\")\n  async regenerateInsights(@Auth(\"*\") user: User) {\n    this.pulseService.regenerateAll()\n  }\n\n  redactConfig(tpuConfig: any, deleteRedacted = false) {\n    const loop = Object.entries(tpuConfig)\n    for (let [key, value] of loop) {\n      if (\n        typeof tpuConfig[key] === \"object\" &&\n        !Array.isArray(tpuConfig[key])\n      ) {\n        value = this.redactConfig(tpuConfig[key], deleteRedacted)\n      }\n      if (\n        [\"password\", \"token\", \"secret\", \"key\", \"tenor\", \"webhook\"].some((s) =>\n          key.toLowerCase().includes(s)\n        ) &&\n        !deleteRedacted\n      ) {\n        if (typeof tpuConfig[key] === \"string\" && !deleteRedacted) {\n          tpuConfig[key] = \"[REDACTED]\"\n        }\n      } else if (deleteRedacted && tpuConfig[key] === \"[REDACTED]\") {\n        console.log(\"deleting\", key)\n        delete tpuConfig[key]\n      }\n    }\n    return tpuConfig\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/config\")\n  async getConfig(@Auth(\"*\") user: User) {\n    let tpuConfig: Partial<TpuConfig> = structuredClone(global.config)\n    delete tpuConfig.mediaProxySecret\n    delete tpuConfig.jitsiToken\n    tpuConfig = this.redactConfig(tpuConfig)\n    return tpuConfig\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/config\")\n  async updateConfig(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: TpuConfig\n  ) {\n    const tpuConfig = mergeDeep(\n      structuredClone(global.config),\n      this.redactConfig(body, true)\n    )\n    console.log(tpuConfig)\n    TpuConfigValidator.parse(tpuConfig)\n    await this.setupController.writeTPUConfig(tpuConfig)\n    this.cacheService.refreshState()\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/oauth\")\n  async getOauth(@Auth(\"*\") user: User) {\n    return await this.adminService.getOauth()\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/oauth\")\n  async createOauth(\n    @Auth(\"*\") user: User,\n    @Body()\n    body: Partial<OauthApp>\n  ) {\n    return await this.adminService.createOauth(body, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Get(\"/oauth/:id\")\n  async getOauthById(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.getOauthById(id)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/oauth/:id\")\n  async updateOauth(\n    @Auth(\"*\") user: User,\n    @Param(\"id\") id: string,\n    @Body()\n    body: Partial<OauthApp>\n  ) {\n    return await this.adminService.updateOauth(body, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Post(\"/oauth/:id/user\")\n  async createOauthUser(\n    @Auth(\"*\") user: User,\n    @Param(\"id\") id: string,\n    @Body()\n    body: {\n      username: string\n    }\n  ) {\n    return await this.adminService.createOauthUser(id, body.username, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Put(\"/oauth/:id/secret\")\n  async resetOauthSecret(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.resetOauthSecret(id, user.id)\n  }\n\n  @UseBefore(HighLevel)\n  @Delete(\"/oauth/:id\")\n  async deleteOauth(@Auth(\"*\") user: User, @Param(\"id\") id: string) {\n    return await this.adminService.deleteOauth(id, user.id)\n  }\n}\n", "import {\n  Body,\n  Controller,\n  Delete,\n  Get,\n  JsonController,\n  Param,\n  Patch,\n  Post,\n  QueryParam,\n  Res\n} from \"routing-controllers\"\nimport { Service } from \"typedi\"\nimport { Auth } from \"@app/lib/auth\"\nimport Errors from \"@app/lib/errors\"\nimport { User } from \"@app/models/user.model\"\nimport { NoteDataV2, NoteService } from \"@app/services/note.service\"\nimport { Response } from \"express\"\nimport JSZip from \"jszip\"\n\n@Service()\n@JsonController(\"/notes\")\nexport class WorkspaceControllerV3 {\n  constructor(private readonly noteService: NoteService) {}\n\n  @Get(\"/workspaces\")\n  async getWorkspaces(@Auth(\"workspaces.view\") user: User) {\n    return await this.noteService.getWorkspaces(user.id)\n  }\n\n  @Post(\"/workspaces\")\n  async createWorkspace(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.createWorkspace(body.name, user.id)\n  }\n\n  @Get(\"/workspace/:workspaceId\")\n  async getWorkspace(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"workspaceId\") workspaceId: number\n  ) {\n    return await this.noteService.getWorkspace(\n      workspaceId,\n      user.id,\n      \"workspace\"\n    )\n  }\n\n  @Get(\"/recent\")\n  async getRecentNotes(@Auth(\"workspaces.view\") user: User) {\n    return await this.noteService.getRecent(user.id)\n  }\n\n  @Get(\"/:noteId\")\n  async getNote(\n    @Auth(\"workspaces.view\", false) user: User,\n    @Param(\"noteId\") noteId: number | string\n  ) {\n    return await this.noteService.getNote(noteId, user?.id)\n  }\n\n  @Patch(\"/:noteId\")\n  async updateNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @Body()\n    body: {\n      name?: string\n      data?: NoteDataV2\n      manualSave?: boolean\n    }\n  ) {\n    if (body.name && !body.data) {\n      return await this.noteService.renameNote(noteId, body.name, user.id)\n    }\n\n    if (body.data) {\n      return await this.noteService.saveNote(\n        noteId,\n        body.data,\n        user.id,\n        body.manualSave,\n        body.name\n      )\n    }\n\n    throw Errors.INVALID_PARAMETERS\n  }\n\n  @Patch(\"/workspaces/:workspaceId\")\n  async updateWorkspace(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"workspaceId\") workspaceId: number,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.renameWorkspace(\n      workspaceId,\n      body.name,\n      user.id\n    )\n  }\n\n  @Post(\"\")\n  async createNote(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n      workspaceFolderId: number\n    }\n  ) {\n    return await this.noteService.createNote(\n      body.name,\n      body.workspaceFolderId,\n      user.id\n    )\n  }\n\n  @Patch(\"/:id/share\")\n  async shareNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.toggleShareLink(id, user.id)\n  }\n\n  @Post(\"/folder\")\n  async createFolder(\n    @Auth(\"workspaces.create\") user: User,\n    @Body()\n    body: {\n      name: string\n      workspaceId: number\n    }\n  ) {\n    return await this.noteService.createFolder(\n      body.name,\n      body.workspaceId,\n      user.id\n    )\n  }\n\n  @Delete(\"/:id\")\n  async deleteNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteNote(id, user.id)\n  }\n\n  @Delete(\"/workspace/:id\")\n  async deleteWorkspace(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteWorkspace(id, user.id)\n  }\n\n  @Delete(\"/folder/:id\")\n  async deleteFolder(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number\n  ) {\n    return await this.noteService.deleteFolder(id, user.id)\n  }\n\n  @Patch(\"/folder/:id\")\n  async updateFolder(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"id\") id: number,\n    @Body()\n    body: {\n      name: string\n    }\n  ) {\n    return await this.noteService.renameFolder(id, body.name, user.id)\n  }\n\n  @Get(\"/folder/:id/download\")\n  async downloadFolder(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"id\") id: number,\n    @QueryParam(\"type\") type: \"tpudoc\" | \"html\" | \"docx\",\n    @Res() res: Response\n  ) {\n    const folder = await this.noteService.getFolder(id, user.id)\n    const zip: JSZip = new JSZip()\n    for (const { dataValues } of folder.children) {\n      try {\n        const data = await this.noteService.downloadNote(dataValues, type)\n        zip.file(\n          `${dataValues.name\n            .replaceAll(\"/\", \"-\")\n            .replaceAll(\"\\\\\", \"-\")}.${type}`,\n          data\n        )\n      } catch (e) {\n        console.error(e)\n      }\n    }\n    const data = await zip.generateAsync({ type: \"nodebuffer\" })\n    return res.contentType(\"application/octet-stream\").send(data)\n  }\n\n  @Patch(\"/:noteId/restore/:versionId\")\n  async restoreNote(\n    @Auth(\"workspaces.modify\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @Param(\"versionId\") versionId: string\n  ) {\n    await this.noteService.restoreVersion(noteId, versionId, user.id)\n  }\n\n  @Get(\"/:noteId/download\")\n  async downloadNote(\n    @Auth(\"workspaces.view\") user: User,\n    @Param(\"noteId\") noteId: number,\n    @QueryParam(\"type\") type: \"tpudoc\" | \"html\" | \"docx\",\n    @Res() res: Response\n  ) {\n    const note = await this.getNote(user, noteId)\n    if (!note?.permissions?.read) throw Errors.NOT_FOUND\n\n    const data = await this.noteService.downloadNote(note, type)\n    return res.contentType(\"application/octet-stream\").send(data)\n  }\n\n  // TPU Workspaces collaboration sharing code -- to port from v2 to v3\n  /*\n      this.router.all(\n      \"/workspace/:id/*\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          if (!req.user.administrator) throw Errors.COMING_SOON\n          const id = parseInt(req.params.id)\n          const check = await this.noteService.getWorkspacePermissions(\n            id,\n            req.user.id,\n            \"configure\"\n          )\n          if (!check) throw Errors.WORKSPACE_NO_PERMISSION\n          next()\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.post(\n      \"/workspace/:id/user\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const { username } = req.body\n          await this.noteService.addUserToWorkspace(\n            id,\n            req.user.id,\n            username,\n            req.body.write,\n            req.body.configure,\n            true\n          )\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.delete(\n      \"/workspace/:id/user/:userId\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const userId = parseInt(req.params.userId)\n          await this.noteService.removeUserFromWorkspace(id, userId)\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n\n    this.router.patch(\n      \"/workspace/:id/user\",\n      auth(\"workspaces.modify\"),\n      async (req: RequestAuth, res: Response, next: NextFunction) => {\n        try {\n          const id = parseInt(req.params.id)\n          const userId = req.body.id\n          await this.noteService.updateUser(\n            id,\n            userId,\n            req.body.write,\n            req.body.configure,\n            true\n          )\n          res.sendStatus(204)\n        } catch (e) {\n          next(e)\n        }\n      }\n    )\n   */\n}\n", "import { Container, Service } from \"typedi\"\nimport { CacheService } from \"@app/services/cache.service\"\nimport { User } from \"@app/models/user.model\"\nimport { Invite } from \"@app/models/invite.model\"\nimport Mailgen from \"mailgen\"\nimport nodemailer from \"nodemailer\"\nimport { Announcement } from \"@app/models/announcement.model\"\nimport { Experiment } from \"@app/models/experiment.model\"\nimport { CoreService } from \"@app/services/core.service\"\nimport { Feedback } from \"@app/models/feedback.model\"\nimport { Upload } from \"@app/models/upload.model\"\nimport path from \"path\"\nimport * as fs from \"fs\"\nimport { Friend } from \"@app/models/friend.model\"\nimport Errors from \"@app/lib/errors\"\nimport { Collection } from \"@app/models/collection.model\"\nimport { AutoCollectApproval } from \"@app/models/autoCollectApproval.model\"\nimport { Op } from \"sequelize\"\nimport { Chat } from \"@app/models/chat.model\"\nimport { Badge } from \"@app/models/badge.model\"\nimport { BadgeAssociation } from \"@app/models/badgeAssociation.model\"\nimport { AutoCollectRule } from \"@app/models/autoCollectRule.model\"\nimport { ChatAssociation } from \"@app/models/chatAssociation.model\"\nimport { LegacyUser } from \"@app/models/legacyUser.model\"\nimport { Message } from \"@app/models/message.model\"\nimport { CacheType } from \"@app/enums/admin/CacheType\"\nimport { Domain } from \"@app/models/domain.model\"\nimport { OauthApp } from \"@app/models/oauthApp.model\"\nimport cryptoRandomString from \"crypto-random-string\"\nimport utils from \"@app/lib/utils\"\nimport { OauthUser } from \"@app/models/oauthUser.model\"\nimport { Session } from \"@app/models/session.model\"\nimport { OauthSave } from \"@app/models/oauthSave.model\"\n\nconst inviteParams = {\n  include: [\n    {\n      model: User,\n      as: \"user\",\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    },\n    {\n      model: User,\n      as: \"invited\",\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    }\n  ],\n  attributes: [\n    \"id\",\n    \"email\",\n    \"adminId\",\n    \"inviteKey\",\n    \"status\",\n    \"userId\",\n    \"registerUserId\",\n    \"createdAt\",\n    \"updatedAt\"\n  ]\n}\n\n@Service()\nexport class AdminService {\n  constructor(private readonly cacheService: CacheService) {}\n\n  async getFeedback() {\n    return await Feedback.findAll({\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ],\n      order: [[\"createdAt\", \"DESC\"]]\n    })\n  }\n\n  async createAnnouncement(\n    content: string,\n    userId: number\n  ): Promise<Announcement> {\n    return await Announcement.create({\n      content,\n      userId\n    })\n  }\n\n  async editAnnouncement(\n    id: number,\n    content: string,\n    userId: number\n  ): Promise<Announcement> {\n    const announcement = await Announcement.findOne({\n      where: {\n        id\n      }\n    })\n    if (!announcement || announcement.userId !== userId) throw Errors.NOT_FOUND\n    await announcement.update({\n      content\n    })\n    return announcement\n  }\n\n  async deleteAnnouncement(id: number): Promise<boolean> {\n    const announcement = await Announcement.findOne({\n      where: {\n        id\n      }\n    })\n    if (!announcement) throw Errors.NOT_FOUND\n    await announcement.destroy()\n    return true\n  }\n\n  async getInvites() {\n    return Invite.findAll({\n      ...inviteParams\n    })\n  }\n\n  async actOnInvite(\n    inviteKey: string,\n    action: \"accepted\" | \"rejected\"\n  ): Promise<Invite | null> {\n    await Invite.update(\n      {\n        status: action\n      },\n      {\n        where: {\n          inviteKey\n        }\n      }\n    )\n    return await Invite.findOne({\n      where: {\n        inviteKey\n      },\n      ...inviteParams\n    })\n  }\n\n  async getUsers() {\n    return User.findAll({\n      attributes: {\n        exclude: [\"emailToken\", \"storedStatus\"]\n      }\n    })\n  }\n\n  async getStats() {\n    //TODO\n    return {\n      tpu: {\n        users: await User.count(),\n        uploads: await Upload.count(),\n        friends: await Friend.count(),\n        invites: await Invite.count(),\n        feedback: await Feedback.count(),\n        announcements: await Announcement.count(),\n        experiments: await Experiment.count(),\n        collections: await Collection.count(),\n        shareLinks: await Collection.count({\n          where: {\n            shareLink: {\n              [Op.ne]: null\n            }\n          }\n        }),\n        autoCollects: await AutoCollectApproval.count(),\n        chats: await Chat.count(),\n        uploadsSize: await Upload.sum(\"fileSize\")\n      },\n      system: {\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        cpu: process.cpuUsage()\n      }\n    }\n  }\n\n  async purgeCache(type: CacheType) {\n    switch (type) {\n      case CacheType.everything:\n        await this.cacheService.refreshState()\n        await this.cacheService.generateCollectionCache()\n        await this.cacheService.generateShareLinkCache()\n        return true\n      case CacheType.state:\n        await this.cacheService.refreshState()\n        return true\n      case CacheType.collections:\n        await this.cacheService.generateCollectionCache()\n        return true\n      case CacheType.sharelinks:\n        await this.cacheService.generateShareLinkCache()\n        return true\n      case CacheType.autocollects:\n        await this.cacheService.generateAutoCollectCache()\n        return true\n      case CacheType.invites:\n        await redis.del(\"invites\")\n        return true\n      case CacheType.chats:\n        await this.cacheService.generateChatsCache()\n        return true\n      case CacheType.insights:\n        await this.cacheService.generateInsightsCache()\n        return true\n      case CacheType.userstats:\n        await this.cacheService.generateUserStatsCache()\n        return true\n      case CacheType.lastfm:\n        console.log(\"[AdminService] Purging lastfm cache\")\n        await redis.del(\"providers:lastfm:*\")\n        return true\n      case CacheType.mal:\n        console.log(\"[AdminService] Purging mal cache\")\n        await redis.del(\"providers:mal:*\")\n        return true\n      default:\n        return false\n    }\n  }\n\n  async purgeUserCache(id: number) {\n    await this.cacheService.generateCollectionCacheForUser(id)\n    return true\n  }\n\n  async sendEmail(\n    mail: Mailgen.Content,\n    email: string,\n    subject: string,\n    customConfig?: {\n      host: string\n      port: number\n      secure: boolean\n      username: string\n      password: string\n      from: string\n    }\n  ) {\n    console.log(\"[AdminService] Sending email to\", email)\n    let mailGenerator = new Mailgen({\n      theme: \"cerberus\",\n      product: {\n        name: config.siteName,\n        link: config.hostnameWithProtocol\n      }\n    })\n    let emailBody = mailGenerator.generate(mail)\n    let emailText = mailGenerator.generatePlaintext(mail)\n    let transporter = nodemailer.createTransport({\n      host: customConfig?.host || config.email.host,\n      port: customConfig?.port || config.email.port,\n      secure: customConfig?.secure || config.email.secure,\n      auth: {\n        user: customConfig?.username || config.email.username,\n        pass: customConfig?.password || config.email.password\n      }\n    })\n    return await transporter.sendMail({\n      from: customConfig?.from || config.email.from,\n      to: email,\n      subject: subject,\n      text: emailText,\n      html: emailBody\n    })\n  }\n\n  async createExperimentOverrides(\n    currentExperiments: Record<\n      string,\n      string | number | boolean | undefined | null\n    >,\n    overrides: { [key: string]: string | number | boolean | undefined | null },\n    userId: number,\n    dev: boolean = false\n  ) {\n    const experiments = Object.entries(overrides).reduce(\n      (acc: Record<string, any>, [name, value]: any) => {\n        try {\n          if (name === \"meta\") return acc\n          const val = JSON.parse(<string>value)\n          if (val !== currentExperiments[name] && value !== \"destroy\") {\n            acc[name] = val\n          }\n          return acc\n        } catch {\n          if (value !== currentExperiments[name] && value !== \"destroy\") {\n            acc[name] = value\n          }\n          return acc\n        }\n      },\n      {}\n    )\n    const experimentsToDelete = Object.entries(overrides).reduce(\n      (acc, [name, value]) => {\n        if (value === \"destroy\") {\n          acc.push(name)\n        }\n        return acc\n      }\n    )\n    for (const experiment of experimentsToDelete) {\n      await Experiment.destroy({\n        where: {\n          key: experiment,\n          userId\n        }\n      })\n    }\n\n    for (const [key, value] of Object.entries(experiments)) {\n      await Experiment.create({\n        key,\n        value: JSON.stringify(value),\n        userId\n      })\n    }\n    const coreService = Container.get(CoreService)\n    return await coreService.getUserExperiments(userId, dev)\n  }\n\n  async exportCSVUploads() {\n    let uploads = await Upload.findAll({\n      attributes: [\"createdAt\", \"id\"],\n      order: [[\"createdAt\", \"DESC\"]],\n      raw: true\n    })\n\n    let data = uploads.reduce((acc: any, upload) => {\n      const date = dayjs(upload.createdAt).format(\"YYYY-MM-DD\")\n      if (date === \"Invalid Date\") return acc\n      if (!acc[date]) {\n        acc[date] = 1\n      } else {\n        acc[date]++\n      }\n      return acc\n    })\n\n    return Object.entries(data)\n      .map(([date, count]) => `${date},${count}`)\n      .join(\"\\n\")\n  }\n\n  async getServices() {\n    // get all typedi service functions\n    const container = Container as any\n    const services = container?.globalInstance?.services\n    if (!services) return []\n    const serviceNames = Object.keys(services)\n    const serviceFunctions = serviceNames.map((name) => {\n      return services[name]\n    })\n    // get all typedi service names\n    let serviceNamesWithTypes = serviceFunctions.map((service) => {\n      return {\n        name: service.type.name,\n        functions: [] as (string[] | null)[]\n      }\n    })\n    for (const service of serviceNamesWithTypes) {\n      // contains controller, application or server\n      if (\n        service.name.toLowerCase().includes(\"controller\") ||\n        service.name.toLowerCase().includes(\"application\") ||\n        service.name.toLowerCase().includes(\"server\")\n      )\n        continue\n      const name =\n        service.name.charAt(0).toLowerCase() +\n        service.name.slice(1).replace(\"Service\", \".service\")\n      const file = fs.readFileSync(\n        path.join(__dirname, `../../app/services/${name}.ts`),\n        \"utf8\"\n      )\n      // get the function names and also provide the parameters like {\"name\": \"yes\", \"params\": {\"id\": \"number\"}}]}\n      let functionNames\n      try {\n        functionNames = file\n          .split(\"\\n\")\n          .filter((line) => line.includes(\"async\"))\n          .map((line) => {\n            const functionName = line.split(\"async \")[1].split(\"(\")[0]\n            const params = line\n              .split(\"(\")[1]\n              .split(\")\")[0]\n              .split(\",\")\n              .map((param) => {\n                const name = param.split(\":\")[0]?.trim()\n                const type = param.split(\":\")[1]?.trim()\n                return {\n                  name,\n                  type\n                }\n              })\n            return {\n              name: functionName,\n              params\n            }\n          })\n      } catch {}\n      if (!functionNames) continue\n      // @ts-ignore\n      service.functions = functionNames\n    }\n    return serviceNamesWithTypes\n  }\n\n  //dev\n  async devAcceptFriends() {\n    await Friend.update(\n      {\n        status: \"accepted\"\n      },\n      {\n        where: {}\n      }\n    )\n  }\n\n  async updatePlanId(userId: number, planId: number) {\n    const user = await User.findByPk(userId)\n    if (!user) throw Errors.USER_NOT_FOUND\n    if (userId === 6 && planId === 6 && config.officialInstance) {\n      throw Errors.HANDLED_BY_PAYMENT_PROVIDER\n    }\n    await User.update(\n      {\n        planId\n      },\n      {\n        where: {\n          id: userId\n        }\n      }\n    )\n    return true\n  }\n\n  async updateBanned(userId: number, banned: boolean) {\n    const user = await User.findByPk(userId)\n    if (!user) throw Errors.USER_NOT_FOUND\n    if (user.administrator || user.moderator) throw Errors.MANUAL_BAN_REQUIRED\n    await User.update(\n      {\n        banned\n      },\n      {\n        where: {\n          id: userId\n        }\n      }\n    )\n    return true\n  }\n\n  async createBadge(\n    name: string,\n    description: string,\n    icon: string,\n    color: string,\n    tooltip: string,\n    image: string\n  ) {\n    return await Badge.create({\n      name,\n      description,\n      icon,\n      color,\n      tooltip,\n      image\n    })\n  }\n\n  async addUsersToBadge(userIds: number[], badgeId: number) {\n    for (const userId of userIds) {\n      await BadgeAssociation.create({\n        userId,\n        badgeId\n      })\n    }\n    return true\n  }\n\n  async getBadges() {\n    return await Badge.findAll({\n      include: [\n        {\n          model: User,\n          as: \"users\",\n          attributes: [\"id\", \"username\", \"avatar\"]\n        }\n      ]\n    })\n  }\n\n  async updateBadge(badge: Badge) {\n    await Badge.update(\n      {\n        ...badge\n      },\n      {\n        where: {\n          id: badge.id\n        }\n      }\n    )\n    return true\n  }\n\n  async deleteBadge(badgeId: number) {\n    await Badge.destroy({\n      where: {\n        id: badgeId\n      }\n    })\n    await BadgeAssociation.destroy({\n      where: {\n        badgeId\n      }\n    })\n    return true\n  }\n\n  async removeUsersFromBadge(userIds: number[], badgeId: number) {\n    for (const userId of userIds) {\n      await BadgeAssociation.destroy({\n        where: {\n          userId,\n          badgeId\n        }\n      })\n    }\n    return true\n  }\n\n  // AutoCollect\n  async getAutoCollectRules() {\n    return await User.findAll({\n      attributes: [\"id\", \"username\", \"avatar\"],\n      include: [\n        {\n          model: AutoCollectRule,\n          as: \"autoCollectRules\"\n        }\n      ]\n    })\n  }\n\n  // --SCRIPTS--\n  async scriptFindChats(\n    type: undefined | \"group\" | \"direct\" | \"channel\" = undefined\n  ) {\n    return await Chat.findAll({\n      where: {\n        type\n      },\n      include: [\n        {\n          model: ChatAssociation,\n          as: \"users\",\n          attributes: [\n            \"id\",\n            \"userId\",\n            \"user\",\n            \"rank\",\n            \"legacyUserId\",\n            \"lastRead\",\n            \"createdAt\",\n            \"updatedAt\"\n          ],\n          include: [\n            {\n              model: User,\n              as: \"tpuUser\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            },\n            {\n              model: LegacyUser,\n              as: \"legacyUser\",\n              attributes: [\"id\", \"username\", \"createdAt\", \"updatedAt\", \"avatar\"]\n            }\n          ]\n        }\n      ]\n    })\n  }\n\n  async scriptColubrinaGroupOwner() {\n    const chats = await this.scriptFindChats(\"group\")\n    for (const chat of chats) {\n      // if the chat has no owners\n      if (!chat.users.find((user) => user.rank === \"owner\")) {\n        // get the owner\n        const owner = chat.users.find(\n          (user) => user.tpuUser?.id === chat.userId\n        )\n        if (owner?.tpuUser) {\n          await ChatAssociation.update(\n            {\n              rank: \"owner\"\n            },\n            {\n              where: {\n                id: owner.id\n              }\n            }\n          )\n        } else {\n          // make a random admin the owner\n          const admin = chat.users.find((user) => user.rank === \"admin\")\n          if (admin?.tpuUser) {\n            await ChatAssociation.update(\n              {\n                rank: \"owner\"\n              },\n              {\n                where: {\n                  id: admin.id\n                }\n              }\n            )\n          } else {\n            const user = chat.users.find((user) => user.rank === \"member\")\n            if (user?.tpuUser) {\n              await ChatAssociation.update(\n                {\n                  rank: \"owner\"\n                },\n                {\n                  where: {\n                    id: user.id\n                  }\n                }\n              )\n            } else {\n              console.log(\"no users in chat\", chat.id)\n            }\n          }\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMOwners() {\n    const chats = await this.scriptFindChats(\"direct\")\n    for (const chat of chats) {\n      // if any of the chats have users of rank admin or owner, set them to member\n      for (const user of chat.users) {\n        if (user.rank === \"admin\" || user.rank === \"owner\") {\n          console.log(`changing ${user.user?.username} to member`)\n          await ChatAssociation.update(\n            {\n              rank: \"member\"\n            },\n            {\n              where: {\n                id: user.id\n              }\n            }\n          )\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMMerge() {\n    const chats = await this.scriptFindChats(\"direct\")\n    // if any of the chats have the same users, merge them\n    for (const chat of chats) {\n      for (const chat2 of chats) {\n        if (chat.id === chat2.id) continue\n        const users = chat.users.map((user) => user.tpuUser?.id)\n        const users2 = chat2.users.map((user) => user.tpuUser?.id)\n        if (users.length === users2.length) {\n          if (users.every((user) => users2.includes(user))) {\n            // if the users or users2 contains undefined, skip\n            if (users.includes(undefined) || users2.includes(undefined))\n              continue\n            if (users.length !== 2 || users2.length !== 2) continue\n            // delete the other chat from array\n            chats.splice(chats.indexOf(chat2), 1)\n            // merge the chats\n            console.log(\n              `merging ${chat.id} and ${chat2.id}, Users: ${users}, Users2: ${users2}`\n            )\n            await ChatAssociation.destroy({\n              where: {\n                chatId: chat2.id\n              }\n            })\n            await Message.update(\n              {\n                chatId: chat.id\n              },\n              {\n                where: {\n                  chatId: chat2.id\n                }\n              }\n            )\n            await Chat.destroy({\n              where: {\n                id: chat2.id\n              }\n            })\n          }\n        }\n      }\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async scriptColubrinaDMIntents() {\n    const chats = await this.scriptFindChats(\"direct\")\n    for (const chat of chats) {\n      if (chat.intent?.length) continue\n      const users = chat.users.map((user) => user.tpuUser?.id)\n      if (users.length !== 2 || users.includes(undefined)) continue\n      users.sort((a, b) => a - b)\n      console.log(`setting intent for ${chat.id} to ${users}`)\n      // set the intent\n      await Chat.update(\n        {\n          intent: users.join(\"-\")\n        },\n        {\n          where: {\n            id: chat.id\n          }\n        }\n      )\n    }\n    console.log(\"OK, clearing cache\")\n    this.purgeCache(6)\n  }\n\n  async deleteCommunicationsMessage(messageId: number) {\n    const message = await Message.findOne({\n      where: {\n        id: messageId\n      }\n    })\n\n    if (!message) throw Errors.MESSAGE_NOT_FOUND\n\n    await message.destroy()\n  }\n\n  async updateDomain(domain: Partial<Domain>) {\n    const domainInstance = await Domain.findOne({\n      where: {\n        id: domain.id\n      }\n    })\n\n    if (!domainInstance) throw Errors.DOMAIN_NOT_FOUND\n\n    await domainInstance.update({\n      domain: domain.domain\n    })\n  }\n\n  async createDomain(name: string, userId: number) {\n    return await Domain.create({\n      domain: name,\n      active: true,\n      DNSProvisioned: true,\n      userId\n    })\n  }\n\n  async deleteDomain(domainId: number) {\n    if (domainId === 1) throw Errors.CANNOT_DELETE_DEFAULT\n    return await Domain.destroy({\n      where: {\n        id: domainId\n      }\n    })\n  }\n\n  async verify(userId: number, emailVerified: boolean) {\n    const user = await User.findOne({\n      where: {\n        id: userId\n      }\n    })\n\n    if (!user || user.administrator || user.moderator)\n      throw Errors.USER_NOT_FOUND\n\n    await user.update({\n      emailVerified\n    })\n  }\n\n  async getOauth() {\n    return await OauthApp.findAll({\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ],\n      order: [[\"createdAt\", \"DESC\"]]\n    })\n  }\n\n  async createOauth(body: Partial<OauthApp>, userId: number) {\n    return await OauthApp.create({\n      name: body.name,\n      icon: body.icon,\n      // convert the name to a slug shortcode\n      shortCode:\n        body.name?.toLowerCase().replace(/ /g, \"-\") +\n        \"-\" +\n        cryptoRandomString({ length: 5 }),\n      verified: body.verified,\n      redirectUri: body.redirectUri,\n      secret: await utils.generateAPIKey(\"oauth\"),\n      description: body.description,\n      scopes: body.scopes,\n      userId: userId,\n      private: body.private\n    })\n  }\n\n  async getOauthById(id: string, userId?: number) {\n    return await OauthApp.findOne({\n      where: {\n        id,\n        ...(userId ? { userId } : {})\n      },\n      // include secret override\n      attributes: {\n        include: [\"secret\"]\n      },\n      include: [\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        },\n        {\n          model: OauthUser,\n          as: \"oauthUsers\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        }\n      ]\n    })\n  }\n\n  async updateOauth(body: Partial<OauthApp>, userId: number) {\n    const app = await this.getOauthById(body.id || \"\")\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.update({\n      name: body.name,\n      icon: body.icon,\n      verified: body.verified,\n      redirectUri: body.redirectUri,\n      description: body.description,\n      scopes: body.scopes,\n      private: body.private\n    })\n  }\n\n  async createOauthUser(appId: string, username: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    const user = await User.findOne({\n      where: {\n        username\n      }\n    })\n    if (!user || user.id === userId) throw Errors.USER_NOT_FOUND\n    const existence = await OauthUser.findOne({\n      where: {\n        userId: user.id,\n        oauthAppId: app.id\n      }\n    })\n    if (existence) {\n      await existence.destroy()\n      await Session.destroy({\n        where: {\n          oauthAppId: app.id,\n          userId: user.id,\n          type: \"oauth\"\n        }\n      })\n      return\n    }\n    await OauthUser.create({\n      userId: user.id,\n      oauthAppId: app.id,\n      active: true\n    })\n  }\n\n  async resetOauthSecret(appId: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.update({\n      secret: await utils.generateAPIKey(\"oauth\")\n    })\n  }\n\n  async deleteOauth(appId: string, userId: number) {\n    const app = await this.getOauthById(appId)\n    if (!app || app.userId !== userId) throw Errors.NOT_FOUND\n    await app.destroy()\n    await OauthUser.destroy({\n      where: {\n        oauthAppId: app.id\n      }\n    })\n    await Session.destroy({\n      where: {\n        oauthAppId: app.id,\n        type: \"oauth\"\n      }\n    })\n    await OauthSave.destroy({\n      where: {\n        oauthAppId: app.id\n      }\n    })\n  }\n}\n", "import { Service } from \"typedi\"\nimport { Workspace } from \"@app/models/workspace.model\"\nimport { WorkspaceFolder } from \"@app/models/workspaceFolder.model\"\nimport { Note } from \"@app/models/note.model\"\nimport Errors from \"@app/lib/errors\"\nimport cryptoRandomString from \"crypto-random-string\"\nimport { NoteVersion } from \"@app/models/noteVersion.model\"\nimport { WorkspaceUser } from \"@app/models/workspaceUser.model\"\nimport { User } from \"@app/models/user.model\"\nimport { Friend } from \"@app/models/friend.model\"\nimport { WorkspacesDownloadService } from \"@app/services/workspaces/download.service\"\nimport { BadRequestError } from \"routing-controllers\"\n\n//create class of NoteData\nexport class NoteField {\n  type:\n    | \"h1\"\n    | \"h2\"\n    | \"h3\"\n    | \"h4\"\n    | \"h5\"\n    | \"h6\"\n    | \"p\"\n    | \"textarea\"\n    | \"input\"\n    | \"image\"\n    | \"checkbox\"\n    | \"radio\"\n    | \"button\"\n  value: string | number | boolean | object\n  styles: string\n  creatorId: number\n  lastEditorId: number\n  locked: boolean\n}\n\nexport class NoteData {\n  fields: NoteField[]\n  styles: string\n  creatorId: number\n  lastEditorId: number\n\n  constructor(userId: number) {\n    this.fields = [\n      {\n        type: \"h1\",\n        value: \"My new TPUDOC\",\n        styles: \"\",\n        creatorId: userId,\n        lastEditorId: userId,\n        locked: false\n      }\n    ]\n    this.styles = \"\"\n    this.creatorId = userId\n    this.lastEditorId = userId\n  }\n}\n\nexport class NoteDataV2 {\n  blocks: object[]\n}\n\n@Service()\nexport class NoteService {\n  constructor(private readonly downloadService: WorkspacesDownloadService) {}\n\n  async renameWorkspace(id: number, name: string, userId: number) {\n    const workspace = await this.getWorkspace(id, userId, \"workspace\")\n    if (!workspace) throw Errors.NOT_FOUND\n    await Workspace.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return true\n  }\n\n  async getRecent(userId: number) {\n    return await Workspace.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"notes\",\n              attributes: {\n                exclude: [\"data\"]\n              },\n              include: [\n                {\n                  model: WorkspaceFolder,\n                  as: \"folder\",\n                  attributes: [\"id\", \"name\"]\n                }\n              ],\n              order: [[\"updatedAt\", \"DESC\"]]\n            }\n          ],\n          limit: 12\n        }\n      ],\n      where: {\n        userId\n      },\n      order: [[\"updatedAt\", \"DESC\"]]\n    })\n  }\n\n  async restoreVersion(id: number, version: string, userId: number) {\n    const note = await this.getNote(id, userId)\n    if (!note?.permissions?.modify) throw Errors.NOT_FOUND\n\n    const versionData = note.versions.find((v: Note) => v.id === version)\n    if (!versionData) throw Errors.NOT_FOUND\n\n    await Note.update(\n      {\n        data: versionData.data\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n\n    return true\n  }\n\n  async renameFolder(id: number, name: string, userId: number) {\n    const folder = await this.getWorkspace(id, userId, \"folder\")\n    if (!folder) throw Errors.NOT_FOUND\n    await WorkspaceFolder.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return true\n  }\n\n  async deleteFolder(id: number, userId: number) {\n    const folder = await this.getWorkspace(id, userId, \"folder\")\n    if (!folder) throw Errors.NOT_FOUND\n    await Note.destroy({\n      where: {\n        workspaceFolderId: id\n      }\n    })\n    await WorkspaceFolder.destroy({\n      where: {\n        id\n      }\n    })\n    return true\n  }\n\n  async deleteNote(id: number, userId: number) {\n    const note = await this.getNote(id, userId)\n    if (!note?.permissions?.configure) throw Errors.NOT_FOUND\n    await Note.destroy({\n      where: {\n        id\n      }\n    })\n    return true\n  }\n\n  async deleteWorkspace(id: number, userId: number) {\n    const workspace = await this.getWorkspace(id, userId, \"workspace\")\n    console.log(workspace)\n    if (!workspace?.permissionsMetadata?.configure) throw Errors.NOT_FOUND\n    const notes = await Note.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folder\",\n          required: true,\n          where: {\n            workspaceId: id\n          }\n        }\n      ]\n    })\n\n    await Note.destroy({\n      where: {\n        id: notes.map((n) => n.id)\n      }\n    })\n\n    await WorkspaceFolder.destroy({\n      where: {\n        workspaceId: id\n      }\n    })\n\n    await Workspace.destroy({\n      where: {\n        id\n      }\n    })\n\n    return true\n  }\n\n  async createFolder(name: string, id: number, userId: number) {\n    const workspace = await Workspace.findOne({\n      where: {\n        id,\n        userId\n      }\n    })\n    if (!workspace) throw Errors.NOT_FOUND\n    return await WorkspaceFolder.create({\n      name,\n      workspaceId: id\n    })\n  }\n\n  async getWorkspaces(userId: number) {\n    const workspaces = await Workspace.findAll({\n      where: {\n        userId\n      },\n      include: [\n        {\n          model: WorkspaceUser,\n          as: \"users\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"children\",\n              attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ]\n    })\n\n    const shared = await Workspace.findAll({\n      include: [\n        {\n          model: WorkspaceFolder,\n          as: \"folders\",\n          include: [\n            {\n              model: Note,\n              as: \"children\",\n              attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceUser,\n          as: \"users\",\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: WorkspaceUser,\n          as: \"recipient\",\n          required: true,\n          where: {\n            recipientId: userId\n          },\n          include: [\n            {\n              model: User,\n              as: \"user\",\n              attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n            }\n          ]\n        },\n        {\n          model: User,\n          as: \"user\",\n          attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n        }\n      ]\n    })\n\n    return [\n      ...workspaces.map((workspace) => workspace.toJSON()),\n      ...shared.map((workspace) => {\n        return {\n          ...workspace.toJSON(),\n          shared: true,\n          permissionsMetadata: {\n            write: workspace.dataValues.recipient.dataValues.write,\n            configure: workspace.dataValues.recipient.dataValues.configure,\n            read: workspace.dataValues.recipient.dataValues.read\n          }\n        }\n      })\n    ]\n  }\n\n  async getWorkspace(id: number, userId: number, type: \"workspace\" | \"folder\") {\n    const include = [\n      {\n        model: WorkspaceUser,\n        as: \"users\",\n        include: [\n          {\n            model: User,\n            as: \"user\",\n            attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n          }\n        ]\n      },\n      {\n        model: WorkspaceFolder,\n        as: \"folders\",\n        include: [\n          {\n            model: Note,\n            as: \"children\",\n            attributes: [\"id\", \"name\", \"createdAt\", \"updatedAt\"]\n          }\n        ]\n      },\n      {\n        model: User,\n        as: \"user\",\n        attributes: [\"id\", \"username\", \"avatar\", \"createdAt\", \"updatedAt\"]\n      }\n    ]\n    const workspace = await Workspace.findOne({\n      where: {\n        id,\n        userId\n      },\n      include\n    })\n    if (type === \"folder\") {\n      const workspace = await Workspace.findOne({\n        where: {\n          userId\n        },\n        include: [\n          ...include,\n          {\n            model: WorkspaceFolder,\n            as: \"folder\",\n            where: {\n              id\n            },\n            required: true\n          }\n        ]\n      })\n      if (!workspace) {\n        const workspace = await Workspace.findOne({\n          include: [\n            ...include,\n            {\n              model: WorkspaceFolder,\n              as: \"folder\",\n              where: {\n                id\n              },\n              required: true\n            },\n            {\n              model: WorkspaceUser,\n              as: \"recipient\",\n              required: true,\n              where: {\n                recipientId: userId\n              }\n            }\n          ]\n        })\n        if (!workspace) throw Errors.NOT_FOUND\n        return {\n          ...workspace.toJSON(),\n          shared: true,\n          permissionsMetadata: {\n            write: workspace.dataValues.recipient.dataValues.write,\n            configure: workspace.dataValues.recipient.dataValues.configure,\n            read: workspace.dataValues.recipient.dataValues.read\n          }\n        }\n      }\n      return {\n        ...workspace.toJSON(),\n        shared: false,\n        permissionsMetadata: {\n          write: true,\n          configure: true,\n          read: true\n        }\n      }\n    }\n    if (!workspace) {\n      const workspace = await Workspace.findOne({\n        where: {\n          id\n        },\n        include: [\n          ...include,\n          {\n            model: WorkspaceUser,\n            as: \"recipient\",\n            required: true,\n            where: {\n              recipientId: userId\n            }\n          }\n        ]\n      })\n      if (!workspace) throw Errors.NOT_FOUND\n      return {\n        ...workspace.toJSON(),\n        shared: true,\n        permissionsMetadata: {\n          write: workspace.dataValues.recipient.dataValues.write,\n          configure: workspace.dataValues.recipient.dataValues.configure,\n          read: workspace.dataValues.recipient.dataValues.read\n        }\n      }\n    }\n    return {\n      ...workspace.toJSON(),\n      shared: false,\n      permissionsMetadata: {\n        write: true,\n        configure: true,\n        read: true\n      }\n    }\n  }\n\n  async getFolder(id: number, userId: number) {\n    const folder = await WorkspaceFolder.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: Note,\n          as: \"children\",\n          attributes: [\n            \"id\",\n            \"name\",\n            \"createdAt\",\n            \"updatedAt\",\n            \"data\",\n            \"shareLink\"\n          ]\n        }\n      ]\n    })\n    if (!folder) throw Errors.NOT_FOUND\n    console.log(folder.name)\n    const workspace = await this.getWorkspace(\n      folder.workspaceId,\n      userId,\n      \"workspace\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return folder\n  }\n\n  async createWorkspace(name: string, userId: number) {\n    const workspace = await Workspace.create({\n      name,\n      userId\n    })\n\n    const folder = await WorkspaceFolder.create({\n      name: \"Documents\",\n      workspaceId: workspace.id\n    })\n\n    await Note.create({\n      name: `Document 1`,\n      workspaceFolderId: folder.id,\n      data: {}\n    })\n\n    return workspace\n  }\n\n  async getNote(id: number | string, userId: number | undefined) {\n    const note = await Note.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: NoteVersion,\n          as: \"versions\",\n          limit: 50,\n          order: [[\"createdAt\", \"DESC\"]]\n        }\n      ]\n    })\n    if (!note || !userId || id.toString().length === 64) {\n      const note = await Note.findOne({\n        where: {\n          shareLink: id\n        },\n        attributes: {\n          exclude: [\"versions\"]\n        }\n      })\n      if (!note) throw Errors.NOT_FOUND\n      return {\n        ...note.toJSON(),\n        permissions: {\n          modify: false,\n          configure: false,\n          read: true\n        }\n      }\n    }\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return {\n      ...note.toJSON(),\n      permissions: {\n        modify: true,\n        configure: true,\n        read: true\n      }\n    }\n  }\n\n  async renameNote(id: number, name: string, userId: number) {\n    const note = await Note.findOne({\n      where: {\n        id\n      }\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace?.permissionsMetadata?.write) throw Errors.NOT_FOUND\n    await Note.update(\n      {\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return note\n  }\n\n  async saveNote(\n    id: number,\n    data: NoteDataV2,\n    userId: number,\n    manualSave: boolean = false,\n    name?: string\n  ) {\n    let note = await Note.findOne({\n      where: {\n        id\n      },\n      include: [\n        {\n          model: NoteVersion,\n          as: \"versions\",\n          limit: 50,\n          order: [[\"createdAt\", \"DESC\"]]\n        }\n      ]\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace?.permissionsMetadata?.write) throw Errors.NOT_FOUND\n    if (!note.versions) note.versions = []\n\n    const latestSave = note.versions[0]\n    let versions = note.versions\n    if (\n      !latestSave ||\n      new Date().getTime() - new Date(latestSave?.createdAt).getTime() >\n        5 * 60 * 1000 ||\n      (manualSave &&\n        new Date().getTime() - new Date(latestSave?.createdAt).getTime() >\n          30 * 1000)\n    ) {\n      const version = await NoteVersion.create({\n        noteId: note.id,\n        data,\n        userId\n      })\n      versions = [version, ...versions]\n    }\n    await Note.update(\n      {\n        data,\n        name\n      },\n      {\n        where: {\n          id\n        }\n      }\n    )\n    return {\n      ...note.toJSON(),\n      versions: versions.slice(0, 50)\n    }\n  }\n\n  async createNote(name: string, workspaceFolderId: number, userId: number) {\n    const workspace = await this.getWorkspace(\n      workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    return await Note.create({\n      name,\n      workspaceFolderId,\n      data: {}\n    })\n  }\n\n  async toggleShareLink(id: number, userId: number) {\n    const note = await Note.findOne({\n      where: {\n        id\n      }\n    })\n    if (!note) throw Errors.NOT_FOUND\n    const workspace = await this.getWorkspace(\n      note.workspaceFolderId,\n      userId,\n      \"folder\"\n    )\n    if (!workspace) throw Errors.NOT_FOUND\n    const shareLink = note.shareLink\n      ? null\n      : await cryptoRandomString({ length: 64 })\n    await note.update({\n      shareLink\n    })\n    return {\n      shareLink\n    }\n  }\n\n  async removeUserFromWorkspace(workspaceId: number, recipientId: number) {\n    const result = await WorkspaceUser.destroy({\n      where: {\n        workspaceId,\n        recipientId\n      }\n    })\n\n    if (!result) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n    return result\n  }\n\n  async addUserToWorkspace(\n    workspaceId: number,\n    senderId: number,\n    username: string,\n    write: boolean,\n    configure: boolean,\n    read: boolean\n  ) {\n    const workspace = await Workspace.findOne({\n      where: {\n        id: workspaceId\n      }\n    })\n\n    if (!workspace) {\n      throw Errors.WORKSPACE_NOT_FOUND\n    }\n\n    const user = await User.findOne({\n      where: {\n        username\n      },\n      attributes: [\"id\", \"username\", \"avatar\", \"email\"]\n    })\n\n    if (!user) {\n      throw Errors.USER_NOT_FOUND\n    }\n\n    if (workspace.userId === user.id) {\n      throw Errors.CANNOT_ADD_OWNER\n    }\n\n    const friend = await Friend.findOne({\n      where: {\n        userId: senderId,\n        friendId: user.id,\n        status: \"accepted\"\n      }\n    })\n\n    if (!friend) {\n      throw Errors.NOT_FRIENDS_WITH_USER_COLLECTION\n    }\n\n    return {\n      ...(\n        await WorkspaceUser.create({\n          workspaceId,\n          recipientId: user.id,\n          senderId: senderId,\n          write,\n          configure,\n          read,\n          identifier: workspaceId + \"-\" + user.id\n        })\n      ).dataValues,\n      user,\n      workspace: {\n        id: workspace.id,\n        name: workspace.name\n      }\n    }\n  }\n\n  async updateUser(\n    workspaceId: number,\n    recipientId: number,\n    write: boolean,\n    configure: boolean,\n    read: boolean\n  ) {\n    const result = await WorkspaceUser.update(\n      {\n        write,\n        configure,\n        read\n      },\n      {\n        where: {\n          workspaceId,\n          recipientId\n        }\n      }\n    )\n\n    if (!result) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n    return result\n  }\n\n  async getWorkspacePermissions(\n    workspaceId: number,\n    userId: number,\n    permission: \"read\" | \"write\" | \"configure\"\n  ) {\n    const workspace = await WorkspaceUser.findOne({\n      where: {\n        workspaceId,\n        recipientId: userId\n      }\n    })\n\n    if (!workspace) {\n      const workspace = await Workspace.findOne({\n        where: {\n          id: workspaceId,\n          userId\n        }\n      })\n\n      if (!workspace) throw Errors.WORKSPACE_USER_NOT_FOUND\n\n      return true\n    }\n\n    return workspace[permission]\n  }\n\n  async downloadNote(note: Note, type: \"tpudoc\" | \"html\" | \"docx\") {\n    console.log(note.data, type)\n    switch (type) {\n      case \"tpudoc\": {\n        return note.data\n      }\n      case \"html\": {\n        return await this.downloadService.html(<NoteDataV2>note.data)\n      }\n      case \"docx\": {\n        return await this.downloadService.docx(<NoteDataV2>note.data)\n      }\n      default: {\n        throw new BadRequestError(\"Invalid type, must be tpudoc, html or docx\")\n      }\n    }\n  }\n}\n", "import { z } from \"zod\"\n\nexport const HostnameValidator = z.string().refine((value) => {\n  if (value === \"localhost\" || value === \"tpu\") return true\n  // Regular expression pattern for valid hostnames\n  const hostnameRegex = /^[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n\n  // Check if the value matches the pattern and does not contain a protocol\n  return hostnameRegex.test(value) && !value.includes(\"://\")\n}, \"Invalid hostname\")\n\nexport const TpuConfigValidator = z.object({\n  hostnameWithProtocol: z.string().url(),\n  hostname: HostnameValidator,\n  maintenance: z.object({\n    enabled: z.boolean(),\n    message: z.string().nullable().optional(),\n    statusPage: z.string().nullable().optional()\n  }),\n  siteName: z.string(),\n  release: z.string(),\n  storage: z.string(),\n  jitsiToken: z.string().nullable().optional(),\n  registrations: z.boolean(),\n  mediaProxySecret: z.string(),\n  weatherApiKey: z.string().nullable().optional(),\n  providers: z.object({\n    tenor: z.string().nullable().optional(),\n    lastfm: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional(),\n    mal: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional(),\n    anilist: z\n      .object({\n        key: z.string().nullable().optional(),\n        secret: z.string().nullable().optional()\n      })\n      .nullable()\n      .optional()\n  }),\n  redis: z.object({\n    username: z.string().nullable().optional(),\n    password: z.string().nullable().optional(),\n    host: z.string(),\n    db: z.number(),\n    port: z.number()\n  }),\n  email: z.object({\n    secure: z.boolean(),\n    username: z.string(),\n    password: z.string(),\n    from: z.string(),\n    host: z.string(),\n    port: z.number()\n  }),\n  discord: z.object({\n    webhook: z.string().nullable().optional(),\n    token: z.string().nullable().optional()\n  }),\n  officialInstance: z.boolean(),\n  port: z.union([z.number(), z.string().nullable().optional()]),\n  finishedSetup: z.boolean(),\n  threads: z.number(),\n  features: z.object({\n    communications: z.boolean(),\n    collections: z.boolean(),\n    autoCollects: z.boolean(),\n    workspaces: z.boolean(),\n    insights: z.boolean()\n  }),\n  defaultPlanId: z.number().nullable().optional(),\n  privacyNoteId: z.string().nullable().optional(),\n  termsNoteId: z.string().nullable().optional(),\n  inviteAFriend: z.boolean(),\n  hostnames: z.array(z.string()).optional(),\n  preTrustedDomains: z.array(z.string()).optional()\n})\n\nexport const TpuConfigValidatorPartial = TpuConfigValidator.partial()\n", "{\n  \"name\": \"tpu-frontend\",\n  \"version\": \"3.2.49\",\n  \"private\": true,\n  \"author\": \"Troplo <troplo@troplo.com>\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"serve\": \"vite\",\n    \"build-prod\": \"vue-tsc --noEmit && vite build && cp -r dist/* /var/www/html/tpu\",\n    \"build\": \"vue-tsc --noEmit && vite build\",\n    \"preview\": \"vite preview\",\n    \"lint\": \"eslint . --fix --ignore-path .gitignore\",\n    \"build-mobile\": \"CORDOVA=true vite build && rm -rf ./mobile/www && cp -r ./dist ./mobile/www\"\n  },\n  \"dependencies\": {\n    \"@codemirror/autocomplete\": \"^6.4.2\",\n    \"@codemirror/basic-setup\": \"^0.20.0\",\n    \"@codemirror/lang-css\": \"^6.1.1\",\n    \"@codemirror/view\": \"^6.9.3\",\n    \"@editorjs/attaches\": \"^1.3.0\",\n    \"@editorjs/checklist\": \"^1.4.0\",\n    \"@editorjs/code\": \"^2.8.0\",\n    \"@editorjs/delimiter\": \"^1.3.0\",\n    \"@editorjs/editorjs\": \"^2.26.5\",\n    \"@editorjs/embed\": \"^2.5.3\",\n    \"@editorjs/header\": \"^2.7.0\",\n    \"@editorjs/image\": \"^2.8.1\",\n    \"@editorjs/inline-code\": \"^1.4.0\",\n    \"@editorjs/link\": \"^2.5.0\",\n    \"@editorjs/list\": \"^1.8.0\",\n    \"@editorjs/marker\": \"^1.3.0\",\n    \"@editorjs/paragraph\": \"^2.9.0\",\n    \"@editorjs/quote\": \"^2.5.0\",\n    \"@editorjs/raw\": \"^2.4.0\",\n    \"@editorjs/table\": \"^2.2.0\",\n    \"@editorjs/warning\": \"^1.3.0\",\n    \"@guolao/vue-monaco-editor\": \"^1.1.2\",\n    \"@highlightjs/vue-plugin\": \"1.0.2\",\n    \"@mdi/font\": \"7.1.96\",\n    \"@svgmoji/noto\": \"^3.2.0\",\n    \"@troplo/tpu-editorjs-nested-list\": \"^1.3.0-troplo1\",\n    \"@troplo/tpu-simple-image\": \"^1.5.1-troplo1\",\n    \"@troplo/vite-version\": \"^1.0.3\",\n    \"@types/codeflask\": \"^1.4.3\",\n    \"@types/cypress\": \"^1.1.3\",\n    \"@types/dompurify\": \"^2.4.0\",\n    \"@types/markdown-it\": \"^12.2.3\",\n    \"@types/node\": \"^18.11.9\",\n    \"@types/textarea-caret\": \"^3.0.1\",\n    \"@types/vue-cropperjs\": \"^4.1.2\",\n    \"@types/webfontloader\": \"^1.6.35\",\n    \"@vitejs/plugin-vue\": \"^4.1.0\",\n    \"@vue/eslint-config-typescript\": \"^11.0.0\",\n    \"@vuetify/nightly\": \"npm:@vuetify/nightly@4.0.0-dev-20230512.0\",\n    \"apexcharts\": \"^3.37.0\",\n    \"axios\": \"^1.3.2\",\n    \"chart.js\": \"^4.2.1\",\n    \"codeflask\": \"^1.4.1\",\n    \"codemirror\": \"^6.0.1\",\n    \"core-js\": \"^3.8.3\",\n    \"cropperjs\": \"^1.5.13\",\n    \"dayjs\": \"^1.11.7\",\n    \"dompurify\": \"^3.0.0\",\n    \"editorjs-header-with-anchor\": \"^2.6.0\",\n    \"editorjs-html\": \"^3.4.3\",\n    \"editorjs-text-alignment-blocktune\": \"^1.0.3\",\n    \"editorjs-text-color-plugin\": \"^2.0.2\",\n    \"editorjs-undo\": \"^2.0.18\",\n    \"floating-vue\": \"^2.0.0-beta.20\",\n    \"markdown-it\": \"^13.0.1\",\n    \"markdown-it-emoji\": \"^2.0.2\",\n    \"markdown-it-unicode-emoji\": \"https://github.com/Troplo/markdown-it-unicode-emoji\",\n    \"monaco-editor\": \"^0.36.1\",\n    \"pinia\": \"^2.0.23\",\n    \"qrcode.vue\": \"^3.3.3\",\n    \"sass\": \"^1.55.0\",\n    \"socket.io-client\": \"^4.6.0\",\n    \"svgmoji\": \"^3.2.0\",\n    \"textarea-caret\": \"^3.1.0\",\n    \"typescript\": \"^4\",\n    \"vite\": \"^4.2.0\",\n    \"vite-plugin-pwa\": \"^0.14.4\",\n    \"vite-plugin-vuetify\": \"^1.0.2\",\n    \"vite-plugin-warmup\": \"^0.1.0\",\n    \"vue\": \"^3.2.13\",\n    \"vue-axios\": \"^3.5.2\",\n    \"vue-chartjs\": \"^5.2.0\",\n    \"vue-codemirror\": \"^6.1.1\",\n    \"vue-cropperjs\": \"^5.0.0\",\n    \"vue-draggable-plus\": \"^0.1.6\",\n    \"vue-i18n\": \"9\",\n    \"vue-matomo\": \"^4.2.0\",\n    \"vue-mention\": \"^2.0.0-alpha.3\",\n    \"vue-router\": \"^4.0.0\",\n    \"vue-toastification\": \"^2.0.0-rc.5\",\n    \"vue-tsc\": \"^1.0.9\",\n    \"vue3-apexcharts\": \"^1.4.1\",\n    \"vuetify\": \"^3.2.2\",\n    \"webfontloader\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"cypress\": \"^12.7.0\",\n    \"eslint\": \"^8.43.0\",\n    \"eslint-plugin-vue\": \"^9.3.0\",\n    \"rollup-plugin-visualizer\": \"^5.9.0\"\n  }\n}\n"], "filenames": ["app/controllers/v3/admin.controller.ts", "app/controllers/v3/workspace.controller.ts", "app/services/admin.service.ts", "app/services/note.service.ts", "app/validators/setup.ts", "frontend/package.json"], "buggy_code_start_loc": [38, 198, 430, 488, 15, 3], "buggy_code_end_loc": [63, 201, 431, 493, 16, 4], "fixing_code_start_loc": [37, 197, 430, 489, 15, 3], "fixing_code_end_loc": [76, 205, 431, 494, 20, 4], "type": "CWE-287", "message": "PrivateUploader is an open source image hosting server written in Vue and TypeScript. In affected versions `app/routes/v3/admin.controller.ts` did not correctly verify whether the user was an administrator (High Level) or moderator (Low Level) causing the request to continue processing. The response would be a 403 with ADMIN_ONLY, however, next() would call leading to any updates/changes in the route to process. This issue has been addressed in version 3.2.49. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-40020", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-14T21:15:13.797", "lastModified": "2023-08-22T14:36:08.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PrivateUploader is an open source image hosting server written in Vue and TypeScript. In affected versions `app/routes/v3/admin.controller.ts` did not correctly verify whether the user was an administrator (High Level) or moderator (Low Level) causing the request to continue processing. The response would be a 403 with ADMIN_ONLY, however, next() would call leading to any updates/changes in the route to process. This issue has been addressed in version 3.2.49. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:troplo:privateuploader:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.49", "matchCriteriaId": "F3185126-02B9-4939-B4A3-28EC7123FCA4"}]}]}], "references": [{"url": "https://github.com/PrivateUploader/PrivateUploader/commit/869657d61e3c7a518177106fe63ea483082b0d3e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PrivateUploader/PrivateUploader/security/advisories/GHSA-vhrw-2472-rrjx", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PrivateUploader/PrivateUploader/commit/869657d61e3c7a518177106fe63ea483082b0d3e"}}