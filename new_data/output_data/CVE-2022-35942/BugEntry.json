{"buggy_code": ["// Copyright IBM Corp. 2013,2020. All Rights Reserved.\n// Node module: loopback-connector-postgresql\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n/*!\n * PostgreSQL connector for LoopBack\n */\n'use strict';\nconst SG = require('strong-globalize');\nconst g = SG();\nconst postgresql = require('pg');\nconst SqlConnector = require('loopback-connector').SqlConnector;\nconst ParameterizedSQL = SqlConnector.ParameterizedSQL;\nconst util = require('util');\nconst debug = require('debug')('loopback:connector:postgresql');\nconst debugData = require('debug')('loopback:connector:postgresql:data');\nconst debugSort = require('debug')('loopback:connector:postgresql:order');\nconst Promise = require('bluebird');\n\n/**\n *\n * Initialize the PostgreSQL connector against the given data source\n *\n * @param {DataSource} dataSource The loopback-datasource-juggler dataSource\n * @callback {Function} [callback] The callback function\n * @param {String|Error} err The error string or object\n * @header PostgreSQL.initialize(dataSource, [callback])\n */\nexports.initialize = function initializeDataSource(dataSource, callback) {\n  if (!postgresql) {\n    return;\n  }\n\n  const dbSettings = dataSource.settings || {};\n  dbSettings.host = dbSettings.host || dbSettings.hostname || 'localhost';\n  dbSettings.user = dbSettings.user || dbSettings.username;\n\n  dataSource.connector = new PostgreSQL(postgresql, dbSettings);\n  dataSource.connector.dataSource = dataSource;\n\n  if (callback) {\n    if (dbSettings.lazyConnect) {\n      process.nextTick(callback);\n    } else {\n      dataSource.connecting = true;\n      dataSource.connector.connect(callback);\n    }\n  }\n};\n\n/**\n * PostgreSQL connector constructor\n *\n * @param {PostgreSQL} postgresql PostgreSQL node.js binding\n * @options {Object} settings An object for the data source settings.\n * See [node-postgres documentation](https://node-postgres.com/api/client).\n * @property {String} url URL to the database, such as 'postgres://test:mypassword@localhost:5432/devdb'.\n * Other parameters can be defined as query string of the url\n * @property {String} hostname The host name or ip address of the PostgreSQL DB server\n * @property {Number} port The port number of the PostgreSQL DB Server\n * @property {String} user The user name\n * @property {String} password The password\n * @property {String} database The database name\n * @property {Boolean} ssl Whether to try SSL/TLS to connect to server\n * @property {Function | string} [onError] Optional hook to connect to the pg pool 'error' event,\n * or the string 'ignore' to record them with `debug` and otherwise ignore them.\n *\n * @constructor\n */\nfunction PostgreSQL(postgresql, settings) {\n  // this.name = 'postgresql';\n  // this._models = {};\n  // this.settings = settings;\n  this.constructor.super_.call(this, 'postgresql', settings);\n  this.clientConfig = settings;\n  if (settings.url) {\n    // pg-pool doesn't handle string config correctly\n    this.clientConfig.connectionString = settings.url;\n  }\n  this.clientConfig.Promise = Promise;\n  this.pg = new postgresql.Pool(this.clientConfig);\n\n  if (settings.onError) {\n    if (settings.onError === 'ignore') {\n      this.pg.on('error', function(err) {\n        debug(err);\n      });\n    } else {\n      this.pg.on('error', settings.onError);\n    }\n  }\n\n  this.settings = settings;\n  debug('Settings %j', {\n    ...settings,\n    ...(typeof settings.url !== 'undefined' && {\n      get url() {\n        const url = new URL(settings.url);\n        if (url.password !== '') url.password = '***';\n        return url.toString();\n      },\n    }),\n    ...(typeof settings.password !== 'undefined' && {password: '***'}),\n  });\n}\n\n// Inherit from loopback-datasource-juggler BaseSQL\nutil.inherits(PostgreSQL, SqlConnector);\n\nPostgreSQL.prototype.getDefaultSchemaName = function() {\n  return 'public';\n};\n\n/**\n * Connect to PostgreSQL\n * @callback {Function} [callback] The callback after the connection is established\n */\nPostgreSQL.prototype.connect = function(callback) {\n  const self = this;\n  self.pg.connect(function(err, client, releaseCb) {\n    self.client = client;\n    process.nextTick(releaseCb);\n    callback && callback(err, client);\n  });\n};\n\n/**\n * Execute the sql statement\n *\n * @param {String} sql The SQL statement\n * @param {String[]} params The parameter values for the SQL statement\n * @param {Object} [options] Options object\n * @callback {Function} [callback] The callback after the SQL statement is executed\n * @param {String|Error} err The error string or object\n * @param {Object[]} data The result from the SQL\n */\nPostgreSQL.prototype.executeSQL = function(sql, params, options, callback) {\n  const self = this;\n\n  if (params && params.length > 0) {\n    debug('SQL: %s\\nParameters: %j', sql, params);\n  } else {\n    debug('SQL: %s', sql);\n  }\n\n  function executeWithConnection(connection, releaseCb) {\n    connection.query(sql, params, function(err, data) {\n      // if(err) console.error(err);\n      if (err) debug(err);\n      if (data) debugData('%j', data);\n      // Release the connection back to the pool.\n      if (releaseCb) releaseCb(err);\n      let result = null;\n      if (data) {\n        switch (data.command) {\n          case 'DELETE':\n          case 'UPDATE':\n            result = {affectedRows: data.rowCount, count: data.rowCount};\n\n            if (data.rows)\n              result.rows = data.rows;\n\n            break;\n          default:\n            result = data.rows;\n        }\n      }\n      callback(err ? err : null, result);\n    });\n  }\n\n  const transaction = options.transaction;\n  if (transaction && transaction.connector === this) {\n    if (!transaction.connection) {\n      return process.nextTick(function() {\n        callback(new Error(g.f('Connection does not exist')));\n      });\n    }\n    if (transaction.txId !== transaction.connection.txId) {\n      return process.nextTick(function() {\n        callback(new Error(g.f('Transaction is not active')));\n      });\n    }\n    debug('Execute SQL within a transaction');\n    // Do not release the connection\n    executeWithConnection(transaction.connection, null);\n  } else {\n    self.pg.connect(function(err, connection, releaseCb) {\n      if (err) return callback(err);\n      executeWithConnection(connection, releaseCb);\n    });\n  }\n};\n\nPostgreSQL.prototype.buildInsertReturning = function(model, data, options) {\n  const idColumnNames = [];\n  const idNames = this.idNames(model);\n  for (let i = 0, n = idNames.length; i < n; i++) {\n    idColumnNames.push(this.columnEscaped(model, idNames[i]));\n  }\n  return 'RETURNING ' + idColumnNames.join(',');\n};\n\n/**\n * Check if id types have a numeric type\n * @param {String} model name\n * @returns {Boolean}\n */\nPostgreSQL.prototype.hasOnlyNumericIds = function(model) {\n  const cols = this.getModelDefinition(model).properties;\n  const idNames = this.idNames(model);\n  const numericIds = idNames.filter(function(idName) {\n    return cols[idName].type === Number;\n  });\n\n  return numericIds.length == idNames.length;\n};\n\n/**\n * Get default find sort policy\n * @param model\n */\nPostgreSQL.prototype.getDefaultIdSortPolicy = function(model) {\n  const modelClass = this._models[model];\n\n  if (modelClass.settings.hasOwnProperty('defaultIdSort')) {\n    return modelClass.settings.defaultIdSort;\n  }\n\n  if (this.settings.hasOwnProperty('defaultIdSort')) {\n    return this.settings.defaultIdSort;\n  }\n\n  return null;\n};\n\n/**\n * Build a SQL SELECT statement\n * @param {String} model Model name\n * @param {Object} filter Filter object\n * @param {Object} options Options object\n * @returns {ParameterizedSQL} Statement object {sql: ..., params: ...}\n */\nPostgreSQL.prototype.buildSelect = function(model, filter) {\n  let sortById;\n\n  const sortPolicy = this.getDefaultIdSortPolicy(model);\n\n  switch (sortPolicy) {\n    case 'numericIdOnly':\n      sortById = this.hasOnlyNumericIds(model);\n      break;\n    case false:\n      sortById = false;\n      break;\n    default:\n      sortById = true;\n      break;\n  }\n\n  debugSort(model, 'sort policy:', sortPolicy, sortById);\n\n  if (sortById && !filter.order) {\n    const idNames = this.idNames(model);\n    if (idNames && idNames.length) {\n      filter.order = idNames;\n    }\n  }\n\n  let selectStmt = new ParameterizedSQL('SELECT ' +\n    this.buildColumnNames(model, filter) +\n    ' FROM ' + this.tableEscaped(model));\n\n  if (filter) {\n    if (filter.where) {\n      const whereStmt = this.buildWhere(model, filter.where);\n      selectStmt.merge(whereStmt);\n    }\n\n    if (filter.order) {\n      selectStmt.merge(this.buildOrderBy(model, filter.order));\n    }\n\n    if (filter.limit || filter.skip || filter.offset) {\n      selectStmt = this.applyPagination(\n        model, selectStmt, filter,\n      );\n    }\n  }\n  return this.parameterize(selectStmt);\n};\n\nPostgreSQL.prototype.buildInsertDefaultValues = function(model, data, options) {\n  return 'DEFAULT VALUES';\n};\n\n// FIXME: [rfeng] The native implementation of upsert only works with\n// postgresql 9.1 or later as it requres writable CTE\n// See https://github.com/strongloop/loopback-connector-postgresql/issues/27\n/**\n * Update if the model instance exists with the same id or create a new instance\n *\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @callback {Function} [callback] The callback function\n * @param {String|Error} err The error string or object\n * @param {Object} The updated model instance\n */\n/*\n PostgreSQL.prototype.updateOrCreate = function (model, data, callback) {\n var self = this;\n data = self.mapToDB(model, data);\n var props = self._categorizeProperties(model, data);\n var idColumns = props.ids.map(function(key) {\n return self.columnEscaped(model, key); }\n );\n var nonIdsInData = props.nonIdsInData;\n var query = [];\n query.push('WITH update_outcome AS (UPDATE ', self.tableEscaped(model), ' SET ');\n query.push(self.toFields(model, data, false));\n query.push(' WHERE ');\n query.push(idColumns.map(function (key, i) {\n return ((i > 0) ? ' AND ' : ' ') + key + '=$' + (nonIdsInData.length + i + 1);\n }).join(','));\n query.push(' RETURNING ', idColumns.join(','), ')');\n query.push(', insert_outcome AS (INSERT INTO ', self.tableEscaped(model), ' ');\n query.push(self.toFields(model, data, true));\n query.push(' WHERE NOT EXISTS (SELECT * FROM update_outcome) RETURNING ', idColumns.join(','), ')');\n query.push(' SELECT * FROM update_outcome UNION ALL SELECT * FROM insert_outcome');\n var queryParams = [];\n nonIdsInData.forEach(function(key) {\n queryParams.push(data[key]);\n });\n props.ids.forEach(function(key) {\n queryParams.push(data[key] || null);\n });\n var idColName = self.idColumn(model);\n self.query(query.join(''), queryParams, function(err, info) {\n if (err) {\n return callback(err);\n }\n var idValue = null;\n if (info && info[0]) {\n idValue = info[0][idColName];\n }\n callback(err, idValue);\n });\n };\n */\n\nPostgreSQL.prototype.fromColumnValue = function(prop, val) {\n  if (val == null) {\n    return val;\n  }\n  const type = prop.type && prop.type.name;\n  if (prop && type === 'Boolean') {\n    if (typeof val === 'boolean') {\n      return val;\n    } else {\n      return (val === 'Y' || val === 'y' || val === 'T' ||\n      val === 't' || val === '1');\n    }\n  } else if (prop && type === 'GeoPoint' || type === 'Point') {\n    if (typeof val === 'string') {\n      // The point format is (x,y)\n      const point = val.split(/[\\(\\)\\s,]+/).filter(Boolean);\n      return {\n        lat: +point[0],\n        lng: +point[1],\n      };\n    } else if (typeof val === 'object' && val !== null) {\n      // Now pg driver converts point to {x: lng, y: lat}\n      return {\n        lng: val.x,\n        lat: val.y,\n      };\n    } else {\n      return val;\n    }\n  } else {\n    return val;\n  }\n};\n\n/*!\n * Convert to the Database name\n * @param {String} name The name\n * @returns {String} The converted name\n */\nPostgreSQL.prototype.dbName = function(name) {\n  if (!name) {\n    return name;\n  }\n  // PostgreSQL default to lowercase names\n  return name.toLowerCase();\n};\n\nfunction escapeIdentifier(str) {\n  let escaped = '\"';\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    if (c === '\"') {\n      escaped += c + c;\n    } else {\n      escaped += c;\n    }\n  }\n  escaped += '\"';\n  return escaped;\n}\n\nfunction escapeLiteral(str) {\n  let hasBackslash = false;\n  let escaped = '\\'';\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    if (c === '\\'') {\n      escaped += c + c;\n    } else if (c === '\\\\') {\n      escaped += c + c;\n      hasBackslash = true;\n    } else {\n      escaped += c;\n    }\n  }\n  escaped += '\\'';\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped;\n  }\n  return escaped;\n}\n\n/*\n * Check if a value is attempting to use nested json keys\n * @param {String} property The property being queried from where clause\n * @returns {Boolean} True of the property contains dots for nested json\n */\nfunction isNested(property) {\n  return property.split('.').length > 1;\n}\n\n/*\n * Overwrite the loopback-connector column escape\n * to allow querying nested json keys\n * @param {String} model The model name\n * @param {String} property The property name\n * @returns {String} The escaped column name, or column with nested keys for deep json columns\n */\nPostgreSQL.prototype.columnEscaped = function(model, property) {\n  if (isNested(property)) {\n    // Convert column to PostgreSQL json style query: \"model\"->>'val'\n    const self = this;\n    return property\n      .split('.')\n      .map(function(val, idx) { return (idx === 0 ? self.columnEscaped(model, val) : escapeLiteral(val)); })\n      .reduce(function(prev, next, idx, arr) {\n        return idx == 0 ? next : idx < arr.length - 1 ? prev + '->' + next : prev + '->>' + next;\n      });\n  } else {\n    return this.escapeName(this.column(model, property));\n  }\n};\n\n/*!\n * Escape the name for PostgreSQL DB\n * @param {String} name The name\n * @returns {String} The escaped name\n */\nPostgreSQL.prototype.escapeName = function(name) {\n  if (!name) {\n    return name;\n  }\n  return escapeIdentifier(name);\n};\n\nPostgreSQL.prototype.escapeValue = function(value) {\n  if (typeof value === 'string') {\n    return escapeLiteral(value);\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  // Can't send functions, objects, arrays\n  if (typeof value === 'object' || typeof value === 'function') {\n    return null;\n  }\n  return value;\n};\n\nPostgreSQL.prototype.tableEscaped = function(model) {\n  const schema = this.schema(model) || 'public';\n  return this.escapeName(schema) + '.' +\n    this.escapeName(this.table(model));\n};\n\nfunction buildLimit(limit, offset) {\n  const clause = [];\n  if (isNaN(limit)) {\n    limit = 0;\n  }\n  if (isNaN(offset)) {\n    offset = 0;\n  }\n  if (!limit && !offset) {\n    return '';\n  }\n  if (limit) {\n    clause.push('LIMIT ' + limit);\n  }\n  if (offset) {\n    clause.push('OFFSET ' + offset);\n  }\n  return clause.join(' ');\n}\n\nPostgreSQL.prototype.applyPagination = function(model, stmt, filter) {\n  const limitClause = buildLimit(filter.limit, filter.offset || filter.skip);\n  return stmt.merge(limitClause);\n};\n\nPostgreSQL.prototype.buildExpression = function(columnName, operator,\n  operatorValue, propertyDefinition) {\n  switch (operator) {\n    case 'like':\n      return new ParameterizedSQL(columnName + \"::TEXT LIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'ilike':\n      return new ParameterizedSQL(columnName + \"::TEXT ILIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'nlike':\n      return new ParameterizedSQL(columnName + \"::TEXT NOT LIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'nilike':\n      return new ParameterizedSQL(columnName + \"::TEXT NOT ILIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'regexp':\n      if (operatorValue.global)\n        g.warn('{{PostgreSQL}} regex syntax does not respect the {{`g`}} flag');\n\n      if (operatorValue.multiline)\n        g.warn('{{PostgreSQL}} regex syntax does not respect the {{`m`}} flag');\n\n      const regexOperator = operatorValue.ignoreCase ? ' ~* ?' : ' ~ ?';\n      return new ParameterizedSQL(columnName + regexOperator,\n        [operatorValue.source]);\n    case 'contains':\n      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map((v) => `'${v}'`) + ']::'\n        + propertyDefinition.postgresql.dataType);\n    case 'match':\n      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery('${operatorValue}')`);\n    default:\n      // invoke the base implementation of `buildExpression`\n      return this.invokeSuper('buildExpression', columnName, operator,\n        operatorValue, propertyDefinition);\n  }\n};\n\n/**\n * Disconnect from PostgreSQL\n * @param {Function} [cb] The callback function\n */\nPostgreSQL.prototype.disconnect = function disconnect(cb) {\n  if (this.pg) {\n    debug('Disconnecting from ' + this.settings.hostname);\n    const pg = this.pg;\n    this.pg = null;\n    pg.end(); // This is sync\n  }\n\n  if (cb) {\n    process.nextTick(cb);\n  }\n};\n\nPostgreSQL.prototype.ping = function(cb) {\n  this.execute('SELECT 1 AS result', [], cb);\n};\n\nPostgreSQL.prototype.getInsertedId = function(model, info) {\n  const idColName = this.idColumn(model);\n  let idValue;\n  if (info && info[0]) {\n    idValue = info[0][idColName];\n  }\n  return idValue;\n};\n\n/**\n * Build the SQL WHERE clause for the where object\n * @param {string} model Model name\n * @param {object} where An object for the where conditions\n * @returns {ParameterizedSQL} The SQL WHERE clause\n */\nPostgreSQL.prototype.buildWhere = function(model, where) {\n  const whereClause = this._buildWhere(model, where);\n  if (whereClause.sql) {\n    whereClause.sql = 'WHERE ' + whereClause.sql;\n  }\n  return whereClause;\n};\n\n/**\n * @private\n * @param model\n * @param where\n * @returns {ParameterizedSQL}\n */\nPostgreSQL.prototype._buildWhere = function(model, where) {\n  let columnValue, sqlExp;\n  if (!where) {\n    return new ParameterizedSQL('');\n  }\n  if (typeof where !== 'object' || Array.isArray(where)) {\n    debug('Invalid value for where: %j', where);\n    return new ParameterizedSQL('');\n  }\n  const self = this;\n  const props = self.getModelDefinition(model).properties;\n\n  const whereStmts = [];\n  for (const key in where) {\n    const stmt = new ParameterizedSQL('', []);\n    // Handle and/or operators\n    if (key === 'and' || key === 'or') {\n      const branches = [];\n      let branchParams = [];\n      const clauses = where[key];\n      if (Array.isArray(clauses)) {\n        for (let i = 0, n = clauses.length; i < n; i++) {\n          const stmtForClause = self._buildWhere(model, clauses[i]);\n          if (stmtForClause.sql) {\n            stmtForClause.sql = '(' + stmtForClause.sql + ')';\n            branchParams = branchParams.concat(stmtForClause.params);\n            branches.push(stmtForClause.sql);\n          }\n        }\n        if (branches.length > 0) {\n          stmt.merge({\n            sql: '(' + branches.join(' ' + key.toUpperCase() + ' ') + ')',\n            params: branchParams,\n          });\n          whereStmts.push(stmt);\n        }\n        continue;\n      }\n      // The value is not an array, fall back to regular fields\n    }\n    let p = props[key];\n\n    if (p == null && isNested(key)) {\n      // See if we are querying nested json\n      p = props[key.split('.')[0]];\n    }\n\n    if (p == null) {\n      // Unknown property, ignore it\n      debug('Unknown property %s is skipped for model %s', key, model);\n      continue;\n    }\n    // eslint-disable one-var\n    let expression = where[key];\n    const columnName = self.columnEscaped(model, key);\n    // eslint-enable one-var\n    if (expression === null || expression === undefined) {\n      stmt.merge(columnName + ' IS NULL');\n    } else if (expression && expression.constructor === Object) {\n      const operator = Object.keys(expression)[0];\n      // Get the expression without the operator\n      expression = expression[operator];\n      if (operator === 'inq' || operator === 'nin' || operator === 'between') {\n        columnValue = [];\n        if (Array.isArray(expression)) {\n          // Column value is a list\n          for (let j = 0, m = expression.length; j < m; j++) {\n            columnValue.push(this.toColumnValue(p, expression[j], true));\n          }\n        } else {\n          columnValue.push(this.toColumnValue(p, expression, true));\n        }\n        if (operator === 'between') {\n          // BETWEEN v1 AND v2\n          const v1 = columnValue[0] === undefined ? null : columnValue[0];\n          const v2 = columnValue[1] === undefined ? null : columnValue[1];\n          columnValue = [v1, v2];\n        } else {\n          // IN (v1,v2,v3) or NOT IN (v1,v2,v3)\n          if (columnValue.length === 0) {\n            if (operator === 'inq') {\n              columnValue = [null];\n            } else {\n              // nin () is true\n              continue;\n            }\n          }\n        }\n      } else if (operator === 'regexp' && expression instanceof RegExp) {\n        // do not coerce RegExp based on property definitions\n        columnValue = expression;\n      } else {\n        columnValue = this.toColumnValue(p, expression, true);\n      }\n      sqlExp = self.buildExpression(columnName, operator, columnValue, p);\n      stmt.merge(sqlExp);\n    } else {\n      // The expression is the field value, not a condition\n      columnValue = self.toColumnValue(p, expression);\n      if (columnValue === null) {\n        stmt.merge(columnName + ' IS NULL');\n      } else {\n        if (columnValue instanceof ParameterizedSQL) {\n          if (p.type.name === 'GeoPoint')\n            stmt.merge(columnName + '~=').merge(columnValue);\n          else\n            stmt.merge(columnName + '=').merge(columnValue);\n        } else {\n          stmt.merge({\n            sql: columnName + '=?',\n            params: [columnValue],\n          });\n        }\n      }\n    }\n    whereStmts.push(stmt);\n  }\n  let params = [];\n  const sqls = [];\n  for (let k = 0, s = whereStmts.length; k < s; k++) {\n    sqls.push(whereStmts[k].sql);\n    params = params.concat(whereStmts[k].params);\n  }\n  const whereStmt = new ParameterizedSQL({\n    sql: sqls.join(' AND '),\n    params: params,\n  });\n  return whereStmt;\n};\n\n/*!\n * Convert property name/value to an escaped DB column value\n * @param {Object} prop Property descriptor\n * @param {*} val Property value\n * @param {boolean} isWhereClause\n * @returns {*} The escaped value of DB column\n */\nPostgreSQL.prototype.toColumnValue = function(prop, val, isWhereClause) {\n  if (val == null) {\n    // PostgreSQL complains with NULLs in not null columns\n    // If we have an autoincrement value, return DEFAULT instead\n    // Do not return 'DEFAULT' for id field in where clause\n    if (prop.autoIncrement || (prop.id && !isWhereClause)) {\n      return new ParameterizedSQL('DEFAULT');\n    } else {\n      return null;\n    }\n  }\n  if (prop.type === String) {\n    return String(val);\n  }\n  if (prop.type === Number) {\n    if (isNaN(val)) {\n      // Map NaN to NULL\n      return val;\n    }\n    return val;\n  }\n\n  if (prop.type === Date || prop.type.name === 'Timestamp') {\n    if (!val.toISOString) {\n      val = new Date(val);\n    }\n    const iso = val.toISOString();\n\n    // Pass in date as UTC and make sure Postgresql stores using UTC timezone\n    return new ParameterizedSQL({\n      sql: '?::TIMESTAMP WITH TIME ZONE',\n      params: [iso],\n    });\n  }\n\n  // PostgreSQL support char(1) Y/N\n  if (prop.type === Boolean) {\n    if (val) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  if (prop.type.name === 'GeoPoint' || prop.type.name === 'Point') {\n    return new ParameterizedSQL({\n      sql: 'point(?,?)',\n      // Postgres point is point(lng, lat)\n      params: [val.lng, val.lat],\n    });\n  }\n\n  if (Array.isArray(prop.type)) {\n    // There is two possible cases for the type of \"val\" as well as two cases for dataType\n    const isArrayDataType = prop.postgresql && prop.postgresql.dataType === 'varchar[]';\n    if (Array.isArray(val)) {\n      if (isArrayDataType) {\n        return val;\n      } else {\n        return JSON.stringify(val);\n      }\n    } else {\n      if (isArrayDataType) {\n        return JSON.parse(val);\n      } else {\n        return val;\n      }\n    }\n  }\n\n  return val;\n};\n\n/**\n * Get the place holder in SQL for identifiers, such as ??\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nPostgreSQL.prototype.getPlaceholderForIdentifier = function(key) {\n  throw new Error(g.f('{{Placeholder}} for identifiers is not supported'));\n};\n\n/**\n * Get the place holder in SQL for values, such as :1 or ?\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nPostgreSQL.prototype.getPlaceholderForValue = function(key) {\n  return '$' + key;\n};\n\nPostgreSQL.prototype.getCountForAffectedRows = function(model, info) {\n  return info && info.affectedRows;\n};\n\nrequire('./discovery')(PostgreSQL);\nrequire('./migration')(PostgreSQL);\nrequire('./transaction')(PostgreSQL);\n"], "fixing_code": ["// Copyright IBM Corp. 2013,2020. All Rights Reserved.\n// Node module: loopback-connector-postgresql\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n/*!\n * PostgreSQL connector for LoopBack\n */\n'use strict';\nconst SG = require('strong-globalize');\nconst g = SG();\nconst postgresql = require('pg');\nconst SqlConnector = require('loopback-connector').SqlConnector;\nconst ParameterizedSQL = SqlConnector.ParameterizedSQL;\nconst util = require('util');\nconst debug = require('debug')('loopback:connector:postgresql');\nconst debugData = require('debug')('loopback:connector:postgresql:data');\nconst debugSort = require('debug')('loopback:connector:postgresql:order');\nconst Promise = require('bluebird');\n\n/**\n *\n * Initialize the PostgreSQL connector against the given data source\n *\n * @param {DataSource} dataSource The loopback-datasource-juggler dataSource\n * @callback {Function} [callback] The callback function\n * @param {String|Error} err The error string or object\n * @header PostgreSQL.initialize(dataSource, [callback])\n */\nexports.initialize = function initializeDataSource(dataSource, callback) {\n  if (!postgresql) {\n    return;\n  }\n\n  const dbSettings = dataSource.settings || {};\n  dbSettings.host = dbSettings.host || dbSettings.hostname || 'localhost';\n  dbSettings.user = dbSettings.user || dbSettings.username;\n\n  dataSource.connector = new PostgreSQL(postgresql, dbSettings);\n  dataSource.connector.dataSource = dataSource;\n\n  if (callback) {\n    if (dbSettings.lazyConnect) {\n      process.nextTick(callback);\n    } else {\n      dataSource.connecting = true;\n      dataSource.connector.connect(callback);\n    }\n  }\n};\n\n/**\n * PostgreSQL connector constructor\n *\n * @param {PostgreSQL} postgresql PostgreSQL node.js binding\n * @options {Object} settings An object for the data source settings.\n * See [node-postgres documentation](https://node-postgres.com/api/client).\n * @property {String} url URL to the database, such as 'postgres://test:mypassword@localhost:5432/devdb'.\n * Other parameters can be defined as query string of the url\n * @property {String} hostname The host name or ip address of the PostgreSQL DB server\n * @property {Number} port The port number of the PostgreSQL DB Server\n * @property {String} user The user name\n * @property {String} password The password\n * @property {String} database The database name\n * @property {Boolean} ssl Whether to try SSL/TLS to connect to server\n * @property {Function | string} [onError] Optional hook to connect to the pg pool 'error' event,\n * or the string 'ignore' to record them with `debug` and otherwise ignore them.\n *\n * @constructor\n */\nfunction PostgreSQL(postgresql, settings) {\n  // this.name = 'postgresql';\n  // this._models = {};\n  // this.settings = settings;\n  this.constructor.super_.call(this, 'postgresql', settings);\n  this.clientConfig = settings;\n  if (settings.url) {\n    // pg-pool doesn't handle string config correctly\n    this.clientConfig.connectionString = settings.url;\n  }\n  this.clientConfig.Promise = Promise;\n  this.pg = new postgresql.Pool(this.clientConfig);\n\n  if (settings.onError) {\n    if (settings.onError === 'ignore') {\n      this.pg.on('error', function(err) {\n        debug(err);\n      });\n    } else {\n      this.pg.on('error', settings.onError);\n    }\n  }\n\n  this.settings = settings;\n  debug('Settings %j', {\n    ...settings,\n    ...(typeof settings.url !== 'undefined' && {\n      get url() {\n        const url = new URL(settings.url);\n        if (url.password !== '') url.password = '***';\n        return url.toString();\n      },\n    }),\n    ...(typeof settings.password !== 'undefined' && {password: '***'}),\n  });\n}\n\n// Inherit from loopback-datasource-juggler BaseSQL\nutil.inherits(PostgreSQL, SqlConnector);\n\nPostgreSQL.prototype.getDefaultSchemaName = function() {\n  return 'public';\n};\n\n/**\n * Connect to PostgreSQL\n * @callback {Function} [callback] The callback after the connection is established\n */\nPostgreSQL.prototype.connect = function(callback) {\n  const self = this;\n  self.pg.connect(function(err, client, releaseCb) {\n    self.client = client;\n    process.nextTick(releaseCb);\n    callback && callback(err, client);\n  });\n};\n\n/**\n * Execute the sql statement\n *\n * @param {String} sql The SQL statement\n * @param {String[]} params The parameter values for the SQL statement\n * @param {Object} [options] Options object\n * @callback {Function} [callback] The callback after the SQL statement is executed\n * @param {String|Error} err The error string or object\n * @param {Object[]} data The result from the SQL\n */\nPostgreSQL.prototype.executeSQL = function(sql, params, options, callback) {\n  const self = this;\n\n  if (params && params.length > 0) {\n    debug('SQL: %s\\nParameters: %j', sql, params);\n  } else {\n    debug('SQL: %s', sql);\n  }\n\n  function executeWithConnection(connection, releaseCb) {\n    connection.query(sql, params, function(err, data) {\n      // if(err) console.error(err);\n      if (err) debug(err);\n      if (data) debugData('%j', data);\n      // Release the connection back to the pool.\n      if (releaseCb) releaseCb(err);\n      let result = null;\n      if (data) {\n        switch (data.command) {\n          case 'DELETE':\n          case 'UPDATE':\n            result = {affectedRows: data.rowCount, count: data.rowCount};\n\n            if (data.rows)\n              result.rows = data.rows;\n\n            break;\n          default:\n            result = data.rows;\n        }\n      }\n      callback(err ? err : null, result);\n    });\n  }\n\n  const transaction = options.transaction;\n  if (transaction && transaction.connector === this) {\n    if (!transaction.connection) {\n      return process.nextTick(function() {\n        callback(new Error(g.f('Connection does not exist')));\n      });\n    }\n    if (transaction.txId !== transaction.connection.txId) {\n      return process.nextTick(function() {\n        callback(new Error(g.f('Transaction is not active')));\n      });\n    }\n    debug('Execute SQL within a transaction');\n    // Do not release the connection\n    executeWithConnection(transaction.connection, null);\n  } else {\n    self.pg.connect(function(err, connection, releaseCb) {\n      if (err) return callback(err);\n      executeWithConnection(connection, releaseCb);\n    });\n  }\n};\n\nPostgreSQL.prototype.buildInsertReturning = function(model, data, options) {\n  const idColumnNames = [];\n  const idNames = this.idNames(model);\n  for (let i = 0, n = idNames.length; i < n; i++) {\n    idColumnNames.push(this.columnEscaped(model, idNames[i]));\n  }\n  return 'RETURNING ' + idColumnNames.join(',');\n};\n\n/**\n * Check if id types have a numeric type\n * @param {String} model name\n * @returns {Boolean}\n */\nPostgreSQL.prototype.hasOnlyNumericIds = function(model) {\n  const cols = this.getModelDefinition(model).properties;\n  const idNames = this.idNames(model);\n  const numericIds = idNames.filter(function(idName) {\n    return cols[idName].type === Number;\n  });\n\n  return numericIds.length == idNames.length;\n};\n\n/**\n * Get default find sort policy\n * @param model\n */\nPostgreSQL.prototype.getDefaultIdSortPolicy = function(model) {\n  const modelClass = this._models[model];\n\n  if (modelClass.settings.hasOwnProperty('defaultIdSort')) {\n    return modelClass.settings.defaultIdSort;\n  }\n\n  if (this.settings.hasOwnProperty('defaultIdSort')) {\n    return this.settings.defaultIdSort;\n  }\n\n  return null;\n};\n\n/**\n * Build a SQL SELECT statement\n * @param {String} model Model name\n * @param {Object} filter Filter object\n * @param {Object} options Options object\n * @returns {ParameterizedSQL} Statement object {sql: ..., params: ...}\n */\nPostgreSQL.prototype.buildSelect = function(model, filter) {\n  let sortById;\n\n  const sortPolicy = this.getDefaultIdSortPolicy(model);\n\n  switch (sortPolicy) {\n    case 'numericIdOnly':\n      sortById = this.hasOnlyNumericIds(model);\n      break;\n    case false:\n      sortById = false;\n      break;\n    default:\n      sortById = true;\n      break;\n  }\n\n  debugSort(model, 'sort policy:', sortPolicy, sortById);\n\n  if (sortById && !filter.order) {\n    const idNames = this.idNames(model);\n    if (idNames && idNames.length) {\n      filter.order = idNames;\n    }\n  }\n\n  let selectStmt = new ParameterizedSQL('SELECT ' +\n    this.buildColumnNames(model, filter) +\n    ' FROM ' + this.tableEscaped(model));\n\n  if (filter) {\n    if (filter.where) {\n      const whereStmt = this.buildWhere(model, filter.where);\n      selectStmt.merge(whereStmt);\n    }\n\n    if (filter.order) {\n      selectStmt.merge(this.buildOrderBy(model, filter.order));\n    }\n\n    if (filter.limit || filter.skip || filter.offset) {\n      selectStmt = this.applyPagination(\n        model, selectStmt, filter,\n      );\n    }\n  }\n  return this.parameterize(selectStmt);\n};\n\nPostgreSQL.prototype.buildInsertDefaultValues = function(model, data, options) {\n  return 'DEFAULT VALUES';\n};\n\n// FIXME: [rfeng] The native implementation of upsert only works with\n// postgresql 9.1 or later as it requres writable CTE\n// See https://github.com/strongloop/loopback-connector-postgresql/issues/27\n/**\n * Update if the model instance exists with the same id or create a new instance\n *\n * @param {String} model The model name\n * @param {Object} data The model instance data\n * @callback {Function} [callback] The callback function\n * @param {String|Error} err The error string or object\n * @param {Object} The updated model instance\n */\n/*\n PostgreSQL.prototype.updateOrCreate = function (model, data, callback) {\n var self = this;\n data = self.mapToDB(model, data);\n var props = self._categorizeProperties(model, data);\n var idColumns = props.ids.map(function(key) {\n return self.columnEscaped(model, key); }\n );\n var nonIdsInData = props.nonIdsInData;\n var query = [];\n query.push('WITH update_outcome AS (UPDATE ', self.tableEscaped(model), ' SET ');\n query.push(self.toFields(model, data, false));\n query.push(' WHERE ');\n query.push(idColumns.map(function (key, i) {\n return ((i > 0) ? ' AND ' : ' ') + key + '=$' + (nonIdsInData.length + i + 1);\n }).join(','));\n query.push(' RETURNING ', idColumns.join(','), ')');\n query.push(', insert_outcome AS (INSERT INTO ', self.tableEscaped(model), ' ');\n query.push(self.toFields(model, data, true));\n query.push(' WHERE NOT EXISTS (SELECT * FROM update_outcome) RETURNING ', idColumns.join(','), ')');\n query.push(' SELECT * FROM update_outcome UNION ALL SELECT * FROM insert_outcome');\n var queryParams = [];\n nonIdsInData.forEach(function(key) {\n queryParams.push(data[key]);\n });\n props.ids.forEach(function(key) {\n queryParams.push(data[key] || null);\n });\n var idColName = self.idColumn(model);\n self.query(query.join(''), queryParams, function(err, info) {\n if (err) {\n return callback(err);\n }\n var idValue = null;\n if (info && info[0]) {\n idValue = info[0][idColName];\n }\n callback(err, idValue);\n });\n };\n */\n\nPostgreSQL.prototype.fromColumnValue = function(prop, val) {\n  if (val == null) {\n    return val;\n  }\n  const type = prop.type && prop.type.name;\n  if (prop && type === 'Boolean') {\n    if (typeof val === 'boolean') {\n      return val;\n    } else {\n      return (val === 'Y' || val === 'y' || val === 'T' ||\n      val === 't' || val === '1');\n    }\n  } else if (prop && type === 'GeoPoint' || type === 'Point') {\n    if (typeof val === 'string') {\n      // The point format is (x,y)\n      const point = val.split(/[\\(\\)\\s,]+/).filter(Boolean);\n      return {\n        lat: +point[0],\n        lng: +point[1],\n      };\n    } else if (typeof val === 'object' && val !== null) {\n      // Now pg driver converts point to {x: lng, y: lat}\n      return {\n        lng: val.x,\n        lat: val.y,\n      };\n    } else {\n      return val;\n    }\n  } else {\n    return val;\n  }\n};\n\n/*!\n * Convert to the Database name\n * @param {String} name The name\n * @returns {String} The converted name\n */\nPostgreSQL.prototype.dbName = function(name) {\n  if (!name) {\n    return name;\n  }\n  // PostgreSQL default to lowercase names\n  return name.toLowerCase();\n};\n\nfunction escapeIdentifier(str) {\n  let escaped = '\"';\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    if (c === '\"') {\n      escaped += c + c;\n    } else {\n      escaped += c;\n    }\n  }\n  escaped += '\"';\n  return escaped;\n}\n\nfunction escapeLiteral(str) {\n  let hasBackslash = false;\n  let escaped = '\\'';\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i];\n    if (c === '\\'') {\n      escaped += c + c;\n    } else if (c === '\\\\') {\n      escaped += c + c;\n      hasBackslash = true;\n    } else {\n      escaped += c;\n    }\n  }\n  escaped += '\\'';\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped;\n  }\n  return escaped;\n}\n\n/*\n * Check if a value is attempting to use nested json keys\n * @param {String} property The property being queried from where clause\n * @returns {Boolean} True of the property contains dots for nested json\n */\nfunction isNested(property) {\n  return property.split('.').length > 1;\n}\n\n/*\n * Overwrite the loopback-connector column escape\n * to allow querying nested json keys\n * @param {String} model The model name\n * @param {String} property The property name\n * @returns {String} The escaped column name, or column with nested keys for deep json columns\n */\nPostgreSQL.prototype.columnEscaped = function(model, property) {\n  if (isNested(property)) {\n    // Convert column to PostgreSQL json style query: \"model\"->>'val'\n    const self = this;\n    return property\n      .split('.')\n      .map(function(val, idx) { return (idx === 0 ? self.columnEscaped(model, val) : escapeLiteral(val)); })\n      .reduce(function(prev, next, idx, arr) {\n        return idx == 0 ? next : idx < arr.length - 1 ? prev + '->' + next : prev + '->>' + next;\n      });\n  } else {\n    return this.escapeName(this.column(model, property));\n  }\n};\n\n/*!\n * Escape the name for PostgreSQL DB\n * @param {String} name The name\n * @returns {String} The escaped name\n */\nPostgreSQL.prototype.escapeName = function(name) {\n  if (!name) {\n    return name;\n  }\n  return escapeIdentifier(name);\n};\n\nPostgreSQL.prototype.escapeValue = function(value) {\n  if (typeof value === 'string') {\n    return escapeLiteral(value);\n  }\n  if (typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  // Can't send functions, objects, arrays\n  if (typeof value === 'object' || typeof value === 'function') {\n    return null;\n  }\n  return value;\n};\n\nPostgreSQL.prototype.tableEscaped = function(model) {\n  const schema = this.schema(model) || 'public';\n  return this.escapeName(schema) + '.' +\n    this.escapeName(this.table(model));\n};\n\nfunction buildLimit(limit, offset) {\n  const clause = [];\n  if (isNaN(limit)) {\n    limit = 0;\n  }\n  if (isNaN(offset)) {\n    offset = 0;\n  }\n  if (!limit && !offset) {\n    return '';\n  }\n  if (limit) {\n    clause.push('LIMIT ' + limit);\n  }\n  if (offset) {\n    clause.push('OFFSET ' + offset);\n  }\n  return clause.join(' ');\n}\n\nPostgreSQL.prototype.applyPagination = function(model, stmt, filter) {\n  const limitClause = buildLimit(filter.limit, filter.offset || filter.skip);\n  return stmt.merge(limitClause);\n};\n\nPostgreSQL.prototype.buildExpression = function(columnName, operator,\n  operatorValue, propertyDefinition) {\n  switch (operator) {\n    case 'like':\n      return new ParameterizedSQL(columnName + \"::TEXT LIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'ilike':\n      return new ParameterizedSQL(columnName + \"::TEXT ILIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'nlike':\n      return new ParameterizedSQL(columnName + \"::TEXT NOT LIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'nilike':\n      return new ParameterizedSQL(columnName + \"::TEXT NOT ILIKE ? ESCAPE E'\\\\\\\\'\",\n        [operatorValue]);\n    case 'regexp':\n      if (operatorValue.global)\n        g.warn('{{PostgreSQL}} regex syntax does not respect the {{`g`}} flag');\n\n      if (operatorValue.multiline)\n        g.warn('{{PostgreSQL}} regex syntax does not respect the {{`m`}} flag');\n\n      const regexOperator = operatorValue.ignoreCase ? ' ~* ?' : ' ~ ?';\n      return new ParameterizedSQL(columnName + regexOperator,\n        [operatorValue.source]);\n    case 'contains':\n      return new ParameterizedSQL(columnName + ' @> array[' + operatorValue.map(() => '?') + ']::'\n        + propertyDefinition.postgresql.dataType,\n        operatorValue);\n    case 'match':\n      return new ParameterizedSQL(`to_tsvector(${columnName}) @@ to_tsquery(?)`, [operatorValue]);\n    default:\n      // invoke the base implementation of `buildExpression`\n      return this.invokeSuper('buildExpression', columnName, operator,\n        operatorValue, propertyDefinition);\n  }\n};\n\n/**\n * Disconnect from PostgreSQL\n * @param {Function} [cb] The callback function\n */\nPostgreSQL.prototype.disconnect = function disconnect(cb) {\n  if (this.pg) {\n    debug('Disconnecting from ' + this.settings.hostname);\n    const pg = this.pg;\n    this.pg = null;\n    pg.end(); // This is sync\n  }\n\n  if (cb) {\n    process.nextTick(cb);\n  }\n};\n\nPostgreSQL.prototype.ping = function(cb) {\n  this.execute('SELECT 1 AS result', [], cb);\n};\n\nPostgreSQL.prototype.getInsertedId = function(model, info) {\n  const idColName = this.idColumn(model);\n  let idValue;\n  if (info && info[0]) {\n    idValue = info[0][idColName];\n  }\n  return idValue;\n};\n\n/**\n * Build the SQL WHERE clause for the where object\n * @param {string} model Model name\n * @param {object} where An object for the where conditions\n * @returns {ParameterizedSQL} The SQL WHERE clause\n */\nPostgreSQL.prototype.buildWhere = function(model, where) {\n  const whereClause = this._buildWhere(model, where);\n  if (whereClause.sql) {\n    whereClause.sql = 'WHERE ' + whereClause.sql;\n  }\n  return whereClause;\n};\n\n/**\n * @private\n * @param model\n * @param where\n * @returns {ParameterizedSQL}\n */\nPostgreSQL.prototype._buildWhere = function(model, where) {\n  let columnValue, sqlExp;\n  if (!where) {\n    return new ParameterizedSQL('');\n  }\n  if (typeof where !== 'object' || Array.isArray(where)) {\n    debug('Invalid value for where: %j', where);\n    return new ParameterizedSQL('');\n  }\n  const self = this;\n  const props = self.getModelDefinition(model).properties;\n\n  const whereStmts = [];\n  for (const key in where) {\n    const stmt = new ParameterizedSQL('', []);\n    // Handle and/or operators\n    if (key === 'and' || key === 'or') {\n      const branches = [];\n      let branchParams = [];\n      const clauses = where[key];\n      if (Array.isArray(clauses)) {\n        for (let i = 0, n = clauses.length; i < n; i++) {\n          const stmtForClause = self._buildWhere(model, clauses[i]);\n          if (stmtForClause.sql) {\n            stmtForClause.sql = '(' + stmtForClause.sql + ')';\n            branchParams = branchParams.concat(stmtForClause.params);\n            branches.push(stmtForClause.sql);\n          }\n        }\n        if (branches.length > 0) {\n          stmt.merge({\n            sql: '(' + branches.join(' ' + key.toUpperCase() + ' ') + ')',\n            params: branchParams,\n          });\n          whereStmts.push(stmt);\n        }\n        continue;\n      }\n      // The value is not an array, fall back to regular fields\n    }\n    let p = props[key];\n\n    if (p == null && isNested(key)) {\n      // See if we are querying nested json\n      p = props[key.split('.')[0]];\n    }\n\n    if (p == null) {\n      // Unknown property, ignore it\n      debug('Unknown property %s is skipped for model %s', key, model);\n      continue;\n    }\n    // eslint-disable one-var\n    let expression = where[key];\n    const columnName = self.columnEscaped(model, key);\n    // eslint-enable one-var\n    if (expression === null || expression === undefined) {\n      stmt.merge(columnName + ' IS NULL');\n    } else if (expression && expression.constructor === Object) {\n      const operator = Object.keys(expression)[0];\n      // Get the expression without the operator\n      expression = expression[operator];\n      if (operator === 'inq' || operator === 'nin' || operator === 'between') {\n        columnValue = [];\n        if (Array.isArray(expression)) {\n          // Column value is a list\n          for (let j = 0, m = expression.length; j < m; j++) {\n            columnValue.push(this.toColumnValue(p, expression[j], true));\n          }\n        } else {\n          columnValue.push(this.toColumnValue(p, expression, true));\n        }\n        if (operator === 'between') {\n          // BETWEEN v1 AND v2\n          const v1 = columnValue[0] === undefined ? null : columnValue[0];\n          const v2 = columnValue[1] === undefined ? null : columnValue[1];\n          columnValue = [v1, v2];\n        } else {\n          // IN (v1,v2,v3) or NOT IN (v1,v2,v3)\n          if (columnValue.length === 0) {\n            if (operator === 'inq') {\n              columnValue = [null];\n            } else {\n              // nin () is true\n              continue;\n            }\n          }\n        }\n      } else if (operator === 'regexp' && expression instanceof RegExp) {\n        // do not coerce RegExp based on property definitions\n        columnValue = expression;\n      } else {\n        columnValue = this.toColumnValue(p, expression, true);\n      }\n      sqlExp = self.buildExpression(columnName, operator, columnValue, p);\n      stmt.merge(sqlExp);\n    } else {\n      // The expression is the field value, not a condition\n      columnValue = self.toColumnValue(p, expression);\n      if (columnValue === null) {\n        stmt.merge(columnName + ' IS NULL');\n      } else {\n        if (columnValue instanceof ParameterizedSQL) {\n          if (p.type.name === 'GeoPoint')\n            stmt.merge(columnName + '~=').merge(columnValue);\n          else\n            stmt.merge(columnName + '=').merge(columnValue);\n        } else {\n          stmt.merge({\n            sql: columnName + '=?',\n            params: [columnValue],\n          });\n        }\n      }\n    }\n    whereStmts.push(stmt);\n  }\n  let params = [];\n  const sqls = [];\n  for (let k = 0, s = whereStmts.length; k < s; k++) {\n    sqls.push(whereStmts[k].sql);\n    params = params.concat(whereStmts[k].params);\n  }\n  const whereStmt = new ParameterizedSQL({\n    sql: sqls.join(' AND '),\n    params: params,\n  });\n  return whereStmt;\n};\n\n/*!\n * Convert property name/value to an escaped DB column value\n * @param {Object} prop Property descriptor\n * @param {*} val Property value\n * @param {boolean} isWhereClause\n * @returns {*} The escaped value of DB column\n */\nPostgreSQL.prototype.toColumnValue = function(prop, val, isWhereClause) {\n  if (val == null) {\n    // PostgreSQL complains with NULLs in not null columns\n    // If we have an autoincrement value, return DEFAULT instead\n    // Do not return 'DEFAULT' for id field in where clause\n    if (prop.autoIncrement || (prop.id && !isWhereClause)) {\n      return new ParameterizedSQL('DEFAULT');\n    } else {\n      return null;\n    }\n  }\n  if (prop.type === String) {\n    return String(val);\n  }\n  if (prop.type === Number) {\n    if (isNaN(val)) {\n      // Map NaN to NULL\n      return val;\n    }\n    return val;\n  }\n\n  if (prop.type === Date || prop.type.name === 'Timestamp') {\n    if (!val.toISOString) {\n      val = new Date(val);\n    }\n    const iso = val.toISOString();\n\n    // Pass in date as UTC and make sure Postgresql stores using UTC timezone\n    return new ParameterizedSQL({\n      sql: '?::TIMESTAMP WITH TIME ZONE',\n      params: [iso],\n    });\n  }\n\n  // PostgreSQL support char(1) Y/N\n  if (prop.type === Boolean) {\n    if (val) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  if (prop.type.name === 'GeoPoint' || prop.type.name === 'Point') {\n    return new ParameterizedSQL({\n      sql: 'point(?,?)',\n      // Postgres point is point(lng, lat)\n      params: [val.lng, val.lat],\n    });\n  }\n\n  if (Array.isArray(prop.type)) {\n    // There is two possible cases for the type of \"val\" as well as two cases for dataType\n    const isArrayDataType = prop.postgresql && prop.postgresql.dataType === 'varchar[]';\n    if (Array.isArray(val)) {\n      if (isArrayDataType) {\n        return val;\n      } else {\n        return JSON.stringify(val);\n      }\n    } else {\n      if (isArrayDataType) {\n        return JSON.parse(val);\n      } else {\n        return val;\n      }\n    }\n  }\n\n  return val;\n};\n\n/**\n * Get the place holder in SQL for identifiers, such as ??\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nPostgreSQL.prototype.getPlaceholderForIdentifier = function(key) {\n  throw new Error(g.f('{{Placeholder}} for identifiers is not supported'));\n};\n\n/**\n * Get the place holder in SQL for values, such as :1 or ?\n * @param {String} key Optional key, such as 1 or id\n * @returns {String} The place holder\n */\nPostgreSQL.prototype.getPlaceholderForValue = function(key) {\n  return '$' + key;\n};\n\nPostgreSQL.prototype.getCountForAffectedRows = function(model, info) {\n  return info && info.affectedRows;\n};\n\nrequire('./discovery')(PostgreSQL);\nrequire('./migration')(PostgreSQL);\nrequire('./transaction')(PostgreSQL);\n"], "filenames": ["lib/postgresql.js"], "buggy_code_start_loc": [548], "buggy_code_end_loc": [552], "fixing_code_start_loc": [548], "fixing_code_end_loc": [553], "type": "CWE-89", "message": "Improper input validation on the `contains` LoopBack filter may allow for arbitrary SQL injection. When the extended filter property `contains` is permitted to be interpreted by the Postgres connector, it is possible to inject arbitrary SQL which may affect the confidentiality and integrity of data stored on the connected database. A patch was released in version 5.5.1. This affects users who does any of the following: - Connect to the database via the DataSource with `allowExtendedProperties: true` setting OR - Uses the connector's CRUD methods directly OR - Uses the connector's other methods to interpret the LoopBack filter. Users who are unable to upgrade should do the following if applicable: - Remove `allowExtendedProperties: true` DataSource setting - Add `allowExtendedProperties: false` DataSource setting - When passing directly to the connector functions, manually sanitize the user input for the `contains` LoopBack filter beforehand.", "other": {"cve": {"id": "CVE-2022-35942", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-12T23:15:07.717", "lastModified": "2022-08-16T16:11:07.357", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper input validation on the `contains` LoopBack filter may allow for arbitrary SQL injection. When the extended filter property `contains` is permitted to be interpreted by the Postgres connector, it is possible to inject arbitrary SQL which may affect the confidentiality and integrity of data stored on the connected database. A patch was released in version 5.5.1. This affects users who does any of the following: - Connect to the database via the DataSource with `allowExtendedProperties: true` setting OR - Uses the connector's CRUD methods directly OR - Uses the connector's other methods to interpret the LoopBack filter. Users who are unable to upgrade should do the following if applicable: - Remove `allowExtendedProperties: true` DataSource setting - Add `allowExtendedProperties: false` DataSource setting - When passing directly to the connector functions, manually sanitize the user input for the `contains` LoopBack filter beforehand."}, {"lang": "es", "value": "Una comprobaci\u00f3n de entrada inapropiada en el filtro \"contains\" de LoopBack puede permitir la inyecci\u00f3n arbitraria de SQL. Cuando es permitido que la propiedad del filtro extendido \"contains\" sea interpretada por el conector Postgres, es posible inyectar SQL arbitrario que puede afectar a la confidencialidad e integridad de los datos almacenados en la base de datos conectada. Ha sido publicado un parche en versi\u00f3n 5.5.1. Esto afecta a usuarios que realicen cualquiera de las siguientes acciones - Son conectados a la base de datos por medio del DataSource con el ajuste \"allowExtendedProperties: true\" O - Usan los m\u00e9todos CRUD del conector directamente O - Usan otros m\u00e9todos del conector para interpretar el filtro LoopBack. Los usuarios que no puedan actualizarse deber\u00e1n hacer lo siguiente, si procede: - Eliminar el par\u00e1metro \"allowExtendedProperties: true\" de la fuente de datos - A\u00f1adir el par\u00e1metro \"allowExtendedProperties: false\" de la fuente de datos - Cuando pase directamente a las funciones del conector, sanee manualmente la entrada del usuario para el filtro \"contains\" LoopBack de antemano."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.5, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:loopback-connector-postgresql:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.5.1", "matchCriteriaId": "D192247A-D1C7-4E2B-8C6E-684E28F4EC58"}]}]}], "references": [{"url": "https://github.com/loopbackio/loopback-connector-postgresql/commit/d57406c6737692a3a106b58a35406290cddb23e5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/loopbackio/loopback-connector-postgresql/security/advisories/GHSA-j259-6c58-9m58", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/loopbackio/loopback-connector-postgresql/commit/d57406c6737692a3a106b58a35406290cddb23e5"}}