{"buggy_code": ["package createconfig\n\nimport (\n\t\"strings\"\n\n\t\"github.com/docker/docker/daemon/caps\"\n\t\"github.com/docker/docker/pkg/mount\"\n\t\"github.com/docker/docker/profiles/seccomp\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"io/ioutil\"\n)\n\nconst cpuPeriod = 100000\n\n// CreateConfigToOCISpec parses information needed to create a container into an OCI runtime spec\nfunc CreateConfigToOCISpec(config *CreateConfig) (*spec.Spec, error) { //nolint\n\tcgroupPerm := \"ro\"\n\tg := generate.New()\n\tg.HostSpecific = true\n\taddCgroup := true\n\tif config.Privileged {\n\t\tcgroupPerm = \"rw\"\n\t\tg.RemoveMount(\"/sys\")\n\t\tsysMnt := spec.Mount{\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"sysfs\",\n\t\t\tSource:      \"sysfs\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"rw\"},\n\t\t}\n\t\tg.AddMount(sysMnt)\n\t} else if !config.UsernsMode.IsHost() && config.NetMode.IsHost() {\n\t\taddCgroup = false\n\t\tg.RemoveMount(\"/sys\")\n\t\tsysMnt := spec.Mount{\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"bind\",\n\t\t\tSource:      \"/sys\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\", \"rbind\"},\n\t\t}\n\t\tg.AddMount(sysMnt)\n\t}\n\n\tif addCgroup {\n\t\tcgroupMnt := spec.Mount{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tSource:      \"cgroup\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", cgroupPerm},\n\t\t}\n\t\tg.AddMount(cgroupMnt)\n\t}\n\tg.SetProcessCwd(config.WorkDir)\n\tg.SetProcessArgs(config.Command)\n\tg.SetProcessTerminal(config.Tty)\n\n\tfor key, val := range config.GetAnnotations() {\n\t\tg.AddAnnotation(key, val)\n\t}\n\tg.SetRootReadonly(config.ReadOnlyRootfs)\n\tg.SetHostname(config.Hostname)\n\tif config.Hostname != \"\" {\n\t\tg.AddProcessEnv(\"HOSTNAME\", config.Hostname)\n\t}\n\tfor sysctlKey, sysctlVal := range config.Sysctl {\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\tg.AddProcessEnv(\"container\", \"podman\")\n\n\t// RESOURCES - MEMORY\n\tif config.Resources.Memory != 0 {\n\t\tg.SetLinuxResourcesMemoryLimit(config.Resources.Memory)\n\t}\n\tif config.Resources.MemoryReservation != 0 {\n\t\tg.SetLinuxResourcesMemoryReservation(config.Resources.MemoryReservation)\n\t}\n\tif config.Resources.MemorySwap != 0 {\n\t\tg.SetLinuxResourcesMemorySwap(config.Resources.MemorySwap)\n\t}\n\tif config.Resources.KernelMemory != 0 {\n\t\tg.SetLinuxResourcesMemoryKernel(config.Resources.KernelMemory)\n\t}\n\tif config.Resources.MemorySwappiness != -1 {\n\t\tg.SetLinuxResourcesMemorySwappiness(uint64(config.Resources.MemorySwappiness))\n\t}\n\tg.SetLinuxResourcesMemoryDisableOOMKiller(config.Resources.DisableOomKiller)\n\tg.SetProcessOOMScoreAdj(config.Resources.OomScoreAdj)\n\n\t// RESOURCES - CPU\n\tif config.Resources.CPUShares != 0 {\n\t\tg.SetLinuxResourcesCPUShares(config.Resources.CPUShares)\n\t}\n\tif config.Resources.CPUQuota != 0 {\n\t\tg.SetLinuxResourcesCPUQuota(config.Resources.CPUQuota)\n\t}\n\tif config.Resources.CPUPeriod != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(config.Resources.CPUPeriod)\n\t}\n\tif config.Resources.CPUs != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(cpuPeriod)\n\t\tg.SetLinuxResourcesCPUQuota(int64(config.Resources.CPUs * cpuPeriod))\n\t}\n\tif config.Resources.CPURtRuntime != 0 {\n\t\tg.SetLinuxResourcesCPURealtimeRuntime(config.Resources.CPURtRuntime)\n\t}\n\tif config.Resources.CPURtPeriod != 0 {\n\t\tg.SetLinuxResourcesCPURealtimePeriod(config.Resources.CPURtPeriod)\n\t}\n\tif config.Resources.CPUsetCPUs != \"\" {\n\t\tg.SetLinuxResourcesCPUCpus(config.Resources.CPUsetCPUs)\n\t}\n\tif config.Resources.CPUsetMems != \"\" {\n\t\tg.SetLinuxResourcesCPUMems(config.Resources.CPUsetMems)\n\t}\n\n\t// Devices\n\tif config.Privileged {\n\t\t// If privileged, we need to add all the host devices to the\n\t\t// spec.  We do not add the user provided ones because we are\n\t\t// already adding them all.\n\t\tif err := config.AddPrivilegedDevices(&g); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tfor _, device := range config.Devices {\n\t\t\tif err := addDevice(&g, device); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, uidmap := range config.IDMappings.UIDMap {\n\t\tg.AddLinuxUIDMapping(uint32(uidmap.HostID), uint32(uidmap.ContainerID), uint32(uidmap.Size))\n\t}\n\tfor _, gidmap := range config.IDMappings.GIDMap {\n\t\tg.AddLinuxGIDMapping(uint32(gidmap.HostID), uint32(gidmap.ContainerID), uint32(gidmap.Size))\n\t}\n\t// SECURITY OPTS\n\tg.SetProcessNoNewPrivileges(config.NoNewPrivs)\n\tg.SetProcessApparmorProfile(config.ApparmorProfile)\n\tg.SetProcessSelinuxLabel(config.ProcessLabel)\n\tg.SetLinuxMountLabel(config.MountLabel)\n\tblockAccessToKernelFilesystems(config, &g)\n\n\t// RESOURCES - PIDS\n\tif config.Resources.PidsLimit != 0 {\n\t\tg.SetLinuxResourcesPidsLimit(config.Resources.PidsLimit)\n\t}\n\n\tfor _, i := range config.Tmpfs {\n\t\t// Default options if nothing passed\n\t\toptions := []string{\"rw\", \"noexec\", \"nosuid\", \"nodev\", \"size=65536k\"}\n\t\tspliti := strings.SplitN(i, \":\", 2)\n\t\tif len(spliti) > 1 {\n\t\t\tif _, _, err := mount.ParseTmpfsOptions(spliti[1]); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toptions = strings.Split(spliti[1], \",\")\n\t\t}\n\t\ttmpfsMnt := spec.Mount{\n\t\t\tDestination: spliti[0],\n\t\t\tType:        \"tmpfs\",\n\t\t\tSource:      \"tmpfs\",\n\t\t\tOptions:     append(options, \"tmpcopyup\"),\n\t\t}\n\t\tg.AddMount(tmpfsMnt)\n\t}\n\n\tfor name, val := range config.Env {\n\t\tg.AddProcessEnv(name, val)\n\t}\n\n\tif err := addRlimits(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addPidNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addUserNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addNetNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addUTSNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addIpcNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\tconfigSpec := g.Spec()\n\n\t// HANDLE CAPABILITIES\n\t// NOTE: Must happen before SECCOMP\n\tif !config.Privileged {\n\t\tif err := setupCapabilities(config, configSpec); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tg.SetupPrivileged(true)\n\t}\n\n\t// HANDLE SECCOMP\n\tif config.SeccompProfilePath != \"unconfined\" {\n\t\tif config.SeccompProfilePath != \"\" {\n\t\t\tseccompProfile, err := ioutil.ReadFile(config.SeccompProfilePath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"opening seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tseccompConfig, err := seccomp.LoadProfile(string(seccompProfile), configSpec)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"loading seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t\t} else {\n\t\t\tseccompConfig, err := seccomp.GetDefaultProfile(configSpec)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"loading seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t\t}\n\t}\n\n\t// Clear default Seccomp profile from Generator for privileged containers\n\tif config.SeccompProfilePath == \"unconfined\" || config.Privileged {\n\t\tconfigSpec.Linux.Seccomp = nil\n\t}\n\n\t// BIND MOUNTS\n\tmounts, err := config.GetVolumeMounts(configSpec.Mounts)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error getting volume mounts\")\n\t}\n\tconfigSpec.Mounts = append(configSpec.Mounts, mounts...)\n\tfor _, mount := range configSpec.Mounts {\n\t\tfor _, opt := range mount.Options {\n\t\t\tswitch opt {\n\t\t\tcase \"private\", \"rprivate\", \"slave\", \"rslave\", \"shared\", \"rshared\":\n\t\t\t\tif err := g.SetLinuxRootPropagation(opt); err != nil {\n\t\t\t\t\treturn nil, errors.Wrapf(err, \"error setting root propagation for %q\", mount.Destination)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// BLOCK IO\n\tblkio, err := config.CreateBlockIO()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error creating block io\")\n\t}\n\tif blkio != nil {\n\t\tconfigSpec.Linux.Resources.BlockIO = blkio\n\t}\n\n\t/*\n\t\t\t//Annotations\n\t\t\t\tResources: &configSpec.LinuxResources{\n\t\t\t\t\tBlockIO: &blkio,\n\t\t\t\t\t//HugepageLimits:\n\t\t\t\t\tNetwork: &configSpec.LinuxNetwork{\n\t\t\t\t\t// ClassID *uint32\n\t\t\t\t\t// Priorites []LinuxInterfacePriority\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t//CgroupsPath:\n\t\t\t\t//Namespaces: []LinuxNamespace\n\t\t\t\t// DefaultAction:\n\t\t\t\t// Architectures\n\t\t\t\t// Syscalls:\n\t\t\t\t},\n\t\t\t\t// RootfsPropagation\n\t\t\t\t// MaskedPaths\n\t\t\t\t// ReadonlyPaths:\n\t\t\t\t// IntelRdt\n\t\t\t},\n\t\t}\n\t*/\n\treturn configSpec, nil\n}\n\nfunc blockAccessToKernelFilesystems(config *CreateConfig, g *generate.Generator) {\n\tif !config.Privileged {\n\t\tfor _, mp := range []string{\n\t\t\t\"/proc/kcore\",\n\t\t\t\"/proc/latency_stats\",\n\t\t\t\"/proc/timer_list\",\n\t\t\t\"/proc/timer_stats\",\n\t\t\t\"/proc/sched_debug\",\n\t\t\t\"/proc/scsi\",\n\t\t\t\"/sys/firmware\",\n\t\t} {\n\t\t\tg.AddLinuxMaskedPaths(mp)\n\t\t}\n\n\t\tfor _, rp := range []string{\n\t\t\t\"/proc/asound\",\n\t\t\t\"/proc/bus\",\n\t\t\t\"/proc/fs\",\n\t\t\t\"/proc/irq\",\n\t\t\t\"/proc/sys\",\n\t\t\t\"/proc/sysrq-trigger\",\n\t\t} {\n\t\t\tg.AddLinuxReadonlyPaths(rp)\n\t\t}\n\t}\n}\n\nfunc addPidNS(config *CreateConfig, g *generate.Generator) error {\n\tpidMode := config.PidMode\n\tif pidMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(string(spec.PIDNamespace))\n\t}\n\tif pidMode.IsContainer() {\n\t\tlogrus.Debug(\"using container pidmode\")\n\t}\n\treturn nil\n}\n\nfunc addUserNS(config *CreateConfig, g *generate.Generator) error {\n\tif (len(config.IDMappings.UIDMap) > 0 || len(config.IDMappings.GIDMap) > 0) && !config.UsernsMode.IsHost() {\n\t\tg.AddOrReplaceLinuxNamespace(spec.UserNamespace, \"\")\n\t}\n\treturn nil\n}\n\nfunc addNetNS(config *CreateConfig, g *generate.Generator) error {\n\tnetMode := config.NetMode\n\tif netMode.IsHost() {\n\t\tlogrus.Debug(\"Using host netmode\")\n\t\treturn g.RemoveLinuxNamespace(spec.NetworkNamespace)\n\t} else if netMode.IsNone() {\n\t\tlogrus.Debug(\"Using none netmode\")\n\t\treturn nil\n\t} else if netMode.IsBridge() {\n\t\tlogrus.Debug(\"Using bridge netmode\")\n\t\treturn nil\n\t} else if netMode.IsContainer() {\n\t\tlogrus.Debug(\"Using container netmode\")\n\t} else {\n\t\treturn errors.Errorf(\"unknown network mode\")\n\t}\n\treturn nil\n}\n\nfunc addUTSNS(config *CreateConfig, g *generate.Generator) error {\n\tutsMode := config.UtsMode\n\tif utsMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(spec.UTSNamespace)\n\t}\n\treturn nil\n}\n\nfunc addIpcNS(config *CreateConfig, g *generate.Generator) error {\n\tipcMode := config.IpcMode\n\tif ipcMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(spec.IPCNamespace)\n\t}\n\tif ipcMode.IsContainer() {\n\t\tlogrus.Debug(\"Using container ipcmode\")\n\t}\n\n\treturn nil\n}\n\nfunc addRlimits(config *CreateConfig, g *generate.Generator) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t)\n\n\tfor _, u := range config.Resources.Ulimit {\n\t\tif ul, err = units.ParseUlimit(u); err != nil {\n\t\t\treturn errors.Wrapf(err, \"ulimit option %q requires name=SOFT:HARD, failed to be parsed\", u)\n\t\t}\n\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\treturn nil\n}\n\nfunc setupCapabilities(config *CreateConfig, configSpec *spec.Spec) error {\n\tvar err error\n\tvar caplist []string\n\tcaplist, err = caps.TweakCapabilities(configSpec.Process.Capabilities.Bounding, config.CapAdd, config.CapDrop)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfigSpec.Process.Capabilities.Bounding = caplist\n\tconfigSpec.Process.Capabilities.Permitted = caplist\n\tconfigSpec.Process.Capabilities.Inheritable = caplist\n\tconfigSpec.Process.Capabilities.Effective = caplist\n\treturn nil\n}\n\nfunc addDevice(g *generate.Generator, device string) error {\n\tdev, err := devices.DeviceFromPath(device, \"rwm\")\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"%s is not a valid device\", device)\n\t}\n\tlinuxdev := spec.LinuxDevice{\n\t\tPath:     dev.Path,\n\t\tType:     string(dev.Type),\n\t\tMajor:    dev.Major,\n\t\tMinor:    dev.Minor,\n\t\tFileMode: &dev.FileMode,\n\t\tUID:      &dev.Uid,\n\t\tGID:      &dev.Gid,\n\t}\n\tg.AddDevice(linuxdev)\n\tg.AddLinuxResourcesDevice(true, string(dev.Type), &dev.Major, &dev.Minor, dev.Permissions)\n\treturn nil\n}\n", "package integration\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/mrunalp/fileutils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Podman run\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest PodmanTest\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanCreate(tempdir)\n\t\tpodmanTest.RestoreAllArtifacts()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t})\n\n\tIt(\"podman run a container based on local image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run a container based on remote image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", BB_GLIBC, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run selinux grep test\", func() {\n\t\tselinux := podmanTest.SystemExec(\"ls\", []string{\"/usr/sbin/selinuxenabled\"})\n\t\tif selinux.ExitCode() != 0 {\n\t\t\tSkip(\"SELinux not enabled\")\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--security-opt\", \"label=level:s0:c1,c2\", ALPINE, \"cat\", \"/proc/self/attr/current\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(\"s0:c1,c2\")\n\t\tExpect(match).Should(BeTrue())\n\t})\n\n\tIt(\"podman run capabilities test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"sys_admin\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"setuid\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run environment test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"FOO=BAR\", ALPINE, \"printenv\", \"FOO\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(\"BAR\")\n\t\tExpect(match).Should(BeTrue())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"PATH=/bin\", ALPINE, \"printenv\", \"PATH\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"/bin\")\n\t\tExpect(match).Should(BeTrue())\n\n\t\tos.Setenv(\"FOO\", \"BAR\")\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"FOO\", ALPINE, \"printenv\", \"FOO\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"BAR\")\n\t\tExpect(match).Should(BeTrue())\n\t\tos.Unsetenv(\"FOO\")\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// This currently does not work\n\t\t// Re-enable when hostname is an env variable\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"sh\", \"-c\", \"printenv\"})\n\t\tsession.Wait(10)\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"HOSTNAME\")\n\t\tExpect(match).Should(BeTrue())\n\t})\n\n\tIt(\"podman run limits test\", func() {\n\t\tpodmanTest.RestoreArtifact(fedoraMinimal)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"rtprio=99\", \"--cap-add=sys_nice\", fedoraMinimal, \"cat\", \"/proc/self/sched\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=2048:2048\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2048\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=1024:1028\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1024\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-kill-disable=true\", fedoraMinimal, \"echo\", \"memory-hog\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-score-adj=100\", fedoraMinimal, \"cat\", \"/proc/self/oom_score_adj\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run with volume flag\", func() {\n\t\tSkip(\"Skip until we diagnose the regression of volume mounts\")\n\t\tmountPath := filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test rw,relatime\"))\n\n\t\tmountPath = filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test:ro\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test ro,relatime\"))\n\n\t\tmountPath = filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test:shared\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test rw,relatime, shared\"))\n\t})\n\n\tIt(\"podman run with cidfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cidfile\", \"/tmp/cidfile\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\terr := os.Remove(\"/tmp/cidfile\")\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run sysctl test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"net.core.somaxconn = 65535\"))\n\t})\n\n\tIt(\"podman run blkio-weight test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.weight\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"15\"))\n\t})\n\n\tIt(\"podman run device-read-bps test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_bps_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t})\n\n\tIt(\"podman run device-write-bps test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_bps_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t})\n\n\tIt(\"podman run device-read-iops test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_iops_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run device-write-iops test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_iops_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run notify_socket\", func() {\n\t\tsock := \"/run/sock\"\n\t\tos.Setenv(\"NOTIFY_SOCKET\", sock)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"printenv\", \"NOTIFY_SOCKET\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(sock)\n\t\tExpect(match).Should(BeTrue())\n\t\tos.Unsetenv(\"NOTIFY_SOCKET\")\n\t})\n\n\tIt(\"podman run log-opt\", func() {\n\t\tlog := filepath.Join(podmanTest.TempDir, \"/container.log\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--log-opt\", fmt.Sprintf(\"path=%s\", log), ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tfmt.Println(session.OutputToString())\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\t_, err := os.Stat(log)\n\t\tExpect(err).To(BeNil())\n\t\t_ = os.Remove(log)\n\t})\n\n\tIt(\"podman run tagged image\", func() {\n\t\ttag := podmanTest.Podman([]string{\"tag\", \"busybox\", \"bb\"})\n\t\ttag.WaitWithDefaultTimeout()\n\t\tExpect(tag.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"bb\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tfmt.Println(session.OutputToString())\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman test hooks\", func() {\n\t\thcheck := \"/run/hookscheck\"\n\t\thooksDir := \"/tmp/hooks\"\n\t\tos.Mkdir(hooksDir, 0755)\n\t\tfileutils.CopyFile(\"hooks/hooks.json\", hooksDir)\n\t\tos.Setenv(\"HOOK_OPTION\", fmt.Sprintf(\"--hooks-dir-path=%s\", hooksDir))\n\t\tos.Remove(hcheck)\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.Wait(10)\n\t\tos.Unsetenv(\"HOOK_OPTION\")\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run with secrets\", func() {\n\t\tcontainersDir := filepath.Join(podmanTest.TempDir, \"containers\")\n\t\terr := os.MkdirAll(containersDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsDir := filepath.Join(podmanTest.TempDir, \"rhel\", \"secrets\")\n\t\terr = os.MkdirAll(secretsDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tmountsFile := filepath.Join(containersDir, \"mounts.conf\")\n\t\tmountString := secretsDir + \":/run/secrets\"\n\t\terr = ioutil.WriteFile(mountsFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsFile := filepath.Join(secretsDir, \"test.txt\")\n\t\tsecretsString := \"Testing secrets mount. I am mounted!\"\n\t\terr = ioutil.WriteFile(secretsFile, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttargetDir := \"/tmp/symlink/target\"\n\t\terr = os.MkdirAll(targetDir, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tkeyFile := filepath.Join(targetDir, \"key.pem\")\n\t\terr = ioutil.WriteFile(keyFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\t\texecSession := podmanTest.SystemExec(\"ln\", []string{\"-s\", targetDir, filepath.Join(secretsDir, \"mysymlink\")})\n\t\texecSession.WaitWithDefaultTimeout()\n\t\tExpect(execSession.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"cat\", \"/run/secrets/test.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets/mysymlink\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"key.pem\"))\n\t})\n\n\tIt(\"podman run with FIPS mode secrets\", func() {\n\t\tfipsFile := \"/etc/system-fips\"\n\t\terr = ioutil.WriteFile(fipsFile, []byte{}, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"system-fips\"))\n\n\t\terr = os.Remove(fipsFile)\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run without group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)\"))\n\t})\n\n\tIt(\"podman run with group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--group-add=audio\", \"--group-add=nogroup\", \"--group-add=777\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),18(audio),20(dialout),26(tape),27(video),777,65533(nogroup)\"))\n\t})\n\n\tIt(\"podman run with user (default)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)\"))\n\t})\n\n\tIt(\"podman run with user (integer, not in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=1234 gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=12(mail) groups=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user (username)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=12(mail) groups=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user:group (username:integer)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail:21\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user:group (integer:groupname)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8:ftp\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with attach stdin outputs container ID\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--attach\", \"stdin\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tps := podmanTest.Podman([]string{\"ps\", \"-aq\", \"--no-trunc\"})\n\t\tps.WaitWithDefaultTimeout()\n\t\tExpect(ps.ExitCode()).To(Equal(0))\n\t\tExpect(ps.LineInOutputContains(session.OutputToString())).To(BeTrue())\n\t})\n\n\tIt(\"podman run with attach stdout does not print stderr\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stdout\", ALPINE, \"ls\", \"/doesnotexist\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run with attach stderr does not print stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stderr\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run attach nonsense errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"asdfasdf\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(125))\n\t})\n\n})\n"], "fixing_code": ["package createconfig\n\nimport (\n\t\"strings\"\n\n\t\"github.com/docker/docker/daemon/caps\"\n\t\"github.com/docker/docker/pkg/mount\"\n\t\"github.com/docker/docker/profiles/seccomp\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\tspec \"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-tools/generate\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/sirupsen/logrus\"\n\t\"io/ioutil\"\n)\n\nconst cpuPeriod = 100000\n\n// CreateConfigToOCISpec parses information needed to create a container into an OCI runtime spec\nfunc CreateConfigToOCISpec(config *CreateConfig) (*spec.Spec, error) { //nolint\n\tcgroupPerm := \"ro\"\n\tg := generate.New()\n\tg.HostSpecific = true\n\taddCgroup := true\n\tif config.Privileged {\n\t\tcgroupPerm = \"rw\"\n\t\tg.RemoveMount(\"/sys\")\n\t\tsysMnt := spec.Mount{\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"sysfs\",\n\t\t\tSource:      \"sysfs\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"rw\"},\n\t\t}\n\t\tg.AddMount(sysMnt)\n\t} else if !config.UsernsMode.IsHost() && config.NetMode.IsHost() {\n\t\taddCgroup = false\n\t\tg.RemoveMount(\"/sys\")\n\t\tsysMnt := spec.Mount{\n\t\t\tDestination: \"/sys\",\n\t\t\tType:        \"bind\",\n\t\t\tSource:      \"/sys\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\", \"rbind\"},\n\t\t}\n\t\tg.AddMount(sysMnt)\n\t}\n\n\tif addCgroup {\n\t\tcgroupMnt := spec.Mount{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tType:        \"cgroup\",\n\t\t\tSource:      \"cgroup\",\n\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", cgroupPerm},\n\t\t}\n\t\tg.AddMount(cgroupMnt)\n\t}\n\tg.SetProcessCwd(config.WorkDir)\n\tg.SetProcessArgs(config.Command)\n\tg.SetProcessTerminal(config.Tty)\n\n\tfor key, val := range config.GetAnnotations() {\n\t\tg.AddAnnotation(key, val)\n\t}\n\tg.SetRootReadonly(config.ReadOnlyRootfs)\n\tg.SetHostname(config.Hostname)\n\tif config.Hostname != \"\" {\n\t\tg.AddProcessEnv(\"HOSTNAME\", config.Hostname)\n\t}\n\tfor sysctlKey, sysctlVal := range config.Sysctl {\n\t\tg.AddLinuxSysctl(sysctlKey, sysctlVal)\n\t}\n\tg.AddProcessEnv(\"container\", \"podman\")\n\n\t// RESOURCES - MEMORY\n\tif config.Resources.Memory != 0 {\n\t\tg.SetLinuxResourcesMemoryLimit(config.Resources.Memory)\n\t}\n\tif config.Resources.MemoryReservation != 0 {\n\t\tg.SetLinuxResourcesMemoryReservation(config.Resources.MemoryReservation)\n\t}\n\tif config.Resources.MemorySwap != 0 {\n\t\tg.SetLinuxResourcesMemorySwap(config.Resources.MemorySwap)\n\t}\n\tif config.Resources.KernelMemory != 0 {\n\t\tg.SetLinuxResourcesMemoryKernel(config.Resources.KernelMemory)\n\t}\n\tif config.Resources.MemorySwappiness != -1 {\n\t\tg.SetLinuxResourcesMemorySwappiness(uint64(config.Resources.MemorySwappiness))\n\t}\n\tg.SetLinuxResourcesMemoryDisableOOMKiller(config.Resources.DisableOomKiller)\n\tg.SetProcessOOMScoreAdj(config.Resources.OomScoreAdj)\n\n\t// RESOURCES - CPU\n\tif config.Resources.CPUShares != 0 {\n\t\tg.SetLinuxResourcesCPUShares(config.Resources.CPUShares)\n\t}\n\tif config.Resources.CPUQuota != 0 {\n\t\tg.SetLinuxResourcesCPUQuota(config.Resources.CPUQuota)\n\t}\n\tif config.Resources.CPUPeriod != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(config.Resources.CPUPeriod)\n\t}\n\tif config.Resources.CPUs != 0 {\n\t\tg.SetLinuxResourcesCPUPeriod(cpuPeriod)\n\t\tg.SetLinuxResourcesCPUQuota(int64(config.Resources.CPUs * cpuPeriod))\n\t}\n\tif config.Resources.CPURtRuntime != 0 {\n\t\tg.SetLinuxResourcesCPURealtimeRuntime(config.Resources.CPURtRuntime)\n\t}\n\tif config.Resources.CPURtPeriod != 0 {\n\t\tg.SetLinuxResourcesCPURealtimePeriod(config.Resources.CPURtPeriod)\n\t}\n\tif config.Resources.CPUsetCPUs != \"\" {\n\t\tg.SetLinuxResourcesCPUCpus(config.Resources.CPUsetCPUs)\n\t}\n\tif config.Resources.CPUsetMems != \"\" {\n\t\tg.SetLinuxResourcesCPUMems(config.Resources.CPUsetMems)\n\t}\n\n\t// Devices\n\tif config.Privileged {\n\t\t// If privileged, we need to add all the host devices to the\n\t\t// spec.  We do not add the user provided ones because we are\n\t\t// already adding them all.\n\t\tif err := config.AddPrivilegedDevices(&g); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tfor _, device := range config.Devices {\n\t\t\tif err := addDevice(&g, device); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, uidmap := range config.IDMappings.UIDMap {\n\t\tg.AddLinuxUIDMapping(uint32(uidmap.HostID), uint32(uidmap.ContainerID), uint32(uidmap.Size))\n\t}\n\tfor _, gidmap := range config.IDMappings.GIDMap {\n\t\tg.AddLinuxGIDMapping(uint32(gidmap.HostID), uint32(gidmap.ContainerID), uint32(gidmap.Size))\n\t}\n\t// SECURITY OPTS\n\tg.SetProcessNoNewPrivileges(config.NoNewPrivs)\n\tg.SetProcessApparmorProfile(config.ApparmorProfile)\n\tg.SetProcessSelinuxLabel(config.ProcessLabel)\n\tg.SetLinuxMountLabel(config.MountLabel)\n\tblockAccessToKernelFilesystems(config, &g)\n\n\t// RESOURCES - PIDS\n\tif config.Resources.PidsLimit != 0 {\n\t\tg.SetLinuxResourcesPidsLimit(config.Resources.PidsLimit)\n\t}\n\n\tfor _, i := range config.Tmpfs {\n\t\t// Default options if nothing passed\n\t\toptions := []string{\"rw\", \"noexec\", \"nosuid\", \"nodev\", \"size=65536k\"}\n\t\tspliti := strings.SplitN(i, \":\", 2)\n\t\tif len(spliti) > 1 {\n\t\t\tif _, _, err := mount.ParseTmpfsOptions(spliti[1]); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toptions = strings.Split(spliti[1], \",\")\n\t\t}\n\t\ttmpfsMnt := spec.Mount{\n\t\t\tDestination: spliti[0],\n\t\t\tType:        \"tmpfs\",\n\t\t\tSource:      \"tmpfs\",\n\t\t\tOptions:     append(options, \"tmpcopyup\"),\n\t\t}\n\t\tg.AddMount(tmpfsMnt)\n\t}\n\n\tfor name, val := range config.Env {\n\t\tg.AddProcessEnv(name, val)\n\t}\n\n\tif err := addRlimits(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addPidNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addUserNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addNetNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addUTSNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := addIpcNS(config, &g); err != nil {\n\t\treturn nil, err\n\t}\n\tconfigSpec := g.Spec()\n\n\t// HANDLE CAPABILITIES\n\t// NOTE: Must happen before SECCOMP\n\tif !config.Privileged {\n\t\tif err := setupCapabilities(config, configSpec); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tg.SetupPrivileged(true)\n\t}\n\n\t// HANDLE SECCOMP\n\tif config.SeccompProfilePath != \"unconfined\" {\n\t\tif config.SeccompProfilePath != \"\" {\n\t\t\tseccompProfile, err := ioutil.ReadFile(config.SeccompProfilePath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"opening seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tseccompConfig, err := seccomp.LoadProfile(string(seccompProfile), configSpec)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"loading seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t\t} else {\n\t\t\tseccompConfig, err := seccomp.GetDefaultProfile(configSpec)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, errors.Wrapf(err, \"loading seccomp profile (%s) failed\", config.SeccompProfilePath)\n\t\t\t}\n\t\t\tconfigSpec.Linux.Seccomp = seccompConfig\n\t\t}\n\t}\n\n\t// Clear default Seccomp profile from Generator for privileged containers\n\tif config.SeccompProfilePath == \"unconfined\" || config.Privileged {\n\t\tconfigSpec.Linux.Seccomp = nil\n\t}\n\n\t// BIND MOUNTS\n\tmounts, err := config.GetVolumeMounts(configSpec.Mounts)\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error getting volume mounts\")\n\t}\n\tconfigSpec.Mounts = append(configSpec.Mounts, mounts...)\n\tfor _, mount := range configSpec.Mounts {\n\t\tfor _, opt := range mount.Options {\n\t\t\tswitch opt {\n\t\t\tcase \"private\", \"rprivate\", \"slave\", \"rslave\", \"shared\", \"rshared\":\n\t\t\t\tif err := g.SetLinuxRootPropagation(opt); err != nil {\n\t\t\t\t\treturn nil, errors.Wrapf(err, \"error setting root propagation for %q\", mount.Destination)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// BLOCK IO\n\tblkio, err := config.CreateBlockIO()\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error creating block io\")\n\t}\n\tif blkio != nil {\n\t\tconfigSpec.Linux.Resources.BlockIO = blkio\n\t}\n\n\t/*\n\t\t\t//Annotations\n\t\t\t\tResources: &configSpec.LinuxResources{\n\t\t\t\t\tBlockIO: &blkio,\n\t\t\t\t\t//HugepageLimits:\n\t\t\t\t\tNetwork: &configSpec.LinuxNetwork{\n\t\t\t\t\t// ClassID *uint32\n\t\t\t\t\t// Priorites []LinuxInterfacePriority\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t//CgroupsPath:\n\t\t\t\t//Namespaces: []LinuxNamespace\n\t\t\t\t// DefaultAction:\n\t\t\t\t// Architectures\n\t\t\t\t// Syscalls:\n\t\t\t\t},\n\t\t\t\t// RootfsPropagation\n\t\t\t\t// MaskedPaths\n\t\t\t\t// ReadonlyPaths:\n\t\t\t\t// IntelRdt\n\t\t\t},\n\t\t}\n\t*/\n\treturn configSpec, nil\n}\n\nfunc blockAccessToKernelFilesystems(config *CreateConfig, g *generate.Generator) {\n\tif !config.Privileged {\n\t\tfor _, mp := range []string{\n\t\t\t\"/proc/kcore\",\n\t\t\t\"/proc/latency_stats\",\n\t\t\t\"/proc/timer_list\",\n\t\t\t\"/proc/timer_stats\",\n\t\t\t\"/proc/sched_debug\",\n\t\t\t\"/proc/scsi\",\n\t\t\t\"/sys/firmware\",\n\t\t} {\n\t\t\tg.AddLinuxMaskedPaths(mp)\n\t\t}\n\n\t\tfor _, rp := range []string{\n\t\t\t\"/proc/asound\",\n\t\t\t\"/proc/bus\",\n\t\t\t\"/proc/fs\",\n\t\t\t\"/proc/irq\",\n\t\t\t\"/proc/sys\",\n\t\t\t\"/proc/sysrq-trigger\",\n\t\t} {\n\t\t\tg.AddLinuxReadonlyPaths(rp)\n\t\t}\n\t}\n}\n\nfunc addPidNS(config *CreateConfig, g *generate.Generator) error {\n\tpidMode := config.PidMode\n\tif pidMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(string(spec.PIDNamespace))\n\t}\n\tif pidMode.IsContainer() {\n\t\tlogrus.Debug(\"using container pidmode\")\n\t}\n\treturn nil\n}\n\nfunc addUserNS(config *CreateConfig, g *generate.Generator) error {\n\tif (len(config.IDMappings.UIDMap) > 0 || len(config.IDMappings.GIDMap) > 0) && !config.UsernsMode.IsHost() {\n\t\tg.AddOrReplaceLinuxNamespace(spec.UserNamespace, \"\")\n\t}\n\treturn nil\n}\n\nfunc addNetNS(config *CreateConfig, g *generate.Generator) error {\n\tnetMode := config.NetMode\n\tif netMode.IsHost() {\n\t\tlogrus.Debug(\"Using host netmode\")\n\t\treturn g.RemoveLinuxNamespace(spec.NetworkNamespace)\n\t} else if netMode.IsNone() {\n\t\tlogrus.Debug(\"Using none netmode\")\n\t\treturn nil\n\t} else if netMode.IsBridge() {\n\t\tlogrus.Debug(\"Using bridge netmode\")\n\t\treturn nil\n\t} else if netMode.IsContainer() {\n\t\tlogrus.Debug(\"Using container netmode\")\n\t} else {\n\t\treturn errors.Errorf(\"unknown network mode\")\n\t}\n\treturn nil\n}\n\nfunc addUTSNS(config *CreateConfig, g *generate.Generator) error {\n\tutsMode := config.UtsMode\n\tif utsMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(spec.UTSNamespace)\n\t}\n\treturn nil\n}\n\nfunc addIpcNS(config *CreateConfig, g *generate.Generator) error {\n\tipcMode := config.IpcMode\n\tif ipcMode.IsHost() {\n\t\treturn g.RemoveLinuxNamespace(spec.IPCNamespace)\n\t}\n\tif ipcMode.IsContainer() {\n\t\tlogrus.Debug(\"Using container ipcmode\")\n\t}\n\n\treturn nil\n}\n\nfunc addRlimits(config *CreateConfig, g *generate.Generator) error {\n\tvar (\n\t\tul  *units.Ulimit\n\t\terr error\n\t)\n\n\tfor _, u := range config.Resources.Ulimit {\n\t\tif ul, err = units.ParseUlimit(u); err != nil {\n\t\t\treturn errors.Wrapf(err, \"ulimit option %q requires name=SOFT:HARD, failed to be parsed\", u)\n\t\t}\n\n\t\tg.AddProcessRlimits(\"RLIMIT_\"+strings.ToUpper(ul.Name), uint64(ul.Hard), uint64(ul.Soft))\n\t}\n\treturn nil\n}\n\nfunc setupCapabilities(config *CreateConfig, configSpec *spec.Spec) error {\n\tuseNotRoot := func(user string) bool {\n\t\tif user == \"\" || user == \"root\" || user == \"0\" {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tvar err error\n\tvar caplist []string\n\tbounding := configSpec.Process.Capabilities.Bounding\n\tif useNotRoot(config.User) {\n\t\tconfigSpec.Process.Capabilities.Bounding = caplist\n\t}\n\tcaplist, err = caps.TweakCapabilities(configSpec.Process.Capabilities.Bounding, config.CapAdd, config.CapDrop)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfigSpec.Process.Capabilities.Bounding = caplist\n\tconfigSpec.Process.Capabilities.Permitted = caplist\n\tconfigSpec.Process.Capabilities.Inheritable = caplist\n\tconfigSpec.Process.Capabilities.Effective = caplist\n\tconfigSpec.Process.Capabilities.Ambient = caplist\n\tif useNotRoot(config.User) {\n\t\tcaplist, err = caps.TweakCapabilities(bounding, config.CapAdd, config.CapDrop)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tconfigSpec.Process.Capabilities.Bounding = caplist\n\treturn nil\n}\n\nfunc addDevice(g *generate.Generator, device string) error {\n\tdev, err := devices.DeviceFromPath(device, \"rwm\")\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"%s is not a valid device\", device)\n\t}\n\tlinuxdev := spec.LinuxDevice{\n\t\tPath:     dev.Path,\n\t\tType:     string(dev.Type),\n\t\tMajor:    dev.Major,\n\t\tMinor:    dev.Minor,\n\t\tFileMode: &dev.FileMode,\n\t\tUID:      &dev.Uid,\n\t\tGID:      &dev.Gid,\n\t}\n\tg.AddDevice(linuxdev)\n\tg.AddLinuxResourcesDevice(true, string(dev.Type), &dev.Major, &dev.Minor, dev.Permissions)\n\treturn nil\n}\n", "package integration\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/mrunalp/fileutils\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Podman run\", func() {\n\tvar (\n\t\ttempdir    string\n\t\terr        error\n\t\tpodmanTest PodmanTest\n\t)\n\n\tBeforeEach(func() {\n\t\ttempdir, err = CreateTempDirInTempDir()\n\t\tif err != nil {\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpodmanTest = PodmanCreate(tempdir)\n\t\tpodmanTest.RestoreAllArtifacts()\n\t})\n\n\tAfterEach(func() {\n\t\tpodmanTest.Cleanup()\n\t})\n\n\tIt(\"podman run a container based on local image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run a container based on local image with short options\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run a container based on remote image\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-dt\", BB_GLIBC, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run selinux grep test\", func() {\n\t\tselinux := podmanTest.SystemExec(\"ls\", []string{\"/usr/sbin/selinuxenabled\"})\n\t\tif selinux.ExitCode() != 0 {\n\t\t\tSkip(\"SELinux not enabled\")\n\t\t}\n\t\tsession := podmanTest.Podman([]string{\"run\", \"-it\", \"--security-opt\", \"label=level:s0:c1,c2\", ALPINE, \"cat\", \"/proc/self/attr/current\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(\"s0:c1,c2\")\n\t\tExpect(match).Should(BeTrue())\n\t})\n\n\tIt(\"podman run capabilities test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-add\", \"sys_admin\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"all\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--cap-drop\", \"setuid\", ALPINE, \"cat\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run environment test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"FOO=BAR\", ALPINE, \"printenv\", \"FOO\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(\"BAR\")\n\t\tExpect(match).Should(BeTrue())\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"PATH=/bin\", ALPINE, \"printenv\", \"PATH\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"/bin\")\n\t\tExpect(match).Should(BeTrue())\n\n\t\tos.Setenv(\"FOO\", \"BAR\")\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--env\", \"FOO\", ALPINE, \"printenv\", \"FOO\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"BAR\")\n\t\tExpect(match).Should(BeTrue())\n\t\tos.Unsetenv(\"FOO\")\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\t// This currently does not work\n\t\t// Re-enable when hostname is an env variable\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"sh\", \"-c\", \"printenv\"})\n\t\tsession.Wait(10)\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ = session.GrepString(\"HOSTNAME\")\n\t\tExpect(match).Should(BeTrue())\n\t})\n\n\tIt(\"podman run limits test\", func() {\n\t\tpodmanTest.RestoreArtifact(fedoraMinimal)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"rtprio=99\", \"--cap-add=sys_nice\", fedoraMinimal, \"cat\", \"/proc/self/sched\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=2048:2048\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"2048\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--ulimit\", \"nofile=1024:1028\", fedoraMinimal, \"ulimit\", \"-n\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1024\"))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-kill-disable=true\", fedoraMinimal, \"echo\", \"memory-hog\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"--oom-score-adj=100\", fedoraMinimal, \"cat\", \"/proc/self/oom_score_adj\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run with volume flag\", func() {\n\t\tSkip(\"Skip until we diagnose the regression of volume mounts\")\n\t\tmountPath := filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test rw,relatime\"))\n\n\t\tmountPath = filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test:ro\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test ro,relatime\"))\n\n\t\tmountPath = filepath.Join(podmanTest.TempDir, \"secrets\")\n\t\tos.Mkdir(mountPath, 0755)\n\t\tsession = podmanTest.Podman([]string{\"run\", \"--rm\", \"-v\", fmt.Sprintf(\"%s:/run/test:shared\", mountPath), ALPINE, \"cat\", \"/proc/self/mountinfo\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"/run/test rw,relatime, shared\"))\n\t})\n\n\tIt(\"podman run with cidfile\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--cidfile\", \"/tmp/cidfile\", ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\terr := os.Remove(\"/tmp/cidfile\")\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run sysctl test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--sysctl\", \"net.core.somaxconn=65535\", ALPINE, \"sysctl\", \"net.core.somaxconn\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"net.core.somaxconn = 65535\"))\n\t})\n\n\tIt(\"podman run blkio-weight test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--blkio-weight=15\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.weight\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"15\"))\n\t})\n\n\tIt(\"podman run device-read-bps test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_bps_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t})\n\n\tIt(\"podman run device-write-bps test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-bps=/dev/zero:1mb\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_bps_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"1048576\"))\n\t})\n\n\tIt(\"podman run device-read-iops test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-read-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.read_iops_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run device-write-iops test\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--device-write-iops=/dev/zero:100\", ALPINE, \"cat\", \"/sys/fs/cgroup/blkio/blkio.throttle.write_iops_device\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"100\"))\n\t})\n\n\tIt(\"podman run notify_socket\", func() {\n\t\tsock := \"/run/sock\"\n\t\tos.Setenv(\"NOTIFY_SOCKET\", sock)\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"printenv\", \"NOTIFY_SOCKET\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tmatch, _ := session.GrepString(sock)\n\t\tExpect(match).Should(BeTrue())\n\t\tos.Unsetenv(\"NOTIFY_SOCKET\")\n\t})\n\n\tIt(\"podman run log-opt\", func() {\n\t\tlog := filepath.Join(podmanTest.TempDir, \"/container.log\")\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--log-opt\", fmt.Sprintf(\"path=%s\", log), ALPINE, \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tfmt.Println(session.OutputToString())\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\t_, err := os.Stat(log)\n\t\tExpect(err).To(BeNil())\n\t\t_ = os.Remove(log)\n\t})\n\n\tIt(\"podman run tagged image\", func() {\n\t\ttag := podmanTest.Podman([]string{\"tag\", \"busybox\", \"bb\"})\n\t\ttag.WaitWithDefaultTimeout()\n\t\tExpect(tag.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"bb\", \"ls\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tfmt.Println(session.OutputToString())\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman test hooks\", func() {\n\t\thcheck := \"/run/hookscheck\"\n\t\thooksDir := \"/tmp/hooks\"\n\t\tos.Mkdir(hooksDir, 0755)\n\t\tfileutils.CopyFile(\"hooks/hooks.json\", hooksDir)\n\t\tos.Setenv(\"HOOK_OPTION\", fmt.Sprintf(\"--hooks-dir-path=%s\", hooksDir))\n\t\tos.Remove(hcheck)\n\t\tsession := podmanTest.Podman([]string{\"run\", ALPINE, \"ls\"})\n\t\tsession.Wait(10)\n\t\tos.Unsetenv(\"HOOK_OPTION\")\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t})\n\n\tIt(\"podman run with secrets\", func() {\n\t\tcontainersDir := filepath.Join(podmanTest.TempDir, \"containers\")\n\t\terr := os.MkdirAll(containersDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsDir := filepath.Join(podmanTest.TempDir, \"rhel\", \"secrets\")\n\t\terr = os.MkdirAll(secretsDir, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tmountsFile := filepath.Join(containersDir, \"mounts.conf\")\n\t\tmountString := secretsDir + \":/run/secrets\"\n\t\terr = ioutil.WriteFile(mountsFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsecretsFile := filepath.Join(secretsDir, \"test.txt\")\n\t\tsecretsString := \"Testing secrets mount. I am mounted!\"\n\t\terr = ioutil.WriteFile(secretsFile, []byte(secretsString), 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\ttargetDir := \"/tmp/symlink/target\"\n\t\terr = os.MkdirAll(targetDir, 0755)\n\t\tExpect(err).To(BeNil())\n\t\tkeyFile := filepath.Join(targetDir, \"key.pem\")\n\t\terr = ioutil.WriteFile(keyFile, []byte(mountString), 0755)\n\t\tExpect(err).To(BeNil())\n\t\texecSession := podmanTest.SystemExec(\"ln\", []string{\"-s\", targetDir, filepath.Join(secretsDir, \"mysymlink\")})\n\t\texecSession.WaitWithDefaultTimeout()\n\t\tExpect(execSession.ExitCode()).To(Equal(0))\n\n\t\tsession := podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"cat\", \"/run/secrets/test.txt\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(secretsString))\n\n\t\tsession = podmanTest.Podman([]string{\"--default-mounts-file=\" + mountsFile, \"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets/mysymlink\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"key.pem\"))\n\t})\n\n\tIt(\"podman run with FIPS mode secrets\", func() {\n\t\tfipsFile := \"/etc/system-fips\"\n\t\terr = ioutil.WriteFile(fipsFile, []byte{}, 0755)\n\t\tExpect(err).To(BeNil())\n\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"ls\", \"/run/secrets\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(ContainSubstring(\"system-fips\"))\n\n\t\terr = os.Remove(fipsFile)\n\t\tExpect(err).To(BeNil())\n\t})\n\n\tIt(\"podman run without group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)\"))\n\t})\n\n\tIt(\"podman run with group-add\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--group-add=audio\", \"--group-add=nogroup\", \"--group-add=777\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),18(audio),20(dialout),26(tape),27(video),777,65533(nogroup)\"))\n\t})\n\n\tIt(\"podman run with user (default)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)\"))\n\t})\n\n\tIt(\"podman run with user (integer, not in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=1234 gid=0(root)\"))\n\t})\n\n\tIt(\"podman run with user (integer, in /etc/passwd)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=12(mail) groups=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user (username)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=12(mail) groups=12(mail)\"))\n\t})\n\n\tIt(\"podman run with user:group (username:integer)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=mail:21\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user:group (integer:groupname)\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=8:ftp\", ALPINE, \"id\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"uid=8(mail) gid=21(ftp)\"))\n\t})\n\n\tIt(\"podman run with user, verify caps dropped\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--user=1234\", ALPINE, \"grep\", \"CapEff\", \"/proc/self/status\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tcapEff := strings.Split(session.OutputToString(), \" \")\n\t\tExpect(\"0000000000000000\").To(Equal(capEff[1]))\n\t})\n\n\tIt(\"podman run with attach stdin outputs container ID\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--attach\", \"stdin\", ALPINE, \"printenv\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tps := podmanTest.Podman([]string{\"ps\", \"-aq\", \"--no-trunc\"})\n\t\tps.WaitWithDefaultTimeout()\n\t\tExpect(ps.ExitCode()).To(Equal(0))\n\t\tExpect(ps.LineInOutputContains(session.OutputToString())).To(BeTrue())\n\t})\n\n\tIt(\"podman run with attach stdout does not print stderr\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stdout\", ALPINE, \"ls\", \"/doesnotexist\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run with attach stderr does not print stdout\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"stderr\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(0))\n\t\tExpect(session.OutputToString()).To(Equal(\"\"))\n\t})\n\n\tIt(\"podman run attach nonsense errors\", func() {\n\t\tsession := podmanTest.Podman([]string{\"run\", \"--rm\", \"--attach\", \"asdfasdf\", ALPINE, \"ls\", \"/\"})\n\t\tsession.WaitWithDefaultTimeout()\n\t\tExpect(session.ExitCode()).To(Equal(125))\n\t})\n\n})\n"], "filenames": ["pkg/spec/spec.go", "test/e2e/run_test.go"], "buggy_code_start_loc": [390, 7], "buggy_code_end_loc": [401, 371], "fixing_code_start_loc": [391, 8], "fixing_code_end_loc": [421, 381], "type": "CWE-732", "message": "It has been discovered that podman before version 0.6.1 does not drop capabilities when executing a container as a non-root user. This results in unnecessary privileges being granted to the container.", "other": {"cve": {"id": "CVE-2018-10856", "sourceIdentifier": "secalert@redhat.com", "published": "2018-07-03T01:29:00.643", "lastModified": "2019-10-09T23:33:04.867", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "It has been discovered that podman before version 0.6.1 does not drop capabilities when executing a container as a non-root user. This results in unnecessary privileges being granted to the container."}, {"lang": "es", "value": "Se ha descubierto que podman en versiones anteriores a la 0.6.1 no deja capacidades cuando ejecuta un contenedor como usuario no-root. Esto resulta en que se otorgan privilegios innecesarios al contenedor."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-250"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libpod_project:libpod:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.1", "matchCriteriaId": "AA1A340D-B1C2-48F0-A7E6-BE8C639B4626"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2037", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-10856", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/projectatomic/libpod/commit/bae80a0b663925ec751ad2784ca32989403cdc24", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/projectatomic/libpod/commit/bae80a0b663925ec751ad2784ca32989403cdc24"}}