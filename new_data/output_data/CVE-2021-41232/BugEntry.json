{"buggy_code": ["package main\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/StevenWeathers/thunderdome-planning-poker/pkg/database\"\n\tldap \"github.com/go-ldap/ldap/v3\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc (s *server) createCookie(UserID string) *http.Cookie {\n\tencoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)\n\tvar NewCookie *http.Cookie\n\n\tif err == nil {\n\t\tNewCookie = &http.Cookie{\n\t\t\tName:     s.config.SecureCookieName,\n\t\t\tValue:    encoded,\n\t\t\tPath:     s.config.PathPrefix + \"/\",\n\t\t\tHttpOnly: true,\n\t\t\tDomain:   s.config.AppDomain,\n\t\t\tMaxAge:   86400 * 30, // 30 days\n\t\t\tSecure:   s.config.SecureCookieFlag,\n\t\t\tSameSite: http.SameSiteStrictMode,\n\t\t}\n\t}\n\treturn NewCookie\n}\n\nfunc (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {\n\tAuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)\n\tif err != nil {\n\t\tlog.Println(\"Failed authenticating user\", UserEmail)\n\t} else if AuthedUser == nil {\n\t\tlog.Println(\"Unknown user\", UserEmail)\n\t}\n\treturn AuthedUser, err\n}\n\n// Authenticate using LDAP and if user does not exist, automatically add user as a verified user\nfunc (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {\n\tvar AuthedUser *database.User\n\tl, err := ldap.DialURL(viper.GetString(\"auth.ldap.url\"))\n\tif err != nil {\n\t\tlog.Println(\"Failed connecting to ldap server at\", viper.GetString(\"auth.ldap.url\"))\n\t\treturn AuthedUser, err\n\t}\n\tdefer l.Close()\n\tif viper.GetBool(\"auth.ldap.use_tls\") {\n\t\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed securing ldap connection\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t}\n\n\tif viper.GetString(\"auth.ldap.bindname\") != \"\" {\n\t\terr = l.Bind(viper.GetString(\"auth.ldap.bindname\"), viper.GetString(\"auth.ldap.bindpass\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed binding for authentication:\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t}\n\n\tsearchRequest := ldap.NewSearchRequest(viper.GetString(\"auth.ldap.basedn\"),\n\t\tldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,\n\t\tfmt.Sprintf(viper.GetString(\"auth.ldap.filter\"), UserName),\n\t\t[]string{\"dn\", viper.GetString(\"auth.ldap.mail_attr\"), viper.GetString(\"auth.ldap.cn_attr\")},\n\t\tnil,\n\t)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tlog.Println(\"Failed performing ldap search query for\", UserName, \":\", err)\n\t\treturn AuthedUser, err\n\t}\n\n\tif len(sr.Entries) != 1 {\n\t\tlog.Println(\"User\", UserName, \"does not exist or too many entries returned\")\n\t\treturn AuthedUser, errors.New(\"user not found\")\n\t}\n\n\tuserdn := sr.Entries[0].DN\n\tuseremail := sr.Entries[0].GetAttributeValue(viper.GetString(\"auth.ldap.mail_attr\"))\n\tusercn := sr.Entries[0].GetAttributeValue(viper.GetString(\"auth.ldap.cn_attr\"))\n\n\terr = l.Bind(userdn, UserPassword)\n\tif err != nil {\n\t\tlog.Println(\"Failed authenticating user \", UserName)\n\t\treturn AuthedUser, err\n\t}\n\n\tAuthedUser, err = s.database.GetUserByEmail(useremail)\n\tif AuthedUser == nil {\n\t\tlog.Println(\"User\", useremail, \"does not exist in database, auto-recruit\")\n\t\tnewUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, \"\", \"\")\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed auto-creating new user\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t\terr = s.database.VerifyUserAccount(verifyID)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed verifying new user\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t\tAuthedUser = newUser\n\t}\n\n\treturn AuthedUser, nil\n}\n"], "fixing_code": ["package main\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/StevenWeathers/thunderdome-planning-poker/pkg/database\"\n\tldap \"github.com/go-ldap/ldap/v3\"\n\t\"github.com/spf13/viper\"\n)\n\nfunc (s *server) createCookie(UserID string) *http.Cookie {\n\tencoded, err := s.cookie.Encode(s.config.SecureCookieName, UserID)\n\tvar NewCookie *http.Cookie\n\n\tif err == nil {\n\t\tNewCookie = &http.Cookie{\n\t\t\tName:     s.config.SecureCookieName,\n\t\t\tValue:    encoded,\n\t\t\tPath:     s.config.PathPrefix + \"/\",\n\t\t\tHttpOnly: true,\n\t\t\tDomain:   s.config.AppDomain,\n\t\t\tMaxAge:   86400 * 30, // 30 days\n\t\t\tSecure:   s.config.SecureCookieFlag,\n\t\t\tSameSite: http.SameSiteStrictMode,\n\t\t}\n\t}\n\treturn NewCookie\n}\n\nfunc (s *server) authUserDatabase(UserEmail string, UserPassword string) (*database.User, error) {\n\tAuthedUser, err := s.database.AuthUser(UserEmail, UserPassword)\n\tif err != nil {\n\t\tlog.Println(\"Failed authenticating user\", UserEmail)\n\t} else if AuthedUser == nil {\n\t\tlog.Println(\"Unknown user\", UserEmail)\n\t}\n\treturn AuthedUser, err\n}\n\n// Authenticate using LDAP and if user does not exist, automatically add user as a verified user\nfunc (s *server) authAndCreateUserLdap(UserName string, UserPassword string) (*database.User, error) {\n\tvar AuthedUser *database.User\n\tl, err := ldap.DialURL(viper.GetString(\"auth.ldap.url\"))\n\tif err != nil {\n\t\tlog.Println(\"Failed connecting to ldap server at\", viper.GetString(\"auth.ldap.url\"))\n\t\treturn AuthedUser, err\n\t}\n\tdefer l.Close()\n\tif viper.GetBool(\"auth.ldap.use_tls\") {\n\t\terr = l.StartTLS(&tls.Config{InsecureSkipVerify: true})\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed securing ldap connection\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t}\n\n\tif viper.GetString(\"auth.ldap.bindname\") != \"\" {\n\t\terr = l.Bind(viper.GetString(\"auth.ldap.bindname\"), viper.GetString(\"auth.ldap.bindpass\"))\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed binding for authentication:\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t}\n\n\tsearchRequest := ldap.NewSearchRequest(viper.GetString(\"auth.ldap.basedn\"),\n\t\tldap.ScopeWholeSubtree, ldap.NeverDerefAliases, 0, 0, false,\n\t\tfmt.Sprintf(viper.GetString(\"auth.ldap.filter\"), ldap.EscapeFilter(UserName)),\n\t\t[]string{\"dn\", viper.GetString(\"auth.ldap.mail_attr\"), viper.GetString(\"auth.ldap.cn_attr\")},\n\t\tnil,\n\t)\n\n\tsr, err := l.Search(searchRequest)\n\tif err != nil {\n\t\tlog.Println(\"Failed performing ldap search query for\", UserName, \":\", err)\n\t\treturn AuthedUser, err\n\t}\n\n\tif len(sr.Entries) != 1 {\n\t\tlog.Println(\"User\", UserName, \"does not exist or too many entries returned\")\n\t\treturn AuthedUser, errors.New(\"user not found\")\n\t}\n\n\tuserdn := sr.Entries[0].DN\n\tuseremail := sr.Entries[0].GetAttributeValue(viper.GetString(\"auth.ldap.mail_attr\"))\n\tusercn := sr.Entries[0].GetAttributeValue(viper.GetString(\"auth.ldap.cn_attr\"))\n\n\terr = l.Bind(userdn, UserPassword)\n\tif err != nil {\n\t\tlog.Println(\"Failed authenticating user \", UserName)\n\t\treturn AuthedUser, err\n\t}\n\n\tAuthedUser, err = s.database.GetUserByEmail(useremail)\n\tif AuthedUser == nil {\n\t\tlog.Println(\"User\", useremail, \"does not exist in database, auto-recruit\")\n\t\tnewUser, verifyID, err := s.database.CreateUserRegistered(usercn, useremail, \"\", \"\")\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed auto-creating new user\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t\terr = s.database.VerifyUserAccount(verifyID)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Failed verifying new user\", err)\n\t\t\treturn AuthedUser, err\n\t\t}\n\t\tAuthedUser = newUser\n\t}\n\n\treturn AuthedUser, nil\n}\n"], "filenames": ["auth.go"], "buggy_code_start_loc": [71], "buggy_code_end_loc": [72], "fixing_code_start_loc": [71], "fixing_code_end_loc": [72], "type": "CWE-74", "message": "Thunderdome is an open source agile planning poker tool in the theme of Battling for points. In affected versions there is an LDAP injection vulnerability which affects instances with LDAP authentication enabled. The provided username is not properly escaped. This issue has been patched in version 1.16.3. If users are unable to update they should disable the LDAP feature if in use.", "other": {"cve": {"id": "CVE-2021-41232", "sourceIdentifier": "security-advisories@github.com", "published": "2021-11-02T18:15:08.710", "lastModified": "2021-11-04T20:59:07.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Thunderdome is an open source agile planning poker tool in the theme of Battling for points. In affected versions there is an LDAP injection vulnerability which affects instances with LDAP authentication enabled. The provided username is not properly escaped. This issue has been patched in version 1.16.3. If users are unable to update they should disable the LDAP feature if in use."}, {"lang": "es", "value": "Thunderdome es una herramienta de p\u00f3ker de planificaci\u00f3n \u00e1gil de c\u00f3digo abierto con el tema de la Lucha por los puntos. En las versiones afectadas se presenta una vulnerabilidad de inyecci\u00f3n LDAP que afecta a las instancias con autenticaci\u00f3n LDAP habilitada. El nombre de usuario proporcionado no se escapa correctamente. Este problema ha sido parcheado en la versi\u00f3n 1.16.3. Si los usuarios no pueden actualizar deber\u00edan deshabilitar la funci\u00f3n LDAP si est\u00e1 en uso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-90"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thunderdome:planning_poker:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.3", "matchCriteriaId": "31418C22-4E9A-4EFA-A914-4E554B10F255"}]}]}], "references": [{"url": "https://github.com/StevenWeathers/thunderdome-planning-poker/commit/f1524d01e8a0f2d6c3db5461c742456c692dd8c1", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/StevenWeathers/thunderdome-planning-poker/security/advisories/GHSA-26cm-qrc6-mfgj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/github/securitylab/issues/464#issuecomment-957094994", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/StevenWeathers/thunderdome-planning-poker/commit/f1524d01e8a0f2d6c3db5461c742456c692dd8c1"}}