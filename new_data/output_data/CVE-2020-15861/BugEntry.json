{"buggy_code": ["*~\n*.bak\n*.bs\n*.ft\n*.ft.1\n*.la\n*.lo\n*.made\n*.o\n*.obj\n*.old\n*.orig\n*.out\n*.pdb\n*.rej\n*.swp\n.libs/\nagent/*.exe\nagent/mibgroup/agent_module_dot_conf.h\nagent/mibgroup/agent_module_includes.h\nagent/mibgroup/agent_module_inits.h\nagent/mibgroup/agent_module_shutdown.h\nagent/mibgroup/mib_module_dot_conf.h\nagent/mibgroup/mib_module_includes.h\nagent/mibgroup/mib_module_inits.h\nagent/mibgroup/mib_module_shutdown.h\nagent/snmpd\napps/*.exe\napps/agentxtrap\napps/encode_keychange\napps/snmpbulkget\napps/snmpbulkwalk\napps/snmpdelta\napps/snmpdf\napps/snmpget\napps/snmpgetnext\napps/snmpnetstat/*.exe\napps/snmpnetstat/snmpnetstat\napps/snmppcap\napps/snmpping\napps/snmpps\napps/snmpset\napps/snmpstatus\napps/snmptable\napps/snmptest\napps/snmptls\napps/snmptranslate\napps/snmptrap\napps/snmptrapd\napps/snmpusm\napps/snmpvacm\napps/snmpwalk\napps/sshtosnmp\nautom4te.cache/\nChangeLog.add*\nChangeLog.reallyadd\nCHANGES.new*\nconfdefs.h\nconfig.cache\nconfig.log\nconfig.status\nconfigure-summary\ndist/generation-scripts/gen-variables\ndocs/html\ndocs/latex\nEXAMPLE.conf\ninclude/net-snmp/agent/agent_module_config.h\ninclude/net-snmp/agent/mib_module_config.h\ninclude/net-snmp/library/snmpv3-security-includes.h\ninclude/net-snmp/net-snmp-config.h\nlibtool\nlocal/snmpcheck\nlocal/snmpconf\nMakefile\nman/*.[1358]\nman/default_store.3.h\nman/manaliases\nmibs/.index\nmk/\nmodule_tmp_header.h\nnet-snmp-5*\nnet-snmp-6*\nnet-snmp-config\nnet-snmp-config-x\nnet-snmp-create-v3-user\nNEWS.new*\nperl/*.json\nperl/*.yml\nperl/*/*.def\nperl/*/*.json\nperl/*/*.yml\nperl/*/*/*.json\nperl/*/*/*.yml\nperl/agent/agent.c\nperl/agent/default_store/default_store.c\nperl/agent/default_store/default_store.def\nperl/ASN/ASN.c\nperl/blib/\nperl/default_store/default_store.c\nperl/NetSNMP.c\nperl/OID/OID.c\nperl/SNMP/SNMP.c\nperl/SNMP/t/*.log\nperl/SNMP/t/*.pid\nperl/SNMP/t/*.stderr\nperl/SNMP/t/snmptest.cmd\nperl/TrapReceiver/const-c.inc\nperl/TrapReceiver/const-xs.inc\nperl/TrapReceiver/TrapReceiver.c\npm_to_blib\npython/build\nsedscript\nsnmplib/snmpsm_init.h\nsnmplib/snmpsm_shutdown.h\nsnmplib/transports/snmp_transport_inits.h\nstamp-h\nTAGS\ntesting/failed_tests\ntesting/testing/\nwin32/*/debug\nwin32/*/release\nwin32/bin\nwin32/lib\n", "#ifndef MIB_H\n#define MIB_H\n\n#ifdef __cplusplus\nextern          \"C\" {\n#endif\n    /*\n     * mib.h - Definitions for the variables as defined in the MIB\n     *\n     * Update: 1998-07-17 <jhy@gsu.edu>\n     * Added prototypes for print_oid_report* functions.\n     */\n/***********************************************************\n\tCopyright 1988, 1989 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its \ndocumentation for any purpose and without fee is hereby granted, \nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in \nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.  \n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n\n#include <stdio.h>              /* for FILE */\n\n#include <net-snmp/mib_api.h>\n\n#define NETSNMP_MIB2_OID 1, 3, 6, 1, 2, 1\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\n#define MIB NETSNMP_MIB2_OID\n#endif\n\n#define MIB_IFTYPE_OTHER\t\t    1\n#define MIB_IFTYPE_REGULAR1822\t\t    2\n#define MIB_IFTYPE_HDH1822\t\t    3\n#define MIB_IFTYPE_DDNX25\t\t    4\n#define MIB_IFTYPE_RFC877X25\t\t    5\n#define MIB_IFTYPE_ETHERNETCSMACD\t    6\n#define MIB_IFTYPE_ISO88023CSMACD\t    7\n#define MIB_IFTYPE_ISO88024TOKENBUS\t    8\n#define MIB_IFTYPE_ISO88025TOKENRING\t    9\n#define MIB_IFTYPE_ISO88026MAN\t\t    10\n#define MIB_IFTYPE_STARLAN\t\t    11\n#define MIB_IFTYPE_PROTEON10MBIT\t    12\n#define MIB_IFTYPE_PROTEON80MBIT\t    13\n#define MIB_IFTYPE_HYPERCHANNEL\t\t    14\n#define MIB_IFTYPE_FDDI\t\t\t    15\n#define MIB_IFTYPE_LAPB\t\t\t    16\n#define MIB_IFTYPE_SDLC\t\t\t    17\n#define MIB_IFTYPE_T1CARRIER\t\t    18\n#define MIB_IFTYPE_CEPT\t\t\t    19\n#define MIB_IFTYPE_BASICISDN\t\t    20\n#define MIB_IFTYPE_PRIMARYISDN\t\t    21\n#define MIB_IFTYPE_PROPPOINTTOPOINTSERIAL   22\n\n#define MIB_IFSTATUS_UP\t\t1\n#define MIB_IFSTATUS_DOWN\t2\n#define MIB_IFSTATUS_TESTING\t3\n\n#define MIB_FORWARD_GATEWAY\t1\n#define MIB_FORWARD_HOST\t2\n\n#define MIB_IPROUTETYPE_OTHER\t1\n#define MIB_IPROUTETYPE_INVALID\t2\n#define MIB_IPROUTETYPE_DIRECT\t3\n#define MIB_IPROUTETYPE_REMOTE\t4\n\n#define MIB_IPROUTEPROTO_OTHER\t    1\n#define MIB_IPROUTEPROTO_LOCAL\t    2\n#define MIB_IPROUTEPROTO_NETMGMT    3\n#define MIB_IPROUTEPROTO_ICMP\t    4\n#define MIB_IPROUTEPROTO_EGP\t    5\n#define MIB_IPROUTEPROTO_GGP\t    6\n#define MIB_IPROUTEPROTO_HELLO\t    7\n#define MIB_IPROUTEPROTO_RIP\t    8\n#define MIB_IPROUTEPROTO_ISIS\t    9\n#define MIB_IPROUTEPROTO_ESIS\t    10\n#define MIB_IPROUTEPROTO_CISCOIGRP  11\n#define MIB_IPROUTEPROTO_BBNSPFIGP  12\n#define MIB_IPROUTEPROTO_OIGP\t    13\n\n#define MIB_TCPRTOALG_OTHER\t1\n#define MIB_TCPRTOALG_CONSTANT\t2\n#define MIB_TCPRTOALG_RSRE\t3\n#define MIB_TCPRTOALG_VANJ\t4\n\n#define MIB_TCPCONNSTATE_CLOSED\t\t1\n#define MIB_TCPCONNSTATE_LISTEN\t\t2\n#define MIB_TCPCONNSTATE_SYNSENT\t3\n#define MIB_TCPCONNSTATE_SYNRECEIVED\t4\n#define MIB_TCPCONNSTATE_ESTABLISHED\t5\n#define MIB_TCPCONNSTATE_FINWAIT1\t6\n#define MIB_TCPCONNSTATE_FINWAIT2\t7\n#define MIB_TCPCONNSTATE_CLOSEWAIT\t8\n#define MIB_TCPCONNSTATE_LASTACK\t9\n#define MIB_TCPCONNSTATE_CLOSING\t10\n#define MIB_TCPCONNSTATE_TIMEWAIT\t11\n\n#define MIB_EGPNEIGHSTATE_IDLE\t\t1\n#define MIB_EGPNEIGHSTATE_AQUISITION\t2\n#define MIB_EGPNEIGHSTATE_DOWN\t\t3\n#define MIB_EGPNEIGHSTATE_UP\t\t4\n#define MIB_EGPNEIGHSTATE_CEASE\t\t5\n\n    struct variable_list;\n    struct enum_list;\n\n    NETSNMP_IMPORT\n    void            print_ascii_dump(FILE *);\n    void            register_mib_handlers(void);\n    void            netsnmp_set_mib_directory(const char *dir);\n    NETSNMP_IMPORT\n    char            *netsnmp_get_mib_directory(void);\n    void            netsnmp_fixup_mib_directory(void);\n    void            netsnmp_mibindex_load( void );\n    char *          netsnmp_mibindex_lookup( const char * );\n    FILE *          netsnmp_mibindex_new( const char * );\n    int             sprint_realloc_description(u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc,\n                                oid * objid, size_t objidlen, int width);\n    NETSNMP_IMPORT\n    int             get_wild_node(const char *, oid *, size_t *);\n    NETSNMP_IMPORT\n    int             get_node(const char *, oid *, size_t *);\n    NETSNMP_IMPORT\n    struct tree    *get_tree(const oid *, size_t, struct tree *);\n    NETSNMP_IMPORT\n    struct tree    *get_tree_head(void);\n    void            set_function(struct tree *);\n\n    NETSNMP_IMPORT\n    int             parse_one_oid_index(oid ** oidStart, size_t * oidLen,\n                                        netsnmp_variable_list * data,\n                                        int complete);\n    NETSNMP_IMPORT\n    int             parse_oid_indexes(oid * oidIndex, size_t oidLen,\n                                      netsnmp_variable_list * data);\n    NETSNMP_IMPORT\n    int             build_oid_noalloc(oid * in, size_t in_len,\n                                      size_t * out_len, oid * prefix,\n                                      size_t prefix_len,\n                                      netsnmp_variable_list * indexes);\n    NETSNMP_IMPORT\n    int             build_oid(oid ** out, size_t * out_len, oid * prefix,\n                              size_t prefix_len,\n                              netsnmp_variable_list * indexes);\n    int             build_oid_segment(netsnmp_variable_list * var);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_variable(u_char ** buf, size_t * buf_len,\n                                   size_t * out_len, int allow_realloc,\n                                   const oid * objid, size_t objidlen,\n                                   const netsnmp_variable_list * variable);\n\n    NETSNMP_IMPORT\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *\n#else\n    void\n#endif\n                    netsnmp_sprint_realloc_objid_tree(u_char ** buf,\n                                                      size_t * buf_len,\n                                                      size_t * out_len,\n                                                      int allow_realloc,\n                                                      int *buf_overflow,\n                                                      const oid * objid,\n                                                      size_t objidlen);\n\n    NETSNMP_IMPORT\n    void\n                    netsnmp_sprint_realloc_objid(u_char ** buf,\n                                                 size_t * buf_len,\n                                                 size_t * out_len,\n                                                 int allow_realloc,\n                                                 int *buf_overflow,\n                                                 const oid * objid,\n                                                 size_t objidlen);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_value(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const oid * objid, size_t objidlen,\n                                 const netsnmp_variable_list * variable);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const oid * objid, size_t objidlen);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_by_type(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list * var,\n                                           const struct enum_list *enums,\n                                           const char *hint,\n                                           const char *units);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_hexstring(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const u_char *, size_t);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_asciistring(u_char ** buf,\n                                               size_t * buf_len,\n                                               size_t * out_len,\n                                               int allow_realloc,\n                                               const u_char * cp,\n                                               size_t len);\n\n    int             sprint_realloc_octet_string(u_char ** buf,\n                                                size_t * buf_len,\n                                                size_t * out_len,\n                                                int allow_realloc,\n                                                const netsnmp_variable_list *,\n                                                const struct enum_list *,\n                                                const char *,\n                                                const char *);\n\n    int             sprint_realloc_opaque(u_char ** buf, size_t * buf_len,\n                                          size_t * out_len,\n                                          int allow_realloc,\n                                          const netsnmp_variable_list *,\n                                          const struct enum_list *, const char *,\n                                          const char *);\n\n    int             sprint_realloc_object_identifier(u_char ** buf,\n                                                     size_t * buf_len,\n                                                     size_t * out_len,\n                                                     int allow_realloc,\n                                                     const netsnmp_variable_list\n                                                     *, const struct enum_list *,\n                                                     const char *,\n                                                     const char *);\n\n    int             sprint_realloc_timeticks(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_hinted_integer(u_char ** buf,\n                                                  size_t * buf_len,\n                                                  size_t * out_len,\n                                                  int allow_realloc, long,\n                                                  const char, const char *,\n                                                  const char *);\n\n    int             sprint_realloc_integer(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             sprint_realloc_uinteger(u_char ** buf,\n                                            size_t * buf_len,\n                                            size_t * out_len,\n                                            int allow_realloc,\n                                            const netsnmp_variable_list *,\n                                            const struct enum_list *,\n                                            const char *, const char *);\n\n    int             sprint_realloc_gauge(u_char ** buf, size_t * buf_len,\n                                         size_t * out_len,\n                                         int allow_realloc,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             sprint_realloc_counter(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             sprint_realloc_networkaddress(u_char ** buf,\n                                                  size_t * buf_len,\n                                                  size_t * out_len,\n                                                  int allow_realloc,\n                                                  const netsnmp_variable_list *,\n                                                  const struct enum_list *,\n                                                  const char *,\n                                                  const char *);\n\n    int             sprint_realloc_ipaddress(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_null(u_char ** buf, size_t * buf_len,\n                                        size_t * out_len,\n                                        int allow_realloc,\n                                        const netsnmp_variable_list *,\n                                        const struct enum_list *, const char *,\n                                        const char *);\n\n    int             sprint_realloc_bitstring(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_nsapaddress(u_char ** buf,\n                                               size_t * buf_len,\n                                               size_t * out_len,\n                                               int allow_realloc,\n                                               const netsnmp_variable_list *,\n                                               const struct enum_list *,\n                                               const char *, const char *);\n\n    int             sprint_realloc_counter64(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_badtype(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    int             sprint_realloc_float(u_char ** buf, size_t * buf_len,\n                                         size_t * out_len,\n                                         int allow_realloc,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             sprint_realloc_double(u_char ** buf, size_t * buf_len,\n                                          size_t * out_len,\n                                          int allow_realloc,\n                                          const netsnmp_variable_list *,\n                                          const struct enum_list *, const char *,\n                                          const char *);\n#endif\n\n\n    int             snprint_by_type(char *buf, size_t buf_len,\n                                    netsnmp_variable_list * var,\n                                    const struct enum_list *enums,\n                                    const char *hint, const char *units);\n\n    int             snprint_hexstring(char *buf, size_t buf_len,\n                                      const u_char *, size_t);\n\n    int             snprint_asciistring(char *buf, size_t buf_len,\n                                        const u_char * cp, size_t len);\n\n    int             snprint_octet_string(char *buf, size_t buf_len,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             snprint_opaque(char *buf, size_t buf_len,\n                                   const netsnmp_variable_list *,\n                                   const struct enum_list *, const char *,\n                                   const char *);\n\n    int             snprint_object_identifier(char *buf, size_t buf_len,\n                                              const netsnmp_variable_list *,\n                                              const struct enum_list *,\n                                              const char *, const char *);\n\n    int             snprint_timeticks(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_hinted_integer(char *buf, size_t buf_len,\n                                           long, const char *,\n                                           const char *);\n\n    int             snprint_integer(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n    int             snprint_uinteger(char *buf, size_t buf_len,\n                                     const netsnmp_variable_list *,\n                                     const struct enum_list *, const char *,\n                                     const char *);\n\n    int             snprint_gauge(char *buf, size_t buf_len,\n                                  const netsnmp_variable_list *,\n                                  const struct enum_list *, const char *,\n                                  const char *);\n\n    int             snprint_counter(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n    int             snprint_networkaddress(char *buf, size_t buf_len,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             snprint_ipaddress(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_null(char *buf, size_t buf_len,\n                                 const netsnmp_variable_list *,\n                                 const struct enum_list *, const char *,\n                                 const char *);\n\n    NETSNMP_IMPORT\n    int             snprint_bitstring(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_nsapaddress(char *buf, size_t buf_len,\n                                        const netsnmp_variable_list *,\n                                        const struct enum_list *, const char *,\n                                        const char *);\n\n    int             snprint_counter64(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_badtype(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    int             snprint_float(char *buf, size_t buf_len,\n                                  const netsnmp_variable_list *,\n                                  const struct enum_list *, const char *,\n                                  const char *);\n\n    int             snprint_double(char *buf, size_t buf_len,\n                                   const netsnmp_variable_list *,\n                                   const struct enum_list *, const char *,\n                                   const char *);\n#endif\n\n    NETSNMP_IMPORT\n    void            print_oid_report(FILE *);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_labeledoid(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_oid(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_suffix(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_symbolic(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_mibchildoid(void);\n\n    const char     *parse_octet_hint(const char *hint, const char *value,\n\t                             unsigned char **new_val, int *new_val_len);\n\n    NETSNMP_IMPORT\n    void            clear_tree_flags(register struct tree *tp);\n\n    NETSNMP_IMPORT\n    char           *snmp_out_toggle_options(char *);\n    NETSNMP_IMPORT\n    char           *snmp_out_options(char *, int, char * const *);\n    NETSNMP_IMPORT\n    void            snmp_out_toggle_options_usage(const char *, FILE *);\n    NETSNMP_IMPORT\n    char           *snmp_in_toggle_options(char *);\n    NETSNMP_IMPORT\n    char           *snmp_in_options(char *, int, char * const *);\n    NETSNMP_IMPORT\n    void            snmp_in_toggle_options_usage(const char *, FILE *);\n    NETSNMP_IMPORT\n    u_char          mib_to_asn_type(int mib_type);\n\n\n    int             netsnmp_str2oid(const char *S, oid * O, int L);\n    char            *make_printf_format_string(const char *);\n\n\n#define NETSNMP_STRING_OUTPUT_GUESS  1\n#define NETSNMP_STRING_OUTPUT_ASCII  2\n#define NETSNMP_STRING_OUTPUT_HEX    3\n\n#define NETSNMP_OID_OUTPUT_SUFFIX  1\n#define NETSNMP_OID_OUTPUT_MODULE  2\n#define NETSNMP_OID_OUTPUT_FULL    3\n#define NETSNMP_OID_OUTPUT_NUMERIC 4\n#define NETSNMP_OID_OUTPUT_UCD     5\n#define NETSNMP_OID_OUTPUT_NONE    6\n#ifdef __cplusplus\n}\n#endif\n#endif                          /* MIB_H */\n", "#ifndef PARSE_H\n#define PARSE_H\n\n#ifdef __cplusplus\nextern          \"C\" {\n#endif\n\n#include <net-snmp/mib_api.h>\n\n    /*\n     * parse.h\n     */\n/***********************************************************\n        Copyright 1989 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n\n#define NETSNMP_MAXLABEL 64      /* maximum characters in a label */\n#define MAXTOKEN        128     /* maximum characters in a token */\n#define MAXQUOTESTR     4096    /* maximum characters in a quoted string */\n\n/*\n * MAXLABEL appears to be unused in code, and conflicts with\n * <arpa/nameser.h>. Only define it if requested. This will\n * cause problems if local DNSSEC validation is also enabled.\n */\n#ifdef UCD_COMPATIBLE\n#define MAXLABEL        NETSNMP_MAXLABEL\n#endif\n\n    struct variable_list;\n\n    /*\n     * A linked list of tag-value pairs for enumerated integers.\n     */\n    struct enum_list {\n        struct enum_list *next;\n        int             value;\n        char           *label;\n    };\n\n    /*\n     * A linked list of ranges\n     */\n    struct range_list {\n        struct range_list *next;\n        int             low, high;\n    };\n\n    /*\n     * A linked list of indexes\n     */\n    struct index_list {\n        struct index_list *next;\n        char           *ilabel;\n        char            isimplied;\n    };\n\n    /*\n     * A linked list of varbinds\n     */\n    struct varbind_list {\n        struct varbind_list *next;\n        char           *vblabel;\n    };\n\n    /*\n     * A tree in the format of the tree structure of the MIB.\n     */\n    struct tree {\n        struct tree    *child_list;     /* list of children of this node */\n        struct tree    *next_peer;      /* Next node in list of peers */\n        struct tree    *next;   /* Next node in hashed list of names */\n        struct tree    *parent;\n        char           *label;  /* This node's textual name */\n        u_long          subid;  /* This node's integer subidentifier */\n        int             modid;  /* The module containing this node */\n        int             number_modules;\n        int            *module_list;    /* To handle multiple modules */\n        int             tc_index;       /* index into tclist (-1 if NA) */\n        int             type;   /* This node's object type */\n        int             access; /* This nodes access */\n        int             status; /* This nodes status */\n        struct enum_list *enums;        /* (optional) list of enumerated integers */\n        struct range_list *ranges;\n        struct index_list *indexes;\n        char           *augments;\n        struct varbind_list *varbinds;\n        char           *hint;\n        char           *units;\n        int             (*printomat) (u_char **, size_t *, size_t *, int,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n        void            (*printer) (char *, const netsnmp_variable_list *, const struct enum_list *, const char *, const char *);   /* Value printing function */\n        char           *description;    /* description (a quoted string) */\n        char           *reference;    /* references (a quoted string) */\n        int             reported;       /* 1=report started in print_subtree... */\n        char           *defaultValue;\n       char\t       *parseErrorString; /* Contains the error string if there are errors in parsing MIBs */\n    };\n\n    /*\n     * Information held about each MIB module\n     */\n    struct module_import {\n        char           *label;  /* The descriptor being imported */\n        int             modid;  /* The module imported from */\n    };\n\n    struct module {\n        char           *name;   /* This module's name */\n        char           *file;   /* The file containing the module */\n        struct module_import *imports;  /* List of descriptors being imported */\n        int             no_imports;     /* The number of such import descriptors */\n        /*\n         * -1 implies the module hasn't been read in yet \n         */\n        int             modid;  /* The index number of this module */\n        struct module  *next;   /* Linked list pointer */\n    };\n\n    struct module_compatability {\n        const char     *old_module;\n        const char     *new_module;\n        const char     *tag;    /* NULL implies unconditional replacement,\n                                 * otherwise node identifier or prefix */\n        size_t          tag_len;        /* 0 implies exact match (or unconditional) */\n        struct module_compatability *next;      /* linked list */\n    };\n\n\n    /*\n     * non-aggregate types for tree end nodes \n     */\n#define TYPE_OTHER          0\n#define TYPE_OBJID          1\n#define TYPE_OCTETSTR       2\n#define TYPE_INTEGER        3\n#define TYPE_NETADDR        4\n#define TYPE_IPADDR         5\n#define TYPE_COUNTER        6\n#define TYPE_GAUGE          7\n#define TYPE_TIMETICKS      8\n#define TYPE_OPAQUE         9\n#define TYPE_NULL           10\n#define TYPE_COUNTER64      11\n#define TYPE_BITSTRING      12\n#define TYPE_NSAPADDRESS    13\n#define TYPE_UINTEGER       14\n#define TYPE_UNSIGNED32     15\n#define TYPE_INTEGER32      16\n\n#define TYPE_SIMPLE_LAST    16\n\n#define TYPE_TRAPTYPE\t    20\n#define TYPE_NOTIFTYPE      21\n#define TYPE_OBJGROUP\t    22\n#define TYPE_NOTIFGROUP\t    23\n#define TYPE_MODID\t    24\n#define TYPE_AGENTCAP       25\n#define TYPE_MODCOMP        26\n#define TYPE_OBJIDENTITY    27\n\n#define MIB_ACCESS_READONLY    18\n#define MIB_ACCESS_READWRITE   19\n#define\tMIB_ACCESS_WRITEONLY   20\n#define MIB_ACCESS_NOACCESS    21\n#define MIB_ACCESS_NOTIFY      67\n#define MIB_ACCESS_CREATE      48\n\n#define MIB_STATUS_MANDATORY   23\n#define MIB_STATUS_OPTIONAL    24\n#define MIB_STATUS_OBSOLETE    25\n#define MIB_STATUS_DEPRECATED  39\n#define MIB_STATUS_CURRENT     57\n\n#define\tANON\t\"anonymous#\"\n#define\tANON_LEN  strlen(ANON)\n\n    int             netsnmp_unload_module(const char *name);\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\n    int             unload_module(const char *name);\n#endif\n    void            netsnmp_init_mib_internals(void);\n    void            unload_all_mibs(void);\n    int             add_mibfile(const char*, const char*, FILE *);\n    int             which_module(const char *);\n    NETSNMP_IMPORT\n    char           *module_name(int, char *);\n    NETSNMP_IMPORT\n    void            print_subtree(FILE *, struct tree *, int);\n    NETSNMP_IMPORT\n    void            print_ascii_dump_tree(FILE *, struct tree *, int);\n    NETSNMP_IMPORT\n    struct tree    *find_tree_node(const char *, int);\n    NETSNMP_IMPORT\n    const char     *get_tc_descriptor(int);\n    NETSNMP_IMPORT\n    const char     *get_tc_description(int);\n    NETSNMP_IMPORT\n    struct tree    *find_best_tree_node(const char *, struct tree *,\n                                        u_int *);\n    /*\n     * backwards compatability \n     */\n    NETSNMP_IMPORT\n    struct tree    *find_node(const char *, struct tree *);\n    struct tree    *find_node2(const char *, const char *); \n    NETSNMP_IMPORT\n    struct module  *find_module(int);\n    void            adopt_orphans(void);\n    NETSNMP_IMPORT\n    char           *snmp_mib_toggle_options(char *options);\n    NETSNMP_IMPORT\n    void            snmp_mib_toggle_options_usage(const char *lead,\n                                                  FILE * outf);\n    NETSNMP_IMPORT\n    void            print_mib(FILE *);\n    NETSNMP_IMPORT\n    void            print_mib_tree(FILE *, struct tree *, int);\n    int             get_mib_parse_error_count(void);\n    NETSNMP_IMPORT\n    int             snmp_get_token(FILE * fp, char *token, int maxtlen);\n    NETSNMP_IMPORT\n    struct tree    *find_best_tree_node(const char *name,\n                                        struct tree *tree_top,\n                                        u_int * match);\n\n#ifdef __cplusplus\n}\n#endif\n#endif                          /* PARSE_H */\n", "/*\n * mib.c\n *\n * $Id$\n *\n * Update: 1998-07-17 <jhy@gsu.edu>\n * Added print_oid_report* functions.\n *\n */\n/* Portions of this file are subject to the following copyrights.  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/**********************************************************************\n\tCopyright 1988, 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/types.h>\n\n#if HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# if HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# if HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# if HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/asn1.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/parse.h>\n#include <net-snmp/library/int64.h>\n#include <net-snmp/library/snmp_client.h>\n\nnetsnmp_feature_child_of(mib_api, libnetsnmp)\nnetsnmp_feature_child_of(mib_strings_all, mib_api)\n\nnetsnmp_feature_child_of(mib_snprint, mib_strings_all)\nnetsnmp_feature_child_of(mib_snprint_description, mib_strings_all)\nnetsnmp_feature_child_of(mib_snprint_variable, mib_strings_all)\nnetsnmp_feature_child_of(mib_string_conversions, mib_strings_all)\nnetsnmp_feature_child_of(print_mib, mib_strings_all)\nnetsnmp_feature_child_of(snprint_objid, mib_strings_all)\nnetsnmp_feature_child_of(snprint_value, mib_strings_all)\n\nnetsnmp_feature_child_of(mib_to_asn_type, mib_api)\n\n/** @defgroup mib_utilities mib parsing and datatype manipulation routines.\n *  @ingroup library\n *\n *  @{\n */\n\nstatic char    *uptimeString(u_long, char *, size_t);\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic struct tree *_get_realloc_symbol(const oid * objid, size_t objidlen,\n                                        struct tree *subtree,\n                                        u_char ** buf, size_t * buf_len,\n                                        size_t * out_len,\n                                        int allow_realloc,\n                                        int *buf_overflow,\n                                        struct index_list *in_dices,\n                                        size_t * end_of_known);\n\nstatic int      print_tree_node(u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc,\n                                struct tree *tp, int width);\nstatic void     handle_mibdirs_conf(const char *token, char *line);\nstatic void     handle_mibs_conf(const char *token, char *line);\nstatic void     handle_mibfile_conf(const char *token, char *line);\n#endif /*NETSNMP_DISABLE_MIB_LOADING */\n\nstatic void     _oid_finish_printing(const oid * objid, size_t objidlen,\n                                     u_char ** buf, size_t * buf_len,\n                                     size_t * out_len,\n                                     int allow_realloc, int *buf_overflow);\n\n/*\n * helper functions for get_module_node \n */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic int      node_to_oid(struct tree *, oid *, size_t *);\nstatic int      _add_strings_to_oid(struct tree *, char *,\n                                    oid *, size_t *, size_t);\n#else\nstatic int      _add_strings_to_oid(void *, char *,\n                                    oid *, size_t *, size_t);\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nNETSNMP_IMPORT struct tree *tree_head;\nstatic struct tree *tree_top;\n\nNETSNMP_IMPORT struct tree *Mib;\nstruct tree    *Mib;            /* Backwards compatibility */\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nstatic char     Standard_Prefix[] = \".1.3.6.1.2.1\";\n\n/*\n * Set default here as some uses of read_objid require valid pointer. \n */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic char    *Prefix = &Standard_Prefix[0];\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\ntypedef struct _PrefixList {\n    const char     *str;\n    int             len;\n}              *PrefixListPtr, PrefixList;\n\n/*\n * Here are the prefix strings.\n * Note that the first one finds the value of Prefix or Standard_Prefix.\n * Any of these MAY start with period; all will NOT end with period.\n * Period is added where needed.  See use of Prefix in this module.\n */\nPrefixList      mib_prefixes[] = {\n    {&Standard_Prefix[0]},      /* placeholder for Prefix data */\n    {\".iso.org.dod.internet.mgmt.mib-2\"},\n    {\".iso.org.dod.internet.experimental\"},\n    {\".iso.org.dod.internet.private\"},\n    {\".iso.org.dod.internet.snmpParties\"},\n    {\".iso.org.dod.internet.snmpSecrets\"},\n    {NULL, 0}                   /* end of list */\n};\n\nenum inet_address_type {\n    IPV4 = 1,\n    IPV6 = 2,\n    IPV4Z = 3,\n    IPV6Z = 4,\n    DNS = 16\n};\n\n\n/**\n * @internal\n * Converts timeticks to hours, minutes, seconds string.\n *\n * @param timeticks    The timeticks to convert.\n * @param buf          Buffer to write to, has to be at \n *                     least 40 Bytes large.\n *       \n * @return The buffer.\n */\nstatic char    *\nuptimeString(u_long timeticks, char *buf, size_t buflen)\n{\n    int             centisecs, seconds, minutes, hours, days;\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {\n        snprintf(buf, buflen, \"%lu\", timeticks);\n        return buf;\n    }\n\n\n    centisecs = timeticks % 100;\n    timeticks /= 100;\n    days = timeticks / (60 * 60 * 24);\n    timeticks %= (60 * 60 * 24);\n\n    hours = timeticks / (60 * 60);\n    timeticks %= (60 * 60);\n\n    minutes = timeticks / 60;\n    seconds = timeticks % 60;\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT))\n        snprintf(buf, buflen, \"%d:%d:%02d:%02d.%02d\",\n                days, hours, minutes, seconds, centisecs);\n    else {\n        if (days == 0) {\n            snprintf(buf, buflen, \"%d:%02d:%02d.%02d\",\n                    hours, minutes, seconds, centisecs);\n        } else if (days == 1) {\n            snprintf(buf, buflen, \"%d day, %d:%02d:%02d.%02d\",\n                    days, hours, minutes, seconds, centisecs);\n        } else {\n            snprintf(buf, buflen, \"%d days, %d:%02d:%02d.%02d\",\n                    days, hours, minutes, seconds, centisecs);\n        }\n    }\n    return buf;\n}\n\n\n\n/**\n * @internal\n * Prints the character pointed to if in human-readable ASCII range,\n * otherwise prints a dot.\n *\n * @param buf Buffer to print the character to.\n * @param ch  Character to print.\n */\nstatic void\nsprint_char(char *buf, const u_char ch)\n{\n    if (isprint(ch) || isspace(ch)) {\n        sprintf(buf, \"%c\", (int) ch);\n    } else {\n        sprintf(buf, \".\");\n    }\n}\n\n\n\n/**\n * Prints a hexadecimal string into a buffer.\n *\n * The characters pointed by *cp are encoded as hexadecimal string.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      address of the buffer to print to.\n * @param buf_len  address to an integer containing the size of buf.\n * @param out_len  incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param cp       the array of characters to encode.\n * @param line_len the array length of cp.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\n_sprint_hexstring_line(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc, const u_char * cp, size_t line_len)\n{\n    const u_char   *tp;\n    const u_char   *cp2 = cp;\n    size_t          lenleft = line_len;\n\n    /*\n     * Make sure there's enough room for the hex output....\n     */\n    while ((*out_len + line_len*3+1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    /*\n     * .... and display the hex values themselves....\n     */\n    for (; lenleft >= 8; lenleft-=8) {\n        sprintf((char *) (*buf + *out_len),\n                \"%02X %02X %02X %02X %02X %02X %02X %02X \", cp[0], cp[1],\n                cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);\n        *out_len += strlen((char *) (*buf + *out_len));\n        cp       += 8;\n    }\n    for (; lenleft > 0; lenleft--) {\n        sprintf((char *) (*buf + *out_len), \"%02X \", *cp++);\n        *out_len += strlen((char *) (*buf + *out_len));\n    }\n\n    /*\n     * .... plus (optionally) do the same for the ASCII equivalent.\n     */\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT)) {\n        while ((*out_len + line_len+5) >= *buf_len) {\n            if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n        }\n        sprintf((char *) (*buf + *out_len), \"  [\");\n        *out_len += strlen((char *) (*buf + *out_len));\n        for (tp = cp2; tp < cp; tp++) {\n            sprint_char((char *) (*buf + *out_len), *tp);\n            (*out_len)++;\n        }\n        sprintf((char *) (*buf + *out_len), \"]\");\n        *out_len += strlen((char *) (*buf + *out_len));\n    }\n    return 1;\n}\n\nint\nsprint_realloc_hexstring(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc, const u_char * cp, size_t len)\n{\n    int line_len = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,\n                                      NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);\n    if (line_len <= 0)\n        line_len = len;\n\n    for (; (int)len > line_len; len -= line_len) {\n        if(!_sprint_hexstring_line(buf, buf_len, out_len, allow_realloc, cp, line_len))\n            return 0;\n        *(*buf + (*out_len)++) = '\\n';\n        *(*buf + *out_len) = 0;\n        cp += line_len;\n    }\n    if(!_sprint_hexstring_line(buf, buf_len, out_len, allow_realloc, cp, len))\n        return 0;\n    *(*buf + *out_len) = 0;\n    return 1;\n}\n\n\n\n/**\n * Prints an ascii string into a buffer.\n *\n * The characters pointed by *cp are encoded as an ascii string.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      address of the buffer to print to.\n * @param buf_len  address to an integer containing the size of buf.\n * @param out_len  incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param cp       the array of characters to encode.\n * @param len      the array length of cp.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_asciistring(u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           const u_char * cp, size_t len)\n{\n    int             i;\n\n    for (i = 0; i < (int) len; i++) {\n        if (isprint(*cp) || isspace(*cp)) {\n            if (*cp == '\\\\' || *cp == '\"') {\n                if ((*out_len >= *buf_len) &&\n                    !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n                *(*buf + (*out_len)++) = '\\\\';\n            }\n            if ((*out_len >= *buf_len) &&\n                !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n            *(*buf + (*out_len)++) = *cp++;\n        } else {\n            if ((*out_len >= *buf_len) &&\n                !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n            *(*buf + (*out_len)++) = '.';\n            cp++;\n        }\n    }\n    if ((*out_len >= *buf_len) &&\n        !(allow_realloc && snmp_realloc(buf, buf_len))) {\n        return 0;\n    }\n    *(*buf + *out_len) = '\\0';\n    return 1;\n}\n\n/**\n * Prints an octet string into a buffer.\n *\n * The variable var is encoded as octet string.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_octet_string(u_char ** buf, size_t * buf_len,\n                            size_t * out_len, int allow_realloc,\n                            const netsnmp_variable_list * var,\n                            const struct enum_list *enums, const char *hint,\n                            const char *units)\n{\n    size_t          saved_out_len = *out_len;\n    const char     *saved_hint = hint;\n    int             hex = 0, x = 0;\n    u_char         *cp;\n    int             output_format, cnt;\n\n    if (var->type != ASN_OCTET_STR) {\n        if (!netsnmp_ds_get_boolean(\n                    NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            const char      str[] = \"Wrong Type (should be OCTET STRING): \";\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n\n    if (hint) {\n        int             repeat, width = 1;\n        long            value;\n        char            code = 'd', separ = 0, term = 0, ch, intbuf[32];\n#define HEX2DIGIT_NEED_INIT 3\n        char            hex2digit = HEX2DIGIT_NEED_INIT;\n        u_char         *ecp;\n\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"STRING: \")) {\n                return 0;\n            }\n        }\n        cp = var->val.string;\n        ecp = cp + var->val_len;\n\n        while (cp < ecp) {\n            repeat = 1;\n            if (*hint) {\n                if (*hint == '*') {\n                    repeat = *cp++;\n                    hint++;\n                }\n                width = 0;\n                while ('0' <= *hint && *hint <= '9')\n                    width = (width * 10) + (*hint++ - '0');\n                code = *hint++;\n                if ((ch = *hint) && ch != '*' && (ch < '0' || ch > '9')\n                    && (width != 0\n                        || (ch != 'x' && ch != 'd' && ch != 'o')))\n                    separ = *hint++;\n                else\n                    separ = 0;\n                if ((ch = *hint) && ch != '*' && (ch < '0' || ch > '9')\n                    && (width != 0\n                        || (ch != 'x' && ch != 'd' && ch != 'o')))\n                    term = *hint++;\n                else\n                    term = 0;\n                if (width == 0)  /* Handle malformed hint strings */\n                    width = 1;\n            }\n\n            while (repeat && cp < ecp) {\n                value = 0;\n                if (code != 'a' && code != 't') {\n                    for (x = 0; x < width; x++) {\n                        value = value * 256 + *cp++;\n                    }\n                }\n                switch (code) {\n                case 'x':\n                    if (HEX2DIGIT_NEED_INIT == hex2digit)\n                        hex2digit = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                                           NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);\n                    /*\n                     * if value is < 16, it will be a single hex digit. If the\n                     * width is 1 (we are outputting a byte at a time), pat it\n                     * to 2 digits if NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT is set\n                     * or all of the following are true:\n                     *  - we do not have a separation character\n                     *  - there is no hint left (or there never was a hint)\n                     *\n                     * e.g. for the data 0xAA01BB, would anyone really ever\n                     * want the string \"AA1BB\"??\n                     */\n                    if (((value < 16) && (1 == width)) &&\n                        (hex2digit || ((0 == separ) && (0 == *hint)))) {\n                        sprintf(intbuf, \"0%lx\", value);\n                    } else {\n                        sprintf(intbuf, \"%lx\", value);\n                    }\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 'd':\n                    sprintf(intbuf, \"%ld\", value);\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 'o':\n                    sprintf(intbuf, \"%lo\", value);\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 't': /* new in rfc 3411 */\n                case 'a':\n                    /* A string hint gives the max size - we may not need this much */\n                    cnt = SNMP_MIN(width, ecp - cp);\n                    while ((*out_len + cnt + 1) > *buf_len) {\n                        if (!allow_realloc || !snmp_realloc(buf, buf_len))\n                            return 0;\n                    }\n                    if (memchr(cp, '\\0', cnt) == NULL) {\n                        /* No embedded '\\0' - use memcpy() to preserve UTF-8 */\n                        memcpy(*buf + *out_len, cp, cnt);\n                        *out_len += cnt;\n                        *(*buf + *out_len) = '\\0';\n                    } else if (!sprint_realloc_asciistring(buf, buf_len,\n                                     out_len, allow_realloc, cp, cnt)) {\n                        return 0;\n                    }\n                    cp += cnt;\n                    break;\n                default:\n                    *out_len = saved_out_len;\n                    if (snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                     \"(Bad hint ignored: \")\n                        && snmp_cstrcat(buf, buf_len, out_len,\n                                       allow_realloc, saved_hint)\n                        && snmp_cstrcat(buf, buf_len, out_len,\n                                       allow_realloc, \") \")) {\n                        return sprint_realloc_octet_string(buf, buf_len,\n                                                           out_len,\n                                                           allow_realloc,\n                                                           var, enums,\n                                                           NULL, NULL);\n                    } else {\n                        return 0;\n                    }\n                }\n\n                if (cp < ecp && separ) {\n                    while ((*out_len + 1) >= *buf_len) {\n                        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                            return 0;\n                        }\n                    }\n                    *(*buf + *out_len) = separ;\n                    (*out_len)++;\n                    *(*buf + *out_len) = '\\0';\n                }\n                repeat--;\n            }\n\n            if (term && cp < ecp) {\n                while ((*out_len + 1) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = term;\n                (*out_len)++;\n                *(*buf + *out_len) = '\\0';\n            }\n        }\n\n        if (units) {\n            return (snmp_cstrcat\n                    (buf, buf_len, out_len, allow_realloc, \" \")\n                    && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n        }\n        if ((*out_len >= *buf_len) &&\n            !(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n        *(*buf + *out_len) = '\\0';\n\n        return 1;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_STRING_OUTPUT_GUESS;\n    }\n    switch (output_format) {\n    case NETSNMP_STRING_OUTPUT_GUESS:\n        hex = 0;\n        for (cp = var->val.string, x = 0; x < (int) var->val_len; x++, cp++) {\n            if (!isprint(*cp) && !isspace(*cp)) {\n                hex = 1;\n            }\n        }\n        break;\n\n    case NETSNMP_STRING_OUTPUT_ASCII:\n        hex = 0;\n        break;\n\n    case NETSNMP_STRING_OUTPUT_HEX:\n        hex = 1;\n        break;\n    }\n\n    if (var->val_len == 0) {\n        return snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\\"\");\n    }\n\n    if (hex) {\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n                return 0;\n            }\n        } else {\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Hex-STRING: \")) {\n                return 0;\n            }\n        }\n\n        if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                      var->val.string, var->val_len)) {\n            return 0;\n        }\n\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n                return 0;\n            }\n        }\n    } else {\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"STRING: \")) {\n                return 0;\n            }\n        }\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n            return 0;\n        }\n        if (!sprint_realloc_asciistring\n            (buf, buf_len, out_len, allow_realloc, var->val.string,\n             var->val_len)) {\n            return 0;\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n\n/**\n * Prints a float into a buffer.\n *\n * The variable var is encoded as a floating point value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_float(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const netsnmp_variable_list * var,\n                     const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    char *printf_format_string = NULL;\n\n    if (var->type != ASN_OPAQUE_FLOAT) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Float): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"Opaque: Float: \")) {\n            return 0;\n        }\n    }\n\n\n    /*\n     * How much space needed for max. length float?  128 is overkill.  \n     */\n\n    while ((*out_len + 128 + 1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    printf_format_string = make_printf_format_string(\"%f\");\n    if (!printf_format_string) {\n        return 0;\n    }\n    snprintf((char *)(*buf + *out_len), 128, printf_format_string, *var->val.floatVal);\n    free(printf_format_string);\n    *out_len += strlen((char *) (*buf + *out_len));\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a double into a buffer.\n *\n * The variable var is encoded as a double precision floating point value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_double(u_char ** buf, size_t * buf_len,\n                      size_t * out_len, int allow_realloc,\n                      const netsnmp_variable_list * var,\n                      const struct enum_list *enums,\n                      const char *hint, const char *units)\n{\n    char *printf_format_string = NULL;\n\n    if (var->type != ASN_OPAQUE_DOUBLE) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Double): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"Opaque: Float: \")) {\n            return 0;\n        }\n    }\n\n    /*\n     * How much space needed for max. length double?  128 is overkill.  \n     */\n\n    while ((*out_len + 128 + 1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    printf_format_string = make_printf_format_string(\"%f\");\n    if (!printf_format_string) {\n        return 0;\n    }\n    snprintf((char *)(*buf + *out_len), 128, printf_format_string, *var->val.doubleVal);\n    free(printf_format_string);\n    *out_len += strlen((char *) (*buf + *out_len));\n\n    if (units) {\n        return (snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n\n\n/**\n * Prints a counter into a buffer.\n *\n * The variable var is encoded as a counter value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_counter64(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    char            a64buf[I64CHARSZ + 1];\n\n    if (var->type != ASN_COUNTER64\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        && var->type != ASN_OPAQUE_COUNTER64\n        && var->type != ASN_OPAQUE_I64 && var->type != ASN_OPAQUE_U64\n#endif\n        ) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Counter64): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        if (var->type != ASN_COUNTER64) {\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Opaque: \")) {\n                return 0;\n            }\n        }\n#endif\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        switch (var->type) {\n        case ASN_OPAQUE_U64:\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"UInt64: \")) {\n                return 0;\n            }\n            break;\n        case ASN_OPAQUE_I64:\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Int64: \")) {\n                return 0;\n            }\n            break;\n        case ASN_COUNTER64:\n        case ASN_OPAQUE_COUNTER64:\n#endif\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Counter64: \")) {\n                return 0;\n            }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        }\n#endif\n    }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    if (var->type == ASN_OPAQUE_I64) {\n        printI64(a64buf, var->val.counter64);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, a64buf)) {\n            return 0;\n        }\n    } else {\n#endif\n        printU64(a64buf, var->val.counter64);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, a64buf)) {\n            return 0;\n        }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    }\n#endif\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an object identifier into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_opaque(u_char ** buf, size_t * buf_len,\n                      size_t * out_len, int allow_realloc,\n                      const netsnmp_variable_list * var,\n                      const struct enum_list *enums,\n                      const char *hint, const char *units)\n{\n    if (var->type != ASN_OPAQUE\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        && var->type != ASN_OPAQUE_COUNTER64\n        && var->type != ASN_OPAQUE_U64\n        && var->type != ASN_OPAQUE_I64\n        && var->type != ASN_OPAQUE_FLOAT && var->type != ASN_OPAQUE_DOUBLE\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n        ) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Opaque): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    switch (var->type) {\n    case ASN_OPAQUE_COUNTER64:\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n        return sprint_realloc_counter64(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n        break;\n\n    case ASN_OPAQUE_FLOAT:\n        return sprint_realloc_float(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n        break;\n\n    case ASN_OPAQUE_DOUBLE:\n        return sprint_realloc_double(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n        break;\n\n    case ASN_OPAQUE:\n#endif\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            u_char          str[] = \"OPAQUE: \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n                return 0;\n            }\n        }\n        if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                      var->val.string, var->val_len)) {\n            return 0;\n        }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    }\n#endif\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an object identifier into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_object_identifier(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const netsnmp_variable_list * var,\n                                 const struct enum_list *enums,\n                                 const char *hint, const char *units)\n{\n    int             buf_overflow = 0;\n\n    if (var->type != ASN_OBJECT_ID) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be OBJECT IDENTIFIER): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"OID: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,\n                                      &buf_overflow,\n                                      (oid *) (var->val.objid),\n                                      var->val_len / sizeof(oid));\n\n    if (buf_overflow) {\n        return 0;\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n\n/**\n * Prints a timetick variable into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_timeticks(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    char            timebuf[40];\n\n    if (var->type != ASN_TIMETICKS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Timeticks): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {\n        char            str[32];\n        sprintf(str, \"%lu\", *(u_long *) var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n        return 1;\n    }\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        char            str[32];\n        sprintf(str, \"Timeticks: (%lu) \", *(u_long *) var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n    uptimeString(*(u_long *) (var->val.integer), timebuf, sizeof(timebuf));\n    if (!snmp_strcat\n        (buf, buf_len, out_len, allow_realloc, (const u_char *) timebuf)) {\n        return 0;\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an integer according to the hint into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param val      The variable to encode.\n * @param decimaltype 'd' or 'u' depending on integer type\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may _NOT_ be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_hinted_integer(u_char ** buf, size_t * buf_len,\n                              size_t * out_len, int allow_realloc,\n                              long val, const char decimaltype,\n                              const char *hint, const char *units)\n{\n    char            fmt[10] = \"%l@\", tmp[256];\n    int             shift = 0, len, negative = 0;\n\n    if (hint[0] == 'd') {\n        /*\n         * We might *actually* want a 'u' here.  \n         */\n        if (hint[1] == '-')\n            shift = atoi(hint + 2);\n        fmt[2] = decimaltype;\n        if (val < 0) {\n            negative = 1;\n            val = -val;\n        }\n    } else {\n        /*\n         * DISPLAY-HINT character is 'b', 'o', or 'x'.  \n         */\n        fmt[2] = hint[0];\n    }\n\n    if (hint[0] == 'b') {\n\tunsigned long int bit = 0x80000000LU;\n\tchar *bp = tmp;\n\twhile (bit) {\n\t    *bp++ = val & bit ? '1' : '0';\n\t    bit >>= 1;\n\t}\n\t*bp = 0;\n    }\n    else\n\tsprintf(tmp, fmt, val);\n\n    if (shift != 0) {\n        len = strlen(tmp);\n        if (shift <= len) {\n            tmp[len + 1] = 0;\n            while (shift--) {\n                tmp[len] = tmp[len - 1];\n                len--;\n            }\n            tmp[len] = '.';\n        } else {\n            tmp[shift + 1] = 0;\n            while (shift) {\n                if (len-- > 0) {\n                    tmp[shift] = tmp[len];\n                } else {\n                    tmp[shift] = '0';\n                }\n                shift--;\n            }\n            tmp[0] = '.';\n        }\n    }\n    if (negative) {\n        len = strlen(tmp)+1;\n        while (len) {\n            tmp[len] = tmp[len-1];\n            len--;\n        }\n        tmp[0] = '-';\n    }\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, (u_char *)tmp);\n}\n\n\n/**\n * Prints an integer into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_integer(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    char           *enum_string = NULL;\n\n    if (var->type != ASN_INTEGER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be INTEGER): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    for (; enums; enums = enums->next) {\n        if (enums->value == *var->val.integer) {\n            enum_string = enums->label;\n            break;\n        }\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                         (const u_char *) \"INTEGER: \")) {\n            return 0;\n        }\n    }\n\n    if (enum_string == NULL ||\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n        if (hint) {\n            if (!(sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                                allow_realloc,\n                                                *var->val.integer, 'd',\n                                                hint, units))) {\n                return 0;\n            }\n        } else {\n            char            str[32];\n            sprintf(str, \"%ld\", *var->val.integer);\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) str)) {\n                return 0;\n            }\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n    } else {\n        char            str[32];\n        sprintf(str, \"(%ld)\", *var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an unsigned integer into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_uinteger(u_char ** buf, size_t * buf_len, size_t * out_len,\n                        int allow_realloc,\n                        const netsnmp_variable_list * var,\n                        const struct enum_list *enums,\n                        const char *hint, const char *units)\n{\n    char           *enum_string = NULL;\n\n    if (var->type != ASN_UINTEGER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be UInteger32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    for (; enums; enums = enums->next) {\n        if (enums->value == *var->val.integer) {\n            enum_string = enums->label;\n            break;\n        }\n    }\n\n    if (enum_string == NULL ||\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n        if (hint) {\n            if (!(sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                                allow_realloc,\n                                                *var->val.integer, 'u',\n                                                hint, units))) {\n                return 0;\n            }\n        } else {\n            char            str[32];\n            sprintf(str, \"%lu\", *var->val.integer);\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) str)) {\n                return 0;\n            }\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n    } else {\n        char            str[32];\n        sprintf(str, \"(%lu)\", *var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a gauge value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_gauge(u_char ** buf, size_t * buf_len, size_t * out_len,\n                     int allow_realloc,\n                     const netsnmp_variable_list * var,\n                     const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    char            tmp[32];\n\n    if (var->type != ASN_GAUGE) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Gauge32 or Unsigned32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Gauge32: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    if (hint) {\n        if (!sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           *var->val.integer, 'u', hint,\n                                           units)) {\n            return 0;\n        }\n    } else {\n        sprintf(tmp, \"%u\", (unsigned int)(*var->val.integer & 0xffffffff));\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) tmp)) {\n            return 0;\n        }\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a counter value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_counter(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    char            tmp[32];\n\n    if (var->type != ASN_COUNTER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Counter32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Counter32: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    sprintf(tmp, \"%u\", (unsigned int)(*var->val.integer & 0xffffffff));\n    if (!snmp_strcat\n        (buf, buf_len, out_len, allow_realloc, (const u_char *) tmp)) {\n        return 0;\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a network address into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_networkaddress(u_char ** buf, size_t * buf_len,\n                              size_t * out_len, int allow_realloc,\n                              const netsnmp_variable_list * var,\n                              const struct enum_list *enums, const char *hint,\n                              const char *units)\n{\n    size_t          i;\n\n    if (var->type != ASN_IPADDRESS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NetworkAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Network Address: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    while ((*out_len + (var->val_len * 3) + 2) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    for (i = 0; i < var->val_len; i++) {\n        sprintf((char *) (*buf + *out_len), \"%02X\", var->val.string[i]);\n        *out_len += 2;\n        if (i < var->val_len - 1) {\n            *(*buf + *out_len) = ':';\n            (*out_len)++;\n        }\n    }\n    return 1;\n}\n\n\n/**\n * Prints an ip-address into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_ipaddress(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    u_char         *ip = var->val.string;\n\n    if (var->type != ASN_IPADDRESS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be IpAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"IpAddress: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    while ((*out_len + 17) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n    if (ip)\n        sprintf((char *) (*buf + *out_len), \"%d.%d.%d.%d\",\n                                            ip[0], ip[1], ip[2], ip[3]);\n    *out_len += strlen((char *) (*buf + *out_len));\n    return 1;\n}\n\n\n/**\n * Prints a null value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_null(u_char ** buf, size_t * buf_len, size_t * out_len,\n                    int allow_realloc,\n                    const netsnmp_variable_list * var,\n                    const struct enum_list *enums,\n                    const char *hint, const char *units)\n{\n    u_char          str[] = \"NULL\";\n\n    if (var->type != ASN_NULL) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NULL): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, str);\n}\n\n\n/**\n * Prints a bit string into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_bitstring(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    int             len, bit;\n    u_char         *cp;\n    char           *enum_string;\n\n    if (var->type != ASN_BIT_STR && var->type != ASN_OCTET_STR) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be BITS): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"\\\"\";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    } else {\n        u_char          str[] = \"BITS: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                  var->val.bitstring, var->val_len)) {\n        return 0;\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"\\\"\";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    } else {\n        cp = var->val.bitstring;\n        for (len = 0; len < (int) var->val_len; len++) {\n            for (bit = 0; bit < 8; bit++) {\n                if (*cp & (0x80 >> bit)) {\n                    enum_string = NULL;\n                    for (; enums; enums = enums->next) {\n                        if (enums->value == (len * 8) + bit) {\n                            enum_string = enums->label;\n                            break;\n                        }\n                    }\n                    if (enum_string == NULL ||\n                        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                       NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n                        char            str[32];\n                        sprintf(str, \"%d \", (len * 8) + bit);\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) str)) {\n                            return 0;\n                        }\n                    } else {\n                        char            str[32];\n                        sprintf(str, \"(%d) \", (len * 8) + bit);\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) enum_string)) {\n                            return 0;\n                        }\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) str)) {\n                            return 0;\n                        }\n                    }\n                }\n            }\n            cp++;\n        }\n    }\n    return 1;\n}\n\nint\nsprint_realloc_nsapaddress(u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           const netsnmp_variable_list * var,\n                           const struct enum_list *enums, const char *hint,\n                           const char *units)\n{\n    if (var->type != ASN_NSAP) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NsapAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"NsapAddress: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    return sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                    var->val.string, var->val_len);\n}\n\n\n/**\n * Fallback routine for a bad type, prints \"Variable has bad type\" into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_badtype(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    u_char          str[] = \"Variable has bad type\";\n\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, str);\n}\n\n\n\n/**\n * Universal print routine, prints a variable into a buffer according to the variable \n * type.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_by_type(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    DEBUGMSGTL((\"output\", \"sprint_by_type, type %d\\n\", var->type));\n\n    switch (var->type) {\n    case ASN_INTEGER:\n        return sprint_realloc_integer(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    case ASN_OCTET_STR:\n        return sprint_realloc_octet_string(buf, buf_len, out_len,\n                                           allow_realloc, var, enums, hint,\n                                           units);\n    case ASN_BIT_STR:\n        return sprint_realloc_bitstring(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_OPAQUE:\n        return sprint_realloc_opaque(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n    case ASN_OBJECT_ID:\n        return sprint_realloc_object_identifier(buf, buf_len, out_len,\n                                                allow_realloc, var, enums,\n                                                hint, units);\n    case ASN_TIMETICKS:\n        return sprint_realloc_timeticks(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_GAUGE:\n        return sprint_realloc_gauge(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n    case ASN_COUNTER:\n        return sprint_realloc_counter(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    case ASN_IPADDRESS:\n        return sprint_realloc_ipaddress(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_NULL:\n        return sprint_realloc_null(buf, buf_len, out_len, allow_realloc,\n                                   var, enums, hint, units);\n    case ASN_UINTEGER:\n        return sprint_realloc_uinteger(buf, buf_len, out_len,\n                                       allow_realloc, var, enums, hint,\n                                       units);\n    case ASN_COUNTER64:\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n    case ASN_OPAQUE_COUNTER64:\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n        return sprint_realloc_counter64(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_FLOAT:\n        return sprint_realloc_float(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n    case ASN_OPAQUE_DOUBLE:\n        return sprint_realloc_double(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n    default:\n        DEBUGMSGTL((\"sprint_by_type\", \"bad type: %d\\n\", var->type));\n        return sprint_realloc_badtype(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    }\n}\n\n/**\n * Generates a prinf format string.\n *\n * The original format string is combined with the optional\n * NETSNMP_DS_LIB_OUTPUT_PRECISION string (the -Op parameter).\n *\n * Example:\n * If the original format string is \"%f\", and the NETSNMP_DS_LIB_OUTPUT_PRECISION\n * is \"5.2\", the returned format string will be \"%5.2f\".\n * \n * The PRECISION string is inserted after the '%' of the original format string.\n * To prevent buffer overflow if NETSNMP_DS_LIB_OUTPUT_PRECISION is set to an\n * illegal size (e.g. with -Op 10000) snprintf should be used to prevent buffer\n * overflow.\n * \n * @param printf_format_default  The format string used by the original printf.\n * \n * @return The address of of the new allocated format string (which must be freed\n *         if no longer used), or NULL if any error (malloc).\n */\nchar *\nmake_printf_format_string(const char *printf_format_default)\n{\n    const char *cp_printf_format_default;\n    const char *printf_precision;\n    const char *cp_printf_precision;\n    char       *printf_format_string;\n    char       *cp_out;\n    char       c;\n\n    printf_precision = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OUTPUT_PRECISION);\n    if (!printf_precision) {\n        printf_precision = \"\";\n    }\n\n    /* reserve new format string buffer */\n    printf_format_string = (char *) malloc(strlen(printf_format_default)+strlen(printf_precision)+1);\n    if (!printf_format_string)\n    {\n        DEBUGMSGTL((\"make_printf_format_string\", \"malloc failed\\n\"));\n        return NULL;\n    }\n\n    /* copy default format string, including the '%' */\n    cp_out = printf_format_string;\n    cp_printf_format_default = printf_format_default;\n    while((c = *cp_printf_format_default) != '\\0')\n    {\n        *cp_out++ = c;\n        cp_printf_format_default++;\n        if (c == '%') break;\n    }\n\n    /* insert the precision string */\n    cp_printf_precision = printf_precision;\n    while ((c = *cp_printf_precision++) != '\\0')\n    {\n        *cp_out++ = c;\n    }\n\n    /* copy the remaining default format string, including the terminating '\\0' */\n    strcpy(cp_out, cp_printf_format_default);\n\n    DEBUGMSGTL((\"make_printf_format_string\", \"\\\"%s\\\"+\\\"%s\\\"->\\\"%s\\\"\\n\",\n                printf_format_default, printf_precision, printf_format_string));\n    return printf_format_string;\n}\n\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/**\n * Retrieves the tree head.\n *\n * @return the tree head.\n */\nstruct tree    *\nget_tree_head(void)\n{\n    return (tree_head);\n}\n\nstatic char    *confmibdir = NULL;\nstatic char    *confmibs = NULL;\n\nstatic void\nhandle_mibdirs_conf(const char *token, char *line)\n{\n    char           *ctmp;\n\n    if (confmibdir) {\n        if ((*line == '+') || (*line == '-')) {\n            ctmp = (char *) malloc(strlen(confmibdir) + strlen(line) + 2);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\",\n                            \"mibdir conf malloc failed\"));\n                return;\n            }\n            if(*line++ == '+')\n                sprintf(ctmp, \"%s%c%s\", confmibdir, ENV_SEPARATOR_CHAR, line);\n            else\n                sprintf(ctmp, \"%s%c%s\", line, ENV_SEPARATOR_CHAR, confmibdir);\n        } else {\n            ctmp = strdup(line);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n        }\n        SNMP_FREE(confmibdir);\n    } else {\n        ctmp = strdup(line);\n        if (!ctmp) {\n            DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n            return;\n        }\n    }\n    confmibdir = ctmp;\n    DEBUGMSGTL((\"read_config:initmib\", \"using mibdirs: %s\\n\", confmibdir));\n}\n\nstatic void\nhandle_mibs_conf(const char *token, char *line)\n{\n    char           *ctmp;\n\n    if (confmibs) {\n        if ((*line == '+') || (*line == '-')) {\n            ctmp = (char *) malloc(strlen(confmibs) + strlen(line) + 2);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n            if(*line++ == '+')\n                sprintf(ctmp, \"%s%c%s\", confmibs, ENV_SEPARATOR_CHAR, line);\n            else\n                sprintf(ctmp, \"%s%c%s\", line, ENV_SEPARATOR_CHAR, confmibdir);\n        } else {\n            ctmp = strdup(line);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n        }\n        SNMP_FREE(confmibs);\n    } else {\n        ctmp = strdup(line);\n        if (!ctmp) {\n            DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n            return;\n        }\n    }\n    confmibs = ctmp;\n    DEBUGMSGTL((\"read_config:initmib\", \"using mibs: %s\\n\", confmibs));\n}\n\n\nstatic void\nhandle_mibfile_conf(const char *token, char *line)\n{\n    DEBUGMSGTL((\"read_config:initmib\", \"reading mibfile: %s\\n\", line));\n    read_mib(line);\n}\n#endif\n\nstatic void\nhandle_print_numeric(const char *token, char *line)\n{\n    const char *value;\n    char       *st;\n\n    value = strtok_r(line, \" \\t\\n\", &st);\n    if (value && (\n\t    (strcasecmp(value, \"yes\")  == 0) || \n\t    (strcasecmp(value, \"true\") == 0) ||\n\t    (*value == '1') )) {\n\n        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                  NETSNMP_OID_OUTPUT_NUMERIC);\n    }\n}\n\nchar *\nsnmp_out_options(char *options, int argc, char *const *argv)\n{\n    while (*options) {\n        switch (*options++) {\n        case '0':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n                                      NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);\n            break;\n        case 'a':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,\n                                                      NETSNMP_STRING_OUTPUT_ASCII);\n            break;\n        case 'b':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);\n            break;\n        case 'e':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n            break;\n        case 'E':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);\n            break;\n        case 'f':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_FULL);\n            break;\n        case 'n':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_NUMERIC);\n            break;\n        case 'p':\n            /* What if argc/argv are null ? */\n            if (!*(options)) {\n                options = argv[optind++];\n            }\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OUTPUT_PRECISION,\n                                  options);\n            return NULL;  /* -Op... is a standalone option, so we're done here */\n        case 'q':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n            break;\n        case 'Q':\n            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 1);\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n            break;\n        case 's':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_SUFFIX);\n            break;\n        case 'S':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_MODULE);\n            break;\n        case 't':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);\n            break;\n        case 'T':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);\n            break;\n        case 'u':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_UCD);\n            break;\n        case 'U':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);\n            break;\n        case 'v':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);\n            break;\n        case 'x':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,\n                                                      NETSNMP_STRING_OUTPUT_HEX);\n            break;\n        case 'X':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n            break;\n        default:\n            return options - 1;\n        }\n    }\n    return NULL;\n}\n\nchar           *\nsnmp_out_toggle_options(char *options)\n{\n    return snmp_out_options( options, 0, NULL );\n}\n\nvoid\nsnmp_out_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%s0:  print leading 0 for single-digit hex characters\\n\", lead);\n    fprintf(outf, \"%sa:  print all strings in ascii format\\n\", lead);\n    fprintf(outf, \"%sb:  do not break OID indexes down\\n\", lead);\n    fprintf(outf, \"%se:  print enums numerically\\n\", lead);\n    fprintf(outf, \"%sE:  escape quotes in string indices\\n\", lead);\n    fprintf(outf, \"%sf:  print full OIDs on output\\n\", lead);\n    fprintf(outf, \"%sn:  print OIDs numerically\\n\", lead);\n    fprintf(outf, \"%sp PRECISION:  display floating point values with specified PRECISION (printf format string)\\n\", lead);\n    fprintf(outf, \"%sq:  quick print for easier parsing\\n\", lead);\n    fprintf(outf, \"%sQ:  quick print with equal-signs\\n\", lead);    /* @@JDW */\n    fprintf(outf, \"%ss:  print only last symbolic element of OID\\n\", lead);\n    fprintf(outf, \"%sS:  print MIB module-id plus last element\\n\", lead);\n    fprintf(outf, \"%st:  print timeticks unparsed as numeric integers\\n\",\n            lead);\n    fprintf(outf,\n            \"%sT:  print human-readable text along with hex strings\\n\",\n            lead);\n    fprintf(outf, \"%su:  print OIDs using UCD-style prefix suppression\\n\",\n            lead);\n    fprintf(outf, \"%sU:  don't print units\\n\", lead);\n    fprintf(outf, \"%sv:  print values only (not OID = value)\\n\", lead);\n    fprintf(outf, \"%sx:  print all strings in hex format\\n\", lead);\n    fprintf(outf, \"%sX:  extended index format\\n\", lead);\n}\n\nchar *\nsnmp_in_options(char *optarg, int argc, char *const *argv)\n{\n    char *cp;\n\n    for (cp = optarg; *cp; cp++) {\n        switch (*cp) {\n        case 'b':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS);\n            break;\n        case 'R':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS);\n            break;\n        case 'r':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);\n            break;\n        case 'h':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);\n            break;\n        case 'u':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID);\n            break;\n        case 's':\n            /* What if argc/argv are null ? */\n            if (!*(++cp))\n                cp = argv[optind++];\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OIDSUFFIX,\n                                  cp);\n            return NULL;  /* -Is... is a standalone option, so we're done here */\n\n        case 'S':\n            /* What if argc/argv are null ? */\n            if (!*(++cp))\n                cp = argv[optind++];\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OIDPREFIX,\n                                  cp);\n            return NULL;  /* -IS... is a standalone option, so we're done here */\n\n        default:\n           /*\n            *  Here?  Or in snmp_parse_args?\n            snmp_log(LOG_ERR, \"Unknown input option passed to -I: %c.\\n\", *cp);\n            */\n            return cp;\n        }\n    }\n    return NULL;\n}\n\nchar           *\nsnmp_in_toggle_options(char *options)\n{\n    return snmp_in_options( options, 0, NULL );\n}\n\n\n/**\n * Prints out a help usage for the in* toggle options.\n *\n * @param lead      The lead to print for every line.\n * @param outf      The file descriptor to write to.\n * \n */\nvoid\nsnmp_in_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%sb:  do best/regex matching to find a MIB node\\n\", lead);\n    fprintf(outf, \"%sh:  don't apply DISPLAY-HINTs\\n\", lead);\n    fprintf(outf, \"%sr:  do not check values for range/type legality\\n\", lead);\n    fprintf(outf, \"%sR:  do random access to OID labels\\n\", lead);\n    fprintf(outf,\n            \"%su:  top-level OIDs must have '.' prefix (UCD-style)\\n\", lead);\n    fprintf(outf,\n            \"%ss SUFFIX:  Append all textual OIDs with SUFFIX before parsing\\n\",\n            lead);\n    fprintf(outf,\n            \"%sS PREFIX:  Prepend all textual OIDs with PREFIX before parsing\\n\",\n            lead);\n}\n\n/***\n *\n */ \nvoid\nregister_mib_handlers(void)\n{\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    register_prenetsnmp_mib_handler(\"snmp\", \"mibdirs\",\n                                    handle_mibdirs_conf, NULL,\n                                    \"[mib-dirs|+mib-dirs|-mib-dirs]\");\n    register_prenetsnmp_mib_handler(\"snmp\", \"mibs\",\n                                    handle_mibs_conf, NULL,\n                                    \"[mib-tokens|+mib-tokens]\");\n    register_config_handler(\"snmp\", \"mibfile\",\n                            handle_mibfile_conf, NULL, \"mibfile-to-read\");\n    /*\n     * register the snmp.conf configuration handlers for default\n     * parsing behaviour \n     */\n\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"showMibErrors\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"commentToEOL\",     /* Describes actual behaviour */\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"strictCommentTerm\",    /* Backward compatibility */\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"mibAllowUnderline\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"mibWarningLevel\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"mibReplaceWithLatest\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_REPLACE);\n#endif\n\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printNumericEnums\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n    register_prenetsnmp_mib_handler(\"snmp\", \"printNumericOids\",\n                       handle_print_numeric, NULL, \"(1|yes|true|0|no|false)\");\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"escapeQuotes\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"dontBreakdownOids\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"quickPrinting\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"numericTimeticks\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"oidOutputFormat\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"suffixPrinting\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"extendedIndex\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printHexText\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printValueOnly\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"dontPrintUnits\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"hexOutputLength\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * function : netsnmp_set_mib_directory\n *            - This function sets the string of the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n * arguments: const char *dir, which are the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n * returns  : -\n */\nvoid\nnetsnmp_set_mib_directory(const char *dir)\n{\n    const char *newdir;\n    char *olddir, *tmpdir = NULL;\n\n    DEBUGTRACE;\n    if (NULL == dir) {\n        return;\n    }\n    \n    olddir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIBDIRS);\n    if (olddir) {\n        if ((*dir == '+') || (*dir == '-')) {\n            /** New dir starts with '+', thus we add it. */\n            tmpdir = (char *)malloc(strlen(dir) + strlen(olddir) + 2);\n            if (!tmpdir) {\n                DEBUGMSGTL((\"read_config:initmib\", \"set mibdir malloc failed\"));\n                return;\n            }\n            if (*dir++ == '+')\n                sprintf(tmpdir, \"%s%c%s\", olddir, ENV_SEPARATOR_CHAR, dir);\n            else\n                sprintf(tmpdir, \"%s%c%s\", dir, ENV_SEPARATOR_CHAR, olddir);\n            newdir = tmpdir;\n        } else {\n            newdir = dir;\n        }\n    } else {\n        /** If dir starts with '+' skip '+' it. */\n        newdir = ((*dir == '+') ? ++dir : dir);\n    }\n    netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS,\n                          newdir);\n\n    /** set_string calls strdup, so if we allocated memory, free it */\n    if (tmpdir == newdir) {\n        SNMP_FREE(tmpdir);\n    }\n}\n\n/*\n * function : netsnmp_get_mib_directory\n *            - This function returns a string of the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n *              If the value still does not exists, it will be made\n *              from the evironment variable 'MIBDIRS' and/or the\n *              default.\n * arguments: -\n * returns  : char * of the directories in which the MIB modules\n *            will be searched/loaded.\n */\n\nchar *\nnetsnmp_get_mib_directory(void)\n{\n    char *dir;\n\n    DEBUGTRACE;\n    dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);\n    if (dir == NULL) {\n        DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set\\n\"));\n\n        /** Check if the environment variable is set */\n        dir = netsnmp_getenv(\"MIBDIRS\");\n        if (dir == NULL) {\n            DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set by environment\\n\"));\n            /** Not set use hard coded path */\n            if (confmibdir == NULL) {\n                DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set by config\\n\"));\n                netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n            }\n            else if ((*confmibdir == '+') || (*confmibdir == '-')) {\n                DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by config (but added)\\n\"));\n                netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n                netsnmp_set_mib_directory(confmibdir);\n            }\n            else {\n                DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by config\\n\"));\n                netsnmp_set_mib_directory(confmibdir);\n            }\n        } else if ((*dir == '+') || (*dir == '-')) {\n            DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by environment (but added)\\n\"));\n            netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n            netsnmp_set_mib_directory(dir);\n        } else {\n            DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by environment\\n\"));\n            netsnmp_set_mib_directory(dir);\n        }\n        dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);\n    }\n    DEBUGMSGTL((\"get_mib_directory\", \"mib directories set '%s'\\n\", dir));\n    return(dir);\n}\n\n/*\n * function : netsnmp_fixup_mib_directory\n * arguments: -\n * returns  : -\n */\nvoid\nnetsnmp_fixup_mib_directory(void)\n{\n    char *homepath = netsnmp_getenv(\"HOME\");\n    char *mibpath = netsnmp_get_mib_directory();\n    char *oldmibpath = NULL;\n    char *ptr_home;\n    char *new_mibpath;\n\n    DEBUGTRACE;\n    if (homepath && mibpath) {\n        DEBUGMSGTL((\"fixup_mib_directory\", \"mib directories '%s'\\n\", mibpath));\n        while ((ptr_home = strstr(mibpath, \"$HOME\"))) {\n            new_mibpath = (char *)malloc(strlen(mibpath) - strlen(\"$HOME\") +\n\t\t\t\t\t strlen(homepath)+1);\n            if (new_mibpath) {\n                *ptr_home = 0; /* null out the spot where we stop copying */\n                sprintf(new_mibpath, \"%s%s%s\", mibpath, homepath,\n\t\t\tptr_home + strlen(\"$HOME\"));\n                /** swap in the new value and repeat */\n                mibpath = new_mibpath;\n\t\tif (oldmibpath != NULL) {\n\t\t    SNMP_FREE(oldmibpath);\n\t\t}\n\t\toldmibpath = new_mibpath;\n            } else {\n                break;\n            }\n        }\n\n        netsnmp_set_mib_directory(mibpath);\n\t\n\t/*  The above copies the mibpath for us, so...  */\n\n\tif (oldmibpath != NULL) {\n\t    SNMP_FREE(oldmibpath);\n\t}\n\n    }\n\n}\n\n/**\n * Initialises the mib reader.\n *\n * Reads in all settings from the environment.\n */\nvoid\nnetsnmp_init_mib(void)\n{\n    const char     *prefix;\n    char           *env_var, *entry;\n    PrefixListPtr   pp = &mib_prefixes[0];\n    char           *st = NULL;\n\n    if (Mib)\n        return;\n    netsnmp_init_mib_internals();\n\n    /*\n     * Initialise the MIB directory/ies \n     */\n    netsnmp_fixup_mib_directory();\n    env_var = strdup(netsnmp_get_mib_directory());\n    if (!env_var)\n        return;\n    netsnmp_mibindex_load();\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n                env_var));\n\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        add_mibdir(entry);\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if (*env_var == '+')\n            entry = strtok_r(env_var+1, ENV_SEPARATOR, &st);\n        else\n            entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            add_mibfile(entry, NULL, NULL);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n    }\n\n    netsnmp_init_mib_internals();\n\n    /*\n     * Read in any modules or mibs requested \n     */\n\n    env_var = netsnmp_getenv(\"MIBS\");\n    if (env_var == NULL) {\n        if (confmibs != NULL)\n            env_var = strdup(confmibs);\n        else\n            env_var = strdup(NETSNMP_DEFAULT_MIBS);\n    } else {\n        env_var = strdup(env_var);\n    }\n    if (env_var && ((*env_var == '+') || (*env_var == '-'))) {\n        entry =\n            (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2);\n        if (!entry) {\n            DEBUGMSGTL((\"init_mib\", \"env mibs malloc failed\"));\n            SNMP_FREE(env_var);\n            return;\n        } else {\n            if (*env_var == '+')\n                sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR,\n                        env_var+1);\n            else\n                sprintf(entry, \"%s%c%s\", env_var+1, ENV_SEPARATOR_CHAR,\n                        NETSNMP_DEFAULT_MIBS );\n        }\n        SNMP_FREE(env_var);\n        env_var = entry;\n    }\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBS: Looking in '%s' for mib files ...\\n\",\n                env_var));\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {\n            read_all_mibs();\n        } else if (strstr(entry, \"/\") != NULL) {\n            read_mib(entry);\n        } else {\n            netsnmp_read_module(entry);\n        }\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    adopt_orphans();\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if ((*env_var == '+') || (*env_var == '-')) {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n            entry =\n                (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) +\n                                strlen(env_var) + 2);\n            if (!entry) {\n                DEBUGMSGTL((\"init_mib\", \"env mibfiles malloc failed\"));\n            } else {\n                if (*env_var++ == '+')\n                    sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,\n                            env_var );\n                else\n                    sprintf(entry, \"%s%c%s\", env_var, ENV_SEPARATOR_CHAR,\n                            NETSNMP_DEFAULT_MIBFILES );\n            }\n            SNMP_FREE(env_var);\n            env_var = entry;\n#else\n            env_var = strdup(env_var + 1);\n#endif\n        } else {\n            env_var = strdup(env_var);\n        }\n    } else {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n        env_var = strdup(NETSNMP_DEFAULT_MIBFILES);\n#endif\n    }\n\n    if (env_var != NULL) {\n        DEBUGMSGTL((\"init_mib\",\n                    \"Seen MIBFILES: Looking in '%s' for mib files ...\\n\",\n                    env_var));\n        entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            read_mib(entry);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n        SNMP_FREE(env_var);\n    }\n\n    prefix = netsnmp_getenv(\"PREFIX\");\n\n    if (!prefix)\n        prefix = Standard_Prefix;\n\n    Prefix = (char *) malloc(strlen(prefix) + 2);\n    if (!Prefix)\n        DEBUGMSGTL((\"init_mib\", \"Prefix malloc failed\"));\n    else\n        strcpy(Prefix, prefix);\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen PREFIX: Looking in '%s' for prefix ...\\n\", Prefix));\n\n    /*\n     * remove trailing dot \n     */\n    if (Prefix) {\n        env_var = &Prefix[strlen(Prefix) - 1];\n        if (*env_var == '.')\n            *env_var = '\\0';\n    }\n\n    pp->str = Prefix;           /* fixup first mib_prefix entry */\n    /*\n     * now that the list of prefixes is built, save each string length. \n     */\n    while (pp->str) {\n        pp->len = strlen(pp->str);\n        pp++;\n    }\n\n    Mib = tree_head;            /* Backwards compatibility */\n    tree_top = (struct tree *) calloc(1, sizeof(struct tree));\n    /*\n     * XX error check ? \n     */\n    if (tree_top) {\n        tree_top->label = strdup(\"(top)\");\n        tree_top->child_list = tree_head;\n    }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nvoid\ninit_mib(void)\n{\n    netsnmp_init_mib();\n}\n#endif\n\n\n/*\n * Handle MIB indexes centrally\n */\nstatic int _mibindex     = 0;   /* Last index in use */\nstatic int _mibindex_max = 0;   /* Size of index array */\nchar     **_mibindexes   = NULL;\n\nint _mibindex_add( const char *dirname, int i );\nvoid\nnetsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n\n    /*\n     * Open the MIB index directory, or create it (empty)\n     */\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n\n    /*\n     * Create a list of which directory each file refers to\n     */\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  /* Skip 'DIR ' */\n    }\n    closedir( dir );\n}\n\nchar *\nnetsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}\n\nint\n_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        /*\n         * If the index array is full (or non-existent)\n         *   then expand (or create) it\n         */\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}\n    \nFILE *\nnetsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}\n\n\n/**\n * Unloads all mibs.\n */\nvoid\nshutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}\n\n/**\n * Prints the MIBs to the file fp.\n *\n * @param fp   The file descriptor to print to.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_PRINT_MIB\nvoid\nprint_mib(FILE * fp)\n{\n    print_subtree(fp, tree_head, 0);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PRINT_MIB */\n\nvoid\nprint_ascii_dump(FILE * fp)\n{\n    fprintf(fp, \"dump DEFINITIONS ::= BEGIN\\n\");\n    print_ascii_dump_tree(fp, tree_head, 0);\n    fprintf(fp, \"END\\n\");\n}\n\n\n/**\n * Set's the printing function printomat in a subtree according\n * it's type\n *\n * @param subtree    The subtree to set.\n */\nvoid\nset_function(struct tree *subtree)\n{\n    subtree->printer = NULL;\n    switch (subtree->type) {\n    case TYPE_OBJID:\n        subtree->printomat = sprint_realloc_object_identifier;\n        break;\n    case TYPE_OCTETSTR:\n        subtree->printomat = sprint_realloc_octet_string;\n        break;\n    case TYPE_INTEGER:\n        subtree->printomat = sprint_realloc_integer;\n        break;\n    case TYPE_INTEGER32:\n        subtree->printomat = sprint_realloc_integer;\n        break;\n    case TYPE_NETADDR:\n        subtree->printomat = sprint_realloc_networkaddress;\n        break;\n    case TYPE_IPADDR:\n        subtree->printomat = sprint_realloc_ipaddress;\n        break;\n    case TYPE_COUNTER:\n        subtree->printomat = sprint_realloc_counter;\n        break;\n    case TYPE_GAUGE:\n        subtree->printomat = sprint_realloc_gauge;\n        break;\n    case TYPE_TIMETICKS:\n        subtree->printomat = sprint_realloc_timeticks;\n        break;\n    case TYPE_OPAQUE:\n        subtree->printomat = sprint_realloc_opaque;\n        break;\n    case TYPE_NULL:\n        subtree->printomat = sprint_realloc_null;\n        break;\n    case TYPE_BITSTRING:\n        subtree->printomat = sprint_realloc_bitstring;\n        break;\n    case TYPE_NSAPADDRESS:\n        subtree->printomat = sprint_realloc_nsapaddress;\n        break;\n    case TYPE_COUNTER64:\n        subtree->printomat = sprint_realloc_counter64;\n        break;\n    case TYPE_UINTEGER:\n        subtree->printomat = sprint_realloc_uinteger;\n        break;\n    case TYPE_UNSIGNED32:\n        subtree->printomat = sprint_realloc_gauge;\n        break;\n    case TYPE_OTHER:\n    default:\n        subtree->printomat = sprint_realloc_by_type;\n        break;\n    }\n}\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n/**\n * Reads an object identifier from an input string into internal OID form.\n * \n * When called, out_len must hold the maximum length of the output array.\n *\n * @param input     the input string.\n * @param output    the oid wirte.\n * @param out_len   number of subid's in output.\n * \n * @return 1 if successful.\n * \n * If an error occurs, this function returns 0 and MAY set snmp_errno.\n * snmp_errno is NOT set if SET_SNMP_ERROR evaluates to nothing.\n * This can make multi-threaded use a tiny bit more robust.\n */\nint\nread_objid(const char *input, oid * output, size_t * out_len)\n{                               /* number of subid's in \"output\" */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *root = tree_top;\n    char            buf[SPRINT_MAX_LEN];\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    int             ret, max_out_len;\n    char           *name, ch;\n    const char     *cp;\n\n    cp = input;\n    while ((ch = *cp)) {\n        if (('0' <= ch && ch <= '9')\n            || ('a' <= ch && ch <= 'z')\n            || ('A' <= ch && ch <= 'Z')\n            || ch == '-')\n            cp++;\n        else\n            break;\n    }\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if (ch == ':')\n        return get_node(input, output, out_len);\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n    if (*input == '.')\n        input++;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID)) {\n        /*\n         * get past leading '.', append '.' to Prefix. \n         */\n        if (*Prefix == '.')\n            strlcpy(buf, Prefix + 1, sizeof(buf));\n        else\n            strlcpy(buf, Prefix, sizeof(buf));\n        strlcat(buf, \".\", sizeof(buf));\n        strlcat(buf, input, sizeof(buf));\n        input = buf;\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if ((root == NULL) && (tree_head != NULL)) {\n        root = tree_head;\n    }\n    else if (root == NULL) {\n        SET_SNMP_ERROR(SNMPERR_NOMIB);\n        *out_len = 0;\n        return 0;\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    name = strdup(input);\n    max_out_len = *out_len;\n    *out_len = 0;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if ((ret =\n         _add_strings_to_oid(root, name, output, out_len,\n                             max_out_len)) <= 0)\n#else\n    if ((ret =\n         _add_strings_to_oid(NULL, name, output, out_len,\n                             max_out_len)) <= 0)\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    {\n        if (ret == 0)\n            ret = SNMPERR_UNKNOWN_OBJID;\n        SET_SNMP_ERROR(ret);\n        SNMP_FREE(name);\n        return 0;\n    }\n    SNMP_FREE(name);\n\n    return 1;\n}\n\n/**\n * \n */\nvoid\nnetsnmp_sprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                             size_t * out_len, int allow_realloc,\n                             int *buf_overflow,\n                             const oid * objid, size_t objidlen)\n{\n    u_char         *tbuf = NULL, *cp = NULL;\n    size_t          tbuf_len = 256, tout_len = 0;\n    int             tbuf_overflow = 0;\n    int             output_format;\n\n    if ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {\n        tbuf_overflow = 1;\n    } else {\n        *tbuf = '.';\n        tout_len = 1;\n    }\n\n    _oid_finish_printing(objid, objidlen,\n                         &tbuf, &tbuf_len, &tout_len,\n                         allow_realloc, &tbuf_overflow);\n\n    if (tbuf_overflow) {\n        if (!*buf_overflow) {\n            snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);\n            *buf_overflow = 1;\n        }\n        SNMP_FREE(tbuf);\n        return;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_OID_OUTPUT_NUMERIC;\n    }\n    switch (output_format) {\n    case NETSNMP_OID_OUTPUT_FULL:\n    case NETSNMP_OID_OUTPUT_NUMERIC:\n    case NETSNMP_OID_OUTPUT_SUFFIX:\n    case NETSNMP_OID_OUTPUT_MODULE:\n        cp = tbuf;\n        break;\n\n    case NETSNMP_OID_OUTPUT_NONE:\n    default:\n        cp = NULL;\n    }\n\n    if (!*buf_overflow &&\n        !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {\n        *buf_overflow = 1;\n    }\n    SNMP_FREE(tbuf);\n}\n\n/**\n * \n */\n#ifdef NETSNMP_DISABLE_MIB_LOADING\nvoid\nnetsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,\n                                  size_t * out_len, int allow_realloc,\n                                  int *buf_overflow,\n                                  const oid * objid, size_t objidlen)\n{\n    netsnmp_sprint_realloc_objid(buf, buf_len, out_len, allow_realloc,\n                                 buf_overflow, objid, objidlen);\n}\n#else\nstruct tree    *\nnetsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,\n                                  size_t * out_len, int allow_realloc,\n                                  int *buf_overflow,\n                                  const oid * objid, size_t objidlen)\n{\n    u_char         *tbuf = NULL, *cp = NULL;\n    size_t          tbuf_len = 512, tout_len = 0;\n    struct tree    *subtree = tree_head;\n    size_t          midpoint_offset = 0;\n    int             tbuf_overflow = 0;\n    int             output_format;\n\n    if ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {\n        tbuf_overflow = 1;\n    } else {\n        *tbuf = '.';\n        tout_len = 1;\n    }\n\n    subtree = _get_realloc_symbol(objid, objidlen, subtree,\n                                  &tbuf, &tbuf_len, &tout_len,\n                                  allow_realloc, &tbuf_overflow, NULL,\n                                  &midpoint_offset);\n\n    if (tbuf_overflow) {\n        if (!*buf_overflow) {\n            snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);\n            *buf_overflow = 1;\n        }\n        SNMP_FREE(tbuf);\n        return subtree;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_OID_OUTPUT_MODULE;\n    }\n    switch (output_format) {\n    case NETSNMP_OID_OUTPUT_FULL:\n    case NETSNMP_OID_OUTPUT_NUMERIC:\n        cp = tbuf;\n        break;\n\n    case NETSNMP_OID_OUTPUT_SUFFIX:\n    case NETSNMP_OID_OUTPUT_MODULE:\n        for (cp = tbuf; *cp; cp++);\n\n        if (midpoint_offset != 0) {\n            cp = tbuf + midpoint_offset - 2;    /*  beyond the '.'  */\n        } else {\n            while (cp >= tbuf) {\n                if (isalpha(*cp)) {\n                    break;\n                }\n                cp--;\n            }\n        }\n\n        while (cp >= tbuf) {\n            if (*cp == '.') {\n                break;\n            }\n            cp--;\n        }\n\n        cp++;\n\n        if ((NETSNMP_OID_OUTPUT_MODULE == output_format)\n            && cp > tbuf) {\n            char            modbuf[256] = { 0 }, *mod =\n                module_name(subtree->modid, modbuf);\n\n            /*\n             * Don't add the module ID if it's just numeric (i.e. we couldn't look\n             * it up properly.  \n             */\n\n            if (!*buf_overflow && modbuf[0] != '#') {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) mod)\n                    || !snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                                    (const u_char *) \"::\")) {\n                    *buf_overflow = 1;\n                }\n            }\n        }\n        break;\n\n    case NETSNMP_OID_OUTPUT_UCD:\n    {\n        PrefixListPtr   pp = &mib_prefixes[0];\n        size_t          ilen, tlen;\n        const char     *testcp;\n\n        cp = tbuf;\n        tlen = strlen((char *) tbuf);\n\n        while (pp->str) {\n            ilen = pp->len;\n            testcp = pp->str;\n\n            if ((tlen > ilen) && memcmp(tbuf, testcp, ilen) == 0) {\n                cp += (ilen + 1);\n                break;\n            }\n            pp++;\n        }\n        break;\n    }\n\n    case NETSNMP_OID_OUTPUT_NONE:\n    default:\n        cp = NULL;\n    }\n\n    if (!*buf_overflow &&\n        !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {\n        *buf_overflow = 1;\n    }\n    SNMP_FREE(tbuf);\n    return subtree;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nint\nsprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const oid * objid, size_t objidlen)\n{\n    int             buf_overflow = 0;\n\n    netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,\n                                      &buf_overflow, objid, objidlen);\n    return !buf_overflow;\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SPRINT_OBJID\nint\nsnprint_objid(char *buf, size_t buf_len,\n              const oid * objid, size_t objidlen)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_objid((u_char **) & buf, &buf_len, &out_len, 0,\n                             objid, objidlen)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SPRINT_OBJID */\n\n/**\n * Prints an oid to stdout.\n *\n * @param objid      The oid to print\n * @param objidlen   The length of oidid.\n */\nvoid\nprint_objid(const oid * objid, size_t objidlen)\n{                               /* number of subidentifiers */\n    fprint_objid(stdout, objid, objidlen);\n}\n\n\n/**\n * Prints an oid to a file descriptor.\n *\n * @param f          The file descriptor to print to.\n * @param objid      The oid to print\n * @param objidlen   The length of oidid.\n */\nvoid\nfprint_objid(FILE * f, const oid * objid, size_t objidlen)\n{                               /* number of subidentifiers */\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n    int             buf_overflow = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        netsnmp_sprint_realloc_objid_tree(&buf, &buf_len, &out_len, 1,\n                                          &buf_overflow, objid, objidlen);\n        if (buf_overflow) {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        } else {\n            fprintf(f, \"%s\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\nint\nsprint_realloc_variable(u_char ** buf, size_t * buf_len,\n                        size_t * out_len, int allow_realloc,\n                        const oid * objid, size_t objidlen,\n                        const netsnmp_variable_list * variable)\n{\n    int             buf_overflow = 0;\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *subtree = tree_head;\n\n    subtree =\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len,\n                                          allow_realloc, &buf_overflow,\n                                          objid, objidlen);\n\n    if (buf_overflow) {\n        return 0;\n    }\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE)) {\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" = \")) {\n                return 0;\n            }\n        } else {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) \" \")) {\n                    return 0;\n                }\n            } else {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) \" = \")) {\n                    return 0;\n                }\n            }                   /* end if-else NETSNMP_DS_LIB_QUICK_PRINT */\n        }                       /* end if-else NETSNMP_DS_LIB_QUICKE_PRINT */\n    } else {\n        *out_len = 0;\n    }\n\n    if (variable->type == SNMP_NOSUCHOBJECT) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Object available on this agent at this OID\");\n    } else if (variable->type == SNMP_NOSUCHINSTANCE) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Instance currently exists at this OID\");\n    } else if (variable->type == SNMP_ENDOFMIBVIEW) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No more variables left in this MIB View (It is past the end of the MIB tree)\");\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    } else if (subtree) {\n        const char *units = NULL;\n        const char *hint = NULL;\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                    NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {\n            units = subtree->units;\n        }\n\n\t\tif (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                    NETSNMP_DS_LIB_NO_DISPLAY_HINT)) {\n\t\t\thint = subtree->hint;\n        }\n\n        if (subtree->printomat) {\n            return (*subtree->printomat) (buf, buf_len, out_len,\n                                          allow_realloc, variable,\n                                          subtree->enums, hint,\n                                          units);\n        } else {\n            return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, variable,\n                                          subtree->enums, hint,\n                                          units);\n        }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    } else {\n        /*\n         * Handle rare case where tree is empty.  \n         */\n        return sprint_realloc_by_type(buf, buf_len, out_len, allow_realloc,\n                                      variable, NULL, NULL, NULL);\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNPRINT_VARABLE\nint\nsnprint_variable(char *buf, size_t buf_len,\n                 const oid * objid, size_t objidlen,\n                 const netsnmp_variable_list * variable)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_variable((u_char **) & buf, &buf_len, &out_len, 0,\n                                objid, objidlen, variable)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNPRINT_VARABLE */\n\n/**\n * Prints a variable to stdout.\n *\n * @param objid     The object id.\n * @param objidlen  The length of teh object id.\n * @param variable  The variable to print.\n */\nvoid\nprint_variable(const oid * objid,\n               size_t objidlen, const netsnmp_variable_list * variable)\n{\n    fprint_variable(stdout, objid, objidlen, variable);\n}\n\n\n/**\n * Prints a variable to a file descriptor.\n *\n * @param f         The file descriptor to print to.\n * @param objid     The object id.\n * @param objidlen  The length of teh object id.\n * @param variable  The variable to print.\n */\nvoid\nfprint_variable(FILE * f,\n                const oid * objid,\n                size_t objidlen, const netsnmp_variable_list * variable)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (sprint_realloc_variable(&buf, &buf_len, &out_len, 1,\n                                    objid, objidlen, variable)) {\n            fprintf(f, \"%s\\n\", buf);\n        } else {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\nint\nsprint_realloc_value(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const oid * objid, size_t objidlen,\n                     const netsnmp_variable_list * variable)\n{\n    if (variable->type == SNMP_NOSUCHOBJECT) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Object available on this agent at this OID\");\n    } else if (variable->type == SNMP_NOSUCHINSTANCE) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Instance currently exists at this OID\");\n    } else if (variable->type == SNMP_ENDOFMIBVIEW) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No more variables left in this MIB View (It is past the end of the MIB tree)\");\n    } else {\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        const char *units = NULL;\n        struct tree *subtree = tree_head;\n\tsubtree = get_tree(objid, objidlen, subtree);\n        if (subtree && !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                            NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {\n            units = subtree->units;\n        }\n        if (subtree) {\n\t    if(subtree->printomat) {\n\t\treturn (*subtree->printomat) (buf, buf_len, out_len,\n\t\t\t\t\t      allow_realloc, variable,\n\t\t\t\t\t      subtree->enums, subtree->hint,\n\t\t\t\t\t      units);\n\t    } else {\n\t\treturn sprint_realloc_by_type(buf, buf_len, out_len,\n\t\t\t\t\t      allow_realloc, variable,\n\t\t\t\t\t      subtree->enums, subtree->hint,\n\t\t\t\t\t      units);\n\t    }\n\t}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                      allow_realloc, variable,\n                                      NULL, NULL, NULL);\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNPRINT_VALUE\n/* used in the perl module */\nint\nsnprint_value(char *buf, size_t buf_len,\n              const oid * objid, size_t objidlen,\n              const netsnmp_variable_list * variable)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_value((u_char **) & buf, &buf_len, &out_len, 0,\n                             objid, objidlen, variable)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNPRINT_VALUE */\n\nvoid\nprint_value(const oid * objid,\n            size_t objidlen, const netsnmp_variable_list * variable)\n{\n    fprint_value(stdout, objid, objidlen, variable);\n}\n\nvoid\nfprint_value(FILE * f,\n             const oid * objid,\n             size_t objidlen, const netsnmp_variable_list * variable)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (sprint_realloc_value(&buf, &buf_len, &out_len, 1,\n                                 objid, objidlen, variable)) {\n            fprintf(f, \"%s\\n\", buf);\n        } else {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\n\n/**\n * Takes the value in VAR and turns it into an OID segment in var->name.\n *  \n * @param var    The variable.\n *\n * @return SNMPERR_SUCCESS or SNMPERR_GENERR \n */\nint\nbuild_oid_segment(netsnmp_variable_list * var)\n{\n    int             i;\n    uint32_t        ipaddr;\n\n    if (var->name && var->name != var->name_loc)\n        SNMP_FREE(var->name);\n    switch (var->type) {\n    case ASN_INTEGER:\n    case ASN_COUNTER:\n    case ASN_GAUGE:\n    case ASN_TIMETICKS:\n        var->name_length = 1;\n        var->name = var->name_loc;\n        var->name[0] = *(var->val.integer);\n        break;\n\n    case ASN_IPADDRESS:\n        var->name_length = 4;\n        var->name = var->name_loc;\n        memcpy(&ipaddr, var->val.string, sizeof(ipaddr));\n        var->name[0] = (ipaddr >> 24) & 0xff;\n        var->name[1] = (ipaddr >> 16) & 0xff;\n        var->name[2] = (ipaddr >>  8) & 0xff;\n        var->name[3] = (ipaddr >>  0) & 0xff;\n        break;\n        \n    case ASN_PRIV_IMPLIED_OBJECT_ID:\n        var->name_length = var->val_len / sizeof(oid);\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        for (i = 0; i < (int) var->name_length; i++)\n            var->name[i] = var->val.objid[i];\n        break;\n\n    case ASN_OBJECT_ID:\n        var->name_length = var->val_len / sizeof(oid) + 1;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        var->name[0] = var->name_length - 1;\n        for (i = 0; i < (int) var->name_length - 1; i++)\n            var->name[i + 1] = var->val.objid[i];\n        break;\n\n    case ASN_PRIV_IMPLIED_OCTET_STR:\n        var->name_length = var->val_len;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        for (i = 0; i < (int) var->val_len; i++)\n            var->name[i] = (oid) var->val.string[i];\n        break;\n\n    case ASN_OPAQUE:\n    case ASN_OCTET_STR:\n        var->name_length = var->val_len + 1;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        var->name[0] = (oid) var->val_len;\n        for (i = 0; i < (int) var->val_len; i++)\n            var->name[i + 1] = (oid) var->val.string[i];\n        break;\n\n    default:\n        DEBUGMSGTL((\"build_oid_segment\",\n                    \"invalid asn type: %d\\n\", var->type));\n        return SNMPERR_GENERR;\n    }\n\n    if (var->name_length > MAX_OID_LEN) {\n        DEBUGMSGTL((\"build_oid_segment\",\n                    \"Something terribly wrong, namelen = %lu\\n\",\n                    (unsigned long)var->name_length));\n        return SNMPERR_GENERR;\n    }\n\n    return SNMPERR_SUCCESS;\n}\n\n\nint\nbuild_oid_noalloc(oid * in, size_t in_len, size_t * out_len,\n                  oid * prefix, size_t prefix_len,\n                  netsnmp_variable_list * indexes)\n{\n    netsnmp_variable_list *var;\n\n    if (prefix) {\n        if (in_len < prefix_len)\n            return SNMPERR_GENERR;\n        memcpy(in, prefix, prefix_len * sizeof(oid));\n        *out_len = prefix_len;\n    } else {\n        *out_len = 0;\n    }\n\n    for (var = indexes; var != NULL; var = var->next_variable) {\n        if (build_oid_segment(var) != SNMPERR_SUCCESS)\n            return SNMPERR_GENERR;\n        if (var->name_length + *out_len <= in_len) {\n            memcpy(&(in[*out_len]), var->name,\n                   sizeof(oid) * var->name_length);\n            *out_len += var->name_length;\n        } else {\n            return SNMPERR_GENERR;\n        }\n    }\n\n    DEBUGMSGTL((\"build_oid_noalloc\", \"generated: \"));\n    DEBUGMSGOID((\"build_oid_noalloc\", in, *out_len));\n    DEBUGMSG((\"build_oid_noalloc\", \"\\n\"));\n    return SNMPERR_SUCCESS;\n}\n\nint\nbuild_oid(oid ** out, size_t * out_len,\n          oid * prefix, size_t prefix_len, netsnmp_variable_list * indexes)\n{\n    oid             tmpout[MAX_OID_LEN];\n\n    /*\n     * xxx-rks: inefficent. try only building segments to find index len:\n     *   for (var = indexes; var != NULL; var = var->next_variable) {\n     *      if (build_oid_segment(var) != SNMPERR_SUCCESS)\n     *         return SNMPERR_GENERR;\n     *      *out_len += var->name_length;\n     *\n     * then see if it fits in existing buffer, or realloc buffer.\n     */\n    if (build_oid_noalloc(tmpout, sizeof(tmpout), out_len,\n                          prefix, prefix_len, indexes) != SNMPERR_SUCCESS)\n        return SNMPERR_GENERR;\n\n    /** xxx-rks: should free previous value? */\n    snmp_clone_mem((void **) out, (void *) tmpout, *out_len * sizeof(oid));\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * vblist_out must contain a pre-allocated string of variables into\n * which indexes can be extracted based on the previously existing\n * types in the variable chain\n * returns:\n * SNMPERR_GENERR  on error\n * SNMPERR_SUCCESS on success\n */\n\nint\nparse_oid_indexes(oid * oidIndex, size_t oidLen,\n                  netsnmp_variable_list * data)\n{\n    netsnmp_variable_list *var = data;\n\n    while (var && oidLen > 0) {\n\n        if (parse_one_oid_index(&oidIndex, &oidLen, var, 0) !=\n            SNMPERR_SUCCESS)\n            break;\n\n        var = var->next_variable;\n    }\n\n    if (var != NULL || oidLen != 0)\n        return SNMPERR_GENERR;\n    return SNMPERR_SUCCESS;\n}\n\n\nint\nparse_one_oid_index(oid ** oidStart, size_t * oidLen,\n                    netsnmp_variable_list * data, int complete)\n{\n    netsnmp_variable_list *var = data;\n    oid             tmpout[MAX_OID_LEN];\n    unsigned int    i;\n    unsigned int    uitmp = 0;\n\n    oid            *oidIndex = *oidStart;\n\n    if (var == NULL || ((*oidLen == 0) && (complete == 0)))\n        return SNMPERR_GENERR;\n    else {\n        switch (var->type) {\n        case ASN_INTEGER:\n        case ASN_COUNTER:\n        case ASN_GAUGE:\n        case ASN_TIMETICKS:\n            if (*oidLen) {\n                snmp_set_var_value(var, (u_char *) oidIndex++,\n                                   sizeof(oid));\n                --(*oidLen);\n            } else {\n                snmp_set_var_value(var, (u_char *) oidLen, sizeof(long));\n            }\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed int(%d): %ld\\n\", var->type,\n                        *var->val.integer));\n            break;\n\n        case ASN_IPADDRESS:\n            if ((4 > *oidLen) && (complete == 0))\n                return SNMPERR_GENERR;\n            \n            for (i = 0; i < 4 && i < *oidLen; ++i) {\n                if (oidIndex[i] > 255) {\n                    DEBUGMSGTL((\"parse_oid_indexes\",\n                                \"illegal oid in index: %\" NETSNMP_PRIo \"d\\n\",\n                                oidIndex[0]));\n                        return SNMPERR_GENERR;  /* sub-identifier too large */\n                    }\n                    uitmp = uitmp + (oidIndex[i] << (8*(3-i)));\n                }\n            if (4 > (int) (*oidLen)) {\n                oidIndex += *oidLen;\n                (*oidLen) = 0;\n            } else {\n                oidIndex += 4;\n                (*oidLen) -= 4;\n            }\n            uitmp = htonl(uitmp); /* put it in proper order for byte copies */\n            uitmp = \n                snmp_set_var_value(var, (u_char *) &uitmp, 4);\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed ipaddr(%d): %d.%d.%d.%d\\n\", var->type,\n                        var->val.string[0], var->val.string[1],\n                        var->val.string[2], var->val.string[3]));\n            break;\n\n        case ASN_OBJECT_ID:\n        case ASN_PRIV_IMPLIED_OBJECT_ID:\n            if (var->type == ASN_PRIV_IMPLIED_OBJECT_ID) {\n                /*\n                 * might not be implied, might be fixed len. check if\n                 * caller set up val len, and use it if they did.\n                 */\n                if (0 == var->val_len)\n                    uitmp = *oidLen;\n                else {\n                    DEBUGMSGTL((\"parse_oid_indexes:fix\", \"fixed len oid\\n\"));\n                    uitmp = var->val_len;\n                }\n            } else {\n                if (*oidLen) {\n                    uitmp = *oidIndex++;\n                    --(*oidLen);\n                } else {\n                    uitmp = 0;\n                }\n                if ((uitmp > *oidLen) && (complete == 0))\n                    return SNMPERR_GENERR;\n            }\n\n            if (uitmp > MAX_OID_LEN)\n                return SNMPERR_GENERR;  /* too big and illegal */\n\n            if (uitmp > *oidLen) {\n                memcpy(tmpout, oidIndex, sizeof(oid) * (*oidLen));\n                memset(&tmpout[*oidLen], 0x00,\n                       sizeof(oid) * (uitmp - *oidLen));\n                snmp_set_var_value(var, (u_char *) tmpout,\n                                   sizeof(oid) * uitmp);\n                oidIndex += *oidLen;\n                (*oidLen) = 0;\n            } else {\n                snmp_set_var_value(var, (u_char *) oidIndex,\n                                   sizeof(oid) * uitmp);\n                oidIndex += uitmp;\n                (*oidLen) -= uitmp;\n            }\n\n            DEBUGMSGTL((\"parse_oid_indexes\", \"Parsed oid: \"));\n            DEBUGMSGOID((\"parse_oid_indexes\",\n                         var->val.objid, var->val_len / sizeof(oid)));\n            DEBUGMSG((\"parse_oid_indexes\", \"\\n\"));\n            break;\n\n        case ASN_OPAQUE:\n        case ASN_OCTET_STR:\n        case ASN_PRIV_IMPLIED_OCTET_STR:\n            if (var->type == ASN_PRIV_IMPLIED_OCTET_STR) {\n                /*\n                 * might not be implied, might be fixed len. check if\n                 * caller set up val len, and use it if they did.\n                 */\n                if (0 == var->val_len)\n                    uitmp = *oidLen;\n                else {\n                    DEBUGMSGTL((\"parse_oid_indexes:fix\", \"fixed len str\\n\"));\n                    uitmp = var->val_len;\n                }\n            } else {\n                if (*oidLen) {\n                    uitmp = *oidIndex++;\n                    --(*oidLen);\n                } else {\n                    uitmp = 0;\n                }\n                if ((uitmp > *oidLen) && (complete == 0))\n                    return SNMPERR_GENERR;\n            }\n\n            /*\n             * we handle this one ourselves since we don't have\n             * pre-allocated memory to copy from using\n             * snmp_set_var_value() \n             */\n\n            if (uitmp == 0)\n                break;          /* zero length strings shouldn't malloc */\n\n            if (uitmp > MAX_OID_LEN)\n                return SNMPERR_GENERR;  /* too big and illegal */\n\n            /*\n             * malloc by size+1 to allow a null to be appended. \n             */\n            var->val_len = uitmp;\n            var->val.string = (u_char *) calloc(1, uitmp + 1);\n            if (var->val.string == NULL)\n                return SNMPERR_GENERR;\n\n            if ((size_t)uitmp > (*oidLen)) {\n                for (i = 0; i < *oidLen; ++i)\n                    var->val.string[i] = (u_char) * oidIndex++;\n                for (i = *oidLen; i < uitmp; ++i)\n                    var->val.string[i] = '\\0';\n                (*oidLen) = 0;\n            } else {\n                for (i = 0; i < uitmp; ++i)\n                    var->val.string[i] = (u_char) * oidIndex++;\n                (*oidLen) -= uitmp;\n            }\n            var->val.string[uitmp] = '\\0';\n\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed str(%d): %s\\n\", var->type,\n                        var->val.string));\n            break;\n\n        default:\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"invalid asn type: %d\\n\", var->type));\n            return SNMPERR_GENERR;\n        }\n    }\n    (*oidStart) = oidIndex;\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * dump_realloc_oid_to_inetaddress:\n *   return 0 for failure,\n *   return 1 for success,\n *   return 2 for not handled\n */\n\nint \ndump_realloc_oid_to_inetaddress(const int addr_type, const oid * objid, size_t objidlen, \n                                u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc, \n                                char quotechar)\n{\n    int             i, len;\n    char            intbuf[64], *p;\n    char *const     end = intbuf + sizeof(intbuf);\n    unsigned char  *zc;\n    unsigned long   zone;\n\n    if (!buf)\n        return 1;\n\n    for (i = 0; i < objidlen; i++)\n        if (objid[i] < 0 || objid[i] > 255)\n            return 2;\n\n    p = intbuf;\n    *p++ = quotechar;\n\n    switch (addr_type) {\n    case IPV4:\n    case IPV4Z:\n        if ((addr_type == IPV4  && objidlen != 4) ||\n            (addr_type == IPV4Z && objidlen != 8))\n            return 2;\n\n        len = snprintf(p, end - p, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                      \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                      objid[0], objid[1], objid[2], objid[3]);\n        p += len;\n        if (p >= end)\n            return 2;\n        if (addr_type == IPV4Z) {\n            zc = (unsigned char*)&zone;\n            zc[0] = objid[4];\n            zc[1] = objid[5];\n            zc[2] = objid[6];\n            zc[3] = objid[7];\n            zone = ntohl(zone);\n            len = snprintf(p, end - p, \"%%%lu\", zone);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        break;\n\n    case IPV6:\n    case IPV6Z:\n        if ((addr_type == IPV6 && objidlen != 16) ||\n            (addr_type == IPV6Z && objidlen != 20))\n            return 2;\n\n        len = 0;\n        for (i = 0; i < 16; i ++) {\n            len = snprintf(p, end - p, \"%s%02\" NETSNMP_PRIo \"x\", i ? \":\" : \"\",\n                           objid[i]);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        if (addr_type == IPV6Z) {\n            zc = (unsigned char*)&zone;\n            zc[0] = objid[16];\n            zc[1] = objid[17];\n            zc[2] = objid[18];\n            zc[3] = objid[19];\n            zone = ntohl(zone);\n            len = snprintf(p, end - p, \"%%%lu\", zone);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        break;\n\n    case DNS:\n    default: \n        /* DNS can just be handled by dump_realloc_oid_to_string() */\n        return 2;\n    }\n\n    *p++ = quotechar;\n    if (p >= end)\n        return 2;\n\n    *p++ = '\\0';\n    if (p >= end)\n        return 2;\n\n    return snmp_cstrcat(buf, buf_len, out_len, allow_realloc, intbuf);\n}\n\nint\ndump_realloc_oid_to_string(const oid * objid, size_t objidlen,\n                           u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           char quotechar)\n{\n    if (buf) {\n        int             i, alen;\n\n        for (i = 0, alen = 0; i < (int) objidlen; i++) {\n            oid             tst = objid[i];\n            if ((tst > 254) || (!isprint(tst))) {\n                tst = (oid) '.';\n            }\n\n            if (alen == 0) {\n                if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                    while ((*out_len + 2) >= *buf_len) {\n                        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                            return 0;\n                        }\n                    }\n                    *(*buf + *out_len) = '\\\\';\n                    (*out_len)++;\n                }\n                while ((*out_len + 2) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = quotechar;\n                (*out_len)++;\n            }\n\n            while ((*out_len + 2) >= *buf_len) {\n                if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n            }\n            *(*buf + *out_len) = (char) tst;\n            (*out_len)++;\n            alen++;\n        }\n\n        if (alen) {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                while ((*out_len + 2) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = '\\\\';\n                (*out_len)++;\n            }\n            while ((*out_len + 2) >= *buf_len) {\n                if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n            }\n            *(*buf + *out_len) = quotechar;\n            (*out_len)++;\n        }\n\n        *(*buf + *out_len) = '\\0';\n    }\n\n    return 1;\n}\n\nvoid\n_oid_finish_printing(const oid * objid, size_t objidlen,\n                     u_char ** buf, size_t * buf_len, size_t * out_len,\n                     int allow_realloc, int *buf_overflow) {\n    char            intbuf[64];\n    if (*buf != NULL && *(*buf + *out_len - 1) != '.') {\n        if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           (const u_char *) \".\")) {\n            *buf_overflow = 1;\n        }\n    }\n\n    while (objidlen-- > 0) {    /* output rest of name, uninterpreted */\n        sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", *objid++);\n        if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           (const u_char *) intbuf)) {\n            *buf_overflow = 1;\n        }\n    }\n\n    if (*buf != NULL) {\n        *(*buf + *out_len - 1) = '\\0';  /* remove trailing dot */\n        *out_len = *out_len - 1;\n    }\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic void\n_get_realloc_symbol_octet_string(size_t numids, const oid * objid,\n\t\t\t\t u_char ** buf, size_t * buf_len,\n\t\t\t\t size_t * out_len, int allow_realloc,\n\t\t\t\t int *buf_overflow, struct tree* tp)\n{\n  netsnmp_variable_list\tvar = { 0 };\n  u_char\t\tbuffer[1024];\n  size_t\t\ti;\n\n  for (i = 0; i < numids; i++)\n    buffer[i] = (u_char) objid[i];\n  var.type = ASN_OCTET_STR;\n  var.val.string = buffer;\n  var.val_len = numids;\n  if (!*buf_overflow) {\n    if (!sprint_realloc_octet_string(buf, buf_len, out_len,\n\t\t\t\t     allow_realloc, &var,\n\t\t\t\t     NULL, tp->hint,\n\t\t\t\t     NULL)) {\n      *buf_overflow = 1;\n    }\n  }\n}\n\nstatic struct tree *\n_get_realloc_symbol(const oid * objid, size_t objidlen,\n                    struct tree *subtree,\n                    u_char ** buf, size_t * buf_len, size_t * out_len,\n                    int allow_realloc, int *buf_overflow,\n                    struct index_list *in_dices, size_t * end_of_known)\n{\n    struct tree    *return_tree = NULL;\n    int             extended_index =\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n    int             output_format =\n        netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    char            intbuf[64];\n    struct tree    *orgtree = subtree;\n\n    if (!objid || !buf) {\n        return NULL;\n    }\n\n    for (; subtree; subtree = subtree->next_peer) {\n        if (*objid == subtree->subid) {\n\t    while (subtree->next_peer && subtree->next_peer->subid == *objid)\n\t\tsubtree = subtree->next_peer;\n            if (subtree->indexes) {\n                in_dices = subtree->indexes;\n            } else if (subtree->augments) {\n                struct tree    *tp2 =\n                    find_tree_node(subtree->augments, -1);\n                if (tp2) {\n                    in_dices = tp2->indexes;\n                }\n            }\n\n            if (!strncmp(subtree->label, ANON, ANON_LEN) ||\n                (NETSNMP_OID_OUTPUT_NUMERIC == output_format)) {\n                sprintf(intbuf, \"%lu\", subtree->subid);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n            } else {\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   subtree->label)) {\n                    *buf_overflow = 1;\n                }\n            }\n\n            if (objidlen > 1) {\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *) \".\")) {\n                    *buf_overflow = 1;\n                }\n\n                return_tree = _get_realloc_symbol(objid + 1, objidlen - 1,\n                                                  subtree->child_list,\n                                                  buf, buf_len, out_len,\n                                                  allow_realloc,\n                                                  buf_overflow, in_dices,\n                                                  end_of_known);\n            }\n\n            if (return_tree != NULL) {\n                return return_tree;\n            } else {\n                return subtree;\n            }\n        }\n    }\n\n    if (end_of_known) {\n        *end_of_known = *out_len;\n    }\n\n    /*\n     * Subtree not found.  \n     */\n\n    if (orgtree && in_dices && objidlen > 0) {\n\tsprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", *objid);\n\tif (!*buf_overflow\n\t    && !snmp_strcat(buf, buf_len, out_len,\n\t\t\t    allow_realloc,\n\t\t\t    (const u_char *) intbuf)) {\n\t    *buf_overflow = 1;\n\t}\n\tobjid++;\n\tobjidlen--;\n    }\n\n    while (in_dices && (objidlen > 0) &&\n           (NETSNMP_OID_OUTPUT_NUMERIC != output_format) &&\n           !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS)) {\n        size_t          numids;\n        struct tree    *tp;\n\n        tp = find_tree_node(in_dices->ilabel, -1);\n\n        if (!tp) {\n            /*\n             * Can't find an index in the mib tree.  Bail.  \n             */\n            goto finish_it;\n        }\n\n        if (extended_index) {\n            if (*buf != NULL && *(*buf + *out_len - 1) == '.') {\n                (*out_len)--;\n            }\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \"[\")) {\n                *buf_overflow = 1;\n            }\n        }\n\n        switch (tp->type) {\n        case TYPE_OCTETSTR:\n            if (extended_index && tp->hint) {\n                if (in_dices->isimplied) {\n                    numids = objidlen;\n                    if (numids > objidlen)\n                        goto finish_it;\n                } else if (tp->ranges && !tp->ranges->next\n                           && tp->ranges->low == tp->ranges->high) {\n                    numids = tp->ranges->low;\n                    if (numids > objidlen)\n                        goto finish_it;\n                } else {\n                    numids = *objid;\n                    if (numids >= objidlen)\n                        goto finish_it;\n                    objid++;\n                    objidlen--;\n                }\n                if (numids > objidlen)\n                    goto finish_it;\n\t\t_get_realloc_symbol_octet_string(numids, objid, buf, buf_len,\n\t\t\t\t\t\t out_len, allow_realloc,\n\t\t\t\t\t\t buf_overflow, tp);\n            } else if (in_dices->isimplied) {\n                numids = objidlen;\n                if (numids > objidlen)\n                    goto finish_it;\n\n                if (!*buf_overflow) {\n                    if (!dump_realloc_oid_to_string\n                        (objid, numids, buf, buf_len, out_len,\n                         allow_realloc, '\\'')) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else if (tp->ranges && !tp->ranges->next\n                       && tp->ranges->low == tp->ranges->high) {\n                /*\n                 * a fixed-length octet string \n                 */\n                numids = tp->ranges->low;\n                if (numids > objidlen)\n                    goto finish_it;\n\n                if (!*buf_overflow) {\n                    if (!dump_realloc_oid_to_string\n                        (objid, numids, buf, buf_len, out_len,\n                         allow_realloc, '\\'')) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                numids = (size_t) * objid + 1;\n                if (numids > objidlen)\n                    goto finish_it;\n                if (numids == 1) {\n                    if (netsnmp_ds_get_boolean\n                        (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                        if (!*buf_overflow\n                            && !snmp_strcat(buf, buf_len, out_len,\n                                            allow_realloc,\n                                            (const u_char *) \"\\\\\")) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) \"\\\"\")) {\n                        *buf_overflow = 1;\n                    }\n                    if (netsnmp_ds_get_boolean\n                        (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                        if (!*buf_overflow\n                            && !snmp_strcat(buf, buf_len, out_len,\n                                            allow_realloc,\n                                            (const u_char *) \"\\\\\")) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) \"\\\"\")) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    if (!*buf_overflow) {\n                        struct tree * next_peer;\n                        int normal_handling = 1;\n\n                        if (tp->next_peer) {\n                            next_peer = tp->next_peer;\n                        }\n\n                        /* Try handling the InetAddress in the OID, in case of failure,\n                         * use the normal_handling. \n                         */\n                        if (tp->next_peer &&\n                            tp->tc_index != -1 &&\n                            next_peer->tc_index != -1 &&\n                            strcmp(get_tc_descriptor(tp->tc_index), \"InetAddress\") == 0 &&\n                            strcmp(get_tc_descriptor(next_peer->tc_index), \n                                    \"InetAddressType\") == 0 ) {\n\n                            int ret;\n                            int addr_type = *(objid - 1);\n\n                            ret = dump_realloc_oid_to_inetaddress(addr_type, \n                                        objid + 1, numids - 1, buf, buf_len, out_len,\n                                        allow_realloc, '\"');\n                            if (ret != 2) {\n                                normal_handling = 0;\n                                if (ret == 0) {\n                                    *buf_overflow = 1;\n                                }\n\n                            }\n                        } \n                        if (normal_handling && !dump_realloc_oid_to_string\n                            (objid + 1, numids - 1, buf, buf_len, out_len,\n                             allow_realloc, '\"')) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                }\n            }\n            objid += numids;\n            objidlen -= numids;\n            break;\n\n        case TYPE_INTEGER32:\n        case TYPE_UINTEGER:\n        case TYPE_UNSIGNED32:\n        case TYPE_GAUGE:\n        case TYPE_INTEGER:\n            if (tp->enums) {\n                struct enum_list *ep = tp->enums;\n                while (ep && ep->value != (int) (*objid)) {\n                    ep = ep->next;\n                }\n                if (ep) {\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) ep->label)) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) intbuf)) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n            }\n            objid++;\n            objidlen--;\n            break;\n\n        case TYPE_TIMETICKS:\n            /* In an index, this is probably a timefilter */\n            if (extended_index) {\n                uptimeString( *objid, intbuf, sizeof( intbuf ) );\n            } else {\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n            }   \n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *)\n                                               intbuf)) {\n                *buf_overflow = 1;\n            }\n            objid++;\n            objidlen--;\n            break;\n\n        case TYPE_OBJID:\n            if (in_dices->isimplied) {\n                numids = objidlen;\n            } else {\n                numids = (size_t) * objid + 1;\n            }\n            if (numids > objidlen)\n                goto finish_it;\n            if (extended_index) {\n                if (in_dices->isimplied) {\n                    if (!*buf_overflow\n                        && !netsnmp_sprint_realloc_objid_tree(buf, buf_len,\n                                                              out_len,\n                                                              allow_realloc,\n                                                              buf_overflow,\n                                                              objid,\n                                                              numids)) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    if (!*buf_overflow\n                        && !netsnmp_sprint_realloc_objid_tree(buf, buf_len,\n                                                              out_len,\n                                                              allow_realloc,\n                                                              buf_overflow,\n                                                              objid + 1,\n                                                              numids -\n                                                              1)) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                _get_realloc_symbol(objid, numids, NULL, buf, buf_len,\n                                    out_len, allow_realloc, buf_overflow,\n                                    NULL, NULL);\n            }\n            objid += (numids);\n            objidlen -= (numids);\n            break;\n\n        case TYPE_IPADDR:\n            if (objidlen < 4)\n                goto finish_it;\n            sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                    \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                    objid[0], objid[1], objid[2], objid[3]);\n            objid += 4;\n            objidlen -= 4;\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) intbuf)) {\n                *buf_overflow = 1;\n            }\n            break;\n\n        case TYPE_NETADDR:{\n                oid             ntype = *objid++;\n\n                objidlen--;\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", ntype);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n\n                if (ntype == 1 && objidlen >= 4) {\n                    sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                            \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                            objid[0], objid[1], objid[2], objid[3]);\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) intbuf)) {\n                        *buf_overflow = 1;\n                    }\n                    objid += 4;\n                    objidlen -= 4;\n                } else {\n                    goto finish_it;\n                }\n            }\n            break;\n\n        case TYPE_NSAPADDRESS:\n        default:\n            goto finish_it;\n            break;\n        }\n\n        if (extended_index) {\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \"]\")) {\n                *buf_overflow = 1;\n            }\n        } else {\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \".\")) {\n                *buf_overflow = 1;\n            }\n        }\n        in_dices = in_dices->next;\n    }\n\n  finish_it:\n    _oid_finish_printing(objid, objidlen,\n                         buf, buf_len, out_len,\n                         allow_realloc, buf_overflow);\n    return NULL;\n}\n\nstruct tree    *\nget_tree(const oid * objid, size_t objidlen, struct tree *subtree)\n{\n    struct tree    *return_tree = NULL;\n\n    for (; subtree; subtree = subtree->next_peer) {\n        if (*objid == subtree->subid)\n            goto found;\n    }\n\n    return NULL;\n\n  found:\n    while (subtree->next_peer && subtree->next_peer->subid == *objid)\n\tsubtree = subtree->next_peer;\n    if (objidlen > 1)\n        return_tree =\n            get_tree(objid + 1, objidlen - 1, subtree->child_list);\n    if (return_tree != NULL)\n        return return_tree;\n    else\n        return subtree;\n}\n\n/**\n * Prints on oid description on stdout.\n *\n * @see fprint_description\n */\nvoid\nprint_description(oid * objid, size_t objidlen, /* number of subidentifiers */\n                  int width)\n{\n    fprint_description(stdout, objid, objidlen, width);\n}\n\n\n/**\n * Prints on oid description into a file descriptor.\n * \n * @param f         The file descriptor to print to.\n * @param objid     The object identifier.\n * @param objidlen  The object id length.\n * @param width     Number of subidentifiers.\n */\nvoid\nfprint_description(FILE * f, oid * objid, size_t objidlen,\n                   int width)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (!sprint_realloc_description(&buf, &buf_len, &out_len, 1,\n                                   objid, objidlen, width)) {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        } else {\n            fprintf(f, \"%s\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_SNPRINT_DESCRIPTION\nint\nsnprint_description(char *buf, size_t buf_len,\n                    oid * objid, size_t objidlen, int width)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_description((u_char **) & buf, &buf_len, &out_len, 0,\n                                    objid, objidlen, width)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_SNPRINT_DESCRIPTION */\n\nint\nsprint_realloc_description(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     oid * objid, size_t objidlen, int width)\n{\n    struct tree    *tp = get_tree(objid, objidlen, tree_head);\n    struct tree    *subtree = tree_head;\n    int             pos, len;\n    char            tmpbuf[128];\n    const char     *cp;\n\n    if (NULL == tp)\n        return 0;\n\n    if (tp->type <= TYPE_SIMPLE_LAST)\n        cp = \" OBJECT-TYPE\";\n    else\n        switch (tp->type) {\n        case TYPE_TRAPTYPE:\n            cp = \" TRAP-TYPE\";\n            break;\n        case TYPE_NOTIFTYPE:\n            cp = \" NOTIFICATION-TYPE\";\n            break;\n        case TYPE_OBJGROUP:\n            cp = \" OBJECT-GROUP\";\n            break;\n        case TYPE_AGENTCAP:\n            cp = \" AGENT-CAPABILITIES\";\n            break;\n        case TYPE_MODID:\n            cp = \" MODULE-IDENTITY\";\n            break;\n        case TYPE_OBJIDENTITY:\n            cp = \" OBJECT-IDENTITY\";\n            break;\n        case TYPE_MODCOMP:\n            cp = \" MODULE-COMPLIANCE\";\n            break;\n        default:\n            sprintf(tmpbuf, \" type_%d\", tp->type);\n            cp = tmpbuf;\n        }\n\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->label) ||\n        !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n        !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\")) {\n        return 0;\n    }\n    if (!print_tree_node(buf, buf_len, out_len, allow_realloc, tp, width))\n        return 0;\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"::= {\"))\n        return 0;\n    pos = 5;\n    while (objidlen > 1) {\n        for (; subtree; subtree = subtree->next_peer) {\n            if (*objid == subtree->subid) {\n                while (subtree->next_peer && subtree->next_peer->subid == *objid)\n                    subtree = subtree->next_peer;\n                if (strncmp(subtree->label, ANON, ANON_LEN)) {\n                    snprintf(tmpbuf, sizeof(tmpbuf), \" %s(%lu)\", subtree->label, subtree->subid);\n                    tmpbuf[ sizeof(tmpbuf)-1 ] = 0;\n                } else\n                    sprintf(tmpbuf, \" %lu\", subtree->subid);\n                len = strlen(tmpbuf);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len,\n                                     allow_realloc, \"\\n     \"))\n                        return 0;\n                    pos = 5;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n                    return 0;\n                pos += len;\n                objid++;\n                objidlen--;\n                break;\n            }\n        }\n        if (subtree)\n            subtree = subtree->child_list;\n        else\n            break;\n    }\n    while (objidlen > 1) {\n        sprintf(tmpbuf, \" %\" NETSNMP_PRIo \"u\", *objid);\n        len = strlen(tmpbuf);\n        if (pos + len + 2 > width) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n     \"))\n                return 0;\n            pos = 5;\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n            return 0;\n        pos += len;\n        objid++;\n        objidlen--;\n    }\n    sprintf(tmpbuf, \" %\" NETSNMP_PRIo \"u }\", *objid);\n    len = strlen(tmpbuf);\n    if (pos + len + 2 > width) {\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n     \"))\n            return 0;\n        pos = 5;\n    }\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n        return 0;\n    return 1;\n}\n\nstatic int\nprint_tree_node(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     struct tree *tp, int width)\n{\n    const char     *cp;\n    char            str[MAXTOKEN];\n    int             i, prevmod, pos, len;\n\n    if (tp) {\n        module_name(tp->modid, str);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"  -- FROM\\t\") ||\n            !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n            return 0;\n        pos = 16+strlen(str);\n        for (i = 1, prevmod = tp->modid; i < tp->number_modules; i++) {\n            if (prevmod != tp->module_list[i]) {\n                module_name(tp->module_list[i], str);\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                     \",\\n  --\\t\\t\"))\n                        return 0;\n                    pos = 16;\n                }\n                else {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                    pos += 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len;\n            }\n            prevmod = tp->module_list[i];\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n            return 0;\n        if (tp->tc_index != -1) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  -- TEXTUAL CONVENTION \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              get_tc_descriptor(tp->tc_index)) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        }\n        switch (tp->type) {\n        case TYPE_OBJID:\n            cp = \"OBJECT IDENTIFIER\";\n            break;\n        case TYPE_OCTETSTR:\n            cp = \"OCTET STRING\";\n            break;\n        case TYPE_INTEGER:\n            cp = \"INTEGER\";\n            break;\n        case TYPE_NETADDR:\n            cp = \"NetworkAddress\";\n            break;\n        case TYPE_IPADDR:\n            cp = \"IpAddress\";\n            break;\n        case TYPE_COUNTER:\n            cp = \"Counter32\";\n            break;\n        case TYPE_GAUGE:\n            cp = \"Gauge32\";\n            break;\n        case TYPE_TIMETICKS:\n            cp = \"TimeTicks\";\n            break;\n        case TYPE_OPAQUE:\n            cp = \"Opaque\";\n            break;\n        case TYPE_NULL:\n            cp = \"NULL\";\n            break;\n        case TYPE_COUNTER64:\n            cp = \"Counter64\";\n            break;\n        case TYPE_BITSTRING:\n            cp = \"BITS\";\n            break;\n        case TYPE_NSAPADDRESS:\n            cp = \"NsapAddress\";\n            break;\n        case TYPE_UINTEGER:\n            cp = \"UInteger32\";\n            break;\n        case TYPE_UNSIGNED32:\n            cp = \"Unsigned32\";\n            break;\n        case TYPE_INTEGER32:\n            cp = \"Integer32\";\n            break;\n        default:\n            cp = NULL;\n            break;\n        }\n#if NETSNMP_ENABLE_TESTING_CODE\n        if (!cp && (tp->ranges || tp->enums)) { /* ranges without type ? */\n            sprintf(str, \"?0 with %s %s ?\",\n                    tp->ranges ? \"Range\" : \"\", tp->enums ? \"Enum\" : \"\");\n            cp = str;\n        }\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  SYNTAX\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp))\n                return 0;\n        if (tp->ranges) {\n            struct range_list *rp = tp->ranges;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" (\"))\n                return 0;\n            while (rp) {\n                switch (tp->type) {\n                case TYPE_INTEGER:\n                case TYPE_INTEGER32:\n                    if (rp->low == rp->high)\n                        sprintf(str, \"%s%d\", (first ? \"\" : \" | \"), rp->low );\n                    else\n                        sprintf(str, \"%s%d..%d\", (first ? \"\" : \" | \"),\n                                rp->low, rp->high);\n                    break;\n                case TYPE_UNSIGNED32:\n                case TYPE_OCTETSTR:\n                case TYPE_GAUGE:\n                case TYPE_UINTEGER:\n                    if (rp->low == rp->high)\n                        sprintf(str, \"%s%u\", (first ? \"\" : \" | \"),\n                                (unsigned)rp->low );\n                    else\n                        sprintf(str, \"%s%u..%u\", (first ? \"\" : \" | \"),\n                                (unsigned)rp->low, (unsigned)rp->high);\n                    break;\n                default:\n                    /* No other range types allowed */\n                    break;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                if (first)\n                    first = 0;\n                rp = rp->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \") \"))\n                return 0;\n        }\n        if (tp->enums) {\n            struct enum_list *ep = tp->enums;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" {\"))\n                return 0;\n            pos = 16 + strlen(cp) + 2;\n            while (ep) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                snprintf(str, sizeof(str), \"%s(%d)\", ep->label, ep->value);\n                str[ sizeof(str)-1 ] = 0;\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len,\n                                     allow_realloc, \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 18;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                ep = ep->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"} \"))\n                return 0;\n        }\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        if (tp->hint)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  DISPLAY-HINT\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->hint) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        if (tp->units)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  UNITS\\t\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->units) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        switch (tp->access) {\n        case MIB_ACCESS_READONLY:\n            cp = \"read-only\";\n            break;\n        case MIB_ACCESS_READWRITE:\n            cp = \"read-write\";\n            break;\n        case MIB_ACCESS_WRITEONLY:\n            cp = \"write-only\";\n            break;\n        case MIB_ACCESS_NOACCESS:\n            cp = \"not-accessible\";\n            break;\n        case MIB_ACCESS_NOTIFY:\n            cp = \"accessible-for-notify\";\n            break;\n        case MIB_ACCESS_CREATE:\n            cp = \"read-create\";\n            break;\n        case 0:\n            cp = NULL;\n            break;\n        default:\n            sprintf(str, \"access_%d\", tp->access);\n            cp = str;\n        }\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  MAX-ACCESS\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        switch (tp->status) {\n        case MIB_STATUS_MANDATORY:\n            cp = \"mandatory\";\n            break;\n        case MIB_STATUS_OPTIONAL:\n            cp = \"optional\";\n            break;\n        case MIB_STATUS_OBSOLETE:\n            cp = \"obsolete\";\n            break;\n        case MIB_STATUS_DEPRECATED:\n            cp = \"deprecated\";\n            break;\n        case MIB_STATUS_CURRENT:\n            cp = \"current\";\n            break;\n        case 0:\n            cp = NULL;\n            break;\n        default:\n            sprintf(str, \"status_%d\", tp->status);\n            cp = str;\n        }\n#if NETSNMP_ENABLE_TESTING_CODE\n        if (!cp && (tp->indexes)) {     /* index without status ? */\n            sprintf(str, \"?0 with %s ?\", tp->indexes ? \"Index\" : \"\");\n            cp = str;\n        }\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  STATUS\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        if (tp->augments)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  AUGMENTS\\t{ \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->augments) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        if (tp->indexes) {\n            struct index_list *ip = tp->indexes;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  INDEX\\t\\t{ \"))\n                return 0;\n            pos = 16 + 2;\n            while (ip) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                snprintf(str, sizeof(str), \"%s%s\",\n                        ip->isimplied ? \"IMPLIED \" : \"\",\n                        ip->ilabel);\n                str[ sizeof(str)-1 ] = 0;\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 16 + 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                ip = ip->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        }\n        if (tp->varbinds) {\n            struct varbind_list *vp = tp->varbinds;\n            int             first = 1;\n\n            if (tp->type == TYPE_TRAPTYPE) {\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                    \"  VARIABLES\\t{ \"))\n                    return 0;\n            } else {\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                    \"  OBJECTS\\t{ \"))\n                    return 0;\n            }\n            pos = 16 + 2;\n            while (vp) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                strlcpy(str, vp->vblabel, sizeof(str));\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                    \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 16 + 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                vp = vp->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        }\n        if (tp->description)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  DESCRIPTION\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->description) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        if (tp->defaultValue)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  DEFVAL\\t{ \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->defaultValue) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n    } else\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"No description\\n\"))\n            return 0;\n    return 1;\n}\n\nint\nget_module_node(const char *fname,\n                const char *module, oid * objid, size_t * objidlen)\n{\n    int             modid, rc = 0;\n    struct tree    *tp;\n    char           *name, *cp;\n\n    if (!strcmp(module, \"ANY\"))\n        modid = -1;\n    else {\n        netsnmp_read_module(module);\n        modid = which_module(module);\n        if (modid == -1)\n            return 0;\n    }\n\n    /*\n     * Isolate the first component of the name ... \n     */\n    name = strdup(fname);\n    cp = strchr(name, '.');\n    if (cp != NULL) {\n        *cp = '\\0';\n        cp++;\n    }\n    /*\n     * ... and locate it in the tree. \n     */\n    tp = find_tree_node(name, modid);\n    if (tp) {\n        size_t          maxlen = *objidlen;\n\n        /*\n         * Set the first element of the object ID \n         */\n        if (node_to_oid(tp, objid, objidlen)) {\n            rc = 1;\n\n            /*\n             * If the name requested was more than one element,\n             * tag on the rest of the components \n             */\n            if (cp != NULL)\n                rc = _add_strings_to_oid(tp, cp, objid, objidlen, maxlen);\n        }\n    }\n\n    SNMP_FREE(name);\n    return (rc);\n}\n\n\n/**\n * @internal\n *\n * Populates the object identifier from a node in the MIB hierarchy.\n * Builds up the object ID, working backwards,\n * starting from the end of the objid buffer.\n * When the top of the MIB tree is reached, the buffer is adjusted.\n *\n * The buffer length is set to the number of subidentifiers\n * for the object identifier associated with the MIB node.\n * \n * @return the number of subidentifiers copied.\n *\n * If 0 is returned, the objid buffer is too small,\n * and the buffer contents are indeterminate.\n * The buffer length can be used to create a larger buffer.\n */\nstatic int\nnode_to_oid(struct tree *tp, oid * objid, size_t * objidlen)\n{\n    int             numids, lenids;\n    oid            *op;\n\n    if (!tp || !objid || !objidlen)\n        return 0;\n\n    lenids = (int) *objidlen;\n    op = objid + lenids;        /* points after the last element */\n\n    for (numids = 0; tp; tp = tp->parent, numids++) {\n        if (numids >= lenids)\n            continue;\n        --op;\n        *op = tp->subid;\n    }\n\n    *objidlen = (size_t) numids;\n    if (numids > lenids) {\n        return 0;\n    }\n\n    if (numids < lenids)\n        memmove(objid, op, numids * sizeof(oid));\n\n    return (numids);\n}\n\n/*\n * Replace \\x with x stop at eos_marker\n * return NULL if eos_marker not found\n */\nstatic char *_apply_escapes(char *src, char eos_marker)\n{\n    char *dst;\n    int backslash = 0;\n    \n    dst = src;\n    while (*src) {\n\tif (backslash) {\n\t    backslash = 0;\n\t    *dst++ = *src;\n\t} else {\n\t    if (eos_marker == *src) break;\n\t    if ('\\\\' == *src) {\n\t\tbackslash = 1;\n\t    } else {\n\t\t*dst++ = *src;\n\t    }\n\t}\n\tsrc++;\n    }\n    if (!*src) {\n\t/* never found eos_marker */\n\treturn NULL;\n    } else {\n\t*dst = 0;\n\treturn src;\n    }\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nstatic int\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n_add_strings_to_oid(struct tree *tp, char *cp,\n                    oid * objid, size_t * objidlen, size_t maxlen)\n#else\n_add_strings_to_oid(void *tp, char *cp,\n                    oid * objid, size_t * objidlen, size_t maxlen)\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n{\n    oid             subid;\n    char           *fcp, *ecp, *cp2 = NULL;\n    char            doingquote;\n    int             len = -1;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *tp2 = NULL;\n    struct index_list *in_dices = NULL;\n    int             pos = -1;\n    int             check =\n        !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);\n    int             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);\n    int             len_index = 1000000;\n\n    while (cp && tp && tp->child_list) {\n        fcp = cp;\n        tp2 = tp->child_list;\n        /*\n         * Isolate the next entry \n         */\n        cp2 = strchr(cp, '.');\n        if (cp2)\n            *cp2++ = '\\0';\n\n        /*\n         * Search for the appropriate child \n         */\n        if (isdigit((unsigned char)(*cp))) {\n            subid = strtoul(cp, &ecp, 0);\n            if (*ecp)\n                goto bad_id;\n            while (tp2 && tp2->subid != subid)\n                tp2 = tp2->next_peer;\n        } else {\n            while (tp2 && strcmp(tp2->label, fcp))\n                tp2 = tp2->next_peer;\n            if (!tp2)\n                goto bad_id;\n            subid = tp2->subid;\n        }\n        if (*objidlen >= maxlen)\n            goto bad_id;\n\twhile (tp2 && tp2->next_peer && tp2->next_peer->subid == subid)\n\t    tp2 = tp2->next_peer;\n        objid[*objidlen] = subid;\n        (*objidlen)++;\n\n        cp = cp2;\n        if (!tp2)\n            break;\n        tp = tp2;\n    }\n\n    if (tp && !tp->child_list) {\n        if ((tp2 = tp->parent)) {\n            if (tp2->indexes)\n                in_dices = tp2->indexes;\n            else if (tp2->augments) {\n                tp2 = find_tree_node(tp2->augments, -1);\n                if (tp2)\n                    in_dices = tp2->indexes;\n            }\n        }\n        tp = NULL;\n    }\n\n    while (cp && in_dices) {\n        fcp = cp;\n\n        tp = find_tree_node(in_dices->ilabel, -1);\n        if (!tp)\n            break;\n        switch (tp->type) {\n        case TYPE_INTEGER:\n        case TYPE_INTEGER32:\n        case TYPE_UINTEGER:\n        case TYPE_UNSIGNED32:\n        case TYPE_TIMETICKS:\n            /*\n             * Isolate the next entry \n             */\n            cp2 = strchr(cp, '.');\n            if (cp2)\n                *cp2++ = '\\0';\n            if (isdigit((unsigned char)(*cp))) {\n                subid = strtoul(cp, &ecp, 0);\n                if (*ecp)\n                    goto bad_id;\n            } else {\n                if (tp->enums) {\n                    struct enum_list *ep = tp->enums;\n                    while (ep && strcmp(ep->label, cp))\n                        ep = ep->next;\n                    if (!ep)\n                        goto bad_id;\n                    subid = ep->value;\n                } else\n                    goto bad_id;\n            }\n            if (check && tp->ranges) {\n                struct range_list *rp = tp->ranges;\n                int             ok = 0;\n                if (tp->type == TYPE_INTEGER ||\n                    tp->type == TYPE_INTEGER32) {\n                  while (!ok && rp) {\n                    if ((rp->low <= (int) subid)\n                        && ((int) subid <= rp->high))\n                        ok = 1;\n                    else\n                        rp = rp->next;\n                  }\n                } else { /* check unsigned range */\n                  while (!ok && rp) {\n                    if (((unsigned int)rp->low <= subid)\n                        && (subid <= (unsigned int)rp->high))\n                        ok = 1;\n                    else\n                        rp = rp->next;\n                  }\n                }\n                if (!ok)\n                    goto bad_id;\n            }\n            if (*objidlen >= maxlen)\n                goto bad_id;\n            objid[*objidlen] = subid;\n            (*objidlen)++;\n            break;\n        case TYPE_IPADDR:\n            if (*objidlen + 4 > maxlen)\n                goto bad_id;\n            for (subid = 0; cp && subid < 4; subid++) {\n                fcp = cp;\n                cp2 = strchr(cp, '.');\n                if (cp2)\n                    *cp2++ = 0;\n                objid[*objidlen] = strtoul(cp, &ecp, 0);\n                if (*ecp)\n                    goto bad_id;\n                if (check && objid[*objidlen] > 255)\n                    goto bad_id;\n                (*objidlen)++;\n                cp = cp2;\n            }\n            break;\n        case TYPE_OCTETSTR:\n            if (tp->ranges && !tp->ranges->next\n                && tp->ranges->low == tp->ranges->high)\n                len = tp->ranges->low;\n            else\n                len = -1;\n            pos = 0;\n            if (*cp == '\"' || *cp == '\\'') {\n                doingquote = *cp++;\n                /*\n                 * insert length if requested \n                 */\n                if (!in_dices->isimplied && len == -1) {\n                    if (doingquote == '\\'') {\n                        snmp_set_detail\n                            (\"'-quote is for fixed length strings\");\n                        return 0;\n                    }\n                    if (*objidlen >= maxlen)\n                        goto bad_id;\n                    len_index = *objidlen;\n                    (*objidlen)++;\n                } else if (doingquote == '\"') {\n                    snmp_set_detail\n                        (\"\\\"-quote is for variable length strings\");\n                    return 0;\n                }\n\n\t\tcp2 = _apply_escapes(cp, doingquote);\n\t\tif (!cp2) goto bad_id;\n\t\telse {\n\t\t    unsigned char *new_val;\n\t\t    int new_val_len;\n\t\t    int parsed_hint = 0;\n\t\t    const char *parsed_value;\n\n\t\t    if (do_hint && tp->hint) {\n\t\t\tparsed_value = parse_octet_hint(tp->hint, cp,\n\t\t\t                                &new_val, &new_val_len);\n\t\t\tparsed_hint = parsed_value == NULL;\n\t\t    }\n\t\t    if (parsed_hint) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < new_val_len; i++) {\n\t\t\t    if (*objidlen >= maxlen) goto bad_id;\n\t\t\t    objid[ *objidlen ] = new_val[i];\n\t\t\t    (*objidlen)++;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\tSNMP_FREE(new_val);\n\t\t    } else {\n\t\t\twhile(*cp) {\n\t\t\t    if (*objidlen >= maxlen) goto bad_id;\n\t\t\t    objid[ *objidlen ] = *cp++;\n\t\t\t    (*objidlen)++;\n\t\t\t    pos++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\tcp2++;\n                if (!*cp2)\n                    cp2 = NULL;\n                else if (*cp2 != '.')\n                    goto bad_id;\n                else\n                    cp2++;\n\t\tif (check) {\n                    if (len == -1) {\n                        struct range_list *rp = tp->ranges;\n                        int             ok = 0;\n                        while (rp && !ok)\n                            if (rp->low <= pos && pos <= rp->high)\n                                ok = 1;\n                            else\n                                rp = rp->next;\n                        if (!ok)\n                            goto bad_id;\n                        if (!in_dices->isimplied)\n                            objid[len_index] = pos;\n                    } else if (pos != len)\n                        goto bad_id;\n\t\t}\n\t\telse if (len == -1 && !in_dices->isimplied)\n\t\t    objid[len_index] = pos;\n            } else {\n                if (!in_dices->isimplied && len == -1) {\n                    fcp = cp;\n                    cp2 = strchr(cp, '.');\n                    if (cp2)\n                        *cp2++ = 0;\n                    len = strtoul(cp, &ecp, 0);\n                    if (*ecp)\n                        goto bad_id;\n                    if (*objidlen + len + 1 >= maxlen)\n                        goto bad_id;\n                    objid[*objidlen] = len;\n                    (*objidlen)++;\n                    cp = cp2;\n                }\n                while (len && cp) {\n                    fcp = cp;\n                    cp2 = strchr(cp, '.');\n                    if (cp2)\n                        *cp2++ = 0;\n                    objid[*objidlen] = strtoul(cp, &ecp, 0);\n                    if (*ecp)\n                        goto bad_id;\n                    if (check && objid[*objidlen] > 255)\n                        goto bad_id;\n                    (*objidlen)++;\n                    len--;\n                    cp = cp2;\n                }\n            }\n            break;\n        case TYPE_OBJID:\n            in_dices = NULL;\n            cp2 = cp;\n            break;\n\tcase TYPE_NETADDR:\n\t    fcp = cp;\n\t    cp2 = strchr(cp, '.');\n\t    if (cp2)\n\t\t*cp2++ = 0;\n\t    subid = strtoul(cp, &ecp, 0);\n\t    if (*ecp)\n\t\tgoto bad_id;\n\t    if (*objidlen + 1 >= maxlen)\n\t\tgoto bad_id;\n\t    objid[*objidlen] = subid;\n\t    (*objidlen)++;\n\t    cp = cp2;\n\t    if (subid == 1) {\n\t\tfor (len = 0; cp && len < 4; len++) {\n\t\t    fcp = cp;\n\t\t    cp2 = strchr(cp, '.');\n\t\t    if (cp2)\n\t\t\t*cp2++ = 0;\n\t\t    subid = strtoul(cp, &ecp, 0);\n\t\t    if (*ecp)\n\t\t\tgoto bad_id;\n\t\t    if (*objidlen + 1 >= maxlen)\n\t\t\tgoto bad_id;\n\t\t    if (check && subid > 255)\n\t\t\tgoto bad_id;\n\t\t    objid[*objidlen] = subid;\n\t\t    (*objidlen)++;\n\t\t    cp = cp2;\n\t\t}\n\t    }\n\t    else {\n\t\tin_dices = NULL;\n\t    }\n\t    break;\n        default:\n            snmp_log(LOG_ERR, \"Unexpected index type: %d %s %s\\n\",\n                     tp->type, in_dices->ilabel, cp);\n            in_dices = NULL;\n            cp2 = cp;\n            break;\n        }\n        cp = cp2;\n        if (in_dices)\n            in_dices = in_dices->next;\n    }\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    while (cp) {\n        fcp = cp;\n        switch (*cp) {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            cp2 = strchr(cp, '.');\n            if (cp2)\n                *cp2++ = 0;\n            subid = strtoul(cp, &ecp, 0);\n            if (*ecp)\n                goto bad_id;\n            if (*objidlen >= maxlen)\n                goto bad_id;\n            objid[*objidlen] = subid;\n            (*objidlen)++;\n            break;\n        case '\"':\n        case '\\'':\n            doingquote = *cp++;\n            /*\n             * insert length if requested \n             */\n            if (doingquote == '\"') {\n                if (*objidlen >= maxlen)\n                    goto bad_id;\n                objid[*objidlen] = len = strchr(cp, doingquote) - cp;\n                (*objidlen)++;\n            }\n\n            while (*cp && *cp != doingquote) {\n                if (*objidlen >= maxlen)\n                    goto bad_id;\n                objid[*objidlen] = *cp++;\n                (*objidlen)++;\n            }\n            cp2 = cp + 1;\n            if (!*cp2)\n                cp2 = NULL;\n            else if (*cp2 == '.')\n                cp2++;\n            else\n                goto bad_id;\n            break;\n        default:\n            goto bad_id;\n        }\n        cp = cp2;\n    }\n    return 1;\n\n  bad_id:\n    {\n        char            buf[256];\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        if (in_dices)\n            snprintf(buf, sizeof(buf), \"Index out of range: %s (%s)\",\n                    fcp, in_dices->ilabel);\n        else if (tp)\n            snprintf(buf, sizeof(buf), \"Sub-id not found: %s -> %s\", tp->label, fcp);\n        else\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n            snprintf(buf, sizeof(buf), \"%s\", fcp);\n        buf[ sizeof(buf)-1 ] = 0;\n\n        snmp_set_detail(buf);\n    }\n    return 0;\n}\n\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/**\n * @see comments on find_best_tree_node for usage after first time.\n */\nint\nget_wild_node(const char *name, oid * objid, size_t * objidlen)\n{\n    struct tree    *tp = find_best_tree_node(name, tree_head, NULL);\n    if (!tp)\n        return 0;\n    return get_node(tp->label, objid, objidlen);\n}\n\nint\nget_node(const char *name, oid * objid, size_t * objidlen)\n{\n    const char     *cp;\n    char            ch;\n    int             res;\n\n    cp = name;\n    while ((ch = *cp))\n        if (('0' <= ch && ch <= '9')\n            || ('a' <= ch && ch <= 'z')\n            || ('A' <= ch && ch <= 'Z')\n            || ch == '-')\n            cp++;\n        else\n            break;\n    if (ch != ':')\n        if (*name == '.')\n            res = get_module_node(name + 1, \"ANY\", objid, objidlen);\n        else\n            res = get_module_node(name, \"ANY\", objid, objidlen);\n    else {\n        char           *module;\n        /*\n         *  requested name is of the form\n         *      \"module:subidentifier\"\n         */\n        module = (char *) malloc((size_t) (cp - name + 1));\n        if (!module)\n            return SNMPERR_GENERR;\n        sprintf(module, \"%.*s\", (int) (cp - name), name);\n        cp++;                   /* cp now point to the subidentifier */\n        if (*cp == ':')\n            cp++;\n\n        /*\n         * 'cp' and 'name' *do* go that way round! \n         */\n        res = get_module_node(cp, module, objid, objidlen);\n        SNMP_FREE(module);\n    }\n    if (res == 0) {\n        SET_SNMP_ERROR(SNMPERR_UNKNOWN_OBJID);\n    }\n\n    return res;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifdef testing\n\nmain(int argc, char *argv[])\n{\n    oid             objid[MAX_OID_LEN];\n    int             objidlen = MAX_OID_LEN;\n    int             count;\n    netsnmp_variable_list variable;\n\n    netsnmp_init_mib();\n    if (argc < 2)\n        print_subtree(stdout, tree_head, 0);\n    variable.type = ASN_INTEGER;\n    variable.val.integer = 3;\n    variable.val_len = 4;\n    for (argc--; argc; argc--, argv++) {\n        objidlen = MAX_OID_LEN;\n        printf(\"read_objid(%s) = %d\\n\",\n               argv[1], read_objid(argv[1], objid, &objidlen));\n        for (count = 0; count < objidlen; count++)\n            printf(\"%d.\", objid[count]);\n        printf(\"\\n\");\n        print_variable(objid, objidlen, &variable);\n    }\n}\n\n#endif                          /* testing */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * initialize: no peers included in the report. \n */\nvoid\nclear_tree_flags(register struct tree *tp)\n{\n    for (; tp; tp = tp->next_peer) {\n        tp->reported = 0;\n        if (tp->child_list)\n            clear_tree_flags(tp->child_list);\n     /*RECURSE*/}\n}\n\n/*\n * Update: 1998-07-17 <jhy@gsu.edu>\n * Added print_oid_report* functions.\n */\nstatic int      print_subtree_oid_report_labeledoid = 0;\nstatic int      print_subtree_oid_report_oid = 0;\nstatic int      print_subtree_oid_report_symbolic = 0;\nstatic int      print_subtree_oid_report_mibchildoid = 0;\nstatic int      print_subtree_oid_report_suffix = 0;\n\n/*\n * These methods recurse. \n */\nstatic void     print_parent_labeledoid(FILE *, struct tree *);\nstatic void     print_parent_oid(FILE *, struct tree *);\nstatic void     print_parent_mibchildoid(FILE *, struct tree *);\nstatic void     print_parent_label(FILE *, struct tree *);\nstatic void     print_subtree_oid_report(FILE *, struct tree *, int);\n\n\nvoid\nprint_oid_report(FILE * fp)\n{\n    struct tree    *tp;\n    clear_tree_flags(tree_head);\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        print_subtree_oid_report(fp, tp, 0);\n}\n\nvoid\nprint_oid_report_enable_labeledoid(void)\n{\n    print_subtree_oid_report_labeledoid = 1;\n}\n\nvoid\nprint_oid_report_enable_oid(void)\n{\n    print_subtree_oid_report_oid = 1;\n}\n\nvoid\nprint_oid_report_enable_suffix(void)\n{\n    print_subtree_oid_report_suffix = 1;\n}\n\nvoid\nprint_oid_report_enable_symbolic(void)\n{\n    print_subtree_oid_report_symbolic = 1;\n}\n\nvoid\nprint_oid_report_enable_mibchildoid(void)\n{\n    print_subtree_oid_report_mibchildoid = 1;\n}\n\n/*\n * helper methods for print_subtree_oid_report()\n * each one traverses back up the node tree\n * until there is no parent.  Then, the label combination\n * is output, such that the parent is displayed first.\n *\n * Warning: these methods are all recursive.\n */\n\nstatic void\nprint_parent_labeledoid(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_labeledoid(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%s(%lu)\", tp->label, tp->subid);\n    }\n}\n\nstatic void\nprint_parent_oid(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_oid(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%lu\", tp->subid);\n    }\n}\n\n\nstatic void print_parent_mibchildoid(FILE * f, struct tree *tp)\n{\n    static struct tree *temp;\n    unsigned long elems[100];\n    int elem_cnt = 0;\n    int i = 0;\n    temp = tp;\n    if (temp) {\n        while (temp->parent) {\n                elems[elem_cnt++] = temp->subid;\n                temp = temp->parent;\n        }\n        elems[elem_cnt++] = temp->subid;\n    }\n    for (i = elem_cnt - 1; i >= 0; i--) {\n        if (i == elem_cnt - 1) {\n            fprintf(f, \"%lu\", elems[i]);           \n            } else {\n            fprintf(f, \".%lu\", elems[i]);          \n        }\n    }\n}\n\nstatic void\nprint_parent_label(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_label(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%s\", tp->label);\n    }\n}\n\n/**\n * @internal\n * This methods generates variations on the original print_subtree() report.\n * Traverse the tree depth first, from least to greatest sub-identifier.\n * Warning: this methods recurses and calls methods that recurse.\n *\n * @param f       File descriptor to print to.\n * @param tree    ???\n * @param count   ???\n */\n\nstatic void\nprint_subtree_oid_report(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n\n    count++;\n\n    /*\n     * sanity check \n     */\n    if (!tree) {\n        return;\n    }\n\n    /*\n     * find the not reported peer with the lowest sub-identifier.\n     * if no more, break the loop and cleanup.\n     * set \"reported\" flag, and create report for this peer.\n     * recurse using the children of this peer, if any.\n     */\n    while (1) {\n        register struct tree *ntp;\n\n        tp = NULL;\n        for (ntp = tree->child_list; ntp; ntp = ntp->next_peer) {\n            if (ntp->reported)\n                continue;\n\n            if (!tp || (tp->subid > ntp->subid))\n                tp = ntp;\n        }\n        if (!tp)\n            break;\n\n        tp->reported = 1;\n\n        if (print_subtree_oid_report_labeledoid) {\n            print_parent_labeledoid(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_oid) {\n            print_parent_oid(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_symbolic) {\n            print_parent_label(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_mibchildoid) {\n\t    fprintf(f, \"\\\"%s\\\"\\t\", tp->label);\n            fprintf(f, \"\\t\\t\\\"\");\n            print_parent_mibchildoid(f, tp);\n            fprintf(f, \"\\\"\\n\");\n        }\n        if (print_subtree_oid_report_suffix) {\n            int             i;\n            for (i = 0; i < count; i++)\n                fprintf(f, \"  \");\n            fprintf(f, \"%s(%ld) type=%d\", tp->label, tp->subid, tp->type);\n            if (tp->tc_index != -1)\n                fprintf(f, \" tc=%d\", tp->tc_index);\n            if (tp->hint)\n                fprintf(f, \" hint=%s\", tp->hint);\n            if (tp->units)\n                fprintf(f, \" units=%s\", tp->units);\n\n            fprintf(f, \"\\n\");\n        }\n        print_subtree_oid_report(f, tp, count);\n     /*RECURSE*/}\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n\n/**\n * Converts timeticks to hours, minutes, seconds string.\n *\n * @param timeticks    The timeticks to convert.\n * @param buf          Buffer to write to, has to be at \n *                     least 40 Bytes large.\n *       \n * @return The buffer\n *\n * @see uptimeString\n */\nchar           *\nuptime_string(u_long timeticks, char *buf)\n{\n    return uptime_string_n( timeticks, buf, 40);\n}\n\nchar           *\nuptime_string_n(u_long timeticks, char *buf, size_t buflen)\n{\n    uptimeString(timeticks, buf, buflen);\n    return buf;\n}\n\n/**\n * Given a string, parses an oid out of it (if possible).\n * It will try to parse it based on predetermined configuration if\n * present or by every method possible otherwise.\n * If a suffix has been registered using NETSNMP_DS_LIB_OIDSUFFIX, it\n * will be appended to the input string before processing.\n *\n * @param argv    The OID to string parse\n * @param root    An OID array where the results are stored.\n * @param rootlen The max length of the array going in and the data\n *                length coming out.\n *\n * @return        The root oid pointer if successful, or NULL otherwise.\n */\n \noid            *\nsnmp_parse_oid(const char *argv, oid * root, size_t * rootlen)\n{\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    size_t          savlen = *rootlen;\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    static size_t   tmpbuf_len = 0;\n    static char    *tmpbuf = NULL;\n    const char     *suffix, *prefix;\n\n    suffix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n                                   NETSNMP_DS_LIB_OIDSUFFIX);\n    prefix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n                                   NETSNMP_DS_LIB_OIDPREFIX);\n    if ((suffix && suffix[0]) || (prefix && prefix[0])) {\n        if (!suffix)\n            suffix = \"\";\n        if (!prefix)\n            prefix = \"\";\n        if ((strlen(suffix) + strlen(prefix) + strlen(argv) + 2) > tmpbuf_len) {\n            tmpbuf_len = strlen(suffix) + strlen(argv) + strlen(prefix) + 2;\n            tmpbuf = malloc(tmpbuf_len);\n        }\n        snprintf(tmpbuf, tmpbuf_len, \"%s%s%s%s\", prefix, argv,\n                 ((suffix[0] == '.' || suffix[0] == '\\0') ? \"\" : \".\"),\n                 suffix);\n        argv = tmpbuf;\n        DEBUGMSGTL((\"snmp_parse_oid\",\"Parsing: %s\\n\",argv));\n    }\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS)\n        || strchr(argv, ':')) {\n        if (get_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS)) {\n\tclear_tree_flags(tree_head);\n        if (get_wild_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    } else {\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        if (read_objid(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        *rootlen = savlen;\n        if (get_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n        *rootlen = savlen;\n        DEBUGMSGTL((\"parse_oid\", \"wildly parsing\\n\"));\n\tclear_tree_flags(tree_head);\n        if (get_wild_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    free(tmpbuf);\n    return NULL;\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * Use DISPLAY-HINT to parse a value into an octet string.\n *\n * note that \"1d1d\", \"11\" could have come from an octet string that\n * looked like { 1, 1 } or an octet string that looked like { 11 }\n * because of this, it's doubtful that anyone would use such a display\n * string. Therefore, the parser ignores this case.\n */\n\nstruct parse_hints {\n    int length;\n    int repeat;\n    int format;\n    int separator;\n    int terminator;\n    unsigned char *result;\n    int result_max;\n    int result_len;\n};\n\nstatic void parse_hints_reset(struct parse_hints *ph)\n{\n    ph->length = 0;\n    ph->repeat = 0;\n    ph->format = 0;\n    ph->separator = 0;\n    ph->terminator = 0;\n}\n\nstatic void parse_hints_ctor(struct parse_hints *ph)\n{\n    parse_hints_reset(ph);\n    ph->result = NULL;\n    ph->result_max = 0;\n    ph->result_len = 0;\n}\n\nstatic int parse_hints_add_result_octet(struct parse_hints *ph, unsigned char octet)\n{\n    if (!(ph->result_len < ph->result_max)) {\n\tph->result_max = ph->result_len + 32;\n\tif (!ph->result) {\n\t    ph->result = (unsigned char *)malloc(ph->result_max);\n\t} else {\n\t    ph->result = (unsigned char *)realloc(ph->result, ph->result_max);\n\t}\n    }\n    \n    if (!ph->result) {\n\treturn 0;\t\t/* failed */\n    }\n\n    ph->result[ph->result_len++] = octet;\n    return 1;\t\t\t/* success */\n}\n\nstatic int parse_hints_parse(struct parse_hints *ph, const char **v_in_out)\n{\n    const char *v = *v_in_out;\n    char *nv;\n    int base;\n    int repeats = 0;\n    int repeat_fixup = ph->result_len;\n    \n    if (ph->repeat) {\n\tif (!parse_hints_add_result_octet(ph, 0)) {\n\t    return 0;\n\t}\n    }\n    do {\n\tbase = 0;\n\tswitch (ph->format) {\n\tcase 'x': base += 6;\t/* fall through */\n\tcase 'd': base += 2;\t/* fall through */\n\tcase 'o': base += 8;\t/* fall through */\n\t    {\n\t\tint i;\n\t\tunsigned long number = strtol(v, &nv, base);\n\t\tif (nv == v) return 0;\n\t\tv = nv;\n\t\tfor (i = 0; i < ph->length; i++) {\n\t\t    int shift = 8 * (ph->length - 1 - i);\n\t\t    if (!parse_hints_add_result_octet(ph, (u_char)(number >> shift) )) {\n\t\t\treturn 0; /* failed */\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase 'a':\n\t    {\n\t\tint i;\n\t\t    \n\t\tfor (i = 0; i < ph->length && *v; i++) {\n\t\t    if (!parse_hints_add_result_octet(ph, *v++)) {\n\t\t\treturn 0;\t/* failed */\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\trepeats++;\n\n\tif (ph->separator && *v) {\n\t    if (*v == ph->separator) {\n\t\tv++;\n\t    } else {\n\t\treturn 0;\t\t/* failed */\n\t    }\n\t}\n\n\tif (ph->terminator) {\n\t    if (*v == ph->terminator) {\n\t\tv++;\n\t\tbreak;\n\t    }\n\t}\n    } while (ph->repeat && *v);\n    if (ph->repeat) {\n\tph->result[repeat_fixup] = repeats;\n    }\n\n    *v_in_out = v;\n    return 1;\n}\n\nstatic void parse_hints_length_add_digit(struct parse_hints *ph, int digit)\n{\n    ph->length *= 10;\n    ph->length += digit - '0';\n}\n\nconst char *parse_octet_hint(const char *hint, const char *value, unsigned char **new_val, int *new_val_len)\n{\n    const char *h = hint;\n    const char *v = value;\n    struct parse_hints ph;\n    int retval = 1;\n    /* See RFC 1443 */\n    enum {\n\tHINT_1_2,\n\tHINT_2_3,\n\tHINT_1_2_4,\n\tHINT_1_2_5\n    } state = HINT_1_2;\n\n    parse_hints_ctor(&ph);\n    while (*h && *v && retval) {\n\tswitch (state) {\n\tcase HINT_1_2:\n\t    if ('*' == *h) {\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\treturn v;\t/* failed */\n\t    }\n\t    break;\n\n\tcase HINT_2_3:\n\t    if (isdigit((unsigned char)(*h))) {\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\t/* state = HINT_2_3 */\n\t    } else if ('x' == *h || 'd' == *h || 'o' == *h || 'a' == *h) {\n\t\tph.format = *h;\n\t\tstate = HINT_1_2_4;\n\t    } else {\n\t\treturn v;\t/* failed */\n\t    }\n\t    break;\n\n\tcase HINT_1_2_4:\n\t    if ('*' == *h) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\tph.separator = *h;\n\t\tstate = HINT_1_2_5;\n\t    }\n\t    break;\n\n\tcase HINT_1_2_5:\n\t    if ('*' == *h) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\tph.terminator = *h;\n\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\n\t\tstate = HINT_1_2;\n\t    }\n\t    break;\n\t}\n\th++;\n    }\n    while (*v && retval) {\n\tretval = parse_hints_parse(&ph, &v);\n    }\n    if (retval) {\n\t*new_val = ph.result;\n\t*new_val_len = ph.result_len;\n    } else {\n\tif (ph.result) {\n\t    SNMP_FREE(ph.result);\n\t}\n\t*new_val = NULL;\n\t*new_val_len = 0;\n    }\n    return retval ? NULL : v;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifdef test_display_hint\n\nint main(int argc, const char **argv)\n{\n    const char *hint;\n    const char *value;\n    unsigned char *new_val;\n    int new_val_len;\n    char *r;\n    \n    if (argc < 3) {\n\tfprintf(stderr, \"usage: dh <hint> <value>\\n\");\n\texit(2);\n    }\n    hint = argv[1];\n    value = argv[2];\n    r = parse_octet_hint(hint, value, &new_val, &new_val_len);\n    printf(\"{\\\"%s\\\", \\\"%s\\\"}: \\n\\t\", hint, value);\n    if (r) {\n        *r = 0;\n    \tprintf(\"returned failed\\n\");\n\tprintf(\"value syntax error at: %s\\n\", value);\n    }\n    else {\n\tint i;\n\tprintf(\"returned success\\n\");\n\tfor (i = 0; i < new_val_len; i++) {\n\t    int c = new_val[i] & 0xFF;\n\t    printf(\"%02X(%c) \", c, isprint(c) ? c : ' ');\n\t}\n\tSNMP_FREE(new_val);\n    }\n    printf(\"\\n\");\n    exit(0);\n}\n\n#endif /* test_display_hint */\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_TO_ASN_TYPE\nu_char\nmib_to_asn_type(int mib_type)\n{\n    switch (mib_type) {\n    case TYPE_OBJID:\n        return ASN_OBJECT_ID;\n\n    case TYPE_OCTETSTR:\n        return ASN_OCTET_STR;\n\n    case TYPE_NETADDR:\n    case TYPE_IPADDR:\n        return ASN_IPADDRESS;\n\n    case TYPE_INTEGER32:\n    case TYPE_INTEGER:\n        return ASN_INTEGER;\n\n    case TYPE_COUNTER:\n        return ASN_COUNTER;\n\n    case TYPE_GAUGE:\n        return ASN_GAUGE;\n\n    case TYPE_TIMETICKS:\n        return ASN_TIMETICKS;\n\n    case TYPE_OPAQUE:\n        return ASN_OPAQUE;\n\n    case TYPE_NULL:\n        return ASN_NULL;\n\n    case TYPE_COUNTER64:\n        return ASN_COUNTER64;\n\n    case TYPE_BITSTRING:\n        return ASN_BIT_STR;\n\n    case TYPE_UINTEGER:\n    case TYPE_UNSIGNED32:\n        return ASN_UNSIGNED;\n\n    case TYPE_NSAPADDRESS:\n        return ASN_NSAP;\n\n    }\n    return -1;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_TO_ASN_TYPE */\n\n/**\n * Converts a string to its OID form.\n * in example  \"hello\" = 5 . 'h' . 'e' . 'l' . 'l' . 'o'\n *\n * @param S   The string.\n * @param O   The oid.\n * @param L   The length of the oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_STRING_CONVERSIONS\nint\nnetsnmp_str2oid(const char *S, oid * O, int L)\n{\n    const char     *c = S;\n    oid            *o = &O[1];\n\n    --L;                        /* leave room for length prefix */\n\n    for (; *c && L; --L, ++o, ++c)\n        *o = *c;\n\n    /*\n     * make sure we got to the end of the string \n     */\n    if (*c != 0)\n        return 1;\n\n    /*\n     * set the length of the oid \n     */\n    *O = c - S;\n\n    return 0;\n}\n\n/**\n * Converts an OID to its character form.\n * in example  5 . 1 . 2 . 3 . 4 . 5 = 12345\n *\n * @param C   The character buffer.\n * @param L   The length of the buffer.\n * @param O   The oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\nint\nnetsnmp_oid2chars(char *C, int L, const oid * O)\n{\n    char           *c = C;\n    const oid      *o = &O[1];\n\n    if (L < (int)*O)\n        return 1;\n\n    L = *O; /** length */\n    for (; L; --L, ++o, ++c) {\n        if (*o > 0xFF)\n            return 1;\n        *c = (char)*o;\n    }\n    return 0;\n}\n\n/**\n * Converts an OID to its string form.\n * in example  5 . 'h' . 'e' . 'l' . 'l' . 'o' = \"hello\\0\" (null terminated)\n *\n * @param S   The character string buffer.\n * @param L   The length of the string buffer.\n * @param O   The oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\nint\nnetsnmp_oid2str(char *S, int L, oid * O)\n{\n    int            rc;\n\n    if (L <= (int)*O)\n        return 1;\n\n    rc = netsnmp_oid2chars(S, L, O);\n    if (rc)\n        return 1;\n\n    S[ *O ] = 0;\n\n    return 0;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_STRING_CONVERSIONS */\n\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_SNPRINT\nint\nsnprint_by_type(char *buf, size_t buf_len,\n                netsnmp_variable_list * var,\n                const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_by_type((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_hexstring(char *buf, size_t buf_len, const u_char * cp, size_t len)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_hexstring((u_char **) & buf, &buf_len, &out_len, 0,\n                                 cp, len))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_asciistring(char *buf, size_t buf_len,\n                    const u_char * cp, size_t len)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_asciistring\n        ((u_char **) & buf, &buf_len, &out_len, 0, cp, len))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_octet_string(char *buf, size_t buf_len,\n                     const netsnmp_variable_list * var, const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_octet_string\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_opaque(char *buf, size_t buf_len,\n               const netsnmp_variable_list * var, const struct enum_list *enums,\n               const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_opaque((u_char **) & buf, &buf_len, &out_len, 0,\n                              var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_object_identifier(char *buf, size_t buf_len,\n                          const netsnmp_variable_list * var,\n                          const struct enum_list *enums, const char *hint,\n                          const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_object_identifier\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_timeticks(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_timeticks((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_hinted_integer(char *buf, size_t buf_len,\n                       long val, const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_hinted_integer\n        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_integer(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_integer((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_uinteger(char *buf, size_t buf_len,\n                 const netsnmp_variable_list * var, const struct enum_list *enums,\n                 const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_uinteger((u_char **) & buf, &buf_len, &out_len, 0,\n                                var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_gauge(char *buf, size_t buf_len,\n              const netsnmp_variable_list * var, const struct enum_list *enums,\n              const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_gauge((u_char **) & buf, &buf_len, &out_len, 0,\n                             var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_counter(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_counter((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_networkaddress(char *buf, size_t buf_len,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums, const char *hint,\n                       const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_networkaddress\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_ipaddress(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_ipaddress((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_null(char *buf, size_t buf_len,\n             const netsnmp_variable_list * var, const struct enum_list *enums,\n             const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_null((u_char **) & buf, &buf_len, &out_len, 0,\n                            var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_bitstring(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_bitstring((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_nsapaddress(char *buf, size_t buf_len,\n                    const netsnmp_variable_list * var, const struct enum_list *enums,\n                    const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_nsapaddress\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_counter64(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_counter64((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_badtype(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_badtype((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\nint\nsnprint_float(char *buf, size_t buf_len,\n              const netsnmp_variable_list * var, const struct enum_list *enums,\n              const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_float((u_char **) & buf, &buf_len, &out_len, 0,\n                             var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_double(char *buf, size_t buf_len,\n               const netsnmp_variable_list * var, const struct enum_list *enums,\n               const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_double((u_char **) & buf, &buf_len, &out_len, 0,\n                              var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n#endif\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_SNPRINT */\n/** @} */\n\n", "/*\n * parse.c\n *\n */\n/* Portions of this file are subject to the following copyrights.  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/******************************************************************\n        Copyright 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n\n#if HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#include <stdio.h>\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#include <ctype.h>\n#include <sys/types.h>\n#if HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\n/*\n * Wow.  This is ugly.  -- Wes \n */\n#if HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# if HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# if HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# if HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)\n#include <regex.h>\n#endif\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <errno.h>\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/parse.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/tools.h>\n\nnetsnmp_feature_child_of(find_module, mib_api)\nnetsnmp_feature_child_of(get_tc_description, mib_api)\n\n/*\n * A linked list of nodes.\n */\nstruct node {\n    struct node    *next;\n    char           *label;  /* This node's (unique) textual name */\n    u_long          subid;  /* This node's integer subidentifier */\n    int             modid;  /* The module containing this node */\n    char           *parent; /* The parent's textual name */\n    int             tc_index; /* index into tclist (-1 if NA) */\n    int             type;   /* The type of object this represents */\n    int             access;\n    int             status;\n    struct enum_list *enums; /* (optional) list of enumerated integers */\n    struct range_list *ranges;\n    struct index_list *indexes;\n    char           *augments;\n    struct varbind_list *varbinds;\n    char           *hint;\n    char           *units;\n    char           *description; /* description (a quoted string) */\n    char           *reference; /* references (a quoted string) */\n    char           *defaultValue;\n    char           *filename;\n    int             lineno;\n};\n\n/*\n * This is one element of an object identifier with either an integer\n * subidentifier, or a textual string label, or both.\n * The subid is -1 if not present, and label is NULL if not present.\n */\nstruct subid_s {\n    int             subid;\n    int             modid;\n    char           *label;\n};\n\n#define MAXTC   16384\nstruct tc {                     /* textual conventions */\n    int             type;\n    int             modid;\n    char           *descriptor;\n    char           *hint;\n    struct enum_list *enums;\n    struct range_list *ranges;\n    char           *description;\n} tclist[MAXTC];\n\nint             mibLine = 0;\nconst char     *File = \"(none)\";\nstatic int      anonymous = 0;\n\nstruct objgroup {\n    char           *name;\n    int             line;\n    struct objgroup *next;\n}              *objgroups = NULL, *objects = NULL, *notifs = NULL;\n\n#define SYNTAX_MASK     0x80\n/*\n * types of tokens\n * Tokens wiht the SYNTAX_MASK bit set are syntax tokens \n */\n#define CONTINUE    -1\n#define ENDOFFILE   0\n#define LABEL       1\n#define SUBTREE     2\n#define SYNTAX      3\n#define OBJID       (4 | SYNTAX_MASK)\n#define OCTETSTR    (5 | SYNTAX_MASK)\n#define INTEGER     (6 | SYNTAX_MASK)\n#define NETADDR     (7 | SYNTAX_MASK)\n#define IPADDR      (8 | SYNTAX_MASK)\n#define COUNTER     (9 | SYNTAX_MASK)\n#define GAUGE       (10 | SYNTAX_MASK)\n#define TIMETICKS   (11 | SYNTAX_MASK)\n#define KW_OPAQUE   (12 | SYNTAX_MASK)\n#define NUL         (13 | SYNTAX_MASK)\n#define SEQUENCE    14\n#define OF          15          /* SEQUENCE OF */\n#define OBJTYPE     16\n#define ACCESS      17\n#define READONLY    18\n#define READWRITE   19\n#define WRITEONLY   20\n#ifdef NOACCESS\n#undef NOACCESS                 /* agent 'NOACCESS' token */\n#endif\n#define NOACCESS    21\n#define STATUS      22\n#define MANDATORY   23\n#define KW_OPTIONAL    24\n#define OBSOLETE    25\n/*\n * #define RECOMMENDED 26 \n */\n#define PUNCT       27\n#define EQUALS      28\n#define NUMBER      29\n#define LEFTBRACKET 30\n#define RIGHTBRACKET 31\n#define LEFTPAREN   32\n#define RIGHTPAREN  33\n#define COMMA       34\n#define DESCRIPTION 35\n#define QUOTESTRING 36\n#define INDEX       37\n#define DEFVAL      38\n#define DEPRECATED  39\n#define SIZE        40\n#define BITSTRING   (41 | SYNTAX_MASK)\n#define NSAPADDRESS (42 | SYNTAX_MASK)\n#define COUNTER64   (43 | SYNTAX_MASK)\n#define OBJGROUP    44\n#define NOTIFTYPE   45\n#define AUGMENTS    46\n#define COMPLIANCE  47\n#define READCREATE  48\n#define UNITS       49\n#define REFERENCE   50\n#define NUM_ENTRIES 51\n#define MODULEIDENTITY 52\n#define LASTUPDATED 53\n#define ORGANIZATION 54\n#define CONTACTINFO 55\n#define UINTEGER32 (56 | SYNTAX_MASK)\n#define CURRENT     57\n#define DEFINITIONS 58\n#define END         59\n#define SEMI        60\n#define TRAPTYPE    61\n#define ENTERPRISE  62\n/*\n * #define DISPLAYSTR (63 | SYNTAX_MASK) \n */\n#define BEGIN       64\n#define IMPORTS     65\n#define EXPORTS     66\n#define ACCNOTIFY   67\n#define BAR         68\n#define RANGE       69\n#define CONVENTION  70\n#define DISPLAYHINT 71\n#define FROM        72\n#define AGENTCAP    73\n#define MACRO       74\n#define IMPLIED     75\n#define SUPPORTS    76\n#define INCLUDES    77\n#define VARIATION   78\n#define REVISION    79\n#define NOTIMPL\t    80\n#define OBJECTS\t    81\n#define NOTIFICATIONS\t82\n#define MODULE\t    83\n#define MINACCESS   84\n#define PRODREL\t    85\n#define WRSYNTAX    86\n#define CREATEREQ   87\n#define NOTIFGROUP  88\n#define MANDATORYGROUPS\t89\n#define GROUP\t    90\n#define OBJECT\t    91\n#define IDENTIFIER  92\n#define CHOICE\t    93\n#define LEFTSQBRACK\t95\n#define RIGHTSQBRACK\t96\n#define IMPLICIT    97\n#define APPSYNTAX\t(98 | SYNTAX_MASK)\n#define OBJSYNTAX\t(99 | SYNTAX_MASK)\n#define SIMPLESYNTAX\t(100 | SYNTAX_MASK)\n#define OBJNAME\t\t(101 | SYNTAX_MASK)\n#define NOTIFNAME\t(102 | SYNTAX_MASK)\n#define VARIABLES\t103\n#define UNSIGNED32\t(104 | SYNTAX_MASK)\n#define INTEGER32\t(105 | SYNTAX_MASK)\n#define OBJIDENTITY\t106\n/*\n * Beware of reaching SYNTAX_MASK (0x80) \n */\n\nstruct tok {\n    const char     *name;       /* token name */\n    int             len;        /* length not counting nul */\n    int             token;      /* value */\n    int             hash;       /* hash of name */\n    struct tok     *next;       /* pointer to next in hash table */\n};\n\n\nstatic struct tok tokens[] = {\n    {\"obsolete\", sizeof(\"obsolete\") - 1, OBSOLETE}\n    ,\n    {\"Opaque\", sizeof(\"Opaque\") - 1, KW_OPAQUE}\n    ,\n    {\"optional\", sizeof(\"optional\") - 1, KW_OPTIONAL}\n    ,\n    {\"LAST-UPDATED\", sizeof(\"LAST-UPDATED\") - 1, LASTUPDATED}\n    ,\n    {\"ORGANIZATION\", sizeof(\"ORGANIZATION\") - 1, ORGANIZATION}\n    ,\n    {\"CONTACT-INFO\", sizeof(\"CONTACT-INFO\") - 1, CONTACTINFO}\n    ,\n    {\"MODULE-IDENTITY\", sizeof(\"MODULE-IDENTITY\") - 1, MODULEIDENTITY}\n    ,\n    {\"MODULE-COMPLIANCE\", sizeof(\"MODULE-COMPLIANCE\") - 1, COMPLIANCE}\n    ,\n    {\"DEFINITIONS\", sizeof(\"DEFINITIONS\") - 1, DEFINITIONS}\n    ,\n    {\"END\", sizeof(\"END\") - 1, END}\n    ,\n    {\"AUGMENTS\", sizeof(\"AUGMENTS\") - 1, AUGMENTS}\n    ,\n    {\"not-accessible\", sizeof(\"not-accessible\") - 1, NOACCESS}\n    ,\n    {\"write-only\", sizeof(\"write-only\") - 1, WRITEONLY}\n    ,\n    {\"NsapAddress\", sizeof(\"NsapAddress\") - 1, NSAPADDRESS}\n    ,\n    {\"UNITS\", sizeof(\"Units\") - 1, UNITS}\n    ,\n    {\"REFERENCE\", sizeof(\"REFERENCE\") - 1, REFERENCE}\n    ,\n    {\"NUM-ENTRIES\", sizeof(\"NUM-ENTRIES\") - 1, NUM_ENTRIES}\n    ,\n    {\"BITSTRING\", sizeof(\"BITSTRING\") - 1, BITSTRING}\n    ,\n    {\"BIT\", sizeof(\"BIT\") - 1, CONTINUE}\n    ,\n    {\"BITS\", sizeof(\"BITS\") - 1, BITSTRING}\n    ,\n    {\"Counter64\", sizeof(\"Counter64\") - 1, COUNTER64}\n    ,\n    {\"TimeTicks\", sizeof(\"TimeTicks\") - 1, TIMETICKS}\n    ,\n    {\"NOTIFICATION-TYPE\", sizeof(\"NOTIFICATION-TYPE\") - 1, NOTIFTYPE}\n    ,\n    {\"OBJECT-GROUP\", sizeof(\"OBJECT-GROUP\") - 1, OBJGROUP}\n    ,\n    {\"OBJECT-IDENTITY\", sizeof(\"OBJECT-IDENTITY\") - 1, OBJIDENTITY}\n    ,\n    {\"IDENTIFIER\", sizeof(\"IDENTIFIER\") - 1, IDENTIFIER}\n    ,\n    {\"OBJECT\", sizeof(\"OBJECT\") - 1, OBJECT}\n    ,\n    {\"NetworkAddress\", sizeof(\"NetworkAddress\") - 1, NETADDR}\n    ,\n    {\"Gauge\", sizeof(\"Gauge\") - 1, GAUGE}\n    ,\n    {\"Gauge32\", sizeof(\"Gauge32\") - 1, GAUGE}\n    ,\n    {\"Unsigned32\", sizeof(\"Unsigned32\") - 1, UNSIGNED32}\n    ,\n    {\"read-write\", sizeof(\"read-write\") - 1, READWRITE}\n    ,\n    {\"read-create\", sizeof(\"read-create\") - 1, READCREATE}\n    ,\n    {\"OCTETSTRING\", sizeof(\"OCTETSTRING\") - 1, OCTETSTR}\n    ,\n    {\"OCTET\", sizeof(\"OCTET\") - 1, CONTINUE}\n    ,\n    {\"OF\", sizeof(\"OF\") - 1, OF}\n    ,\n    {\"SEQUENCE\", sizeof(\"SEQUENCE\") - 1, SEQUENCE}\n    ,\n    {\"NULL\", sizeof(\"NULL\") - 1, NUL}\n    ,\n    {\"IpAddress\", sizeof(\"IpAddress\") - 1, IPADDR}\n    ,\n    {\"UInteger32\", sizeof(\"UInteger32\") - 1, UINTEGER32}\n    ,\n    {\"INTEGER\", sizeof(\"INTEGER\") - 1, INTEGER}\n    ,\n    {\"Integer32\", sizeof(\"Integer32\") - 1, INTEGER32}\n    ,\n    {\"Counter\", sizeof(\"Counter\") - 1, COUNTER}\n    ,\n    {\"Counter32\", sizeof(\"Counter32\") - 1, COUNTER}\n    ,\n    {\"read-only\", sizeof(\"read-only\") - 1, READONLY}\n    ,\n    {\"DESCRIPTION\", sizeof(\"DESCRIPTION\") - 1, DESCRIPTION}\n    ,\n    {\"INDEX\", sizeof(\"INDEX\") - 1, INDEX}\n    ,\n    {\"DEFVAL\", sizeof(\"DEFVAL\") - 1, DEFVAL}\n    ,\n    {\"deprecated\", sizeof(\"deprecated\") - 1, DEPRECATED}\n    ,\n    {\"SIZE\", sizeof(\"SIZE\") - 1, SIZE}\n    ,\n    {\"MAX-ACCESS\", sizeof(\"MAX-ACCESS\") - 1, ACCESS}\n    ,\n    {\"ACCESS\", sizeof(\"ACCESS\") - 1, ACCESS}\n    ,\n    {\"mandatory\", sizeof(\"mandatory\") - 1, MANDATORY}\n    ,\n    {\"current\", sizeof(\"current\") - 1, CURRENT}\n    ,\n    {\"STATUS\", sizeof(\"STATUS\") - 1, STATUS}\n    ,\n    {\"SYNTAX\", sizeof(\"SYNTAX\") - 1, SYNTAX}\n    ,\n    {\"OBJECT-TYPE\", sizeof(\"OBJECT-TYPE\") - 1, OBJTYPE}\n    ,\n    {\"TRAP-TYPE\", sizeof(\"TRAP-TYPE\") - 1, TRAPTYPE}\n    ,\n    {\"ENTERPRISE\", sizeof(\"ENTERPRISE\") - 1, ENTERPRISE}\n    ,\n    {\"BEGIN\", sizeof(\"BEGIN\") - 1, BEGIN}\n    ,\n    {\"IMPORTS\", sizeof(\"IMPORTS\") - 1, IMPORTS}\n    ,\n    {\"EXPORTS\", sizeof(\"EXPORTS\") - 1, EXPORTS}\n    ,\n    {\"accessible-for-notify\", sizeof(\"accessible-for-notify\") - 1,\n     ACCNOTIFY}\n    ,\n    {\"TEXTUAL-CONVENTION\", sizeof(\"TEXTUAL-CONVENTION\") - 1, CONVENTION}\n    ,\n    {\"NOTIFICATION-GROUP\", sizeof(\"NOTIFICATION-GROUP\") - 1, NOTIFGROUP}\n    ,\n    {\"DISPLAY-HINT\", sizeof(\"DISPLAY-HINT\") - 1, DISPLAYHINT}\n    ,\n    {\"FROM\", sizeof(\"FROM\") - 1, FROM}\n    ,\n    {\"AGENT-CAPABILITIES\", sizeof(\"AGENT-CAPABILITIES\") - 1, AGENTCAP}\n    ,\n    {\"MACRO\", sizeof(\"MACRO\") - 1, MACRO}\n    ,\n    {\"IMPLIED\", sizeof(\"IMPLIED\") - 1, IMPLIED}\n    ,\n    {\"SUPPORTS\", sizeof(\"SUPPORTS\") - 1, SUPPORTS}\n    ,\n    {\"INCLUDES\", sizeof(\"INCLUDES\") - 1, INCLUDES}\n    ,\n    {\"VARIATION\", sizeof(\"VARIATION\") - 1, VARIATION}\n    ,\n    {\"REVISION\", sizeof(\"REVISION\") - 1, REVISION}\n    ,\n    {\"not-implemented\", sizeof(\"not-implemented\") - 1, NOTIMPL}\n    ,\n    {\"OBJECTS\", sizeof(\"OBJECTS\") - 1, OBJECTS}\n    ,\n    {\"NOTIFICATIONS\", sizeof(\"NOTIFICATIONS\") - 1, NOTIFICATIONS}\n    ,\n    {\"MODULE\", sizeof(\"MODULE\") - 1, MODULE}\n    ,\n    {\"MIN-ACCESS\", sizeof(\"MIN-ACCESS\") - 1, MINACCESS}\n    ,\n    {\"PRODUCT-RELEASE\", sizeof(\"PRODUCT-RELEASE\") - 1, PRODREL}\n    ,\n    {\"WRITE-SYNTAX\", sizeof(\"WRITE-SYNTAX\") - 1, WRSYNTAX}\n    ,\n    {\"CREATION-REQUIRES\", sizeof(\"CREATION-REQUIRES\") - 1, CREATEREQ}\n    ,\n    {\"MANDATORY-GROUPS\", sizeof(\"MANDATORY-GROUPS\") - 1, MANDATORYGROUPS}\n    ,\n    {\"GROUP\", sizeof(\"GROUP\") - 1, GROUP}\n    ,\n    {\"CHOICE\", sizeof(\"CHOICE\") - 1, CHOICE}\n    ,\n    {\"IMPLICIT\", sizeof(\"IMPLICIT\") - 1, IMPLICIT}\n    ,\n    {\"ObjectSyntax\", sizeof(\"ObjectSyntax\") - 1, OBJSYNTAX}\n    ,\n    {\"SimpleSyntax\", sizeof(\"SimpleSyntax\") - 1, SIMPLESYNTAX}\n    ,\n    {\"ApplicationSyntax\", sizeof(\"ApplicationSyntax\") - 1, APPSYNTAX}\n    ,\n    {\"ObjectName\", sizeof(\"ObjectName\") - 1, OBJNAME}\n    ,\n    {\"NotificationName\", sizeof(\"NotificationName\") - 1, NOTIFNAME}\n    ,\n    {\"VARIABLES\", sizeof(\"VARIABLES\") - 1, VARIABLES}\n    ,\n    {NULL}\n};\n\nstatic struct module_compatability *module_map_head;\nstatic struct module_compatability module_map[] = {\n    {\"RFC1065-SMI\", \"RFC1155-SMI\", NULL, 0},\n    {\"RFC1066-MIB\", \"RFC1156-MIB\", NULL, 0},\n    /*\n     * 'mib' -> 'mib-2' \n     */\n    {\"RFC1156-MIB\", \"RFC1158-MIB\", NULL, 0},\n    /*\n     * 'snmpEnableAuthTraps' -> 'snmpEnableAuthenTraps' \n     */\n    {\"RFC1158-MIB\", \"RFC1213-MIB\", NULL, 0},\n    /*\n     * 'nullOID' -> 'zeroDotZero' \n     */\n    {\"RFC1155-SMI\", \"SNMPv2-SMI\", NULL, 0},\n    {\"RFC1213-MIB\", \"SNMPv2-SMI\", \"mib-2\", 0},\n    {\"RFC1213-MIB\", \"SNMPv2-MIB\", \"sys\", 3},\n    {\"RFC1213-MIB\", \"IF-MIB\", \"if\", 2},\n    {\"RFC1213-MIB\", \"IP-MIB\", \"ip\", 2},\n    {\"RFC1213-MIB\", \"IP-MIB\", \"icmp\", 4},\n    {\"RFC1213-MIB\", \"TCP-MIB\", \"tcp\", 3},\n    {\"RFC1213-MIB\", \"UDP-MIB\", \"udp\", 3},\n    {\"RFC1213-MIB\", \"SNMPv2-SMI\", \"transmission\", 0},\n    {\"RFC1213-MIB\", \"SNMPv2-MIB\", \"snmp\", 4},\n    {\"RFC1231-MIB\", \"TOKENRING-MIB\", NULL, 0},\n    {\"RFC1271-MIB\", \"RMON-MIB\", NULL, 0},\n    {\"RFC1286-MIB\", \"SOURCE-ROUTING-MIB\", \"dot1dSr\", 7},\n    {\"RFC1286-MIB\", \"BRIDGE-MIB\", NULL, 0},\n    {\"RFC1315-MIB\", \"FRAME-RELAY-DTE-MIB\", NULL, 0},\n    {\"RFC1316-MIB\", \"CHARACTER-MIB\", NULL, 0},\n    {\"RFC1406-MIB\", \"DS1-MIB\", NULL, 0},\n    {\"RFC-1213\", \"RFC1213-MIB\", NULL, 0},\n};\n\n#define MODULE_NOT_FOUND\t0\n#define MODULE_LOADED_OK\t1\n#define MODULE_ALREADY_LOADED\t2\n/*\n * #define MODULE_LOAD_FAILED   3       \n */\n#define MODULE_LOAD_FAILED\tMODULE_NOT_FOUND\n#define MODULE_SYNTAX_ERROR     4\n\nint gMibError = 0,gLoop = 0;\nstatic char *gpMibErrorString;\nchar gMibNames[STRINGMAX];\n\n#define HASHSIZE        32\n#define BUCKET(x)       (x & (HASHSIZE-1))\n\n#define NHASHSIZE    128\n#define NBUCKET(x)   (x & (NHASHSIZE-1))\n\nstatic struct tok *buckets[HASHSIZE];\n\nstatic struct node *nbuckets[NHASHSIZE];\nstatic struct tree *tbuckets[NHASHSIZE];\nstatic struct module *module_head = NULL;\n\nstatic struct node *orphan_nodes = NULL;\nNETSNMP_IMPORT struct tree *tree_head;\nstruct tree        *tree_head = NULL;\n\n#define\tNUMBER_OF_ROOT_NODES\t3\nstatic struct module_import root_imports[NUMBER_OF_ROOT_NODES];\n\nstatic int      current_module = 0;\nstatic int      max_module = 0;\nstatic int      first_err_module = 1;\nstatic char    *last_err_module = NULL; /* no repeats on \"Cannot find module...\" */\n\nstatic void     tree_from_node(struct tree *tp, struct node *np);\nstatic void     do_subtree(struct tree *, struct node **);\nstatic void     do_linkup(struct module *, struct node *);\nstatic void     dump_module_list(void);\nstatic int      get_token(FILE *, char *, int);\nstatic int      parseQuoteString(FILE *, char *, int);\nstatic int      tossObjectIdentifier(FILE *);\nstatic int      name_hash(const char *);\nstatic void     init_node_hash(struct node *);\nstatic void     print_error(const char *, const char *, int);\nstatic void     free_tree(struct tree *);\nstatic void     free_partial_tree(struct tree *, int);\nstatic void     free_node(struct node *);\nstatic void     build_translation_table(void);\nstatic void     init_tree_roots(void);\nstatic void     merge_anon_children(struct tree *, struct tree *);\nstatic void     unlink_tbucket(struct tree *);\nstatic void     unlink_tree(struct tree *);\nstatic int      getoid(FILE *, struct subid_s *, int);\nstatic struct node *parse_objectid(FILE *, char *);\nstatic int      get_tc(const char *, int, int *, struct enum_list **,\n                       struct range_list **, char **);\nstatic int      get_tc_index(const char *, int);\nstatic struct enum_list *parse_enumlist(FILE *, struct enum_list **);\nstatic struct range_list *parse_ranges(FILE * fp, struct range_list **);\nstatic struct node *parse_asntype(FILE *, char *, int *, char *);\nstatic struct node *parse_objecttype(FILE *, char *);\nstatic struct node *parse_objectgroup(FILE *, char *, int,\n                                      struct objgroup **);\nstatic struct node *parse_notificationDefinition(FILE *, char *);\nstatic struct node *parse_trapDefinition(FILE *, char *);\nstatic struct node *parse_compliance(FILE *, char *);\nstatic struct node *parse_capabilities(FILE *, char *);\nstatic struct node *parse_moduleIdentity(FILE *, char *);\nstatic struct node *parse_macro(FILE *, char *);\nstatic void     parse_imports(FILE *);\nstatic struct node *parse(FILE *, struct node *);\n\nstatic int     read_module_internal(const char *);\nstatic int     read_module_replacements(const char *);\nstatic int     read_import_replacements(const char *,\n                                         struct module_import *);\n\nstatic void     new_module(const char *, const char *);\n\nstatic struct node *merge_parse_objectid(struct node *, FILE *, char *);\nstatic struct index_list *getIndexes(FILE * fp, struct index_list **);\nstatic struct varbind_list *getVarbinds(FILE * fp, struct varbind_list **);\nstatic void     free_indexes(struct index_list **);\nstatic void     free_varbinds(struct varbind_list **);\nstatic void     free_ranges(struct range_list **);\nstatic void     free_enums(struct enum_list **);\nstatic struct range_list *copy_ranges(struct range_list *);\nstatic struct enum_list *copy_enums(struct enum_list *);\n\nstatic u_int    compute_match(const char *search_base, const char *key);\n\nvoid\nsnmp_mib_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%su:  %sallow the use of underlines in MIB symbols\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_PARSE_LABEL)) ?\n\t\t   \"dis\" : \"\"));\n    fprintf(outf, \"%sc:  %sallow the use of \\\"--\\\" to terminate comments\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_COMMENT_TERM)) ?\n\t\t   \"\" : \"dis\"));\n\n    fprintf(outf, \"%sd:  %ssave the DESCRIPTIONs of the MIB objects\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) ?\n\t\t   \"do not \" : \"\"));\n\n    fprintf(outf, \"%se:  disable errors when MIB symbols conflict\\n\", lead);\n\n    fprintf(outf, \"%sw:  enable warnings when MIB symbols conflict\\n\", lead);\n\n    fprintf(outf, \"%sW:  enable detailed warnings when MIB symbols conflict\\n\",\n            lead);\n\n    fprintf(outf, \"%sR:  replace MIB symbols from latest module\\n\", lead);\n}\n\nchar           *\nsnmp_mib_toggle_options(char *options)\n{\n    if (options) {\n        while (*options) {\n            switch (*options) {\n            case 'u':\n                netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL,\n                               !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                               NETSNMP_DS_LIB_MIB_PARSE_LABEL));\n                break;\n\n            case 'c':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n                break;\n\n            case 'e':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_ERRORS);\n                break;\n\n            case 'w':\n                netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS, 1);\n                break;\n\n            case 'W':\n                netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS, 2);\n                break;\n\n            case 'd':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_SAVE_MIB_DESCRS);\n                break;\n\n            case 'R':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_REPLACE);\n                break;\n\n            default:\n                /*\n                 * return at the unknown option \n                 */\n                return options;\n            }\n            options++;\n        }\n    }\n    return NULL;\n}\n\nstatic int\nname_hash(const char *name)\n{\n    int             hash = 0;\n    const char     *cp;\n\n    if (!name)\n        return 0;\n    for (cp = name; *cp; cp++)\n        hash += tolower((unsigned char)(*cp));\n    return (hash);\n}\n\nvoid\nnetsnmp_init_mib_internals(void)\n{\n    register struct tok *tp;\n    register int    b, i;\n    int             max_modc;\n\n    if (tree_head)\n        return;\n\n    /*\n     * Set up hash list of pre-defined tokens\n     */\n    memset(buckets, 0, sizeof(buckets));\n    for (tp = tokens; tp->name; tp++) {\n        tp->hash = name_hash(tp->name);\n        b = BUCKET(tp->hash);\n        if (buckets[b])\n            tp->next = buckets[b];      /* BUG ??? */\n        buckets[b] = tp;\n    }\n\n    /*\n     * Initialise other internal structures\n     */\n\n    max_modc = sizeof(module_map) / sizeof(module_map[0]) - 1;\n    for (i = 0; i < max_modc; ++i)\n        module_map[i].next = &(module_map[i + 1]);\n    module_map[max_modc].next = NULL;\n    module_map_head = module_map;\n\n    memset(nbuckets, 0, sizeof(nbuckets));\n    memset(tbuckets, 0, sizeof(tbuckets));\n    memset(tclist, 0, MAXTC * sizeof(struct tc));\n    build_translation_table();\n    init_tree_roots();          /* Set up initial roots */\n    /*\n     * Relies on 'add_mibdir' having set up the modules \n     */\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nvoid\ninit_mib_internals(void)\n{\n    netsnmp_init_mib_internals();\n}\n#endif\n\nstatic void\ninit_node_hash(struct node *nodes)\n{\n    struct node    *np, *nextp;\n    int             hash;\n\n    memset(nbuckets, 0, sizeof(nbuckets));\n    for (np = nodes; np;) {\n        nextp = np->next;\n        hash = NBUCKET(name_hash(np->parent));\n        np->next = nbuckets[hash];\n        nbuckets[hash] = np;\n        np = nextp;\n    }\n}\n\nstatic int      erroneousMibs = 0;\n\nnetsnmp_feature_child_of(parse_get_error_count, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_GET_ERROR_COUNT\nint\nget_mib_parse_error_count(void)\n{\n    return erroneousMibs;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_GET_ERROR_COUNT */\n\n\nstatic void\nprint_error(const char *str, const char *token, int type)\n{\n    erroneousMibs++;\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                NETSNMP_DS_LIB_MIB_ERRORS))\n\treturn;\n    DEBUGMSGTL((\"parse-mibs\", \"\\n\"));\n    if (type == ENDOFFILE)\n        snmp_log(LOG_ERR, \"%s (EOF): At line %d in %s\\n\", str, mibLine,\n                 File);\n    else if (token && *token)\n        snmp_log(LOG_ERR, \"%s (%s): At line %d in %s\\n\", str, token,\n                 mibLine, File);\n    else\n        snmp_log(LOG_ERR, \"%s: At line %d in %s\\n\", str, mibLine, File);\n}\n\nstatic void\nprint_module_not_found(const char *cp)\n{\n    if (first_err_module) {\n        snmp_log(LOG_ERR, \"MIB search path: %s\\n\",\n                           netsnmp_get_mib_directory());\n        first_err_module = 0;\n    }\n    if (!last_err_module || strcmp(cp, last_err_module))\n        print_error(\"Cannot find module\", cp, CONTINUE);\n    if (last_err_module)\n        free(last_err_module);\n    last_err_module = strdup(cp);\n}\n\nstatic struct node *\nalloc_node(int modid)\n{\n    struct node    *np;\n    np = (struct node *) calloc(1, sizeof(struct node));\n    if (np) {\n        np->tc_index = -1;\n        np->modid = modid;\n\tnp->filename = strdup(File);\n\tnp->lineno = mibLine;\n    }\n    return np;\n}\n\nstatic void\nunlink_tbucket(struct tree *tp)\n{\n    int             hash = NBUCKET(name_hash(tp->label));\n    struct tree    *otp = NULL, *ntp = tbuckets[hash];\n\n    while (ntp && ntp != tp) {\n        otp = ntp;\n        ntp = ntp->next;\n    }\n    if (!ntp)\n        snmp_log(LOG_EMERG, \"Can't find %s in tbuckets\\n\", tp->label);\n    else if (otp)\n        otp->next = ntp->next;\n    else\n        tbuckets[hash] = tp->next;\n}\n\nstatic void\nunlink_tree(struct tree *tp)\n{\n    struct tree    *otp = NULL, *ntp = tp->parent;\n\n    if (!ntp) {                 /* this tree has no parent */\n        DEBUGMSGTL((\"unlink_tree\", \"Tree node %s has no parent\\n\",\n                    tp->label));\n    } else {\n        ntp = ntp->child_list;\n\n        while (ntp && ntp != tp) {\n            otp = ntp;\n            ntp = ntp->next_peer;\n        }\n        if (!ntp)\n            snmp_log(LOG_EMERG, \"Can't find %s in %s's children\\n\",\n                     tp->label, tp->parent->label);\n        else if (otp)\n            otp->next_peer = ntp->next_peer;\n        else\n            tp->parent->child_list = tp->next_peer;\n    }\n\n    if (tree_head == tp)\n        tree_head = tp->next_peer;\n}\n\nstatic void\nfree_partial_tree(struct tree *tp, int keep_label)\n{\n    if (!tp)\n        return;\n\n    /*\n     * remove the data from this tree node \n     */\n    free_enums(&tp->enums);\n    free_ranges(&tp->ranges);\n    free_indexes(&tp->indexes);\n    free_varbinds(&tp->varbinds);\n    if (!keep_label)\n        SNMP_FREE(tp->label);\n    SNMP_FREE(tp->hint);\n    SNMP_FREE(tp->units);\n    SNMP_FREE(tp->description);\n    SNMP_FREE(tp->reference);\n    SNMP_FREE(tp->augments);\n    SNMP_FREE(tp->defaultValue);\n}\n\n/*\n * free a tree node. Note: the node must already have been unlinked\n * from the tree when calling this routine\n */\nstatic void\nfree_tree(struct tree *Tree)\n{\n    if (!Tree)\n        return;\n\n    unlink_tbucket(Tree);\n    free_partial_tree(Tree, FALSE);\n    if (Tree->module_list != &Tree->modid)\n        free(Tree->module_list);\n    free(Tree);\n}\n\nstatic void\nfree_node(struct node *np)\n{\n    if (!np)\n        return;\n\n    free_enums(&np->enums);\n    free_ranges(&np->ranges);\n    free_indexes(&np->indexes);\n    free_varbinds(&np->varbinds);\n    if (np->label)\n        free(np->label);\n    if (np->hint)\n        free(np->hint);\n    if (np->units)\n        free(np->units);\n    if (np->description)\n        free(np->description);\n    if (np->reference)\n        free(np->reference);\n    if (np->defaultValue)\n        free(np->defaultValue);\n    if (np->parent)\n        free(np->parent);\n    if (np->augments)\n        free(np->augments);\n    if (np->filename)\n\tfree(np->filename);\n    free((char *) np);\n}\n\nstatic void\nprint_range_value(FILE * fp, int type, struct range_list * rp)\n{\n    switch (type) {\n    case TYPE_INTEGER:\n    case TYPE_INTEGER32:\n        if (rp->low == rp->high)\n            fprintf(fp, \"%d\", rp->low);\n        else\n            fprintf(fp, \"%d..%d\", rp->low, rp->high);\n        break;\n    case TYPE_UNSIGNED32:\n    case TYPE_OCTETSTR:\n    case TYPE_GAUGE:\n    case TYPE_UINTEGER:\n        if (rp->low == rp->high)\n            fprintf(fp, \"%u\", (unsigned)rp->low);\n        else\n            fprintf(fp, \"%u..%u\", (unsigned)rp->low, (unsigned)rp->high);\n        break;\n    default:\n        /* No other range types allowed */\n        break;\n    }\n}\n\n#ifdef TEST\nstatic void\nprint_nodes(FILE * fp, struct node *root)\n{\n    struct enum_list *ep;\n    struct index_list *ip;\n    struct varbind_list *vp;\n    struct node    *np;\n\n    for (np = root; np; np = np->next) {\n        fprintf(fp, \"%s ::= { %s %ld } (%d)\\n\", np->label, np->parent,\n                np->subid, np->type);\n        if (np->tc_index >= 0)\n            fprintf(fp, \"  TC = %s\\n\", tclist[np->tc_index].descriptor);\n        if (np->enums) {\n            fprintf(fp, \"  Enums: \\n\");\n            for (ep = np->enums; ep; ep = ep->next) {\n                fprintf(fp, \"    %s(%d)\\n\", ep->label, ep->value);\n            }\n        }\n        if (np->ranges) {\n            struct range_list *rp;\n            fprintf(fp, \"  Ranges: \");\n            for (rp = np->ranges; rp; rp = rp->next) {\n                fprintf(fp, \"\\n    \");\n                print_range_value(fp, np->type, rp);\n            }\n            fprintf(fp, \"\\n\");\n        }\n        if (np->indexes) {\n            fprintf(fp, \"  Indexes: \\n\");\n            for (ip = np->indexes; ip; ip = ip->next) {\n                fprintf(fp, \"    %s\\n\", ip->ilabel);\n            }\n        }\n        if (np->augments)\n            fprintf(fp, \"  Augments: %s\\n\", np->augments);\n        if (np->varbinds) {\n            fprintf(fp, \"  Varbinds: \\n\");\n            for (vp = np->varbinds; vp; vp = vp->next) {\n                fprintf(fp, \"    %s\\n\", vp->vblabel);\n            }\n        }\n        if (np->hint)\n            fprintf(fp, \"  Hint: %s\\n\", np->hint);\n        if (np->units)\n            fprintf(fp, \"  Units: %s\\n\", np->units);\n        if (np->defaultValue)\n            fprintf(fp, \"  DefaultValue: %s\\n\", np->defaultValue);\n    }\n}\n#endif\n\nvoid\nprint_subtree(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n    int             i;\n    char            modbuf[256];\n\n    for (i = 0; i < count; i++)\n        fprintf(f, \"  \");\n    fprintf(f, \"Children of %s(%ld):\\n\", tree->label, tree->subid);\n    count++;\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        for (i = 0; i < count; i++)\n            fprintf(f, \"  \");\n        fprintf(f, \"%s:%s(%ld) type=%d\",\n                module_name(tp->module_list[0], modbuf),\n                tp->label, tp->subid, tp->type);\n        if (tp->tc_index != -1)\n            fprintf(f, \" tc=%d\", tp->tc_index);\n        if (tp->hint)\n            fprintf(f, \" hint=%s\", tp->hint);\n        if (tp->units)\n            fprintf(f, \" units=%s\", tp->units);\n        if (tp->number_modules > 1) {\n            fprintf(f, \" modules:\");\n            for (i = 1; i < tp->number_modules; i++)\n                fprintf(f, \" %s\", module_name(tp->module_list[i], modbuf));\n        }\n        fprintf(f, \"\\n\");\n    }\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        if (tp->child_list)\n            print_subtree(f, tp, count);\n    }\n}\n\nvoid\nprint_ascii_dump_tree(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n\n    count++;\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        fprintf(f, \"%s OBJECT IDENTIFIER ::= { %s %ld }\\n\", tp->label,\n                tree->label, tp->subid);\n    }\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        if (tp->child_list)\n            print_ascii_dump_tree(f, tp, count);\n    }\n}\n\nstatic int      translation_table[256];\n\nstatic void\nbuild_translation_table(void)\n{\n    int             count;\n\n    for (count = 0; count < 256; count++) {\n        switch (count) {\n        case OBJID:\n            translation_table[count] = TYPE_OBJID;\n            break;\n        case OCTETSTR:\n            translation_table[count] = TYPE_OCTETSTR;\n            break;\n        case INTEGER:\n            translation_table[count] = TYPE_INTEGER;\n            break;\n        case NETADDR:\n            translation_table[count] = TYPE_NETADDR;\n            break;\n        case IPADDR:\n            translation_table[count] = TYPE_IPADDR;\n            break;\n        case COUNTER:\n            translation_table[count] = TYPE_COUNTER;\n            break;\n        case GAUGE:\n            translation_table[count] = TYPE_GAUGE;\n            break;\n        case TIMETICKS:\n            translation_table[count] = TYPE_TIMETICKS;\n            break;\n        case KW_OPAQUE:\n            translation_table[count] = TYPE_OPAQUE;\n            break;\n        case NUL:\n            translation_table[count] = TYPE_NULL;\n            break;\n        case COUNTER64:\n            translation_table[count] = TYPE_COUNTER64;\n            break;\n        case BITSTRING:\n            translation_table[count] = TYPE_BITSTRING;\n            break;\n        case NSAPADDRESS:\n            translation_table[count] = TYPE_NSAPADDRESS;\n            break;\n        case INTEGER32:\n            translation_table[count] = TYPE_INTEGER32;\n            break;\n        case UINTEGER32:\n            translation_table[count] = TYPE_UINTEGER;\n            break;\n        case UNSIGNED32:\n            translation_table[count] = TYPE_UNSIGNED32;\n            break;\n        case TRAPTYPE:\n            translation_table[count] = TYPE_TRAPTYPE;\n            break;\n        case NOTIFTYPE:\n            translation_table[count] = TYPE_NOTIFTYPE;\n            break;\n        case NOTIFGROUP:\n            translation_table[count] = TYPE_NOTIFGROUP;\n            break;\n        case OBJGROUP:\n            translation_table[count] = TYPE_OBJGROUP;\n            break;\n        case MODULEIDENTITY:\n            translation_table[count] = TYPE_MODID;\n            break;\n        case OBJIDENTITY:\n            translation_table[count] = TYPE_OBJIDENTITY;\n            break;\n        case AGENTCAP:\n            translation_table[count] = TYPE_AGENTCAP;\n            break;\n        case COMPLIANCE:\n            translation_table[count] = TYPE_MODCOMP;\n            break;\n        default:\n            translation_table[count] = TYPE_OTHER;\n            break;\n        }\n    }\n}\n\nstatic void\ninit_tree_roots(void)\n{\n    struct tree    *tp, *lasttp;\n    int             base_modid;\n    int             hash;\n\n    base_modid = which_module(\"SNMPv2-SMI\");\n    if (base_modid == -1)\n        base_modid = which_module(\"RFC1155-SMI\");\n    if (base_modid == -1)\n        base_modid = which_module(\"RFC1213-MIB\");\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->label = strdup(\"joint-iso-ccitt\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 2;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[0].label = strdup(tp->label);\n    root_imports[0].modid = base_modid;\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->next_peer = lasttp;\n    tp->label = strdup(\"ccitt\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 0;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[1].label = strdup(tp->label);\n    root_imports[1].modid = base_modid;\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->next_peer = lasttp;\n    tp->label = strdup(\"iso\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 1;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[2].label = strdup(tp->label);\n    root_imports[2].modid = base_modid;\n\n    tree_head = tp;\n}\n\n#ifdef STRICT_MIB_PARSEING\n#define\tlabel_compare\tstrcasecmp\n#else\n#define\tlabel_compare\tstrcmp\n#endif\n\n\nstruct tree    *\nfind_tree_node(const char *name, int modid)\n{\n    struct tree    *tp, *headtp;\n    int             count, *int_p;\n\n    if (!name || !*name)\n        return (NULL);\n\n    headtp = tbuckets[NBUCKET(name_hash(name))];\n    for (tp = headtp; tp; tp = tp->next) {\n        if (tp->label && !label_compare(tp->label, name)) {\n\n            if (modid == -1)    /* Any module */\n                return (tp);\n\n            for (int_p = tp->module_list, count = 0;\n                 count < tp->number_modules; ++count, ++int_p)\n                if (*int_p == modid)\n                    return (tp);\n        }\n    }\n\n    return (NULL);\n}\n\n/*\n * computes a value which represents how close name1 is to name2.\n * * high scores mean a worse match.\n * * (yes, the algorithm sucks!)\n */\n#define MAX_BAD 0xffffff\n\nstatic          u_int\ncompute_match(const char *search_base, const char *key)\n{\n#if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)\n    int             rc;\n    regex_t         parsetree;\n    regmatch_t      pmatch;\n    rc = regcomp(&parsetree, key, REG_ICASE | REG_EXTENDED);\n    if (rc == 0)\n        rc = regexec(&parsetree, search_base, 1, &pmatch, 0);\n    regfree(&parsetree);\n    if (rc == 0) {\n        /*\n         * found \n         */\n        return pmatch.rm_so;\n    }\n#else                           /* use our own wildcard matcher */\n    /*\n     * first find the longest matching substring (ick) \n     */\n    char           *first = NULL, *result = NULL, *entry;\n    const char     *position;\n    char           *newkey = strdup(key);\n    char           *st;\n\n\n    entry = strtok_r(newkey, \"*\", &st);\n    position = search_base;\n    while (entry) {\n        result = strcasestr(position, entry);\n\n        if (result == NULL) {\n            free(newkey);\n            return MAX_BAD;\n        }\n\n        if (first == NULL)\n            first = result;\n\n        position = result + strlen(entry);\n        entry = strtok_r(NULL, \"*\", &st);\n    }\n    free(newkey);\n    if (result)\n        return (first - search_base);\n#endif\n\n    /*\n     * not found \n     */\n    return MAX_BAD;\n}\n\n/*\n * Find the tree node that best matches the pattern string.\n * Use the \"reported\" flag such that only one match\n * is attempted for every node.\n *\n * Warning! This function may recurse.\n *\n * Caller _must_ invoke clear_tree_flags before first call\n * to this function.  This function may be called multiple times\n * to ensure that the entire tree is traversed.\n */\n\nstruct tree    *\nfind_best_tree_node(const char *pattrn, struct tree *tree_top,\n                    u_int * match)\n{\n    struct tree    *tp, *best_so_far = NULL, *retptr;\n    u_int           old_match = MAX_BAD, new_match = MAX_BAD;\n\n    if (!pattrn || !*pattrn)\n        return (NULL);\n\n    if (!tree_top)\n        tree_top = get_tree_head();\n\n    for (tp = tree_top; tp; tp = tp->next_peer) {\n        if (!tp->reported && tp->label)\n            new_match = compute_match(tp->label, pattrn);\n        tp->reported = 1;\n\n        if (new_match < old_match) {\n            best_so_far = tp;\n            old_match = new_match;\n        }\n        if (new_match == 0)\n            break;              /* this is the best result we can get */\n        if (tp->child_list) {\n            retptr =\n                find_best_tree_node(pattrn, tp->child_list, &new_match);\n            if (new_match < old_match) {\n                best_so_far = retptr;\n                old_match = new_match;\n            }\n            if (new_match == 0)\n                break;          /* this is the best result we can get */\n        }\n    }\n    if (match)\n        *match = old_match;\n    return (best_so_far);\n}\n\n\nstatic void\nmerge_anon_children(struct tree *tp1, struct tree *tp2)\n                /*\n                 * NB: tp1 is the 'anonymous' node \n                 */\n{\n    struct tree    *child1, *child2, *previous;\n\n    for (child1 = tp1->child_list; child1;) {\n\n        for (child2 = tp2->child_list, previous = NULL;\n             child2; previous = child2, child2 = child2->next_peer) {\n\n            if (child1->subid == child2->subid) {\n                /*\n                 * Found 'matching' children,\n                 *  so merge them\n                 */\n                if (!strncmp(child1->label, ANON, ANON_LEN)) {\n                    merge_anon_children(child1, child2);\n\n                    child1->child_list = NULL;\n                    previous = child1;  /* Finished with 'child1' */\n                    child1 = child1->next_peer;\n                    free_tree(previous);\n                    goto next;\n                }\n\n                else if (!strncmp(child2->label, ANON, ANON_LEN)) {\n                    merge_anon_children(child2, child1);\n\n                    if (previous)\n                        previous->next_peer = child2->next_peer;\n                    else\n                        tp2->child_list = child2->next_peer;\n                    free_tree(child2);\n\n                    previous = child1;  /* Move 'child1' to 'tp2' */\n                    child1 = child1->next_peer;\n                    previous->next_peer = tp2->child_list;\n                    tp2->child_list = previous;\n                    for (previous = tp2->child_list;\n                         previous; previous = previous->next_peer)\n                        previous->parent = tp2;\n                    goto next;\n                } else if (!label_compare(child1->label, child2->label)) {\n                    if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                        snmp_log(LOG_WARNING,\n                                 \"Warning: %s.%ld is both %s and %s (%s)\\n\",\n                                 tp2->label, child1->subid, child1->label,\n                                 child2->label, File);\n\t\t    }\n                    continue;\n                } else {\n                    /*\n                     * Two copies of the same node.\n                     * 'child2' adopts the children of 'child1'\n                     */\n\n                    if (child2->child_list) {\n                        for (previous = child2->child_list; previous->next_peer; previous = previous->next_peer);       /* Find the end of the list */\n                        previous->next_peer = child1->child_list;\n                    } else\n                        child2->child_list = child1->child_list;\n                    for (previous = child1->child_list;\n                         previous; previous = previous->next_peer)\n                        previous->parent = child2;\n                    child1->child_list = NULL;\n\n                    previous = child1;  /* Finished with 'child1' */\n                    child1 = child1->next_peer;\n                    free_tree(previous);\n                    goto next;\n                }\n            }\n        }\n        /*\n         * If no match, move 'child1' to 'tp2' child_list\n         */\n        if (child1) {\n            previous = child1;\n            child1 = child1->next_peer;\n            previous->parent = tp2;\n            previous->next_peer = tp2->child_list;\n            tp2->child_list = previous;\n        }\n      next:;\n    }\n}\n\n\n/*\n * Find all the children of root in the list of nodes.  Link them into the\n * tree and out of the nodes list.\n */\nstatic void\ndo_subtree(struct tree *root, struct node **nodes)\n{\n    struct tree    *tp, *anon_tp = NULL;\n    struct tree    *xroot = root;\n    struct node    *np, **headp;\n    struct node    *oldnp = NULL, *child_list = NULL, *childp = NULL;\n    int             hash;\n    int            *int_p;\n\n    while (xroot->next_peer && xroot->next_peer->subid == root->subid) {\n#if 0\n        printf(\"xroot: %s.%s => %s\\n\", xroot->parent->label, xroot->label,\n               xroot->next_peer->label);\n#endif\n        xroot = xroot->next_peer;\n    }\n\n    tp = root;\n    headp = &nbuckets[NBUCKET(name_hash(tp->label))];\n    /*\n     * Search each of the nodes for one whose parent is root, and\n     * move each into a separate list.\n     */\n    for (np = *headp; np; np = np->next) {\n        if (!label_compare(tp->label, np->parent)) {\n            /*\n             * take this node out of the node list \n             */\n            if (oldnp == NULL) {\n                *headp = np->next;      /* fix root of node list */\n            } else {\n                oldnp->next = np->next; /* link around this node */\n            }\n            if (child_list)\n                childp->next = np;\n            else\n                child_list = np;\n            childp = np;\n        } else {\n            oldnp = np;\n        }\n\n    }\n    if (childp)\n        childp->next = NULL;\n    /*\n     * Take each element in the child list and place it into the tree.\n     */\n    for (np = child_list; np; np = np->next) {\n        struct tree    *otp = NULL;\n        struct tree    *xxroot = xroot;\n        anon_tp = NULL;\n        tp = xroot->child_list;\n\n        if (np->subid == -1) {\n            /*\n             * name ::= { parent } \n             */\n            np->subid = xroot->subid;\n            tp = xroot;\n            xxroot = xroot->parent;\n        }\n\n        while (tp) {\n            if (tp->subid == np->subid)\n                break;\n            else {\n                otp = tp;\n                tp = tp->next_peer;\n            }\n        }\n        if (tp) {\n            if (!label_compare(tp->label, np->label)) {\n                /*\n                 * Update list of modules \n                 */\n                int_p = malloc((tp->number_modules + 1) * sizeof(int));\n                if (int_p == NULL)\n                    return;\n                memcpy(int_p, tp->module_list,\n                       tp->number_modules * sizeof(int));\n                int_p[tp->number_modules] = np->modid;\n                if (tp->module_list != &tp->modid)\n                    free(tp->module_list);\n                ++tp->number_modules;\n                tp->module_list = int_p;\n\n                if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_REPLACE)) {\n                    /*\n                     * Replace from node \n                     */\n                    tree_from_node(tp, np);\n                }\n                /*\n                 * Handle children \n                 */\n                do_subtree(tp, nodes);\n                continue;\n            }\n            if (!strncmp(np->label, ANON, ANON_LEN) ||\n                !strncmp(tp->label, ANON, ANON_LEN)) {\n                anon_tp = tp;   /* Need to merge these two trees later */\n            } else if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                snmp_log(LOG_WARNING,\n                         \"Warning: %s.%ld is both %s and %s (%s)\\n\",\n                         root->label, np->subid, tp->label, np->label,\n                         File);\n\t    }\n        }\n\n        tp = (struct tree *) calloc(1, sizeof(struct tree));\n        if (tp == NULL)\n            return;\n        tp->parent = xxroot;\n        tp->modid = np->modid;\n        tp->number_modules = 1;\n        tp->module_list = &(tp->modid);\n        tree_from_node(tp, np);\n        tp->next_peer = otp ? otp->next_peer : xxroot->child_list;\n        if (otp)\n            otp->next_peer = tp;\n        else\n            xxroot->child_list = tp;\n        hash = NBUCKET(name_hash(tp->label));\n        tp->next = tbuckets[hash];\n        tbuckets[hash] = tp;\n        do_subtree(tp, nodes);\n\n        if (anon_tp) {\n            if (!strncmp(tp->label, ANON, ANON_LEN)) {\n                /*\n                 * The new node is anonymous,\n                 *  so merge it with the existing one.\n                 */\n                merge_anon_children(tp, anon_tp);\n\n                /*\n                 * unlink and destroy tp \n                 */\n                unlink_tree(tp);\n                free_tree(tp);\n            } else if (!strncmp(anon_tp->label, ANON, ANON_LEN)) {\n                struct tree    *ntp;\n                /*\n                 * The old node was anonymous,\n                 *  so merge it with the existing one,\n                 *  and fill in the full information.\n                 */\n                merge_anon_children(anon_tp, tp);\n\n                /*\n                 * unlink anon_tp from the hash \n                 */\n                unlink_tbucket(anon_tp);\n\n                /*\n                 * get rid of old contents of anon_tp \n                 */\n                free_partial_tree(anon_tp, FALSE);\n\n                /*\n                 * put in the current information \n                 */\n                anon_tp->label = tp->label;\n                anon_tp->child_list = tp->child_list;\n                anon_tp->modid = tp->modid;\n                anon_tp->tc_index = tp->tc_index;\n                anon_tp->type = tp->type;\n                anon_tp->enums = tp->enums;\n                anon_tp->indexes = tp->indexes;\n                anon_tp->augments = tp->augments;\n                anon_tp->varbinds = tp->varbinds;\n                anon_tp->ranges = tp->ranges;\n                anon_tp->hint = tp->hint;\n                anon_tp->units = tp->units;\n                anon_tp->description = tp->description;\n                anon_tp->reference = tp->reference;\n                anon_tp->defaultValue = tp->defaultValue;\n                anon_tp->parent = tp->parent;\n\n                set_function(anon_tp);\n\n                /*\n                 * update parent pointer in moved children \n                 */\n                ntp = anon_tp->child_list;\n                while (ntp) {\n                    ntp->parent = anon_tp;\n                    ntp = ntp->next_peer;\n                }\n\n                /*\n                 * hash in anon_tp in its new place \n                 */\n                hash = NBUCKET(name_hash(anon_tp->label));\n                anon_tp->next = tbuckets[hash];\n                tbuckets[hash] = anon_tp;\n\n                /*\n                 * unlink and destroy tp \n                 */\n                unlink_tbucket(tp);\n                unlink_tree(tp);\n                free(tp);\n            } else {\n                /*\n                 * Uh?  One of these two should have been anonymous! \n                 */\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Warning: expected anonymous node (either %s or %s) in %s\\n\",\n                             tp->label, anon_tp->label, File);\n\t\t}\n            }\n            anon_tp = NULL;\n        }\n    }\n    /*\n     * free all nodes that were copied into tree \n     */\n    oldnp = NULL;\n    for (np = child_list; np; np = np->next) {\n        if (oldnp)\n            free_node(oldnp);\n        oldnp = np;\n    }\n    if (oldnp)\n        free_node(oldnp);\n}\n\nstatic void\ndo_linkup(struct module *mp, struct node *np)\n{\n    struct module_import *mip;\n    struct node    *onp, *oldp, *newp;\n    struct tree    *tp;\n    int             i, more;\n    /*\n     * All modules implicitly import\n     *   the roots of the tree\n     */\n    if (snmp_get_do_debugging() > 1)\n        dump_module_list();\n    DEBUGMSGTL((\"parse-mibs\", \"Processing IMPORTS for module %d %s\\n\",\n                mp->modid, mp->name));\n    if (mp->no_imports == 0) {\n        mp->no_imports = NUMBER_OF_ROOT_NODES;\n        mp->imports = root_imports;\n    }\n\n    /*\n     * Build the tree\n     */\n    init_node_hash(np);\n    for (i = 0, mip = mp->imports; i < mp->no_imports; ++i, ++mip) {\n        char            modbuf[256];\n        DEBUGMSGTL((\"parse-mibs\", \"  Processing import: %s\\n\",\n                    mip->label));\n        if (get_tc_index(mip->label, mip->modid) != -1)\n            continue;\n        tp = find_tree_node(mip->label, mip->modid);\n        if (!tp) {\n\t    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS))\n                snmp_log(LOG_WARNING,\n                         \"Did not find '%s' in module %s (%s)\\n\",\n                         mip->label, module_name(mip->modid, modbuf),\n                         File);\n            continue;\n        }\n        do_subtree(tp, &np);\n    }\n\n    /*\n     * If any nodes left over,\n     *   check that they're not the result of a \"fully qualified\"\n     *   name, and then add them to the list of orphans\n     */\n\n    if (!np)\n        return;\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        do_subtree(tp, &np);\n    if (!np)\n        return;\n\n    /*\n     * quietly move all internal references to the orphan list \n     */\n    oldp = orphan_nodes;\n    do {\n        for (i = 0; i < NHASHSIZE; i++)\n            for (onp = nbuckets[i]; onp; onp = onp->next) {\n                struct node    *op = NULL;\n                int             hash = NBUCKET(name_hash(onp->label));\n                np = nbuckets[hash];\n                while (np) {\n                    if (label_compare(onp->label, np->parent)) {\n                        op = np;\n                        np = np->next;\n                    } else {\n                        if (op)\n                            op->next = np->next;\n                        else\n                            nbuckets[hash] = np->next;\n\t\t\tDEBUGMSGTL((\"parse-mibs\", \"Moving %s to orphanage\", np->label));\n                        np->next = orphan_nodes;\n                        orphan_nodes = np;\n                        op = NULL;\n                        np = nbuckets[hash];\n                    }\n                }\n            }\n        newp = orphan_nodes;\n        more = 0;\n        for (onp = orphan_nodes; onp != oldp; onp = onp->next) {\n            struct node    *op = NULL;\n            int             hash = NBUCKET(name_hash(onp->label));\n            np = nbuckets[hash];\n            while (np) {\n                if (label_compare(onp->label, np->parent)) {\n                    op = np;\n                    np = np->next;\n                } else {\n                    if (op)\n                        op->next = np->next;\n                    else\n                        nbuckets[hash] = np->next;\n                    np->next = orphan_nodes;\n                    orphan_nodes = np;\n                    op = NULL;\n                    np = nbuckets[hash];\n                    more = 1;\n                }\n            }\n        }\n        oldp = newp;\n    } while (more);\n\n    /*\n     * complain about left over nodes \n     */\n    for (np = orphan_nodes; np && np->next; np = np->next);     /* find the end of the orphan list */\n    for (i = 0; i < NHASHSIZE; i++)\n        if (nbuckets[i]) {\n            if (orphan_nodes)\n                onp = np->next = nbuckets[i];\n            else\n                onp = orphan_nodes = nbuckets[i];\n            nbuckets[i] = NULL;\n            while (onp) {\n                snmp_log(LOG_WARNING,\n                         \"Unlinked OID in %s: %s ::= { %s %ld }\\n\",\n                         (mp->name ? mp->name : \"<no module>\"),\n                         (onp->label ? onp->label : \"<no label>\"),\n                         (onp->parent ? onp->parent : \"<no parent>\"),\n                         onp->subid);\n\t\t snmp_log(LOG_WARNING,\n\t\t\t  \"Undefined identifier: %s near line %d of %s\\n\",\n\t\t\t  (onp->parent ? onp->parent : \"<no parent>\"),\n\t\t\t  onp->lineno, onp->filename);\n                np = onp;\n                onp = onp->next;\n            }\n        }\n    return;\n}\n\n\n/*\n * Takes a list of the form:\n * { iso org(3) dod(6) 1 }\n * and creates several nodes, one for each parent-child pair.\n * Returns 0 on error.\n */\nstatic int\ngetoid(FILE * fp, struct subid_s *id,   /* an array of subids */\n       int length)\n{                               /* the length of the array */\n    register int    count;\n    int             type;\n    char            token[MAXTOKEN];\n\n    if ((type = get_token(fp, token, MAXTOKEN)) != LEFTBRACKET) {\n        print_error(\"Expected \\\"{\\\"\", token, type);\n        return 0;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    for (count = 0; count < length; count++, id++) {\n        id->label = NULL;\n        id->modid = current_module;\n        id->subid = -1;\n        if (type == RIGHTBRACKET)\n            return count;\n        if (type == LABEL) {\n            /*\n             * this entry has a label \n             */\n            id->label = strdup(token);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == LEFTPAREN) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type == NUMBER) {\n                    id->subid = strtoul(token, NULL, 10);\n                    if ((type =\n                         get_token(fp, token, MAXTOKEN)) != RIGHTPAREN) {\n                        print_error(\"Expected a closing parenthesis\",\n                                    token, type);\n                        return 0;\n                    }\n                } else {\n                    print_error(\"Expected a number\", token, type);\n                    return 0;\n                }\n            } else {\n                continue;\n            }\n        } else if (type == NUMBER) {\n            /*\n             * this entry  has just an integer sub-identifier \n             */\n            id->subid = strtoul(token, NULL, 10);\n        } else {\n            print_error(\"Expected label or number\", token, type);\n            return 0;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    print_error(\"Too long OID\", token, type);\n    return 0;\n}\n\n/*\n * Parse a sequence of object subidentifiers for the given name.\n * The \"label OBJECT IDENTIFIER ::=\" portion has already been parsed.\n *\n * The majority of cases take this form :\n * label OBJECT IDENTIFIER ::= { parent 2 }\n * where a parent label and a child subidentifier number are specified.\n *\n * Variations on the theme include cases where a number appears with\n * the parent, or intermediate subidentifiers are specified by label,\n * by number, or both.\n *\n * Here are some representative samples :\n * internet        OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }\n * mgmt            OBJECT IDENTIFIER ::= { internet 2 }\n * rptrInfoHealth  OBJECT IDENTIFIER ::= { snmpDot3RptrMgt 0 4 }\n *\n * Here is a very rare form :\n * iso             OBJECT IDENTIFIER ::= { 1 }\n *\n * Returns NULL on error.  When this happens, memory may be leaked.\n */\nstatic struct node *\nparse_objectid(FILE * fp, char *name)\n{\n    register int    count;\n    register struct subid_s *op, *nop;\n    int             length;\n    struct subid_s  loid[32];\n    struct node    *np, *root = NULL, *oldnp = NULL;\n    struct tree    *tp;\n\n    if ((length = getoid(fp, loid, 32)) == 0) {\n        print_error(\"Bad object identifier\", NULL, CONTINUE);\n        return NULL;\n    }\n\n    /*\n     * Handle numeric-only object identifiers,\n     *  by labelling the first sub-identifier\n     */\n    op = loid;\n    if (!op->label) {\n        if (length == 1) {\n            print_error(\"Attempt to define a root oid\", name, OBJECT);\n            return NULL;\n        }\n        for (tp = tree_head; tp; tp = tp->next_peer)\n            if ((int) tp->subid == op->subid) {\n                op->label = strdup(tp->label);\n                break;\n            }\n    }\n\n    /*\n     * Handle  \"label OBJECT-IDENTIFIER ::= { subid }\"\n     */\n    if (length == 1) {\n        op = loid;\n        np = alloc_node(op->modid);\n        if (np == NULL)\n            return (NULL);\n        np->subid = op->subid;\n        np->label = strdup(name);\n        np->parent = op->label;\n        return np;\n    }\n\n    /*\n     * For each parent-child subid pair in the subid array,\n     * create a node and link it into the node list.\n     */\n    for (count = 0, op = loid, nop = loid + 1; count < (length - 1);\n         count++, op++, nop++) {\n        /*\n         * every node must have parent's name and child's name or number \n         */\n        /*\n         * XX the next statement is always true -- does it matter ?? \n         */\n        if (op->label && (nop->label || (nop->subid != -1))) {\n            np = alloc_node(nop->modid);\n            if (np == NULL)\n                goto err;\n            if (root == NULL)\n                root = np;\n\n            np->parent = strdup(op->label);\n            if (count == (length - 2)) {\n                /*\n                 * The name for this node is the label for this entry \n                 */\n                np->label = strdup(name);\n                if (np->label == NULL)\n                    goto err;\n            } else {\n                if (!nop->label) {\n                    nop->label = (char *) malloc(20 + ANON_LEN);\n                    if (nop->label == NULL)\n                        goto err;\n                    sprintf(nop->label, \"%s%d\", ANON, anonymous++);\n                }\n                np->label = strdup(nop->label);\n            }\n            if (nop->subid != -1)\n                np->subid = nop->subid;\n            else\n                print_error(\"Warning: This entry is pretty silly\",\n                            np->label, CONTINUE);\n\n            /*\n             * set up next entry \n             */\n            if (oldnp)\n                oldnp->next = np;\n            oldnp = np;\n        }                       /* end if(op->label... */\n    }\n\nout:\n    /*\n     * free the loid array \n     */\n    for (count = 0, op = loid; count < length; count++, op++) {\n        if (op->label)\n            free(op->label);\n    }\n\n    return root;\n\nerr:\n    for (; root; root = np) {\n        np = root->next;\n        free_node(root);\n    }\n    goto out;\n}\n\nstatic int\nget_tc(const char *descriptor,\n       int modid,\n       int *tc_index,\n       struct enum_list **ep, struct range_list **rp, char **hint)\n{\n    int             i;\n    struct tc      *tcp;\n\n    i = get_tc_index(descriptor, modid);\n    if (tc_index)\n        *tc_index = i;\n    if (i != -1) {\n        tcp = &tclist[i];\n        if (ep) {\n            free_enums(ep);\n            *ep = copy_enums(tcp->enums);\n        }\n        if (rp) {\n            free_ranges(rp);\n            *rp = copy_ranges(tcp->ranges);\n        }\n        if (hint) {\n            if (*hint)\n                free(*hint);\n            *hint = (tcp->hint ? strdup(tcp->hint) : NULL);\n        }\n        return tcp->type;\n    }\n    return LABEL;\n}\n\n/*\n * return index into tclist of given TC descriptor\n * return -1 if not found\n */\nstatic int\nget_tc_index(const char *descriptor, int modid)\n{\n    int             i;\n    struct tc      *tcp;\n    struct module  *mp;\n    struct module_import *mip;\n\n    /*\n     * Check that the descriptor isn't imported\n     *  by searching the import list\n     */\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == modid)\n            break;\n    if (mp)\n        for (i = 0, mip = mp->imports; i < mp->no_imports; ++i, ++mip) {\n            if (!label_compare(mip->label, descriptor)) {\n                /*\n                 * Found it - so amend the module ID \n                 */\n                modid = mip->modid;\n                break;\n            }\n        }\n\n\n    for (i = 0, tcp = tclist; i < MAXTC; i++, tcp++) {\n        if (tcp->type == 0)\n            break;\n        if (!label_compare(descriptor, tcp->descriptor) &&\n            ((modid == tcp->modid) || (modid == -1))) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n * translate integer tc_index to string identifier from tclist\n * *\n * * Returns pointer to string in table (should not be modified) or NULL\n */\nconst char     *\nget_tc_descriptor(int tc_index)\n{\n    if (tc_index < 0 || tc_index >= MAXTC)\n        return NULL;\n    return (tclist[tc_index].descriptor);\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_GET_TC_DESCRIPTION\n/* used in the perl module */\nconst char     *\nget_tc_description(int tc_index)\n{\n    if (tc_index < 0 || tc_index >= MAXTC)\n        return NULL;\n    return (tclist[tc_index].description);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_GET_TC_DESCRIPTION */\n\n\n/*\n * Parses an enumeration list of the form:\n *        { label(value) label(value) ... }\n * The initial { has already been parsed.\n * Returns NULL on error.\n */\n\nstatic struct enum_list *\nparse_enumlist(FILE * fp, struct enum_list **retp)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    struct enum_list *ep = NULL, **epp = &ep;\n\n    free_enums(retp);\n\n    while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {\n        if (type == RIGHTBRACKET)\n            break;\n        /* some enums use \"deprecated\" to indicate a no longer value label */\n        /* (EG: IP-MIB's IpAddressStatusTC) */\n        if (type == LABEL || type == DEPRECATED) {\n            /*\n             * this is an enumerated label \n             */\n            *epp =\n                (struct enum_list *) calloc(1, sizeof(struct enum_list));\n            if (*epp == NULL)\n                return (NULL);\n            /*\n             * a reasonable approximation for the length \n             */\n            (*epp)->label = strdup(token);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LEFTPAREN) {\n                print_error(\"Expected \\\"(\\\"\", token, type);\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != NUMBER) {\n                print_error(\"Expected integer\", token, type);\n                return NULL;\n            }\n            (*epp)->value = strtol(token, NULL, 10);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != RIGHTPAREN) {\n                print_error(\"Expected \\\")\\\"\", token, type);\n                return NULL;\n            }\n            epp = &(*epp)->next;\n        }\n    }\n    if (type == ENDOFFILE) {\n        print_error(\"Expected \\\"}\\\"\", token, type);\n        return NULL;\n    }\n    *retp = ep;\n    return ep;\n}\n\nstatic struct range_list *\nparse_ranges(FILE * fp, struct range_list **retp)\n{\n    int             low, high;\n    char            nexttoken[MAXTOKEN];\n    int             nexttype;\n    struct range_list *rp = NULL, **rpp = &rp;\n    int             size = 0, taken = 1;\n\n    free_ranges(retp);\n\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    if (nexttype == SIZE) {\n        size = 1;\n        taken = 0;\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        if (nexttype != LEFTPAREN)\n            print_error(\"Expected \\\"(\\\" after SIZE\", nexttoken, nexttype);\n    }\n\n    do {\n        if (!taken)\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        else\n            taken = 0;\n        high = low = strtoul(nexttoken, NULL, 10);\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        if (nexttype == RANGE) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            errno = 0;\n            high = strtoul(nexttoken, NULL, 10);\n            if ( errno == ERANGE ) {\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n                                       NETSNMP_DS_LIB_MIB_WARNINGS))\n                    snmp_log(LOG_WARNING,\n                             \"Warning: Upper bound not handled correctly (%s != %d): At line %d in %s\\n\",\n                                 nexttoken, high, mibLine, File);\n            }\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        *rpp = (struct range_list *) calloc(1, sizeof(struct range_list));\n        if (*rpp == NULL)\n            break;\n        (*rpp)->low = low;\n        (*rpp)->high = high;\n        rpp = &(*rpp)->next;\n\n    } while (nexttype == BAR);\n    if (size) {\n        if (nexttype != RIGHTPAREN)\n            print_error(\"Expected \\\")\\\" after SIZE\", nexttoken, nexttype);\n        nexttype = get_token(fp, nexttoken, nexttype);\n    }\n    if (nexttype != RIGHTPAREN)\n        print_error(\"Expected \\\")\\\"\", nexttoken, nexttype);\n\n    *retp = rp;\n    return rp;\n}\n\n/*\n * Parses an asn type.  Structures are ignored by this parser.\n * Returns NULL on error.\n */\nstatic struct node *\nparse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)\n{\n    int             type, i;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    char           *hint = NULL;\n    char           *descr = NULL;\n    struct tc      *tcp;\n    int             level;\n\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == SEQUENCE || type == CHOICE) {\n        level = 0;\n        while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {\n            if (type == LEFTBRACKET) {\n                level++;\n            } else if (type == RIGHTBRACKET && --level == 0) {\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                return NULL;\n            }\n        }\n        print_error(\"Expected \\\"}\\\"\", token, type);\n        return NULL;\n    } else if (type == LEFTBRACKET) {\n        struct node    *np;\n        int             ch_next = '{';\n        ungetc(ch_next, fp);\n        np = parse_objectid(fp, name);\n        if (np != NULL) {\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n            return np;\n        }\n        return NULL;\n    } else if (type == LEFTSQBRACK) {\n        int             size = 0;\n        do {\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type != ENDOFFILE && type != RIGHTSQBRACK);\n        if (type != RIGHTSQBRACK) {\n            print_error(\"Expected \\\"]\\\"\", token, type);\n            return NULL;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == IMPLICIT)\n            type = get_token(fp, token, MAXTOKEN);\n        *ntype = get_token(fp, ntoken, MAXTOKEN);\n        if (*ntype == LEFTPAREN) {\n            switch (type) {\n            case OCTETSTR:\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (*ntype != SIZE) {\n                    print_error(\"Expected SIZE\", ntoken, *ntype);\n                    return NULL;\n                }\n                size = 1;\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (*ntype != LEFTPAREN) {\n                    print_error(\"Expected \\\"(\\\" after SIZE\", ntoken,\n                                *ntype);\n                    return NULL;\n                }\n                /* FALL THROUGH */\n            case INTEGER:\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                do {\n                    if (*ntype != NUMBER)\n                        print_error(\"Expected NUMBER\", ntoken, *ntype);\n                    *ntype = get_token(fp, ntoken, MAXTOKEN);\n                    if (*ntype == RANGE) {\n                        *ntype = get_token(fp, ntoken, MAXTOKEN);\n                        if (*ntype != NUMBER)\n                            print_error(\"Expected NUMBER\", ntoken, *ntype);\n                        *ntype = get_token(fp, ntoken, MAXTOKEN);\n                    }\n                } while (*ntype == BAR);\n                if (*ntype != RIGHTPAREN) {\n                    print_error(\"Expected \\\")\\\"\", ntoken, *ntype);\n                    return NULL;\n                }\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (size) {\n                    if (*ntype != RIGHTPAREN) {\n                        print_error(\"Expected \\\")\\\" to terminate SIZE\",\n                                    ntoken, *ntype);\n                        return NULL;\n                    }\n                    *ntype = get_token(fp, ntoken, MAXTOKEN);\n                }\n            }\n        }\n        return NULL;\n    } else {\n        if (type == CONVENTION) {\n            while (type != SYNTAX && type != ENDOFFILE) {\n                if (type == DISPLAYHINT) {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != QUOTESTRING) {\n                        print_error(\"DISPLAY-HINT must be string\", token,\n                                    type);\n                    } else {\n                        free(hint);\n                        hint = strdup(token);\n                    }\n                } else if (type == DESCRIPTION &&\n                           netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n                                                  NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n                    if (type != QUOTESTRING) {\n                        print_error(\"DESCRIPTION must be string\", token,\n                                    type);\n                    } else {\n                        free(descr);\n                        descr = strdup(quoted_string_buffer);\n                    }\n                } else\n                    type =\n                        get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == OBJECT) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != IDENTIFIER) {\n                    print_error(\"Expected IDENTIFIER\", token, type);\n                    goto err;\n                }\n                type = OBJID;\n            }\n        } else if (type == OBJECT) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != IDENTIFIER) {\n                print_error(\"Expected IDENTIFIER\", token, type);\n                goto err;\n            }\n            type = OBJID;\n        }\n\n        if (type == LABEL) {\n            type = get_tc(token, current_module, NULL, NULL, NULL, NULL);\n        }\n\n        /*\n         * textual convention \n         */\n        for (i = 0; i < MAXTC; i++) {\n            if (tclist[i].type == 0)\n                break;\n        }\n\n        if (i == MAXTC) {\n            print_error(\"Too many textual conventions\", token, type);\n            goto err;\n        }\n        if (!(type & SYNTAX_MASK)) {\n            print_error(\"Textual convention doesn't map to real type\",\n                        token, type);\n            goto err;\n        }\n        tcp = &tclist[i];\n        tcp->modid = current_module;\n        tcp->descriptor = strdup(name);\n        tcp->hint = hint;\n        tcp->description = descr;\n        tcp->type = type;\n        *ntype = get_token(fp, ntoken, MAXTOKEN);\n        if (*ntype == LEFTPAREN) {\n            tcp->ranges = parse_ranges(fp, &tcp->ranges);\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n        } else if (*ntype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            tcp->enums = parse_enumlist(fp, &tcp->enums);\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n        }\n        return NULL;\n    }\n\nerr:\n    SNMP_FREE(descr);\n    SNMP_FREE(hint);\n    return NULL;\n}\n\n\n/*\n * Parses an OBJECT TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_objecttype(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            nexttoken[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    int             nexttype, tctype;\n    register struct node *np;\n\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != SYNTAX) {\n        print_error(\"Bad format for OBJECT-TYPE\", token, type);\n        return NULL;\n    }\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == OBJECT) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != IDENTIFIER) {\n            print_error(\"Expected IDENTIFIER\", token, type);\n            free_node(np);\n            return NULL;\n        }\n        type = OBJID;\n    }\n    if (type == LABEL) {\n        int             tmp_index;\n        tctype = get_tc(token, current_module, &tmp_index,\n                        &np->enums, &np->ranges, &np->hint);\n        if (tctype == LABEL &&\n            netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS) > 1) {\n            print_error(\"Warning: No known translation for type\", token,\n                        type);\n        }\n        type = tctype;\n        np->tc_index = tmp_index;       /* store TC for later reference */\n    }\n    np->type = type;\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    switch (type) {\n    case SEQUENCE:\n        if (nexttype == OF) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n\n        }\n        break;\n    case INTEGER:\n    case INTEGER32:\n    case UINTEGER32:\n    case UNSIGNED32:\n    case COUNTER:\n    case GAUGE:\n    case BITSTRING:\n    case LABEL:\n        if (nexttype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            np->enums = parse_enumlist(fp, &np->enums);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        } else if (nexttype == LEFTPAREN) {\n            /*\n             * if there is a range list, parse it \n             */\n            np->ranges = parse_ranges(fp, &np->ranges);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        break;\n    case OCTETSTR:\n    case KW_OPAQUE:\n        /*\n         * parse any SIZE specification \n         */\n        if (nexttype == LEFTPAREN) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            if (nexttype == SIZE) {\n                nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                if (nexttype == LEFTPAREN) {\n                    np->ranges = parse_ranges(fp, &np->ranges);\n                    nexttype = get_token(fp, nexttoken, MAXTOKEN);      /* ) */\n                    if (nexttype == RIGHTPAREN) {\n                        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                        break;\n                    }\n                }\n            }\n            print_error(\"Bad SIZE syntax\", token, type);\n            free_node(np);\n            return NULL;\n        }\n        break;\n    case OBJID:\n    case NETADDR:\n    case IPADDR:\n    case TIMETICKS:\n    case NUL:\n    case NSAPADDRESS:\n    case COUNTER64:\n        break;\n    default:\n        print_error(\"Bad syntax\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    if (nexttype == UNITS) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad UNITS\", quoted_string_buffer, type);\n            free_node(np);\n            return NULL;\n        }\n        np->units = strdup(quoted_string_buffer);\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    }\n    if (nexttype != ACCESS) {\n        print_error(\"Should be ACCESS\", nexttoken, nexttype);\n        free_node(np);\n        return NULL;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != READONLY && type != READWRITE && type != WRITEONLY\n        && type != NOACCESS && type != READCREATE && type != ACCNOTIFY) {\n        print_error(\"Bad ACCESS type\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->access = type;\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Should be STATUS\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != MANDATORY && type != CURRENT && type != KW_OPTIONAL &&\n        type != OBSOLETE && type != DEPRECATED) {\n        print_error(\"Bad STATUS\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->status = type;\n    /*\n     * Optional parts of the OBJECT-TYPE macro\n     */\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n\n        case REFERENCE:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case INDEX:\n            if (np->augments) {\n                print_error(\"Cannot have both INDEX and AUGMENTS\", token,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n            np->indexes = getIndexes(fp, &np->indexes);\n            if (np->indexes == NULL) {\n                print_error(\"Bad INDEX list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        case AUGMENTS:\n            if (np->indexes) {\n                print_error(\"Cannot have both INDEX and AUGMENTS\", token,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n            np->indexes = getIndexes(fp, &np->indexes);\n            if (np->indexes == NULL) {\n                print_error(\"Bad AUGMENTS list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            np->augments = strdup(np->indexes->ilabel);\n            free_indexes(&np->indexes);\n            break;\n        case DEFVAL:\n            /*\n             * Mark's defVal section \n             */\n            type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n            if (type != LEFTBRACKET) {\n                print_error(\"Bad DEFAULTVALUE\", quoted_string_buffer,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n\n            {\n                int             level = 1;\n                char            defbuf[512];\n\n                defbuf[0] = 0;\n                while (1) {\n                    type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n                    if ((type == RIGHTBRACKET && --level == 0)\n                        || type == ENDOFFILE)\n                        break;\n                    else if (type == LEFTBRACKET)\n                        level++;\n                    if (type == QUOTESTRING)\n                        strlcat(defbuf, \"\\\\\\\"\", sizeof(defbuf));\n                    strlcat(defbuf, quoted_string_buffer, sizeof(defbuf));\n                    if (type == QUOTESTRING)\n                        strlcat(defbuf, \"\\\\\\\"\", sizeof(defbuf));\n                    strlcat(defbuf, \" \", sizeof(defbuf));\n                }\n\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Bad DEFAULTVALUE\", quoted_string_buffer,\n                                type);\n                    free_node(np);\n                    return NULL;\n                }\n\n                defbuf[strlen(defbuf) - 1] = 0;\n                np->defaultValue = strdup(defbuf);\n            }\n\n            break;\n\n        case NUM_ENTRIES:\n            if (tossObjectIdentifier(fp) != OBJID) {\n                print_error(\"Bad Object Identifier\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n\n        default:\n            print_error(\"Bad format of optional clauses\", token, type);\n            free_node(np);\n            return NULL;\n\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS) {\n        print_error(\"Bad format\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses an OBJECT GROUP macro.\n * Returns 0 on error.\n *\n * Also parses object-identity, since they are similar (ignore STATUS).\n *   - WJH 10/96\n */\nstatic struct node *\nparse_objectgroup(FILE * fp, char *name, int what, struct objgroup **ol)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == what) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LEFTBRACKET) {\n            print_error(\"Expected \\\"{\\\"\", token, type);\n            goto skip;\n        }\n        do {\n            struct objgroup *o;\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Bad identifier\", token, type);\n                goto skip;\n            }\n            o = (struct objgroup *) malloc(sizeof(struct objgroup));\n            if (!o) {\n                print_error(\"Resource failure\", token, type);\n                goto skip;\n            }\n            o->line = mibLine;\n            o->name = strdup(token);\n            o->next = *ol;\n            *ol = o;\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type == COMMA);\n        if (type != RIGHTBRACKET) {\n            print_error(\"Expected \\\"}\\\" after list\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, type);\n    }\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != DEPRECATED && type != OBSOLETE) {\n        print_error(\"Bad STATUS value\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        free_node(np);\n        return NULL;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            free_node(np);\n            return NULL;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE)\n        type = get_token(fp, token, MAXTOKEN);\n\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a NOTIFICATION-TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_notificationDefinition(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n        case REFERENCE:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case OBJECTS:\n            np->varbinds = getVarbinds(fp, &np->varbinds);\n            if (!np->varbinds) {\n                print_error(\"Bad OBJECTS list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        default:\n            /*\n             * NOTHING \n             */\n            break;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a TRAP-TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_trapDefinition(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n        case REFERENCE:\n            /* I'm not sure REFERENCEs are legal in smiv1 traps??? */\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case ENTERPRISE:\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == LEFTBRACKET) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad Trap Format\", token, type);\n                    free_node(np);\n                    return NULL;\n                }\n                np->parent = strdup(token);\n                /*\n                 * Get right bracket \n                 */\n                type = get_token(fp, token, MAXTOKEN);\n            } else if (type == LABEL) {\n                np->parent = strdup(token);\n            } else {\n                free_node(np);\n                return NULL;\n            }\n            break;\n        case VARIABLES:\n            np->varbinds = getVarbinds(fp, &np->varbinds);\n            if (!np->varbinds) {\n                print_error(\"Bad VARIABLES list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        default:\n            /*\n             * NOTHING \n             */\n            break;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n\n    np->label = strdup(name);\n\n    if (type != NUMBER) {\n        print_error(\"Expected a Number\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->subid = strtoul(token, NULL, 10);\n    np->next = alloc_node(current_module);\n    if (np->next == NULL) {\n        free_node(np);\n        return (NULL);\n    }\n\n    /* Catch the syntax error */\n    if (np->parent == NULL) {\n        free_node(np->next);\n        free_node(np);\n        gMibError = MODULE_SYNTAX_ERROR;\n        return (NULL);\n    }\n\n    np->next->parent = np->parent;\n    np->parent = (char *) malloc(strlen(np->parent) + 2);\n    if (np->parent == NULL) {\n        free_node(np->next);\n        free_node(np);\n        return (NULL);\n    }\n    strcpy(np->parent, np->next->parent);\n    strcat(np->parent, \"#\");\n    np->next->label = strdup(np->parent);\n    return np;\n}\n\n\n/*\n * Parses a compliance macro\n * Returns 0 on error.\n */\nstatic int\neat_syntax(FILE * fp, char *token, int maxtoken)\n{\n    int             type, nexttype;\n    struct node    *np = alloc_node(current_module);\n    char            nexttoken[MAXTOKEN];\n\n    if (!np)\n\treturn 0;\n\n    type = get_token(fp, token, maxtoken);\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    switch (type) {\n    case INTEGER:\n    case INTEGER32:\n    case UINTEGER32:\n    case UNSIGNED32:\n    case COUNTER:\n    case GAUGE:\n    case BITSTRING:\n    case LABEL:\n        if (nexttype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            np->enums = parse_enumlist(fp, &np->enums);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        } else if (nexttype == LEFTPAREN) {\n            /*\n             * if there is a range list, parse it \n             */\n            np->ranges = parse_ranges(fp, &np->ranges);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        break;\n    case OCTETSTR:\n    case KW_OPAQUE:\n        /*\n         * parse any SIZE specification \n         */\n        if (nexttype == LEFTPAREN) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            if (nexttype == SIZE) {\n                nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                if (nexttype == LEFTPAREN) {\n                    np->ranges = parse_ranges(fp, &np->ranges);\n                    nexttype = get_token(fp, nexttoken, MAXTOKEN);      /* ) */\n                    if (nexttype == RIGHTPAREN) {\n                        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                        break;\n                    }\n                }\n            }\n            print_error(\"Bad SIZE syntax\", token, type);\n            free_node(np);\n            return nexttype;\n        }\n        break;\n    case OBJID:\n    case NETADDR:\n    case IPADDR:\n    case TIMETICKS:\n    case NUL:\n    case NSAPADDRESS:\n    case COUNTER64:\n        break;\n    default:\n        print_error(\"Bad syntax\", token, type);\n        free_node(np);\n        return nexttype;\n    }\n    free_node(np);\n    return nexttype;\n}\n\nstatic int\ncompliance_lookup(const char *name, int modid)\n{\n    if (modid == -1) {\n        struct objgroup *op =\n            (struct objgroup *) malloc(sizeof(struct objgroup));\n        if (!op)\n            return 0;\n        op->next = objgroups;\n        op->name = strdup(name);\n        op->line = mibLine;\n        objgroups = op;\n        return 1;\n    } else\n        return find_tree_node(name, modid) != NULL;\n}\n\nstatic struct node *\nparse_compliance(FILE * fp, char *name)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != DEPRECATED && type != OBSOLETE) {\n        print_error(\"Bad STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS))\n        np->description = strdup(quoted_string_buffer);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            goto skip;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != MODULE) {\n        print_error(\"Expected MODULE\", token, type);\n        goto skip;\n    }\n    while (type == MODULE) {\n        int             modid = -1;\n        char            modname[MAXTOKEN];\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == LABEL\n            && strcmp(token, module_name(current_module, modname))) {\n            modid = read_module_internal(token);\n            if (modid != MODULE_LOADED_OK\n                && modid != MODULE_ALREADY_LOADED) {\n                print_error(\"Unknown module\", token, type);\n                goto skip;\n            }\n            modid = which_module(token);\n            type = get_token(fp, token, MAXTOKEN);\n        }\n        if (type == MANDATORYGROUPS) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LEFTBRACKET) {\n                print_error(\"Expected \\\"{\\\"\", token, type);\n                goto skip;\n            }\n            do {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad group name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n            } while (type == COMMA);\n            if (type != RIGHTBRACKET) {\n                print_error(\"Expected \\\"}\\\"\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n        while (type == GROUP || type == OBJECT) {\n            if (type == GROUP) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad group name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n            } else {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad object name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n                if (type == SYNTAX)\n                    type = eat_syntax(fp, token, MAXTOKEN);\n                if (type == WRSYNTAX)\n                    type = eat_syntax(fp, token, MAXTOKEN);\n                if (type == MINACCESS) {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != NOACCESS && type != ACCNOTIFY\n                        && type != READONLY && type != WRITEONLY\n                        && type != READCREATE && type != READWRITE) {\n                        print_error(\"Bad MIN-ACCESS spec\", token, type);\n                        goto skip;\n                    }\n                    type = get_token(fp, token, MAXTOKEN);\n                }\n            }\n            if (type != DESCRIPTION) {\n                print_error(\"Expected DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n    }\n  skip:\n    while (type != EQUALS && type != ENDOFFILE)\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n\n    return merge_parse_objectid(np, fp, name);\n}\n\n\n/*\n * Parses a capabilities macro\n * Returns 0 on error.\n */\nstatic struct node *\nparse_capabilities(FILE * fp, char *name)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != PRODREL) {\n        print_error(\"Expected PRODUCT-RELEASE\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Expected STRING after PRODUCT-RELEASE\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != OBSOLETE) {\n        print_error(\"STATUS should be current or obsolete\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            goto skip;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, type);\n    }\n    while (type == SUPPORTS) {\n        int             modid;\n        struct tree    *tp;\n\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LABEL) {\n            print_error(\"Bad module name\", token, type);\n            goto skip;\n        }\n        modid = read_module_internal(token);\n        if (modid != MODULE_LOADED_OK && modid != MODULE_ALREADY_LOADED) {\n            print_error(\"Module not found\", token, type);\n            goto skip;\n        }\n        modid = which_module(token);\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != INCLUDES) {\n            print_error(\"Expected INCLUDES\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LEFTBRACKET) {\n            print_error(\"Expected \\\"{\\\"\", token, type);\n            goto skip;\n        }\n        do {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Expected group name\", token, type);\n                goto skip;\n            }\n            tp = find_tree_node(token, modid);\n            if (!tp)\n                print_error(\"Group not found in module\", token, type);\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type == COMMA);\n        if (type != RIGHTBRACKET) {\n            print_error(\"Expected \\\"}\\\" after group list\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        while (type == VARIATION) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Bad object name\", token, type);\n                goto skip;\n            }\n            tp = find_tree_node(token, modid);\n            if (!tp)\n                print_error(\"Object not found in module\", token, type);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == SYNTAX) {\n                type = eat_syntax(fp, token, MAXTOKEN);\n            }\n            if (type == WRSYNTAX) {\n                type = eat_syntax(fp, token, MAXTOKEN);\n            }\n            if (type == ACCESS) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != ACCNOTIFY && type != READONLY\n                    && type != READWRITE && type != READCREATE\n                    && type != WRITEONLY && type != NOTIMPL) {\n                    print_error(\"Bad ACCESS\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type == CREATEREQ) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LEFTBRACKET) {\n                    print_error(\"Expected \\\"{\\\"\", token, type);\n                    goto skip;\n                }\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != LABEL) {\n                        print_error(\"Bad object name in list\", token,\n                                    type);\n                        goto skip;\n                    }\n                    type = get_token(fp, token, MAXTOKEN);\n                } while (type == COMMA);\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Expected \\\"}\\\" after list\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type == DEFVAL) {\n                int             level = 1;\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LEFTBRACKET) {\n                    print_error(\"Expected \\\"{\\\" after DEFVAL\", token,\n                                type);\n                    goto skip;\n                }\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type == LEFTBRACKET)\n                        level++;\n                    else if (type == RIGHTBRACKET)\n                        level--;\n                } while ((type != RIGHTBRACKET || level != 0)\n                         && type != ENDOFFILE);\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Missing \\\"}\\\" after DEFVAL\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type != DESCRIPTION) {\n                print_error(\"Expected DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a module identity macro\n * Returns 0 on error.\n */\nstatic void\ncheck_utc(const char *utc)\n{\n    int             len, year, month, day, hour, minute;\n\n    len = strlen(utc);\n    if (utc[len - 1] != 'Z' && utc[len - 1] != 'z') {\n        print_error(\"Timestamp should end with Z\", utc, QUOTESTRING);\n        return;\n    }\n    if (len == 11) {\n        len =\n            sscanf(utc, \"%2d%2d%2d%2d%2dZ\", &year, &month, &day, &hour,\n                   &minute);\n        year += 1900;\n    } else if (len == 13)\n        len =\n            sscanf(utc, \"%4d%2d%2d%2d%2dZ\", &year, &month, &day, &hour,\n                   &minute);\n    else {\n        print_error(\"Bad timestamp format (11 or 13 characters)\",\n                    utc, QUOTESTRING);\n        return;\n    }\n    if (len != 5) {\n        print_error(\"Bad timestamp format\", utc, QUOTESTRING);\n        return;\n    }\n    if (month < 1 || month > 12)\n        print_error(\"Bad month in timestamp\", utc, QUOTESTRING);\n    if (day < 1 || day > 31)\n        print_error(\"Bad day in timestamp\", utc, QUOTESTRING);\n    if (hour < 0 || hour > 23)\n        print_error(\"Bad hour in timestamp\", utc, QUOTESTRING);\n    if (minute < 0 || minute > 59)\n        print_error(\"Bad minute in timestamp\", utc, QUOTESTRING);\n}\n\nstatic struct node *\nparse_moduleIdentity(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != LASTUPDATED) {\n        print_error(\"Expected LAST-UPDATED\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Need STRING for LAST-UPDATED\", token, type);\n        goto skip;\n    }\n    check_utc(token);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != ORGANIZATION) {\n        print_error(\"Expected ORGANIZATION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad ORGANIZATION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CONTACTINFO) {\n        print_error(\"Expected CONTACT-INFO\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad CONTACT-INFO\", quoted_string_buffer, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    while (type == REVISION) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REVISION\", token, type);\n            goto skip;\n        }\n        check_utc(token);\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != DESCRIPTION) {\n            print_error(\"Expected DESCRIPTION\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n\n/*\n * Parses a MACRO definition\n * Expect BEGIN, discard everything to end.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_macro(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    struct node    *np;\n    int             iLine = mibLine;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, sizeof(token));\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != EQUALS) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n    while (type != BEGIN && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != BEGIN) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n    while (type != END && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != END) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n\n    if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n        snmp_log(LOG_WARNING,\n                 \"%s MACRO (lines %d..%d parsed and ignored).\\n\", name,\n                 iLine, mibLine);\n    }\n\n    return np;\n}\n\n/*\n * Parses a module import clause\n *   loading any modules referenced\n */\nstatic void\nparse_imports(FILE * fp)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            modbuf[256];\n#define MAX_IMPORTS\t256\n    struct module_import import_list[MAX_IMPORTS];\n    int             this_module;\n    struct module  *mp;\n\n    int             import_count = 0;   /* Total number of imported descriptors */\n    int             i = 0, old_i;       /* index of first import from each module */\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    /*\n     * Parse the IMPORTS clause\n     */\n    while (type != SEMI && type != ENDOFFILE) {\n        if (type == LABEL) {\n            if (import_count == MAX_IMPORTS) {\n                print_error(\"Too many imported symbols\", token, type);\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                } while (type != SEMI && type != ENDOFFILE);\n                return;\n            }\n            import_list[import_count++].label = strdup(token);\n        } else if (type == FROM) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (import_count == i) {    /* All imports are handled internally */\n                type = get_token(fp, token, MAXTOKEN);\n                continue;\n            }\n            this_module = which_module(token);\n\n            for (old_i = i; i < import_count; ++i)\n                import_list[i].modid = this_module;\n\n            /*\n             * Recursively read any pre-requisite modules\n             */\n            if (read_module_internal(token) == MODULE_NOT_FOUND) {\n\t\tint found = 0;\n                for (; old_i < import_count; ++old_i) {\n                    found += read_import_replacements(token, &import_list[old_i]);\n                }\n\t\tif (!found)\n\t\t    print_module_not_found(token);\n            }\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    /* Initialize modid in case the module name was missing. */\n    for (; i < import_count; ++i)\n        import_list[i].modid = -1;\n\n    /*\n     * Save the import information\n     *   in the global module table\n     */\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == current_module) {\n            if (import_count == 0)\n                return;\n            if (mp->imports && (mp->imports != root_imports)) {\n                /*\n                 * this can happen if all modules are in one source file. \n                 */\n                for (i = 0; i < mp->no_imports; ++i) {\n                    DEBUGMSGTL((\"parse-mibs\",\n                                \"#### freeing Module %d '%s' %d\\n\",\n                                mp->modid, mp->imports[i].label,\n                                mp->imports[i].modid));\n                    free((char *) mp->imports[i].label);\n                }\n                free((char *) mp->imports);\n            }\n            mp->imports = (struct module_import *)\n                calloc(import_count, sizeof(struct module_import));\n            if (mp->imports == NULL)\n                return;\n            for (i = 0; i < import_count; ++i) {\n                mp->imports[i].label = import_list[i].label;\n                mp->imports[i].modid = import_list[i].modid;\n                DEBUGMSGTL((\"parse-mibs\",\n                            \"#### adding Module %d '%s' %d\\n\", mp->modid,\n                            mp->imports[i].label, mp->imports[i].modid));\n            }\n            mp->no_imports = import_count;\n            return;\n        }\n\n    /*\n     * Shouldn't get this far\n     */\n    print_module_not_found(module_name(current_module, modbuf));\n    return;\n}\n\n\n\n/*\n * MIB module handling routines\n */\n\nstatic void\ndump_module_list(void)\n{\n    struct module  *mp = module_head;\n\n    DEBUGMSGTL((\"parse-mibs\", \"Module list:\\n\"));\n    while (mp) {\n        DEBUGMSGTL((\"parse-mibs\", \"  %s %d %s %d\\n\", mp->name, mp->modid,\n                    mp->file, mp->no_imports));\n        mp = mp->next;\n    }\n}\n\nint\nwhich_module(const char *name)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name))\n            return (mp->modid);\n\n    DEBUGMSGTL((\"parse-mibs\", \"Module %s not found\\n\", name));\n    return (-1);\n}\n\n/*\n * module_name - copy module name to user buffer, return ptr to same.\n */\nchar           *\nmodule_name(int modid, char *cp)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == modid) {\n            strcpy(cp, mp->name);\n            return (cp);\n        }\n\n    if (modid != -1) DEBUGMSGTL((\"parse-mibs\", \"Module %d not found\\n\", modid));\n    sprintf(cp, \"#%d\", modid);\n    return (cp);\n}\n\n/*\n *  Backwards compatability\n *  Read newer modules that replace the one specified:-\n *      either all of them (read_module_replacements),\n *      or those relating to a specified identifier (read_import_replacements)\n *      plus an interface to add new replacement requirements\n */\nnetsnmp_feature_child_of(parse_add_module_replacement, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_ADD_MODULE_REPLACEMENT\nvoid\nadd_module_replacement(const char *old_module,\n                       const char *new_module_name,\n                       const char *tag, int len)\n{\n    struct module_compatability *mcp;\n\n    mcp = (struct module_compatability *)\n        calloc(1, sizeof(struct module_compatability));\n    if (mcp == NULL)\n        return;\n\n    mcp->old_module = strdup(old_module);\n    mcp->new_module = strdup(new_module_name);\n    if (tag)\n        mcp->tag = strdup(tag);\n    mcp->tag_len = len;\n\n    mcp->next = module_map_head;\n    module_map_head = mcp;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_ADD_MODULE_REPLACEMENT */\n\nstatic int\nread_module_replacements(const char *name)\n{\n    struct module_compatability *mcp;\n\n    for (mcp = module_map_head; mcp; mcp = mcp->next) {\n        if (!label_compare(mcp->old_module, name)) {\n            if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                snmp_log(LOG_WARNING,\n                         \"Loading replacement module %s for %s (%s)\\n\",\n                         mcp->new_module, name, File);\n\t    }\n            (void) netsnmp_read_module(mcp->new_module);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic int\nread_import_replacements(const char *old_module_name,\n                         struct module_import *identifier)\n{\n    struct module_compatability *mcp;\n\n    /*\n     * Look for matches first\n     */\n    for (mcp = module_map_head; mcp; mcp = mcp->next) {\n        if (!label_compare(mcp->old_module, old_module_name)) {\n\n            if (                /* exact match */\n                   (mcp->tag_len == 0 &&\n                    (mcp->tag == NULL ||\n                     !label_compare(mcp->tag, identifier->label))) ||\n                   /*\n                    * prefix match \n                    */\n                   (mcp->tag_len != 0 &&\n                    !strncmp(mcp->tag, identifier->label, mcp->tag_len))\n                ) {\n\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Importing %s from replacement module %s instead of %s (%s)\\n\",\n                             identifier->label, mcp->new_module,\n                             old_module_name, File);\n\t\t}\n                (void) netsnmp_read_module(mcp->new_module);\n                identifier->modid = which_module(mcp->new_module);\n                return 1;         /* finished! */\n            }\n        }\n    }\n\n    /*\n     * If no exact match, load everything relevant\n     */\n    return read_module_replacements(old_module_name);\n}\n\n\n/*\n *  Read in the named module\n *      Returns the root of the whole tree\n *      (by analogy with 'read_mib')\n */\nstatic int\nread_module_internal(const char *name)\n{\n    struct module  *mp;\n    FILE           *fp;\n    struct node    *np;\n\n    netsnmp_init_mib_internals();\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            const char     *oldFile = File;\n            int             oldLine = mibLine;\n            int             oldModule = current_module;\n\n            if (mp->no_imports != -1) {\n                DEBUGMSGTL((\"parse-mibs\", \"Module %s already loaded\\n\",\n                            name));\n                return MODULE_ALREADY_LOADED;\n            }\n            if ((fp = fopen(mp->file, \"r\")) == NULL) {\n                int rval;\n                if (errno == ENOTDIR || errno == ENOENT)\n                    rval = MODULE_NOT_FOUND;\n                else\n                    rval = MODULE_LOAD_FAILED;\n                snmp_log_perror(mp->file);\n                return rval;\n            }\n#ifdef HAVE_FLOCKFILE\n            flockfile(fp);\n#endif\n            mp->no_imports = 0; /* Note that we've read the file */\n            File = mp->file;\n            mibLine = 1;\n            current_module = mp->modid;\n            /*\n             * Parse the file\n             */\n            np = parse(fp, NULL);\n#ifdef HAVE_FUNLOCKFILE\n            funlockfile(fp);\n#endif\n            fclose(fp);\n            File = oldFile;\n            mibLine = oldLine;\n            current_module = oldModule;\n            if ((np == NULL) && (gMibError == MODULE_SYNTAX_ERROR) )\n                return MODULE_SYNTAX_ERROR;\n            return MODULE_LOADED_OK;\n        }\n\n    return MODULE_NOT_FOUND;\n}\n\nvoid\nadopt_orphans(void)\n{\n    struct node    *np, *onp;\n    struct tree    *tp;\n    int             i, adopted = 1;\n\n    if (!orphan_nodes)\n        return;\n    init_node_hash(orphan_nodes);\n    orphan_nodes = NULL;\n\n    while (adopted) {\n        adopted = 0;\n        for (i = 0; i < NHASHSIZE; i++)\n            if (nbuckets[i]) {\n                for (np = nbuckets[i]; np != NULL; np = np->next) {\n                    tp = find_tree_node(np->parent, -1);\n\t\t    if (tp) {\n\t\t\tdo_subtree(tp, &np);\n\t\t\tadopted = 1;\n                        /*\n                         * if do_subtree adopted the entire bucket, stop\n                         */\n                        if(NULL == nbuckets[i])\n                            break;\n\n                        /*\n                         * do_subtree may modify nbuckets, and if np\n                         * was adopted, np->next probably isn't an orphan\n                         * anymore. if np is still in the bucket (do_subtree\n                         * didn't adopt it) keep on plugging. otherwise\n                         * start over, at the top of the bucket.\n                         */\n                        for(onp = nbuckets[i]; onp; onp = onp->next)\n                            if(onp == np)\n                                break;\n                        if(NULL == onp) { /* not in the list */\n                            np = nbuckets[i]; /* start over */\n                        }\n\t\t    }\n\t\t}\n            }\n    }\n\n    /*\n     * Report on outstanding orphans\n     *    and link them back into the orphan list\n     */\n    for (i = 0; i < NHASHSIZE; i++)\n        if (nbuckets[i]) {\n            if (orphan_nodes)\n                onp = np->next = nbuckets[i];\n            else\n                onp = orphan_nodes = nbuckets[i];\n            nbuckets[i] = NULL;\n            while (onp) {\n                char            modbuf[256];\n                snmp_log(LOG_WARNING,\n                         \"Cannot adopt OID in %s: %s ::= { %s %ld }\\n\",\n                         module_name(onp->modid, modbuf),\n                         (onp->label ? onp->label : \"<no label>\"),\n                         (onp->parent ? onp->parent : \"<no parent>\"),\n                         onp->subid);\n\n                np = onp;\n                onp = onp->next;\n            }\n        }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nstruct tree    *\nread_module(const char *name)\n{\n    return netsnmp_read_module(name);\n}\n#endif\n\nstruct tree    *\nnetsnmp_read_module(const char *name)\n{\n    int status = 0;\n    status = read_module_internal(name);\n\n    if (status == MODULE_NOT_FOUND) {\n        if (!read_module_replacements(name))\n            print_module_not_found(name);\n    } else if (status == MODULE_SYNTAX_ERROR) {\n        gMibError = 0;\n        gLoop = 1;\n\n        strncat(gMibNames, \" \", sizeof(gMibNames) - strlen(gMibNames) - 1);\n        strncat(gMibNames, name, sizeof(gMibNames) - strlen(gMibNames) - 1);\n    }\n\n    return tree_head;\n}\n\n/*\n * Prototype definition \n */\nvoid            unload_module_by_ID(int modID, struct tree *tree_top);\n\nvoid\nunload_module_by_ID(int modID, struct tree *tree_top)\n{\n    struct tree    *tp, *next;\n    int             i;\n\n    for (tp = tree_top; tp; tp = next) {\n        /*\n         * Essentially, this is equivalent to the code fragment:\n         *      if (tp->modID == modID)\n         *        tp->number_modules--;\n         * but handles one tree node being part of several modules,\n         * and possible multiple copies of the same module ID.\n         */\n        int             nmod = tp->number_modules;\n        if (nmod > 0) {         /* in some module */\n            /*\n             * Remove all copies of this module ID\n             */\n            int             cnt = 0, *pi1, *pi2 = tp->module_list;\n            for (i = 0, pi1 = pi2; i < nmod; i++, pi2++) {\n                if (*pi2 == modID)\n                    continue;\n                cnt++;\n                *pi1++ = *pi2;\n            }\n            if (nmod != cnt) {  /* in this module */\n                /*\n                 * if ( (nmod - cnt) > 1)\n                 * printf(\"Dup modid %d,  %d times, '%s'\\n\", tp->modid, (nmod-cnt), tp->label); fflush(stdout); ?* XXDEBUG \n                 */\n                tp->number_modules = cnt;\n                switch (cnt) {\n                case 0:\n                    tp->module_list[0] = -1;    /* Mark unused, */\n\t\t    /* FALL THROUGH */\n\n                case 1:        /* save the remaining module */\n                    if (&(tp->modid) != tp->module_list) {\n                        tp->modid = tp->module_list[0];\n                        free(tp->module_list);\n                        tp->module_list = &(tp->modid);\n                    }\n                    break;\n\n                default:\n                    break;\n                }\n            }                   /* if tree node is in this module */\n        }\n        /*\n         * if tree node is in some module \n         */\n        next = tp->next_peer;\n\n\n        /*\n         *  OK - that's dealt with *this* node.\n         *    Now let's look at the children.\n         *    (Isn't recursion wonderful!)\n         */\n        if (tp->child_list)\n            unload_module_by_ID(modID, tp->child_list);\n\n\n        if (tp->number_modules == 0) {\n            /*\n             * This node isn't needed any more (except perhaps\n             * for the sake of the children) \n             */\n            if (tp->child_list == NULL) {\n                unlink_tree(tp);\n                free_tree(tp);\n            } else {\n                free_partial_tree(tp, TRUE);\n            }\n        }\n    }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nint\nunload_module(const char *name)\n{\n    return netsnmp_unload_module(name);\n}\n#endif\n\nint\nnetsnmp_unload_module(const char *name)\n{\n    struct module  *mp;\n    int             modID = -1;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            modID = mp->modid;\n            break;\n        }\n\n    if (modID == -1) {\n        DEBUGMSGTL((\"unload-mib\", \"Module %s not found to unload\\n\",\n                    name));\n        return MODULE_NOT_FOUND;\n    }\n    unload_module_by_ID(modID, tree_head);\n    mp->no_imports = -1;        /* mark as unloaded */\n    return MODULE_LOADED_OK;    /* Well, you know what I mean! */\n}\n\n/*\n * Clear module map, tree nodes, textual convention table.\n */\nvoid\nunload_all_mibs(void)\n{\n    struct module  *mp;\n    struct module_compatability *mcp;\n    struct tc      *ptc;\n    unsigned int    i;\n\n    for (mcp = module_map_head; mcp; mcp = module_map_head) {\n        if (mcp == module_map)\n            break;\n        module_map_head = mcp->next;\n        if (mcp->tag) free(NETSNMP_REMOVE_CONST(char *, mcp->tag));\n        free(NETSNMP_REMOVE_CONST(char *, mcp->old_module));\n        free(NETSNMP_REMOVE_CONST(char *, mcp->new_module));\n        free(mcp);\n    }\n\n    for (mp = module_head; mp; mp = module_head) {\n        struct module_import *mi = mp->imports;\n        if (mi) {\n            for (i = 0; i < (unsigned int)mp->no_imports; ++i) {\n                SNMP_FREE((mi + i)->label);\n            }\n            mp->no_imports = 0;\n            if (mi == root_imports)\n                memset(mi, 0, sizeof(*mi));\n            else\n                free(mi);\n        }\n\n        unload_module_by_ID(mp->modid, tree_head);\n        module_head = mp->next;\n        free(mp->name);\n        free(mp->file);\n        free(mp);\n    }\n    unload_module_by_ID(-1, tree_head);\n    /*\n     * tree nodes are cleared \n     */\n\n    for (i = 0, ptc = tclist; i < MAXTC; i++, ptc++) {\n        if (ptc->type == 0)\n            continue;\n        free_enums(&ptc->enums);\n        free_ranges(&ptc->ranges);\n        free(ptc->descriptor);\n        if (ptc->hint)\n            free(ptc->hint);\n        if (ptc->description)\n            free(ptc->description);\n    }\n    memset(tclist, 0, MAXTC * sizeof(struct tc));\n\n    memset(buckets, 0, sizeof(buckets));\n    memset(nbuckets, 0, sizeof(nbuckets));\n    memset(tbuckets, 0, sizeof(tbuckets));\n\n    for (i = 0; i < sizeof(root_imports) / sizeof(root_imports[0]); i++) {\n        SNMP_FREE(root_imports[i].label);\n    }\n\n    max_module = 0;\n    current_module = 0;\n    module_map_head = NULL;\n    SNMP_FREE(last_err_module);\n}\n\nstatic void\nnew_module(const char *name, const char *file)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            DEBUGMSGTL((\"parse-mibs\", \"  Module %s already noted\\n\", name));\n            /*\n             * Not the same file \n             */\n            if (label_compare(mp->file, file)) {\n                DEBUGMSGTL((\"parse-mibs\", \"    %s is now in %s\\n\",\n                            name, file));\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Warning: Module %s was in %s now is %s\\n\",\n                             name, mp->file, file);\n\t\t}\n\n                /*\n                 * Use the new one in preference \n                 */\n                free(mp->file);\n                mp->file = strdup(file);\n            }\n            return;\n        }\n\n    /*\n     * Add this module to the list \n     */\n    DEBUGMSGTL((\"parse-mibs\", \"  Module %d %s is in %s\\n\", max_module,\n                name, file));\n    mp = (struct module *) calloc(1, sizeof(struct module));\n    if (mp == NULL)\n        return;\n    mp->name = strdup(name);\n    mp->file = strdup(file);\n    mp->imports = NULL;\n    mp->no_imports = -1;        /* Not yet loaded */\n    mp->modid = max_module;\n    ++max_module;\n\n    mp->next = module_head;     /* Or add to the *end* of the list? */\n    module_head = mp;\n}\n\n\nstatic void\nscan_objlist(struct node *root, struct module *mp, struct objgroup *list, const char *error)\n{\n    int             oLine = mibLine;\n\n    while (list) {\n        struct objgroup *gp = list;\n        struct node    *np;\n        list = list->next;\n        np = root;\n        while (np)\n            if (label_compare(np->label, gp->name))\n                np = np->next;\n            else\n                break;\n        if (!np) {\n\t    int i;\n\t    struct module_import *mip;\n\t    /* if not local, check if it was IMPORTed */\n\t    for (i = 0, mip = mp->imports; i < mp->no_imports; i++, mip++)\n\t\tif (strcmp(mip->label, gp->name) == 0)\n\t\t    break;\n\t    if (i == mp->no_imports) {\n\t\tmibLine = gp->line;\n\t\tprint_error(error, gp->name, QUOTESTRING);\n\t    }\n        }\n        free(gp->name);\n        free(gp);\n    }\n    mibLine = oLine;\n}\n\n/*\n * Parses a mib file and returns a linked list of nodes found in the file.\n * Returns NULL on error.\n */\nstatic struct node *\nparse(FILE * fp, struct node *root)\n{\n#ifdef TEST\n    extern void     xmalloc_stats(FILE *);\n#endif\n    char            token[MAXTOKEN];\n    char            name[MAXTOKEN+1];\n    int             type = LABEL;\n    int             lasttype = LABEL;\n\n#define BETWEEN_MIBS          1\n#define IN_MIB                2\n    int             state = BETWEEN_MIBS;\n    struct node    *np, *nnp;\n    struct objgroup *oldgroups = NULL, *oldobjects = NULL, *oldnotifs =\n        NULL;\n\n    DEBUGMSGTL((\"parse-file\", \"Parsing file:  %s...\\n\", File));\n\n    if (last_err_module)\n        free(last_err_module);\n    last_err_module = NULL;\n\n    np = root;\n    if (np != NULL) {\n        /*\n         * now find end of chain \n         */\n        while (np->next)\n            np = np->next;\n    }\n\n    while (type != ENDOFFILE) {\n        if (lasttype == CONTINUE)\n            lasttype = type;\n        else\n            type = lasttype = get_token(fp, token, MAXTOKEN);\n\n        switch (type) {\n        case END:\n            if (state != IN_MIB) {\n                print_error(\"Error, END before start of MIB\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            } else {\n                struct module  *mp;\n#ifdef TEST\n                printf(\"\\nNodes for Module %s:\\n\", name);\n                print_nodes(stdout, root);\n#endif\n                for (mp = module_head; mp; mp = mp->next)\n                    if (mp->modid == current_module)\n                        break;\n                scan_objlist(root, mp, objgroups, \"Undefined OBJECT-GROUP\");\n                scan_objlist(root, mp, objects, \"Undefined OBJECT\");\n                scan_objlist(root, mp, notifs, \"Undefined NOTIFICATION\");\n                objgroups = oldgroups;\n                objects = oldobjects;\n                notifs = oldnotifs;\n                do_linkup(mp, root);\n                np = root = NULL;\n            }\n            state = BETWEEN_MIBS;\n#ifdef TEST\n            if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                /* xmalloc_stats(stderr); */\n\t    }\n#endif\n            continue;\n        case IMPORTS:\n            parse_imports(fp);\n            continue;\n        case EXPORTS:\n            while (type != SEMI && type != ENDOFFILE)\n                type = get_token(fp, token, MAXTOKEN);\n            continue;\n        case LABEL:\n        case INTEGER:\n        case INTEGER32:\n        case UINTEGER32:\n        case UNSIGNED32:\n        case COUNTER:\n        case COUNTER64:\n        case GAUGE:\n        case IPADDR:\n        case NETADDR:\n        case NSAPADDRESS:\n        case OBJSYNTAX:\n        case APPSYNTAX:\n        case SIMPLESYNTAX:\n        case OBJNAME:\n        case NOTIFNAME:\n        case KW_OPAQUE:\n        case TIMETICKS:\n            break;\n        case ENDOFFILE:\n            continue;\n        default:\n            strlcpy(name, token, sizeof(name));\n            type = get_token(fp, token, MAXTOKEN);\n            nnp = NULL;\n            if (type == MACRO) {\n                nnp = parse_macro(fp, name);\n                if (nnp == NULL) {\n                    print_error(\"Bad parse of MACRO\", NULL, type);\n                    gMibError = MODULE_SYNTAX_ERROR;\n                    /*\n                     * return NULL;\n                     */\n                }\n                free_node(nnp); /* IGNORE */\n                nnp = NULL;\n            } else\n                print_error(name, \"is a reserved word\", lasttype);\n            continue;           /* see if we can parse the rest of the file */\n        }\n        strlcpy(name, token, sizeof(name));\n        type = get_token(fp, token, MAXTOKEN);\n        nnp = NULL;\n\n        /*\n         * Handle obsolete method to assign an object identifier to a\n         * module\n         */\n        if (lasttype == LABEL && type == LEFTBRACKET) {\n            while (type != RIGHTBRACKET && type != ENDOFFILE)\n                type = get_token(fp, token, MAXTOKEN);\n            if (type == ENDOFFILE) {\n                print_error(\"Expected \\\"}\\\"\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n\n        switch (type) {\n        case DEFINITIONS:\n            if (state != BETWEEN_MIBS) {\n                print_error(\"Error, nested MIBS\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            state = IN_MIB;\n            current_module = which_module(name);\n            oldgroups = objgroups;\n            objgroups = NULL;\n            oldobjects = objects;\n            objects = NULL;\n            oldnotifs = notifs;\n            notifs = NULL;\n            if (current_module == -1) {\n                new_module(name, File);\n                current_module = which_module(name);\n            }\n            DEBUGMSGTL((\"parse-mibs\", \"Parsing MIB: %d %s\\n\",\n                        current_module, name));\n            while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE)\n                if (type == BEGIN)\n                    break;\n            break;\n        case OBJTYPE:\n            nnp = parse_objecttype(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJGROUP:\n            nnp = parse_objectgroup(fp, name, OBJECTS, &objects);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-GROUP\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case NOTIFGROUP:\n            nnp = parse_objectgroup(fp, name, NOTIFICATIONS, &notifs);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of NOTIFICATION-GROUP\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case TRAPTYPE:\n            nnp = parse_trapDefinition(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of TRAP-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case NOTIFTYPE:\n            nnp = parse_notificationDefinition(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of NOTIFICATION-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case COMPLIANCE:\n            nnp = parse_compliance(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MODULE-COMPLIANCE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case AGENTCAP:\n            nnp = parse_capabilities(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of AGENT-CAPABILITIES\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case MACRO:\n            nnp = parse_macro(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MACRO\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                /*\n                 * return NULL;\n                 */\n            }\n            free_node(nnp);     /* IGNORE */\n            nnp = NULL;\n            break;\n        case MODULEIDENTITY:\n            nnp = parse_moduleIdentity(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MODULE-IDENTITY\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJIDENTITY:\n            nnp = parse_objectgroup(fp, name, OBJECTS, &objects);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-IDENTITY\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJECT:\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != IDENTIFIER) {\n                print_error(\"Expected IDENTIFIER\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != EQUALS) {\n                print_error(\"Expected \\\"::=\\\"\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            nnp = parse_objectid(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT IDENTIFIER\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case EQUALS:\n            nnp = parse_asntype(fp, name, &type, token);\n            lasttype = CONTINUE;\n            break;\n        case ENDOFFILE:\n            break;\n        default:\n            print_error(\"Bad operator\", token, type);\n            gMibError = MODULE_SYNTAX_ERROR;\n            return NULL;\n        }\n        if (nnp) {\n            if (np)\n                np->next = nnp;\n            else\n                np = root = nnp;\n            while (np->next)\n                np = np->next;\n            if (np->type == TYPE_OTHER)\n                np->type = type;\n        }\n    }\n    DEBUGMSGTL((\"parse-file\", \"End of file (%s)\\n\", File));\n    return root;\n}\n\n/*\n * return zero if character is not a label character. \n */\nstatic int\nis_labelchar(int ich)\n{\n    if ((isalnum(ich)) || (ich == '-'))\n        return 1;\n    if (ich == '_' && netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t     NETSNMP_DS_LIB_MIB_PARSE_LABEL)) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Read a single character from a file. Assumes that the caller has invoked\n * flockfile(). Uses fgetc_unlocked() instead of getc() since the former is\n * implemented as an inline function in glibc. See also bug 3447196\n * (http://sourceforge.net/tracker/?func=detail&aid=3447196&group_id=12694&atid=112694).\n */\nstatic int netsnmp_getc(FILE *stream)\n{\n#ifdef HAVE_FGETC_UNLOCKED\n    return fgetc_unlocked(stream);\n#else\n    return getc(stream);\n#endif\n}\n\n/*\n * Parses a token from the file.  The type of the token parsed is returned,\n * and the text is placed in the string pointed to by token.\n * Warning: this method may recurse.\n */\nstatic int\nget_token(FILE * fp, char *token, int maxtlen)\n{\n    register int    ch, ch_next;\n    register char  *cp = token;\n    register int    hash = 0;\n    register struct tok *tp;\n    int             too_long = 0;\n    enum { bdigits, xdigits, other } seenSymbols;\n\n    /*\n     * skip all white space \n     */\n    do {\n        ch = netsnmp_getc(fp);\n        if (ch == '\\n')\n            mibLine++;\n    }\n    while (isspace(ch) && ch != EOF);\n    *cp++ = ch;\n    *cp = '\\0';\n    switch (ch) {\n    case EOF:\n        return ENDOFFILE;\n    case '\"':\n        return parseQuoteString(fp, token, maxtlen);\n    case '\\'':                 /* binary or hex constant */\n        seenSymbols = bdigits;\n        while ((ch = netsnmp_getc(fp)) != EOF && ch != '\\'') {\n            switch (seenSymbols) {\n            case bdigits:\n                if (ch == '0' || ch == '1')\n                    break;\n                seenSymbols = xdigits;\n\t\t/* FALL THROUGH */\n            case xdigits:\n                if (isxdigit(ch))\n                    break;\n                seenSymbols = other;\n            case other:\n                break;\n            }\n            if (cp - token < maxtlen - 2)\n                *cp++ = ch;\n        }\n        if (ch == '\\'') {\n            unsigned long   val = 0;\n            char           *run = token + 1;\n            ch = netsnmp_getc(fp);\n            switch (ch) {\n            case EOF:\n                return ENDOFFILE;\n            case 'b':\n            case 'B':\n                if (seenSymbols > bdigits) {\n                    *cp++ = '\\'';\n                    *cp = 0;\n                    return LABEL;\n                }\n                while (run != cp)\n                    val = val * 2 + *run++ - '0';\n                break;\n            case 'h':\n            case 'H':\n                if (seenSymbols > xdigits) {\n                    *cp++ = '\\'';\n                    *cp = 0;\n                    return LABEL;\n                }\n                while (run != cp) {\n                    ch = *run++;\n                    if ('0' <= ch && ch <= '9')\n                        val = val * 16 + ch - '0';\n                    else if ('a' <= ch && ch <= 'f')\n                        val = val * 16 + ch - 'a' + 10;\n                    else if ('A' <= ch && ch <= 'F')\n                        val = val * 16 + ch - 'A' + 10;\n                }\n                break;\n            default:\n                *cp++ = '\\'';\n                *cp = 0;\n                return LABEL;\n            }\n            sprintf(token, \"%ld\", val);\n            return NUMBER;\n        } else\n            return LABEL;\n    case '(':\n        return LEFTPAREN;\n    case ')':\n        return RIGHTPAREN;\n    case '{':\n        return LEFTBRACKET;\n    case '}':\n        return RIGHTBRACKET;\n    case '[':\n        return LEFTSQBRACK;\n    case ']':\n        return RIGHTSQBRACK;\n    case ';':\n        return SEMI;\n    case ',':\n        return COMMA;\n    case '|':\n        return BAR;\n    case '.':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next == '.')\n            return RANGE;\n        ungetc(ch_next, fp);\n        return LABEL;\n    case ':':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next != ':') {\n            ungetc(ch_next, fp);\n            return LABEL;\n        }\n        ch_next = netsnmp_getc(fp);\n        if (ch_next != '=') {\n            ungetc(ch_next, fp);\n            return LABEL;\n        }\n        return EQUALS;\n    case '-':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next == '-') {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_COMMENT_TERM)) {\n                /*\n                 * Treat the rest of this line as a comment. \n                 */\n                while ((ch_next != EOF) && (ch_next != '\\n'))\n                    ch_next = netsnmp_getc(fp);\n            } else {\n                /*\n                 * Treat the rest of the line or until another '--' as a comment \n                 */\n                /*\n                 * (this is the \"technically\" correct way to parse comments) \n                 */\n                ch = ' ';\n                ch_next = netsnmp_getc(fp);\n                while (ch_next != EOF && ch_next != '\\n' &&\n                       (ch != '-' || ch_next != '-')) {\n                    ch = ch_next;\n                    ch_next = netsnmp_getc(fp);\n                }\n            }\n            if (ch_next == EOF)\n                return ENDOFFILE;\n            if (ch_next == '\\n')\n                mibLine++;\n            return get_token(fp, token, maxtlen);\n        }\n        ungetc(ch_next, fp);\n\t/* fallthrough */\n    default:\n        /*\n         * Accumulate characters until end of token is found.  Then attempt to\n         * match this token as a reserved word.  If a match is found, return the\n         * type.  Else it is a label.\n         */\n        if (!is_labelchar(ch))\n            return LABEL;\n        hash += tolower(ch);\n      more:\n        while (is_labelchar(ch_next = netsnmp_getc(fp))) {\n            hash += tolower(ch_next);\n            if (cp - token < maxtlen - 1)\n                *cp++ = ch_next;\n            else\n                too_long = 1;\n        }\n        ungetc(ch_next, fp);\n        *cp = '\\0';\n\n        if (too_long)\n            print_error(\"Warning: token too long\", token, CONTINUE);\n        for (tp = buckets[BUCKET(hash)]; tp; tp = tp->next) {\n            if ((tp->hash == hash) && (!label_compare(tp->name, token)))\n                break;\n        }\n        if (tp) {\n            if (tp->token != CONTINUE)\n                return (tp->token);\n            while (isspace((ch_next = netsnmp_getc(fp))))\n                if (ch_next == '\\n')\n                    mibLine++;\n            if (ch_next == EOF)\n                return ENDOFFILE;\n            if (isalnum(ch_next)) {\n                *cp++ = ch_next;\n                hash += tolower(ch_next);\n                goto more;\n            }\n        }\n        if (token[0] == '-' || isdigit((unsigned char)(token[0]))) {\n            for (cp = token + 1; *cp; cp++)\n                if (!isdigit((unsigned char)(*cp)))\n                    return LABEL;\n            return NUMBER;\n        }\n        return LABEL;\n    }\n}\n\nnetsnmp_feature_child_of(parse_get_token, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_GET_TOKEN\nint\nsnmp_get_token(FILE * fp, char *token, int maxtlen)\n{\n    return get_token(fp, token, maxtlen);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_GET_TOKEN */\n\nint\nadd_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}\n\nstatic int elemcmp(const void *a, const void *b)\n{\n    const char *const *s1 = a, *const *s2 = b;\n\n    return strcmp(*s1, *s2);\n}\n\n/*\n * Scan a directory and return all filenames found as an array of pointers to\n * directory entries (@result).\n */\nstatic int scan_directory(char ***result, const char *dirname)\n{\n    DIR            *dir, *dir2;\n    struct dirent  *file;\n    char          **filenames = NULL;\n    int             fname_len, i, filename_count = 0, array_size = 0;\n    char           *tmpstr;\n\n    *result = NULL;\n\n    dir = opendir(dirname);\n    if (!dir)\n        return -1;\n\n    while ((file = readdir(dir))) {\n        /*\n         * Only parse file names that don't begin with a '.'\n         * Also skip files ending in '~', or starting/ending\n         * with '#' which are typically editor backup files.\n         */\n        fname_len = strlen(file->d_name);\n        if (fname_len > 0 && file->d_name[0] != '.'\n            && file->d_name[0] != '#'\n            && file->d_name[fname_len-1] != '#'\n            && file->d_name[fname_len-1] != '~') {\n            if (asprintf(&tmpstr, \"%s/%s\", dirname, file->d_name) < 0)\n                continue;\n            dir2 = opendir(tmpstr);\n            if (dir2) {\n                /* file is a directory, don't read it */\n                closedir(dir2);\n            } else {\n                if (filename_count >= array_size) {\n                    char **new_filenames;\n\n                    array_size = (array_size + 16) * 2;\n                    new_filenames = realloc(filenames,\n                                        array_size * sizeof(filenames[0]));\n                    if (!new_filenames) {\n                        free(tmpstr);\n                        for (i = 0; i < filename_count; i++)\n                            free(filenames[i]);\n                        free(filenames);\n                        closedir(dir);\n                        return -1;\n                    }\n                    filenames = new_filenames;\n                }\n                filenames[filename_count++] = tmpstr;\n                tmpstr = NULL;\n            }\n            free(tmpstr);\n        }\n    }\n    closedir(dir);\n\n    if (filenames)\n        qsort(filenames, filename_count, sizeof(filenames[0]), elemcmp);\n    *result = filenames;\n\n    return filename_count;\n}\n\n/* For Win32 platforms, the directory does not maintain a last modification\n * date that we can compare with the modification date of the .index file.\n * Therefore there is no way to know whether any .index file is valid.\n * This is the reason for the #if !(defined(WIN32) || defined(cygwin))\n * in the add_mibdir function\n */\nint\nadd_mibdir(const char *dirname)\n{\n    FILE           *ip;\n    const char     *oldFile = File;\n    char          **filenames;\n    int             count = 0;\n    int             filename_count, i;\n#if !(defined(WIN32) || defined(cygwin))\n    char           *token;\n    char space;\n    char newline;\n    struct stat     dir_stat, idx_stat;\n    char            tmpstr[300];\n    char            tmpstr1[300];\n#endif\n\n    DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n#if !(defined(WIN32) || defined(cygwin))\n    token = netsnmp_mibindex_lookup( dirname );\n    if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {\n        if (dir_stat.st_mtime < idx_stat.st_mtime) {\n            DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));\n            if ((ip = fopen(token, \"r\")) != NULL) {\n                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */\n                while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,\n\t\t    &newline) == 4) {\n\n\t\t    /*\n\t\t     * If an overflow of the token or tmpstr buffers has been\n\t\t     * found log a message and break out of the while loop,\n\t\t     * thus the rest of the file tokens will be ignored.\n\t\t     */\n\t\t    if (space != ' ' || newline != '\\n') {\n\t\t\tsnmp_log(LOG_ERR,\n\t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\\n\t\t\t    \"are too large.  count = %d\\n \", dirname,\n\t\t\t    \".index\", count);\n\t\t\t    break;\n\t\t    }\n\t\t   \n\t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);\n                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;\n                    new_module(token, tmpstr1);\n                    count++;\n                }\n                fclose(ip);\n                return count;\n            } else\n                DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));\n        } else\n            DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));\n    } else\n        DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));\n#endif\n\n    filename_count = scan_directory(&filenames, dirname);\n\n    if (filename_count >= 0) {\n        ip = netsnmp_mibindex_new(dirname);\n        for (i = 0; i < filename_count; i++) {\n            if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)\n                count++;\n\t    free(filenames[i]);\n        }\n        File = oldFile;\n        if (ip)\n            fclose(ip);\n        free(filenames);\n        return (count);\n    }\n    else\n        DEBUGMSGTL((\"parse-mibs\",\"cannot open MIB directory %s\\n\", dirname));\n\n    return (-1);\n}\n\n\n/*\n * Returns the root of the whole tree\n *   (for backwards compatability)\n */\nstruct tree    *\nread_mib(const char *filename)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN];\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        snmp_log_perror(filename);\n        return NULL;\n    }\n    mibLine = 1;\n    File = filename;\n    DEBUGMSGTL((\"parse-mibs\", \"Parsing file: %s...\\n\", filename));\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    snmp_log(LOG_ERR, \"Failed to parse MIB file %s\\n\", filename);\n\t    fclose(fp);\n\t    return NULL;\n    }\n    fclose(fp);\n    new_module(token, filename);\n    (void) netsnmp_read_module(token);\n\n    return tree_head;\n}\n\n\nstruct tree    *\nread_all_mibs(void)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->no_imports == -1)\n            netsnmp_read_module(mp->name);\n    adopt_orphans();\n\n    /* If entered the syntax error loop in \"read_module()\" */\n    if (gLoop == 1) {\n        gLoop = 0;\n        free(gpMibErrorString);\n        gpMibErrorString = NULL;\n        if (asprintf(&gpMibErrorString, \"Error in parsing MIB module(s): %s !\"\n                     \" Unable to load corresponding MIB(s)\", gMibNames) < 0) {\n            snmp_log(LOG_CRIT,\n                     \"failed to allocated memory for gpMibErrorString\\n\");\n        }\n    }\n\n    /* Caller's responsibility to free this memory */\n    tree_head->parseErrorString = gpMibErrorString;\n\t\n    return tree_head;\n}\n\n\n#ifdef TEST\nint main(int argc, char *argv[])\n{\n    int             i;\n    struct tree    *tp;\n    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS, 2);\n\n    netsnmp_init_mib();\n\n    if (argc == 1)\n        (void) read_all_mibs();\n    else\n        for (i = 1; i < argc; i++)\n            read_mib(argv[i]);\n\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        print_subtree(stdout, tp, 0);\n    free_tree(tree_head);\n\n    return 0;\n}\n#endif                          /* TEST */\n\nstatic int\nparseQuoteString(FILE * fp, char *token, int maxtlen)\n{\n    register int    ch;\n    int             count = 0;\n    int             too_long = 0;\n    char           *token_start = token;\n\n    for (ch = netsnmp_getc(fp); ch != EOF; ch = netsnmp_getc(fp)) {\n        if (ch == '\\r')\n            continue;\n        if (ch == '\\n') {\n            mibLine++;\n        } else if (ch == '\"') {\n            *token = '\\0';\n            if (too_long && netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS) > 1) {\n                /*\n                 * show short form for brevity sake \n                 */\n                char            ch_save = *(token_start + 50);\n                *(token_start + 50) = '\\0';\n                print_error(\"Warning: string too long\",\n                            token_start, QUOTESTRING);\n                *(token_start + 50) = ch_save;\n            }\n            return QUOTESTRING;\n        }\n        /*\n         * maximum description length check.  If greater, keep parsing\n         * but truncate the string \n         */\n        if (++count < maxtlen)\n            *token++ = ch;\n        else\n            too_long = 1;\n    }\n\n    return 0;\n}\n\n/*\n * struct index_list *\n * getIndexes(FILE *fp):\n *   This routine parses a string like  { blah blah blah } and returns a\n *   list of the strings enclosed within it.\n *\n */\nstatic struct index_list *\ngetIndexes(FILE * fp, struct index_list **retp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            nextIsImplied = 0;\n\n    struct index_list *mylist = NULL;\n    struct index_list **mypp = &mylist;\n\n    free_indexes(retp);\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET) {\n        return NULL;\n    }\n\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != RIGHTBRACKET && type != ENDOFFILE) {\n        if ((type == LABEL) || (type & SYNTAX_MASK)) {\n            *mypp =\n                (struct index_list *) calloc(1, sizeof(struct index_list));\n            if (*mypp) {\n                (*mypp)->ilabel = strdup(token);\n                (*mypp)->isimplied = nextIsImplied;\n                mypp = &(*mypp)->next;\n                nextIsImplied = 0;\n            }\n        } else if (type == IMPLIED) {\n            nextIsImplied = 1;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    *retp = mylist;\n    return mylist;\n}\n\nstatic struct varbind_list *\ngetVarbinds(FILE * fp, struct varbind_list **retp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n\n    struct varbind_list *mylist = NULL;\n    struct varbind_list **mypp = &mylist;\n\n    free_varbinds(retp);\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET) {\n        return NULL;\n    }\n\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != RIGHTBRACKET && type != ENDOFFILE) {\n        if ((type == LABEL) || (type & SYNTAX_MASK)) {\n            *mypp =\n                (struct varbind_list *) calloc(1,\n                                               sizeof(struct\n                                                      varbind_list));\n            if (*mypp) {\n                (*mypp)->vblabel = strdup(token);\n                mypp = &(*mypp)->next;\n            }\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    *retp = mylist;\n    return mylist;\n}\n\nstatic void\nfree_indexes(struct index_list **spp)\n{\n    if (spp && *spp) {\n        struct index_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->ilabel)\n                free(pp->ilabel);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_varbinds(struct varbind_list **spp)\n{\n    if (spp && *spp) {\n        struct varbind_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->vblabel)\n                free(pp->vblabel);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_ranges(struct range_list **spp)\n{\n    if (spp && *spp) {\n        struct range_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_enums(struct enum_list **spp)\n{\n    if (spp && *spp) {\n        struct enum_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->label)\n                free(pp->label);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic struct enum_list *\ncopy_enums(struct enum_list *sp)\n{\n    struct enum_list *xp = NULL, **spp = &xp;\n\n    while (sp) {\n        *spp = (struct enum_list *) calloc(1, sizeof(struct enum_list));\n        if (!*spp)\n            break;\n        (*spp)->label = strdup(sp->label);\n        (*spp)->value = sp->value;\n        spp = &(*spp)->next;\n        sp = sp->next;\n    }\n    return (xp);\n}\n\nstatic struct range_list *\ncopy_ranges(struct range_list *sp)\n{\n    struct range_list *xp = NULL, **spp = &xp;\n\n    while (sp) {\n        *spp = (struct range_list *) calloc(1, sizeof(struct range_list));\n        if (!*spp)\n            break;\n        (*spp)->low = sp->low;\n        (*spp)->high = sp->high;\n        spp = &(*spp)->next;\n        sp = sp->next;\n    }\n    return (xp);\n}\n\n/*\n * This routine parses a string like  { blah blah blah } and returns OBJID if\n * it is well formed, and NULL if not.\n */\nstatic int\ntossObjectIdentifier(FILE * fp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    int             bracketcount = 1;\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET)\n        return 0;\n    while ((type != RIGHTBRACKET || bracketcount > 0) && type != ENDOFFILE) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == LEFTBRACKET)\n            bracketcount++;\n        else if (type == RIGHTBRACKET)\n            bracketcount--;\n    }\n\n    if (type == RIGHTBRACKET)\n        return OBJID;\n    else\n        return 0;\n}\n\n/* Find node in any MIB module\n   Used by Perl modules\t\t*/\nstruct tree    *\nfind_node(const char *name, struct tree *subtree)\n{                               /* Unused */\n    return (find_tree_node(name, -1));\n}\n\nnetsnmp_feature_child_of(parse_find_node2, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_FIND_NODE2\nstruct tree    *\nfind_node2(const char *name, const char *module)\n{                               \n  int modid = -1;\n  if (module) {\n    modid = which_module(module);\n  }\n  if (modid == -1)\n  {\n    return (NULL);\n  }\n  return (find_tree_node(name, modid));\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_FIND_NODE2 */\n\n#ifndef NETSNMP_FEATURE_REMOVE_FIND_MODULE\n/* Used in the perl module */\nstruct module  *\nfind_module(int mid)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp != NULL; mp = mp->next) {\n        if (mp->modid == mid)\n            break;\n    }\n    return mp;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_FIND_MODULE */\n\n\nstatic char     leave_indent[256];\nstatic int      leave_was_simple;\n\nstatic void\nprint_mib_leaves(FILE * f, struct tree *tp, int width)\n{\n    struct tree    *ntp;\n    char           *ip = leave_indent + strlen(leave_indent) - 1;\n    char            last_ipch = *ip;\n\n    *ip = '+';\n    if (tp->type == TYPE_OTHER || tp->type > TYPE_SIMPLE_LAST) {\n        fprintf(f, \"%s--%s(%ld)\\n\", leave_indent, tp->label, tp->subid);\n        if (tp->indexes) {\n            struct index_list *xp = tp->indexes;\n            int             first = 1, cpos = 0, len, cmax =\n                width - strlen(leave_indent) - 12;\n            *ip = last_ipch;\n            fprintf(f, \"%s  |  Index: \", leave_indent);\n            while (xp) {\n                if (first)\n                    first = 0;\n                else\n                    fprintf(f, \", \");\n                cpos += (len = strlen(xp->ilabel) + 2);\n                if (cpos > cmax) {\n                    fprintf(f, \"\\n\");\n                    fprintf(f, \"%s  |         \", leave_indent);\n                    cpos = len;\n                }\n                fprintf(f, \"%s\", xp->ilabel);\n                xp = xp->next;\n            }\n            fprintf(f, \"\\n\");\n            *ip = '+';\n        }\n    } else {\n        const char     *acc, *typ;\n        int             size = 0;\n        switch (tp->access) {\n        case MIB_ACCESS_NOACCESS:\n            acc = \"----\";\n            break;\n        case MIB_ACCESS_READONLY:\n            acc = \"-R--\";\n            break;\n        case MIB_ACCESS_WRITEONLY:\n            acc = \"--W-\";\n            break;\n        case MIB_ACCESS_READWRITE:\n            acc = \"-RW-\";\n            break;\n        case MIB_ACCESS_NOTIFY:\n            acc = \"---N\";\n            break;\n        case MIB_ACCESS_CREATE:\n            acc = \"CR--\";\n            break;\n        default:\n            acc = \"    \";\n            break;\n        }\n        switch (tp->type) {\n        case TYPE_OBJID:\n            typ = \"ObjID    \";\n            break;\n        case TYPE_OCTETSTR:\n            typ = \"String   \";\n            size = 1;\n            break;\n        case TYPE_INTEGER:\n            if (tp->enums)\n                typ = \"EnumVal  \";\n            else\n                typ = \"INTEGER  \";\n            break;\n        case TYPE_NETADDR:\n            typ = \"NetAddr  \";\n            break;\n        case TYPE_IPADDR:\n            typ = \"IpAddr   \";\n            break;\n        case TYPE_COUNTER:\n            typ = \"Counter  \";\n            break;\n        case TYPE_GAUGE:\n            typ = \"Gauge    \";\n            break;\n        case TYPE_TIMETICKS:\n            typ = \"TimeTicks\";\n            break;\n        case TYPE_OPAQUE:\n            typ = \"Opaque   \";\n            size = 1;\n            break;\n        case TYPE_NULL:\n            typ = \"Null     \";\n            break;\n        case TYPE_COUNTER64:\n            typ = \"Counter64\";\n            break;\n        case TYPE_BITSTRING:\n            typ = \"BitString\";\n            break;\n        case TYPE_NSAPADDRESS:\n            typ = \"NsapAddr \";\n            break;\n        case TYPE_UNSIGNED32:\n            typ = \"Unsigned \";\n            break;\n        case TYPE_UINTEGER:\n            typ = \"UInteger \";\n            break;\n        case TYPE_INTEGER32:\n            typ = \"Integer32\";\n            break;\n        default:\n            typ = \"         \";\n            break;\n        }\n        fprintf(f, \"%s-- %s %s %s(%ld)\\n\", leave_indent, acc, typ,\n                tp->label, tp->subid);\n        *ip = last_ipch;\n        if (tp->tc_index >= 0)\n            fprintf(f, \"%s        Textual Convention: %s\\n\", leave_indent,\n                    tclist[tp->tc_index].descriptor);\n        if (tp->enums) {\n            struct enum_list *ep = tp->enums;\n            int             cpos = 0, cmax =\n                width - strlen(leave_indent) - 16;\n            fprintf(f, \"%s        Values: \", leave_indent);\n            while (ep) {\n                char            buf[80];\n                int             bufw;\n                if (ep != tp->enums)\n                    fprintf(f, \", \");\n                snprintf(buf, sizeof(buf), \"%s(%d)\", ep->label, ep->value);\n                buf[ sizeof(buf)-1 ] = 0;\n                cpos += (bufw = strlen(buf) + 2);\n                if (cpos >= cmax) {\n                    fprintf(f, \"\\n%s                \", leave_indent);\n                    cpos = bufw;\n                }\n                fprintf(f, \"%s\", buf);\n                ep = ep->next;\n            }\n            fprintf(f, \"\\n\");\n        }\n        if (tp->ranges) {\n            struct range_list *rp = tp->ranges;\n            if (size)\n                fprintf(f, \"%s        Size: \", leave_indent);\n            else\n                fprintf(f, \"%s        Range: \", leave_indent);\n            while (rp) {\n                if (rp != tp->ranges)\n                    fprintf(f, \" | \");\n                print_range_value(f, tp->type, rp);\n                rp = rp->next;\n            }\n            fprintf(f, \"\\n\");\n        }\n    }\n    *ip = last_ipch;\n    strcat(leave_indent, \"  |\");\n    leave_was_simple = tp->type != TYPE_OTHER;\n\n    {\n        int             i, j, count = 0;\n        struct leave {\n            oid             id;\n            struct tree    *tp;\n        }              *leaves, *lp;\n\n        for (ntp = tp->child_list; ntp; ntp = ntp->next_peer)\n            count++;\n        if (count) {\n            leaves = (struct leave *) calloc(count, sizeof(struct leave));\n            if (!leaves)\n                return;\n            for (ntp = tp->child_list, count = 0; ntp;\n                 ntp = ntp->next_peer) {\n                for (i = 0, lp = leaves; i < count; i++, lp++)\n                    if (lp->id >= ntp->subid)\n                        break;\n                for (j = count; j > i; j--)\n                    leaves[j] = leaves[j - 1];\n                lp->id = ntp->subid;\n                lp->tp = ntp;\n                count++;\n            }\n            for (i = 1, lp = leaves; i <= count; i++, lp++) {\n                if (!leave_was_simple || lp->tp->type == 0)\n                    fprintf(f, \"%s\\n\", leave_indent);\n                if (i == count)\n                    ip[3] = ' ';\n                print_mib_leaves(f, lp->tp, width);\n            }\n            free(leaves);\n            leave_was_simple = 0;\n        }\n    }\n    ip[1] = 0;\n}\n\nvoid\nprint_mib_tree(FILE * f, struct tree *tp, int width)\n{\n    leave_indent[0] = ' ';\n    leave_indent[1] = 0;\n    leave_was_simple = 1;\n    print_mib_leaves(f, tp, width);\n}\n\n\n/*\n * Merge the parsed object identifier with the existing node.\n * If there is a problem with the identifier, release the existing node.\n */\nstatic struct node *\nmerge_parse_objectid(struct node *np, FILE * fp, char *name)\n{\n    struct node    *nnp;\n    /*\n     * printf(\"merge defval --> %s\\n\",np->defaultValue); \n     */\n    nnp = parse_objectid(fp, name);\n    if (nnp) {\n\n        /*\n         * apply last OID sub-identifier data to the information \n         */\n        /*\n         * already collected for this node. \n         */\n        struct node    *headp, *nextp;\n        int             ncount = 0;\n        nextp = headp = nnp;\n        while (nnp->next) {\n            nextp = nnp;\n            ncount++;\n            nnp = nnp->next;\n        }\n\n        np->label = nnp->label;\n        np->subid = nnp->subid;\n        np->modid = nnp->modid;\n        np->parent = nnp->parent;\n\tif (nnp->filename != NULL) {\n\t  free(nnp->filename);\n\t}\n        free(nnp);\n\n        if (ncount) {\n            nextp->next = np;\n            np = headp;\n        }\n    } else {\n        free_node(np);\n        np = NULL;\n    }\n\n    return np;\n}\n\n/*\n * transfer data to tree from node\n *\n * move pointers for alloc'd data from np to tp.\n * this prevents them from being freed when np is released.\n * parent member is not moved.\n *\n * CAUTION: nodes may be repeats of existing tree nodes.\n * This can happen especially when resolving IMPORT clauses.\n *\n */\nstatic void\ntree_from_node(struct tree *tp, struct node *np)\n{\n    free_partial_tree(tp, FALSE);\n\n    tp->label = np->label;\n    np->label = NULL;\n    tp->enums = np->enums;\n    np->enums = NULL;\n    tp->ranges = np->ranges;\n    np->ranges = NULL;\n    tp->indexes = np->indexes;\n    np->indexes = NULL;\n    tp->augments = np->augments;\n    np->augments = NULL;\n    tp->varbinds = np->varbinds;\n    np->varbinds = NULL;\n    tp->hint = np->hint;\n    np->hint = NULL;\n    tp->units = np->units;\n    np->units = NULL;\n    tp->description = np->description;\n    np->description = NULL;\n    tp->reference = np->reference;\n    np->reference = NULL;\n    tp->defaultValue = np->defaultValue;\n    np->defaultValue = NULL;\n    tp->subid = np->subid;\n    tp->tc_index = np->tc_index;\n    tp->type = translation_table[np->type];\n    tp->access = np->access;\n    tp->status = np->status;\n\n    set_function(tp);\n}\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n"], "fixing_code": ["*~\n*.bak\n*.bs\n*.ft\n*.ft.1\n*.la\n*.lo\n*.made\n*.o\n*.obj\n*.old\n*.orig\n*.out\n*.pdb\n*.rej\n*.swp\n.libs/\nagent/*.exe\nagent/mibgroup/agent_module_dot_conf.h\nagent/mibgroup/agent_module_includes.h\nagent/mibgroup/agent_module_inits.h\nagent/mibgroup/agent_module_shutdown.h\nagent/mibgroup/mib_module_dot_conf.h\nagent/mibgroup/mib_module_includes.h\nagent/mibgroup/mib_module_inits.h\nagent/mibgroup/mib_module_shutdown.h\nagent/snmpd\napps/*.exe\napps/agentxtrap\napps/encode_keychange\napps/snmpbulkget\napps/snmpbulkwalk\napps/snmpdelta\napps/snmpdf\napps/snmpget\napps/snmpgetnext\napps/snmpnetstat/*.exe\napps/snmpnetstat/snmpnetstat\napps/snmppcap\napps/snmpping\napps/snmpps\napps/snmpset\napps/snmpstatus\napps/snmptable\napps/snmptest\napps/snmptls\napps/snmptranslate\napps/snmptrap\napps/snmptrapd\napps/snmpusm\napps/snmpvacm\napps/snmpwalk\napps/sshtosnmp\nautom4te.cache/\nChangeLog.add*\nChangeLog.reallyadd\nCHANGES.new*\nconfdefs.h\nconfig.cache\nconfig.log\nconfig.status\nconfigure-summary\ndist/generation-scripts/gen-variables\ndocs/html\ndocs/latex\nEXAMPLE.conf\ninclude/net-snmp/agent/agent_module_config.h\ninclude/net-snmp/agent/mib_module_config.h\ninclude/net-snmp/library/snmpv3-security-includes.h\ninclude/net-snmp/net-snmp-config.h\nlibtool\nlocal/snmpcheck\nlocal/snmpconf\nMakefile\nman/*.[1358]\nman/default_store.3.h\nman/manaliases\nmk/\nmodule_tmp_header.h\nnet-snmp-5*\nnet-snmp-6*\nnet-snmp-config\nnet-snmp-config-x\nnet-snmp-create-v3-user\nNEWS.new*\nperl/*.json\nperl/*.yml\nperl/*/*.def\nperl/*/*.json\nperl/*/*.yml\nperl/*/*/*.json\nperl/*/*/*.yml\nperl/agent/agent.c\nperl/agent/default_store/default_store.c\nperl/agent/default_store/default_store.def\nperl/ASN/ASN.c\nperl/blib/\nperl/default_store/default_store.c\nperl/NetSNMP.c\nperl/OID/OID.c\nperl/SNMP/SNMP.c\nperl/SNMP/t/*.log\nperl/SNMP/t/*.pid\nperl/SNMP/t/*.stderr\nperl/SNMP/t/snmptest.cmd\nperl/TrapReceiver/const-c.inc\nperl/TrapReceiver/const-xs.inc\nperl/TrapReceiver/TrapReceiver.c\npm_to_blib\npython/build\nsedscript\nsnmplib/snmpsm_init.h\nsnmplib/snmpsm_shutdown.h\nsnmplib/transports/snmp_transport_inits.h\nstamp-h\nTAGS\ntesting/failed_tests\ntesting/testing/\nwin32/*/debug\nwin32/*/release\nwin32/bin\nwin32/lib\n", "#ifndef MIB_H\n#define MIB_H\n\n#ifdef __cplusplus\nextern          \"C\" {\n#endif\n    /*\n     * mib.h - Definitions for the variables as defined in the MIB\n     *\n     * Update: 1998-07-17 <jhy@gsu.edu>\n     * Added prototypes for print_oid_report* functions.\n     */\n/***********************************************************\n\tCopyright 1988, 1989 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its \ndocumentation for any purpose and without fee is hereby granted, \nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in \nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.  \n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n\n#include <stdio.h>              /* for FILE */\n\n#include <net-snmp/mib_api.h>\n\n#define NETSNMP_MIB2_OID 1, 3, 6, 1, 2, 1\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\n#define MIB NETSNMP_MIB2_OID\n#endif\n\n#define MIB_IFTYPE_OTHER\t\t    1\n#define MIB_IFTYPE_REGULAR1822\t\t    2\n#define MIB_IFTYPE_HDH1822\t\t    3\n#define MIB_IFTYPE_DDNX25\t\t    4\n#define MIB_IFTYPE_RFC877X25\t\t    5\n#define MIB_IFTYPE_ETHERNETCSMACD\t    6\n#define MIB_IFTYPE_ISO88023CSMACD\t    7\n#define MIB_IFTYPE_ISO88024TOKENBUS\t    8\n#define MIB_IFTYPE_ISO88025TOKENRING\t    9\n#define MIB_IFTYPE_ISO88026MAN\t\t    10\n#define MIB_IFTYPE_STARLAN\t\t    11\n#define MIB_IFTYPE_PROTEON10MBIT\t    12\n#define MIB_IFTYPE_PROTEON80MBIT\t    13\n#define MIB_IFTYPE_HYPERCHANNEL\t\t    14\n#define MIB_IFTYPE_FDDI\t\t\t    15\n#define MIB_IFTYPE_LAPB\t\t\t    16\n#define MIB_IFTYPE_SDLC\t\t\t    17\n#define MIB_IFTYPE_T1CARRIER\t\t    18\n#define MIB_IFTYPE_CEPT\t\t\t    19\n#define MIB_IFTYPE_BASICISDN\t\t    20\n#define MIB_IFTYPE_PRIMARYISDN\t\t    21\n#define MIB_IFTYPE_PROPPOINTTOPOINTSERIAL   22\n\n#define MIB_IFSTATUS_UP\t\t1\n#define MIB_IFSTATUS_DOWN\t2\n#define MIB_IFSTATUS_TESTING\t3\n\n#define MIB_FORWARD_GATEWAY\t1\n#define MIB_FORWARD_HOST\t2\n\n#define MIB_IPROUTETYPE_OTHER\t1\n#define MIB_IPROUTETYPE_INVALID\t2\n#define MIB_IPROUTETYPE_DIRECT\t3\n#define MIB_IPROUTETYPE_REMOTE\t4\n\n#define MIB_IPROUTEPROTO_OTHER\t    1\n#define MIB_IPROUTEPROTO_LOCAL\t    2\n#define MIB_IPROUTEPROTO_NETMGMT    3\n#define MIB_IPROUTEPROTO_ICMP\t    4\n#define MIB_IPROUTEPROTO_EGP\t    5\n#define MIB_IPROUTEPROTO_GGP\t    6\n#define MIB_IPROUTEPROTO_HELLO\t    7\n#define MIB_IPROUTEPROTO_RIP\t    8\n#define MIB_IPROUTEPROTO_ISIS\t    9\n#define MIB_IPROUTEPROTO_ESIS\t    10\n#define MIB_IPROUTEPROTO_CISCOIGRP  11\n#define MIB_IPROUTEPROTO_BBNSPFIGP  12\n#define MIB_IPROUTEPROTO_OIGP\t    13\n\n#define MIB_TCPRTOALG_OTHER\t1\n#define MIB_TCPRTOALG_CONSTANT\t2\n#define MIB_TCPRTOALG_RSRE\t3\n#define MIB_TCPRTOALG_VANJ\t4\n\n#define MIB_TCPCONNSTATE_CLOSED\t\t1\n#define MIB_TCPCONNSTATE_LISTEN\t\t2\n#define MIB_TCPCONNSTATE_SYNSENT\t3\n#define MIB_TCPCONNSTATE_SYNRECEIVED\t4\n#define MIB_TCPCONNSTATE_ESTABLISHED\t5\n#define MIB_TCPCONNSTATE_FINWAIT1\t6\n#define MIB_TCPCONNSTATE_FINWAIT2\t7\n#define MIB_TCPCONNSTATE_CLOSEWAIT\t8\n#define MIB_TCPCONNSTATE_LASTACK\t9\n#define MIB_TCPCONNSTATE_CLOSING\t10\n#define MIB_TCPCONNSTATE_TIMEWAIT\t11\n\n#define MIB_EGPNEIGHSTATE_IDLE\t\t1\n#define MIB_EGPNEIGHSTATE_AQUISITION\t2\n#define MIB_EGPNEIGHSTATE_DOWN\t\t3\n#define MIB_EGPNEIGHSTATE_UP\t\t4\n#define MIB_EGPNEIGHSTATE_CEASE\t\t5\n\n    struct variable_list;\n    struct enum_list;\n\n    NETSNMP_IMPORT\n    void            print_ascii_dump(FILE *);\n    void            register_mib_handlers(void);\n    void            netsnmp_set_mib_directory(const char *dir);\n    NETSNMP_IMPORT\n    char            *netsnmp_get_mib_directory(void);\n    void            netsnmp_fixup_mib_directory(void);\n    int             sprint_realloc_description(u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc,\n                                oid * objid, size_t objidlen, int width);\n    NETSNMP_IMPORT\n    int             get_wild_node(const char *, oid *, size_t *);\n    NETSNMP_IMPORT\n    int             get_node(const char *, oid *, size_t *);\n    NETSNMP_IMPORT\n    struct tree    *get_tree(const oid *, size_t, struct tree *);\n    NETSNMP_IMPORT\n    struct tree    *get_tree_head(void);\n    void            set_function(struct tree *);\n\n    NETSNMP_IMPORT\n    int             parse_one_oid_index(oid ** oidStart, size_t * oidLen,\n                                        netsnmp_variable_list * data,\n                                        int complete);\n    NETSNMP_IMPORT\n    int             parse_oid_indexes(oid * oidIndex, size_t oidLen,\n                                      netsnmp_variable_list * data);\n    NETSNMP_IMPORT\n    int             build_oid_noalloc(oid * in, size_t in_len,\n                                      size_t * out_len, oid * prefix,\n                                      size_t prefix_len,\n                                      netsnmp_variable_list * indexes);\n    NETSNMP_IMPORT\n    int             build_oid(oid ** out, size_t * out_len, oid * prefix,\n                              size_t prefix_len,\n                              netsnmp_variable_list * indexes);\n    int             build_oid_segment(netsnmp_variable_list * var);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_variable(u_char ** buf, size_t * buf_len,\n                                   size_t * out_len, int allow_realloc,\n                                   const oid * objid, size_t objidlen,\n                                   const netsnmp_variable_list * variable);\n\n    NETSNMP_IMPORT\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *\n#else\n    void\n#endif\n                    netsnmp_sprint_realloc_objid_tree(u_char ** buf,\n                                                      size_t * buf_len,\n                                                      size_t * out_len,\n                                                      int allow_realloc,\n                                                      int *buf_overflow,\n                                                      const oid * objid,\n                                                      size_t objidlen);\n\n    NETSNMP_IMPORT\n    void\n                    netsnmp_sprint_realloc_objid(u_char ** buf,\n                                                 size_t * buf_len,\n                                                 size_t * out_len,\n                                                 int allow_realloc,\n                                                 int *buf_overflow,\n                                                 const oid * objid,\n                                                 size_t objidlen);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_value(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const oid * objid, size_t objidlen,\n                                 const netsnmp_variable_list * variable);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const oid * objid, size_t objidlen);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_by_type(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list * var,\n                                           const struct enum_list *enums,\n                                           const char *hint,\n                                           const char *units);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_hexstring(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const u_char *, size_t);\n\n    NETSNMP_IMPORT\n    int             sprint_realloc_asciistring(u_char ** buf,\n                                               size_t * buf_len,\n                                               size_t * out_len,\n                                               int allow_realloc,\n                                               const u_char * cp,\n                                               size_t len);\n\n    int             sprint_realloc_octet_string(u_char ** buf,\n                                                size_t * buf_len,\n                                                size_t * out_len,\n                                                int allow_realloc,\n                                                const netsnmp_variable_list *,\n                                                const struct enum_list *,\n                                                const char *,\n                                                const char *);\n\n    int             sprint_realloc_opaque(u_char ** buf, size_t * buf_len,\n                                          size_t * out_len,\n                                          int allow_realloc,\n                                          const netsnmp_variable_list *,\n                                          const struct enum_list *, const char *,\n                                          const char *);\n\n    int             sprint_realloc_object_identifier(u_char ** buf,\n                                                     size_t * buf_len,\n                                                     size_t * out_len,\n                                                     int allow_realloc,\n                                                     const netsnmp_variable_list\n                                                     *, const struct enum_list *,\n                                                     const char *,\n                                                     const char *);\n\n    int             sprint_realloc_timeticks(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_hinted_integer(u_char ** buf,\n                                                  size_t * buf_len,\n                                                  size_t * out_len,\n                                                  int allow_realloc, long,\n                                                  const char, const char *,\n                                                  const char *);\n\n    int             sprint_realloc_integer(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             sprint_realloc_uinteger(u_char ** buf,\n                                            size_t * buf_len,\n                                            size_t * out_len,\n                                            int allow_realloc,\n                                            const netsnmp_variable_list *,\n                                            const struct enum_list *,\n                                            const char *, const char *);\n\n    int             sprint_realloc_gauge(u_char ** buf, size_t * buf_len,\n                                         size_t * out_len,\n                                         int allow_realloc,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             sprint_realloc_counter(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             sprint_realloc_networkaddress(u_char ** buf,\n                                                  size_t * buf_len,\n                                                  size_t * out_len,\n                                                  int allow_realloc,\n                                                  const netsnmp_variable_list *,\n                                                  const struct enum_list *,\n                                                  const char *,\n                                                  const char *);\n\n    int             sprint_realloc_ipaddress(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_null(u_char ** buf, size_t * buf_len,\n                                        size_t * out_len,\n                                        int allow_realloc,\n                                        const netsnmp_variable_list *,\n                                        const struct enum_list *, const char *,\n                                        const char *);\n\n    int             sprint_realloc_bitstring(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_nsapaddress(u_char ** buf,\n                                               size_t * buf_len,\n                                               size_t * out_len,\n                                               int allow_realloc,\n                                               const netsnmp_variable_list *,\n                                               const struct enum_list *,\n                                               const char *, const char *);\n\n    int             sprint_realloc_counter64(u_char ** buf,\n                                             size_t * buf_len,\n                                             size_t * out_len,\n                                             int allow_realloc,\n                                             const netsnmp_variable_list *,\n                                             const struct enum_list *,\n                                             const char *, const char *);\n\n    int             sprint_realloc_badtype(u_char ** buf, size_t * buf_len,\n                                           size_t * out_len,\n                                           int allow_realloc,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    int             sprint_realloc_float(u_char ** buf, size_t * buf_len,\n                                         size_t * out_len,\n                                         int allow_realloc,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             sprint_realloc_double(u_char ** buf, size_t * buf_len,\n                                          size_t * out_len,\n                                          int allow_realloc,\n                                          const netsnmp_variable_list *,\n                                          const struct enum_list *, const char *,\n                                          const char *);\n#endif\n\n\n    int             snprint_by_type(char *buf, size_t buf_len,\n                                    netsnmp_variable_list * var,\n                                    const struct enum_list *enums,\n                                    const char *hint, const char *units);\n\n    int             snprint_hexstring(char *buf, size_t buf_len,\n                                      const u_char *, size_t);\n\n    int             snprint_asciistring(char *buf, size_t buf_len,\n                                        const u_char * cp, size_t len);\n\n    int             snprint_octet_string(char *buf, size_t buf_len,\n                                         const netsnmp_variable_list *,\n                                         const struct enum_list *, const char *,\n                                         const char *);\n\n    int             snprint_opaque(char *buf, size_t buf_len,\n                                   const netsnmp_variable_list *,\n                                   const struct enum_list *, const char *,\n                                   const char *);\n\n    int             snprint_object_identifier(char *buf, size_t buf_len,\n                                              const netsnmp_variable_list *,\n                                              const struct enum_list *,\n                                              const char *, const char *);\n\n    int             snprint_timeticks(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_hinted_integer(char *buf, size_t buf_len,\n                                           long, const char *,\n                                           const char *);\n\n    int             snprint_integer(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n    int             snprint_uinteger(char *buf, size_t buf_len,\n                                     const netsnmp_variable_list *,\n                                     const struct enum_list *, const char *,\n                                     const char *);\n\n    int             snprint_gauge(char *buf, size_t buf_len,\n                                  const netsnmp_variable_list *,\n                                  const struct enum_list *, const char *,\n                                  const char *);\n\n    int             snprint_counter(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n    int             snprint_networkaddress(char *buf, size_t buf_len,\n                                           const netsnmp_variable_list *,\n                                           const struct enum_list *,\n                                           const char *, const char *);\n\n    int             snprint_ipaddress(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_null(char *buf, size_t buf_len,\n                                 const netsnmp_variable_list *,\n                                 const struct enum_list *, const char *,\n                                 const char *);\n\n    NETSNMP_IMPORT\n    int             snprint_bitstring(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_nsapaddress(char *buf, size_t buf_len,\n                                        const netsnmp_variable_list *,\n                                        const struct enum_list *, const char *,\n                                        const char *);\n\n    int             snprint_counter64(char *buf, size_t buf_len,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n\n    int             snprint_badtype(char *buf, size_t buf_len,\n                                    const netsnmp_variable_list *,\n                                    const struct enum_list *, const char *,\n                                    const char *);\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    int             snprint_float(char *buf, size_t buf_len,\n                                  const netsnmp_variable_list *,\n                                  const struct enum_list *, const char *,\n                                  const char *);\n\n    int             snprint_double(char *buf, size_t buf_len,\n                                   const netsnmp_variable_list *,\n                                   const struct enum_list *, const char *,\n                                   const char *);\n#endif\n\n    NETSNMP_IMPORT\n    void            print_oid_report(FILE *);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_labeledoid(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_oid(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_suffix(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_symbolic(void);\n    NETSNMP_IMPORT\n    void            print_oid_report_enable_mibchildoid(void);\n\n    const char     *parse_octet_hint(const char *hint, const char *value,\n\t                             unsigned char **new_val, int *new_val_len);\n\n    NETSNMP_IMPORT\n    void            clear_tree_flags(register struct tree *tp);\n\n    NETSNMP_IMPORT\n    char           *snmp_out_toggle_options(char *);\n    NETSNMP_IMPORT\n    char           *snmp_out_options(char *, int, char * const *);\n    NETSNMP_IMPORT\n    void            snmp_out_toggle_options_usage(const char *, FILE *);\n    NETSNMP_IMPORT\n    char           *snmp_in_toggle_options(char *);\n    NETSNMP_IMPORT\n    char           *snmp_in_options(char *, int, char * const *);\n    NETSNMP_IMPORT\n    void            snmp_in_toggle_options_usage(const char *, FILE *);\n    NETSNMP_IMPORT\n    u_char          mib_to_asn_type(int mib_type);\n\n\n    int             netsnmp_str2oid(const char *S, oid * O, int L);\n    char            *make_printf_format_string(const char *);\n\n\n#define NETSNMP_STRING_OUTPUT_GUESS  1\n#define NETSNMP_STRING_OUTPUT_ASCII  2\n#define NETSNMP_STRING_OUTPUT_HEX    3\n\n#define NETSNMP_OID_OUTPUT_SUFFIX  1\n#define NETSNMP_OID_OUTPUT_MODULE  2\n#define NETSNMP_OID_OUTPUT_FULL    3\n#define NETSNMP_OID_OUTPUT_NUMERIC 4\n#define NETSNMP_OID_OUTPUT_UCD     5\n#define NETSNMP_OID_OUTPUT_NONE    6\n#ifdef __cplusplus\n}\n#endif\n#endif                          /* MIB_H */\n", "#ifndef PARSE_H\n#define PARSE_H\n\n#ifdef __cplusplus\nextern          \"C\" {\n#endif\n\n#include <net-snmp/mib_api.h>\n\n    /*\n     * parse.h\n     */\n/***********************************************************\n        Copyright 1989 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n\n#define NETSNMP_MAXLABEL 64      /* maximum characters in a label */\n#define MAXTOKEN        128     /* maximum characters in a token */\n#define MAXQUOTESTR     4096    /* maximum characters in a quoted string */\n\n/*\n * MAXLABEL appears to be unused in code, and conflicts with\n * <arpa/nameser.h>. Only define it if requested. This will\n * cause problems if local DNSSEC validation is also enabled.\n */\n#ifdef UCD_COMPATIBLE\n#define MAXLABEL        NETSNMP_MAXLABEL\n#endif\n\n    struct variable_list;\n\n    /*\n     * A linked list of tag-value pairs for enumerated integers.\n     */\n    struct enum_list {\n        struct enum_list *next;\n        int             value;\n        char           *label;\n    };\n\n    /*\n     * A linked list of ranges\n     */\n    struct range_list {\n        struct range_list *next;\n        int             low, high;\n    };\n\n    /*\n     * A linked list of indexes\n     */\n    struct index_list {\n        struct index_list *next;\n        char           *ilabel;\n        char            isimplied;\n    };\n\n    /*\n     * A linked list of varbinds\n     */\n    struct varbind_list {\n        struct varbind_list *next;\n        char           *vblabel;\n    };\n\n    /*\n     * A tree in the format of the tree structure of the MIB.\n     */\n    struct tree {\n        struct tree    *child_list;     /* list of children of this node */\n        struct tree    *next_peer;      /* Next node in list of peers */\n        struct tree    *next;   /* Next node in hashed list of names */\n        struct tree    *parent;\n        char           *label;  /* This node's textual name */\n        u_long          subid;  /* This node's integer subidentifier */\n        int             modid;  /* The module containing this node */\n        int             number_modules;\n        int            *module_list;    /* To handle multiple modules */\n        int             tc_index;       /* index into tclist (-1 if NA) */\n        int             type;   /* This node's object type */\n        int             access; /* This nodes access */\n        int             status; /* This nodes status */\n        struct enum_list *enums;        /* (optional) list of enumerated integers */\n        struct range_list *ranges;\n        struct index_list *indexes;\n        char           *augments;\n        struct varbind_list *varbinds;\n        char           *hint;\n        char           *units;\n        int             (*printomat) (u_char **, size_t *, size_t *, int,\n                                      const netsnmp_variable_list *,\n                                      const struct enum_list *, const char *,\n                                      const char *);\n        void            (*printer) (char *, const netsnmp_variable_list *, const struct enum_list *, const char *, const char *);   /* Value printing function */\n        char           *description;    /* description (a quoted string) */\n        char           *reference;    /* references (a quoted string) */\n        int             reported;       /* 1=report started in print_subtree... */\n        char           *defaultValue;\n       char\t       *parseErrorString; /* Contains the error string if there are errors in parsing MIBs */\n    };\n\n    /*\n     * Information held about each MIB module\n     */\n    struct module_import {\n        char           *label;  /* The descriptor being imported */\n        int             modid;  /* The module imported from */\n    };\n\n    struct module {\n        char           *name;   /* This module's name */\n        char           *file;   /* The file containing the module */\n        struct module_import *imports;  /* List of descriptors being imported */\n        int             no_imports;     /* The number of such import descriptors */\n        /*\n         * -1 implies the module hasn't been read in yet \n         */\n        int             modid;  /* The index number of this module */\n        struct module  *next;   /* Linked list pointer */\n    };\n\n    struct module_compatability {\n        const char     *old_module;\n        const char     *new_module;\n        const char     *tag;    /* NULL implies unconditional replacement,\n                                 * otherwise node identifier or prefix */\n        size_t          tag_len;        /* 0 implies exact match (or unconditional) */\n        struct module_compatability *next;      /* linked list */\n    };\n\n\n    /*\n     * non-aggregate types for tree end nodes \n     */\n#define TYPE_OTHER          0\n#define TYPE_OBJID          1\n#define TYPE_OCTETSTR       2\n#define TYPE_INTEGER        3\n#define TYPE_NETADDR        4\n#define TYPE_IPADDR         5\n#define TYPE_COUNTER        6\n#define TYPE_GAUGE          7\n#define TYPE_TIMETICKS      8\n#define TYPE_OPAQUE         9\n#define TYPE_NULL           10\n#define TYPE_COUNTER64      11\n#define TYPE_BITSTRING      12\n#define TYPE_NSAPADDRESS    13\n#define TYPE_UINTEGER       14\n#define TYPE_UNSIGNED32     15\n#define TYPE_INTEGER32      16\n\n#define TYPE_SIMPLE_LAST    16\n\n#define TYPE_TRAPTYPE\t    20\n#define TYPE_NOTIFTYPE      21\n#define TYPE_OBJGROUP\t    22\n#define TYPE_NOTIFGROUP\t    23\n#define TYPE_MODID\t    24\n#define TYPE_AGENTCAP       25\n#define TYPE_MODCOMP        26\n#define TYPE_OBJIDENTITY    27\n\n#define MIB_ACCESS_READONLY    18\n#define MIB_ACCESS_READWRITE   19\n#define\tMIB_ACCESS_WRITEONLY   20\n#define MIB_ACCESS_NOACCESS    21\n#define MIB_ACCESS_NOTIFY      67\n#define MIB_ACCESS_CREATE      48\n\n#define MIB_STATUS_MANDATORY   23\n#define MIB_STATUS_OPTIONAL    24\n#define MIB_STATUS_OBSOLETE    25\n#define MIB_STATUS_DEPRECATED  39\n#define MIB_STATUS_CURRENT     57\n\n#define\tANON\t\"anonymous#\"\n#define\tANON_LEN  strlen(ANON)\n\n    int             netsnmp_unload_module(const char *name);\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\n    int             unload_module(const char *name);\n#endif\n    void            netsnmp_init_mib_internals(void);\n    void            unload_all_mibs(void);\n    int             add_mibfile(const char*, const char*);\n    int             which_module(const char *);\n    NETSNMP_IMPORT\n    char           *module_name(int, char *);\n    NETSNMP_IMPORT\n    void            print_subtree(FILE *, struct tree *, int);\n    NETSNMP_IMPORT\n    void            print_ascii_dump_tree(FILE *, struct tree *, int);\n    NETSNMP_IMPORT\n    struct tree    *find_tree_node(const char *, int);\n    NETSNMP_IMPORT\n    const char     *get_tc_descriptor(int);\n    NETSNMP_IMPORT\n    const char     *get_tc_description(int);\n    NETSNMP_IMPORT\n    struct tree    *find_best_tree_node(const char *, struct tree *,\n                                        u_int *);\n    /*\n     * backwards compatability \n     */\n    NETSNMP_IMPORT\n    struct tree    *find_node(const char *, struct tree *);\n    struct tree    *find_node2(const char *, const char *); \n    NETSNMP_IMPORT\n    struct module  *find_module(int);\n    void            adopt_orphans(void);\n    NETSNMP_IMPORT\n    char           *snmp_mib_toggle_options(char *options);\n    NETSNMP_IMPORT\n    void            snmp_mib_toggle_options_usage(const char *lead,\n                                                  FILE * outf);\n    NETSNMP_IMPORT\n    void            print_mib(FILE *);\n    NETSNMP_IMPORT\n    void            print_mib_tree(FILE *, struct tree *, int);\n    int             get_mib_parse_error_count(void);\n    NETSNMP_IMPORT\n    int             snmp_get_token(FILE * fp, char *token, int maxtlen);\n    NETSNMP_IMPORT\n    struct tree    *find_best_tree_node(const char *name,\n                                        struct tree *tree_top,\n                                        u_int * match);\n\n#ifdef __cplusplus\n}\n#endif\n#endif                          /* PARSE_H */\n", "/*\n * mib.c\n *\n * $Id$\n *\n * Update: 1998-07-17 <jhy@gsu.edu>\n * Added print_oid_report* functions.\n *\n */\n/* Portions of this file are subject to the following copyrights.  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/**********************************************************************\n\tCopyright 1988, 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n *\n * Portions of this file are copyrighted by:\n * Copyright (c) 2016 VMware, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#include <stdio.h>\n#include <ctype.h>\n#include <sys/types.h>\n\n#if HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# if HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# if HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# if HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/asn1.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/parse.h>\n#include <net-snmp/library/int64.h>\n#include <net-snmp/library/snmp_client.h>\n\nnetsnmp_feature_child_of(mib_api, libnetsnmp)\nnetsnmp_feature_child_of(mib_strings_all, mib_api)\n\nnetsnmp_feature_child_of(mib_snprint, mib_strings_all)\nnetsnmp_feature_child_of(mib_snprint_description, mib_strings_all)\nnetsnmp_feature_child_of(mib_snprint_variable, mib_strings_all)\nnetsnmp_feature_child_of(mib_string_conversions, mib_strings_all)\nnetsnmp_feature_child_of(print_mib, mib_strings_all)\nnetsnmp_feature_child_of(snprint_objid, mib_strings_all)\nnetsnmp_feature_child_of(snprint_value, mib_strings_all)\n\nnetsnmp_feature_child_of(mib_to_asn_type, mib_api)\n\n/** @defgroup mib_utilities mib parsing and datatype manipulation routines.\n *  @ingroup library\n *\n *  @{\n */\n\nstatic char    *uptimeString(u_long, char *, size_t);\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic struct tree *_get_realloc_symbol(const oid * objid, size_t objidlen,\n                                        struct tree *subtree,\n                                        u_char ** buf, size_t * buf_len,\n                                        size_t * out_len,\n                                        int allow_realloc,\n                                        int *buf_overflow,\n                                        struct index_list *in_dices,\n                                        size_t * end_of_known);\n\nstatic int      print_tree_node(u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc,\n                                struct tree *tp, int width);\nstatic void     handle_mibdirs_conf(const char *token, char *line);\nstatic void     handle_mibs_conf(const char *token, char *line);\nstatic void     handle_mibfile_conf(const char *token, char *line);\n#endif /*NETSNMP_DISABLE_MIB_LOADING */\n\nstatic void     _oid_finish_printing(const oid * objid, size_t objidlen,\n                                     u_char ** buf, size_t * buf_len,\n                                     size_t * out_len,\n                                     int allow_realloc, int *buf_overflow);\n\n/*\n * helper functions for get_module_node \n */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic int      node_to_oid(struct tree *, oid *, size_t *);\nstatic int      _add_strings_to_oid(struct tree *, char *,\n                                    oid *, size_t *, size_t);\n#else\nstatic int      _add_strings_to_oid(void *, char *,\n                                    oid *, size_t *, size_t);\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nNETSNMP_IMPORT struct tree *tree_head;\nstatic struct tree *tree_top;\n\nNETSNMP_IMPORT struct tree *Mib;\nstruct tree    *Mib;            /* Backwards compatibility */\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nstatic char     Standard_Prefix[] = \".1.3.6.1.2.1\";\n\n/*\n * Set default here as some uses of read_objid require valid pointer. \n */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic char    *Prefix = &Standard_Prefix[0];\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\ntypedef struct _PrefixList {\n    const char     *str;\n    int             len;\n}              *PrefixListPtr, PrefixList;\n\n/*\n * Here are the prefix strings.\n * Note that the first one finds the value of Prefix or Standard_Prefix.\n * Any of these MAY start with period; all will NOT end with period.\n * Period is added where needed.  See use of Prefix in this module.\n */\nPrefixList      mib_prefixes[] = {\n    {&Standard_Prefix[0]},      /* placeholder for Prefix data */\n    {\".iso.org.dod.internet.mgmt.mib-2\"},\n    {\".iso.org.dod.internet.experimental\"},\n    {\".iso.org.dod.internet.private\"},\n    {\".iso.org.dod.internet.snmpParties\"},\n    {\".iso.org.dod.internet.snmpSecrets\"},\n    {NULL, 0}                   /* end of list */\n};\n\nenum inet_address_type {\n    IPV4 = 1,\n    IPV6 = 2,\n    IPV4Z = 3,\n    IPV6Z = 4,\n    DNS = 16\n};\n\n\n/**\n * @internal\n * Converts timeticks to hours, minutes, seconds string.\n *\n * @param timeticks    The timeticks to convert.\n * @param buf          Buffer to write to, has to be at \n *                     least 40 Bytes large.\n *       \n * @return The buffer.\n */\nstatic char    *\nuptimeString(u_long timeticks, char *buf, size_t buflen)\n{\n    int             centisecs, seconds, minutes, hours, days;\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {\n        snprintf(buf, buflen, \"%lu\", timeticks);\n        return buf;\n    }\n\n\n    centisecs = timeticks % 100;\n    timeticks /= 100;\n    days = timeticks / (60 * 60 * 24);\n    timeticks %= (60 * 60 * 24);\n\n    hours = timeticks / (60 * 60);\n    timeticks %= (60 * 60);\n\n    minutes = timeticks / 60;\n    seconds = timeticks % 60;\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT))\n        snprintf(buf, buflen, \"%d:%d:%02d:%02d.%02d\",\n                days, hours, minutes, seconds, centisecs);\n    else {\n        if (days == 0) {\n            snprintf(buf, buflen, \"%d:%02d:%02d.%02d\",\n                    hours, minutes, seconds, centisecs);\n        } else if (days == 1) {\n            snprintf(buf, buflen, \"%d day, %d:%02d:%02d.%02d\",\n                    days, hours, minutes, seconds, centisecs);\n        } else {\n            snprintf(buf, buflen, \"%d days, %d:%02d:%02d.%02d\",\n                    days, hours, minutes, seconds, centisecs);\n        }\n    }\n    return buf;\n}\n\n\n\n/**\n * @internal\n * Prints the character pointed to if in human-readable ASCII range,\n * otherwise prints a dot.\n *\n * @param buf Buffer to print the character to.\n * @param ch  Character to print.\n */\nstatic void\nsprint_char(char *buf, const u_char ch)\n{\n    if (isprint(ch) || isspace(ch)) {\n        sprintf(buf, \"%c\", (int) ch);\n    } else {\n        sprintf(buf, \".\");\n    }\n}\n\n\n\n/**\n * Prints a hexadecimal string into a buffer.\n *\n * The characters pointed by *cp are encoded as hexadecimal string.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      address of the buffer to print to.\n * @param buf_len  address to an integer containing the size of buf.\n * @param out_len  incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param cp       the array of characters to encode.\n * @param line_len the array length of cp.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\n_sprint_hexstring_line(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc, const u_char * cp, size_t line_len)\n{\n    const u_char   *tp;\n    const u_char   *cp2 = cp;\n    size_t          lenleft = line_len;\n\n    /*\n     * Make sure there's enough room for the hex output....\n     */\n    while ((*out_len + line_len*3+1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    /*\n     * .... and display the hex values themselves....\n     */\n    for (; lenleft >= 8; lenleft-=8) {\n        sprintf((char *) (*buf + *out_len),\n                \"%02X %02X %02X %02X %02X %02X %02X %02X \", cp[0], cp[1],\n                cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);\n        *out_len += strlen((char *) (*buf + *out_len));\n        cp       += 8;\n    }\n    for (; lenleft > 0; lenleft--) {\n        sprintf((char *) (*buf + *out_len), \"%02X \", *cp++);\n        *out_len += strlen((char *) (*buf + *out_len));\n    }\n\n    /*\n     * .... plus (optionally) do the same for the ASCII equivalent.\n     */\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT)) {\n        while ((*out_len + line_len+5) >= *buf_len) {\n            if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n        }\n        sprintf((char *) (*buf + *out_len), \"  [\");\n        *out_len += strlen((char *) (*buf + *out_len));\n        for (tp = cp2; tp < cp; tp++) {\n            sprint_char((char *) (*buf + *out_len), *tp);\n            (*out_len)++;\n        }\n        sprintf((char *) (*buf + *out_len), \"]\");\n        *out_len += strlen((char *) (*buf + *out_len));\n    }\n    return 1;\n}\n\nint\nsprint_realloc_hexstring(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc, const u_char * cp, size_t len)\n{\n    int line_len = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID,\n                                      NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);\n    if (line_len <= 0)\n        line_len = len;\n\n    for (; (int)len > line_len; len -= line_len) {\n        if(!_sprint_hexstring_line(buf, buf_len, out_len, allow_realloc, cp, line_len))\n            return 0;\n        *(*buf + (*out_len)++) = '\\n';\n        *(*buf + *out_len) = 0;\n        cp += line_len;\n    }\n    if(!_sprint_hexstring_line(buf, buf_len, out_len, allow_realloc, cp, len))\n        return 0;\n    *(*buf + *out_len) = 0;\n    return 1;\n}\n\n\n\n/**\n * Prints an ascii string into a buffer.\n *\n * The characters pointed by *cp are encoded as an ascii string.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      address of the buffer to print to.\n * @param buf_len  address to an integer containing the size of buf.\n * @param out_len  incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param cp       the array of characters to encode.\n * @param len      the array length of cp.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_asciistring(u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           const u_char * cp, size_t len)\n{\n    int             i;\n\n    for (i = 0; i < (int) len; i++) {\n        if (isprint(*cp) || isspace(*cp)) {\n            if (*cp == '\\\\' || *cp == '\"') {\n                if ((*out_len >= *buf_len) &&\n                    !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n                *(*buf + (*out_len)++) = '\\\\';\n            }\n            if ((*out_len >= *buf_len) &&\n                !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n            *(*buf + (*out_len)++) = *cp++;\n        } else {\n            if ((*out_len >= *buf_len) &&\n                !(allow_realloc && snmp_realloc(buf, buf_len))) {\n                return 0;\n            }\n            *(*buf + (*out_len)++) = '.';\n            cp++;\n        }\n    }\n    if ((*out_len >= *buf_len) &&\n        !(allow_realloc && snmp_realloc(buf, buf_len))) {\n        return 0;\n    }\n    *(*buf + *out_len) = '\\0';\n    return 1;\n}\n\n/**\n * Prints an octet string into a buffer.\n *\n * The variable var is encoded as octet string.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_octet_string(u_char ** buf, size_t * buf_len,\n                            size_t * out_len, int allow_realloc,\n                            const netsnmp_variable_list * var,\n                            const struct enum_list *enums, const char *hint,\n                            const char *units)\n{\n    size_t          saved_out_len = *out_len;\n    const char     *saved_hint = hint;\n    int             hex = 0, x = 0;\n    u_char         *cp;\n    int             output_format, cnt;\n\n    if (var->type != ASN_OCTET_STR) {\n        if (!netsnmp_ds_get_boolean(\n                    NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            const char      str[] = \"Wrong Type (should be OCTET STRING): \";\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n\n    if (hint) {\n        int             repeat, width = 1;\n        long            value;\n        char            code = 'd', separ = 0, term = 0, ch, intbuf[32];\n#define HEX2DIGIT_NEED_INIT 3\n        char            hex2digit = HEX2DIGIT_NEED_INIT;\n        u_char         *ecp;\n\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"STRING: \")) {\n                return 0;\n            }\n        }\n        cp = var->val.string;\n        ecp = cp + var->val_len;\n\n        while (cp < ecp) {\n            repeat = 1;\n            if (*hint) {\n                if (*hint == '*') {\n                    repeat = *cp++;\n                    hint++;\n                }\n                width = 0;\n                while ('0' <= *hint && *hint <= '9')\n                    width = (width * 10) + (*hint++ - '0');\n                code = *hint++;\n                if ((ch = *hint) && ch != '*' && (ch < '0' || ch > '9')\n                    && (width != 0\n                        || (ch != 'x' && ch != 'd' && ch != 'o')))\n                    separ = *hint++;\n                else\n                    separ = 0;\n                if ((ch = *hint) && ch != '*' && (ch < '0' || ch > '9')\n                    && (width != 0\n                        || (ch != 'x' && ch != 'd' && ch != 'o')))\n                    term = *hint++;\n                else\n                    term = 0;\n                if (width == 0)  /* Handle malformed hint strings */\n                    width = 1;\n            }\n\n            while (repeat && cp < ecp) {\n                value = 0;\n                if (code != 'a' && code != 't') {\n                    for (x = 0; x < width; x++) {\n                        value = value * 256 + *cp++;\n                    }\n                }\n                switch (code) {\n                case 'x':\n                    if (HEX2DIGIT_NEED_INIT == hex2digit)\n                        hex2digit = netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                                           NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);\n                    /*\n                     * if value is < 16, it will be a single hex digit. If the\n                     * width is 1 (we are outputting a byte at a time), pat it\n                     * to 2 digits if NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT is set\n                     * or all of the following are true:\n                     *  - we do not have a separation character\n                     *  - there is no hint left (or there never was a hint)\n                     *\n                     * e.g. for the data 0xAA01BB, would anyone really ever\n                     * want the string \"AA1BB\"??\n                     */\n                    if (((value < 16) && (1 == width)) &&\n                        (hex2digit || ((0 == separ) && (0 == *hint)))) {\n                        sprintf(intbuf, \"0%lx\", value);\n                    } else {\n                        sprintf(intbuf, \"%lx\", value);\n                    }\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 'd':\n                    sprintf(intbuf, \"%ld\", value);\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 'o':\n                    sprintf(intbuf, \"%lo\", value);\n                    if (!snmp_cstrcat\n                        (buf, buf_len, out_len, allow_realloc, intbuf)) {\n                        return 0;\n                    }\n                    break;\n                case 't': /* new in rfc 3411 */\n                case 'a':\n                    /* A string hint gives the max size - we may not need this much */\n                    cnt = SNMP_MIN(width, ecp - cp);\n                    while ((*out_len + cnt + 1) > *buf_len) {\n                        if (!allow_realloc || !snmp_realloc(buf, buf_len))\n                            return 0;\n                    }\n                    if (memchr(cp, '\\0', cnt) == NULL) {\n                        /* No embedded '\\0' - use memcpy() to preserve UTF-8 */\n                        memcpy(*buf + *out_len, cp, cnt);\n                        *out_len += cnt;\n                        *(*buf + *out_len) = '\\0';\n                    } else if (!sprint_realloc_asciistring(buf, buf_len,\n                                     out_len, allow_realloc, cp, cnt)) {\n                        return 0;\n                    }\n                    cp += cnt;\n                    break;\n                default:\n                    *out_len = saved_out_len;\n                    if (snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                     \"(Bad hint ignored: \")\n                        && snmp_cstrcat(buf, buf_len, out_len,\n                                       allow_realloc, saved_hint)\n                        && snmp_cstrcat(buf, buf_len, out_len,\n                                       allow_realloc, \") \")) {\n                        return sprint_realloc_octet_string(buf, buf_len,\n                                                           out_len,\n                                                           allow_realloc,\n                                                           var, enums,\n                                                           NULL, NULL);\n                    } else {\n                        return 0;\n                    }\n                }\n\n                if (cp < ecp && separ) {\n                    while ((*out_len + 1) >= *buf_len) {\n                        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                            return 0;\n                        }\n                    }\n                    *(*buf + *out_len) = separ;\n                    (*out_len)++;\n                    *(*buf + *out_len) = '\\0';\n                }\n                repeat--;\n            }\n\n            if (term && cp < ecp) {\n                while ((*out_len + 1) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = term;\n                (*out_len)++;\n                *(*buf + *out_len) = '\\0';\n            }\n        }\n\n        if (units) {\n            return (snmp_cstrcat\n                    (buf, buf_len, out_len, allow_realloc, \" \")\n                    && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n        }\n        if ((*out_len >= *buf_len) &&\n            !(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n        *(*buf + *out_len) = '\\0';\n\n        return 1;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_STRING_OUTPUT_GUESS;\n    }\n    switch (output_format) {\n    case NETSNMP_STRING_OUTPUT_GUESS:\n        hex = 0;\n        for (cp = var->val.string, x = 0; x < (int) var->val_len; x++, cp++) {\n            if (!isprint(*cp) && !isspace(*cp)) {\n                hex = 1;\n            }\n        }\n        break;\n\n    case NETSNMP_STRING_OUTPUT_ASCII:\n        hex = 0;\n        break;\n\n    case NETSNMP_STRING_OUTPUT_HEX:\n        hex = 1;\n        break;\n    }\n\n    if (var->val_len == 0) {\n        return snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\\"\");\n    }\n\n    if (hex) {\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n                return 0;\n            }\n        } else {\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Hex-STRING: \")) {\n                return 0;\n            }\n        }\n\n        if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                      var->val.string, var->val_len)) {\n            return 0;\n        }\n\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n                return 0;\n            }\n        }\n    } else {\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"STRING: \")) {\n                return 0;\n            }\n        }\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n            return 0;\n        }\n        if (!sprint_realloc_asciistring\n            (buf, buf_len, out_len, allow_realloc, var->val.string,\n             var->val_len)) {\n            return 0;\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\")) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n\n/**\n * Prints a float into a buffer.\n *\n * The variable var is encoded as a floating point value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_float(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const netsnmp_variable_list * var,\n                     const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    char *printf_format_string = NULL;\n\n    if (var->type != ASN_OPAQUE_FLOAT) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Float): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"Opaque: Float: \")) {\n            return 0;\n        }\n    }\n\n\n    /*\n     * How much space needed for max. length float?  128 is overkill.  \n     */\n\n    while ((*out_len + 128 + 1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    printf_format_string = make_printf_format_string(\"%f\");\n    if (!printf_format_string) {\n        return 0;\n    }\n    snprintf((char *)(*buf + *out_len), 128, printf_format_string, *var->val.floatVal);\n    free(printf_format_string);\n    *out_len += strlen((char *) (*buf + *out_len));\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a double into a buffer.\n *\n * The variable var is encoded as a double precision floating point value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_double(u_char ** buf, size_t * buf_len,\n                      size_t * out_len, int allow_realloc,\n                      const netsnmp_variable_list * var,\n                      const struct enum_list *enums,\n                      const char *hint, const char *units)\n{\n    char *printf_format_string = NULL;\n\n    if (var->type != ASN_OPAQUE_DOUBLE) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Double): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_cstrcat\n            (buf, buf_len, out_len, allow_realloc, \"Opaque: Float: \")) {\n            return 0;\n        }\n    }\n\n    /*\n     * How much space needed for max. length double?  128 is overkill.  \n     */\n\n    while ((*out_len + 128 + 1) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    printf_format_string = make_printf_format_string(\"%f\");\n    if (!printf_format_string) {\n        return 0;\n    }\n    snprintf((char *)(*buf + *out_len), 128, printf_format_string, *var->val.doubleVal);\n    free(printf_format_string);\n    *out_len += strlen((char *) (*buf + *out_len));\n\n    if (units) {\n        return (snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n\n\n/**\n * Prints a counter into a buffer.\n *\n * The variable var is encoded as a counter value.\n * \n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_counter64(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    char            a64buf[I64CHARSZ + 1];\n\n    if (var->type != ASN_COUNTER64\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        && var->type != ASN_OPAQUE_COUNTER64\n        && var->type != ASN_OPAQUE_I64 && var->type != ASN_OPAQUE_U64\n#endif\n        ) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Counter64): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        if (var->type != ASN_COUNTER64) {\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Opaque: \")) {\n                return 0;\n            }\n        }\n#endif\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        switch (var->type) {\n        case ASN_OPAQUE_U64:\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"UInt64: \")) {\n                return 0;\n            }\n            break;\n        case ASN_OPAQUE_I64:\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Int64: \")) {\n                return 0;\n            }\n            break;\n        case ASN_COUNTER64:\n        case ASN_OPAQUE_COUNTER64:\n#endif\n            if (!snmp_cstrcat\n                (buf, buf_len, out_len, allow_realloc, \"Counter64: \")) {\n                return 0;\n            }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        }\n#endif\n    }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    if (var->type == ASN_OPAQUE_I64) {\n        printI64(a64buf, var->val.counter64);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, a64buf)) {\n            return 0;\n        }\n    } else {\n#endif\n        printU64(a64buf, var->val.counter64);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, a64buf)) {\n            return 0;\n        }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    }\n#endif\n\n    if (units) {\n        return (snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" \")\n                && snmp_cstrcat(buf, buf_len, out_len, allow_realloc, units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an object identifier into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_opaque(u_char ** buf, size_t * buf_len,\n                      size_t * out_len, int allow_realloc,\n                      const netsnmp_variable_list * var,\n                      const struct enum_list *enums,\n                      const char *hint, const char *units)\n{\n    if (var->type != ASN_OPAQUE\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n        && var->type != ASN_OPAQUE_COUNTER64\n        && var->type != ASN_OPAQUE_U64\n        && var->type != ASN_OPAQUE_I64\n        && var->type != ASN_OPAQUE_FLOAT && var->type != ASN_OPAQUE_DOUBLE\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n        ) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Opaque): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    switch (var->type) {\n    case ASN_OPAQUE_COUNTER64:\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n        return sprint_realloc_counter64(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n        break;\n\n    case ASN_OPAQUE_FLOAT:\n        return sprint_realloc_float(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n        break;\n\n    case ASN_OPAQUE_DOUBLE:\n        return sprint_realloc_double(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n        break;\n\n    case ASN_OPAQUE:\n#endif\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n            u_char          str[] = \"OPAQUE: \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n                return 0;\n            }\n        }\n        if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                      var->val.string, var->val_len)) {\n            return 0;\n        }\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    }\n#endif\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an object identifier into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_object_identifier(u_char ** buf, size_t * buf_len,\n                                 size_t * out_len, int allow_realloc,\n                                 const netsnmp_variable_list * var,\n                                 const struct enum_list *enums,\n                                 const char *hint, const char *units)\n{\n    int             buf_overflow = 0;\n\n    if (var->type != ASN_OBJECT_ID) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be OBJECT IDENTIFIER): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"OID: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,\n                                      &buf_overflow,\n                                      (oid *) (var->val.objid),\n                                      var->val_len / sizeof(oid));\n\n    if (buf_overflow) {\n        return 0;\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n\n/**\n * Prints a timetick variable into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_timeticks(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    char            timebuf[40];\n\n    if (var->type != ASN_TIMETICKS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Timeticks): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS)) {\n        char            str[32];\n        sprintf(str, \"%lu\", *(u_long *) var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n        return 1;\n    }\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        char            str[32];\n        sprintf(str, \"Timeticks: (%lu) \", *(u_long *) var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n    uptimeString(*(u_long *) (var->val.integer), timebuf, sizeof(timebuf));\n    if (!snmp_strcat\n        (buf, buf_len, out_len, allow_realloc, (const u_char *) timebuf)) {\n        return 0;\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an integer according to the hint into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param val      The variable to encode.\n * @param decimaltype 'd' or 'u' depending on integer type\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may _NOT_ be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_hinted_integer(u_char ** buf, size_t * buf_len,\n                              size_t * out_len, int allow_realloc,\n                              long val, const char decimaltype,\n                              const char *hint, const char *units)\n{\n    char            fmt[10] = \"%l@\", tmp[256];\n    int             shift = 0, len, negative = 0;\n\n    if (hint[0] == 'd') {\n        /*\n         * We might *actually* want a 'u' here.  \n         */\n        if (hint[1] == '-')\n            shift = atoi(hint + 2);\n        fmt[2] = decimaltype;\n        if (val < 0) {\n            negative = 1;\n            val = -val;\n        }\n    } else {\n        /*\n         * DISPLAY-HINT character is 'b', 'o', or 'x'.  \n         */\n        fmt[2] = hint[0];\n    }\n\n    if (hint[0] == 'b') {\n\tunsigned long int bit = 0x80000000LU;\n\tchar *bp = tmp;\n\twhile (bit) {\n\t    *bp++ = val & bit ? '1' : '0';\n\t    bit >>= 1;\n\t}\n\t*bp = 0;\n    }\n    else\n\tsprintf(tmp, fmt, val);\n\n    if (shift != 0) {\n        len = strlen(tmp);\n        if (shift <= len) {\n            tmp[len + 1] = 0;\n            while (shift--) {\n                tmp[len] = tmp[len - 1];\n                len--;\n            }\n            tmp[len] = '.';\n        } else {\n            tmp[shift + 1] = 0;\n            while (shift) {\n                if (len-- > 0) {\n                    tmp[shift] = tmp[len];\n                } else {\n                    tmp[shift] = '0';\n                }\n                shift--;\n            }\n            tmp[0] = '.';\n        }\n    }\n    if (negative) {\n        len = strlen(tmp)+1;\n        while (len) {\n            tmp[len] = tmp[len-1];\n            len--;\n        }\n        tmp[0] = '-';\n    }\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, (u_char *)tmp);\n}\n\n\n/**\n * Prints an integer into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_integer(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    char           *enum_string = NULL;\n\n    if (var->type != ASN_INTEGER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be INTEGER): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    for (; enums; enums = enums->next) {\n        if (enums->value == *var->val.integer) {\n            enum_string = enums->label;\n            break;\n        }\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                         (const u_char *) \"INTEGER: \")) {\n            return 0;\n        }\n    }\n\n    if (enum_string == NULL ||\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n        if (hint) {\n            if (!(sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                                allow_realloc,\n                                                *var->val.integer, 'd',\n                                                hint, units))) {\n                return 0;\n            }\n        } else {\n            char            str[32];\n            sprintf(str, \"%ld\", *var->val.integer);\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) str)) {\n                return 0;\n            }\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n    } else {\n        char            str[32];\n        sprintf(str, \"(%ld)\", *var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints an unsigned integer into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_uinteger(u_char ** buf, size_t * buf_len, size_t * out_len,\n                        int allow_realloc,\n                        const netsnmp_variable_list * var,\n                        const struct enum_list *enums,\n                        const char *hint, const char *units)\n{\n    char           *enum_string = NULL;\n\n    if (var->type != ASN_UINTEGER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be UInteger32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    for (; enums; enums = enums->next) {\n        if (enums->value == *var->val.integer) {\n            enum_string = enums->label;\n            break;\n        }\n    }\n\n    if (enum_string == NULL ||\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n        if (hint) {\n            if (!(sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                                allow_realloc,\n                                                *var->val.integer, 'u',\n                                                hint, units))) {\n                return 0;\n            }\n        } else {\n            char            str[32];\n            sprintf(str, \"%lu\", *var->val.integer);\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) str)) {\n                return 0;\n            }\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n    } else {\n        char            str[32];\n        sprintf(str, \"(%lu)\", *var->val.integer);\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc,\n             (const u_char *) enum_string)) {\n            return 0;\n        }\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) str)) {\n            return 0;\n        }\n    }\n\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a gauge value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_gauge(u_char ** buf, size_t * buf_len, size_t * out_len,\n                     int allow_realloc,\n                     const netsnmp_variable_list * var,\n                     const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    char            tmp[32];\n\n    if (var->type != ASN_GAUGE) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Gauge32 or Unsigned32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Gauge32: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    if (hint) {\n        if (!sprint_realloc_hinted_integer(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           *var->val.integer, 'u', hint,\n                                           units)) {\n            return 0;\n        }\n    } else {\n        sprintf(tmp, \"%u\", (unsigned int)(*var->val.integer & 0xffffffff));\n        if (!snmp_strcat\n            (buf, buf_len, out_len, allow_realloc, (const u_char *) tmp)) {\n            return 0;\n        }\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a counter value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_counter(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    char            tmp[32];\n\n    if (var->type != ASN_COUNTER) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be Counter32): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Counter32: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    sprintf(tmp, \"%u\", (unsigned int)(*var->val.integer & 0xffffffff));\n    if (!snmp_strcat\n        (buf, buf_len, out_len, allow_realloc, (const u_char *) tmp)) {\n        return 0;\n    }\n    if (units) {\n        return (snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" \")\n                && snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                               (const u_char *) units));\n    }\n    return 1;\n}\n\n\n/**\n * Prints a network address into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_networkaddress(u_char ** buf, size_t * buf_len,\n                              size_t * out_len, int allow_realloc,\n                              const netsnmp_variable_list * var,\n                              const struct enum_list *enums, const char *hint,\n                              const char *units)\n{\n    size_t          i;\n\n    if (var->type != ASN_IPADDRESS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NetworkAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"Network Address: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    while ((*out_len + (var->val_len * 3) + 2) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n\n    for (i = 0; i < var->val_len; i++) {\n        sprintf((char *) (*buf + *out_len), \"%02X\", var->val.string[i]);\n        *out_len += 2;\n        if (i < var->val_len - 1) {\n            *(*buf + *out_len) = ':';\n            (*out_len)++;\n        }\n    }\n    return 1;\n}\n\n\n/**\n * Prints an ip-address into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_ipaddress(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    u_char         *ip = var->val.string;\n\n    if (var->type != ASN_IPADDRESS) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be IpAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"IpAddress: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    while ((*out_len + 17) >= *buf_len) {\n        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n            return 0;\n        }\n    }\n    if (ip)\n        sprintf((char *) (*buf + *out_len), \"%d.%d.%d.%d\",\n                                            ip[0], ip[1], ip[2], ip[3]);\n    *out_len += strlen((char *) (*buf + *out_len));\n    return 1;\n}\n\n\n/**\n * Prints a null value into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_null(u_char ** buf, size_t * buf_len, size_t * out_len,\n                    int allow_realloc,\n                    const netsnmp_variable_list * var,\n                    const struct enum_list *enums,\n                    const char *hint, const char *units)\n{\n    u_char          str[] = \"NULL\";\n\n    if (var->type != ASN_NULL) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NULL): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, str);\n}\n\n\n/**\n * Prints a bit string into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_bitstring(u_char ** buf, size_t * buf_len, size_t * out_len,\n                         int allow_realloc,\n                         const netsnmp_variable_list * var,\n                         const struct enum_list *enums,\n                         const char *hint, const char *units)\n{\n    int             len, bit;\n    u_char         *cp;\n    char           *enum_string;\n\n    if (var->type != ASN_BIT_STR && var->type != ASN_OCTET_STR) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be BITS): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"\\\"\";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    } else {\n        u_char          str[] = \"BITS: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n    if (!sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                  var->val.bitstring, var->val_len)) {\n        return 0;\n    }\n\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"\\\"\";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    } else {\n        cp = var->val.bitstring;\n        for (len = 0; len < (int) var->val_len; len++) {\n            for (bit = 0; bit < 8; bit++) {\n                if (*cp & (0x80 >> bit)) {\n                    enum_string = NULL;\n                    for (; enums; enums = enums->next) {\n                        if (enums->value == (len * 8) + bit) {\n                            enum_string = enums->label;\n                            break;\n                        }\n                    }\n                    if (enum_string == NULL ||\n                        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                       NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM)) {\n                        char            str[32];\n                        sprintf(str, \"%d \", (len * 8) + bit);\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) str)) {\n                            return 0;\n                        }\n                    } else {\n                        char            str[32];\n                        sprintf(str, \"(%d) \", (len * 8) + bit);\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) enum_string)) {\n                            return 0;\n                        }\n                        if (!snmp_strcat\n                            (buf, buf_len, out_len, allow_realloc,\n                             (const u_char *) str)) {\n                            return 0;\n                        }\n                    }\n                }\n            }\n            cp++;\n        }\n    }\n    return 1;\n}\n\nint\nsprint_realloc_nsapaddress(u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           const netsnmp_variable_list * var,\n                           const struct enum_list *enums, const char *hint,\n                           const char *units)\n{\n    if (var->type != ASN_NSAP) {\n        if (!netsnmp_ds_get_boolean(\n                NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            u_char          str[] = \"Wrong Type (should be NsapAddress): \";\n            if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str))\n                return 0;\n        }\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, var, NULL, NULL,\n                                          NULL);\n    }\n\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n        u_char          str[] = \"NsapAddress: \";\n        if (!snmp_strcat(buf, buf_len, out_len, allow_realloc, str)) {\n            return 0;\n        }\n    }\n\n    return sprint_realloc_hexstring(buf, buf_len, out_len, allow_realloc,\n                                    var->val.string, var->val_len);\n}\n\n\n/**\n * Fallback routine for a bad type, prints \"Variable has bad type\" into a buffer.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_badtype(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    u_char          str[] = \"Variable has bad type\";\n\n    return snmp_strcat(buf, buf_len, out_len, allow_realloc, str);\n}\n\n\n\n/**\n * Universal print routine, prints a variable into a buffer according to the variable \n * type.\n *\n * If allow_realloc is true the buffer will be (re)allocated to fit in the \n * needed size. (Note: *buf may change due to this.)\n * \n * @param buf      Address of the buffer to print to.\n * @param buf_len  Address to an integer containing the size of buf.\n * @param out_len  Incremented by the number of characters printed.\n * @param allow_realloc if not zero reallocate the buffer to fit the \n *                      needed size.\n * @param var      The variable to encode.\n * @param enums    The enumeration ff this variable is enumerated. may be NULL.\n * @param hint     Contents of the DISPLAY-HINT clause of the MIB.\n *                 See RFC 1903 Section 3.1 for details. may be NULL.\n * @param units    Contents of the UNITS clause of the MIB. may be NULL.\n * \n * @return 1 on success, or 0 on failure (out of memory, or buffer to\n *         small when not allowed to realloc.)\n */\nint\nsprint_realloc_by_type(u_char ** buf, size_t * buf_len, size_t * out_len,\n                       int allow_realloc,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums,\n                       const char *hint, const char *units)\n{\n    DEBUGMSGTL((\"output\", \"sprint_by_type, type %d\\n\", var->type));\n\n    switch (var->type) {\n    case ASN_INTEGER:\n        return sprint_realloc_integer(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    case ASN_OCTET_STR:\n        return sprint_realloc_octet_string(buf, buf_len, out_len,\n                                           allow_realloc, var, enums, hint,\n                                           units);\n    case ASN_BIT_STR:\n        return sprint_realloc_bitstring(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_OPAQUE:\n        return sprint_realloc_opaque(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n    case ASN_OBJECT_ID:\n        return sprint_realloc_object_identifier(buf, buf_len, out_len,\n                                                allow_realloc, var, enums,\n                                                hint, units);\n    case ASN_TIMETICKS:\n        return sprint_realloc_timeticks(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_GAUGE:\n        return sprint_realloc_gauge(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n    case ASN_COUNTER:\n        return sprint_realloc_counter(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    case ASN_IPADDRESS:\n        return sprint_realloc_ipaddress(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n    case ASN_NULL:\n        return sprint_realloc_null(buf, buf_len, out_len, allow_realloc,\n                                   var, enums, hint, units);\n    case ASN_UINTEGER:\n        return sprint_realloc_uinteger(buf, buf_len, out_len,\n                                       allow_realloc, var, enums, hint,\n                                       units);\n    case ASN_COUNTER64:\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_U64:\n    case ASN_OPAQUE_I64:\n    case ASN_OPAQUE_COUNTER64:\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n        return sprint_realloc_counter64(buf, buf_len, out_len,\n                                        allow_realloc, var, enums, hint,\n                                        units);\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\n    case ASN_OPAQUE_FLOAT:\n        return sprint_realloc_float(buf, buf_len, out_len, allow_realloc,\n                                    var, enums, hint, units);\n    case ASN_OPAQUE_DOUBLE:\n        return sprint_realloc_double(buf, buf_len, out_len, allow_realloc,\n                                     var, enums, hint, units);\n#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */\n    default:\n        DEBUGMSGTL((\"sprint_by_type\", \"bad type: %d\\n\", var->type));\n        return sprint_realloc_badtype(buf, buf_len, out_len, allow_realloc,\n                                      var, enums, hint, units);\n    }\n}\n\n/**\n * Generates a prinf format string.\n *\n * The original format string is combined with the optional\n * NETSNMP_DS_LIB_OUTPUT_PRECISION string (the -Op parameter).\n *\n * Example:\n * If the original format string is \"%f\", and the NETSNMP_DS_LIB_OUTPUT_PRECISION\n * is \"5.2\", the returned format string will be \"%5.2f\".\n * \n * The PRECISION string is inserted after the '%' of the original format string.\n * To prevent buffer overflow if NETSNMP_DS_LIB_OUTPUT_PRECISION is set to an\n * illegal size (e.g. with -Op 10000) snprintf should be used to prevent buffer\n * overflow.\n * \n * @param printf_format_default  The format string used by the original printf.\n * \n * @return The address of of the new allocated format string (which must be freed\n *         if no longer used), or NULL if any error (malloc).\n */\nchar *\nmake_printf_format_string(const char *printf_format_default)\n{\n    const char *cp_printf_format_default;\n    const char *printf_precision;\n    const char *cp_printf_precision;\n    char       *printf_format_string;\n    char       *cp_out;\n    char       c;\n\n    printf_precision = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OUTPUT_PRECISION);\n    if (!printf_precision) {\n        printf_precision = \"\";\n    }\n\n    /* reserve new format string buffer */\n    printf_format_string = (char *) malloc(strlen(printf_format_default)+strlen(printf_precision)+1);\n    if (!printf_format_string)\n    {\n        DEBUGMSGTL((\"make_printf_format_string\", \"malloc failed\\n\"));\n        return NULL;\n    }\n\n    /* copy default format string, including the '%' */\n    cp_out = printf_format_string;\n    cp_printf_format_default = printf_format_default;\n    while((c = *cp_printf_format_default) != '\\0')\n    {\n        *cp_out++ = c;\n        cp_printf_format_default++;\n        if (c == '%') break;\n    }\n\n    /* insert the precision string */\n    cp_printf_precision = printf_precision;\n    while ((c = *cp_printf_precision++) != '\\0')\n    {\n        *cp_out++ = c;\n    }\n\n    /* copy the remaining default format string, including the terminating '\\0' */\n    strcpy(cp_out, cp_printf_format_default);\n\n    DEBUGMSGTL((\"make_printf_format_string\", \"\\\"%s\\\"+\\\"%s\\\"->\\\"%s\\\"\\n\",\n                printf_format_default, printf_precision, printf_format_string));\n    return printf_format_string;\n}\n\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/**\n * Retrieves the tree head.\n *\n * @return the tree head.\n */\nstruct tree    *\nget_tree_head(void)\n{\n    return (tree_head);\n}\n\nstatic char    *confmibdir = NULL;\nstatic char    *confmibs = NULL;\n\nstatic void\nhandle_mibdirs_conf(const char *token, char *line)\n{\n    char           *ctmp;\n\n    if (confmibdir) {\n        if ((*line == '+') || (*line == '-')) {\n            ctmp = (char *) malloc(strlen(confmibdir) + strlen(line) + 2);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\",\n                            \"mibdir conf malloc failed\"));\n                return;\n            }\n            if(*line++ == '+')\n                sprintf(ctmp, \"%s%c%s\", confmibdir, ENV_SEPARATOR_CHAR, line);\n            else\n                sprintf(ctmp, \"%s%c%s\", line, ENV_SEPARATOR_CHAR, confmibdir);\n        } else {\n            ctmp = strdup(line);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n        }\n        SNMP_FREE(confmibdir);\n    } else {\n        ctmp = strdup(line);\n        if (!ctmp) {\n            DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n            return;\n        }\n    }\n    confmibdir = ctmp;\n    DEBUGMSGTL((\"read_config:initmib\", \"using mibdirs: %s\\n\", confmibdir));\n}\n\nstatic void\nhandle_mibs_conf(const char *token, char *line)\n{\n    char           *ctmp;\n\n    if (confmibs) {\n        if ((*line == '+') || (*line == '-')) {\n            ctmp = (char *) malloc(strlen(confmibs) + strlen(line) + 2);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n            if(*line++ == '+')\n                sprintf(ctmp, \"%s%c%s\", confmibs, ENV_SEPARATOR_CHAR, line);\n            else\n                sprintf(ctmp, \"%s%c%s\", line, ENV_SEPARATOR_CHAR, confmibdir);\n        } else {\n            ctmp = strdup(line);\n            if (!ctmp) {\n                DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n                return;\n            }\n        }\n        SNMP_FREE(confmibs);\n    } else {\n        ctmp = strdup(line);\n        if (!ctmp) {\n            DEBUGMSGTL((\"read_config:initmib\", \"mibs conf malloc failed\"));\n            return;\n        }\n    }\n    confmibs = ctmp;\n    DEBUGMSGTL((\"read_config:initmib\", \"using mibs: %s\\n\", confmibs));\n}\n\n\nstatic void\nhandle_mibfile_conf(const char *token, char *line)\n{\n    DEBUGMSGTL((\"read_config:initmib\", \"reading mibfile: %s\\n\", line));\n    read_mib(line);\n}\n#endif\n\nstatic void\nhandle_print_numeric(const char *token, char *line)\n{\n    const char *value;\n    char       *st;\n\n    value = strtok_r(line, \" \\t\\n\", &st);\n    if (value && (\n\t    (strcasecmp(value, \"yes\")  == 0) || \n\t    (strcasecmp(value, \"true\") == 0) ||\n\t    (*value == '1') )) {\n\n        netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                  NETSNMP_OID_OUTPUT_NUMERIC);\n    }\n}\n\nchar *\nsnmp_out_options(char *options, int argc, char *const *argv)\n{\n    while (*options) {\n        switch (*options++) {\n        case '0':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n                                      NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT);\n            break;\n        case 'a':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,\n                                                      NETSNMP_STRING_OUTPUT_ASCII);\n            break;\n        case 'b':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);\n            break;\n        case 'e':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n            break;\n        case 'E':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);\n            break;\n        case 'f':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_FULL);\n            break;\n        case 'n':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_NUMERIC);\n            break;\n        case 'p':\n            /* What if argc/argv are null ? */\n            if (!*(options)) {\n                options = argv[optind++];\n            }\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OUTPUT_PRECISION,\n                                  options);\n            return NULL;  /* -Op... is a standalone option, so we're done here */\n        case 'q':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n            break;\n        case 'Q':\n            netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT, 1);\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n            break;\n        case 's':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_SUFFIX);\n            break;\n        case 'S':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_MODULE);\n            break;\n        case 't':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);\n            break;\n        case 'T':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);\n            break;\n        case 'u':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT,\n                                                      NETSNMP_OID_OUTPUT_UCD);\n            break;\n        case 'U':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);\n            break;\n        case 'v':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);\n            break;\n        case 'x':\n            netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT,\n                                                      NETSNMP_STRING_OUTPUT_HEX);\n            break;\n        case 'X':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n            break;\n        default:\n            return options - 1;\n        }\n    }\n    return NULL;\n}\n\nchar           *\nsnmp_out_toggle_options(char *options)\n{\n    return snmp_out_options( options, 0, NULL );\n}\n\nvoid\nsnmp_out_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%s0:  print leading 0 for single-digit hex characters\\n\", lead);\n    fprintf(outf, \"%sa:  print all strings in ascii format\\n\", lead);\n    fprintf(outf, \"%sb:  do not break OID indexes down\\n\", lead);\n    fprintf(outf, \"%se:  print enums numerically\\n\", lead);\n    fprintf(outf, \"%sE:  escape quotes in string indices\\n\", lead);\n    fprintf(outf, \"%sf:  print full OIDs on output\\n\", lead);\n    fprintf(outf, \"%sn:  print OIDs numerically\\n\", lead);\n    fprintf(outf, \"%sp PRECISION:  display floating point values with specified PRECISION (printf format string)\\n\", lead);\n    fprintf(outf, \"%sq:  quick print for easier parsing\\n\", lead);\n    fprintf(outf, \"%sQ:  quick print with equal-signs\\n\", lead);    /* @@JDW */\n    fprintf(outf, \"%ss:  print only last symbolic element of OID\\n\", lead);\n    fprintf(outf, \"%sS:  print MIB module-id plus last element\\n\", lead);\n    fprintf(outf, \"%st:  print timeticks unparsed as numeric integers\\n\",\n            lead);\n    fprintf(outf,\n            \"%sT:  print human-readable text along with hex strings\\n\",\n            lead);\n    fprintf(outf, \"%su:  print OIDs using UCD-style prefix suppression\\n\",\n            lead);\n    fprintf(outf, \"%sU:  don't print units\\n\", lead);\n    fprintf(outf, \"%sv:  print values only (not OID = value)\\n\", lead);\n    fprintf(outf, \"%sx:  print all strings in hex format\\n\", lead);\n    fprintf(outf, \"%sX:  extended index format\\n\", lead);\n}\n\nchar *\nsnmp_in_options(char *optarg, int argc, char *const *argv)\n{\n    char *cp;\n\n    for (cp = optarg; *cp; cp++) {\n        switch (*cp) {\n        case 'b':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS);\n            break;\n        case 'R':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS);\n            break;\n        case 'r':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);\n            break;\n        case 'h':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);\n            break;\n        case 'u':\n            netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID);\n            break;\n        case 's':\n            /* What if argc/argv are null ? */\n            if (!*(++cp))\n                cp = argv[optind++];\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OIDSUFFIX,\n                                  cp);\n            return NULL;  /* -Is... is a standalone option, so we're done here */\n\n        case 'S':\n            /* What if argc/argv are null ? */\n            if (!*(++cp))\n                cp = argv[optind++];\n            netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID,\n                                  NETSNMP_DS_LIB_OIDPREFIX,\n                                  cp);\n            return NULL;  /* -IS... is a standalone option, so we're done here */\n\n        default:\n           /*\n            *  Here?  Or in snmp_parse_args?\n            snmp_log(LOG_ERR, \"Unknown input option passed to -I: %c.\\n\", *cp);\n            */\n            return cp;\n        }\n    }\n    return NULL;\n}\n\nchar           *\nsnmp_in_toggle_options(char *options)\n{\n    return snmp_in_options( options, 0, NULL );\n}\n\n\n/**\n * Prints out a help usage for the in* toggle options.\n *\n * @param lead      The lead to print for every line.\n * @param outf      The file descriptor to write to.\n * \n */\nvoid\nsnmp_in_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%sb:  do best/regex matching to find a MIB node\\n\", lead);\n    fprintf(outf, \"%sh:  don't apply DISPLAY-HINTs\\n\", lead);\n    fprintf(outf, \"%sr:  do not check values for range/type legality\\n\", lead);\n    fprintf(outf, \"%sR:  do random access to OID labels\\n\", lead);\n    fprintf(outf,\n            \"%su:  top-level OIDs must have '.' prefix (UCD-style)\\n\", lead);\n    fprintf(outf,\n            \"%ss SUFFIX:  Append all textual OIDs with SUFFIX before parsing\\n\",\n            lead);\n    fprintf(outf,\n            \"%sS PREFIX:  Prepend all textual OIDs with PREFIX before parsing\\n\",\n            lead);\n}\n\n/***\n *\n */ \nvoid\nregister_mib_handlers(void)\n{\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    register_prenetsnmp_mib_handler(\"snmp\", \"mibdirs\",\n                                    handle_mibdirs_conf, NULL,\n                                    \"[mib-dirs|+mib-dirs|-mib-dirs]\");\n    register_prenetsnmp_mib_handler(\"snmp\", \"mibs\",\n                                    handle_mibs_conf, NULL,\n                                    \"[mib-tokens|+mib-tokens]\");\n    register_config_handler(\"snmp\", \"mibfile\",\n                            handle_mibfile_conf, NULL, \"mibfile-to-read\");\n    /*\n     * register the snmp.conf configuration handlers for default\n     * parsing behaviour \n     */\n\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"showMibErrors\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"commentToEOL\",     /* Describes actual behaviour */\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"strictCommentTerm\",    /* Backward compatibility */\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"mibAllowUnderline\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"mibWarningLevel\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"mibReplaceWithLatest\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_REPLACE);\n#endif\n\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printNumericEnums\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM);\n    register_prenetsnmp_mib_handler(\"snmp\", \"printNumericOids\",\n                       handle_print_numeric, NULL, \"(1|yes|true|0|no|false)\");\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"escapeQuotes\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"dontBreakdownOids\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"quickPrinting\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"numericTimeticks\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NUMERIC_TIMETICKS);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"oidOutputFormat\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"suffixPrinting\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"extendedIndex\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printHexText\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_HEX_TEXT);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"printValueOnly\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE);\n    netsnmp_ds_register_premib(ASN_BOOLEAN, \"snmp\", \"dontPrintUnits\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_PRINT_UNITS);\n    netsnmp_ds_register_premib(ASN_INTEGER, \"snmp\", \"hexOutputLength\",\n                       NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH);\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * function : netsnmp_set_mib_directory\n *            - This function sets the string of the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n * arguments: const char *dir, which are the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n * returns  : -\n */\nvoid\nnetsnmp_set_mib_directory(const char *dir)\n{\n    const char *newdir;\n    char *olddir, *tmpdir = NULL;\n\n    DEBUGTRACE;\n    if (NULL == dir) {\n        return;\n    }\n    \n    olddir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIBDIRS);\n    if (olddir) {\n        if ((*dir == '+') || (*dir == '-')) {\n            /** New dir starts with '+', thus we add it. */\n            tmpdir = (char *)malloc(strlen(dir) + strlen(olddir) + 2);\n            if (!tmpdir) {\n                DEBUGMSGTL((\"read_config:initmib\", \"set mibdir malloc failed\"));\n                return;\n            }\n            if (*dir++ == '+')\n                sprintf(tmpdir, \"%s%c%s\", olddir, ENV_SEPARATOR_CHAR, dir);\n            else\n                sprintf(tmpdir, \"%s%c%s\", dir, ENV_SEPARATOR_CHAR, olddir);\n            newdir = tmpdir;\n        } else {\n            newdir = dir;\n        }\n    } else {\n        /** If dir starts with '+' skip '+' it. */\n        newdir = ((*dir == '+') ? ++dir : dir);\n    }\n    netsnmp_ds_set_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS,\n                          newdir);\n\n    /** set_string calls strdup, so if we allocated memory, free it */\n    if (tmpdir == newdir) {\n        SNMP_FREE(tmpdir);\n    }\n}\n\n/*\n * function : netsnmp_get_mib_directory\n *            - This function returns a string of the directories\n *              from which the MIB modules will be searched or\n *              loaded.\n *              If the value still does not exists, it will be made\n *              from the evironment variable 'MIBDIRS' and/or the\n *              default.\n * arguments: -\n * returns  : char * of the directories in which the MIB modules\n *            will be searched/loaded.\n */\n\nchar *\nnetsnmp_get_mib_directory(void)\n{\n    char *dir;\n\n    DEBUGTRACE;\n    dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);\n    if (dir == NULL) {\n        DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set\\n\"));\n\n        /** Check if the environment variable is set */\n        dir = netsnmp_getenv(\"MIBDIRS\");\n        if (dir == NULL) {\n            DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set by environment\\n\"));\n            /** Not set use hard coded path */\n            if (confmibdir == NULL) {\n                DEBUGMSGTL((\"get_mib_directory\", \"no mib directories set by config\\n\"));\n                netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n            }\n            else if ((*confmibdir == '+') || (*confmibdir == '-')) {\n                DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by config (but added)\\n\"));\n                netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n                netsnmp_set_mib_directory(confmibdir);\n            }\n            else {\n                DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by config\\n\"));\n                netsnmp_set_mib_directory(confmibdir);\n            }\n        } else if ((*dir == '+') || (*dir == '-')) {\n            DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by environment (but added)\\n\"));\n            netsnmp_set_mib_directory(NETSNMP_DEFAULT_MIBDIRS);\n            netsnmp_set_mib_directory(dir);\n        } else {\n            DEBUGMSGTL((\"get_mib_directory\", \"mib directories set by environment\\n\"));\n            netsnmp_set_mib_directory(dir);\n        }\n        dir = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIBDIRS);\n    }\n    DEBUGMSGTL((\"get_mib_directory\", \"mib directories set '%s'\\n\", dir));\n    return(dir);\n}\n\n/*\n * function : netsnmp_fixup_mib_directory\n * arguments: -\n * returns  : -\n */\nvoid\nnetsnmp_fixup_mib_directory(void)\n{\n    char *homepath = netsnmp_getenv(\"HOME\");\n    char *mibpath = netsnmp_get_mib_directory();\n    char *oldmibpath = NULL;\n    char *ptr_home;\n    char *new_mibpath;\n\n    DEBUGTRACE;\n    if (homepath && mibpath) {\n        DEBUGMSGTL((\"fixup_mib_directory\", \"mib directories '%s'\\n\", mibpath));\n        while ((ptr_home = strstr(mibpath, \"$HOME\"))) {\n            new_mibpath = (char *)malloc(strlen(mibpath) - strlen(\"$HOME\") +\n\t\t\t\t\t strlen(homepath)+1);\n            if (new_mibpath) {\n                *ptr_home = 0; /* null out the spot where we stop copying */\n                sprintf(new_mibpath, \"%s%s%s\", mibpath, homepath,\n\t\t\tptr_home + strlen(\"$HOME\"));\n                /** swap in the new value and repeat */\n                mibpath = new_mibpath;\n\t\tif (oldmibpath != NULL) {\n\t\t    SNMP_FREE(oldmibpath);\n\t\t}\n\t\toldmibpath = new_mibpath;\n            } else {\n                break;\n            }\n        }\n\n        netsnmp_set_mib_directory(mibpath);\n\t\n\t/*  The above copies the mibpath for us, so...  */\n\n\tif (oldmibpath != NULL) {\n\t    SNMP_FREE(oldmibpath);\n\t}\n\n    }\n\n}\n\n/**\n * Initialises the mib reader.\n *\n * Reads in all settings from the environment.\n */\nvoid\nnetsnmp_init_mib(void)\n{\n    const char     *prefix;\n    char           *env_var, *entry;\n    PrefixListPtr   pp = &mib_prefixes[0];\n    char           *st = NULL;\n\n    if (Mib)\n        return;\n    netsnmp_init_mib_internals();\n\n    /*\n     * Initialise the MIB directory/ies \n     */\n    netsnmp_fixup_mib_directory();\n    env_var = strdup(netsnmp_get_mib_directory());\n    if (!env_var)\n        return;\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n                env_var));\n\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        add_mibdir(entry);\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if (*env_var == '+')\n            entry = strtok_r(env_var+1, ENV_SEPARATOR, &st);\n        else\n            entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            add_mibfile(entry, NULL);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n    }\n\n    netsnmp_init_mib_internals();\n\n    /*\n     * Read in any modules or mibs requested \n     */\n\n    env_var = netsnmp_getenv(\"MIBS\");\n    if (env_var == NULL) {\n        if (confmibs != NULL)\n            env_var = strdup(confmibs);\n        else\n            env_var = strdup(NETSNMP_DEFAULT_MIBS);\n    } else {\n        env_var = strdup(env_var);\n    }\n    if (env_var && ((*env_var == '+') || (*env_var == '-'))) {\n        entry =\n            (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2);\n        if (!entry) {\n            DEBUGMSGTL((\"init_mib\", \"env mibs malloc failed\"));\n            SNMP_FREE(env_var);\n            return;\n        } else {\n            if (*env_var == '+')\n                sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR,\n                        env_var+1);\n            else\n                sprintf(entry, \"%s%c%s\", env_var+1, ENV_SEPARATOR_CHAR,\n                        NETSNMP_DEFAULT_MIBS );\n        }\n        SNMP_FREE(env_var);\n        env_var = entry;\n    }\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBS: Looking in '%s' for mib files ...\\n\",\n                env_var));\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {\n            read_all_mibs();\n        } else if (strstr(entry, \"/\") != NULL) {\n            read_mib(entry);\n        } else {\n            netsnmp_read_module(entry);\n        }\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    adopt_orphans();\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if ((*env_var == '+') || (*env_var == '-')) {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n            entry =\n                (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) +\n                                strlen(env_var) + 2);\n            if (!entry) {\n                DEBUGMSGTL((\"init_mib\", \"env mibfiles malloc failed\"));\n            } else {\n                if (*env_var++ == '+')\n                    sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,\n                            env_var );\n                else\n                    sprintf(entry, \"%s%c%s\", env_var, ENV_SEPARATOR_CHAR,\n                            NETSNMP_DEFAULT_MIBFILES );\n            }\n            SNMP_FREE(env_var);\n            env_var = entry;\n#else\n            env_var = strdup(env_var + 1);\n#endif\n        } else {\n            env_var = strdup(env_var);\n        }\n    } else {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n        env_var = strdup(NETSNMP_DEFAULT_MIBFILES);\n#endif\n    }\n\n    if (env_var != NULL) {\n        DEBUGMSGTL((\"init_mib\",\n                    \"Seen MIBFILES: Looking in '%s' for mib files ...\\n\",\n                    env_var));\n        entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            read_mib(entry);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n        SNMP_FREE(env_var);\n    }\n\n    prefix = netsnmp_getenv(\"PREFIX\");\n\n    if (!prefix)\n        prefix = Standard_Prefix;\n\n    Prefix = (char *) malloc(strlen(prefix) + 2);\n    if (!Prefix)\n        DEBUGMSGTL((\"init_mib\", \"Prefix malloc failed\"));\n    else\n        strcpy(Prefix, prefix);\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen PREFIX: Looking in '%s' for prefix ...\\n\", Prefix));\n\n    /*\n     * remove trailing dot \n     */\n    if (Prefix) {\n        env_var = &Prefix[strlen(Prefix) - 1];\n        if (*env_var == '.')\n            *env_var = '\\0';\n    }\n\n    pp->str = Prefix;           /* fixup first mib_prefix entry */\n    /*\n     * now that the list of prefixes is built, save each string length. \n     */\n    while (pp->str) {\n        pp->len = strlen(pp->str);\n        pp++;\n    }\n\n    Mib = tree_head;            /* Backwards compatibility */\n    tree_top = (struct tree *) calloc(1, sizeof(struct tree));\n    /*\n     * XX error check ? \n     */\n    if (tree_top) {\n        tree_top->label = strdup(\"(top)\");\n        tree_top->child_list = tree_head;\n    }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nvoid\ninit_mib(void)\n{\n    netsnmp_init_mib();\n}\n#endif\n\n\n/**\n * Unloads all mibs.\n */\nvoid\nshutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}\n\n/**\n * Prints the MIBs to the file fp.\n *\n * @param fp   The file descriptor to print to.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_PRINT_MIB\nvoid\nprint_mib(FILE * fp)\n{\n    print_subtree(fp, tree_head, 0);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PRINT_MIB */\n\nvoid\nprint_ascii_dump(FILE * fp)\n{\n    fprintf(fp, \"dump DEFINITIONS ::= BEGIN\\n\");\n    print_ascii_dump_tree(fp, tree_head, 0);\n    fprintf(fp, \"END\\n\");\n}\n\n\n/**\n * Set's the printing function printomat in a subtree according\n * it's type\n *\n * @param subtree    The subtree to set.\n */\nvoid\nset_function(struct tree *subtree)\n{\n    subtree->printer = NULL;\n    switch (subtree->type) {\n    case TYPE_OBJID:\n        subtree->printomat = sprint_realloc_object_identifier;\n        break;\n    case TYPE_OCTETSTR:\n        subtree->printomat = sprint_realloc_octet_string;\n        break;\n    case TYPE_INTEGER:\n        subtree->printomat = sprint_realloc_integer;\n        break;\n    case TYPE_INTEGER32:\n        subtree->printomat = sprint_realloc_integer;\n        break;\n    case TYPE_NETADDR:\n        subtree->printomat = sprint_realloc_networkaddress;\n        break;\n    case TYPE_IPADDR:\n        subtree->printomat = sprint_realloc_ipaddress;\n        break;\n    case TYPE_COUNTER:\n        subtree->printomat = sprint_realloc_counter;\n        break;\n    case TYPE_GAUGE:\n        subtree->printomat = sprint_realloc_gauge;\n        break;\n    case TYPE_TIMETICKS:\n        subtree->printomat = sprint_realloc_timeticks;\n        break;\n    case TYPE_OPAQUE:\n        subtree->printomat = sprint_realloc_opaque;\n        break;\n    case TYPE_NULL:\n        subtree->printomat = sprint_realloc_null;\n        break;\n    case TYPE_BITSTRING:\n        subtree->printomat = sprint_realloc_bitstring;\n        break;\n    case TYPE_NSAPADDRESS:\n        subtree->printomat = sprint_realloc_nsapaddress;\n        break;\n    case TYPE_COUNTER64:\n        subtree->printomat = sprint_realloc_counter64;\n        break;\n    case TYPE_UINTEGER:\n        subtree->printomat = sprint_realloc_uinteger;\n        break;\n    case TYPE_UNSIGNED32:\n        subtree->printomat = sprint_realloc_gauge;\n        break;\n    case TYPE_OTHER:\n    default:\n        subtree->printomat = sprint_realloc_by_type;\n        break;\n    }\n}\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n/**\n * Reads an object identifier from an input string into internal OID form.\n * \n * When called, out_len must hold the maximum length of the output array.\n *\n * @param input     the input string.\n * @param output    the oid wirte.\n * @param out_len   number of subid's in output.\n * \n * @return 1 if successful.\n * \n * If an error occurs, this function returns 0 and MAY set snmp_errno.\n * snmp_errno is NOT set if SET_SNMP_ERROR evaluates to nothing.\n * This can make multi-threaded use a tiny bit more robust.\n */\nint\nread_objid(const char *input, oid * output, size_t * out_len)\n{                               /* number of subid's in \"output\" */\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *root = tree_top;\n    char            buf[SPRINT_MAX_LEN];\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    int             ret, max_out_len;\n    char           *name, ch;\n    const char     *cp;\n\n    cp = input;\n    while ((ch = *cp)) {\n        if (('0' <= ch && ch <= '9')\n            || ('a' <= ch && ch <= 'z')\n            || ('A' <= ch && ch <= 'Z')\n            || ch == '-')\n            cp++;\n        else\n            break;\n    }\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if (ch == ':')\n        return get_node(input, output, out_len);\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n    if (*input == '.')\n        input++;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_READ_UCD_STYLE_OID)) {\n        /*\n         * get past leading '.', append '.' to Prefix. \n         */\n        if (*Prefix == '.')\n            strlcpy(buf, Prefix + 1, sizeof(buf));\n        else\n            strlcpy(buf, Prefix, sizeof(buf));\n        strlcat(buf, \".\", sizeof(buf));\n        strlcat(buf, input, sizeof(buf));\n        input = buf;\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if ((root == NULL) && (tree_head != NULL)) {\n        root = tree_head;\n    }\n    else if (root == NULL) {\n        SET_SNMP_ERROR(SNMPERR_NOMIB);\n        *out_len = 0;\n        return 0;\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    name = strdup(input);\n    max_out_len = *out_len;\n    *out_len = 0;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if ((ret =\n         _add_strings_to_oid(root, name, output, out_len,\n                             max_out_len)) <= 0)\n#else\n    if ((ret =\n         _add_strings_to_oid(NULL, name, output, out_len,\n                             max_out_len)) <= 0)\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    {\n        if (ret == 0)\n            ret = SNMPERR_UNKNOWN_OBJID;\n        SET_SNMP_ERROR(ret);\n        SNMP_FREE(name);\n        return 0;\n    }\n    SNMP_FREE(name);\n\n    return 1;\n}\n\n/**\n * \n */\nvoid\nnetsnmp_sprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                             size_t * out_len, int allow_realloc,\n                             int *buf_overflow,\n                             const oid * objid, size_t objidlen)\n{\n    u_char         *tbuf = NULL, *cp = NULL;\n    size_t          tbuf_len = 256, tout_len = 0;\n    int             tbuf_overflow = 0;\n    int             output_format;\n\n    if ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {\n        tbuf_overflow = 1;\n    } else {\n        *tbuf = '.';\n        tout_len = 1;\n    }\n\n    _oid_finish_printing(objid, objidlen,\n                         &tbuf, &tbuf_len, &tout_len,\n                         allow_realloc, &tbuf_overflow);\n\n    if (tbuf_overflow) {\n        if (!*buf_overflow) {\n            snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);\n            *buf_overflow = 1;\n        }\n        SNMP_FREE(tbuf);\n        return;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_OID_OUTPUT_NUMERIC;\n    }\n    switch (output_format) {\n    case NETSNMP_OID_OUTPUT_FULL:\n    case NETSNMP_OID_OUTPUT_NUMERIC:\n    case NETSNMP_OID_OUTPUT_SUFFIX:\n    case NETSNMP_OID_OUTPUT_MODULE:\n        cp = tbuf;\n        break;\n\n    case NETSNMP_OID_OUTPUT_NONE:\n    default:\n        cp = NULL;\n    }\n\n    if (!*buf_overflow &&\n        !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {\n        *buf_overflow = 1;\n    }\n    SNMP_FREE(tbuf);\n}\n\n/**\n * \n */\n#ifdef NETSNMP_DISABLE_MIB_LOADING\nvoid\nnetsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,\n                                  size_t * out_len, int allow_realloc,\n                                  int *buf_overflow,\n                                  const oid * objid, size_t objidlen)\n{\n    netsnmp_sprint_realloc_objid(buf, buf_len, out_len, allow_realloc,\n                                 buf_overflow, objid, objidlen);\n}\n#else\nstruct tree    *\nnetsnmp_sprint_realloc_objid_tree(u_char ** buf, size_t * buf_len,\n                                  size_t * out_len, int allow_realloc,\n                                  int *buf_overflow,\n                                  const oid * objid, size_t objidlen)\n{\n    u_char         *tbuf = NULL, *cp = NULL;\n    size_t          tbuf_len = 512, tout_len = 0;\n    struct tree    *subtree = tree_head;\n    size_t          midpoint_offset = 0;\n    int             tbuf_overflow = 0;\n    int             output_format;\n\n    if ((tbuf = (u_char *) calloc(tbuf_len, 1)) == NULL) {\n        tbuf_overflow = 1;\n    } else {\n        *tbuf = '.';\n        tout_len = 1;\n    }\n\n    subtree = _get_realloc_symbol(objid, objidlen, subtree,\n                                  &tbuf, &tbuf_len, &tout_len,\n                                  allow_realloc, &tbuf_overflow, NULL,\n                                  &midpoint_offset);\n\n    if (tbuf_overflow) {\n        if (!*buf_overflow) {\n            snmp_strcat(buf, buf_len, out_len, allow_realloc, tbuf);\n            *buf_overflow = 1;\n        }\n        SNMP_FREE(tbuf);\n        return subtree;\n    }\n\n    output_format = netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    if (0 == output_format) {\n        output_format = NETSNMP_OID_OUTPUT_MODULE;\n    }\n    switch (output_format) {\n    case NETSNMP_OID_OUTPUT_FULL:\n    case NETSNMP_OID_OUTPUT_NUMERIC:\n        cp = tbuf;\n        break;\n\n    case NETSNMP_OID_OUTPUT_SUFFIX:\n    case NETSNMP_OID_OUTPUT_MODULE:\n        for (cp = tbuf; *cp; cp++);\n\n        if (midpoint_offset != 0) {\n            cp = tbuf + midpoint_offset - 2;    /*  beyond the '.'  */\n        } else {\n            while (cp >= tbuf) {\n                if (isalpha(*cp)) {\n                    break;\n                }\n                cp--;\n            }\n        }\n\n        while (cp >= tbuf) {\n            if (*cp == '.') {\n                break;\n            }\n            cp--;\n        }\n\n        cp++;\n\n        if ((NETSNMP_OID_OUTPUT_MODULE == output_format)\n            && cp > tbuf) {\n            char            modbuf[256] = { 0 }, *mod =\n                module_name(subtree->modid, modbuf);\n\n            /*\n             * Don't add the module ID if it's just numeric (i.e. we couldn't look\n             * it up properly.  \n             */\n\n            if (!*buf_overflow && modbuf[0] != '#') {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) mod)\n                    || !snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                                    (const u_char *) \"::\")) {\n                    *buf_overflow = 1;\n                }\n            }\n        }\n        break;\n\n    case NETSNMP_OID_OUTPUT_UCD:\n    {\n        PrefixListPtr   pp = &mib_prefixes[0];\n        size_t          ilen, tlen;\n        const char     *testcp;\n\n        cp = tbuf;\n        tlen = strlen((char *) tbuf);\n\n        while (pp->str) {\n            ilen = pp->len;\n            testcp = pp->str;\n\n            if ((tlen > ilen) && memcmp(tbuf, testcp, ilen) == 0) {\n                cp += (ilen + 1);\n                break;\n            }\n            pp++;\n        }\n        break;\n    }\n\n    case NETSNMP_OID_OUTPUT_NONE:\n    default:\n        cp = NULL;\n    }\n\n    if (!*buf_overflow &&\n        !snmp_strcat(buf, buf_len, out_len, allow_realloc, cp)) {\n        *buf_overflow = 1;\n    }\n    SNMP_FREE(tbuf);\n    return subtree;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nint\nsprint_realloc_objid(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const oid * objid, size_t objidlen)\n{\n    int             buf_overflow = 0;\n\n    netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len, allow_realloc,\n                                      &buf_overflow, objid, objidlen);\n    return !buf_overflow;\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SPRINT_OBJID\nint\nsnprint_objid(char *buf, size_t buf_len,\n              const oid * objid, size_t objidlen)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_objid((u_char **) & buf, &buf_len, &out_len, 0,\n                             objid, objidlen)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SPRINT_OBJID */\n\n/**\n * Prints an oid to stdout.\n *\n * @param objid      The oid to print\n * @param objidlen   The length of oidid.\n */\nvoid\nprint_objid(const oid * objid, size_t objidlen)\n{                               /* number of subidentifiers */\n    fprint_objid(stdout, objid, objidlen);\n}\n\n\n/**\n * Prints an oid to a file descriptor.\n *\n * @param f          The file descriptor to print to.\n * @param objid      The oid to print\n * @param objidlen   The length of oidid.\n */\nvoid\nfprint_objid(FILE * f, const oid * objid, size_t objidlen)\n{                               /* number of subidentifiers */\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n    int             buf_overflow = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        netsnmp_sprint_realloc_objid_tree(&buf, &buf_len, &out_len, 1,\n                                          &buf_overflow, objid, objidlen);\n        if (buf_overflow) {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        } else {\n            fprintf(f, \"%s\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\nint\nsprint_realloc_variable(u_char ** buf, size_t * buf_len,\n                        size_t * out_len, int allow_realloc,\n                        const oid * objid, size_t objidlen,\n                        const netsnmp_variable_list * variable)\n{\n    int             buf_overflow = 0;\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *subtree = tree_head;\n\n    subtree =\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        netsnmp_sprint_realloc_objid_tree(buf, buf_len, out_len,\n                                          allow_realloc, &buf_overflow,\n                                          objid, objidlen);\n\n    if (buf_overflow) {\n        return 0;\n    }\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_BARE_VALUE)) {\n        if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICKE_PRINT)) {\n            if (!snmp_strcat\n                (buf, buf_len, out_len, allow_realloc,\n                 (const u_char *) \" = \")) {\n                return 0;\n            }\n        } else {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_QUICK_PRINT)) {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) \" \")) {\n                    return 0;\n                }\n            } else {\n                if (!snmp_strcat\n                    (buf, buf_len, out_len, allow_realloc,\n                     (const u_char *) \" = \")) {\n                    return 0;\n                }\n            }                   /* end if-else NETSNMP_DS_LIB_QUICK_PRINT */\n        }                       /* end if-else NETSNMP_DS_LIB_QUICKE_PRINT */\n    } else {\n        *out_len = 0;\n    }\n\n    if (variable->type == SNMP_NOSUCHOBJECT) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Object available on this agent at this OID\");\n    } else if (variable->type == SNMP_NOSUCHINSTANCE) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Instance currently exists at this OID\");\n    } else if (variable->type == SNMP_ENDOFMIBVIEW) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No more variables left in this MIB View (It is past the end of the MIB tree)\");\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    } else if (subtree) {\n        const char *units = NULL;\n        const char *hint = NULL;\n        if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                    NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {\n            units = subtree->units;\n        }\n\n\t\tif (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                    NETSNMP_DS_LIB_NO_DISPLAY_HINT)) {\n\t\t\thint = subtree->hint;\n        }\n\n        if (subtree->printomat) {\n            return (*subtree->printomat) (buf, buf_len, out_len,\n                                          allow_realloc, variable,\n                                          subtree->enums, hint,\n                                          units);\n        } else {\n            return sprint_realloc_by_type(buf, buf_len, out_len,\n                                          allow_realloc, variable,\n                                          subtree->enums, hint,\n                                          units);\n        }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    } else {\n        /*\n         * Handle rare case where tree is empty.  \n         */\n        return sprint_realloc_by_type(buf, buf_len, out_len, allow_realloc,\n                                      variable, NULL, NULL, NULL);\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNPRINT_VARABLE\nint\nsnprint_variable(char *buf, size_t buf_len,\n                 const oid * objid, size_t objidlen,\n                 const netsnmp_variable_list * variable)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_variable((u_char **) & buf, &buf_len, &out_len, 0,\n                                objid, objidlen, variable)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNPRINT_VARABLE */\n\n/**\n * Prints a variable to stdout.\n *\n * @param objid     The object id.\n * @param objidlen  The length of teh object id.\n * @param variable  The variable to print.\n */\nvoid\nprint_variable(const oid * objid,\n               size_t objidlen, const netsnmp_variable_list * variable)\n{\n    fprint_variable(stdout, objid, objidlen, variable);\n}\n\n\n/**\n * Prints a variable to a file descriptor.\n *\n * @param f         The file descriptor to print to.\n * @param objid     The object id.\n * @param objidlen  The length of teh object id.\n * @param variable  The variable to print.\n */\nvoid\nfprint_variable(FILE * f,\n                const oid * objid,\n                size_t objidlen, const netsnmp_variable_list * variable)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (sprint_realloc_variable(&buf, &buf_len, &out_len, 1,\n                                    objid, objidlen, variable)) {\n            fprintf(f, \"%s\\n\", buf);\n        } else {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\nint\nsprint_realloc_value(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     const oid * objid, size_t objidlen,\n                     const netsnmp_variable_list * variable)\n{\n    if (variable->type == SNMP_NOSUCHOBJECT) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Object available on this agent at this OID\");\n    } else if (variable->type == SNMP_NOSUCHINSTANCE) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No Such Instance currently exists at this OID\");\n    } else if (variable->type == SNMP_ENDOFMIBVIEW) {\n        return snmp_strcat(buf, buf_len, out_len, allow_realloc,\n                           (const u_char *)\n                           \"No more variables left in this MIB View (It is past the end of the MIB tree)\");\n    } else {\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        const char *units = NULL;\n        struct tree *subtree = tree_head;\n\tsubtree = get_tree(objid, objidlen, subtree);\n        if (subtree && !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                            NETSNMP_DS_LIB_DONT_PRINT_UNITS)) {\n            units = subtree->units;\n        }\n        if (subtree) {\n\t    if(subtree->printomat) {\n\t\treturn (*subtree->printomat) (buf, buf_len, out_len,\n\t\t\t\t\t      allow_realloc, variable,\n\t\t\t\t\t      subtree->enums, subtree->hint,\n\t\t\t\t\t      units);\n\t    } else {\n\t\treturn sprint_realloc_by_type(buf, buf_len, out_len,\n\t\t\t\t\t      allow_realloc, variable,\n\t\t\t\t\t      subtree->enums, subtree->hint,\n\t\t\t\t\t      units);\n\t    }\n\t}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        return sprint_realloc_by_type(buf, buf_len, out_len,\n                                      allow_realloc, variable,\n                                      NULL, NULL, NULL);\n    }\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_SNPRINT_VALUE\n/* used in the perl module */\nint\nsnprint_value(char *buf, size_t buf_len,\n              const oid * objid, size_t objidlen,\n              const netsnmp_variable_list * variable)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_value((u_char **) & buf, &buf_len, &out_len, 0,\n                             objid, objidlen, variable)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_SNPRINT_VALUE */\n\nvoid\nprint_value(const oid * objid,\n            size_t objidlen, const netsnmp_variable_list * variable)\n{\n    fprint_value(stdout, objid, objidlen, variable);\n}\n\nvoid\nfprint_value(FILE * f,\n             const oid * objid,\n             size_t objidlen, const netsnmp_variable_list * variable)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (sprint_realloc_value(&buf, &buf_len, &out_len, 1,\n                                 objid, objidlen, variable)) {\n            fprintf(f, \"%s\\n\", buf);\n        } else {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\n\n/**\n * Takes the value in VAR and turns it into an OID segment in var->name.\n *  \n * @param var    The variable.\n *\n * @return SNMPERR_SUCCESS or SNMPERR_GENERR \n */\nint\nbuild_oid_segment(netsnmp_variable_list * var)\n{\n    int             i;\n    uint32_t        ipaddr;\n\n    if (var->name && var->name != var->name_loc)\n        SNMP_FREE(var->name);\n    switch (var->type) {\n    case ASN_INTEGER:\n    case ASN_COUNTER:\n    case ASN_GAUGE:\n    case ASN_TIMETICKS:\n        var->name_length = 1;\n        var->name = var->name_loc;\n        var->name[0] = *(var->val.integer);\n        break;\n\n    case ASN_IPADDRESS:\n        var->name_length = 4;\n        var->name = var->name_loc;\n        memcpy(&ipaddr, var->val.string, sizeof(ipaddr));\n        var->name[0] = (ipaddr >> 24) & 0xff;\n        var->name[1] = (ipaddr >> 16) & 0xff;\n        var->name[2] = (ipaddr >>  8) & 0xff;\n        var->name[3] = (ipaddr >>  0) & 0xff;\n        break;\n        \n    case ASN_PRIV_IMPLIED_OBJECT_ID:\n        var->name_length = var->val_len / sizeof(oid);\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        for (i = 0; i < (int) var->name_length; i++)\n            var->name[i] = var->val.objid[i];\n        break;\n\n    case ASN_OBJECT_ID:\n        var->name_length = var->val_len / sizeof(oid) + 1;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        var->name[0] = var->name_length - 1;\n        for (i = 0; i < (int) var->name_length - 1; i++)\n            var->name[i + 1] = var->val.objid[i];\n        break;\n\n    case ASN_PRIV_IMPLIED_OCTET_STR:\n        var->name_length = var->val_len;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        for (i = 0; i < (int) var->val_len; i++)\n            var->name[i] = (oid) var->val.string[i];\n        break;\n\n    case ASN_OPAQUE:\n    case ASN_OCTET_STR:\n        var->name_length = var->val_len + 1;\n        if (var->name_length > (sizeof(var->name_loc) / sizeof(oid)))\n            var->name = (oid *) malloc(sizeof(oid) * (var->name_length));\n        else\n            var->name = var->name_loc;\n        if (var->name == NULL)\n            return SNMPERR_GENERR;\n\n        var->name[0] = (oid) var->val_len;\n        for (i = 0; i < (int) var->val_len; i++)\n            var->name[i + 1] = (oid) var->val.string[i];\n        break;\n\n    default:\n        DEBUGMSGTL((\"build_oid_segment\",\n                    \"invalid asn type: %d\\n\", var->type));\n        return SNMPERR_GENERR;\n    }\n\n    if (var->name_length > MAX_OID_LEN) {\n        DEBUGMSGTL((\"build_oid_segment\",\n                    \"Something terribly wrong, namelen = %lu\\n\",\n                    (unsigned long)var->name_length));\n        return SNMPERR_GENERR;\n    }\n\n    return SNMPERR_SUCCESS;\n}\n\n\nint\nbuild_oid_noalloc(oid * in, size_t in_len, size_t * out_len,\n                  oid * prefix, size_t prefix_len,\n                  netsnmp_variable_list * indexes)\n{\n    netsnmp_variable_list *var;\n\n    if (prefix) {\n        if (in_len < prefix_len)\n            return SNMPERR_GENERR;\n        memcpy(in, prefix, prefix_len * sizeof(oid));\n        *out_len = prefix_len;\n    } else {\n        *out_len = 0;\n    }\n\n    for (var = indexes; var != NULL; var = var->next_variable) {\n        if (build_oid_segment(var) != SNMPERR_SUCCESS)\n            return SNMPERR_GENERR;\n        if (var->name_length + *out_len <= in_len) {\n            memcpy(&(in[*out_len]), var->name,\n                   sizeof(oid) * var->name_length);\n            *out_len += var->name_length;\n        } else {\n            return SNMPERR_GENERR;\n        }\n    }\n\n    DEBUGMSGTL((\"build_oid_noalloc\", \"generated: \"));\n    DEBUGMSGOID((\"build_oid_noalloc\", in, *out_len));\n    DEBUGMSG((\"build_oid_noalloc\", \"\\n\"));\n    return SNMPERR_SUCCESS;\n}\n\nint\nbuild_oid(oid ** out, size_t * out_len,\n          oid * prefix, size_t prefix_len, netsnmp_variable_list * indexes)\n{\n    oid             tmpout[MAX_OID_LEN];\n\n    /*\n     * xxx-rks: inefficent. try only building segments to find index len:\n     *   for (var = indexes; var != NULL; var = var->next_variable) {\n     *      if (build_oid_segment(var) != SNMPERR_SUCCESS)\n     *         return SNMPERR_GENERR;\n     *      *out_len += var->name_length;\n     *\n     * then see if it fits in existing buffer, or realloc buffer.\n     */\n    if (build_oid_noalloc(tmpout, sizeof(tmpout), out_len,\n                          prefix, prefix_len, indexes) != SNMPERR_SUCCESS)\n        return SNMPERR_GENERR;\n\n    /** xxx-rks: should free previous value? */\n    snmp_clone_mem((void **) out, (void *) tmpout, *out_len * sizeof(oid));\n\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * vblist_out must contain a pre-allocated string of variables into\n * which indexes can be extracted based on the previously existing\n * types in the variable chain\n * returns:\n * SNMPERR_GENERR  on error\n * SNMPERR_SUCCESS on success\n */\n\nint\nparse_oid_indexes(oid * oidIndex, size_t oidLen,\n                  netsnmp_variable_list * data)\n{\n    netsnmp_variable_list *var = data;\n\n    while (var && oidLen > 0) {\n\n        if (parse_one_oid_index(&oidIndex, &oidLen, var, 0) !=\n            SNMPERR_SUCCESS)\n            break;\n\n        var = var->next_variable;\n    }\n\n    if (var != NULL || oidLen != 0)\n        return SNMPERR_GENERR;\n    return SNMPERR_SUCCESS;\n}\n\n\nint\nparse_one_oid_index(oid ** oidStart, size_t * oidLen,\n                    netsnmp_variable_list * data, int complete)\n{\n    netsnmp_variable_list *var = data;\n    oid             tmpout[MAX_OID_LEN];\n    unsigned int    i;\n    unsigned int    uitmp = 0;\n\n    oid            *oidIndex = *oidStart;\n\n    if (var == NULL || ((*oidLen == 0) && (complete == 0)))\n        return SNMPERR_GENERR;\n    else {\n        switch (var->type) {\n        case ASN_INTEGER:\n        case ASN_COUNTER:\n        case ASN_GAUGE:\n        case ASN_TIMETICKS:\n            if (*oidLen) {\n                snmp_set_var_value(var, (u_char *) oidIndex++,\n                                   sizeof(oid));\n                --(*oidLen);\n            } else {\n                snmp_set_var_value(var, (u_char *) oidLen, sizeof(long));\n            }\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed int(%d): %ld\\n\", var->type,\n                        *var->val.integer));\n            break;\n\n        case ASN_IPADDRESS:\n            if ((4 > *oidLen) && (complete == 0))\n                return SNMPERR_GENERR;\n            \n            for (i = 0; i < 4 && i < *oidLen; ++i) {\n                if (oidIndex[i] > 255) {\n                    DEBUGMSGTL((\"parse_oid_indexes\",\n                                \"illegal oid in index: %\" NETSNMP_PRIo \"d\\n\",\n                                oidIndex[0]));\n                        return SNMPERR_GENERR;  /* sub-identifier too large */\n                    }\n                    uitmp = uitmp + (oidIndex[i] << (8*(3-i)));\n                }\n            if (4 > (int) (*oidLen)) {\n                oidIndex += *oidLen;\n                (*oidLen) = 0;\n            } else {\n                oidIndex += 4;\n                (*oidLen) -= 4;\n            }\n            uitmp = htonl(uitmp); /* put it in proper order for byte copies */\n            uitmp = \n                snmp_set_var_value(var, (u_char *) &uitmp, 4);\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed ipaddr(%d): %d.%d.%d.%d\\n\", var->type,\n                        var->val.string[0], var->val.string[1],\n                        var->val.string[2], var->val.string[3]));\n            break;\n\n        case ASN_OBJECT_ID:\n        case ASN_PRIV_IMPLIED_OBJECT_ID:\n            if (var->type == ASN_PRIV_IMPLIED_OBJECT_ID) {\n                /*\n                 * might not be implied, might be fixed len. check if\n                 * caller set up val len, and use it if they did.\n                 */\n                if (0 == var->val_len)\n                    uitmp = *oidLen;\n                else {\n                    DEBUGMSGTL((\"parse_oid_indexes:fix\", \"fixed len oid\\n\"));\n                    uitmp = var->val_len;\n                }\n            } else {\n                if (*oidLen) {\n                    uitmp = *oidIndex++;\n                    --(*oidLen);\n                } else {\n                    uitmp = 0;\n                }\n                if ((uitmp > *oidLen) && (complete == 0))\n                    return SNMPERR_GENERR;\n            }\n\n            if (uitmp > MAX_OID_LEN)\n                return SNMPERR_GENERR;  /* too big and illegal */\n\n            if (uitmp > *oidLen) {\n                memcpy(tmpout, oidIndex, sizeof(oid) * (*oidLen));\n                memset(&tmpout[*oidLen], 0x00,\n                       sizeof(oid) * (uitmp - *oidLen));\n                snmp_set_var_value(var, (u_char *) tmpout,\n                                   sizeof(oid) * uitmp);\n                oidIndex += *oidLen;\n                (*oidLen) = 0;\n            } else {\n                snmp_set_var_value(var, (u_char *) oidIndex,\n                                   sizeof(oid) * uitmp);\n                oidIndex += uitmp;\n                (*oidLen) -= uitmp;\n            }\n\n            DEBUGMSGTL((\"parse_oid_indexes\", \"Parsed oid: \"));\n            DEBUGMSGOID((\"parse_oid_indexes\",\n                         var->val.objid, var->val_len / sizeof(oid)));\n            DEBUGMSG((\"parse_oid_indexes\", \"\\n\"));\n            break;\n\n        case ASN_OPAQUE:\n        case ASN_OCTET_STR:\n        case ASN_PRIV_IMPLIED_OCTET_STR:\n            if (var->type == ASN_PRIV_IMPLIED_OCTET_STR) {\n                /*\n                 * might not be implied, might be fixed len. check if\n                 * caller set up val len, and use it if they did.\n                 */\n                if (0 == var->val_len)\n                    uitmp = *oidLen;\n                else {\n                    DEBUGMSGTL((\"parse_oid_indexes:fix\", \"fixed len str\\n\"));\n                    uitmp = var->val_len;\n                }\n            } else {\n                if (*oidLen) {\n                    uitmp = *oidIndex++;\n                    --(*oidLen);\n                } else {\n                    uitmp = 0;\n                }\n                if ((uitmp > *oidLen) && (complete == 0))\n                    return SNMPERR_GENERR;\n            }\n\n            /*\n             * we handle this one ourselves since we don't have\n             * pre-allocated memory to copy from using\n             * snmp_set_var_value() \n             */\n\n            if (uitmp == 0)\n                break;          /* zero length strings shouldn't malloc */\n\n            if (uitmp > MAX_OID_LEN)\n                return SNMPERR_GENERR;  /* too big and illegal */\n\n            /*\n             * malloc by size+1 to allow a null to be appended. \n             */\n            var->val_len = uitmp;\n            var->val.string = (u_char *) calloc(1, uitmp + 1);\n            if (var->val.string == NULL)\n                return SNMPERR_GENERR;\n\n            if ((size_t)uitmp > (*oidLen)) {\n                for (i = 0; i < *oidLen; ++i)\n                    var->val.string[i] = (u_char) * oidIndex++;\n                for (i = *oidLen; i < uitmp; ++i)\n                    var->val.string[i] = '\\0';\n                (*oidLen) = 0;\n            } else {\n                for (i = 0; i < uitmp; ++i)\n                    var->val.string[i] = (u_char) * oidIndex++;\n                (*oidLen) -= uitmp;\n            }\n            var->val.string[uitmp] = '\\0';\n\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"Parsed str(%d): %s\\n\", var->type,\n                        var->val.string));\n            break;\n\n        default:\n            DEBUGMSGTL((\"parse_oid_indexes\",\n                        \"invalid asn type: %d\\n\", var->type));\n            return SNMPERR_GENERR;\n        }\n    }\n    (*oidStart) = oidIndex;\n    return SNMPERR_SUCCESS;\n}\n\n/*\n * dump_realloc_oid_to_inetaddress:\n *   return 0 for failure,\n *   return 1 for success,\n *   return 2 for not handled\n */\n\nint \ndump_realloc_oid_to_inetaddress(const int addr_type, const oid * objid, size_t objidlen, \n                                u_char ** buf, size_t * buf_len,\n                                size_t * out_len, int allow_realloc, \n                                char quotechar)\n{\n    int             i, len;\n    char            intbuf[64], *p;\n    char *const     end = intbuf + sizeof(intbuf);\n    unsigned char  *zc;\n    unsigned long   zone;\n\n    if (!buf)\n        return 1;\n\n    for (i = 0; i < objidlen; i++)\n        if (objid[i] < 0 || objid[i] > 255)\n            return 2;\n\n    p = intbuf;\n    *p++ = quotechar;\n\n    switch (addr_type) {\n    case IPV4:\n    case IPV4Z:\n        if ((addr_type == IPV4  && objidlen != 4) ||\n            (addr_type == IPV4Z && objidlen != 8))\n            return 2;\n\n        len = snprintf(p, end - p, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                      \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                      objid[0], objid[1], objid[2], objid[3]);\n        p += len;\n        if (p >= end)\n            return 2;\n        if (addr_type == IPV4Z) {\n            zc = (unsigned char*)&zone;\n            zc[0] = objid[4];\n            zc[1] = objid[5];\n            zc[2] = objid[6];\n            zc[3] = objid[7];\n            zone = ntohl(zone);\n            len = snprintf(p, end - p, \"%%%lu\", zone);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        break;\n\n    case IPV6:\n    case IPV6Z:\n        if ((addr_type == IPV6 && objidlen != 16) ||\n            (addr_type == IPV6Z && objidlen != 20))\n            return 2;\n\n        len = 0;\n        for (i = 0; i < 16; i ++) {\n            len = snprintf(p, end - p, \"%s%02\" NETSNMP_PRIo \"x\", i ? \":\" : \"\",\n                           objid[i]);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        if (addr_type == IPV6Z) {\n            zc = (unsigned char*)&zone;\n            zc[0] = objid[16];\n            zc[1] = objid[17];\n            zc[2] = objid[18];\n            zc[3] = objid[19];\n            zone = ntohl(zone);\n            len = snprintf(p, end - p, \"%%%lu\", zone);\n            p += len;\n            if (p >= end)\n                return 2;\n        }\n\n        break;\n\n    case DNS:\n    default: \n        /* DNS can just be handled by dump_realloc_oid_to_string() */\n        return 2;\n    }\n\n    *p++ = quotechar;\n    if (p >= end)\n        return 2;\n\n    *p++ = '\\0';\n    if (p >= end)\n        return 2;\n\n    return snmp_cstrcat(buf, buf_len, out_len, allow_realloc, intbuf);\n}\n\nint\ndump_realloc_oid_to_string(const oid * objid, size_t objidlen,\n                           u_char ** buf, size_t * buf_len,\n                           size_t * out_len, int allow_realloc,\n                           char quotechar)\n{\n    if (buf) {\n        int             i, alen;\n\n        for (i = 0, alen = 0; i < (int) objidlen; i++) {\n            oid             tst = objid[i];\n            if ((tst > 254) || (!isprint(tst))) {\n                tst = (oid) '.';\n            }\n\n            if (alen == 0) {\n                if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                    while ((*out_len + 2) >= *buf_len) {\n                        if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                            return 0;\n                        }\n                    }\n                    *(*buf + *out_len) = '\\\\';\n                    (*out_len)++;\n                }\n                while ((*out_len + 2) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = quotechar;\n                (*out_len)++;\n            }\n\n            while ((*out_len + 2) >= *buf_len) {\n                if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n            }\n            *(*buf + *out_len) = (char) tst;\n            (*out_len)++;\n            alen++;\n        }\n\n        if (alen) {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                while ((*out_len + 2) >= *buf_len) {\n                    if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                        return 0;\n                    }\n                }\n                *(*buf + *out_len) = '\\\\';\n                (*out_len)++;\n            }\n            while ((*out_len + 2) >= *buf_len) {\n                if (!(allow_realloc && snmp_realloc(buf, buf_len))) {\n                    return 0;\n                }\n            }\n            *(*buf + *out_len) = quotechar;\n            (*out_len)++;\n        }\n\n        *(*buf + *out_len) = '\\0';\n    }\n\n    return 1;\n}\n\nvoid\n_oid_finish_printing(const oid * objid, size_t objidlen,\n                     u_char ** buf, size_t * buf_len, size_t * out_len,\n                     int allow_realloc, int *buf_overflow) {\n    char            intbuf[64];\n    if (*buf != NULL && *(*buf + *out_len - 1) != '.') {\n        if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           (const u_char *) \".\")) {\n            *buf_overflow = 1;\n        }\n    }\n\n    while (objidlen-- > 0) {    /* output rest of name, uninterpreted */\n        sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", *objid++);\n        if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                           allow_realloc,\n                                           (const u_char *) intbuf)) {\n            *buf_overflow = 1;\n        }\n    }\n\n    if (*buf != NULL) {\n        *(*buf + *out_len - 1) = '\\0';  /* remove trailing dot */\n        *out_len = *out_len - 1;\n    }\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\nstatic void\n_get_realloc_symbol_octet_string(size_t numids, const oid * objid,\n\t\t\t\t u_char ** buf, size_t * buf_len,\n\t\t\t\t size_t * out_len, int allow_realloc,\n\t\t\t\t int *buf_overflow, struct tree* tp)\n{\n  netsnmp_variable_list\tvar = { 0 };\n  u_char\t\tbuffer[1024];\n  size_t\t\ti;\n\n  for (i = 0; i < numids; i++)\n    buffer[i] = (u_char) objid[i];\n  var.type = ASN_OCTET_STR;\n  var.val.string = buffer;\n  var.val_len = numids;\n  if (!*buf_overflow) {\n    if (!sprint_realloc_octet_string(buf, buf_len, out_len,\n\t\t\t\t     allow_realloc, &var,\n\t\t\t\t     NULL, tp->hint,\n\t\t\t\t     NULL)) {\n      *buf_overflow = 1;\n    }\n  }\n}\n\nstatic struct tree *\n_get_realloc_symbol(const oid * objid, size_t objidlen,\n                    struct tree *subtree,\n                    u_char ** buf, size_t * buf_len, size_t * out_len,\n                    int allow_realloc, int *buf_overflow,\n                    struct index_list *in_dices, size_t * end_of_known)\n{\n    struct tree    *return_tree = NULL;\n    int             extended_index =\n        netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_EXTENDED_INDEX);\n    int             output_format =\n        netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_OID_OUTPUT_FORMAT);\n    char            intbuf[64];\n    struct tree    *orgtree = subtree;\n\n    if (!objid || !buf) {\n        return NULL;\n    }\n\n    for (; subtree; subtree = subtree->next_peer) {\n        if (*objid == subtree->subid) {\n\t    while (subtree->next_peer && subtree->next_peer->subid == *objid)\n\t\tsubtree = subtree->next_peer;\n            if (subtree->indexes) {\n                in_dices = subtree->indexes;\n            } else if (subtree->augments) {\n                struct tree    *tp2 =\n                    find_tree_node(subtree->augments, -1);\n                if (tp2) {\n                    in_dices = tp2->indexes;\n                }\n            }\n\n            if (!strncmp(subtree->label, ANON, ANON_LEN) ||\n                (NETSNMP_OID_OUTPUT_NUMERIC == output_format)) {\n                sprintf(intbuf, \"%lu\", subtree->subid);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n            } else {\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   subtree->label)) {\n                    *buf_overflow = 1;\n                }\n            }\n\n            if (objidlen > 1) {\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *) \".\")) {\n                    *buf_overflow = 1;\n                }\n\n                return_tree = _get_realloc_symbol(objid + 1, objidlen - 1,\n                                                  subtree->child_list,\n                                                  buf, buf_len, out_len,\n                                                  allow_realloc,\n                                                  buf_overflow, in_dices,\n                                                  end_of_known);\n            }\n\n            if (return_tree != NULL) {\n                return return_tree;\n            } else {\n                return subtree;\n            }\n        }\n    }\n\n    if (end_of_known) {\n        *end_of_known = *out_len;\n    }\n\n    /*\n     * Subtree not found.  \n     */\n\n    if (orgtree && in_dices && objidlen > 0) {\n\tsprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", *objid);\n\tif (!*buf_overflow\n\t    && !snmp_strcat(buf, buf_len, out_len,\n\t\t\t    allow_realloc,\n\t\t\t    (const u_char *) intbuf)) {\n\t    *buf_overflow = 1;\n\t}\n\tobjid++;\n\tobjidlen--;\n    }\n\n    while (in_dices && (objidlen > 0) &&\n           (NETSNMP_OID_OUTPUT_NUMERIC != output_format) &&\n           !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS)) {\n        size_t          numids;\n        struct tree    *tp;\n\n        tp = find_tree_node(in_dices->ilabel, -1);\n\n        if (!tp) {\n            /*\n             * Can't find an index in the mib tree.  Bail.  \n             */\n            goto finish_it;\n        }\n\n        if (extended_index) {\n            if (*buf != NULL && *(*buf + *out_len - 1) == '.') {\n                (*out_len)--;\n            }\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \"[\")) {\n                *buf_overflow = 1;\n            }\n        }\n\n        switch (tp->type) {\n        case TYPE_OCTETSTR:\n            if (extended_index && tp->hint) {\n                if (in_dices->isimplied) {\n                    numids = objidlen;\n                    if (numids > objidlen)\n                        goto finish_it;\n                } else if (tp->ranges && !tp->ranges->next\n                           && tp->ranges->low == tp->ranges->high) {\n                    numids = tp->ranges->low;\n                    if (numids > objidlen)\n                        goto finish_it;\n                } else {\n                    numids = *objid;\n                    if (numids >= objidlen)\n                        goto finish_it;\n                    objid++;\n                    objidlen--;\n                }\n                if (numids > objidlen)\n                    goto finish_it;\n\t\t_get_realloc_symbol_octet_string(numids, objid, buf, buf_len,\n\t\t\t\t\t\t out_len, allow_realloc,\n\t\t\t\t\t\t buf_overflow, tp);\n            } else if (in_dices->isimplied) {\n                numids = objidlen;\n                if (numids > objidlen)\n                    goto finish_it;\n\n                if (!*buf_overflow) {\n                    if (!dump_realloc_oid_to_string\n                        (objid, numids, buf, buf_len, out_len,\n                         allow_realloc, '\\'')) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else if (tp->ranges && !tp->ranges->next\n                       && tp->ranges->low == tp->ranges->high) {\n                /*\n                 * a fixed-length octet string \n                 */\n                numids = tp->ranges->low;\n                if (numids > objidlen)\n                    goto finish_it;\n\n                if (!*buf_overflow) {\n                    if (!dump_realloc_oid_to_string\n                        (objid, numids, buf, buf_len, out_len,\n                         allow_realloc, '\\'')) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                numids = (size_t) * objid + 1;\n                if (numids > objidlen)\n                    goto finish_it;\n                if (numids == 1) {\n                    if (netsnmp_ds_get_boolean\n                        (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                        if (!*buf_overflow\n                            && !snmp_strcat(buf, buf_len, out_len,\n                                            allow_realloc,\n                                            (const u_char *) \"\\\\\")) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) \"\\\"\")) {\n                        *buf_overflow = 1;\n                    }\n                    if (netsnmp_ds_get_boolean\n                        (NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_ESCAPE_QUOTES)) {\n                        if (!*buf_overflow\n                            && !snmp_strcat(buf, buf_len, out_len,\n                                            allow_realloc,\n                                            (const u_char *) \"\\\\\")) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) \"\\\"\")) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    if (!*buf_overflow) {\n                        struct tree * next_peer;\n                        int normal_handling = 1;\n\n                        if (tp->next_peer) {\n                            next_peer = tp->next_peer;\n                        }\n\n                        /* Try handling the InetAddress in the OID, in case of failure,\n                         * use the normal_handling. \n                         */\n                        if (tp->next_peer &&\n                            tp->tc_index != -1 &&\n                            next_peer->tc_index != -1 &&\n                            strcmp(get_tc_descriptor(tp->tc_index), \"InetAddress\") == 0 &&\n                            strcmp(get_tc_descriptor(next_peer->tc_index), \n                                    \"InetAddressType\") == 0 ) {\n\n                            int ret;\n                            int addr_type = *(objid - 1);\n\n                            ret = dump_realloc_oid_to_inetaddress(addr_type, \n                                        objid + 1, numids - 1, buf, buf_len, out_len,\n                                        allow_realloc, '\"');\n                            if (ret != 2) {\n                                normal_handling = 0;\n                                if (ret == 0) {\n                                    *buf_overflow = 1;\n                                }\n\n                            }\n                        } \n                        if (normal_handling && !dump_realloc_oid_to_string\n                            (objid + 1, numids - 1, buf, buf_len, out_len,\n                             allow_realloc, '\"')) {\n                            *buf_overflow = 1;\n                        }\n                    }\n                }\n            }\n            objid += numids;\n            objidlen -= numids;\n            break;\n\n        case TYPE_INTEGER32:\n        case TYPE_UINTEGER:\n        case TYPE_UNSIGNED32:\n        case TYPE_GAUGE:\n        case TYPE_INTEGER:\n            if (tp->enums) {\n                struct enum_list *ep = tp->enums;\n                while (ep && ep->value != (int) (*objid)) {\n                    ep = ep->next;\n                }\n                if (ep) {\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) ep->label)) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) intbuf)) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n            }\n            objid++;\n            objidlen--;\n            break;\n\n        case TYPE_TIMETICKS:\n            /* In an index, this is probably a timefilter */\n            if (extended_index) {\n                uptimeString( *objid, intbuf, sizeof( intbuf ) );\n            } else {\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u\", *objid);\n            }   \n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *)\n                                               intbuf)) {\n                *buf_overflow = 1;\n            }\n            objid++;\n            objidlen--;\n            break;\n\n        case TYPE_OBJID:\n            if (in_dices->isimplied) {\n                numids = objidlen;\n            } else {\n                numids = (size_t) * objid + 1;\n            }\n            if (numids > objidlen)\n                goto finish_it;\n            if (extended_index) {\n                if (in_dices->isimplied) {\n                    if (!*buf_overflow\n                        && !netsnmp_sprint_realloc_objid_tree(buf, buf_len,\n                                                              out_len,\n                                                              allow_realloc,\n                                                              buf_overflow,\n                                                              objid,\n                                                              numids)) {\n                        *buf_overflow = 1;\n                    }\n                } else {\n                    if (!*buf_overflow\n                        && !netsnmp_sprint_realloc_objid_tree(buf, buf_len,\n                                                              out_len,\n                                                              allow_realloc,\n                                                              buf_overflow,\n                                                              objid + 1,\n                                                              numids -\n                                                              1)) {\n                        *buf_overflow = 1;\n                    }\n                }\n            } else {\n                _get_realloc_symbol(objid, numids, NULL, buf, buf_len,\n                                    out_len, allow_realloc, buf_overflow,\n                                    NULL, NULL);\n            }\n            objid += (numids);\n            objidlen -= (numids);\n            break;\n\n        case TYPE_IPADDR:\n            if (objidlen < 4)\n                goto finish_it;\n            sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                    \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                    objid[0], objid[1], objid[2], objid[3]);\n            objid += 4;\n            objidlen -= 4;\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) intbuf)) {\n                *buf_overflow = 1;\n            }\n            break;\n\n        case TYPE_NETADDR:{\n                oid             ntype = *objid++;\n\n                objidlen--;\n                sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.\", ntype);\n                if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                                   allow_realloc,\n                                                   (const u_char *)\n                                                   intbuf)) {\n                    *buf_overflow = 1;\n                }\n\n                if (ntype == 1 && objidlen >= 4) {\n                    sprintf(intbuf, \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u.\"\n                            \"%\" NETSNMP_PRIo \"u.%\" NETSNMP_PRIo \"u\",\n                            objid[0], objid[1], objid[2], objid[3]);\n                    if (!*buf_overflow\n                        && !snmp_strcat(buf, buf_len, out_len,\n                                        allow_realloc,\n                                        (const u_char *) intbuf)) {\n                        *buf_overflow = 1;\n                    }\n                    objid += 4;\n                    objidlen -= 4;\n                } else {\n                    goto finish_it;\n                }\n            }\n            break;\n\n        case TYPE_NSAPADDRESS:\n        default:\n            goto finish_it;\n            break;\n        }\n\n        if (extended_index) {\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \"]\")) {\n                *buf_overflow = 1;\n            }\n        } else {\n            if (!*buf_overflow && !snmp_strcat(buf, buf_len, out_len,\n                                               allow_realloc,\n                                               (const u_char *) \".\")) {\n                *buf_overflow = 1;\n            }\n        }\n        in_dices = in_dices->next;\n    }\n\n  finish_it:\n    _oid_finish_printing(objid, objidlen,\n                         buf, buf_len, out_len,\n                         allow_realloc, buf_overflow);\n    return NULL;\n}\n\nstruct tree    *\nget_tree(const oid * objid, size_t objidlen, struct tree *subtree)\n{\n    struct tree    *return_tree = NULL;\n\n    for (; subtree; subtree = subtree->next_peer) {\n        if (*objid == subtree->subid)\n            goto found;\n    }\n\n    return NULL;\n\n  found:\n    while (subtree->next_peer && subtree->next_peer->subid == *objid)\n\tsubtree = subtree->next_peer;\n    if (objidlen > 1)\n        return_tree =\n            get_tree(objid + 1, objidlen - 1, subtree->child_list);\n    if (return_tree != NULL)\n        return return_tree;\n    else\n        return subtree;\n}\n\n/**\n * Prints on oid description on stdout.\n *\n * @see fprint_description\n */\nvoid\nprint_description(oid * objid, size_t objidlen, /* number of subidentifiers */\n                  int width)\n{\n    fprint_description(stdout, objid, objidlen, width);\n}\n\n\n/**\n * Prints on oid description into a file descriptor.\n * \n * @param f         The file descriptor to print to.\n * @param objid     The object identifier.\n * @param objidlen  The object id length.\n * @param width     Number of subidentifiers.\n */\nvoid\nfprint_description(FILE * f, oid * objid, size_t objidlen,\n                   int width)\n{\n    u_char         *buf = NULL;\n    size_t          buf_len = 256, out_len = 0;\n\n    if ((buf = (u_char *) calloc(buf_len, 1)) == NULL) {\n        fprintf(f, \"[TRUNCATED]\\n\");\n        return;\n    } else {\n        if (!sprint_realloc_description(&buf, &buf_len, &out_len, 1,\n                                   objid, objidlen, width)) {\n            fprintf(f, \"%s [TRUNCATED]\\n\", buf);\n        } else {\n            fprintf(f, \"%s\\n\", buf);\n        }\n    }\n\n    SNMP_FREE(buf);\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_SNPRINT_DESCRIPTION\nint\nsnprint_description(char *buf, size_t buf_len,\n                    oid * objid, size_t objidlen, int width)\n{\n    size_t          out_len = 0;\n\n    if (sprint_realloc_description((u_char **) & buf, &buf_len, &out_len, 0,\n                                    objid, objidlen, width)) {\n        return (int) out_len;\n    } else {\n        return -1;\n    }\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_SNPRINT_DESCRIPTION */\n\nint\nsprint_realloc_description(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     oid * objid, size_t objidlen, int width)\n{\n    struct tree    *tp = get_tree(objid, objidlen, tree_head);\n    struct tree    *subtree = tree_head;\n    int             pos, len;\n    char            tmpbuf[128];\n    const char     *cp;\n\n    if (NULL == tp)\n        return 0;\n\n    if (tp->type <= TYPE_SIMPLE_LAST)\n        cp = \" OBJECT-TYPE\";\n    else\n        switch (tp->type) {\n        case TYPE_TRAPTYPE:\n            cp = \" TRAP-TYPE\";\n            break;\n        case TYPE_NOTIFTYPE:\n            cp = \" NOTIFICATION-TYPE\";\n            break;\n        case TYPE_OBJGROUP:\n            cp = \" OBJECT-GROUP\";\n            break;\n        case TYPE_AGENTCAP:\n            cp = \" AGENT-CAPABILITIES\";\n            break;\n        case TYPE_MODID:\n            cp = \" MODULE-IDENTITY\";\n            break;\n        case TYPE_OBJIDENTITY:\n            cp = \" OBJECT-IDENTITY\";\n            break;\n        case TYPE_MODCOMP:\n            cp = \" MODULE-COMPLIANCE\";\n            break;\n        default:\n            sprintf(tmpbuf, \" type_%d\", tp->type);\n            cp = tmpbuf;\n        }\n\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->label) ||\n        !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n        !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\")) {\n        return 0;\n    }\n    if (!print_tree_node(buf, buf_len, out_len, allow_realloc, tp, width))\n        return 0;\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"::= {\"))\n        return 0;\n    pos = 5;\n    while (objidlen > 1) {\n        for (; subtree; subtree = subtree->next_peer) {\n            if (*objid == subtree->subid) {\n                while (subtree->next_peer && subtree->next_peer->subid == *objid)\n                    subtree = subtree->next_peer;\n                if (strncmp(subtree->label, ANON, ANON_LEN)) {\n                    snprintf(tmpbuf, sizeof(tmpbuf), \" %s(%lu)\", subtree->label, subtree->subid);\n                    tmpbuf[ sizeof(tmpbuf)-1 ] = 0;\n                } else\n                    sprintf(tmpbuf, \" %lu\", subtree->subid);\n                len = strlen(tmpbuf);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len,\n                                     allow_realloc, \"\\n     \"))\n                        return 0;\n                    pos = 5;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n                    return 0;\n                pos += len;\n                objid++;\n                objidlen--;\n                break;\n            }\n        }\n        if (subtree)\n            subtree = subtree->child_list;\n        else\n            break;\n    }\n    while (objidlen > 1) {\n        sprintf(tmpbuf, \" %\" NETSNMP_PRIo \"u\", *objid);\n        len = strlen(tmpbuf);\n        if (pos + len + 2 > width) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n     \"))\n                return 0;\n            pos = 5;\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n            return 0;\n        pos += len;\n        objid++;\n        objidlen--;\n    }\n    sprintf(tmpbuf, \" %\" NETSNMP_PRIo \"u }\", *objid);\n    len = strlen(tmpbuf);\n    if (pos + len + 2 > width) {\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n     \"))\n            return 0;\n        pos = 5;\n    }\n    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tmpbuf))\n        return 0;\n    return 1;\n}\n\nstatic int\nprint_tree_node(u_char ** buf, size_t * buf_len,\n                     size_t * out_len, int allow_realloc,\n                     struct tree *tp, int width)\n{\n    const char     *cp;\n    char            str[MAXTOKEN];\n    int             i, prevmod, pos, len;\n\n    if (tp) {\n        module_name(tp->modid, str);\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"  -- FROM\\t\") ||\n            !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n            return 0;\n        pos = 16+strlen(str);\n        for (i = 1, prevmod = tp->modid; i < tp->number_modules; i++) {\n            if (prevmod != tp->module_list[i]) {\n                module_name(tp->module_list[i], str);\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                     \",\\n  --\\t\\t\"))\n                        return 0;\n                    pos = 16;\n                }\n                else {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                    pos += 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len;\n            }\n            prevmod = tp->module_list[i];\n        }\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n            return 0;\n        if (tp->tc_index != -1) {\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  -- TEXTUAL CONVENTION \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              get_tc_descriptor(tp->tc_index)) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        }\n        switch (tp->type) {\n        case TYPE_OBJID:\n            cp = \"OBJECT IDENTIFIER\";\n            break;\n        case TYPE_OCTETSTR:\n            cp = \"OCTET STRING\";\n            break;\n        case TYPE_INTEGER:\n            cp = \"INTEGER\";\n            break;\n        case TYPE_NETADDR:\n            cp = \"NetworkAddress\";\n            break;\n        case TYPE_IPADDR:\n            cp = \"IpAddress\";\n            break;\n        case TYPE_COUNTER:\n            cp = \"Counter32\";\n            break;\n        case TYPE_GAUGE:\n            cp = \"Gauge32\";\n            break;\n        case TYPE_TIMETICKS:\n            cp = \"TimeTicks\";\n            break;\n        case TYPE_OPAQUE:\n            cp = \"Opaque\";\n            break;\n        case TYPE_NULL:\n            cp = \"NULL\";\n            break;\n        case TYPE_COUNTER64:\n            cp = \"Counter64\";\n            break;\n        case TYPE_BITSTRING:\n            cp = \"BITS\";\n            break;\n        case TYPE_NSAPADDRESS:\n            cp = \"NsapAddress\";\n            break;\n        case TYPE_UINTEGER:\n            cp = \"UInteger32\";\n            break;\n        case TYPE_UNSIGNED32:\n            cp = \"Unsigned32\";\n            break;\n        case TYPE_INTEGER32:\n            cp = \"Integer32\";\n            break;\n        default:\n            cp = NULL;\n            break;\n        }\n#if NETSNMP_ENABLE_TESTING_CODE\n        if (!cp && (tp->ranges || tp->enums)) { /* ranges without type ? */\n            sprintf(str, \"?0 with %s %s ?\",\n                    tp->ranges ? \"Range\" : \"\", tp->enums ? \"Enum\" : \"\");\n            cp = str;\n        }\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  SYNTAX\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp))\n                return 0;\n        if (tp->ranges) {\n            struct range_list *rp = tp->ranges;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" (\"))\n                return 0;\n            while (rp) {\n                switch (tp->type) {\n                case TYPE_INTEGER:\n                case TYPE_INTEGER32:\n                    if (rp->low == rp->high)\n                        sprintf(str, \"%s%d\", (first ? \"\" : \" | \"), rp->low );\n                    else\n                        sprintf(str, \"%s%d..%d\", (first ? \"\" : \" | \"),\n                                rp->low, rp->high);\n                    break;\n                case TYPE_UNSIGNED32:\n                case TYPE_OCTETSTR:\n                case TYPE_GAUGE:\n                case TYPE_UINTEGER:\n                    if (rp->low == rp->high)\n                        sprintf(str, \"%s%u\", (first ? \"\" : \" | \"),\n                                (unsigned)rp->low );\n                    else\n                        sprintf(str, \"%s%u..%u\", (first ? \"\" : \" | \"),\n                                (unsigned)rp->low, (unsigned)rp->high);\n                    break;\n                default:\n                    /* No other range types allowed */\n                    break;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                if (first)\n                    first = 0;\n                rp = rp->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \") \"))\n                return 0;\n        }\n        if (tp->enums) {\n            struct enum_list *ep = tp->enums;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" {\"))\n                return 0;\n            pos = 16 + strlen(cp) + 2;\n            while (ep) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                snprintf(str, sizeof(str), \"%s(%d)\", ep->label, ep->value);\n                str[ sizeof(str)-1 ] = 0;\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len,\n                                     allow_realloc, \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 18;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                ep = ep->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"} \"))\n                return 0;\n        }\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        if (tp->hint)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  DISPLAY-HINT\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->hint) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        if (tp->units)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  UNITS\\t\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->units) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        switch (tp->access) {\n        case MIB_ACCESS_READONLY:\n            cp = \"read-only\";\n            break;\n        case MIB_ACCESS_READWRITE:\n            cp = \"read-write\";\n            break;\n        case MIB_ACCESS_WRITEONLY:\n            cp = \"write-only\";\n            break;\n        case MIB_ACCESS_NOACCESS:\n            cp = \"not-accessible\";\n            break;\n        case MIB_ACCESS_NOTIFY:\n            cp = \"accessible-for-notify\";\n            break;\n        case MIB_ACCESS_CREATE:\n            cp = \"read-create\";\n            break;\n        case 0:\n            cp = NULL;\n            break;\n        default:\n            sprintf(str, \"access_%d\", tp->access);\n            cp = str;\n        }\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  MAX-ACCESS\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        switch (tp->status) {\n        case MIB_STATUS_MANDATORY:\n            cp = \"mandatory\";\n            break;\n        case MIB_STATUS_OPTIONAL:\n            cp = \"optional\";\n            break;\n        case MIB_STATUS_OBSOLETE:\n            cp = \"obsolete\";\n            break;\n        case MIB_STATUS_DEPRECATED:\n            cp = \"deprecated\";\n            break;\n        case MIB_STATUS_CURRENT:\n            cp = \"current\";\n            break;\n        case 0:\n            cp = NULL;\n            break;\n        default:\n            sprintf(str, \"status_%d\", tp->status);\n            cp = str;\n        }\n#if NETSNMP_ENABLE_TESTING_CODE\n        if (!cp && (tp->indexes)) {     /* index without status ? */\n            sprintf(str, \"?0 with %s ?\", tp->indexes ? \"Index\" : \"\");\n            cp = str;\n        }\n#endif                          /* NETSNMP_ENABLE_TESTING_CODE */\n        if (cp)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  STATUS\\t\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, cp) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\"))\n                return 0;\n        if (tp->augments)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  AUGMENTS\\t{ \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->augments) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        if (tp->indexes) {\n            struct index_list *ip = tp->indexes;\n            int             first = 1;\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                             \"  INDEX\\t\\t{ \"))\n                return 0;\n            pos = 16 + 2;\n            while (ip) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                snprintf(str, sizeof(str), \"%s%s\",\n                        ip->isimplied ? \"IMPLIED \" : \"\",\n                        ip->ilabel);\n                str[ sizeof(str)-1 ] = 0;\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 16 + 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                ip = ip->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        }\n        if (tp->varbinds) {\n            struct varbind_list *vp = tp->varbinds;\n            int             first = 1;\n\n            if (tp->type == TYPE_TRAPTYPE) {\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                    \"  VARIABLES\\t{ \"))\n                    return 0;\n            } else {\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                    \"  OBJECTS\\t{ \"))\n                    return 0;\n            }\n            pos = 16 + 2;\n            while (vp) {\n                if (first)\n                    first = 0;\n                else\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \", \"))\n                        return 0;\n                strlcpy(str, vp->vblabel, sizeof(str));\n                len = strlen(str);\n                if (pos + len + 2 > width) {\n                    if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                                    \"\\n\\t\\t  \"))\n                        return 0;\n                    pos = 16 + 2;\n                }\n                if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, str))\n                    return 0;\n                pos += len + 2;\n                vp = vp->next;\n            }\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n        }\n        if (tp->description)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  DESCRIPTION\\t\\\"\") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->description) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"\\\"\\n\"))\n                return 0;\n        if (tp->defaultValue)\n            if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc,\n                              \"  DEFVAL\\t{ \") ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, tp->defaultValue) ||\n                !snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \" }\\n\"))\n                return 0;\n    } else\n        if (!snmp_cstrcat(buf, buf_len, out_len, allow_realloc, \"No description\\n\"))\n            return 0;\n    return 1;\n}\n\nint\nget_module_node(const char *fname,\n                const char *module, oid * objid, size_t * objidlen)\n{\n    int             modid, rc = 0;\n    struct tree    *tp;\n    char           *name, *cp;\n\n    if (!strcmp(module, \"ANY\"))\n        modid = -1;\n    else {\n        netsnmp_read_module(module);\n        modid = which_module(module);\n        if (modid == -1)\n            return 0;\n    }\n\n    /*\n     * Isolate the first component of the name ... \n     */\n    name = strdup(fname);\n    cp = strchr(name, '.');\n    if (cp != NULL) {\n        *cp = '\\0';\n        cp++;\n    }\n    /*\n     * ... and locate it in the tree. \n     */\n    tp = find_tree_node(name, modid);\n    if (tp) {\n        size_t          maxlen = *objidlen;\n\n        /*\n         * Set the first element of the object ID \n         */\n        if (node_to_oid(tp, objid, objidlen)) {\n            rc = 1;\n\n            /*\n             * If the name requested was more than one element,\n             * tag on the rest of the components \n             */\n            if (cp != NULL)\n                rc = _add_strings_to_oid(tp, cp, objid, objidlen, maxlen);\n        }\n    }\n\n    SNMP_FREE(name);\n    return (rc);\n}\n\n\n/**\n * @internal\n *\n * Populates the object identifier from a node in the MIB hierarchy.\n * Builds up the object ID, working backwards,\n * starting from the end of the objid buffer.\n * When the top of the MIB tree is reached, the buffer is adjusted.\n *\n * The buffer length is set to the number of subidentifiers\n * for the object identifier associated with the MIB node.\n * \n * @return the number of subidentifiers copied.\n *\n * If 0 is returned, the objid buffer is too small,\n * and the buffer contents are indeterminate.\n * The buffer length can be used to create a larger buffer.\n */\nstatic int\nnode_to_oid(struct tree *tp, oid * objid, size_t * objidlen)\n{\n    int             numids, lenids;\n    oid            *op;\n\n    if (!tp || !objid || !objidlen)\n        return 0;\n\n    lenids = (int) *objidlen;\n    op = objid + lenids;        /* points after the last element */\n\n    for (numids = 0; tp; tp = tp->parent, numids++) {\n        if (numids >= lenids)\n            continue;\n        --op;\n        *op = tp->subid;\n    }\n\n    *objidlen = (size_t) numids;\n    if (numids > lenids) {\n        return 0;\n    }\n\n    if (numids < lenids)\n        memmove(objid, op, numids * sizeof(oid));\n\n    return (numids);\n}\n\n/*\n * Replace \\x with x stop at eos_marker\n * return NULL if eos_marker not found\n */\nstatic char *_apply_escapes(char *src, char eos_marker)\n{\n    char *dst;\n    int backslash = 0;\n    \n    dst = src;\n    while (*src) {\n\tif (backslash) {\n\t    backslash = 0;\n\t    *dst++ = *src;\n\t} else {\n\t    if (eos_marker == *src) break;\n\t    if ('\\\\' == *src) {\n\t\tbackslash = 1;\n\t    } else {\n\t\t*dst++ = *src;\n\t    }\n\t}\n\tsrc++;\n    }\n    if (!*src) {\n\t/* never found eos_marker */\n\treturn NULL;\n    } else {\n\t*dst = 0;\n\treturn src;\n    }\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\nstatic int\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n_add_strings_to_oid(struct tree *tp, char *cp,\n                    oid * objid, size_t * objidlen, size_t maxlen)\n#else\n_add_strings_to_oid(void *tp, char *cp,\n                    oid * objid, size_t * objidlen, size_t maxlen)\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n{\n    oid             subid;\n    char           *fcp, *ecp, *cp2 = NULL;\n    char            doingquote;\n    int             len = -1;\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    struct tree    *tp2 = NULL;\n    struct index_list *in_dices = NULL;\n    int             pos = -1;\n    int             check =\n        !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_DONT_CHECK_RANGE);\n    int             do_hint = !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_NO_DISPLAY_HINT);\n    int             len_index = 1000000;\n\n    while (cp && tp && tp->child_list) {\n        fcp = cp;\n        tp2 = tp->child_list;\n        /*\n         * Isolate the next entry \n         */\n        cp2 = strchr(cp, '.');\n        if (cp2)\n            *cp2++ = '\\0';\n\n        /*\n         * Search for the appropriate child \n         */\n        if (isdigit((unsigned char)(*cp))) {\n            subid = strtoul(cp, &ecp, 0);\n            if (*ecp)\n                goto bad_id;\n            while (tp2 && tp2->subid != subid)\n                tp2 = tp2->next_peer;\n        } else {\n            while (tp2 && strcmp(tp2->label, fcp))\n                tp2 = tp2->next_peer;\n            if (!tp2)\n                goto bad_id;\n            subid = tp2->subid;\n        }\n        if (*objidlen >= maxlen)\n            goto bad_id;\n\twhile (tp2 && tp2->next_peer && tp2->next_peer->subid == subid)\n\t    tp2 = tp2->next_peer;\n        objid[*objidlen] = subid;\n        (*objidlen)++;\n\n        cp = cp2;\n        if (!tp2)\n            break;\n        tp = tp2;\n    }\n\n    if (tp && !tp->child_list) {\n        if ((tp2 = tp->parent)) {\n            if (tp2->indexes)\n                in_dices = tp2->indexes;\n            else if (tp2->augments) {\n                tp2 = find_tree_node(tp2->augments, -1);\n                if (tp2)\n                    in_dices = tp2->indexes;\n            }\n        }\n        tp = NULL;\n    }\n\n    while (cp && in_dices) {\n        fcp = cp;\n\n        tp = find_tree_node(in_dices->ilabel, -1);\n        if (!tp)\n            break;\n        switch (tp->type) {\n        case TYPE_INTEGER:\n        case TYPE_INTEGER32:\n        case TYPE_UINTEGER:\n        case TYPE_UNSIGNED32:\n        case TYPE_TIMETICKS:\n            /*\n             * Isolate the next entry \n             */\n            cp2 = strchr(cp, '.');\n            if (cp2)\n                *cp2++ = '\\0';\n            if (isdigit((unsigned char)(*cp))) {\n                subid = strtoul(cp, &ecp, 0);\n                if (*ecp)\n                    goto bad_id;\n            } else {\n                if (tp->enums) {\n                    struct enum_list *ep = tp->enums;\n                    while (ep && strcmp(ep->label, cp))\n                        ep = ep->next;\n                    if (!ep)\n                        goto bad_id;\n                    subid = ep->value;\n                } else\n                    goto bad_id;\n            }\n            if (check && tp->ranges) {\n                struct range_list *rp = tp->ranges;\n                int             ok = 0;\n                if (tp->type == TYPE_INTEGER ||\n                    tp->type == TYPE_INTEGER32) {\n                  while (!ok && rp) {\n                    if ((rp->low <= (int) subid)\n                        && ((int) subid <= rp->high))\n                        ok = 1;\n                    else\n                        rp = rp->next;\n                  }\n                } else { /* check unsigned range */\n                  while (!ok && rp) {\n                    if (((unsigned int)rp->low <= subid)\n                        && (subid <= (unsigned int)rp->high))\n                        ok = 1;\n                    else\n                        rp = rp->next;\n                  }\n                }\n                if (!ok)\n                    goto bad_id;\n            }\n            if (*objidlen >= maxlen)\n                goto bad_id;\n            objid[*objidlen] = subid;\n            (*objidlen)++;\n            break;\n        case TYPE_IPADDR:\n            if (*objidlen + 4 > maxlen)\n                goto bad_id;\n            for (subid = 0; cp && subid < 4; subid++) {\n                fcp = cp;\n                cp2 = strchr(cp, '.');\n                if (cp2)\n                    *cp2++ = 0;\n                objid[*objidlen] = strtoul(cp, &ecp, 0);\n                if (*ecp)\n                    goto bad_id;\n                if (check && objid[*objidlen] > 255)\n                    goto bad_id;\n                (*objidlen)++;\n                cp = cp2;\n            }\n            break;\n        case TYPE_OCTETSTR:\n            if (tp->ranges && !tp->ranges->next\n                && tp->ranges->low == tp->ranges->high)\n                len = tp->ranges->low;\n            else\n                len = -1;\n            pos = 0;\n            if (*cp == '\"' || *cp == '\\'') {\n                doingquote = *cp++;\n                /*\n                 * insert length if requested \n                 */\n                if (!in_dices->isimplied && len == -1) {\n                    if (doingquote == '\\'') {\n                        snmp_set_detail\n                            (\"'-quote is for fixed length strings\");\n                        return 0;\n                    }\n                    if (*objidlen >= maxlen)\n                        goto bad_id;\n                    len_index = *objidlen;\n                    (*objidlen)++;\n                } else if (doingquote == '\"') {\n                    snmp_set_detail\n                        (\"\\\"-quote is for variable length strings\");\n                    return 0;\n                }\n\n\t\tcp2 = _apply_escapes(cp, doingquote);\n\t\tif (!cp2) goto bad_id;\n\t\telse {\n\t\t    unsigned char *new_val;\n\t\t    int new_val_len;\n\t\t    int parsed_hint = 0;\n\t\t    const char *parsed_value;\n\n\t\t    if (do_hint && tp->hint) {\n\t\t\tparsed_value = parse_octet_hint(tp->hint, cp,\n\t\t\t                                &new_val, &new_val_len);\n\t\t\tparsed_hint = parsed_value == NULL;\n\t\t    }\n\t\t    if (parsed_hint) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < new_val_len; i++) {\n\t\t\t    if (*objidlen >= maxlen) goto bad_id;\n\t\t\t    objid[ *objidlen ] = new_val[i];\n\t\t\t    (*objidlen)++;\n\t\t\t    pos++;\n\t\t\t}\n\t\t\tSNMP_FREE(new_val);\n\t\t    } else {\n\t\t\twhile(*cp) {\n\t\t\t    if (*objidlen >= maxlen) goto bad_id;\n\t\t\t    objid[ *objidlen ] = *cp++;\n\t\t\t    (*objidlen)++;\n\t\t\t    pos++;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\t\n\t\tcp2++;\n                if (!*cp2)\n                    cp2 = NULL;\n                else if (*cp2 != '.')\n                    goto bad_id;\n                else\n                    cp2++;\n\t\tif (check) {\n                    if (len == -1) {\n                        struct range_list *rp = tp->ranges;\n                        int             ok = 0;\n                        while (rp && !ok)\n                            if (rp->low <= pos && pos <= rp->high)\n                                ok = 1;\n                            else\n                                rp = rp->next;\n                        if (!ok)\n                            goto bad_id;\n                        if (!in_dices->isimplied)\n                            objid[len_index] = pos;\n                    } else if (pos != len)\n                        goto bad_id;\n\t\t}\n\t\telse if (len == -1 && !in_dices->isimplied)\n\t\t    objid[len_index] = pos;\n            } else {\n                if (!in_dices->isimplied && len == -1) {\n                    fcp = cp;\n                    cp2 = strchr(cp, '.');\n                    if (cp2)\n                        *cp2++ = 0;\n                    len = strtoul(cp, &ecp, 0);\n                    if (*ecp)\n                        goto bad_id;\n                    if (*objidlen + len + 1 >= maxlen)\n                        goto bad_id;\n                    objid[*objidlen] = len;\n                    (*objidlen)++;\n                    cp = cp2;\n                }\n                while (len && cp) {\n                    fcp = cp;\n                    cp2 = strchr(cp, '.');\n                    if (cp2)\n                        *cp2++ = 0;\n                    objid[*objidlen] = strtoul(cp, &ecp, 0);\n                    if (*ecp)\n                        goto bad_id;\n                    if (check && objid[*objidlen] > 255)\n                        goto bad_id;\n                    (*objidlen)++;\n                    len--;\n                    cp = cp2;\n                }\n            }\n            break;\n        case TYPE_OBJID:\n            in_dices = NULL;\n            cp2 = cp;\n            break;\n\tcase TYPE_NETADDR:\n\t    fcp = cp;\n\t    cp2 = strchr(cp, '.');\n\t    if (cp2)\n\t\t*cp2++ = 0;\n\t    subid = strtoul(cp, &ecp, 0);\n\t    if (*ecp)\n\t\tgoto bad_id;\n\t    if (*objidlen + 1 >= maxlen)\n\t\tgoto bad_id;\n\t    objid[*objidlen] = subid;\n\t    (*objidlen)++;\n\t    cp = cp2;\n\t    if (subid == 1) {\n\t\tfor (len = 0; cp && len < 4; len++) {\n\t\t    fcp = cp;\n\t\t    cp2 = strchr(cp, '.');\n\t\t    if (cp2)\n\t\t\t*cp2++ = 0;\n\t\t    subid = strtoul(cp, &ecp, 0);\n\t\t    if (*ecp)\n\t\t\tgoto bad_id;\n\t\t    if (*objidlen + 1 >= maxlen)\n\t\t\tgoto bad_id;\n\t\t    if (check && subid > 255)\n\t\t\tgoto bad_id;\n\t\t    objid[*objidlen] = subid;\n\t\t    (*objidlen)++;\n\t\t    cp = cp2;\n\t\t}\n\t    }\n\t    else {\n\t\tin_dices = NULL;\n\t    }\n\t    break;\n        default:\n            snmp_log(LOG_ERR, \"Unexpected index type: %d %s %s\\n\",\n                     tp->type, in_dices->ilabel, cp);\n            in_dices = NULL;\n            cp2 = cp;\n            break;\n        }\n        cp = cp2;\n        if (in_dices)\n            in_dices = in_dices->next;\n    }\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    while (cp) {\n        fcp = cp;\n        switch (*cp) {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            cp2 = strchr(cp, '.');\n            if (cp2)\n                *cp2++ = 0;\n            subid = strtoul(cp, &ecp, 0);\n            if (*ecp)\n                goto bad_id;\n            if (*objidlen >= maxlen)\n                goto bad_id;\n            objid[*objidlen] = subid;\n            (*objidlen)++;\n            break;\n        case '\"':\n        case '\\'':\n            doingquote = *cp++;\n            /*\n             * insert length if requested \n             */\n            if (doingquote == '\"') {\n                if (*objidlen >= maxlen)\n                    goto bad_id;\n                objid[*objidlen] = len = strchr(cp, doingquote) - cp;\n                (*objidlen)++;\n            }\n\n            while (*cp && *cp != doingquote) {\n                if (*objidlen >= maxlen)\n                    goto bad_id;\n                objid[*objidlen] = *cp++;\n                (*objidlen)++;\n            }\n            cp2 = cp + 1;\n            if (!*cp2)\n                cp2 = NULL;\n            else if (*cp2 == '.')\n                cp2++;\n            else\n                goto bad_id;\n            break;\n        default:\n            goto bad_id;\n        }\n        cp = cp2;\n    }\n    return 1;\n\n  bad_id:\n    {\n        char            buf[256];\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        if (in_dices)\n            snprintf(buf, sizeof(buf), \"Index out of range: %s (%s)\",\n                    fcp, in_dices->ilabel);\n        else if (tp)\n            snprintf(buf, sizeof(buf), \"Sub-id not found: %s -> %s\", tp->label, fcp);\n        else\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n            snprintf(buf, sizeof(buf), \"%s\", fcp);\n        buf[ sizeof(buf)-1 ] = 0;\n\n        snmp_set_detail(buf);\n    }\n    return 0;\n}\n\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/**\n * @see comments on find_best_tree_node for usage after first time.\n */\nint\nget_wild_node(const char *name, oid * objid, size_t * objidlen)\n{\n    struct tree    *tp = find_best_tree_node(name, tree_head, NULL);\n    if (!tp)\n        return 0;\n    return get_node(tp->label, objid, objidlen);\n}\n\nint\nget_node(const char *name, oid * objid, size_t * objidlen)\n{\n    const char     *cp;\n    char            ch;\n    int             res;\n\n    cp = name;\n    while ((ch = *cp))\n        if (('0' <= ch && ch <= '9')\n            || ('a' <= ch && ch <= 'z')\n            || ('A' <= ch && ch <= 'Z')\n            || ch == '-')\n            cp++;\n        else\n            break;\n    if (ch != ':')\n        if (*name == '.')\n            res = get_module_node(name + 1, \"ANY\", objid, objidlen);\n        else\n            res = get_module_node(name, \"ANY\", objid, objidlen);\n    else {\n        char           *module;\n        /*\n         *  requested name is of the form\n         *      \"module:subidentifier\"\n         */\n        module = (char *) malloc((size_t) (cp - name + 1));\n        if (!module)\n            return SNMPERR_GENERR;\n        sprintf(module, \"%.*s\", (int) (cp - name), name);\n        cp++;                   /* cp now point to the subidentifier */\n        if (*cp == ':')\n            cp++;\n\n        /*\n         * 'cp' and 'name' *do* go that way round! \n         */\n        res = get_module_node(cp, module, objid, objidlen);\n        SNMP_FREE(module);\n    }\n    if (res == 0) {\n        SET_SNMP_ERROR(SNMPERR_UNKNOWN_OBJID);\n    }\n\n    return res;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifdef testing\n\nmain(int argc, char *argv[])\n{\n    oid             objid[MAX_OID_LEN];\n    int             objidlen = MAX_OID_LEN;\n    int             count;\n    netsnmp_variable_list variable;\n\n    netsnmp_init_mib();\n    if (argc < 2)\n        print_subtree(stdout, tree_head, 0);\n    variable.type = ASN_INTEGER;\n    variable.val.integer = 3;\n    variable.val_len = 4;\n    for (argc--; argc; argc--, argv++) {\n        objidlen = MAX_OID_LEN;\n        printf(\"read_objid(%s) = %d\\n\",\n               argv[1], read_objid(argv[1], objid, &objidlen));\n        for (count = 0; count < objidlen; count++)\n            printf(\"%d.\", objid[count]);\n        printf(\"\\n\");\n        print_variable(objid, objidlen, &variable);\n    }\n}\n\n#endif                          /* testing */\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * initialize: no peers included in the report. \n */\nvoid\nclear_tree_flags(register struct tree *tp)\n{\n    for (; tp; tp = tp->next_peer) {\n        tp->reported = 0;\n        if (tp->child_list)\n            clear_tree_flags(tp->child_list);\n     /*RECURSE*/}\n}\n\n/*\n * Update: 1998-07-17 <jhy@gsu.edu>\n * Added print_oid_report* functions.\n */\nstatic int      print_subtree_oid_report_labeledoid = 0;\nstatic int      print_subtree_oid_report_oid = 0;\nstatic int      print_subtree_oid_report_symbolic = 0;\nstatic int      print_subtree_oid_report_mibchildoid = 0;\nstatic int      print_subtree_oid_report_suffix = 0;\n\n/*\n * These methods recurse. \n */\nstatic void     print_parent_labeledoid(FILE *, struct tree *);\nstatic void     print_parent_oid(FILE *, struct tree *);\nstatic void     print_parent_mibchildoid(FILE *, struct tree *);\nstatic void     print_parent_label(FILE *, struct tree *);\nstatic void     print_subtree_oid_report(FILE *, struct tree *, int);\n\n\nvoid\nprint_oid_report(FILE * fp)\n{\n    struct tree    *tp;\n    clear_tree_flags(tree_head);\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        print_subtree_oid_report(fp, tp, 0);\n}\n\nvoid\nprint_oid_report_enable_labeledoid(void)\n{\n    print_subtree_oid_report_labeledoid = 1;\n}\n\nvoid\nprint_oid_report_enable_oid(void)\n{\n    print_subtree_oid_report_oid = 1;\n}\n\nvoid\nprint_oid_report_enable_suffix(void)\n{\n    print_subtree_oid_report_suffix = 1;\n}\n\nvoid\nprint_oid_report_enable_symbolic(void)\n{\n    print_subtree_oid_report_symbolic = 1;\n}\n\nvoid\nprint_oid_report_enable_mibchildoid(void)\n{\n    print_subtree_oid_report_mibchildoid = 1;\n}\n\n/*\n * helper methods for print_subtree_oid_report()\n * each one traverses back up the node tree\n * until there is no parent.  Then, the label combination\n * is output, such that the parent is displayed first.\n *\n * Warning: these methods are all recursive.\n */\n\nstatic void\nprint_parent_labeledoid(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_labeledoid(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%s(%lu)\", tp->label, tp->subid);\n    }\n}\n\nstatic void\nprint_parent_oid(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_oid(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%lu\", tp->subid);\n    }\n}\n\n\nstatic void print_parent_mibchildoid(FILE * f, struct tree *tp)\n{\n    static struct tree *temp;\n    unsigned long elems[100];\n    int elem_cnt = 0;\n    int i = 0;\n    temp = tp;\n    if (temp) {\n        while (temp->parent) {\n                elems[elem_cnt++] = temp->subid;\n                temp = temp->parent;\n        }\n        elems[elem_cnt++] = temp->subid;\n    }\n    for (i = elem_cnt - 1; i >= 0; i--) {\n        if (i == elem_cnt - 1) {\n            fprintf(f, \"%lu\", elems[i]);           \n            } else {\n            fprintf(f, \".%lu\", elems[i]);          \n        }\n    }\n}\n\nstatic void\nprint_parent_label(FILE * f, struct tree *tp)\n{\n    if (tp) {\n        if (tp->parent) {\n            print_parent_label(f, tp->parent);\n         /*RECURSE*/}\n        fprintf(f, \".%s\", tp->label);\n    }\n}\n\n/**\n * @internal\n * This methods generates variations on the original print_subtree() report.\n * Traverse the tree depth first, from least to greatest sub-identifier.\n * Warning: this methods recurses and calls methods that recurse.\n *\n * @param f       File descriptor to print to.\n * @param tree    ???\n * @param count   ???\n */\n\nstatic void\nprint_subtree_oid_report(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n\n    count++;\n\n    /*\n     * sanity check \n     */\n    if (!tree) {\n        return;\n    }\n\n    /*\n     * find the not reported peer with the lowest sub-identifier.\n     * if no more, break the loop and cleanup.\n     * set \"reported\" flag, and create report for this peer.\n     * recurse using the children of this peer, if any.\n     */\n    while (1) {\n        register struct tree *ntp;\n\n        tp = NULL;\n        for (ntp = tree->child_list; ntp; ntp = ntp->next_peer) {\n            if (ntp->reported)\n                continue;\n\n            if (!tp || (tp->subid > ntp->subid))\n                tp = ntp;\n        }\n        if (!tp)\n            break;\n\n        tp->reported = 1;\n\n        if (print_subtree_oid_report_labeledoid) {\n            print_parent_labeledoid(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_oid) {\n            print_parent_oid(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_symbolic) {\n            print_parent_label(f, tp);\n            fprintf(f, \"\\n\");\n        }\n        if (print_subtree_oid_report_mibchildoid) {\n\t    fprintf(f, \"\\\"%s\\\"\\t\", tp->label);\n            fprintf(f, \"\\t\\t\\\"\");\n            print_parent_mibchildoid(f, tp);\n            fprintf(f, \"\\\"\\n\");\n        }\n        if (print_subtree_oid_report_suffix) {\n            int             i;\n            for (i = 0; i < count; i++)\n                fprintf(f, \"  \");\n            fprintf(f, \"%s(%ld) type=%d\", tp->label, tp->subid, tp->type);\n            if (tp->tc_index != -1)\n                fprintf(f, \" tc=%d\", tp->tc_index);\n            if (tp->hint)\n                fprintf(f, \" hint=%s\", tp->hint);\n            if (tp->units)\n                fprintf(f, \" units=%s\", tp->units);\n\n            fprintf(f, \"\\n\");\n        }\n        print_subtree_oid_report(f, tp, count);\n     /*RECURSE*/}\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n\n/**\n * Converts timeticks to hours, minutes, seconds string.\n *\n * @param timeticks    The timeticks to convert.\n * @param buf          Buffer to write to, has to be at \n *                     least 40 Bytes large.\n *       \n * @return The buffer\n *\n * @see uptimeString\n */\nchar           *\nuptime_string(u_long timeticks, char *buf)\n{\n    return uptime_string_n( timeticks, buf, 40);\n}\n\nchar           *\nuptime_string_n(u_long timeticks, char *buf, size_t buflen)\n{\n    uptimeString(timeticks, buf, buflen);\n    return buf;\n}\n\n/**\n * Given a string, parses an oid out of it (if possible).\n * It will try to parse it based on predetermined configuration if\n * present or by every method possible otherwise.\n * If a suffix has been registered using NETSNMP_DS_LIB_OIDSUFFIX, it\n * will be appended to the input string before processing.\n *\n * @param argv    The OID to string parse\n * @param root    An OID array where the results are stored.\n * @param rootlen The max length of the array going in and the data\n *                length coming out.\n *\n * @return        The root oid pointer if successful, or NULL otherwise.\n */\n \noid            *\nsnmp_parse_oid(const char *argv, oid * root, size_t * rootlen)\n{\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    size_t          savlen = *rootlen;\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    static size_t   tmpbuf_len = 0;\n    static char    *tmpbuf = NULL;\n    const char     *suffix, *prefix;\n\n    suffix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n                                   NETSNMP_DS_LIB_OIDSUFFIX);\n    prefix = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID,\n                                   NETSNMP_DS_LIB_OIDPREFIX);\n    if ((suffix && suffix[0]) || (prefix && prefix[0])) {\n        if (!suffix)\n            suffix = \"\";\n        if (!prefix)\n            prefix = \"\";\n        if ((strlen(suffix) + strlen(prefix) + strlen(argv) + 2) > tmpbuf_len) {\n            tmpbuf_len = strlen(suffix) + strlen(argv) + strlen(prefix) + 2;\n            tmpbuf = malloc(tmpbuf_len);\n        }\n        snprintf(tmpbuf, tmpbuf_len, \"%s%s%s%s\", prefix, argv,\n                 ((suffix[0] == '.' || suffix[0] == '\\0') ? \"\" : \".\"),\n                 suffix);\n        argv = tmpbuf;\n        DEBUGMSGTL((\"snmp_parse_oid\",\"Parsing: %s\\n\",argv));\n    }\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_RANDOM_ACCESS)\n        || strchr(argv, ':')) {\n        if (get_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    } else if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_REGEX_ACCESS)) {\n\tclear_tree_flags(tree_head);\n        if (get_wild_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    } else {\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n        if (read_objid(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n        *rootlen = savlen;\n        if (get_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n        *rootlen = savlen;\n        DEBUGMSGTL((\"parse_oid\", \"wildly parsing\\n\"));\n\tclear_tree_flags(tree_head);\n        if (get_wild_node(argv, root, rootlen)) {\n            free(tmpbuf);\n            return root;\n        }\n    }\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n    free(tmpbuf);\n    return NULL;\n}\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n/*\n * Use DISPLAY-HINT to parse a value into an octet string.\n *\n * note that \"1d1d\", \"11\" could have come from an octet string that\n * looked like { 1, 1 } or an octet string that looked like { 11 }\n * because of this, it's doubtful that anyone would use such a display\n * string. Therefore, the parser ignores this case.\n */\n\nstruct parse_hints {\n    int length;\n    int repeat;\n    int format;\n    int separator;\n    int terminator;\n    unsigned char *result;\n    int result_max;\n    int result_len;\n};\n\nstatic void parse_hints_reset(struct parse_hints *ph)\n{\n    ph->length = 0;\n    ph->repeat = 0;\n    ph->format = 0;\n    ph->separator = 0;\n    ph->terminator = 0;\n}\n\nstatic void parse_hints_ctor(struct parse_hints *ph)\n{\n    parse_hints_reset(ph);\n    ph->result = NULL;\n    ph->result_max = 0;\n    ph->result_len = 0;\n}\n\nstatic int parse_hints_add_result_octet(struct parse_hints *ph, unsigned char octet)\n{\n    if (!(ph->result_len < ph->result_max)) {\n\tph->result_max = ph->result_len + 32;\n\tif (!ph->result) {\n\t    ph->result = (unsigned char *)malloc(ph->result_max);\n\t} else {\n\t    ph->result = (unsigned char *)realloc(ph->result, ph->result_max);\n\t}\n    }\n    \n    if (!ph->result) {\n\treturn 0;\t\t/* failed */\n    }\n\n    ph->result[ph->result_len++] = octet;\n    return 1;\t\t\t/* success */\n}\n\nstatic int parse_hints_parse(struct parse_hints *ph, const char **v_in_out)\n{\n    const char *v = *v_in_out;\n    char *nv;\n    int base;\n    int repeats = 0;\n    int repeat_fixup = ph->result_len;\n    \n    if (ph->repeat) {\n\tif (!parse_hints_add_result_octet(ph, 0)) {\n\t    return 0;\n\t}\n    }\n    do {\n\tbase = 0;\n\tswitch (ph->format) {\n\tcase 'x': base += 6;\t/* fall through */\n\tcase 'd': base += 2;\t/* fall through */\n\tcase 'o': base += 8;\t/* fall through */\n\t    {\n\t\tint i;\n\t\tunsigned long number = strtol(v, &nv, base);\n\t\tif (nv == v) return 0;\n\t\tv = nv;\n\t\tfor (i = 0; i < ph->length; i++) {\n\t\t    int shift = 8 * (ph->length - 1 - i);\n\t\t    if (!parse_hints_add_result_octet(ph, (u_char)(number >> shift) )) {\n\t\t\treturn 0; /* failed */\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\n\tcase 'a':\n\t    {\n\t\tint i;\n\t\t    \n\t\tfor (i = 0; i < ph->length && *v; i++) {\n\t\t    if (!parse_hints_add_result_octet(ph, *v++)) {\n\t\t\treturn 0;\t/* failed */\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t}\n\n\trepeats++;\n\n\tif (ph->separator && *v) {\n\t    if (*v == ph->separator) {\n\t\tv++;\n\t    } else {\n\t\treturn 0;\t\t/* failed */\n\t    }\n\t}\n\n\tif (ph->terminator) {\n\t    if (*v == ph->terminator) {\n\t\tv++;\n\t\tbreak;\n\t    }\n\t}\n    } while (ph->repeat && *v);\n    if (ph->repeat) {\n\tph->result[repeat_fixup] = repeats;\n    }\n\n    *v_in_out = v;\n    return 1;\n}\n\nstatic void parse_hints_length_add_digit(struct parse_hints *ph, int digit)\n{\n    ph->length *= 10;\n    ph->length += digit - '0';\n}\n\nconst char *parse_octet_hint(const char *hint, const char *value, unsigned char **new_val, int *new_val_len)\n{\n    const char *h = hint;\n    const char *v = value;\n    struct parse_hints ph;\n    int retval = 1;\n    /* See RFC 1443 */\n    enum {\n\tHINT_1_2,\n\tHINT_2_3,\n\tHINT_1_2_4,\n\tHINT_1_2_5\n    } state = HINT_1_2;\n\n    parse_hints_ctor(&ph);\n    while (*h && *v && retval) {\n\tswitch (state) {\n\tcase HINT_1_2:\n\t    if ('*' == *h) {\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\treturn v;\t/* failed */\n\t    }\n\t    break;\n\n\tcase HINT_2_3:\n\t    if (isdigit((unsigned char)(*h))) {\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\t/* state = HINT_2_3 */\n\t    } else if ('x' == *h || 'd' == *h || 'o' == *h || 'a' == *h) {\n\t\tph.format = *h;\n\t\tstate = HINT_1_2_4;\n\t    } else {\n\t\treturn v;\t/* failed */\n\t    }\n\t    break;\n\n\tcase HINT_1_2_4:\n\t    if ('*' == *h) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\tph.separator = *h;\n\t\tstate = HINT_1_2_5;\n\t    }\n\t    break;\n\n\tcase HINT_1_2_5:\n\t    if ('*' == *h) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tph.repeat = 1;\n\t\tstate = HINT_2_3;\n\t    } else if (isdigit((unsigned char)(*h))) {\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\t\t\n\t\tparse_hints_length_add_digit(&ph, *h);\n\t\tstate = HINT_2_3;\n\t    } else {\n\t\tph.terminator = *h;\n\n\t\tretval = parse_hints_parse(&ph, &v);\n\t\tparse_hints_reset(&ph);\n\n\t\tstate = HINT_1_2;\n\t    }\n\t    break;\n\t}\n\th++;\n    }\n    while (*v && retval) {\n\tretval = parse_hints_parse(&ph, &v);\n    }\n    if (retval) {\n\t*new_val = ph.result;\n\t*new_val_len = ph.result_len;\n    } else {\n\tif (ph.result) {\n\t    SNMP_FREE(ph.result);\n\t}\n\t*new_val = NULL;\n\t*new_val_len = 0;\n    }\n    return retval ? NULL : v;\n}\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n\n#ifdef test_display_hint\n\nint main(int argc, const char **argv)\n{\n    const char *hint;\n    const char *value;\n    unsigned char *new_val;\n    int new_val_len;\n    char *r;\n    \n    if (argc < 3) {\n\tfprintf(stderr, \"usage: dh <hint> <value>\\n\");\n\texit(2);\n    }\n    hint = argv[1];\n    value = argv[2];\n    r = parse_octet_hint(hint, value, &new_val, &new_val_len);\n    printf(\"{\\\"%s\\\", \\\"%s\\\"}: \\n\\t\", hint, value);\n    if (r) {\n        *r = 0;\n    \tprintf(\"returned failed\\n\");\n\tprintf(\"value syntax error at: %s\\n\", value);\n    }\n    else {\n\tint i;\n\tprintf(\"returned success\\n\");\n\tfor (i = 0; i < new_val_len; i++) {\n\t    int c = new_val[i] & 0xFF;\n\t    printf(\"%02X(%c) \", c, isprint(c) ? c : ' ');\n\t}\n\tSNMP_FREE(new_val);\n    }\n    printf(\"\\n\");\n    exit(0);\n}\n\n#endif /* test_display_hint */\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_TO_ASN_TYPE\nu_char\nmib_to_asn_type(int mib_type)\n{\n    switch (mib_type) {\n    case TYPE_OBJID:\n        return ASN_OBJECT_ID;\n\n    case TYPE_OCTETSTR:\n        return ASN_OCTET_STR;\n\n    case TYPE_NETADDR:\n    case TYPE_IPADDR:\n        return ASN_IPADDRESS;\n\n    case TYPE_INTEGER32:\n    case TYPE_INTEGER:\n        return ASN_INTEGER;\n\n    case TYPE_COUNTER:\n        return ASN_COUNTER;\n\n    case TYPE_GAUGE:\n        return ASN_GAUGE;\n\n    case TYPE_TIMETICKS:\n        return ASN_TIMETICKS;\n\n    case TYPE_OPAQUE:\n        return ASN_OPAQUE;\n\n    case TYPE_NULL:\n        return ASN_NULL;\n\n    case TYPE_COUNTER64:\n        return ASN_COUNTER64;\n\n    case TYPE_BITSTRING:\n        return ASN_BIT_STR;\n\n    case TYPE_UINTEGER:\n    case TYPE_UNSIGNED32:\n        return ASN_UNSIGNED;\n\n    case TYPE_NSAPADDRESS:\n        return ASN_NSAP;\n\n    }\n    return -1;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_TO_ASN_TYPE */\n\n/**\n * Converts a string to its OID form.\n * in example  \"hello\" = 5 . 'h' . 'e' . 'l' . 'l' . 'o'\n *\n * @param S   The string.\n * @param O   The oid.\n * @param L   The length of the oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_STRING_CONVERSIONS\nint\nnetsnmp_str2oid(const char *S, oid * O, int L)\n{\n    const char     *c = S;\n    oid            *o = &O[1];\n\n    --L;                        /* leave room for length prefix */\n\n    for (; *c && L; --L, ++o, ++c)\n        *o = *c;\n\n    /*\n     * make sure we got to the end of the string \n     */\n    if (*c != 0)\n        return 1;\n\n    /*\n     * set the length of the oid \n     */\n    *O = c - S;\n\n    return 0;\n}\n\n/**\n * Converts an OID to its character form.\n * in example  5 . 1 . 2 . 3 . 4 . 5 = 12345\n *\n * @param C   The character buffer.\n * @param L   The length of the buffer.\n * @param O   The oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\nint\nnetsnmp_oid2chars(char *C, int L, const oid * O)\n{\n    char           *c = C;\n    const oid      *o = &O[1];\n\n    if (L < (int)*O)\n        return 1;\n\n    L = *O; /** length */\n    for (; L; --L, ++o, ++c) {\n        if (*o > 0xFF)\n            return 1;\n        *c = (char)*o;\n    }\n    return 0;\n}\n\n/**\n * Converts an OID to its string form.\n * in example  5 . 'h' . 'e' . 'l' . 'l' . 'o' = \"hello\\0\" (null terminated)\n *\n * @param S   The character string buffer.\n * @param L   The length of the string buffer.\n * @param O   The oid.\n *\n * @return 0 on Sucess, 1 on failure.\n */\nint\nnetsnmp_oid2str(char *S, int L, oid * O)\n{\n    int            rc;\n\n    if (L <= (int)*O)\n        return 1;\n\n    rc = netsnmp_oid2chars(S, L, O);\n    if (rc)\n        return 1;\n\n    S[ *O ] = 0;\n\n    return 0;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_STRING_CONVERSIONS */\n\n\n#ifndef NETSNMP_FEATURE_REMOVE_MIB_SNPRINT\nint\nsnprint_by_type(char *buf, size_t buf_len,\n                netsnmp_variable_list * var,\n                const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_by_type((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_hexstring(char *buf, size_t buf_len, const u_char * cp, size_t len)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_hexstring((u_char **) & buf, &buf_len, &out_len, 0,\n                                 cp, len))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_asciistring(char *buf, size_t buf_len,\n                    const u_char * cp, size_t len)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_asciistring\n        ((u_char **) & buf, &buf_len, &out_len, 0, cp, len))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_octet_string(char *buf, size_t buf_len,\n                     const netsnmp_variable_list * var, const struct enum_list *enums,\n                     const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_octet_string\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_opaque(char *buf, size_t buf_len,\n               const netsnmp_variable_list * var, const struct enum_list *enums,\n               const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_opaque((u_char **) & buf, &buf_len, &out_len, 0,\n                              var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_object_identifier(char *buf, size_t buf_len,\n                          const netsnmp_variable_list * var,\n                          const struct enum_list *enums, const char *hint,\n                          const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_object_identifier\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_timeticks(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_timeticks((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_hinted_integer(char *buf, size_t buf_len,\n                       long val, const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_hinted_integer\n        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_integer(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_integer((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_uinteger(char *buf, size_t buf_len,\n                 const netsnmp_variable_list * var, const struct enum_list *enums,\n                 const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_uinteger((u_char **) & buf, &buf_len, &out_len, 0,\n                                var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_gauge(char *buf, size_t buf_len,\n              const netsnmp_variable_list * var, const struct enum_list *enums,\n              const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_gauge((u_char **) & buf, &buf_len, &out_len, 0,\n                             var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_counter(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_counter((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_networkaddress(char *buf, size_t buf_len,\n                       const netsnmp_variable_list * var,\n                       const struct enum_list *enums, const char *hint,\n                       const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_networkaddress\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_ipaddress(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_ipaddress((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_null(char *buf, size_t buf_len,\n             const netsnmp_variable_list * var, const struct enum_list *enums,\n             const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_null((u_char **) & buf, &buf_len, &out_len, 0,\n                            var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_bitstring(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_bitstring((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_nsapaddress(char *buf, size_t buf_len,\n                    const netsnmp_variable_list * var, const struct enum_list *enums,\n                    const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_nsapaddress\n        ((u_char **) & buf, &buf_len, &out_len, 0, var, enums, hint,\n         units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_counter64(char *buf, size_t buf_len,\n                  const netsnmp_variable_list * var, const struct enum_list *enums,\n                  const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_counter64((u_char **) & buf, &buf_len, &out_len, 0,\n                                 var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_badtype(char *buf, size_t buf_len,\n                const netsnmp_variable_list * var, const struct enum_list *enums,\n                const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_badtype((u_char **) & buf, &buf_len, &out_len, 0,\n                               var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\n#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES\nint\nsnprint_float(char *buf, size_t buf_len,\n              const netsnmp_variable_list * var, const struct enum_list *enums,\n              const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_float((u_char **) & buf, &buf_len, &out_len, 0,\n                             var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n\nint\nsnprint_double(char *buf, size_t buf_len,\n               const netsnmp_variable_list * var, const struct enum_list *enums,\n               const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_double((u_char **) & buf, &buf_len, &out_len, 0,\n                              var, enums, hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}\n#endif\n#endif /* NETSNMP_FEATURE_REMOVE_MIB_SNPRINT */\n/** @} */\n\n", "/*\n * parse.c\n *\n */\n/* Portions of this file are subject to the following copyrights.  See\n * the Net-SNMP's COPYING file for more details and other copyrights\n * that may apply:\n */\n/******************************************************************\n        Copyright 1989, 1991, 1992 by Carnegie Mellon University\n\n                      All Rights Reserved\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee is hereby granted,\nprovided that the above copyright notice appear in all copies and that\nboth that copyright notice and this permission notice appear in\nsupporting documentation, and that the name of CMU not be\nused in advertising or publicity pertaining to distribution of the\nsoftware without specific, written prior permission.\n\nCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING\nALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL\nCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR\nANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\nARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\nSOFTWARE.\n******************************************************************/\n/*\n * Copyright \ufffd 2003 Sun Microsystems, Inc. All rights reserved.\n * Use is subject to license terms specified in the COPYING file\n * distributed with the Net-SNMP package.\n */\n#include <net-snmp/net-snmp-config.h>\n#include <net-snmp/net-snmp-features.h>\n\n#ifndef NETSNMP_DISABLE_MIB_LOADING\n\n#if HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#include <stdio.h>\n#if HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#if HAVE_STRING_H\n#include <string.h>\n#else\n#include <strings.h>\n#endif\n#include <ctype.h>\n#include <sys/types.h>\n#if HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n\n/*\n * Wow.  This is ugly.  -- Wes \n */\n#if HAVE_DIRENT_H\n# include <dirent.h>\n# define NAMLEN(dirent) strlen((dirent)->d_name)\n#else\n# define dirent direct\n# define NAMLEN(dirent) (dirent)->d_namlen\n# if HAVE_SYS_NDIR_H\n#  include <sys/ndir.h>\n# endif\n# if HAVE_SYS_DIR_H\n#  include <sys/dir.h>\n# endif\n# if HAVE_NDIR_H\n#  include <ndir.h>\n# endif\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif\n#if HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)\n#include <regex.h>\n#endif\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if HAVE_DMALLOC_H\n#include <dmalloc.h>\n#endif\n\n#include <errno.h>\n\n#include <net-snmp/types.h>\n#include <net-snmp/output_api.h>\n#include <net-snmp/config_api.h>\n#include <net-snmp/utilities.h>\n\n#include <net-snmp/library/parse.h>\n#include <net-snmp/library/mib.h>\n#include <net-snmp/library/snmp_api.h>\n#include <net-snmp/library/tools.h>\n\nnetsnmp_feature_child_of(find_module, mib_api)\nnetsnmp_feature_child_of(get_tc_description, mib_api)\n\n/*\n * A linked list of nodes.\n */\nstruct node {\n    struct node    *next;\n    char           *label;  /* This node's (unique) textual name */\n    u_long          subid;  /* This node's integer subidentifier */\n    int             modid;  /* The module containing this node */\n    char           *parent; /* The parent's textual name */\n    int             tc_index; /* index into tclist (-1 if NA) */\n    int             type;   /* The type of object this represents */\n    int             access;\n    int             status;\n    struct enum_list *enums; /* (optional) list of enumerated integers */\n    struct range_list *ranges;\n    struct index_list *indexes;\n    char           *augments;\n    struct varbind_list *varbinds;\n    char           *hint;\n    char           *units;\n    char           *description; /* description (a quoted string) */\n    char           *reference; /* references (a quoted string) */\n    char           *defaultValue;\n    char           *filename;\n    int             lineno;\n};\n\n/*\n * This is one element of an object identifier with either an integer\n * subidentifier, or a textual string label, or both.\n * The subid is -1 if not present, and label is NULL if not present.\n */\nstruct subid_s {\n    int             subid;\n    int             modid;\n    char           *label;\n};\n\n#define MAXTC   16384\nstruct tc {                     /* textual conventions */\n    int             type;\n    int             modid;\n    char           *descriptor;\n    char           *hint;\n    struct enum_list *enums;\n    struct range_list *ranges;\n    char           *description;\n} tclist[MAXTC];\n\nint             mibLine = 0;\nconst char     *File = \"(none)\";\nstatic int      anonymous = 0;\n\nstruct objgroup {\n    char           *name;\n    int             line;\n    struct objgroup *next;\n}              *objgroups = NULL, *objects = NULL, *notifs = NULL;\n\n#define SYNTAX_MASK     0x80\n/*\n * types of tokens\n * Tokens wiht the SYNTAX_MASK bit set are syntax tokens \n */\n#define CONTINUE    -1\n#define ENDOFFILE   0\n#define LABEL       1\n#define SUBTREE     2\n#define SYNTAX      3\n#define OBJID       (4 | SYNTAX_MASK)\n#define OCTETSTR    (5 | SYNTAX_MASK)\n#define INTEGER     (6 | SYNTAX_MASK)\n#define NETADDR     (7 | SYNTAX_MASK)\n#define IPADDR      (8 | SYNTAX_MASK)\n#define COUNTER     (9 | SYNTAX_MASK)\n#define GAUGE       (10 | SYNTAX_MASK)\n#define TIMETICKS   (11 | SYNTAX_MASK)\n#define KW_OPAQUE   (12 | SYNTAX_MASK)\n#define NUL         (13 | SYNTAX_MASK)\n#define SEQUENCE    14\n#define OF          15          /* SEQUENCE OF */\n#define OBJTYPE     16\n#define ACCESS      17\n#define READONLY    18\n#define READWRITE   19\n#define WRITEONLY   20\n#ifdef NOACCESS\n#undef NOACCESS                 /* agent 'NOACCESS' token */\n#endif\n#define NOACCESS    21\n#define STATUS      22\n#define MANDATORY   23\n#define KW_OPTIONAL    24\n#define OBSOLETE    25\n/*\n * #define RECOMMENDED 26 \n */\n#define PUNCT       27\n#define EQUALS      28\n#define NUMBER      29\n#define LEFTBRACKET 30\n#define RIGHTBRACKET 31\n#define LEFTPAREN   32\n#define RIGHTPAREN  33\n#define COMMA       34\n#define DESCRIPTION 35\n#define QUOTESTRING 36\n#define INDEX       37\n#define DEFVAL      38\n#define DEPRECATED  39\n#define SIZE        40\n#define BITSTRING   (41 | SYNTAX_MASK)\n#define NSAPADDRESS (42 | SYNTAX_MASK)\n#define COUNTER64   (43 | SYNTAX_MASK)\n#define OBJGROUP    44\n#define NOTIFTYPE   45\n#define AUGMENTS    46\n#define COMPLIANCE  47\n#define READCREATE  48\n#define UNITS       49\n#define REFERENCE   50\n#define NUM_ENTRIES 51\n#define MODULEIDENTITY 52\n#define LASTUPDATED 53\n#define ORGANIZATION 54\n#define CONTACTINFO 55\n#define UINTEGER32 (56 | SYNTAX_MASK)\n#define CURRENT     57\n#define DEFINITIONS 58\n#define END         59\n#define SEMI        60\n#define TRAPTYPE    61\n#define ENTERPRISE  62\n/*\n * #define DISPLAYSTR (63 | SYNTAX_MASK) \n */\n#define BEGIN       64\n#define IMPORTS     65\n#define EXPORTS     66\n#define ACCNOTIFY   67\n#define BAR         68\n#define RANGE       69\n#define CONVENTION  70\n#define DISPLAYHINT 71\n#define FROM        72\n#define AGENTCAP    73\n#define MACRO       74\n#define IMPLIED     75\n#define SUPPORTS    76\n#define INCLUDES    77\n#define VARIATION   78\n#define REVISION    79\n#define NOTIMPL\t    80\n#define OBJECTS\t    81\n#define NOTIFICATIONS\t82\n#define MODULE\t    83\n#define MINACCESS   84\n#define PRODREL\t    85\n#define WRSYNTAX    86\n#define CREATEREQ   87\n#define NOTIFGROUP  88\n#define MANDATORYGROUPS\t89\n#define GROUP\t    90\n#define OBJECT\t    91\n#define IDENTIFIER  92\n#define CHOICE\t    93\n#define LEFTSQBRACK\t95\n#define RIGHTSQBRACK\t96\n#define IMPLICIT    97\n#define APPSYNTAX\t(98 | SYNTAX_MASK)\n#define OBJSYNTAX\t(99 | SYNTAX_MASK)\n#define SIMPLESYNTAX\t(100 | SYNTAX_MASK)\n#define OBJNAME\t\t(101 | SYNTAX_MASK)\n#define NOTIFNAME\t(102 | SYNTAX_MASK)\n#define VARIABLES\t103\n#define UNSIGNED32\t(104 | SYNTAX_MASK)\n#define INTEGER32\t(105 | SYNTAX_MASK)\n#define OBJIDENTITY\t106\n/*\n * Beware of reaching SYNTAX_MASK (0x80) \n */\n\nstruct tok {\n    const char     *name;       /* token name */\n    int             len;        /* length not counting nul */\n    int             token;      /* value */\n    int             hash;       /* hash of name */\n    struct tok     *next;       /* pointer to next in hash table */\n};\n\n\nstatic struct tok tokens[] = {\n    {\"obsolete\", sizeof(\"obsolete\") - 1, OBSOLETE}\n    ,\n    {\"Opaque\", sizeof(\"Opaque\") - 1, KW_OPAQUE}\n    ,\n    {\"optional\", sizeof(\"optional\") - 1, KW_OPTIONAL}\n    ,\n    {\"LAST-UPDATED\", sizeof(\"LAST-UPDATED\") - 1, LASTUPDATED}\n    ,\n    {\"ORGANIZATION\", sizeof(\"ORGANIZATION\") - 1, ORGANIZATION}\n    ,\n    {\"CONTACT-INFO\", sizeof(\"CONTACT-INFO\") - 1, CONTACTINFO}\n    ,\n    {\"MODULE-IDENTITY\", sizeof(\"MODULE-IDENTITY\") - 1, MODULEIDENTITY}\n    ,\n    {\"MODULE-COMPLIANCE\", sizeof(\"MODULE-COMPLIANCE\") - 1, COMPLIANCE}\n    ,\n    {\"DEFINITIONS\", sizeof(\"DEFINITIONS\") - 1, DEFINITIONS}\n    ,\n    {\"END\", sizeof(\"END\") - 1, END}\n    ,\n    {\"AUGMENTS\", sizeof(\"AUGMENTS\") - 1, AUGMENTS}\n    ,\n    {\"not-accessible\", sizeof(\"not-accessible\") - 1, NOACCESS}\n    ,\n    {\"write-only\", sizeof(\"write-only\") - 1, WRITEONLY}\n    ,\n    {\"NsapAddress\", sizeof(\"NsapAddress\") - 1, NSAPADDRESS}\n    ,\n    {\"UNITS\", sizeof(\"Units\") - 1, UNITS}\n    ,\n    {\"REFERENCE\", sizeof(\"REFERENCE\") - 1, REFERENCE}\n    ,\n    {\"NUM-ENTRIES\", sizeof(\"NUM-ENTRIES\") - 1, NUM_ENTRIES}\n    ,\n    {\"BITSTRING\", sizeof(\"BITSTRING\") - 1, BITSTRING}\n    ,\n    {\"BIT\", sizeof(\"BIT\") - 1, CONTINUE}\n    ,\n    {\"BITS\", sizeof(\"BITS\") - 1, BITSTRING}\n    ,\n    {\"Counter64\", sizeof(\"Counter64\") - 1, COUNTER64}\n    ,\n    {\"TimeTicks\", sizeof(\"TimeTicks\") - 1, TIMETICKS}\n    ,\n    {\"NOTIFICATION-TYPE\", sizeof(\"NOTIFICATION-TYPE\") - 1, NOTIFTYPE}\n    ,\n    {\"OBJECT-GROUP\", sizeof(\"OBJECT-GROUP\") - 1, OBJGROUP}\n    ,\n    {\"OBJECT-IDENTITY\", sizeof(\"OBJECT-IDENTITY\") - 1, OBJIDENTITY}\n    ,\n    {\"IDENTIFIER\", sizeof(\"IDENTIFIER\") - 1, IDENTIFIER}\n    ,\n    {\"OBJECT\", sizeof(\"OBJECT\") - 1, OBJECT}\n    ,\n    {\"NetworkAddress\", sizeof(\"NetworkAddress\") - 1, NETADDR}\n    ,\n    {\"Gauge\", sizeof(\"Gauge\") - 1, GAUGE}\n    ,\n    {\"Gauge32\", sizeof(\"Gauge32\") - 1, GAUGE}\n    ,\n    {\"Unsigned32\", sizeof(\"Unsigned32\") - 1, UNSIGNED32}\n    ,\n    {\"read-write\", sizeof(\"read-write\") - 1, READWRITE}\n    ,\n    {\"read-create\", sizeof(\"read-create\") - 1, READCREATE}\n    ,\n    {\"OCTETSTRING\", sizeof(\"OCTETSTRING\") - 1, OCTETSTR}\n    ,\n    {\"OCTET\", sizeof(\"OCTET\") - 1, CONTINUE}\n    ,\n    {\"OF\", sizeof(\"OF\") - 1, OF}\n    ,\n    {\"SEQUENCE\", sizeof(\"SEQUENCE\") - 1, SEQUENCE}\n    ,\n    {\"NULL\", sizeof(\"NULL\") - 1, NUL}\n    ,\n    {\"IpAddress\", sizeof(\"IpAddress\") - 1, IPADDR}\n    ,\n    {\"UInteger32\", sizeof(\"UInteger32\") - 1, UINTEGER32}\n    ,\n    {\"INTEGER\", sizeof(\"INTEGER\") - 1, INTEGER}\n    ,\n    {\"Integer32\", sizeof(\"Integer32\") - 1, INTEGER32}\n    ,\n    {\"Counter\", sizeof(\"Counter\") - 1, COUNTER}\n    ,\n    {\"Counter32\", sizeof(\"Counter32\") - 1, COUNTER}\n    ,\n    {\"read-only\", sizeof(\"read-only\") - 1, READONLY}\n    ,\n    {\"DESCRIPTION\", sizeof(\"DESCRIPTION\") - 1, DESCRIPTION}\n    ,\n    {\"INDEX\", sizeof(\"INDEX\") - 1, INDEX}\n    ,\n    {\"DEFVAL\", sizeof(\"DEFVAL\") - 1, DEFVAL}\n    ,\n    {\"deprecated\", sizeof(\"deprecated\") - 1, DEPRECATED}\n    ,\n    {\"SIZE\", sizeof(\"SIZE\") - 1, SIZE}\n    ,\n    {\"MAX-ACCESS\", sizeof(\"MAX-ACCESS\") - 1, ACCESS}\n    ,\n    {\"ACCESS\", sizeof(\"ACCESS\") - 1, ACCESS}\n    ,\n    {\"mandatory\", sizeof(\"mandatory\") - 1, MANDATORY}\n    ,\n    {\"current\", sizeof(\"current\") - 1, CURRENT}\n    ,\n    {\"STATUS\", sizeof(\"STATUS\") - 1, STATUS}\n    ,\n    {\"SYNTAX\", sizeof(\"SYNTAX\") - 1, SYNTAX}\n    ,\n    {\"OBJECT-TYPE\", sizeof(\"OBJECT-TYPE\") - 1, OBJTYPE}\n    ,\n    {\"TRAP-TYPE\", sizeof(\"TRAP-TYPE\") - 1, TRAPTYPE}\n    ,\n    {\"ENTERPRISE\", sizeof(\"ENTERPRISE\") - 1, ENTERPRISE}\n    ,\n    {\"BEGIN\", sizeof(\"BEGIN\") - 1, BEGIN}\n    ,\n    {\"IMPORTS\", sizeof(\"IMPORTS\") - 1, IMPORTS}\n    ,\n    {\"EXPORTS\", sizeof(\"EXPORTS\") - 1, EXPORTS}\n    ,\n    {\"accessible-for-notify\", sizeof(\"accessible-for-notify\") - 1,\n     ACCNOTIFY}\n    ,\n    {\"TEXTUAL-CONVENTION\", sizeof(\"TEXTUAL-CONVENTION\") - 1, CONVENTION}\n    ,\n    {\"NOTIFICATION-GROUP\", sizeof(\"NOTIFICATION-GROUP\") - 1, NOTIFGROUP}\n    ,\n    {\"DISPLAY-HINT\", sizeof(\"DISPLAY-HINT\") - 1, DISPLAYHINT}\n    ,\n    {\"FROM\", sizeof(\"FROM\") - 1, FROM}\n    ,\n    {\"AGENT-CAPABILITIES\", sizeof(\"AGENT-CAPABILITIES\") - 1, AGENTCAP}\n    ,\n    {\"MACRO\", sizeof(\"MACRO\") - 1, MACRO}\n    ,\n    {\"IMPLIED\", sizeof(\"IMPLIED\") - 1, IMPLIED}\n    ,\n    {\"SUPPORTS\", sizeof(\"SUPPORTS\") - 1, SUPPORTS}\n    ,\n    {\"INCLUDES\", sizeof(\"INCLUDES\") - 1, INCLUDES}\n    ,\n    {\"VARIATION\", sizeof(\"VARIATION\") - 1, VARIATION}\n    ,\n    {\"REVISION\", sizeof(\"REVISION\") - 1, REVISION}\n    ,\n    {\"not-implemented\", sizeof(\"not-implemented\") - 1, NOTIMPL}\n    ,\n    {\"OBJECTS\", sizeof(\"OBJECTS\") - 1, OBJECTS}\n    ,\n    {\"NOTIFICATIONS\", sizeof(\"NOTIFICATIONS\") - 1, NOTIFICATIONS}\n    ,\n    {\"MODULE\", sizeof(\"MODULE\") - 1, MODULE}\n    ,\n    {\"MIN-ACCESS\", sizeof(\"MIN-ACCESS\") - 1, MINACCESS}\n    ,\n    {\"PRODUCT-RELEASE\", sizeof(\"PRODUCT-RELEASE\") - 1, PRODREL}\n    ,\n    {\"WRITE-SYNTAX\", sizeof(\"WRITE-SYNTAX\") - 1, WRSYNTAX}\n    ,\n    {\"CREATION-REQUIRES\", sizeof(\"CREATION-REQUIRES\") - 1, CREATEREQ}\n    ,\n    {\"MANDATORY-GROUPS\", sizeof(\"MANDATORY-GROUPS\") - 1, MANDATORYGROUPS}\n    ,\n    {\"GROUP\", sizeof(\"GROUP\") - 1, GROUP}\n    ,\n    {\"CHOICE\", sizeof(\"CHOICE\") - 1, CHOICE}\n    ,\n    {\"IMPLICIT\", sizeof(\"IMPLICIT\") - 1, IMPLICIT}\n    ,\n    {\"ObjectSyntax\", sizeof(\"ObjectSyntax\") - 1, OBJSYNTAX}\n    ,\n    {\"SimpleSyntax\", sizeof(\"SimpleSyntax\") - 1, SIMPLESYNTAX}\n    ,\n    {\"ApplicationSyntax\", sizeof(\"ApplicationSyntax\") - 1, APPSYNTAX}\n    ,\n    {\"ObjectName\", sizeof(\"ObjectName\") - 1, OBJNAME}\n    ,\n    {\"NotificationName\", sizeof(\"NotificationName\") - 1, NOTIFNAME}\n    ,\n    {\"VARIABLES\", sizeof(\"VARIABLES\") - 1, VARIABLES}\n    ,\n    {NULL}\n};\n\nstatic struct module_compatability *module_map_head;\nstatic struct module_compatability module_map[] = {\n    {\"RFC1065-SMI\", \"RFC1155-SMI\", NULL, 0},\n    {\"RFC1066-MIB\", \"RFC1156-MIB\", NULL, 0},\n    /*\n     * 'mib' -> 'mib-2' \n     */\n    {\"RFC1156-MIB\", \"RFC1158-MIB\", NULL, 0},\n    /*\n     * 'snmpEnableAuthTraps' -> 'snmpEnableAuthenTraps' \n     */\n    {\"RFC1158-MIB\", \"RFC1213-MIB\", NULL, 0},\n    /*\n     * 'nullOID' -> 'zeroDotZero' \n     */\n    {\"RFC1155-SMI\", \"SNMPv2-SMI\", NULL, 0},\n    {\"RFC1213-MIB\", \"SNMPv2-SMI\", \"mib-2\", 0},\n    {\"RFC1213-MIB\", \"SNMPv2-MIB\", \"sys\", 3},\n    {\"RFC1213-MIB\", \"IF-MIB\", \"if\", 2},\n    {\"RFC1213-MIB\", \"IP-MIB\", \"ip\", 2},\n    {\"RFC1213-MIB\", \"IP-MIB\", \"icmp\", 4},\n    {\"RFC1213-MIB\", \"TCP-MIB\", \"tcp\", 3},\n    {\"RFC1213-MIB\", \"UDP-MIB\", \"udp\", 3},\n    {\"RFC1213-MIB\", \"SNMPv2-SMI\", \"transmission\", 0},\n    {\"RFC1213-MIB\", \"SNMPv2-MIB\", \"snmp\", 4},\n    {\"RFC1231-MIB\", \"TOKENRING-MIB\", NULL, 0},\n    {\"RFC1271-MIB\", \"RMON-MIB\", NULL, 0},\n    {\"RFC1286-MIB\", \"SOURCE-ROUTING-MIB\", \"dot1dSr\", 7},\n    {\"RFC1286-MIB\", \"BRIDGE-MIB\", NULL, 0},\n    {\"RFC1315-MIB\", \"FRAME-RELAY-DTE-MIB\", NULL, 0},\n    {\"RFC1316-MIB\", \"CHARACTER-MIB\", NULL, 0},\n    {\"RFC1406-MIB\", \"DS1-MIB\", NULL, 0},\n    {\"RFC-1213\", \"RFC1213-MIB\", NULL, 0},\n};\n\n#define MODULE_NOT_FOUND\t0\n#define MODULE_LOADED_OK\t1\n#define MODULE_ALREADY_LOADED\t2\n/*\n * #define MODULE_LOAD_FAILED   3       \n */\n#define MODULE_LOAD_FAILED\tMODULE_NOT_FOUND\n#define MODULE_SYNTAX_ERROR     4\n\nint gMibError = 0,gLoop = 0;\nstatic char *gpMibErrorString;\nchar gMibNames[STRINGMAX];\n\n#define HASHSIZE        32\n#define BUCKET(x)       (x & (HASHSIZE-1))\n\n#define NHASHSIZE    128\n#define NBUCKET(x)   (x & (NHASHSIZE-1))\n\nstatic struct tok *buckets[HASHSIZE];\n\nstatic struct node *nbuckets[NHASHSIZE];\nstatic struct tree *tbuckets[NHASHSIZE];\nstatic struct module *module_head = NULL;\n\nstatic struct node *orphan_nodes = NULL;\nNETSNMP_IMPORT struct tree *tree_head;\nstruct tree        *tree_head = NULL;\n\n#define\tNUMBER_OF_ROOT_NODES\t3\nstatic struct module_import root_imports[NUMBER_OF_ROOT_NODES];\n\nstatic int      current_module = 0;\nstatic int      max_module = 0;\nstatic int      first_err_module = 1;\nstatic char    *last_err_module = NULL; /* no repeats on \"Cannot find module...\" */\n\nstatic void     tree_from_node(struct tree *tp, struct node *np);\nstatic void     do_subtree(struct tree *, struct node **);\nstatic void     do_linkup(struct module *, struct node *);\nstatic void     dump_module_list(void);\nstatic int      get_token(FILE *, char *, int);\nstatic int      parseQuoteString(FILE *, char *, int);\nstatic int      tossObjectIdentifier(FILE *);\nstatic int      name_hash(const char *);\nstatic void     init_node_hash(struct node *);\nstatic void     print_error(const char *, const char *, int);\nstatic void     free_tree(struct tree *);\nstatic void     free_partial_tree(struct tree *, int);\nstatic void     free_node(struct node *);\nstatic void     build_translation_table(void);\nstatic void     init_tree_roots(void);\nstatic void     merge_anon_children(struct tree *, struct tree *);\nstatic void     unlink_tbucket(struct tree *);\nstatic void     unlink_tree(struct tree *);\nstatic int      getoid(FILE *, struct subid_s *, int);\nstatic struct node *parse_objectid(FILE *, char *);\nstatic int      get_tc(const char *, int, int *, struct enum_list **,\n                       struct range_list **, char **);\nstatic int      get_tc_index(const char *, int);\nstatic struct enum_list *parse_enumlist(FILE *, struct enum_list **);\nstatic struct range_list *parse_ranges(FILE * fp, struct range_list **);\nstatic struct node *parse_asntype(FILE *, char *, int *, char *);\nstatic struct node *parse_objecttype(FILE *, char *);\nstatic struct node *parse_objectgroup(FILE *, char *, int,\n                                      struct objgroup **);\nstatic struct node *parse_notificationDefinition(FILE *, char *);\nstatic struct node *parse_trapDefinition(FILE *, char *);\nstatic struct node *parse_compliance(FILE *, char *);\nstatic struct node *parse_capabilities(FILE *, char *);\nstatic struct node *parse_moduleIdentity(FILE *, char *);\nstatic struct node *parse_macro(FILE *, char *);\nstatic void     parse_imports(FILE *);\nstatic struct node *parse(FILE *, struct node *);\n\nstatic int     read_module_internal(const char *);\nstatic int     read_module_replacements(const char *);\nstatic int     read_import_replacements(const char *,\n                                         struct module_import *);\n\nstatic struct node *merge_parse_objectid(struct node *, FILE *, char *);\nstatic struct index_list *getIndexes(FILE * fp, struct index_list **);\nstatic struct varbind_list *getVarbinds(FILE * fp, struct varbind_list **);\nstatic void     free_indexes(struct index_list **);\nstatic void     free_varbinds(struct varbind_list **);\nstatic void     free_ranges(struct range_list **);\nstatic void     free_enums(struct enum_list **);\nstatic struct range_list *copy_ranges(struct range_list *);\nstatic struct enum_list *copy_enums(struct enum_list *);\n\nstatic u_int    compute_match(const char *search_base, const char *key);\n\nvoid\nsnmp_mib_toggle_options_usage(const char *lead, FILE * outf)\n{\n    fprintf(outf, \"%su:  %sallow the use of underlines in MIB symbols\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_PARSE_LABEL)) ?\n\t\t   \"dis\" : \"\"));\n    fprintf(outf, \"%sc:  %sallow the use of \\\"--\\\" to terminate comments\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_COMMENT_TERM)) ?\n\t\t   \"\" : \"dis\"));\n\n    fprintf(outf, \"%sd:  %ssave the DESCRIPTIONs of the MIB objects\\n\",\n            lead, ((netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) ?\n\t\t   \"do not \" : \"\"));\n\n    fprintf(outf, \"%se:  disable errors when MIB symbols conflict\\n\", lead);\n\n    fprintf(outf, \"%sw:  enable warnings when MIB symbols conflict\\n\", lead);\n\n    fprintf(outf, \"%sW:  enable detailed warnings when MIB symbols conflict\\n\",\n            lead);\n\n    fprintf(outf, \"%sR:  replace MIB symbols from latest module\\n\", lead);\n}\n\nchar           *\nsnmp_mib_toggle_options(char *options)\n{\n    if (options) {\n        while (*options) {\n            switch (*options) {\n            case 'u':\n                netsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_PARSE_LABEL,\n                               !netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                               NETSNMP_DS_LIB_MIB_PARSE_LABEL));\n                break;\n\n            case 'c':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_COMMENT_TERM);\n                break;\n\n            case 'e':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_ERRORS);\n                break;\n\n            case 'w':\n                netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS, 1);\n                break;\n\n            case 'W':\n                netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID,\n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS, 2);\n                break;\n\n            case 'd':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_SAVE_MIB_DESCRS);\n                break;\n\n            case 'R':\n                netsnmp_ds_toggle_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_REPLACE);\n                break;\n\n            default:\n                /*\n                 * return at the unknown option \n                 */\n                return options;\n            }\n            options++;\n        }\n    }\n    return NULL;\n}\n\nstatic int\nname_hash(const char *name)\n{\n    int             hash = 0;\n    const char     *cp;\n\n    if (!name)\n        return 0;\n    for (cp = name; *cp; cp++)\n        hash += tolower((unsigned char)(*cp));\n    return (hash);\n}\n\nvoid\nnetsnmp_init_mib_internals(void)\n{\n    register struct tok *tp;\n    register int    b, i;\n    int             max_modc;\n\n    if (tree_head)\n        return;\n\n    /*\n     * Set up hash list of pre-defined tokens\n     */\n    memset(buckets, 0, sizeof(buckets));\n    for (tp = tokens; tp->name; tp++) {\n        tp->hash = name_hash(tp->name);\n        b = BUCKET(tp->hash);\n        if (buckets[b])\n            tp->next = buckets[b];      /* BUG ??? */\n        buckets[b] = tp;\n    }\n\n    /*\n     * Initialise other internal structures\n     */\n\n    max_modc = sizeof(module_map) / sizeof(module_map[0]) - 1;\n    for (i = 0; i < max_modc; ++i)\n        module_map[i].next = &(module_map[i + 1]);\n    module_map[max_modc].next = NULL;\n    module_map_head = module_map;\n\n    memset(nbuckets, 0, sizeof(nbuckets));\n    memset(tbuckets, 0, sizeof(tbuckets));\n    memset(tclist, 0, MAXTC * sizeof(struct tc));\n    build_translation_table();\n    init_tree_roots();          /* Set up initial roots */\n    /*\n     * Relies on 'add_mibdir' having set up the modules \n     */\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nvoid\ninit_mib_internals(void)\n{\n    netsnmp_init_mib_internals();\n}\n#endif\n\nstatic void\ninit_node_hash(struct node *nodes)\n{\n    struct node    *np, *nextp;\n    int             hash;\n\n    memset(nbuckets, 0, sizeof(nbuckets));\n    for (np = nodes; np;) {\n        nextp = np->next;\n        hash = NBUCKET(name_hash(np->parent));\n        np->next = nbuckets[hash];\n        nbuckets[hash] = np;\n        np = nextp;\n    }\n}\n\nstatic int      erroneousMibs = 0;\n\nnetsnmp_feature_child_of(parse_get_error_count, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_GET_ERROR_COUNT\nint\nget_mib_parse_error_count(void)\n{\n    return erroneousMibs;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_GET_ERROR_COUNT */\n\n\nstatic void\nprint_error(const char *str, const char *token, int type)\n{\n    erroneousMibs++;\n    if (!netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID,\n                                NETSNMP_DS_LIB_MIB_ERRORS))\n\treturn;\n    DEBUGMSGTL((\"parse-mibs\", \"\\n\"));\n    if (type == ENDOFFILE)\n        snmp_log(LOG_ERR, \"%s (EOF): At line %d in %s\\n\", str, mibLine,\n                 File);\n    else if (token && *token)\n        snmp_log(LOG_ERR, \"%s (%s): At line %d in %s\\n\", str, token,\n                 mibLine, File);\n    else\n        snmp_log(LOG_ERR, \"%s: At line %d in %s\\n\", str, mibLine, File);\n}\n\nstatic void\nprint_module_not_found(const char *cp)\n{\n    if (first_err_module) {\n        snmp_log(LOG_ERR, \"MIB search path: %s\\n\",\n                           netsnmp_get_mib_directory());\n        first_err_module = 0;\n    }\n    if (!last_err_module || strcmp(cp, last_err_module))\n        print_error(\"Cannot find module\", cp, CONTINUE);\n    if (last_err_module)\n        free(last_err_module);\n    last_err_module = strdup(cp);\n}\n\nstatic struct node *\nalloc_node(int modid)\n{\n    struct node    *np;\n    np = (struct node *) calloc(1, sizeof(struct node));\n    if (np) {\n        np->tc_index = -1;\n        np->modid = modid;\n\tnp->filename = strdup(File);\n\tnp->lineno = mibLine;\n    }\n    return np;\n}\n\nstatic void\nunlink_tbucket(struct tree *tp)\n{\n    int             hash = NBUCKET(name_hash(tp->label));\n    struct tree    *otp = NULL, *ntp = tbuckets[hash];\n\n    while (ntp && ntp != tp) {\n        otp = ntp;\n        ntp = ntp->next;\n    }\n    if (!ntp)\n        snmp_log(LOG_EMERG, \"Can't find %s in tbuckets\\n\", tp->label);\n    else if (otp)\n        otp->next = ntp->next;\n    else\n        tbuckets[hash] = tp->next;\n}\n\nstatic void\nunlink_tree(struct tree *tp)\n{\n    struct tree    *otp = NULL, *ntp = tp->parent;\n\n    if (!ntp) {                 /* this tree has no parent */\n        DEBUGMSGTL((\"unlink_tree\", \"Tree node %s has no parent\\n\",\n                    tp->label));\n    } else {\n        ntp = ntp->child_list;\n\n        while (ntp && ntp != tp) {\n            otp = ntp;\n            ntp = ntp->next_peer;\n        }\n        if (!ntp)\n            snmp_log(LOG_EMERG, \"Can't find %s in %s's children\\n\",\n                     tp->label, tp->parent->label);\n        else if (otp)\n            otp->next_peer = ntp->next_peer;\n        else\n            tp->parent->child_list = tp->next_peer;\n    }\n\n    if (tree_head == tp)\n        tree_head = tp->next_peer;\n}\n\nstatic void\nfree_partial_tree(struct tree *tp, int keep_label)\n{\n    if (!tp)\n        return;\n\n    /*\n     * remove the data from this tree node \n     */\n    free_enums(&tp->enums);\n    free_ranges(&tp->ranges);\n    free_indexes(&tp->indexes);\n    free_varbinds(&tp->varbinds);\n    if (!keep_label)\n        SNMP_FREE(tp->label);\n    SNMP_FREE(tp->hint);\n    SNMP_FREE(tp->units);\n    SNMP_FREE(tp->description);\n    SNMP_FREE(tp->reference);\n    SNMP_FREE(tp->augments);\n    SNMP_FREE(tp->defaultValue);\n}\n\n/*\n * free a tree node. Note: the node must already have been unlinked\n * from the tree when calling this routine\n */\nstatic void\nfree_tree(struct tree *Tree)\n{\n    if (!Tree)\n        return;\n\n    unlink_tbucket(Tree);\n    free_partial_tree(Tree, FALSE);\n    if (Tree->module_list != &Tree->modid)\n        free(Tree->module_list);\n    free(Tree);\n}\n\nstatic void\nfree_node(struct node *np)\n{\n    if (!np)\n        return;\n\n    free_enums(&np->enums);\n    free_ranges(&np->ranges);\n    free_indexes(&np->indexes);\n    free_varbinds(&np->varbinds);\n    if (np->label)\n        free(np->label);\n    if (np->hint)\n        free(np->hint);\n    if (np->units)\n        free(np->units);\n    if (np->description)\n        free(np->description);\n    if (np->reference)\n        free(np->reference);\n    if (np->defaultValue)\n        free(np->defaultValue);\n    if (np->parent)\n        free(np->parent);\n    if (np->augments)\n        free(np->augments);\n    if (np->filename)\n\tfree(np->filename);\n    free((char *) np);\n}\n\nstatic void\nprint_range_value(FILE * fp, int type, struct range_list * rp)\n{\n    switch (type) {\n    case TYPE_INTEGER:\n    case TYPE_INTEGER32:\n        if (rp->low == rp->high)\n            fprintf(fp, \"%d\", rp->low);\n        else\n            fprintf(fp, \"%d..%d\", rp->low, rp->high);\n        break;\n    case TYPE_UNSIGNED32:\n    case TYPE_OCTETSTR:\n    case TYPE_GAUGE:\n    case TYPE_UINTEGER:\n        if (rp->low == rp->high)\n            fprintf(fp, \"%u\", (unsigned)rp->low);\n        else\n            fprintf(fp, \"%u..%u\", (unsigned)rp->low, (unsigned)rp->high);\n        break;\n    default:\n        /* No other range types allowed */\n        break;\n    }\n}\n\n#ifdef TEST\nstatic void\nprint_nodes(FILE * fp, struct node *root)\n{\n    struct enum_list *ep;\n    struct index_list *ip;\n    struct varbind_list *vp;\n    struct node    *np;\n\n    for (np = root; np; np = np->next) {\n        fprintf(fp, \"%s ::= { %s %ld } (%d)\\n\", np->label, np->parent,\n                np->subid, np->type);\n        if (np->tc_index >= 0)\n            fprintf(fp, \"  TC = %s\\n\", tclist[np->tc_index].descriptor);\n        if (np->enums) {\n            fprintf(fp, \"  Enums: \\n\");\n            for (ep = np->enums; ep; ep = ep->next) {\n                fprintf(fp, \"    %s(%d)\\n\", ep->label, ep->value);\n            }\n        }\n        if (np->ranges) {\n            struct range_list *rp;\n            fprintf(fp, \"  Ranges: \");\n            for (rp = np->ranges; rp; rp = rp->next) {\n                fprintf(fp, \"\\n    \");\n                print_range_value(fp, np->type, rp);\n            }\n            fprintf(fp, \"\\n\");\n        }\n        if (np->indexes) {\n            fprintf(fp, \"  Indexes: \\n\");\n            for (ip = np->indexes; ip; ip = ip->next) {\n                fprintf(fp, \"    %s\\n\", ip->ilabel);\n            }\n        }\n        if (np->augments)\n            fprintf(fp, \"  Augments: %s\\n\", np->augments);\n        if (np->varbinds) {\n            fprintf(fp, \"  Varbinds: \\n\");\n            for (vp = np->varbinds; vp; vp = vp->next) {\n                fprintf(fp, \"    %s\\n\", vp->vblabel);\n            }\n        }\n        if (np->hint)\n            fprintf(fp, \"  Hint: %s\\n\", np->hint);\n        if (np->units)\n            fprintf(fp, \"  Units: %s\\n\", np->units);\n        if (np->defaultValue)\n            fprintf(fp, \"  DefaultValue: %s\\n\", np->defaultValue);\n    }\n}\n#endif\n\nvoid\nprint_subtree(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n    int             i;\n    char            modbuf[256];\n\n    for (i = 0; i < count; i++)\n        fprintf(f, \"  \");\n    fprintf(f, \"Children of %s(%ld):\\n\", tree->label, tree->subid);\n    count++;\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        for (i = 0; i < count; i++)\n            fprintf(f, \"  \");\n        fprintf(f, \"%s:%s(%ld) type=%d\",\n                module_name(tp->module_list[0], modbuf),\n                tp->label, tp->subid, tp->type);\n        if (tp->tc_index != -1)\n            fprintf(f, \" tc=%d\", tp->tc_index);\n        if (tp->hint)\n            fprintf(f, \" hint=%s\", tp->hint);\n        if (tp->units)\n            fprintf(f, \" units=%s\", tp->units);\n        if (tp->number_modules > 1) {\n            fprintf(f, \" modules:\");\n            for (i = 1; i < tp->number_modules; i++)\n                fprintf(f, \" %s\", module_name(tp->module_list[i], modbuf));\n        }\n        fprintf(f, \"\\n\");\n    }\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        if (tp->child_list)\n            print_subtree(f, tp, count);\n    }\n}\n\nvoid\nprint_ascii_dump_tree(FILE * f, struct tree *tree, int count)\n{\n    struct tree    *tp;\n\n    count++;\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        fprintf(f, \"%s OBJECT IDENTIFIER ::= { %s %ld }\\n\", tp->label,\n                tree->label, tp->subid);\n    }\n    for (tp = tree->child_list; tp; tp = tp->next_peer) {\n        if (tp->child_list)\n            print_ascii_dump_tree(f, tp, count);\n    }\n}\n\nstatic int      translation_table[256];\n\nstatic void\nbuild_translation_table(void)\n{\n    int             count;\n\n    for (count = 0; count < 256; count++) {\n        switch (count) {\n        case OBJID:\n            translation_table[count] = TYPE_OBJID;\n            break;\n        case OCTETSTR:\n            translation_table[count] = TYPE_OCTETSTR;\n            break;\n        case INTEGER:\n            translation_table[count] = TYPE_INTEGER;\n            break;\n        case NETADDR:\n            translation_table[count] = TYPE_NETADDR;\n            break;\n        case IPADDR:\n            translation_table[count] = TYPE_IPADDR;\n            break;\n        case COUNTER:\n            translation_table[count] = TYPE_COUNTER;\n            break;\n        case GAUGE:\n            translation_table[count] = TYPE_GAUGE;\n            break;\n        case TIMETICKS:\n            translation_table[count] = TYPE_TIMETICKS;\n            break;\n        case KW_OPAQUE:\n            translation_table[count] = TYPE_OPAQUE;\n            break;\n        case NUL:\n            translation_table[count] = TYPE_NULL;\n            break;\n        case COUNTER64:\n            translation_table[count] = TYPE_COUNTER64;\n            break;\n        case BITSTRING:\n            translation_table[count] = TYPE_BITSTRING;\n            break;\n        case NSAPADDRESS:\n            translation_table[count] = TYPE_NSAPADDRESS;\n            break;\n        case INTEGER32:\n            translation_table[count] = TYPE_INTEGER32;\n            break;\n        case UINTEGER32:\n            translation_table[count] = TYPE_UINTEGER;\n            break;\n        case UNSIGNED32:\n            translation_table[count] = TYPE_UNSIGNED32;\n            break;\n        case TRAPTYPE:\n            translation_table[count] = TYPE_TRAPTYPE;\n            break;\n        case NOTIFTYPE:\n            translation_table[count] = TYPE_NOTIFTYPE;\n            break;\n        case NOTIFGROUP:\n            translation_table[count] = TYPE_NOTIFGROUP;\n            break;\n        case OBJGROUP:\n            translation_table[count] = TYPE_OBJGROUP;\n            break;\n        case MODULEIDENTITY:\n            translation_table[count] = TYPE_MODID;\n            break;\n        case OBJIDENTITY:\n            translation_table[count] = TYPE_OBJIDENTITY;\n            break;\n        case AGENTCAP:\n            translation_table[count] = TYPE_AGENTCAP;\n            break;\n        case COMPLIANCE:\n            translation_table[count] = TYPE_MODCOMP;\n            break;\n        default:\n            translation_table[count] = TYPE_OTHER;\n            break;\n        }\n    }\n}\n\nstatic void\ninit_tree_roots(void)\n{\n    struct tree    *tp, *lasttp;\n    int             base_modid;\n    int             hash;\n\n    base_modid = which_module(\"SNMPv2-SMI\");\n    if (base_modid == -1)\n        base_modid = which_module(\"RFC1155-SMI\");\n    if (base_modid == -1)\n        base_modid = which_module(\"RFC1213-MIB\");\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->label = strdup(\"joint-iso-ccitt\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 2;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[0].label = strdup(tp->label);\n    root_imports[0].modid = base_modid;\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->next_peer = lasttp;\n    tp->label = strdup(\"ccitt\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 0;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[1].label = strdup(tp->label);\n    root_imports[1].modid = base_modid;\n\n    /*\n     * build root node \n     */\n    tp = (struct tree *) calloc(1, sizeof(struct tree));\n    if (tp == NULL)\n        return;\n    tp->next_peer = lasttp;\n    tp->label = strdup(\"iso\");\n    tp->modid = base_modid;\n    tp->number_modules = 1;\n    tp->module_list = &(tp->modid);\n    tp->subid = 1;\n    tp->tc_index = -1;\n    set_function(tp);           /* from mib.c */\n    hash = NBUCKET(name_hash(tp->label));\n    tp->next = tbuckets[hash];\n    tbuckets[hash] = tp;\n    lasttp = tp;\n    root_imports[2].label = strdup(tp->label);\n    root_imports[2].modid = base_modid;\n\n    tree_head = tp;\n}\n\n#ifdef STRICT_MIB_PARSEING\n#define\tlabel_compare\tstrcasecmp\n#else\n#define\tlabel_compare\tstrcmp\n#endif\n\n\nstruct tree    *\nfind_tree_node(const char *name, int modid)\n{\n    struct tree    *tp, *headtp;\n    int             count, *int_p;\n\n    if (!name || !*name)\n        return (NULL);\n\n    headtp = tbuckets[NBUCKET(name_hash(name))];\n    for (tp = headtp; tp; tp = tp->next) {\n        if (tp->label && !label_compare(tp->label, name)) {\n\n            if (modid == -1)    /* Any module */\n                return (tp);\n\n            for (int_p = tp->module_list, count = 0;\n                 count < tp->number_modules; ++count, ++int_p)\n                if (*int_p == modid)\n                    return (tp);\n        }\n    }\n\n    return (NULL);\n}\n\n/*\n * computes a value which represents how close name1 is to name2.\n * * high scores mean a worse match.\n * * (yes, the algorithm sucks!)\n */\n#define MAX_BAD 0xffffff\n\nstatic          u_int\ncompute_match(const char *search_base, const char *key)\n{\n#if defined(HAVE_REGEX_H) && defined(HAVE_REGCOMP)\n    int             rc;\n    regex_t         parsetree;\n    regmatch_t      pmatch;\n    rc = regcomp(&parsetree, key, REG_ICASE | REG_EXTENDED);\n    if (rc == 0)\n        rc = regexec(&parsetree, search_base, 1, &pmatch, 0);\n    regfree(&parsetree);\n    if (rc == 0) {\n        /*\n         * found \n         */\n        return pmatch.rm_so;\n    }\n#else                           /* use our own wildcard matcher */\n    /*\n     * first find the longest matching substring (ick) \n     */\n    char           *first = NULL, *result = NULL, *entry;\n    const char     *position;\n    char           *newkey = strdup(key);\n    char           *st;\n\n\n    entry = strtok_r(newkey, \"*\", &st);\n    position = search_base;\n    while (entry) {\n        result = strcasestr(position, entry);\n\n        if (result == NULL) {\n            free(newkey);\n            return MAX_BAD;\n        }\n\n        if (first == NULL)\n            first = result;\n\n        position = result + strlen(entry);\n        entry = strtok_r(NULL, \"*\", &st);\n    }\n    free(newkey);\n    if (result)\n        return (first - search_base);\n#endif\n\n    /*\n     * not found \n     */\n    return MAX_BAD;\n}\n\n/*\n * Find the tree node that best matches the pattern string.\n * Use the \"reported\" flag such that only one match\n * is attempted for every node.\n *\n * Warning! This function may recurse.\n *\n * Caller _must_ invoke clear_tree_flags before first call\n * to this function.  This function may be called multiple times\n * to ensure that the entire tree is traversed.\n */\n\nstruct tree    *\nfind_best_tree_node(const char *pattrn, struct tree *tree_top,\n                    u_int * match)\n{\n    struct tree    *tp, *best_so_far = NULL, *retptr;\n    u_int           old_match = MAX_BAD, new_match = MAX_BAD;\n\n    if (!pattrn || !*pattrn)\n        return (NULL);\n\n    if (!tree_top)\n        tree_top = get_tree_head();\n\n    for (tp = tree_top; tp; tp = tp->next_peer) {\n        if (!tp->reported && tp->label)\n            new_match = compute_match(tp->label, pattrn);\n        tp->reported = 1;\n\n        if (new_match < old_match) {\n            best_so_far = tp;\n            old_match = new_match;\n        }\n        if (new_match == 0)\n            break;              /* this is the best result we can get */\n        if (tp->child_list) {\n            retptr =\n                find_best_tree_node(pattrn, tp->child_list, &new_match);\n            if (new_match < old_match) {\n                best_so_far = retptr;\n                old_match = new_match;\n            }\n            if (new_match == 0)\n                break;          /* this is the best result we can get */\n        }\n    }\n    if (match)\n        *match = old_match;\n    return (best_so_far);\n}\n\n\nstatic void\nmerge_anon_children(struct tree *tp1, struct tree *tp2)\n                /*\n                 * NB: tp1 is the 'anonymous' node \n                 */\n{\n    struct tree    *child1, *child2, *previous;\n\n    for (child1 = tp1->child_list; child1;) {\n\n        for (child2 = tp2->child_list, previous = NULL;\n             child2; previous = child2, child2 = child2->next_peer) {\n\n            if (child1->subid == child2->subid) {\n                /*\n                 * Found 'matching' children,\n                 *  so merge them\n                 */\n                if (!strncmp(child1->label, ANON, ANON_LEN)) {\n                    merge_anon_children(child1, child2);\n\n                    child1->child_list = NULL;\n                    previous = child1;  /* Finished with 'child1' */\n                    child1 = child1->next_peer;\n                    free_tree(previous);\n                    goto next;\n                }\n\n                else if (!strncmp(child2->label, ANON, ANON_LEN)) {\n                    merge_anon_children(child2, child1);\n\n                    if (previous)\n                        previous->next_peer = child2->next_peer;\n                    else\n                        tp2->child_list = child2->next_peer;\n                    free_tree(child2);\n\n                    previous = child1;  /* Move 'child1' to 'tp2' */\n                    child1 = child1->next_peer;\n                    previous->next_peer = tp2->child_list;\n                    tp2->child_list = previous;\n                    for (previous = tp2->child_list;\n                         previous; previous = previous->next_peer)\n                        previous->parent = tp2;\n                    goto next;\n                } else if (!label_compare(child1->label, child2->label)) {\n                    if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                        snmp_log(LOG_WARNING,\n                                 \"Warning: %s.%ld is both %s and %s (%s)\\n\",\n                                 tp2->label, child1->subid, child1->label,\n                                 child2->label, File);\n\t\t    }\n                    continue;\n                } else {\n                    /*\n                     * Two copies of the same node.\n                     * 'child2' adopts the children of 'child1'\n                     */\n\n                    if (child2->child_list) {\n                        for (previous = child2->child_list; previous->next_peer; previous = previous->next_peer);       /* Find the end of the list */\n                        previous->next_peer = child1->child_list;\n                    } else\n                        child2->child_list = child1->child_list;\n                    for (previous = child1->child_list;\n                         previous; previous = previous->next_peer)\n                        previous->parent = child2;\n                    child1->child_list = NULL;\n\n                    previous = child1;  /* Finished with 'child1' */\n                    child1 = child1->next_peer;\n                    free_tree(previous);\n                    goto next;\n                }\n            }\n        }\n        /*\n         * If no match, move 'child1' to 'tp2' child_list\n         */\n        if (child1) {\n            previous = child1;\n            child1 = child1->next_peer;\n            previous->parent = tp2;\n            previous->next_peer = tp2->child_list;\n            tp2->child_list = previous;\n        }\n      next:;\n    }\n}\n\n\n/*\n * Find all the children of root in the list of nodes.  Link them into the\n * tree and out of the nodes list.\n */\nstatic void\ndo_subtree(struct tree *root, struct node **nodes)\n{\n    struct tree    *tp, *anon_tp = NULL;\n    struct tree    *xroot = root;\n    struct node    *np, **headp;\n    struct node    *oldnp = NULL, *child_list = NULL, *childp = NULL;\n    int             hash;\n    int            *int_p;\n\n    while (xroot->next_peer && xroot->next_peer->subid == root->subid) {\n#if 0\n        printf(\"xroot: %s.%s => %s\\n\", xroot->parent->label, xroot->label,\n               xroot->next_peer->label);\n#endif\n        xroot = xroot->next_peer;\n    }\n\n    tp = root;\n    headp = &nbuckets[NBUCKET(name_hash(tp->label))];\n    /*\n     * Search each of the nodes for one whose parent is root, and\n     * move each into a separate list.\n     */\n    for (np = *headp; np; np = np->next) {\n        if (!label_compare(tp->label, np->parent)) {\n            /*\n             * take this node out of the node list \n             */\n            if (oldnp == NULL) {\n                *headp = np->next;      /* fix root of node list */\n            } else {\n                oldnp->next = np->next; /* link around this node */\n            }\n            if (child_list)\n                childp->next = np;\n            else\n                child_list = np;\n            childp = np;\n        } else {\n            oldnp = np;\n        }\n\n    }\n    if (childp)\n        childp->next = NULL;\n    /*\n     * Take each element in the child list and place it into the tree.\n     */\n    for (np = child_list; np; np = np->next) {\n        struct tree    *otp = NULL;\n        struct tree    *xxroot = xroot;\n        anon_tp = NULL;\n        tp = xroot->child_list;\n\n        if (np->subid == -1) {\n            /*\n             * name ::= { parent } \n             */\n            np->subid = xroot->subid;\n            tp = xroot;\n            xxroot = xroot->parent;\n        }\n\n        while (tp) {\n            if (tp->subid == np->subid)\n                break;\n            else {\n                otp = tp;\n                tp = tp->next_peer;\n            }\n        }\n        if (tp) {\n            if (!label_compare(tp->label, np->label)) {\n                /*\n                 * Update list of modules \n                 */\n                int_p = malloc((tp->number_modules + 1) * sizeof(int));\n                if (int_p == NULL)\n                    return;\n                memcpy(int_p, tp->module_list,\n                       tp->number_modules * sizeof(int));\n                int_p[tp->number_modules] = np->modid;\n                if (tp->module_list != &tp->modid)\n                    free(tp->module_list);\n                ++tp->number_modules;\n                tp->module_list = int_p;\n\n                if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_REPLACE)) {\n                    /*\n                     * Replace from node \n                     */\n                    tree_from_node(tp, np);\n                }\n                /*\n                 * Handle children \n                 */\n                do_subtree(tp, nodes);\n                continue;\n            }\n            if (!strncmp(np->label, ANON, ANON_LEN) ||\n                !strncmp(tp->label, ANON, ANON_LEN)) {\n                anon_tp = tp;   /* Need to merge these two trees later */\n            } else if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t  NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                snmp_log(LOG_WARNING,\n                         \"Warning: %s.%ld is both %s and %s (%s)\\n\",\n                         root->label, np->subid, tp->label, np->label,\n                         File);\n\t    }\n        }\n\n        tp = (struct tree *) calloc(1, sizeof(struct tree));\n        if (tp == NULL)\n            return;\n        tp->parent = xxroot;\n        tp->modid = np->modid;\n        tp->number_modules = 1;\n        tp->module_list = &(tp->modid);\n        tree_from_node(tp, np);\n        tp->next_peer = otp ? otp->next_peer : xxroot->child_list;\n        if (otp)\n            otp->next_peer = tp;\n        else\n            xxroot->child_list = tp;\n        hash = NBUCKET(name_hash(tp->label));\n        tp->next = tbuckets[hash];\n        tbuckets[hash] = tp;\n        do_subtree(tp, nodes);\n\n        if (anon_tp) {\n            if (!strncmp(tp->label, ANON, ANON_LEN)) {\n                /*\n                 * The new node is anonymous,\n                 *  so merge it with the existing one.\n                 */\n                merge_anon_children(tp, anon_tp);\n\n                /*\n                 * unlink and destroy tp \n                 */\n                unlink_tree(tp);\n                free_tree(tp);\n            } else if (!strncmp(anon_tp->label, ANON, ANON_LEN)) {\n                struct tree    *ntp;\n                /*\n                 * The old node was anonymous,\n                 *  so merge it with the existing one,\n                 *  and fill in the full information.\n                 */\n                merge_anon_children(anon_tp, tp);\n\n                /*\n                 * unlink anon_tp from the hash \n                 */\n                unlink_tbucket(anon_tp);\n\n                /*\n                 * get rid of old contents of anon_tp \n                 */\n                free_partial_tree(anon_tp, FALSE);\n\n                /*\n                 * put in the current information \n                 */\n                anon_tp->label = tp->label;\n                anon_tp->child_list = tp->child_list;\n                anon_tp->modid = tp->modid;\n                anon_tp->tc_index = tp->tc_index;\n                anon_tp->type = tp->type;\n                anon_tp->enums = tp->enums;\n                anon_tp->indexes = tp->indexes;\n                anon_tp->augments = tp->augments;\n                anon_tp->varbinds = tp->varbinds;\n                anon_tp->ranges = tp->ranges;\n                anon_tp->hint = tp->hint;\n                anon_tp->units = tp->units;\n                anon_tp->description = tp->description;\n                anon_tp->reference = tp->reference;\n                anon_tp->defaultValue = tp->defaultValue;\n                anon_tp->parent = tp->parent;\n\n                set_function(anon_tp);\n\n                /*\n                 * update parent pointer in moved children \n                 */\n                ntp = anon_tp->child_list;\n                while (ntp) {\n                    ntp->parent = anon_tp;\n                    ntp = ntp->next_peer;\n                }\n\n                /*\n                 * hash in anon_tp in its new place \n                 */\n                hash = NBUCKET(name_hash(anon_tp->label));\n                anon_tp->next = tbuckets[hash];\n                tbuckets[hash] = anon_tp;\n\n                /*\n                 * unlink and destroy tp \n                 */\n                unlink_tbucket(tp);\n                unlink_tree(tp);\n                free(tp);\n            } else {\n                /*\n                 * Uh?  One of these two should have been anonymous! \n                 */\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Warning: expected anonymous node (either %s or %s) in %s\\n\",\n                             tp->label, anon_tp->label, File);\n\t\t}\n            }\n            anon_tp = NULL;\n        }\n    }\n    /*\n     * free all nodes that were copied into tree \n     */\n    oldnp = NULL;\n    for (np = child_list; np; np = np->next) {\n        if (oldnp)\n            free_node(oldnp);\n        oldnp = np;\n    }\n    if (oldnp)\n        free_node(oldnp);\n}\n\nstatic void\ndo_linkup(struct module *mp, struct node *np)\n{\n    struct module_import *mip;\n    struct node    *onp, *oldp, *newp;\n    struct tree    *tp;\n    int             i, more;\n    /*\n     * All modules implicitly import\n     *   the roots of the tree\n     */\n    if (snmp_get_do_debugging() > 1)\n        dump_module_list();\n    DEBUGMSGTL((\"parse-mibs\", \"Processing IMPORTS for module %d %s\\n\",\n                mp->modid, mp->name));\n    if (mp->no_imports == 0) {\n        mp->no_imports = NUMBER_OF_ROOT_NODES;\n        mp->imports = root_imports;\n    }\n\n    /*\n     * Build the tree\n     */\n    init_node_hash(np);\n    for (i = 0, mip = mp->imports; i < mp->no_imports; ++i, ++mip) {\n        char            modbuf[256];\n        DEBUGMSGTL((\"parse-mibs\", \"  Processing import: %s\\n\",\n                    mip->label));\n        if (get_tc_index(mip->label, mip->modid) != -1)\n            continue;\n        tp = find_tree_node(mip->label, mip->modid);\n        if (!tp) {\n\t    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_ERRORS))\n                snmp_log(LOG_WARNING,\n                         \"Did not find '%s' in module %s (%s)\\n\",\n                         mip->label, module_name(mip->modid, modbuf),\n                         File);\n            continue;\n        }\n        do_subtree(tp, &np);\n    }\n\n    /*\n     * If any nodes left over,\n     *   check that they're not the result of a \"fully qualified\"\n     *   name, and then add them to the list of orphans\n     */\n\n    if (!np)\n        return;\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        do_subtree(tp, &np);\n    if (!np)\n        return;\n\n    /*\n     * quietly move all internal references to the orphan list \n     */\n    oldp = orphan_nodes;\n    do {\n        for (i = 0; i < NHASHSIZE; i++)\n            for (onp = nbuckets[i]; onp; onp = onp->next) {\n                struct node    *op = NULL;\n                int             hash = NBUCKET(name_hash(onp->label));\n                np = nbuckets[hash];\n                while (np) {\n                    if (label_compare(onp->label, np->parent)) {\n                        op = np;\n                        np = np->next;\n                    } else {\n                        if (op)\n                            op->next = np->next;\n                        else\n                            nbuckets[hash] = np->next;\n\t\t\tDEBUGMSGTL((\"parse-mibs\", \"Moving %s to orphanage\", np->label));\n                        np->next = orphan_nodes;\n                        orphan_nodes = np;\n                        op = NULL;\n                        np = nbuckets[hash];\n                    }\n                }\n            }\n        newp = orphan_nodes;\n        more = 0;\n        for (onp = orphan_nodes; onp != oldp; onp = onp->next) {\n            struct node    *op = NULL;\n            int             hash = NBUCKET(name_hash(onp->label));\n            np = nbuckets[hash];\n            while (np) {\n                if (label_compare(onp->label, np->parent)) {\n                    op = np;\n                    np = np->next;\n                } else {\n                    if (op)\n                        op->next = np->next;\n                    else\n                        nbuckets[hash] = np->next;\n                    np->next = orphan_nodes;\n                    orphan_nodes = np;\n                    op = NULL;\n                    np = nbuckets[hash];\n                    more = 1;\n                }\n            }\n        }\n        oldp = newp;\n    } while (more);\n\n    /*\n     * complain about left over nodes \n     */\n    for (np = orphan_nodes; np && np->next; np = np->next);     /* find the end of the orphan list */\n    for (i = 0; i < NHASHSIZE; i++)\n        if (nbuckets[i]) {\n            if (orphan_nodes)\n                onp = np->next = nbuckets[i];\n            else\n                onp = orphan_nodes = nbuckets[i];\n            nbuckets[i] = NULL;\n            while (onp) {\n                snmp_log(LOG_WARNING,\n                         \"Unlinked OID in %s: %s ::= { %s %ld }\\n\",\n                         (mp->name ? mp->name : \"<no module>\"),\n                         (onp->label ? onp->label : \"<no label>\"),\n                         (onp->parent ? onp->parent : \"<no parent>\"),\n                         onp->subid);\n\t\t snmp_log(LOG_WARNING,\n\t\t\t  \"Undefined identifier: %s near line %d of %s\\n\",\n\t\t\t  (onp->parent ? onp->parent : \"<no parent>\"),\n\t\t\t  onp->lineno, onp->filename);\n                np = onp;\n                onp = onp->next;\n            }\n        }\n    return;\n}\n\n\n/*\n * Takes a list of the form:\n * { iso org(3) dod(6) 1 }\n * and creates several nodes, one for each parent-child pair.\n * Returns 0 on error.\n */\nstatic int\ngetoid(FILE * fp, struct subid_s *id,   /* an array of subids */\n       int length)\n{                               /* the length of the array */\n    register int    count;\n    int             type;\n    char            token[MAXTOKEN];\n\n    if ((type = get_token(fp, token, MAXTOKEN)) != LEFTBRACKET) {\n        print_error(\"Expected \\\"{\\\"\", token, type);\n        return 0;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    for (count = 0; count < length; count++, id++) {\n        id->label = NULL;\n        id->modid = current_module;\n        id->subid = -1;\n        if (type == RIGHTBRACKET)\n            return count;\n        if (type == LABEL) {\n            /*\n             * this entry has a label \n             */\n            id->label = strdup(token);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == LEFTPAREN) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type == NUMBER) {\n                    id->subid = strtoul(token, NULL, 10);\n                    if ((type =\n                         get_token(fp, token, MAXTOKEN)) != RIGHTPAREN) {\n                        print_error(\"Expected a closing parenthesis\",\n                                    token, type);\n                        return 0;\n                    }\n                } else {\n                    print_error(\"Expected a number\", token, type);\n                    return 0;\n                }\n            } else {\n                continue;\n            }\n        } else if (type == NUMBER) {\n            /*\n             * this entry  has just an integer sub-identifier \n             */\n            id->subid = strtoul(token, NULL, 10);\n        } else {\n            print_error(\"Expected label or number\", token, type);\n            return 0;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    print_error(\"Too long OID\", token, type);\n    return 0;\n}\n\n/*\n * Parse a sequence of object subidentifiers for the given name.\n * The \"label OBJECT IDENTIFIER ::=\" portion has already been parsed.\n *\n * The majority of cases take this form :\n * label OBJECT IDENTIFIER ::= { parent 2 }\n * where a parent label and a child subidentifier number are specified.\n *\n * Variations on the theme include cases where a number appears with\n * the parent, or intermediate subidentifiers are specified by label,\n * by number, or both.\n *\n * Here are some representative samples :\n * internet        OBJECT IDENTIFIER ::= { iso org(3) dod(6) 1 }\n * mgmt            OBJECT IDENTIFIER ::= { internet 2 }\n * rptrInfoHealth  OBJECT IDENTIFIER ::= { snmpDot3RptrMgt 0 4 }\n *\n * Here is a very rare form :\n * iso             OBJECT IDENTIFIER ::= { 1 }\n *\n * Returns NULL on error.  When this happens, memory may be leaked.\n */\nstatic struct node *\nparse_objectid(FILE * fp, char *name)\n{\n    register int    count;\n    register struct subid_s *op, *nop;\n    int             length;\n    struct subid_s  loid[32];\n    struct node    *np, *root = NULL, *oldnp = NULL;\n    struct tree    *tp;\n\n    if ((length = getoid(fp, loid, 32)) == 0) {\n        print_error(\"Bad object identifier\", NULL, CONTINUE);\n        return NULL;\n    }\n\n    /*\n     * Handle numeric-only object identifiers,\n     *  by labelling the first sub-identifier\n     */\n    op = loid;\n    if (!op->label) {\n        if (length == 1) {\n            print_error(\"Attempt to define a root oid\", name, OBJECT);\n            return NULL;\n        }\n        for (tp = tree_head; tp; tp = tp->next_peer)\n            if ((int) tp->subid == op->subid) {\n                op->label = strdup(tp->label);\n                break;\n            }\n    }\n\n    /*\n     * Handle  \"label OBJECT-IDENTIFIER ::= { subid }\"\n     */\n    if (length == 1) {\n        op = loid;\n        np = alloc_node(op->modid);\n        if (np == NULL)\n            return (NULL);\n        np->subid = op->subid;\n        np->label = strdup(name);\n        np->parent = op->label;\n        return np;\n    }\n\n    /*\n     * For each parent-child subid pair in the subid array,\n     * create a node and link it into the node list.\n     */\n    for (count = 0, op = loid, nop = loid + 1; count < (length - 1);\n         count++, op++, nop++) {\n        /*\n         * every node must have parent's name and child's name or number \n         */\n        /*\n         * XX the next statement is always true -- does it matter ?? \n         */\n        if (op->label && (nop->label || (nop->subid != -1))) {\n            np = alloc_node(nop->modid);\n            if (np == NULL)\n                goto err;\n            if (root == NULL)\n                root = np;\n\n            np->parent = strdup(op->label);\n            if (count == (length - 2)) {\n                /*\n                 * The name for this node is the label for this entry \n                 */\n                np->label = strdup(name);\n                if (np->label == NULL)\n                    goto err;\n            } else {\n                if (!nop->label) {\n                    nop->label = (char *) malloc(20 + ANON_LEN);\n                    if (nop->label == NULL)\n                        goto err;\n                    sprintf(nop->label, \"%s%d\", ANON, anonymous++);\n                }\n                np->label = strdup(nop->label);\n            }\n            if (nop->subid != -1)\n                np->subid = nop->subid;\n            else\n                print_error(\"Warning: This entry is pretty silly\",\n                            np->label, CONTINUE);\n\n            /*\n             * set up next entry \n             */\n            if (oldnp)\n                oldnp->next = np;\n            oldnp = np;\n        }                       /* end if(op->label... */\n    }\n\nout:\n    /*\n     * free the loid array \n     */\n    for (count = 0, op = loid; count < length; count++, op++) {\n        if (op->label)\n            free(op->label);\n    }\n\n    return root;\n\nerr:\n    for (; root; root = np) {\n        np = root->next;\n        free_node(root);\n    }\n    goto out;\n}\n\nstatic int\nget_tc(const char *descriptor,\n       int modid,\n       int *tc_index,\n       struct enum_list **ep, struct range_list **rp, char **hint)\n{\n    int             i;\n    struct tc      *tcp;\n\n    i = get_tc_index(descriptor, modid);\n    if (tc_index)\n        *tc_index = i;\n    if (i != -1) {\n        tcp = &tclist[i];\n        if (ep) {\n            free_enums(ep);\n            *ep = copy_enums(tcp->enums);\n        }\n        if (rp) {\n            free_ranges(rp);\n            *rp = copy_ranges(tcp->ranges);\n        }\n        if (hint) {\n            if (*hint)\n                free(*hint);\n            *hint = (tcp->hint ? strdup(tcp->hint) : NULL);\n        }\n        return tcp->type;\n    }\n    return LABEL;\n}\n\n/*\n * return index into tclist of given TC descriptor\n * return -1 if not found\n */\nstatic int\nget_tc_index(const char *descriptor, int modid)\n{\n    int             i;\n    struct tc      *tcp;\n    struct module  *mp;\n    struct module_import *mip;\n\n    /*\n     * Check that the descriptor isn't imported\n     *  by searching the import list\n     */\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == modid)\n            break;\n    if (mp)\n        for (i = 0, mip = mp->imports; i < mp->no_imports; ++i, ++mip) {\n            if (!label_compare(mip->label, descriptor)) {\n                /*\n                 * Found it - so amend the module ID \n                 */\n                modid = mip->modid;\n                break;\n            }\n        }\n\n\n    for (i = 0, tcp = tclist; i < MAXTC; i++, tcp++) {\n        if (tcp->type == 0)\n            break;\n        if (!label_compare(descriptor, tcp->descriptor) &&\n            ((modid == tcp->modid) || (modid == -1))) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*\n * translate integer tc_index to string identifier from tclist\n * *\n * * Returns pointer to string in table (should not be modified) or NULL\n */\nconst char     *\nget_tc_descriptor(int tc_index)\n{\n    if (tc_index < 0 || tc_index >= MAXTC)\n        return NULL;\n    return (tclist[tc_index].descriptor);\n}\n\n#ifndef NETSNMP_FEATURE_REMOVE_GET_TC_DESCRIPTION\n/* used in the perl module */\nconst char     *\nget_tc_description(int tc_index)\n{\n    if (tc_index < 0 || tc_index >= MAXTC)\n        return NULL;\n    return (tclist[tc_index].description);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_GET_TC_DESCRIPTION */\n\n\n/*\n * Parses an enumeration list of the form:\n *        { label(value) label(value) ... }\n * The initial { has already been parsed.\n * Returns NULL on error.\n */\n\nstatic struct enum_list *\nparse_enumlist(FILE * fp, struct enum_list **retp)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    struct enum_list *ep = NULL, **epp = &ep;\n\n    free_enums(retp);\n\n    while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {\n        if (type == RIGHTBRACKET)\n            break;\n        /* some enums use \"deprecated\" to indicate a no longer value label */\n        /* (EG: IP-MIB's IpAddressStatusTC) */\n        if (type == LABEL || type == DEPRECATED) {\n            /*\n             * this is an enumerated label \n             */\n            *epp =\n                (struct enum_list *) calloc(1, sizeof(struct enum_list));\n            if (*epp == NULL)\n                return (NULL);\n            /*\n             * a reasonable approximation for the length \n             */\n            (*epp)->label = strdup(token);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LEFTPAREN) {\n                print_error(\"Expected \\\"(\\\"\", token, type);\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != NUMBER) {\n                print_error(\"Expected integer\", token, type);\n                return NULL;\n            }\n            (*epp)->value = strtol(token, NULL, 10);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != RIGHTPAREN) {\n                print_error(\"Expected \\\")\\\"\", token, type);\n                return NULL;\n            }\n            epp = &(*epp)->next;\n        }\n    }\n    if (type == ENDOFFILE) {\n        print_error(\"Expected \\\"}\\\"\", token, type);\n        return NULL;\n    }\n    *retp = ep;\n    return ep;\n}\n\nstatic struct range_list *\nparse_ranges(FILE * fp, struct range_list **retp)\n{\n    int             low, high;\n    char            nexttoken[MAXTOKEN];\n    int             nexttype;\n    struct range_list *rp = NULL, **rpp = &rp;\n    int             size = 0, taken = 1;\n\n    free_ranges(retp);\n\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    if (nexttype == SIZE) {\n        size = 1;\n        taken = 0;\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        if (nexttype != LEFTPAREN)\n            print_error(\"Expected \\\"(\\\" after SIZE\", nexttoken, nexttype);\n    }\n\n    do {\n        if (!taken)\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        else\n            taken = 0;\n        high = low = strtoul(nexttoken, NULL, 10);\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        if (nexttype == RANGE) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            errno = 0;\n            high = strtoul(nexttoken, NULL, 10);\n            if ( errno == ERANGE ) {\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n                                       NETSNMP_DS_LIB_MIB_WARNINGS))\n                    snmp_log(LOG_WARNING,\n                             \"Warning: Upper bound not handled correctly (%s != %d): At line %d in %s\\n\",\n                                 nexttoken, high, mibLine, File);\n            }\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        *rpp = (struct range_list *) calloc(1, sizeof(struct range_list));\n        if (*rpp == NULL)\n            break;\n        (*rpp)->low = low;\n        (*rpp)->high = high;\n        rpp = &(*rpp)->next;\n\n    } while (nexttype == BAR);\n    if (size) {\n        if (nexttype != RIGHTPAREN)\n            print_error(\"Expected \\\")\\\" after SIZE\", nexttoken, nexttype);\n        nexttype = get_token(fp, nexttoken, nexttype);\n    }\n    if (nexttype != RIGHTPAREN)\n        print_error(\"Expected \\\")\\\"\", nexttoken, nexttype);\n\n    *retp = rp;\n    return rp;\n}\n\n/*\n * Parses an asn type.  Structures are ignored by this parser.\n * Returns NULL on error.\n */\nstatic struct node *\nparse_asntype(FILE * fp, char *name, int *ntype, char *ntoken)\n{\n    int             type, i;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    char           *hint = NULL;\n    char           *descr = NULL;\n    struct tc      *tcp;\n    int             level;\n\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == SEQUENCE || type == CHOICE) {\n        level = 0;\n        while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE) {\n            if (type == LEFTBRACKET) {\n                level++;\n            } else if (type == RIGHTBRACKET && --level == 0) {\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                return NULL;\n            }\n        }\n        print_error(\"Expected \\\"}\\\"\", token, type);\n        return NULL;\n    } else if (type == LEFTBRACKET) {\n        struct node    *np;\n        int             ch_next = '{';\n        ungetc(ch_next, fp);\n        np = parse_objectid(fp, name);\n        if (np != NULL) {\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n            return np;\n        }\n        return NULL;\n    } else if (type == LEFTSQBRACK) {\n        int             size = 0;\n        do {\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type != ENDOFFILE && type != RIGHTSQBRACK);\n        if (type != RIGHTSQBRACK) {\n            print_error(\"Expected \\\"]\\\"\", token, type);\n            return NULL;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == IMPLICIT)\n            type = get_token(fp, token, MAXTOKEN);\n        *ntype = get_token(fp, ntoken, MAXTOKEN);\n        if (*ntype == LEFTPAREN) {\n            switch (type) {\n            case OCTETSTR:\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (*ntype != SIZE) {\n                    print_error(\"Expected SIZE\", ntoken, *ntype);\n                    return NULL;\n                }\n                size = 1;\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (*ntype != LEFTPAREN) {\n                    print_error(\"Expected \\\"(\\\" after SIZE\", ntoken,\n                                *ntype);\n                    return NULL;\n                }\n                /* FALL THROUGH */\n            case INTEGER:\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                do {\n                    if (*ntype != NUMBER)\n                        print_error(\"Expected NUMBER\", ntoken, *ntype);\n                    *ntype = get_token(fp, ntoken, MAXTOKEN);\n                    if (*ntype == RANGE) {\n                        *ntype = get_token(fp, ntoken, MAXTOKEN);\n                        if (*ntype != NUMBER)\n                            print_error(\"Expected NUMBER\", ntoken, *ntype);\n                        *ntype = get_token(fp, ntoken, MAXTOKEN);\n                    }\n                } while (*ntype == BAR);\n                if (*ntype != RIGHTPAREN) {\n                    print_error(\"Expected \\\")\\\"\", ntoken, *ntype);\n                    return NULL;\n                }\n                *ntype = get_token(fp, ntoken, MAXTOKEN);\n                if (size) {\n                    if (*ntype != RIGHTPAREN) {\n                        print_error(\"Expected \\\")\\\" to terminate SIZE\",\n                                    ntoken, *ntype);\n                        return NULL;\n                    }\n                    *ntype = get_token(fp, ntoken, MAXTOKEN);\n                }\n            }\n        }\n        return NULL;\n    } else {\n        if (type == CONVENTION) {\n            while (type != SYNTAX && type != ENDOFFILE) {\n                if (type == DISPLAYHINT) {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != QUOTESTRING) {\n                        print_error(\"DISPLAY-HINT must be string\", token,\n                                    type);\n                    } else {\n                        free(hint);\n                        hint = strdup(token);\n                    }\n                } else if (type == DESCRIPTION &&\n                           netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n                                                  NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n                    if (type != QUOTESTRING) {\n                        print_error(\"DESCRIPTION must be string\", token,\n                                    type);\n                    } else {\n                        free(descr);\n                        descr = strdup(quoted_string_buffer);\n                    }\n                } else\n                    type =\n                        get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == OBJECT) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != IDENTIFIER) {\n                    print_error(\"Expected IDENTIFIER\", token, type);\n                    goto err;\n                }\n                type = OBJID;\n            }\n        } else if (type == OBJECT) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != IDENTIFIER) {\n                print_error(\"Expected IDENTIFIER\", token, type);\n                goto err;\n            }\n            type = OBJID;\n        }\n\n        if (type == LABEL) {\n            type = get_tc(token, current_module, NULL, NULL, NULL, NULL);\n        }\n\n        /*\n         * textual convention \n         */\n        for (i = 0; i < MAXTC; i++) {\n            if (tclist[i].type == 0)\n                break;\n        }\n\n        if (i == MAXTC) {\n            print_error(\"Too many textual conventions\", token, type);\n            goto err;\n        }\n        if (!(type & SYNTAX_MASK)) {\n            print_error(\"Textual convention doesn't map to real type\",\n                        token, type);\n            goto err;\n        }\n        tcp = &tclist[i];\n        tcp->modid = current_module;\n        tcp->descriptor = strdup(name);\n        tcp->hint = hint;\n        tcp->description = descr;\n        tcp->type = type;\n        *ntype = get_token(fp, ntoken, MAXTOKEN);\n        if (*ntype == LEFTPAREN) {\n            tcp->ranges = parse_ranges(fp, &tcp->ranges);\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n        } else if (*ntype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            tcp->enums = parse_enumlist(fp, &tcp->enums);\n            *ntype = get_token(fp, ntoken, MAXTOKEN);\n        }\n        return NULL;\n    }\n\nerr:\n    SNMP_FREE(descr);\n    SNMP_FREE(hint);\n    return NULL;\n}\n\n\n/*\n * Parses an OBJECT TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_objecttype(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            nexttoken[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    int             nexttype, tctype;\n    register struct node *np;\n\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != SYNTAX) {\n        print_error(\"Bad format for OBJECT-TYPE\", token, type);\n        return NULL;\n    }\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == OBJECT) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != IDENTIFIER) {\n            print_error(\"Expected IDENTIFIER\", token, type);\n            free_node(np);\n            return NULL;\n        }\n        type = OBJID;\n    }\n    if (type == LABEL) {\n        int             tmp_index;\n        tctype = get_tc(token, current_module, &tmp_index,\n                        &np->enums, &np->ranges, &np->hint);\n        if (tctype == LABEL &&\n            netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS) > 1) {\n            print_error(\"Warning: No known translation for type\", token,\n                        type);\n        }\n        type = tctype;\n        np->tc_index = tmp_index;       /* store TC for later reference */\n    }\n    np->type = type;\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    switch (type) {\n    case SEQUENCE:\n        if (nexttype == OF) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n\n        }\n        break;\n    case INTEGER:\n    case INTEGER32:\n    case UINTEGER32:\n    case UNSIGNED32:\n    case COUNTER:\n    case GAUGE:\n    case BITSTRING:\n    case LABEL:\n        if (nexttype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            np->enums = parse_enumlist(fp, &np->enums);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        } else if (nexttype == LEFTPAREN) {\n            /*\n             * if there is a range list, parse it \n             */\n            np->ranges = parse_ranges(fp, &np->ranges);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        break;\n    case OCTETSTR:\n    case KW_OPAQUE:\n        /*\n         * parse any SIZE specification \n         */\n        if (nexttype == LEFTPAREN) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            if (nexttype == SIZE) {\n                nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                if (nexttype == LEFTPAREN) {\n                    np->ranges = parse_ranges(fp, &np->ranges);\n                    nexttype = get_token(fp, nexttoken, MAXTOKEN);      /* ) */\n                    if (nexttype == RIGHTPAREN) {\n                        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                        break;\n                    }\n                }\n            }\n            print_error(\"Bad SIZE syntax\", token, type);\n            free_node(np);\n            return NULL;\n        }\n        break;\n    case OBJID:\n    case NETADDR:\n    case IPADDR:\n    case TIMETICKS:\n    case NUL:\n    case NSAPADDRESS:\n    case COUNTER64:\n        break;\n    default:\n        print_error(\"Bad syntax\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    if (nexttype == UNITS) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad UNITS\", quoted_string_buffer, type);\n            free_node(np);\n            return NULL;\n        }\n        np->units = strdup(quoted_string_buffer);\n        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    }\n    if (nexttype != ACCESS) {\n        print_error(\"Should be ACCESS\", nexttoken, nexttype);\n        free_node(np);\n        return NULL;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != READONLY && type != READWRITE && type != WRITEONLY\n        && type != NOACCESS && type != READCREATE && type != ACCNOTIFY) {\n        print_error(\"Bad ACCESS type\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->access = type;\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Should be STATUS\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != MANDATORY && type != CURRENT && type != KW_OPTIONAL &&\n        type != OBSOLETE && type != DEPRECATED) {\n        print_error(\"Bad STATUS\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->status = type;\n    /*\n     * Optional parts of the OBJECT-TYPE macro\n     */\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n\n        case REFERENCE:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case INDEX:\n            if (np->augments) {\n                print_error(\"Cannot have both INDEX and AUGMENTS\", token,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n            np->indexes = getIndexes(fp, &np->indexes);\n            if (np->indexes == NULL) {\n                print_error(\"Bad INDEX list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        case AUGMENTS:\n            if (np->indexes) {\n                print_error(\"Cannot have both INDEX and AUGMENTS\", token,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n            np->indexes = getIndexes(fp, &np->indexes);\n            if (np->indexes == NULL) {\n                print_error(\"Bad AUGMENTS list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            np->augments = strdup(np->indexes->ilabel);\n            free_indexes(&np->indexes);\n            break;\n        case DEFVAL:\n            /*\n             * Mark's defVal section \n             */\n            type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n            if (type != LEFTBRACKET) {\n                print_error(\"Bad DEFAULTVALUE\", quoted_string_buffer,\n                            type);\n                free_node(np);\n                return NULL;\n            }\n\n            {\n                int             level = 1;\n                char            defbuf[512];\n\n                defbuf[0] = 0;\n                while (1) {\n                    type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n                    if ((type == RIGHTBRACKET && --level == 0)\n                        || type == ENDOFFILE)\n                        break;\n                    else if (type == LEFTBRACKET)\n                        level++;\n                    if (type == QUOTESTRING)\n                        strlcat(defbuf, \"\\\\\\\"\", sizeof(defbuf));\n                    strlcat(defbuf, quoted_string_buffer, sizeof(defbuf));\n                    if (type == QUOTESTRING)\n                        strlcat(defbuf, \"\\\\\\\"\", sizeof(defbuf));\n                    strlcat(defbuf, \" \", sizeof(defbuf));\n                }\n\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Bad DEFAULTVALUE\", quoted_string_buffer,\n                                type);\n                    free_node(np);\n                    return NULL;\n                }\n\n                defbuf[strlen(defbuf) - 1] = 0;\n                np->defaultValue = strdup(defbuf);\n            }\n\n            break;\n\n        case NUM_ENTRIES:\n            if (tossObjectIdentifier(fp) != OBJID) {\n                print_error(\"Bad Object Identifier\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n\n        default:\n            print_error(\"Bad format of optional clauses\", token, type);\n            free_node(np);\n            return NULL;\n\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS) {\n        print_error(\"Bad format\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses an OBJECT GROUP macro.\n * Returns 0 on error.\n *\n * Also parses object-identity, since they are similar (ignore STATUS).\n *   - WJH 10/96\n */\nstatic struct node *\nparse_objectgroup(FILE * fp, char *name, int what, struct objgroup **ol)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == what) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LEFTBRACKET) {\n            print_error(\"Expected \\\"{\\\"\", token, type);\n            goto skip;\n        }\n        do {\n            struct objgroup *o;\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Bad identifier\", token, type);\n                goto skip;\n            }\n            o = (struct objgroup *) malloc(sizeof(struct objgroup));\n            if (!o) {\n                print_error(\"Resource failure\", token, type);\n                goto skip;\n            }\n            o->line = mibLine;\n            o->name = strdup(token);\n            o->next = *ol;\n            *ol = o;\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type == COMMA);\n        if (type != RIGHTBRACKET) {\n            print_error(\"Expected \\\"}\\\" after list\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, type);\n    }\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != DEPRECATED && type != OBSOLETE) {\n        print_error(\"Bad STATUS value\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        free_node(np);\n        return NULL;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            free_node(np);\n            return NULL;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE)\n        type = get_token(fp, token, MAXTOKEN);\n\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a NOTIFICATION-TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_notificationDefinition(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n        case REFERENCE:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case OBJECTS:\n            np->varbinds = getVarbinds(fp, &np->varbinds);\n            if (!np->varbinds) {\n                print_error(\"Bad OBJECTS list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        default:\n            /*\n             * NOTHING \n             */\n            break;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a TRAP-TYPE macro.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_trapDefinition(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != EQUALS && type != ENDOFFILE) {\n        switch (type) {\n        case DESCRIPTION:\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n                np->description = strdup(quoted_string_buffer);\n            }\n            break;\n        case REFERENCE:\n            /* I'm not sure REFERENCEs are legal in smiv1 traps??? */\n            type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n                free_node(np);\n                return NULL;\n            }\n            np->reference = strdup(quoted_string_buffer);\n            break;\n        case ENTERPRISE:\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == LEFTBRACKET) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad Trap Format\", token, type);\n                    free_node(np);\n                    return NULL;\n                }\n                np->parent = strdup(token);\n                /*\n                 * Get right bracket \n                 */\n                type = get_token(fp, token, MAXTOKEN);\n            } else if (type == LABEL) {\n                np->parent = strdup(token);\n            } else {\n                free_node(np);\n                return NULL;\n            }\n            break;\n        case VARIABLES:\n            np->varbinds = getVarbinds(fp, &np->varbinds);\n            if (!np->varbinds) {\n                print_error(\"Bad VARIABLES list\", token, type);\n                free_node(np);\n                return NULL;\n            }\n            break;\n        default:\n            /*\n             * NOTHING \n             */\n            break;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n\n    np->label = strdup(name);\n\n    if (type != NUMBER) {\n        print_error(\"Expected a Number\", token, type);\n        free_node(np);\n        return NULL;\n    }\n    np->subid = strtoul(token, NULL, 10);\n    np->next = alloc_node(current_module);\n    if (np->next == NULL) {\n        free_node(np);\n        return (NULL);\n    }\n\n    /* Catch the syntax error */\n    if (np->parent == NULL) {\n        free_node(np->next);\n        free_node(np);\n        gMibError = MODULE_SYNTAX_ERROR;\n        return (NULL);\n    }\n\n    np->next->parent = np->parent;\n    np->parent = (char *) malloc(strlen(np->parent) + 2);\n    if (np->parent == NULL) {\n        free_node(np->next);\n        free_node(np);\n        return (NULL);\n    }\n    strcpy(np->parent, np->next->parent);\n    strcat(np->parent, \"#\");\n    np->next->label = strdup(np->parent);\n    return np;\n}\n\n\n/*\n * Parses a compliance macro\n * Returns 0 on error.\n */\nstatic int\neat_syntax(FILE * fp, char *token, int maxtoken)\n{\n    int             type, nexttype;\n    struct node    *np = alloc_node(current_module);\n    char            nexttoken[MAXTOKEN];\n\n    if (!np)\n\treturn 0;\n\n    type = get_token(fp, token, maxtoken);\n    nexttype = get_token(fp, nexttoken, MAXTOKEN);\n    switch (type) {\n    case INTEGER:\n    case INTEGER32:\n    case UINTEGER32:\n    case UNSIGNED32:\n    case COUNTER:\n    case GAUGE:\n    case BITSTRING:\n    case LABEL:\n        if (nexttype == LEFTBRACKET) {\n            /*\n             * if there is an enumeration list, parse it \n             */\n            np->enums = parse_enumlist(fp, &np->enums);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        } else if (nexttype == LEFTPAREN) {\n            /*\n             * if there is a range list, parse it \n             */\n            np->ranges = parse_ranges(fp, &np->ranges);\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n        }\n        break;\n    case OCTETSTR:\n    case KW_OPAQUE:\n        /*\n         * parse any SIZE specification \n         */\n        if (nexttype == LEFTPAREN) {\n            nexttype = get_token(fp, nexttoken, MAXTOKEN);\n            if (nexttype == SIZE) {\n                nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                if (nexttype == LEFTPAREN) {\n                    np->ranges = parse_ranges(fp, &np->ranges);\n                    nexttype = get_token(fp, nexttoken, MAXTOKEN);      /* ) */\n                    if (nexttype == RIGHTPAREN) {\n                        nexttype = get_token(fp, nexttoken, MAXTOKEN);\n                        break;\n                    }\n                }\n            }\n            print_error(\"Bad SIZE syntax\", token, type);\n            free_node(np);\n            return nexttype;\n        }\n        break;\n    case OBJID:\n    case NETADDR:\n    case IPADDR:\n    case TIMETICKS:\n    case NUL:\n    case NSAPADDRESS:\n    case COUNTER64:\n        break;\n    default:\n        print_error(\"Bad syntax\", token, type);\n        free_node(np);\n        return nexttype;\n    }\n    free_node(np);\n    return nexttype;\n}\n\nstatic int\ncompliance_lookup(const char *name, int modid)\n{\n    if (modid == -1) {\n        struct objgroup *op =\n            (struct objgroup *) malloc(sizeof(struct objgroup));\n        if (!op)\n            return 0;\n        op->next = objgroups;\n        op->name = strdup(name);\n        op->line = mibLine;\n        objgroups = op;\n        return 1;\n    } else\n        return find_tree_node(name, modid) != NULL;\n}\n\nstatic struct node *\nparse_compliance(FILE * fp, char *name)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != DEPRECATED && type != OBSOLETE) {\n        print_error(\"Bad STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS))\n        np->description = strdup(quoted_string_buffer);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            goto skip;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != MODULE) {\n        print_error(\"Expected MODULE\", token, type);\n        goto skip;\n    }\n    while (type == MODULE) {\n        int             modid = -1;\n        char            modname[MAXTOKEN];\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == LABEL\n            && strcmp(token, module_name(current_module, modname))) {\n            modid = read_module_internal(token);\n            if (modid != MODULE_LOADED_OK\n                && modid != MODULE_ALREADY_LOADED) {\n                print_error(\"Unknown module\", token, type);\n                goto skip;\n            }\n            modid = which_module(token);\n            type = get_token(fp, token, MAXTOKEN);\n        }\n        if (type == MANDATORYGROUPS) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LEFTBRACKET) {\n                print_error(\"Expected \\\"{\\\"\", token, type);\n                goto skip;\n            }\n            do {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad group name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n            } while (type == COMMA);\n            if (type != RIGHTBRACKET) {\n                print_error(\"Expected \\\"}\\\"\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n        while (type == GROUP || type == OBJECT) {\n            if (type == GROUP) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad group name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n            } else {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LABEL) {\n                    print_error(\"Bad object name\", token, type);\n                    goto skip;\n                }\n                if (!compliance_lookup(token, modid))\n                    print_error(\"Unknown group\", token, type);\n                type = get_token(fp, token, MAXTOKEN);\n                if (type == SYNTAX)\n                    type = eat_syntax(fp, token, MAXTOKEN);\n                if (type == WRSYNTAX)\n                    type = eat_syntax(fp, token, MAXTOKEN);\n                if (type == MINACCESS) {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != NOACCESS && type != ACCNOTIFY\n                        && type != READONLY && type != WRITEONLY\n                        && type != READCREATE && type != READWRITE) {\n                        print_error(\"Bad MIN-ACCESS spec\", token, type);\n                        goto skip;\n                    }\n                    type = get_token(fp, token, MAXTOKEN);\n                }\n            }\n            if (type != DESCRIPTION) {\n                print_error(\"Expected DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n    }\n  skip:\n    while (type != EQUALS && type != ENDOFFILE)\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n\n    return merge_parse_objectid(np, fp, name);\n}\n\n\n/*\n * Parses a capabilities macro\n * Returns 0 on error.\n */\nstatic struct node *\nparse_capabilities(FILE * fp, char *name)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    struct node    *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != PRODREL) {\n        print_error(\"Expected PRODUCT-RELEASE\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Expected STRING after PRODUCT-RELEASE\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != STATUS) {\n        print_error(\"Expected STATUS\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CURRENT && type != OBSOLETE) {\n        print_error(\"STATUS should be current or obsolete\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type == REFERENCE) {\n        type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REFERENCE\", quoted_string_buffer, type);\n            goto skip;\n        }\n        np->reference = strdup(quoted_string_buffer);\n        type = get_token(fp, token, type);\n    }\n    while (type == SUPPORTS) {\n        int             modid;\n        struct tree    *tp;\n\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LABEL) {\n            print_error(\"Bad module name\", token, type);\n            goto skip;\n        }\n        modid = read_module_internal(token);\n        if (modid != MODULE_LOADED_OK && modid != MODULE_ALREADY_LOADED) {\n            print_error(\"Module not found\", token, type);\n            goto skip;\n        }\n        modid = which_module(token);\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != INCLUDES) {\n            print_error(\"Expected INCLUDES\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != LEFTBRACKET) {\n            print_error(\"Expected \\\"{\\\"\", token, type);\n            goto skip;\n        }\n        do {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Expected group name\", token, type);\n                goto skip;\n            }\n            tp = find_tree_node(token, modid);\n            if (!tp)\n                print_error(\"Group not found in module\", token, type);\n            type = get_token(fp, token, MAXTOKEN);\n        } while (type == COMMA);\n        if (type != RIGHTBRACKET) {\n            print_error(\"Expected \\\"}\\\" after group list\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n        while (type == VARIATION) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != LABEL) {\n                print_error(\"Bad object name\", token, type);\n                goto skip;\n            }\n            tp = find_tree_node(token, modid);\n            if (!tp)\n                print_error(\"Object not found in module\", token, type);\n            type = get_token(fp, token, MAXTOKEN);\n            if (type == SYNTAX) {\n                type = eat_syntax(fp, token, MAXTOKEN);\n            }\n            if (type == WRSYNTAX) {\n                type = eat_syntax(fp, token, MAXTOKEN);\n            }\n            if (type == ACCESS) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != ACCNOTIFY && type != READONLY\n                    && type != READWRITE && type != READCREATE\n                    && type != WRITEONLY && type != NOTIMPL) {\n                    print_error(\"Bad ACCESS\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type == CREATEREQ) {\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LEFTBRACKET) {\n                    print_error(\"Expected \\\"{\\\"\", token, type);\n                    goto skip;\n                }\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type != LABEL) {\n                        print_error(\"Bad object name in list\", token,\n                                    type);\n                        goto skip;\n                    }\n                    type = get_token(fp, token, MAXTOKEN);\n                } while (type == COMMA);\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Expected \\\"}\\\" after list\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type == DEFVAL) {\n                int             level = 1;\n                type = get_token(fp, token, MAXTOKEN);\n                if (type != LEFTBRACKET) {\n                    print_error(\"Expected \\\"{\\\" after DEFVAL\", token,\n                                type);\n                    goto skip;\n                }\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                    if (type == LEFTBRACKET)\n                        level++;\n                    else if (type == RIGHTBRACKET)\n                        level--;\n                } while ((type != RIGHTBRACKET || level != 0)\n                         && type != ENDOFFILE);\n                if (type != RIGHTBRACKET) {\n                    print_error(\"Missing \\\"}\\\" after DEFVAL\", token, type);\n                    goto skip;\n                }\n                type = get_token(fp, token, MAXTOKEN);\n            }\n            if (type != DESCRIPTION) {\n                print_error(\"Expected DESCRIPTION\", token, type);\n                goto skip;\n            }\n            type = get_token(fp, quoted_string_buffer, MAXTOKEN);\n            if (type != QUOTESTRING) {\n                print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n                goto skip;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n/*\n * Parses a module identity macro\n * Returns 0 on error.\n */\nstatic void\ncheck_utc(const char *utc)\n{\n    int             len, year, month, day, hour, minute;\n\n    len = strlen(utc);\n    if (utc[len - 1] != 'Z' && utc[len - 1] != 'z') {\n        print_error(\"Timestamp should end with Z\", utc, QUOTESTRING);\n        return;\n    }\n    if (len == 11) {\n        len =\n            sscanf(utc, \"%2d%2d%2d%2d%2dZ\", &year, &month, &day, &hour,\n                   &minute);\n        year += 1900;\n    } else if (len == 13)\n        len =\n            sscanf(utc, \"%4d%2d%2d%2d%2dZ\", &year, &month, &day, &hour,\n                   &minute);\n    else {\n        print_error(\"Bad timestamp format (11 or 13 characters)\",\n                    utc, QUOTESTRING);\n        return;\n    }\n    if (len != 5) {\n        print_error(\"Bad timestamp format\", utc, QUOTESTRING);\n        return;\n    }\n    if (month < 1 || month > 12)\n        print_error(\"Bad month in timestamp\", utc, QUOTESTRING);\n    if (day < 1 || day > 31)\n        print_error(\"Bad day in timestamp\", utc, QUOTESTRING);\n    if (hour < 0 || hour > 23)\n        print_error(\"Bad hour in timestamp\", utc, QUOTESTRING);\n    if (minute < 0 || minute > 59)\n        print_error(\"Bad minute in timestamp\", utc, QUOTESTRING);\n}\n\nstatic struct node *\nparse_moduleIdentity(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            quoted_string_buffer[MAXQUOTESTR];\n    register struct node *np;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != LASTUPDATED) {\n        print_error(\"Expected LAST-UPDATED\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Need STRING for LAST-UPDATED\", token, type);\n        goto skip;\n    }\n    check_utc(token);\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != ORGANIZATION) {\n        print_error(\"Expected ORGANIZATION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad ORGANIZATION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != CONTACTINFO) {\n        print_error(\"Expected CONTACT-INFO\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad CONTACT-INFO\", quoted_string_buffer, type);\n        goto skip;\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    if (type != DESCRIPTION) {\n        print_error(\"Expected DESCRIPTION\", token, type);\n        goto skip;\n    }\n    type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    if (type != QUOTESTRING) {\n        print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n        goto skip;\n    }\n    if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t       NETSNMP_DS_LIB_SAVE_MIB_DESCRS)) {\n        np->description = strdup(quoted_string_buffer);\n    }\n    type = get_token(fp, token, MAXTOKEN);\n    while (type == REVISION) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad REVISION\", token, type);\n            goto skip;\n        }\n        check_utc(token);\n        type = get_token(fp, token, MAXTOKEN);\n        if (type != DESCRIPTION) {\n            print_error(\"Expected DESCRIPTION\", token, type);\n            goto skip;\n        }\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n        if (type != QUOTESTRING) {\n            print_error(\"Bad DESCRIPTION\", quoted_string_buffer, type);\n            goto skip;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n    if (type != EQUALS)\n        print_error(\"Expected \\\"::=\\\"\", token, type);\n  skip:\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, quoted_string_buffer, MAXQUOTESTR);\n    }\n    return merge_parse_objectid(np, fp, name);\n}\n\n\n/*\n * Parses a MACRO definition\n * Expect BEGIN, discard everything to end.\n * Returns 0 on error.\n */\nstatic struct node *\nparse_macro(FILE * fp, char *name)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    struct node    *np;\n    int             iLine = mibLine;\n\n    np = alloc_node(current_module);\n    if (np == NULL)\n        return (NULL);\n    type = get_token(fp, token, sizeof(token));\n    while (type != EQUALS && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != EQUALS) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n    while (type != BEGIN && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != BEGIN) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n    while (type != END && type != ENDOFFILE) {\n        type = get_token(fp, token, sizeof(token));\n    }\n    if (type != END) {\n        if (np)\n            free_node(np);\n        return NULL;\n    }\n\n    if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n        snmp_log(LOG_WARNING,\n                 \"%s MACRO (lines %d..%d parsed and ignored).\\n\", name,\n                 iLine, mibLine);\n    }\n\n    return np;\n}\n\n/*\n * Parses a module import clause\n *   loading any modules referenced\n */\nstatic void\nparse_imports(FILE * fp)\n{\n    register int    type;\n    char            token[MAXTOKEN];\n    char            modbuf[256];\n#define MAX_IMPORTS\t256\n    struct module_import import_list[MAX_IMPORTS];\n    int             this_module;\n    struct module  *mp;\n\n    int             import_count = 0;   /* Total number of imported descriptors */\n    int             i = 0, old_i;       /* index of first import from each module */\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    /*\n     * Parse the IMPORTS clause\n     */\n    while (type != SEMI && type != ENDOFFILE) {\n        if (type == LABEL) {\n            if (import_count == MAX_IMPORTS) {\n                print_error(\"Too many imported symbols\", token, type);\n                do {\n                    type = get_token(fp, token, MAXTOKEN);\n                } while (type != SEMI && type != ENDOFFILE);\n                return;\n            }\n            import_list[import_count++].label = strdup(token);\n        } else if (type == FROM) {\n            type = get_token(fp, token, MAXTOKEN);\n            if (import_count == i) {    /* All imports are handled internally */\n                type = get_token(fp, token, MAXTOKEN);\n                continue;\n            }\n            this_module = which_module(token);\n\n            for (old_i = i; i < import_count; ++i)\n                import_list[i].modid = this_module;\n\n            /*\n             * Recursively read any pre-requisite modules\n             */\n            if (read_module_internal(token) == MODULE_NOT_FOUND) {\n\t\tint found = 0;\n                for (; old_i < import_count; ++old_i) {\n                    found += read_import_replacements(token, &import_list[old_i]);\n                }\n\t\tif (!found)\n\t\t    print_module_not_found(token);\n            }\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    /* Initialize modid in case the module name was missing. */\n    for (; i < import_count; ++i)\n        import_list[i].modid = -1;\n\n    /*\n     * Save the import information\n     *   in the global module table\n     */\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == current_module) {\n            if (import_count == 0)\n                return;\n            if (mp->imports && (mp->imports != root_imports)) {\n                /*\n                 * this can happen if all modules are in one source file. \n                 */\n                for (i = 0; i < mp->no_imports; ++i) {\n                    DEBUGMSGTL((\"parse-mibs\",\n                                \"#### freeing Module %d '%s' %d\\n\",\n                                mp->modid, mp->imports[i].label,\n                                mp->imports[i].modid));\n                    free((char *) mp->imports[i].label);\n                }\n                free((char *) mp->imports);\n            }\n            mp->imports = (struct module_import *)\n                calloc(import_count, sizeof(struct module_import));\n            if (mp->imports == NULL)\n                return;\n            for (i = 0; i < import_count; ++i) {\n                mp->imports[i].label = import_list[i].label;\n                mp->imports[i].modid = import_list[i].modid;\n                DEBUGMSGTL((\"parse-mibs\",\n                            \"#### adding Module %d '%s' %d\\n\", mp->modid,\n                            mp->imports[i].label, mp->imports[i].modid));\n            }\n            mp->no_imports = import_count;\n            return;\n        }\n\n    /*\n     * Shouldn't get this far\n     */\n    print_module_not_found(module_name(current_module, modbuf));\n    return;\n}\n\n\n\n/*\n * MIB module handling routines\n */\n\nstatic void\ndump_module_list(void)\n{\n    struct module  *mp = module_head;\n\n    DEBUGMSGTL((\"parse-mibs\", \"Module list:\\n\"));\n    while (mp) {\n        DEBUGMSGTL((\"parse-mibs\", \"  %s %d %s %d\\n\", mp->name, mp->modid,\n                    mp->file, mp->no_imports));\n        mp = mp->next;\n    }\n}\n\nint\nwhich_module(const char *name)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name))\n            return (mp->modid);\n\n    DEBUGMSGTL((\"parse-mibs\", \"Module %s not found\\n\", name));\n    return (-1);\n}\n\n/*\n * module_name - copy module name to user buffer, return ptr to same.\n */\nchar           *\nmodule_name(int modid, char *cp)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->modid == modid) {\n            strcpy(cp, mp->name);\n            return (cp);\n        }\n\n    if (modid != -1) DEBUGMSGTL((\"parse-mibs\", \"Module %d not found\\n\", modid));\n    sprintf(cp, \"#%d\", modid);\n    return (cp);\n}\n\n/*\n *  Backwards compatability\n *  Read newer modules that replace the one specified:-\n *      either all of them (read_module_replacements),\n *      or those relating to a specified identifier (read_import_replacements)\n *      plus an interface to add new replacement requirements\n */\nnetsnmp_feature_child_of(parse_add_module_replacement, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_ADD_MODULE_REPLACEMENT\nvoid\nadd_module_replacement(const char *old_module,\n                       const char *new_module_name,\n                       const char *tag, int len)\n{\n    struct module_compatability *mcp;\n\n    mcp = (struct module_compatability *)\n        calloc(1, sizeof(struct module_compatability));\n    if (mcp == NULL)\n        return;\n\n    mcp->old_module = strdup(old_module);\n    mcp->new_module = strdup(new_module_name);\n    if (tag)\n        mcp->tag = strdup(tag);\n    mcp->tag_len = len;\n\n    mcp->next = module_map_head;\n    module_map_head = mcp;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_ADD_MODULE_REPLACEMENT */\n\nstatic int\nread_module_replacements(const char *name)\n{\n    struct module_compatability *mcp;\n\n    for (mcp = module_map_head; mcp; mcp = mcp->next) {\n        if (!label_compare(mcp->old_module, name)) {\n            if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                snmp_log(LOG_WARNING,\n                         \"Loading replacement module %s for %s (%s)\\n\",\n                         mcp->new_module, name, File);\n\t    }\n            (void) netsnmp_read_module(mcp->new_module);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nstatic int\nread_import_replacements(const char *old_module_name,\n                         struct module_import *identifier)\n{\n    struct module_compatability *mcp;\n\n    /*\n     * Look for matches first\n     */\n    for (mcp = module_map_head; mcp; mcp = mcp->next) {\n        if (!label_compare(mcp->old_module, old_module_name)) {\n\n            if (                /* exact match */\n                   (mcp->tag_len == 0 &&\n                    (mcp->tag == NULL ||\n                     !label_compare(mcp->tag, identifier->label))) ||\n                   /*\n                    * prefix match \n                    */\n                   (mcp->tag_len != 0 &&\n                    !strncmp(mcp->tag, identifier->label, mcp->tag_len))\n                ) {\n\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Importing %s from replacement module %s instead of %s (%s)\\n\",\n                             identifier->label, mcp->new_module,\n                             old_module_name, File);\n\t\t}\n                (void) netsnmp_read_module(mcp->new_module);\n                identifier->modid = which_module(mcp->new_module);\n                return 1;         /* finished! */\n            }\n        }\n    }\n\n    /*\n     * If no exact match, load everything relevant\n     */\n    return read_module_replacements(old_module_name);\n}\n\n\n/*\n *  Read in the named module\n *      Returns the root of the whole tree\n *      (by analogy with 'read_mib')\n */\nstatic int\nread_module_internal(const char *name)\n{\n    struct module  *mp;\n    FILE           *fp;\n    struct node    *np;\n\n    netsnmp_init_mib_internals();\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            const char     *oldFile = File;\n            int             oldLine = mibLine;\n            int             oldModule = current_module;\n\n            if (mp->no_imports != -1) {\n                DEBUGMSGTL((\"parse-mibs\", \"Module %s already loaded\\n\",\n                            name));\n                return MODULE_ALREADY_LOADED;\n            }\n            if ((fp = fopen(mp->file, \"r\")) == NULL) {\n                int rval;\n                if (errno == ENOTDIR || errno == ENOENT)\n                    rval = MODULE_NOT_FOUND;\n                else\n                    rval = MODULE_LOAD_FAILED;\n                snmp_log_perror(mp->file);\n                return rval;\n            }\n#ifdef HAVE_FLOCKFILE\n            flockfile(fp);\n#endif\n            mp->no_imports = 0; /* Note that we've read the file */\n            File = mp->file;\n            mibLine = 1;\n            current_module = mp->modid;\n            /*\n             * Parse the file\n             */\n            np = parse(fp, NULL);\n#ifdef HAVE_FUNLOCKFILE\n            funlockfile(fp);\n#endif\n            fclose(fp);\n            File = oldFile;\n            mibLine = oldLine;\n            current_module = oldModule;\n            if ((np == NULL) && (gMibError == MODULE_SYNTAX_ERROR) )\n                return MODULE_SYNTAX_ERROR;\n            return MODULE_LOADED_OK;\n        }\n\n    return MODULE_NOT_FOUND;\n}\n\nvoid\nadopt_orphans(void)\n{\n    struct node    *np, *onp;\n    struct tree    *tp;\n    int             i, adopted = 1;\n\n    if (!orphan_nodes)\n        return;\n    init_node_hash(orphan_nodes);\n    orphan_nodes = NULL;\n\n    while (adopted) {\n        adopted = 0;\n        for (i = 0; i < NHASHSIZE; i++)\n            if (nbuckets[i]) {\n                for (np = nbuckets[i]; np != NULL; np = np->next) {\n                    tp = find_tree_node(np->parent, -1);\n\t\t    if (tp) {\n\t\t\tdo_subtree(tp, &np);\n\t\t\tadopted = 1;\n                        /*\n                         * if do_subtree adopted the entire bucket, stop\n                         */\n                        if(NULL == nbuckets[i])\n                            break;\n\n                        /*\n                         * do_subtree may modify nbuckets, and if np\n                         * was adopted, np->next probably isn't an orphan\n                         * anymore. if np is still in the bucket (do_subtree\n                         * didn't adopt it) keep on plugging. otherwise\n                         * start over, at the top of the bucket.\n                         */\n                        for(onp = nbuckets[i]; onp; onp = onp->next)\n                            if(onp == np)\n                                break;\n                        if(NULL == onp) { /* not in the list */\n                            np = nbuckets[i]; /* start over */\n                        }\n\t\t    }\n\t\t}\n            }\n    }\n\n    /*\n     * Report on outstanding orphans\n     *    and link them back into the orphan list\n     */\n    for (i = 0; i < NHASHSIZE; i++)\n        if (nbuckets[i]) {\n            if (orphan_nodes)\n                onp = np->next = nbuckets[i];\n            else\n                onp = orphan_nodes = nbuckets[i];\n            nbuckets[i] = NULL;\n            while (onp) {\n                char            modbuf[256];\n                snmp_log(LOG_WARNING,\n                         \"Cannot adopt OID in %s: %s ::= { %s %ld }\\n\",\n                         module_name(onp->modid, modbuf),\n                         (onp->label ? onp->label : \"<no label>\"),\n                         (onp->parent ? onp->parent : \"<no parent>\"),\n                         onp->subid);\n\n                np = onp;\n                onp = onp->next;\n            }\n        }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nstruct tree    *\nread_module(const char *name)\n{\n    return netsnmp_read_module(name);\n}\n#endif\n\nstruct tree    *\nnetsnmp_read_module(const char *name)\n{\n    int status = 0;\n    status = read_module_internal(name);\n\n    if (status == MODULE_NOT_FOUND) {\n        if (!read_module_replacements(name))\n            print_module_not_found(name);\n    } else if (status == MODULE_SYNTAX_ERROR) {\n        gMibError = 0;\n        gLoop = 1;\n\n        strncat(gMibNames, \" \", sizeof(gMibNames) - strlen(gMibNames) - 1);\n        strncat(gMibNames, name, sizeof(gMibNames) - strlen(gMibNames) - 1);\n    }\n\n    return tree_head;\n}\n\n/*\n * Prototype definition \n */\nvoid            unload_module_by_ID(int modID, struct tree *tree_top);\n\nvoid\nunload_module_by_ID(int modID, struct tree *tree_top)\n{\n    struct tree    *tp, *next;\n    int             i;\n\n    for (tp = tree_top; tp; tp = next) {\n        /*\n         * Essentially, this is equivalent to the code fragment:\n         *      if (tp->modID == modID)\n         *        tp->number_modules--;\n         * but handles one tree node being part of several modules,\n         * and possible multiple copies of the same module ID.\n         */\n        int             nmod = tp->number_modules;\n        if (nmod > 0) {         /* in some module */\n            /*\n             * Remove all copies of this module ID\n             */\n            int             cnt = 0, *pi1, *pi2 = tp->module_list;\n            for (i = 0, pi1 = pi2; i < nmod; i++, pi2++) {\n                if (*pi2 == modID)\n                    continue;\n                cnt++;\n                *pi1++ = *pi2;\n            }\n            if (nmod != cnt) {  /* in this module */\n                /*\n                 * if ( (nmod - cnt) > 1)\n                 * printf(\"Dup modid %d,  %d times, '%s'\\n\", tp->modid, (nmod-cnt), tp->label); fflush(stdout); ?* XXDEBUG \n                 */\n                tp->number_modules = cnt;\n                switch (cnt) {\n                case 0:\n                    tp->module_list[0] = -1;    /* Mark unused, */\n\t\t    /* FALL THROUGH */\n\n                case 1:        /* save the remaining module */\n                    if (&(tp->modid) != tp->module_list) {\n                        tp->modid = tp->module_list[0];\n                        free(tp->module_list);\n                        tp->module_list = &(tp->modid);\n                    }\n                    break;\n\n                default:\n                    break;\n                }\n            }                   /* if tree node is in this module */\n        }\n        /*\n         * if tree node is in some module \n         */\n        next = tp->next_peer;\n\n\n        /*\n         *  OK - that's dealt with *this* node.\n         *    Now let's look at the children.\n         *    (Isn't recursion wonderful!)\n         */\n        if (tp->child_list)\n            unload_module_by_ID(modID, tp->child_list);\n\n\n        if (tp->number_modules == 0) {\n            /*\n             * This node isn't needed any more (except perhaps\n             * for the sake of the children) \n             */\n            if (tp->child_list == NULL) {\n                unlink_tree(tp);\n                free_tree(tp);\n            } else {\n                free_partial_tree(tp, TRUE);\n            }\n        }\n    }\n}\n\n#ifndef NETSNMP_NO_LEGACY_DEFINITIONS\nint\nunload_module(const char *name)\n{\n    return netsnmp_unload_module(name);\n}\n#endif\n\nint\nnetsnmp_unload_module(const char *name)\n{\n    struct module  *mp;\n    int             modID = -1;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            modID = mp->modid;\n            break;\n        }\n\n    if (modID == -1) {\n        DEBUGMSGTL((\"unload-mib\", \"Module %s not found to unload\\n\",\n                    name));\n        return MODULE_NOT_FOUND;\n    }\n    unload_module_by_ID(modID, tree_head);\n    mp->no_imports = -1;        /* mark as unloaded */\n    return MODULE_LOADED_OK;    /* Well, you know what I mean! */\n}\n\n/*\n * Clear module map, tree nodes, textual convention table.\n */\nvoid\nunload_all_mibs(void)\n{\n    struct module  *mp;\n    struct module_compatability *mcp;\n    struct tc      *ptc;\n    unsigned int    i;\n\n    for (mcp = module_map_head; mcp; mcp = module_map_head) {\n        if (mcp == module_map)\n            break;\n        module_map_head = mcp->next;\n        if (mcp->tag) free(NETSNMP_REMOVE_CONST(char *, mcp->tag));\n        free(NETSNMP_REMOVE_CONST(char *, mcp->old_module));\n        free(NETSNMP_REMOVE_CONST(char *, mcp->new_module));\n        free(mcp);\n    }\n\n    for (mp = module_head; mp; mp = module_head) {\n        struct module_import *mi = mp->imports;\n        if (mi) {\n            for (i = 0; i < (unsigned int)mp->no_imports; ++i) {\n                SNMP_FREE((mi + i)->label);\n            }\n            mp->no_imports = 0;\n            if (mi == root_imports)\n                memset(mi, 0, sizeof(*mi));\n            else\n                free(mi);\n        }\n\n        unload_module_by_ID(mp->modid, tree_head);\n        module_head = mp->next;\n        free(mp->name);\n        free(mp->file);\n        free(mp);\n    }\n    unload_module_by_ID(-1, tree_head);\n    /*\n     * tree nodes are cleared \n     */\n\n    for (i = 0, ptc = tclist; i < MAXTC; i++, ptc++) {\n        if (ptc->type == 0)\n            continue;\n        free_enums(&ptc->enums);\n        free_ranges(&ptc->ranges);\n        free(ptc->descriptor);\n        if (ptc->hint)\n            free(ptc->hint);\n        if (ptc->description)\n            free(ptc->description);\n    }\n    memset(tclist, 0, MAXTC * sizeof(struct tc));\n\n    memset(buckets, 0, sizeof(buckets));\n    memset(nbuckets, 0, sizeof(nbuckets));\n    memset(tbuckets, 0, sizeof(tbuckets));\n\n    for (i = 0; i < sizeof(root_imports) / sizeof(root_imports[0]); i++) {\n        SNMP_FREE(root_imports[i].label);\n    }\n\n    max_module = 0;\n    current_module = 0;\n    module_map_head = NULL;\n    SNMP_FREE(last_err_module);\n}\n\nstatic void\nnew_module(const char *name, const char *file)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            DEBUGMSGTL((\"parse-mibs\", \"  Module %s already noted\\n\", name));\n            /*\n             * Not the same file \n             */\n            if (label_compare(mp->file, file)) {\n                DEBUGMSGTL((\"parse-mibs\", \"    %s is now in %s\\n\",\n                            name, file));\n                if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                    snmp_log(LOG_WARNING,\n                             \"Warning: Module %s was in %s now is %s\\n\",\n                             name, mp->file, file);\n\t\t}\n\n                /*\n                 * Use the new one in preference \n                 */\n                free(mp->file);\n                mp->file = strdup(file);\n            }\n            return;\n        }\n\n    /*\n     * Add this module to the list \n     */\n    DEBUGMSGTL((\"parse-mibs\", \"  Module %d %s is in %s\\n\", max_module,\n                name, file));\n    mp = (struct module *) calloc(1, sizeof(struct module));\n    if (mp == NULL)\n        return;\n    mp->name = strdup(name);\n    mp->file = strdup(file);\n    mp->imports = NULL;\n    mp->no_imports = -1;        /* Not yet loaded */\n    mp->modid = max_module;\n    ++max_module;\n\n    mp->next = module_head;     /* Or add to the *end* of the list? */\n    module_head = mp;\n}\n\n\nstatic void\nscan_objlist(struct node *root, struct module *mp, struct objgroup *list, const char *error)\n{\n    int             oLine = mibLine;\n\n    while (list) {\n        struct objgroup *gp = list;\n        struct node    *np;\n        list = list->next;\n        np = root;\n        while (np)\n            if (label_compare(np->label, gp->name))\n                np = np->next;\n            else\n                break;\n        if (!np) {\n\t    int i;\n\t    struct module_import *mip;\n\t    /* if not local, check if it was IMPORTed */\n\t    for (i = 0, mip = mp->imports; i < mp->no_imports; i++, mip++)\n\t\tif (strcmp(mip->label, gp->name) == 0)\n\t\t    break;\n\t    if (i == mp->no_imports) {\n\t\tmibLine = gp->line;\n\t\tprint_error(error, gp->name, QUOTESTRING);\n\t    }\n        }\n        free(gp->name);\n        free(gp);\n    }\n    mibLine = oLine;\n}\n\n/*\n * Parses a mib file and returns a linked list of nodes found in the file.\n * Returns NULL on error.\n */\nstatic struct node *\nparse(FILE * fp, struct node *root)\n{\n#ifdef TEST\n    extern void     xmalloc_stats(FILE *);\n#endif\n    char            token[MAXTOKEN];\n    char            name[MAXTOKEN+1];\n    int             type = LABEL;\n    int             lasttype = LABEL;\n\n#define BETWEEN_MIBS          1\n#define IN_MIB                2\n    int             state = BETWEEN_MIBS;\n    struct node    *np, *nnp;\n    struct objgroup *oldgroups = NULL, *oldobjects = NULL, *oldnotifs =\n        NULL;\n\n    DEBUGMSGTL((\"parse-file\", \"Parsing file:  %s...\\n\", File));\n\n    if (last_err_module)\n        free(last_err_module);\n    last_err_module = NULL;\n\n    np = root;\n    if (np != NULL) {\n        /*\n         * now find end of chain \n         */\n        while (np->next)\n            np = np->next;\n    }\n\n    while (type != ENDOFFILE) {\n        if (lasttype == CONTINUE)\n            lasttype = type;\n        else\n            type = lasttype = get_token(fp, token, MAXTOKEN);\n\n        switch (type) {\n        case END:\n            if (state != IN_MIB) {\n                print_error(\"Error, END before start of MIB\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            } else {\n                struct module  *mp;\n#ifdef TEST\n                printf(\"\\nNodes for Module %s:\\n\", name);\n                print_nodes(stdout, root);\n#endif\n                for (mp = module_head; mp; mp = mp->next)\n                    if (mp->modid == current_module)\n                        break;\n                scan_objlist(root, mp, objgroups, \"Undefined OBJECT-GROUP\");\n                scan_objlist(root, mp, objects, \"Undefined OBJECT\");\n                scan_objlist(root, mp, notifs, \"Undefined NOTIFICATION\");\n                objgroups = oldgroups;\n                objects = oldobjects;\n                notifs = oldnotifs;\n                do_linkup(mp, root);\n                np = root = NULL;\n            }\n            state = BETWEEN_MIBS;\n#ifdef TEST\n            if (netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS)) {\n                /* xmalloc_stats(stderr); */\n\t    }\n#endif\n            continue;\n        case IMPORTS:\n            parse_imports(fp);\n            continue;\n        case EXPORTS:\n            while (type != SEMI && type != ENDOFFILE)\n                type = get_token(fp, token, MAXTOKEN);\n            continue;\n        case LABEL:\n        case INTEGER:\n        case INTEGER32:\n        case UINTEGER32:\n        case UNSIGNED32:\n        case COUNTER:\n        case COUNTER64:\n        case GAUGE:\n        case IPADDR:\n        case NETADDR:\n        case NSAPADDRESS:\n        case OBJSYNTAX:\n        case APPSYNTAX:\n        case SIMPLESYNTAX:\n        case OBJNAME:\n        case NOTIFNAME:\n        case KW_OPAQUE:\n        case TIMETICKS:\n            break;\n        case ENDOFFILE:\n            continue;\n        default:\n            strlcpy(name, token, sizeof(name));\n            type = get_token(fp, token, MAXTOKEN);\n            nnp = NULL;\n            if (type == MACRO) {\n                nnp = parse_macro(fp, name);\n                if (nnp == NULL) {\n                    print_error(\"Bad parse of MACRO\", NULL, type);\n                    gMibError = MODULE_SYNTAX_ERROR;\n                    /*\n                     * return NULL;\n                     */\n                }\n                free_node(nnp); /* IGNORE */\n                nnp = NULL;\n            } else\n                print_error(name, \"is a reserved word\", lasttype);\n            continue;           /* see if we can parse the rest of the file */\n        }\n        strlcpy(name, token, sizeof(name));\n        type = get_token(fp, token, MAXTOKEN);\n        nnp = NULL;\n\n        /*\n         * Handle obsolete method to assign an object identifier to a\n         * module\n         */\n        if (lasttype == LABEL && type == LEFTBRACKET) {\n            while (type != RIGHTBRACKET && type != ENDOFFILE)\n                type = get_token(fp, token, MAXTOKEN);\n            if (type == ENDOFFILE) {\n                print_error(\"Expected \\\"}\\\"\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n        }\n\n        switch (type) {\n        case DEFINITIONS:\n            if (state != BETWEEN_MIBS) {\n                print_error(\"Error, nested MIBS\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            state = IN_MIB;\n            current_module = which_module(name);\n            oldgroups = objgroups;\n            objgroups = NULL;\n            oldobjects = objects;\n            objects = NULL;\n            oldnotifs = notifs;\n            notifs = NULL;\n            if (current_module == -1) {\n                new_module(name, File);\n                current_module = which_module(name);\n            }\n            DEBUGMSGTL((\"parse-mibs\", \"Parsing MIB: %d %s\\n\",\n                        current_module, name));\n            while ((type = get_token(fp, token, MAXTOKEN)) != ENDOFFILE)\n                if (type == BEGIN)\n                    break;\n            break;\n        case OBJTYPE:\n            nnp = parse_objecttype(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJGROUP:\n            nnp = parse_objectgroup(fp, name, OBJECTS, &objects);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-GROUP\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case NOTIFGROUP:\n            nnp = parse_objectgroup(fp, name, NOTIFICATIONS, &notifs);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of NOTIFICATION-GROUP\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case TRAPTYPE:\n            nnp = parse_trapDefinition(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of TRAP-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case NOTIFTYPE:\n            nnp = parse_notificationDefinition(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of NOTIFICATION-TYPE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case COMPLIANCE:\n            nnp = parse_compliance(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MODULE-COMPLIANCE\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case AGENTCAP:\n            nnp = parse_capabilities(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of AGENT-CAPABILITIES\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case MACRO:\n            nnp = parse_macro(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MACRO\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                /*\n                 * return NULL;\n                 */\n            }\n            free_node(nnp);     /* IGNORE */\n            nnp = NULL;\n            break;\n        case MODULEIDENTITY:\n            nnp = parse_moduleIdentity(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of MODULE-IDENTITY\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJIDENTITY:\n            nnp = parse_objectgroup(fp, name, OBJECTS, &objects);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT-IDENTITY\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case OBJECT:\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != IDENTIFIER) {\n                print_error(\"Expected IDENTIFIER\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            type = get_token(fp, token, MAXTOKEN);\n            if (type != EQUALS) {\n                print_error(\"Expected \\\"::=\\\"\", token, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            nnp = parse_objectid(fp, name);\n            if (nnp == NULL) {\n                print_error(\"Bad parse of OBJECT IDENTIFIER\", NULL, type);\n                gMibError = MODULE_SYNTAX_ERROR;\n                return NULL;\n            }\n            break;\n        case EQUALS:\n            nnp = parse_asntype(fp, name, &type, token);\n            lasttype = CONTINUE;\n            break;\n        case ENDOFFILE:\n            break;\n        default:\n            print_error(\"Bad operator\", token, type);\n            gMibError = MODULE_SYNTAX_ERROR;\n            return NULL;\n        }\n        if (nnp) {\n            if (np)\n                np->next = nnp;\n            else\n                np = root = nnp;\n            while (np->next)\n                np = np->next;\n            if (np->type == TYPE_OTHER)\n                np->type = type;\n        }\n    }\n    DEBUGMSGTL((\"parse-file\", \"End of file (%s)\\n\", File));\n    return root;\n}\n\n/*\n * return zero if character is not a label character. \n */\nstatic int\nis_labelchar(int ich)\n{\n    if ((isalnum(ich)) || (ich == '-'))\n        return 1;\n    if (ich == '_' && netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t     NETSNMP_DS_LIB_MIB_PARSE_LABEL)) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Read a single character from a file. Assumes that the caller has invoked\n * flockfile(). Uses fgetc_unlocked() instead of getc() since the former is\n * implemented as an inline function in glibc. See also bug 3447196\n * (http://sourceforge.net/tracker/?func=detail&aid=3447196&group_id=12694&atid=112694).\n */\nstatic int netsnmp_getc(FILE *stream)\n{\n#ifdef HAVE_FGETC_UNLOCKED\n    return fgetc_unlocked(stream);\n#else\n    return getc(stream);\n#endif\n}\n\n/*\n * Parses a token from the file.  The type of the token parsed is returned,\n * and the text is placed in the string pointed to by token.\n * Warning: this method may recurse.\n */\nstatic int\nget_token(FILE * fp, char *token, int maxtlen)\n{\n    register int    ch, ch_next;\n    register char  *cp = token;\n    register int    hash = 0;\n    register struct tok *tp;\n    int             too_long = 0;\n    enum { bdigits, xdigits, other } seenSymbols;\n\n    /*\n     * skip all white space \n     */\n    do {\n        ch = netsnmp_getc(fp);\n        if (ch == '\\n')\n            mibLine++;\n    }\n    while (isspace(ch) && ch != EOF);\n    *cp++ = ch;\n    *cp = '\\0';\n    switch (ch) {\n    case EOF:\n        return ENDOFFILE;\n    case '\"':\n        return parseQuoteString(fp, token, maxtlen);\n    case '\\'':                 /* binary or hex constant */\n        seenSymbols = bdigits;\n        while ((ch = netsnmp_getc(fp)) != EOF && ch != '\\'') {\n            switch (seenSymbols) {\n            case bdigits:\n                if (ch == '0' || ch == '1')\n                    break;\n                seenSymbols = xdigits;\n\t\t/* FALL THROUGH */\n            case xdigits:\n                if (isxdigit(ch))\n                    break;\n                seenSymbols = other;\n            case other:\n                break;\n            }\n            if (cp - token < maxtlen - 2)\n                *cp++ = ch;\n        }\n        if (ch == '\\'') {\n            unsigned long   val = 0;\n            char           *run = token + 1;\n            ch = netsnmp_getc(fp);\n            switch (ch) {\n            case EOF:\n                return ENDOFFILE;\n            case 'b':\n            case 'B':\n                if (seenSymbols > bdigits) {\n                    *cp++ = '\\'';\n                    *cp = 0;\n                    return LABEL;\n                }\n                while (run != cp)\n                    val = val * 2 + *run++ - '0';\n                break;\n            case 'h':\n            case 'H':\n                if (seenSymbols > xdigits) {\n                    *cp++ = '\\'';\n                    *cp = 0;\n                    return LABEL;\n                }\n                while (run != cp) {\n                    ch = *run++;\n                    if ('0' <= ch && ch <= '9')\n                        val = val * 16 + ch - '0';\n                    else if ('a' <= ch && ch <= 'f')\n                        val = val * 16 + ch - 'a' + 10;\n                    else if ('A' <= ch && ch <= 'F')\n                        val = val * 16 + ch - 'A' + 10;\n                }\n                break;\n            default:\n                *cp++ = '\\'';\n                *cp = 0;\n                return LABEL;\n            }\n            sprintf(token, \"%ld\", val);\n            return NUMBER;\n        } else\n            return LABEL;\n    case '(':\n        return LEFTPAREN;\n    case ')':\n        return RIGHTPAREN;\n    case '{':\n        return LEFTBRACKET;\n    case '}':\n        return RIGHTBRACKET;\n    case '[':\n        return LEFTSQBRACK;\n    case ']':\n        return RIGHTSQBRACK;\n    case ';':\n        return SEMI;\n    case ',':\n        return COMMA;\n    case '|':\n        return BAR;\n    case '.':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next == '.')\n            return RANGE;\n        ungetc(ch_next, fp);\n        return LABEL;\n    case ':':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next != ':') {\n            ungetc(ch_next, fp);\n            return LABEL;\n        }\n        ch_next = netsnmp_getc(fp);\n        if (ch_next != '=') {\n            ungetc(ch_next, fp);\n            return LABEL;\n        }\n        return EQUALS;\n    case '-':\n        ch_next = netsnmp_getc(fp);\n        if (ch_next == '-') {\n            if (netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t       NETSNMP_DS_LIB_MIB_COMMENT_TERM)) {\n                /*\n                 * Treat the rest of this line as a comment. \n                 */\n                while ((ch_next != EOF) && (ch_next != '\\n'))\n                    ch_next = netsnmp_getc(fp);\n            } else {\n                /*\n                 * Treat the rest of the line or until another '--' as a comment \n                 */\n                /*\n                 * (this is the \"technically\" correct way to parse comments) \n                 */\n                ch = ' ';\n                ch_next = netsnmp_getc(fp);\n                while (ch_next != EOF && ch_next != '\\n' &&\n                       (ch != '-' || ch_next != '-')) {\n                    ch = ch_next;\n                    ch_next = netsnmp_getc(fp);\n                }\n            }\n            if (ch_next == EOF)\n                return ENDOFFILE;\n            if (ch_next == '\\n')\n                mibLine++;\n            return get_token(fp, token, maxtlen);\n        }\n        ungetc(ch_next, fp);\n\t/* fallthrough */\n    default:\n        /*\n         * Accumulate characters until end of token is found.  Then attempt to\n         * match this token as a reserved word.  If a match is found, return the\n         * type.  Else it is a label.\n         */\n        if (!is_labelchar(ch))\n            return LABEL;\n        hash += tolower(ch);\n      more:\n        while (is_labelchar(ch_next = netsnmp_getc(fp))) {\n            hash += tolower(ch_next);\n            if (cp - token < maxtlen - 1)\n                *cp++ = ch_next;\n            else\n                too_long = 1;\n        }\n        ungetc(ch_next, fp);\n        *cp = '\\0';\n\n        if (too_long)\n            print_error(\"Warning: token too long\", token, CONTINUE);\n        for (tp = buckets[BUCKET(hash)]; tp; tp = tp->next) {\n            if ((tp->hash == hash) && (!label_compare(tp->name, token)))\n                break;\n        }\n        if (tp) {\n            if (tp->token != CONTINUE)\n                return (tp->token);\n            while (isspace((ch_next = netsnmp_getc(fp))))\n                if (ch_next == '\\n')\n                    mibLine++;\n            if (ch_next == EOF)\n                return ENDOFFILE;\n            if (isalnum(ch_next)) {\n                *cp++ = ch_next;\n                hash += tolower(ch_next);\n                goto more;\n            }\n        }\n        if (token[0] == '-' || isdigit((unsigned char)(token[0]))) {\n            for (cp = token + 1; *cp; cp++)\n                if (!isdigit((unsigned char)(*cp)))\n                    return LABEL;\n            return NUMBER;\n        }\n        return LABEL;\n    }\n}\n\nnetsnmp_feature_child_of(parse_get_token, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_GET_TOKEN\nint\nsnmp_get_token(FILE * fp, char *token, int maxtlen)\n{\n    return get_token(fp, token, maxtlen);\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_GET_TOKEN */\n\nint\nadd_mibfile(const char* tmpstr, const char* d_name)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}\n\nstatic int elemcmp(const void *a, const void *b)\n{\n    const char *const *s1 = a, *const *s2 = b;\n\n    return strcmp(*s1, *s2);\n}\n\n/*\n * Scan a directory and return all filenames found as an array of pointers to\n * directory entries (@result).\n */\nstatic int scan_directory(char ***result, const char *dirname)\n{\n    DIR            *dir, *dir2;\n    struct dirent  *file;\n    char          **filenames = NULL;\n    int             fname_len, i, filename_count = 0, array_size = 0;\n    char           *tmpstr;\n\n    *result = NULL;\n\n    dir = opendir(dirname);\n    if (!dir)\n        return -1;\n\n    while ((file = readdir(dir))) {\n        /*\n         * Only parse file names that don't begin with a '.'\n         * Also skip files ending in '~', or starting/ending\n         * with '#' which are typically editor backup files.\n         */\n        fname_len = strlen(file->d_name);\n        if (fname_len > 0 && file->d_name[0] != '.'\n            && file->d_name[0] != '#'\n            && file->d_name[fname_len-1] != '#'\n            && file->d_name[fname_len-1] != '~') {\n            if (asprintf(&tmpstr, \"%s/%s\", dirname, file->d_name) < 0)\n                continue;\n            dir2 = opendir(tmpstr);\n            if (dir2) {\n                /* file is a directory, don't read it */\n                closedir(dir2);\n            } else {\n                if (filename_count >= array_size) {\n                    char **new_filenames;\n\n                    array_size = (array_size + 16) * 2;\n                    new_filenames = realloc(filenames,\n                                        array_size * sizeof(filenames[0]));\n                    if (!new_filenames) {\n                        free(tmpstr);\n                        for (i = 0; i < filename_count; i++)\n                            free(filenames[i]);\n                        free(filenames);\n                        closedir(dir);\n                        return -1;\n                    }\n                    filenames = new_filenames;\n                }\n                filenames[filename_count++] = tmpstr;\n                tmpstr = NULL;\n            }\n            free(tmpstr);\n        }\n    }\n    closedir(dir);\n\n    if (filenames)\n        qsort(filenames, filename_count, sizeof(filenames[0]), elemcmp);\n    *result = filenames;\n\n    return filename_count;\n}\n\n/* For Win32 platforms, the directory does not maintain a last modification\n * date that we can compare with the modification date of the .index file.\n * Therefore there is no way to know whether any .index file is valid.\n * This is the reason for the #if !(defined(WIN32) || defined(cygwin))\n * in the add_mibdir function\n */\nint\nadd_mibdir(const char *dirname)\n{\n    const char     *oldFile = File;\n    char          **filenames;\n    int             count = 0;\n    int             filename_count, i;\n\n    DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n\n    filename_count = scan_directory(&filenames, dirname);\n\n    if (filename_count >= 0) {\n        for (i = 0; i < filename_count; i++) {\n            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)\n                count++;\n\t    free(filenames[i]);\n        }\n        File = oldFile;\n        free(filenames);\n        return (count);\n    }\n    else\n        DEBUGMSGTL((\"parse-mibs\",\"cannot open MIB directory %s\\n\", dirname));\n\n    return (-1);\n}\n\n\n/*\n * Returns the root of the whole tree\n *   (for backwards compatability)\n */\nstruct tree    *\nread_mib(const char *filename)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN];\n\n    fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        snmp_log_perror(filename);\n        return NULL;\n    }\n    mibLine = 1;\n    File = filename;\n    DEBUGMSGTL((\"parse-mibs\", \"Parsing file: %s...\\n\", filename));\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    snmp_log(LOG_ERR, \"Failed to parse MIB file %s\\n\", filename);\n\t    fclose(fp);\n\t    return NULL;\n    }\n    fclose(fp);\n    new_module(token, filename);\n    (void) netsnmp_read_module(token);\n\n    return tree_head;\n}\n\n\nstruct tree    *\nread_all_mibs(void)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (mp->no_imports == -1)\n            netsnmp_read_module(mp->name);\n    adopt_orphans();\n\n    /* If entered the syntax error loop in \"read_module()\" */\n    if (gLoop == 1) {\n        gLoop = 0;\n        free(gpMibErrorString);\n        gpMibErrorString = NULL;\n        if (asprintf(&gpMibErrorString, \"Error in parsing MIB module(s): %s !\"\n                     \" Unable to load corresponding MIB(s)\", gMibNames) < 0) {\n            snmp_log(LOG_CRIT,\n                     \"failed to allocated memory for gpMibErrorString\\n\");\n        }\n    }\n\n    /* Caller's responsibility to free this memory */\n    tree_head->parseErrorString = gpMibErrorString;\n\t\n    return tree_head;\n}\n\n\n#ifdef TEST\nint main(int argc, char *argv[])\n{\n    int             i;\n    struct tree    *tp;\n    netsnmp_ds_set_int(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_MIB_WARNINGS, 2);\n\n    netsnmp_init_mib();\n\n    if (argc == 1)\n        (void) read_all_mibs();\n    else\n        for (i = 1; i < argc; i++)\n            read_mib(argv[i]);\n\n    for (tp = tree_head; tp; tp = tp->next_peer)\n        print_subtree(stdout, tp, 0);\n    free_tree(tree_head);\n\n    return 0;\n}\n#endif                          /* TEST */\n\nstatic int\nparseQuoteString(FILE * fp, char *token, int maxtlen)\n{\n    register int    ch;\n    int             count = 0;\n    int             too_long = 0;\n    char           *token_start = token;\n\n    for (ch = netsnmp_getc(fp); ch != EOF; ch = netsnmp_getc(fp)) {\n        if (ch == '\\r')\n            continue;\n        if (ch == '\\n') {\n            mibLine++;\n        } else if (ch == '\"') {\n            *token = '\\0';\n            if (too_long && netsnmp_ds_get_int(NETSNMP_DS_LIBRARY_ID, \n\t\t\t\t\t   NETSNMP_DS_LIB_MIB_WARNINGS) > 1) {\n                /*\n                 * show short form for brevity sake \n                 */\n                char            ch_save = *(token_start + 50);\n                *(token_start + 50) = '\\0';\n                print_error(\"Warning: string too long\",\n                            token_start, QUOTESTRING);\n                *(token_start + 50) = ch_save;\n            }\n            return QUOTESTRING;\n        }\n        /*\n         * maximum description length check.  If greater, keep parsing\n         * but truncate the string \n         */\n        if (++count < maxtlen)\n            *token++ = ch;\n        else\n            too_long = 1;\n    }\n\n    return 0;\n}\n\n/*\n * struct index_list *\n * getIndexes(FILE *fp):\n *   This routine parses a string like  { blah blah blah } and returns a\n *   list of the strings enclosed within it.\n *\n */\nstatic struct index_list *\ngetIndexes(FILE * fp, struct index_list **retp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    char            nextIsImplied = 0;\n\n    struct index_list *mylist = NULL;\n    struct index_list **mypp = &mylist;\n\n    free_indexes(retp);\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET) {\n        return NULL;\n    }\n\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != RIGHTBRACKET && type != ENDOFFILE) {\n        if ((type == LABEL) || (type & SYNTAX_MASK)) {\n            *mypp =\n                (struct index_list *) calloc(1, sizeof(struct index_list));\n            if (*mypp) {\n                (*mypp)->ilabel = strdup(token);\n                (*mypp)->isimplied = nextIsImplied;\n                mypp = &(*mypp)->next;\n                nextIsImplied = 0;\n            }\n        } else if (type == IMPLIED) {\n            nextIsImplied = 1;\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    *retp = mylist;\n    return mylist;\n}\n\nstatic struct varbind_list *\ngetVarbinds(FILE * fp, struct varbind_list **retp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n\n    struct varbind_list *mylist = NULL;\n    struct varbind_list **mypp = &mylist;\n\n    free_varbinds(retp);\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET) {\n        return NULL;\n    }\n\n    type = get_token(fp, token, MAXTOKEN);\n    while (type != RIGHTBRACKET && type != ENDOFFILE) {\n        if ((type == LABEL) || (type & SYNTAX_MASK)) {\n            *mypp =\n                (struct varbind_list *) calloc(1,\n                                               sizeof(struct\n                                                      varbind_list));\n            if (*mypp) {\n                (*mypp)->vblabel = strdup(token);\n                mypp = &(*mypp)->next;\n            }\n        }\n        type = get_token(fp, token, MAXTOKEN);\n    }\n\n    *retp = mylist;\n    return mylist;\n}\n\nstatic void\nfree_indexes(struct index_list **spp)\n{\n    if (spp && *spp) {\n        struct index_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->ilabel)\n                free(pp->ilabel);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_varbinds(struct varbind_list **spp)\n{\n    if (spp && *spp) {\n        struct varbind_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->vblabel)\n                free(pp->vblabel);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_ranges(struct range_list **spp)\n{\n    if (spp && *spp) {\n        struct range_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic void\nfree_enums(struct enum_list **spp)\n{\n    if (spp && *spp) {\n        struct enum_list *pp, *npp;\n\n        pp = *spp;\n        *spp = NULL;\n\n        while (pp) {\n            npp = pp->next;\n            if (pp->label)\n                free(pp->label);\n            free(pp);\n            pp = npp;\n        }\n    }\n}\n\nstatic struct enum_list *\ncopy_enums(struct enum_list *sp)\n{\n    struct enum_list *xp = NULL, **spp = &xp;\n\n    while (sp) {\n        *spp = (struct enum_list *) calloc(1, sizeof(struct enum_list));\n        if (!*spp)\n            break;\n        (*spp)->label = strdup(sp->label);\n        (*spp)->value = sp->value;\n        spp = &(*spp)->next;\n        sp = sp->next;\n    }\n    return (xp);\n}\n\nstatic struct range_list *\ncopy_ranges(struct range_list *sp)\n{\n    struct range_list *xp = NULL, **spp = &xp;\n\n    while (sp) {\n        *spp = (struct range_list *) calloc(1, sizeof(struct range_list));\n        if (!*spp)\n            break;\n        (*spp)->low = sp->low;\n        (*spp)->high = sp->high;\n        spp = &(*spp)->next;\n        sp = sp->next;\n    }\n    return (xp);\n}\n\n/*\n * This routine parses a string like  { blah blah blah } and returns OBJID if\n * it is well formed, and NULL if not.\n */\nstatic int\ntossObjectIdentifier(FILE * fp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    int             bracketcount = 1;\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET)\n        return 0;\n    while ((type != RIGHTBRACKET || bracketcount > 0) && type != ENDOFFILE) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == LEFTBRACKET)\n            bracketcount++;\n        else if (type == RIGHTBRACKET)\n            bracketcount--;\n    }\n\n    if (type == RIGHTBRACKET)\n        return OBJID;\n    else\n        return 0;\n}\n\n/* Find node in any MIB module\n   Used by Perl modules\t\t*/\nstruct tree    *\nfind_node(const char *name, struct tree *subtree)\n{                               /* Unused */\n    return (find_tree_node(name, -1));\n}\n\nnetsnmp_feature_child_of(parse_find_node2, netsnmp_unused)\n#ifndef NETSNMP_FEATURE_REMOVE_PARSE_FIND_NODE2\nstruct tree    *\nfind_node2(const char *name, const char *module)\n{                               \n  int modid = -1;\n  if (module) {\n    modid = which_module(module);\n  }\n  if (modid == -1)\n  {\n    return (NULL);\n  }\n  return (find_tree_node(name, modid));\n}\n#endif /* NETSNMP_FEATURE_REMOVE_PARSE_FIND_NODE2 */\n\n#ifndef NETSNMP_FEATURE_REMOVE_FIND_MODULE\n/* Used in the perl module */\nstruct module  *\nfind_module(int mid)\n{\n    struct module  *mp;\n\n    for (mp = module_head; mp != NULL; mp = mp->next) {\n        if (mp->modid == mid)\n            break;\n    }\n    return mp;\n}\n#endif /* NETSNMP_FEATURE_REMOVE_FIND_MODULE */\n\n\nstatic char     leave_indent[256];\nstatic int      leave_was_simple;\n\nstatic void\nprint_mib_leaves(FILE * f, struct tree *tp, int width)\n{\n    struct tree    *ntp;\n    char           *ip = leave_indent + strlen(leave_indent) - 1;\n    char            last_ipch = *ip;\n\n    *ip = '+';\n    if (tp->type == TYPE_OTHER || tp->type > TYPE_SIMPLE_LAST) {\n        fprintf(f, \"%s--%s(%ld)\\n\", leave_indent, tp->label, tp->subid);\n        if (tp->indexes) {\n            struct index_list *xp = tp->indexes;\n            int             first = 1, cpos = 0, len, cmax =\n                width - strlen(leave_indent) - 12;\n            *ip = last_ipch;\n            fprintf(f, \"%s  |  Index: \", leave_indent);\n            while (xp) {\n                if (first)\n                    first = 0;\n                else\n                    fprintf(f, \", \");\n                cpos += (len = strlen(xp->ilabel) + 2);\n                if (cpos > cmax) {\n                    fprintf(f, \"\\n\");\n                    fprintf(f, \"%s  |         \", leave_indent);\n                    cpos = len;\n                }\n                fprintf(f, \"%s\", xp->ilabel);\n                xp = xp->next;\n            }\n            fprintf(f, \"\\n\");\n            *ip = '+';\n        }\n    } else {\n        const char     *acc, *typ;\n        int             size = 0;\n        switch (tp->access) {\n        case MIB_ACCESS_NOACCESS:\n            acc = \"----\";\n            break;\n        case MIB_ACCESS_READONLY:\n            acc = \"-R--\";\n            break;\n        case MIB_ACCESS_WRITEONLY:\n            acc = \"--W-\";\n            break;\n        case MIB_ACCESS_READWRITE:\n            acc = \"-RW-\";\n            break;\n        case MIB_ACCESS_NOTIFY:\n            acc = \"---N\";\n            break;\n        case MIB_ACCESS_CREATE:\n            acc = \"CR--\";\n            break;\n        default:\n            acc = \"    \";\n            break;\n        }\n        switch (tp->type) {\n        case TYPE_OBJID:\n            typ = \"ObjID    \";\n            break;\n        case TYPE_OCTETSTR:\n            typ = \"String   \";\n            size = 1;\n            break;\n        case TYPE_INTEGER:\n            if (tp->enums)\n                typ = \"EnumVal  \";\n            else\n                typ = \"INTEGER  \";\n            break;\n        case TYPE_NETADDR:\n            typ = \"NetAddr  \";\n            break;\n        case TYPE_IPADDR:\n            typ = \"IpAddr   \";\n            break;\n        case TYPE_COUNTER:\n            typ = \"Counter  \";\n            break;\n        case TYPE_GAUGE:\n            typ = \"Gauge    \";\n            break;\n        case TYPE_TIMETICKS:\n            typ = \"TimeTicks\";\n            break;\n        case TYPE_OPAQUE:\n            typ = \"Opaque   \";\n            size = 1;\n            break;\n        case TYPE_NULL:\n            typ = \"Null     \";\n            break;\n        case TYPE_COUNTER64:\n            typ = \"Counter64\";\n            break;\n        case TYPE_BITSTRING:\n            typ = \"BitString\";\n            break;\n        case TYPE_NSAPADDRESS:\n            typ = \"NsapAddr \";\n            break;\n        case TYPE_UNSIGNED32:\n            typ = \"Unsigned \";\n            break;\n        case TYPE_UINTEGER:\n            typ = \"UInteger \";\n            break;\n        case TYPE_INTEGER32:\n            typ = \"Integer32\";\n            break;\n        default:\n            typ = \"         \";\n            break;\n        }\n        fprintf(f, \"%s-- %s %s %s(%ld)\\n\", leave_indent, acc, typ,\n                tp->label, tp->subid);\n        *ip = last_ipch;\n        if (tp->tc_index >= 0)\n            fprintf(f, \"%s        Textual Convention: %s\\n\", leave_indent,\n                    tclist[tp->tc_index].descriptor);\n        if (tp->enums) {\n            struct enum_list *ep = tp->enums;\n            int             cpos = 0, cmax =\n                width - strlen(leave_indent) - 16;\n            fprintf(f, \"%s        Values: \", leave_indent);\n            while (ep) {\n                char            buf[80];\n                int             bufw;\n                if (ep != tp->enums)\n                    fprintf(f, \", \");\n                snprintf(buf, sizeof(buf), \"%s(%d)\", ep->label, ep->value);\n                buf[ sizeof(buf)-1 ] = 0;\n                cpos += (bufw = strlen(buf) + 2);\n                if (cpos >= cmax) {\n                    fprintf(f, \"\\n%s                \", leave_indent);\n                    cpos = bufw;\n                }\n                fprintf(f, \"%s\", buf);\n                ep = ep->next;\n            }\n            fprintf(f, \"\\n\");\n        }\n        if (tp->ranges) {\n            struct range_list *rp = tp->ranges;\n            if (size)\n                fprintf(f, \"%s        Size: \", leave_indent);\n            else\n                fprintf(f, \"%s        Range: \", leave_indent);\n            while (rp) {\n                if (rp != tp->ranges)\n                    fprintf(f, \" | \");\n                print_range_value(f, tp->type, rp);\n                rp = rp->next;\n            }\n            fprintf(f, \"\\n\");\n        }\n    }\n    *ip = last_ipch;\n    strcat(leave_indent, \"  |\");\n    leave_was_simple = tp->type != TYPE_OTHER;\n\n    {\n        int             i, j, count = 0;\n        struct leave {\n            oid             id;\n            struct tree    *tp;\n        }              *leaves, *lp;\n\n        for (ntp = tp->child_list; ntp; ntp = ntp->next_peer)\n            count++;\n        if (count) {\n            leaves = (struct leave *) calloc(count, sizeof(struct leave));\n            if (!leaves)\n                return;\n            for (ntp = tp->child_list, count = 0; ntp;\n                 ntp = ntp->next_peer) {\n                for (i = 0, lp = leaves; i < count; i++, lp++)\n                    if (lp->id >= ntp->subid)\n                        break;\n                for (j = count; j > i; j--)\n                    leaves[j] = leaves[j - 1];\n                lp->id = ntp->subid;\n                lp->tp = ntp;\n                count++;\n            }\n            for (i = 1, lp = leaves; i <= count; i++, lp++) {\n                if (!leave_was_simple || lp->tp->type == 0)\n                    fprintf(f, \"%s\\n\", leave_indent);\n                if (i == count)\n                    ip[3] = ' ';\n                print_mib_leaves(f, lp->tp, width);\n            }\n            free(leaves);\n            leave_was_simple = 0;\n        }\n    }\n    ip[1] = 0;\n}\n\nvoid\nprint_mib_tree(FILE * f, struct tree *tp, int width)\n{\n    leave_indent[0] = ' ';\n    leave_indent[1] = 0;\n    leave_was_simple = 1;\n    print_mib_leaves(f, tp, width);\n}\n\n\n/*\n * Merge the parsed object identifier with the existing node.\n * If there is a problem with the identifier, release the existing node.\n */\nstatic struct node *\nmerge_parse_objectid(struct node *np, FILE * fp, char *name)\n{\n    struct node    *nnp;\n    /*\n     * printf(\"merge defval --> %s\\n\",np->defaultValue); \n     */\n    nnp = parse_objectid(fp, name);\n    if (nnp) {\n\n        /*\n         * apply last OID sub-identifier data to the information \n         */\n        /*\n         * already collected for this node. \n         */\n        struct node    *headp, *nextp;\n        int             ncount = 0;\n        nextp = headp = nnp;\n        while (nnp->next) {\n            nextp = nnp;\n            ncount++;\n            nnp = nnp->next;\n        }\n\n        np->label = nnp->label;\n        np->subid = nnp->subid;\n        np->modid = nnp->modid;\n        np->parent = nnp->parent;\n\tif (nnp->filename != NULL) {\n\t  free(nnp->filename);\n\t}\n        free(nnp);\n\n        if (ncount) {\n            nextp->next = np;\n            np = headp;\n        }\n    } else {\n        free_node(np);\n        np = NULL;\n    }\n\n    return np;\n}\n\n/*\n * transfer data to tree from node\n *\n * move pointers for alloc'd data from np to tp.\n * this prevents them from being freed when np is released.\n * parent member is not moved.\n *\n * CAUTION: nodes may be repeats of existing tree nodes.\n * This can happen especially when resolving IMPORT clauses.\n *\n */\nstatic void\ntree_from_node(struct tree *tp, struct node *np)\n{\n    free_partial_tree(tp, FALSE);\n\n    tp->label = np->label;\n    np->label = NULL;\n    tp->enums = np->enums;\n    np->enums = NULL;\n    tp->ranges = np->ranges;\n    np->ranges = NULL;\n    tp->indexes = np->indexes;\n    np->indexes = NULL;\n    tp->augments = np->augments;\n    np->augments = NULL;\n    tp->varbinds = np->varbinds;\n    np->varbinds = NULL;\n    tp->hint = np->hint;\n    np->hint = NULL;\n    tp->units = np->units;\n    np->units = NULL;\n    tp->description = np->description;\n    np->description = NULL;\n    tp->reference = np->reference;\n    np->reference = NULL;\n    tp->defaultValue = np->defaultValue;\n    np->defaultValue = NULL;\n    tp->subid = np->subid;\n    tp->tc_index = np->tc_index;\n    tp->type = translation_table[np->type];\n    tp->access = np->access;\n    tp->status = np->status;\n\n    set_function(tp);\n}\n\n#endif /* NETSNMP_DISABLE_MIB_LOADING */\n"], "filenames": [".gitignore", "include/net-snmp/library/mib.h", "include/net-snmp/library/parse.h", "snmplib/mib.c", "snmplib/parse.c"], "buggy_code_start_loc": [78, 127, 204, 2723, 610], "buggy_code_end_loc": [79, 130, 205, 3053, 5045], "fixing_code_start_loc": [77, 126, 204, 2722, 609], "fixing_code_end_loc": [77, 126, 205, 2906, 4991], "type": "CWE-59", "message": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.", "other": {"cve": {"id": "CVE-2020-15861", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-20T01:17:13.837", "lastModified": "2022-12-03T15:13:43.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following."}, {"lang": "es", "value": "Net-SNMP versiones hasta 5.7.3, permite una Escalada de Privilegios debido al seguimiento de un enlace simb\u00f3lico (symlink) de UNIX."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:net-snmp:net-snmp:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.7.3", "matchCriteriaId": "8BD5C233-45FA-4501-8EA4-C28EC33E7460"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:smi-s_provider:-:*:*:*:*:*:*:*", "matchCriteriaId": "4BB0FDCF-3750-44C6-AC5C-0CC2AAD14093"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}]}]}], "references": [{"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=966599", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/net-snmp/net-snmp/issues/145", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202008-12", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200904-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4471-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602"}}