{"buggy_code": [".. 3.4.x Changelogs\n\nRedbot 3.4.1 (2020-10-27)\n=========================\n\n| Thanks to all these amazing people that contributed to this release:\n| :ghuser:`absj30`, :ghuser:`aikaterna`, :ghuser:`bobloy`, :ghuser:`chloecormier`, :ghuser:`Dav-Git`, :ghuser:`Drapersniper`, :ghuser:`fixator10`, :ghuser:`Flame442`, :ghuser:`flaree`, :ghuser:`Generaleoley`, :ghuser:`hisztendahl`, :ghuser:`jack1142`, :ghuser:`KaiGucci`, :ghuser:`Kowlin`, :ghuser:`maxbooiii`, :ghuser:`MeatyChunks`, :ghuser:`NeuroAssassin`, :ghuser:`nfitzen`, :ghuser:`palmtree5`, :ghuser:`phenom4n4n`, :ghuser:`PredaaA`, :ghuser:`Predeactor`, :ghuser:`PythonTryHard`, :ghuser:`SharkyTheKing`, :ghuser:`Stonedestroyer`, :ghuser:`thisisjvgrace`, :ghuser:`TrustyJAID`, :ghuser:`TurnrDev`, :ghuser:`Vexed01`, :ghuser:`Vuks69`, :ghuser:`xBlynd`, :ghuser:`zephyrkul`\n\nRead before updating\n--------------------\n\n1. This Red update bumps discord.py to version 1.5.1, which explicitly requests Discord intents. Red requires all Prvileged Intents to be enabled. More information can be found at :ref:`enabling-privileged-intents`.\n2. Mutes functionality has been moved from the Mod cog to a new separate cog (Mutes) featuring timed and role-based mutes. If you were using it (or want to start now), you can load the new cog with ``[p]load mutes``. You can see the full `Mutes changelog below <important-341-1>`.\n3. Information for Audio users that are using an external Lavalink instance (if you don't know what that is, you should skip this point):\n\n   We've updated our `application.yml file <https://github.com/Cog-Creators/Red-DiscordBot/blob/3.4.1/redbot/cogs/audio/data/application.yml>`_ and you should update your instance's ``application.yml`` appropriately.\n   Please ensure that the WS port in Audio's settings (``[p]llset wsport``) is set to the port from the ``application.yml``.\n\nEnd-user changelog\n------------------\n\nCore Bot\n********\n\n- Fixed an incorrect error being reported on ``[p]set name`` when the passed name was longer than 32 characters (:issue:`4364`, :issue:`4363`)\n- Fixed ``[p]set nickname`` erroring when the passed name was longer than 32 characters (:issue:`4364`, :issue:`4363`)\n- Fixed an ungraceful error being raised when running ``[p]traceback`` with closed DMs (:issue:`4329`)\n- Fixed errors that could arise from invalid URLs in ``[p]set avatar`` (:issue:`4437`)\n- Fixed an error being raised with ``[p]set nickname`` when no nickname was provided (:issue:`4451`)\n- Fixed and clarified errors being raised with ``[p]set username`` (:issue:`4463`)\n- Fixed an ungraceful error being raised when the output of ``[p]unload`` is larger than 2k characters (:issue:`4469`)\n- Fixed an ungraceful error being raised when running ``[p]choose`` with empty options (:issue:`4499`)\n- Fixed an ungraceful error being raised when a bot left a guild while a menu was open (:issue:`3902`)\n- Fixed info missing on the non-embed version of ``[p]debuginfo`` (:issue:`4524`)\n- Added ``[p]set api list`` to list all currently set API services, without tokens (:issue:`4370`)\n- Added ``[p]set api remove`` to remove API services, including tokens (:issue:`4370`)\n- Added ``[p]helpset usetick``, toggling command message being ticked when help is sent to DM (:issue:`4467`, :issue:`4075`)\n- Added a default color field to ``[p]set showsettings`` (:issue:`4498`, :issue:`4497`)\n- Added the datapath and metadata file to ``[p]debuginfo`` (:issue:`4524`)\n- Added a list of disabled intents to ``[p]debuginfo`` (:issue:`4423`)\n- Bumped discord.py dependency to version 1.5.1 (:issue:`4423`)\n- Locales and regional formats can now be set in individual guilds using ``[p]set locale`` and ``[p]set regionalformat`` (:issue:`3896`, :issue:`1970`)\n\n    - Global locale and regional format setters have been renamed to ``[p]set globallocale`` and ``[p]set globalregionalformat``\n\nAudio\n*****\n\n- Scattered grammar and typo fixes (:issue:`4446`)\n- Fixed Bandcamp playback (:issue:`4504`)\n- Fixed YouTube playlist playback (:issue:`4504`)\n- Fixed YouTube searching issues (:issue:`4504`)\n- Fixed YouTube age restricted track playback (:issue:`4504`)\n- Fixed the Audio cog not being translated when setting locale (:issue:`4492`, :issue:`4495`)\n- Fixed tracks getting stuck at 0:00 after long player sessions (:issue:`4529`)\n- Removed lavalink logs from being added to backup (:issue:`4453`, :issue:`4452`)\n- Removed stream durations from being in queue duration (:issue:`4513`)\n- Added the Global Audio API, to cut down on Youtube 429 errors and allow Spotify playback past user's quota. (:issue:`4446`)\n- Added persistent queues, allowing for queues to be restored on a bot restart or cog reload (:issue:`4446`)\n- Added ``[p]audioset restart``, allowing for Lavalink connection to be restarted (:issue:`4446`)\n- Added ``[p]audioset autodeafen``, allowing for bot to auto-deafen itself when entering voice channel (:issue:`4446`)\n- Added ``[p]audioset mycountrycode``, allowing Spotify search locale per user (:issue:`4446`)\n- Added ``[p]llsetup java``, allowing for a custom Java executable path (:issue:`4446`)\n- Added ``[p]llset info`` to show Lavalink settings (:issue:`4527`)\n- Added ``[p]audioset logs`` to download Lavalink logs if the Lavalink server is set to internal (:issue:`4527`)\n\nCleanup\n*******\n\n- Allowed ``[p]cleanup self`` to work in DMs for all users (:issue:`4481`)\n\nCustom Commands\n***************\n\n- Fixed an ungraceful error being thrown on ``[p]cc edit`` (:issue:`4325`)\n\nDev\n***\n\n- Added ``[p]repl pause`` to pause/resume the REPL session in the current channel (:issue:`4366`)\n\nEconomy\n*******\n\n- Added an embed option for ``[p]leaderboard`` (:issue:`4184`, :issue:`4104`)\n\nGeneral\n*******\n\n- Fixed issues with text not being properly URL encoded (:issue:`4024`)\n- Fixed an ungraceful error occurring when a title is longer than 256 characters in ``[p]urban`` (:issue:`4474`)\n- Changed \"boosters\" to \"boosts\" in ``[p]serverinfo`` to clarify what the number represents (:issue:`4507`)\n\nMod\n***\n\n- Added ``[p]modset mentionspam strict`` allowing for duplicated mentions to count towards the mention spam cap (:issue:`4359`)\n- Added an option to ban users not in the guild to ``[p]ban`` (:issue:`4422`, :issue:`4419`)\n- Added a default tempban duration for ``[p]tempban`` (:issue:`4473`, :issue:`3992`)\n- Fixed nicknames not being properly stored and logged (:issue:`4131`)\n- Fixed plural typos in ``[p]userinfo`` (:issue:`4397`, :issue:`4379`)\n- Renamed ``[p]hackban`` to ``[p]massban``, keeping ``[p]hackban`` as an alias, allowing for multiple users to be banned at once (:issue:`4422`, :issue:`4419`)\n- Moved mutes to a separate, individual cog (:issue:`3634`)\n\n.. _important-341-1:\n\nMutes\n*****\n\n- Added ``[p]muteset forcerole`` to make mutes role based, instead of permission based (:issue:`3634`)\n- Added an optional time argument to all mutes, to specify when the user should be unmuted (:issue:`3634`)\n- Changed ``[p]mute`` to only handle serverwide muting, ``[p]mute voice`` and ``[p]mute channel`` have been moved to separate commands called ``[p]mutechannel`` and ``[p]mutevoice`` (:issue:`3634`)\n- Mute commands can now take multiple user arguments, to mute multiple users at a time (:issue:`3634`)\n\nModlog\n******\n\n- Fixed an error being raised when running ``[p]casesfor`` and ``[p]case`` (:issue:`4415`)\n- Long reasons in Modlog are now properly shortened in message content (:issue:`4541`)\n\nTrivia Lists\n************\n\n- Fixed incorrect order of Machamp and Machoke questions (:issue:`4424`)\n- Added new MLB trivia list (:issue:`4455`)\n- Added new Who's That Pok\u00e9mon - Gen. IV trivia list (:issue:`4434`)\n- Added new Hockey trivia list (:issue:`4384`)\n\nWarnings\n********\n\n- Fixed users being able to warn users above them in hierarchy (:issue:`4100`)\n- Added bool arguments to toggle commands to improve consistency (:issue:`4409`)\n\nDeveloper changelog\n-------------------\n\n| **Important:**\n| 1. Red now allows users to set locale per guild, which requires 3rd-party cogs to set contextual locale manually in code ran outside of command's context. See the `Core Bot changelog below <important-dev-341-1>` for more information.\n\n.. _important-dev-341-1:\n\nCore Bot\n********\n\n- Added API for setting contextual locales (:issue:`3896`, :issue:`1970`)\n\n    - New function added: `redbot.core.i18n.set_contextual_locales_from_guild()`\n    - Contextual locale is automatically set for commands and only needs to be done manually for things like event listeners; see `guidelines-for-cog-creators` for more information\n\n- Added `bot.remove_shared_api_services() <RedBase.remove_shared_api_services()>` to remove all keys and tokens associated with an API service (:issue:`4370`)\n- Added an option to return all tokens for an API service if ``service_name`` is not specified in `bot.get_shared_api_tokens() <RedBase.get_shared_api_tokens()>` (:issue:`4370`)\n- Added `bot.get_or_fetch_user() <RedBase.get_or_fetch_user()>` and `bot.get_or_fetch_member() <RedBase.get_or_fetch_member()>` methods (:issue:`4403`, :issue:`4402`)\n- Moved ``redbot.core.checks.bot_in_a_guild()`` to `redbot.core.commands.bot_in_a_guild()` (old name has been left as an alias) (:issue:`4515`, :issue:`4510`)\n\nBank\n****\n\n- Bank API methods now consistently throw TypeError if a non-integer amount is supplied (:issue:`4376`)\n\nMod\n***\n\n- Deprecated ``redbot.core.utils.mod.is_allowed_by_hierarchy`` (:issue:`4435`)\n\nModlog\n******\n\n- Added an option to accept a ``discord.Object`` in case creation (:issue:`4326`)\n- Added ``last_known_username`` parameter to `modlog.create_case()` function (:issue:`4326`)\n- Fixed an error being raised with a deleted channel in `Case.message_content()` (:issue:`4415`)\n\nUtility\n*******\n\n- Added `redbot.core.utils.get_end_user_data_statement()` and `redbot.core.utils.get_end_user_data_statement_or_raise()` to attempt to fetch a cog's End User Data Statement (:issue:`4404`)\n- Added `redbot.core.utils.chat_formatting.quote()` to quote text in a message (:issue:`4425`)\n\nDocumentation changes\n---------------------\n\nConfig\n******\n\n- Added custom group documentation and tutorial (:issue:`4416`, :issue:`2896`)\n\nModlog\n******\n\n- Clarified that naive ``datetime`` objects will be treated as local times for parameters ``created_at`` and ``until`` in `modlog.create_case()` (:issue:`4389`)\n\nOther\n*****\n\n- Added guide to creating a Bot Application in Discord Developer Portal, with enabling intents (:issue:`4502`)\n\nMiscellaneous\n-------------\n\n- Added JSON schema files for ``info.json`` files (:issue:`4375`)\n- Added ``[all]`` and ``[dev]`` bundled install extras (:issue:`4443`)\n- Replaced the link to the approved repository list on CogBoard and references to ``cogs.red`` with a link to new Red Index (:issue:`4439`)\n- Improved documentation about arguments in command syntax (:issue:`4058`)\n- Replaced a few instances of Red with the bot name in command docstrings (:issue:`4470`)\n- Fixed grammar in places scattered throughout bot (:issue:`4500`)\n- Properly define supported Python versions to be lower than 3.9 (:issue:`4538`)\n\n\nRedbot 3.4.0 (2020-08-17)\n=========================\n\n| Thanks to all these amazing people that contributed to this release:\n| :ghuser:`Dav-Git`, :ghuser:`DevilXD`, :ghuser:`douglas-cpp`, :ghuser:`Drapersniper`, :ghuser:`flaree`, :ghuser:`jack1142`, :ghuser:`kablekompany`, :ghuser:`Kowlin`, :ghuser:`maxbooiii`, :ghuser:`MeatyChunks`, :ghuser:`mikeshardmind`, :ghuser:`NeuroAssassin`, :ghuser:`PredaaA`, :ghuser:`Predeactor`, :ghuser:`retke`, :ghuser:`SharkyTheKing`, :ghuser:`thisisjvgrace`, :ghuser:`Tinonb`, :ghuser:`TrustyJAID`, :ghuser:`Twentysix26`, :ghuser:`Vexed01`, :ghuser:`zephyrkul`\n|\n| **Read before updating**:\n| 1. Red 3.4 comes with support for data deletion requests. Bot owners should read `red_core_data_statement` to ensure they know what information about their users is stored by the bot.\n| 2. Debian Stretch, Fedora 30 and lower, and OpenSUSE Leap 15.0 and lower are no longer supported as they have already reached end of life.\n| 3. There's been a change in behavior of ``[p]tempban``. Look at `Mod changelog <important-340-1>` for full details.\n| 4. There's been a change in behavior of announcements in Admin cog. Look at `Admin changelog <important-340-2>` for full details.\n| 5. Red 3.4 comes with breaking changes for cog developers. Look at `Developer changelog <important-340-3>` for full details.\n\nEnd-user changelog\n------------------\n\nCore Bot\n********\n\n- Added per-guild cog disabling (:issue:`4043`, :issue:`3945`)\n\n    - Bot owners can set the default state for a cog using ``[p]command defaultdisablecog`` and ``[p]command defaultenablecog`` commands\n    - Guild owners can enable/disable cogs for their guild using ``[p]command disablecog`` and ``[p]command enablecog`` commands\n    - Cogs disabled in the guild can be listed with ``[p]command listdisabledcogs``\n\n- Added support for data deletion requests; see `red_core_data_statement` for more information (:issue:`4045`)\n- Red now logs clearer error if it can't find package to load in any cog path during bot startup (:issue:`4079`)\n- ``[p]licenseinfo`` now has a 3 minute cooldown to prevent a single user from spamming channel by using it (:issue:`4110`)\n- Added ``[p]helpset showsettings`` command (:issue:`4013`, :issue:`4022`)\n- Updated Red's emoji usage to ensure consistent rendering accross different devices (:issue:`4106`, :issue:`4105`, :issue:`4127`)\n- Whitelist and blacklist are now called allowlist and blocklist. Old names have been left as aliases (:issue:`4138`)\n\n.. _important-340-2:\n\nAdmin\n*****\n\n- ``[p]announce`` will now only send announcements to guilds that have explicitly configured text channel to send announcements to using ``[p]announceset channel`` command (:issue:`4088`, :issue:`4089`)\n\nDownloader\n**********\n\n- ``[p]cog info`` command now shows end user data statement made by the cog creator (:issue:`4169`)\n- ``[p]cog update`` command will now notify the user if cog's end user data statement has changed since last update (:issue:`4169`)\n\n.. _important-340-1:\n\nMod\n***\n\n- ``[p]tempban`` now respects default days setting (``[p]modset defaultdays``) (:issue:`3993`)\n- Users can now set mention spam triggers which will warn or kick the user. See ``[p]modset mentionspam`` for more information (:issue:`3786`, :issue:`4038`)\n- ``[p]mute voice`` and ``[p]unmute voice`` now take action instantly if bot has Move Members permission (:issue:`4064`)\n- Added typing to ``[p](un)mute guild`` to indicate that mute is being processed (:issue:`4066`, :issue:`4172`)\n\nModLog\n******\n\n- Added timestamp to text version of ``[p]casesfor`` and ``[p]case`` commands (:issue:`4118`, :issue:`4137`)\n\nStreams\n*******\n\n- Stream alerts will no longer make roles temporarily mentionable if bot has \"Mention @everyone, @here, and All Roles\" permission in the channel (:issue:`4182`)\n- Mixer service has been closed and for that reason we've removed support for it from the cog (:issue:`4072`)\n- Hitbox commands have been renamed to smashcast (:issue:`4161`)\n- Improve error messages for invalid channel names/IDs (:issue:`4147`, :issue:`4148`)\n\nTrivia Lists\n************\n\n- Added ``whosthatpokemon2`` trivia containing Pok\u00e9mons from 2nd generation (:issue:`4102`)\n- Added ``whosthatpokemon3`` trivia containing Pok\u00e9mons from 3rd generation (:issue:`4141`)\n\n.. _important-340-3:\n\nDeveloper changelog\n-------------------\n\n| **Important:**\n| 1. Red now offers cog disabling API, which should be respected by 3rd-party cogs in guild-related actions happening outside of command's context. See the `Core Bot changelog below <important-dev-340-1>` for more information.\n| 2. Red now provides data request API, which should be supported by all 3rd-party cogs. See the changelog entries in the `Core Bot changelog below <important-dev-340-1>` for more information.\n\nBreaking changes\n****************\n\n- By default, none of the ``.send()`` methods mention roles or ``@everyone/@here`` (:issue:`3845`)\n\n    - see `discord.AllowedMentions` and ``allowed_mentions`` kwarg of ``.send()`` methods, if your cog requires to mention roles or ``@everyone/@here``\n\n- `Context.maybe_send_embed()` now supresses all mentions, including user mentions (:issue:`4192`)\n- The default value of the ``filter`` keyword argument has been changed to ``None`` (:issue:`3845`)\n- Cog package names (i.e. name of the folder the cog is in and the name used when loading the cog) now have to be `valid Python identifiers <https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`_ (:issue:`3605`, :issue:`3679`)\n- Method/attribute names starting with ``red_`` or being in the form of ``__red_*__`` are now reserved. See `version_guarantees` for more information (:issue:`4085`)\n- `humanize_list()` no longer raises `IndexError` for empty sequences (:issue:`2982`)\n- Removed things past deprecation time: (:issue:`4163`)\n\n    - ``redbot.core.commands.APIToken``\n    - ``loop`` kwarg from `bounded_gather_iter()`, `bounded_gather()`, and `start_adding_reactions()`\n\n.. _important-dev-340-1:\n\nCore Bot\n********\n\n- Added cog disabling API (:issue:`4043`, :issue:`3945`)\n\n    - New methods added: `bot.cog_disabled_in_guild() <RedBase.cog_disabled_in_guild()>`, `bot.cog_disabled_in_guild_raw() <RedBase.cog_disabled_in_guild_raw()>`\n    - Cog disabling is automatically applied for commands and only needs to be done manually for things like event listeners; see `guidelines-for-cog-creators` for more information\n\n- Added data request API (:issue:`4045`,  :issue:`4169`)\n\n    - New special methods added to `commands.Cog`: `red_get_data_for_user()` (documented provisionally), `red_delete_data_for_user()`\n    - New special module level variable added: ``__red_end_user_data_statement__``\n    - These methods and variables should be added by all cogs according to their documentation; see `guidelines-for-cog-creators` for more information\n    - New ``info.json`` key added: ``end_user_data_statement``; see `Info.json format documentation <info-json-format>` for more information\n\n- Added `bot.message_eligible_as_command() <RedBase.message_eligible_as_command()>` utility method which can be used to determine if a message may be responded to as a command (:issue:`4077`)\n- Added a provisional API for replacing the help formatter. See `documentation <framework-commands-help>` for more details (:issue:`4011`)\n- `bot.ignored_channel_or_guild() <RedBase.ignored_channel_or_guild()>` now accepts `discord.Message` objects (:issue:`4077`)\n- `commands.NoParseOptional <NoParseOptional>` is no longer provisional and is now fully supported part of API (:issue:`4142`)\n- Red no longer fails to run subcommands of a command group allowed or denied by permission hook (:issue:`3956`)\n- Autohelp in group commands is now sent *after* invoking the group, which allows before invoke hooks to prevent autohelp from getting triggered (:issue:`4129`)\n- RPC functionality no longer makes Red hang for a minute on shutdown (:issue:`4134`, :issue:`4143`)\n\nVendored packages\n*****************\n\n- Updated ``discord.ext.menus`` vendor (:issue:`4167`)\n\nUtility Functions\n*****************\n\n- `humanize_list()` now accepts ``locale`` and ``style`` keyword arguments. See its documentation for more information (:issue:`2982`)\n- `humanize_list()` is now properly localized (:issue:`2906`, :issue:`2982`)\n- `humanize_list()` now accepts empty sequences (:issue:`2982`)\n\n\nDocumentation changes\n---------------------\n\n- Removed install instructions for Debian Stretch (:issue:`4099`)\n- Added admin user guide (:issue:`3081`)\n- Added alias user guide (:issue:`3084`)\n- Added bank user guide (:issue:`4149`)\n\n\nMiscellaneous\n-------------\n\n- Updated features list in ``[p]serverinfo`` with the latest changes from Discord (:issue:`4116`)\n- Simple version of ``[p]serverinfo`` now shows info about more detailed ``[p]serverinfo 1`` (:issue:`4121`)\n- ``[p]set nickname``, ``[p]set serverprefix``, ``[p]streamalert``, and ``[p]streamset`` commands now can be run by users with permissions related to the actions they're making (:issue:`4109`)\n- `bordered()` now uses ``+`` for corners if keyword argument ``ascii_border`` is set to `True` (:issue:`4097`)\n- Fixed timestamp storage in few places in Red (:issue:`4017`)\n", "import asyncio\nimport contextlib\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional, Tuple, Union\n\nimport discord\nfrom redbot.core import commands, i18n, checks, modlog\nfrom redbot.core.commands import UserInputOptional\nfrom redbot.core.utils import AsyncIter\nfrom redbot.core.utils.chat_formatting import (\n    pagify,\n    humanize_number,\n    bold,\n    humanize_list,\n    format_perms_list,\n)\nfrom redbot.core.utils.mod import get_audit_reason\nfrom .abc import MixinMeta\nfrom .converters import RawUserIds\nfrom .utils import is_allowed_by_hierarchy\n\nlog = logging.getLogger(\"red.mod\")\n_ = i18n.Translator(\"Mod\", __file__)\n\n\nclass KickBanMixin(MixinMeta):\n    \"\"\"\n    Kick and ban commands and tasks go here.\n    \"\"\"\n\n    @staticmethod\n    async def get_invite_for_reinvite(ctx: commands.Context, max_age: int = 86400):\n        \"\"\"Handles the reinvite logic for getting an invite\n        to send the newly unbanned user\n        :returns: :class:`Invite`\"\"\"\n        guild = ctx.guild\n        my_perms: discord.Permissions = guild.me.guild_permissions\n        if my_perms.manage_guild or my_perms.administrator:\n            if \"VANITY_URL\" in guild.features:\n                # guild has a vanity url so use it as the one to send\n                return await guild.vanity_invite()\n            invites = await guild.invites()\n        else:\n            invites = []\n        for inv in invites:  # Loop through the invites for the guild\n            if not (inv.max_uses or inv.max_age or inv.temporary):\n                # Invite is for the guild's default channel,\n                # has unlimited uses, doesn't expire, and\n                # doesn't grant temporary membership\n                # (i.e. they won't be kicked on disconnect)\n                return inv\n        else:  # No existing invite found that is valid\n            channels_and_perms = zip(\n                guild.text_channels, map(guild.me.permissions_in, guild.text_channels)\n            )\n            channel = next(\n                (channel for channel, perms in channels_and_perms if perms.create_instant_invite),\n                None,\n            )\n            if channel is None:\n                return\n            try:\n                # Create invite that expires after max_age\n                return await channel.create_invite(max_age=max_age)\n            except discord.HTTPException:\n                return\n\n    @staticmethod\n    async def _voice_perm_check(\n        ctx: commands.Context, user_voice_state: Optional[discord.VoiceState], **perms: bool\n    ) -> bool:\n        \"\"\"Check if the bot and user have sufficient permissions for voicebans.\n\n        This also verifies that the user's voice state and connected\n        channel are not ``None``.\n\n        Returns\n        -------\n        bool\n            ``True`` if the permissions are sufficient and the user has\n            a valid voice state.\n\n        \"\"\"\n        if user_voice_state is None or user_voice_state.channel is None:\n            await ctx.send(_(\"That user is not in a voice channel.\"))\n            return False\n        voice_channel: discord.VoiceChannel = user_voice_state.channel\n        required_perms = discord.Permissions()\n        required_perms.update(**perms)\n        if not voice_channel.permissions_for(ctx.me) >= required_perms:\n            await ctx.send(\n                _(\"I require the {perms} permission(s) in that user's channel to do that.\").format(\n                    perms=format_perms_list(required_perms)\n                )\n            )\n            return False\n        if (\n            ctx.permission_state is commands.PermState.NORMAL\n            and not voice_channel.permissions_for(ctx.author) >= required_perms\n        ):\n            await ctx.send(\n                _(\n                    \"You must have the {perms} permission(s) in that user's channel to use this \"\n                    \"command.\"\n                ).format(perms=format_perms_list(required_perms))\n            )\n            return False\n        return True\n\n    async def ban_user(\n        self,\n        user: Union[discord.Member, discord.User, discord.Object],\n        ctx: commands.Context,\n        days: int = 0,\n        reason: str = None,\n        create_modlog_case=False,\n    ) -> Tuple[bool, str]:\n        author = ctx.author\n        guild = ctx.guild\n\n        removed_temp = False\n\n        if not (0 <= days <= 7):\n            return False, _(\"Invalid days. Must be between 0 and 7.\")\n\n        if isinstance(user, discord.Member):\n            if author == user:\n                return (\n                    False,\n                    _(\"I cannot let you do that. Self-harm is bad {}\").format(\"\\N{PENSIVE FACE}\"),\n                )\n            elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n                return (\n                    False,\n                    _(\n                        \"I cannot let you do that. You are \"\n                        \"not higher than the user in the role \"\n                        \"hierarchy.\"\n                    ),\n                )\n            elif guild.me.top_role <= user.top_role or user == guild.owner:\n                return False, _(\"I cannot do that due to Discord hierarchy rules.\")\n\n            toggle = await self.config.guild(guild).dm_on_kickban()\n            if toggle:\n                with contextlib.suppress(discord.HTTPException):\n                    em = discord.Embed(\n                        title=bold(_(\"You have been banned from {guild}.\").format(guild=guild))\n                    )\n                    em.add_field(\n                        name=_(\"**Reason**\"),\n                        value=reason if reason is not None else _(\"No reason was given.\"),\n                        inline=False,\n                    )\n                    await user.send(embed=em)\n\n            ban_type = \"ban\"\n        else:\n            tempbans = await self.config.guild(guild).current_tempbans()\n\n            ban_list = [ban.user.id for ban in await guild.bans()]\n            if user.id in ban_list:\n                if user.id in tempbans:\n                    async with self.config.guild(guild).current_tempbans() as tempbans:\n                        tempbans.remove(user.id)\n                    removed_temp = True\n                else:\n                    return (\n                        False,\n                        _(\"User with ID {user_id} is already banned.\").format(user_id=user.id),\n                    )\n\n            ban_type = \"hackban\"\n\n        audit_reason = get_audit_reason(author, reason)\n\n        queue_entry = (guild.id, user.id)\n        if removed_temp:\n            log.info(\n                \"{}({}) upgraded the tempban for {} to a permaban.\".format(\n                    author.name, author.id, user.id\n                )\n            )\n            success_message = _(\n                \"User with ID {user_id} was upgraded from a temporary to a permanent ban.\"\n            ).format(user_id=user.id)\n        else:\n            username = user.name if hasattr(user, \"name\") else \"Unknown\"\n            try:\n                await guild.ban(user, reason=audit_reason, delete_message_days=days)\n                log.info(\n                    \"{}({}) {}ned {}({}), deleting {} days worth of messages.\".format(\n                        author.name, author.id, ban_type, username, user.id, str(days)\n                    )\n                )\n                success_message = _(\"Done. That felt good.\")\n            except discord.Forbidden:\n                return False, _(\"I'm not allowed to do that.\")\n            except discord.NotFound:\n                return False, _(\"User with ID {user_id} not found\").format(user_id=user.id)\n            except Exception as e:\n                log.exception(\n                    \"{}({}) attempted to {} {}({}), but an error occurred.\".format(\n                        author.name, author.id, ban_type, username, user.id\n                    )\n                )\n                return False, _(\"An unexpected error occurred.\")\n\n        if create_modlog_case:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                ban_type,\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n\n        return True, success_message\n\n    async def check_tempban_expirations(self):\n        while self == self.bot.get_cog(\"Mod\"):\n            async for guild in AsyncIter(self.bot.guilds, steps=100):\n                if not guild.me.guild_permissions.ban_members:\n                    continue\n\n                if await self.bot.cog_disabled_in_guild(self, guild):\n                    continue\n\n                async with self.config.guild(guild).current_tempbans() as guild_tempbans:\n                    for uid in guild_tempbans.copy():\n                        unban_time = datetime.fromtimestamp(\n                            await self.config.member_from_ids(guild.id, uid).banned_until(),\n                            timezone.utc,\n                        )\n                        if datetime.now(timezone.utc) > unban_time:  # Time to unban the user\n                            queue_entry = (guild.id, uid)\n                            try:\n                                await guild.unban(\n                                    discord.Object(id=uid), reason=_(\"Tempban finished\")\n                                )\n                            except discord.NotFound:\n                                # user is not banned anymore\n                                guild_tempbans.remove(uid)\n                            except discord.HTTPException as e:\n                                # 50013: Missing permissions error code or 403: Forbidden status\n                                if e.code == 50013 or e.status == 403:\n                                    log.info(\n                                        f\"Failed to unban ({uid}) user from \"\n                                        f\"{guild.name}({guild.id}) guild due to permissions.\"\n                                    )\n                                    break  # skip the rest of this guild\n                                log.info(f\"Failed to unban member: error code: {e.code}\")\n                            else:\n                                # user unbanned successfully\n                                guild_tempbans.remove(uid)\n            await asyncio.sleep(60)\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(kick_members=True)\n    @checks.admin_or_permissions(kick_members=True)\n    async def kick(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Kick a user.\n\n        If a reason is specified, it will be the reason that shows up\n        in the audit log.\n        \"\"\"\n        author = ctx.author\n        guild = ctx.guild\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {emoji}\").format(\n                    emoji=\"\\N{PENSIVE FACE}\"\n                )\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        elif ctx.guild.me.top_role <= user.top_role or user == ctx.guild.owner:\n            await ctx.send(_(\"I cannot do that due to Discord hierarchy rules.\"))\n            return\n        audit_reason = get_audit_reason(author, reason)\n        toggle = await self.config.guild(guild).dm_on_kickban()\n        if toggle:\n            with contextlib.suppress(discord.HTTPException):\n                em = discord.Embed(\n                    title=bold(_(\"You have been kicked from {guild}.\").format(guild=guild))\n                )\n                em.add_field(\n                    name=_(\"**Reason**\"),\n                    value=reason if reason is not None else _(\"No reason was given.\"),\n                    inline=False,\n                )\n                await user.send(embed=em)\n        try:\n            await guild.kick(user, reason=audit_reason)\n            log.info(\"{}({}) kicked {}({})\".format(author.name, author.id, user.name, user.id))\n        except discord.errors.Forbidden:\n            await ctx.send(_(\"I'm not allowed to do that.\"))\n        except Exception as e:\n            log.exception(\n                \"{}({}) attempted to kick {}({}), but an error occurred.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"kick\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Done. That felt good.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def ban(\n        self,\n        ctx: commands.Context,\n        user: Union[discord.Member, RawUserIds],\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Ban a user from this server and optionally delete days of messages.\n\n        A user ID should be provided if the user is not a member of this server.\n\n        If days is not a number, it's treated as the first word of the reason.\n\n        Minimum 0 days, maximum 7. If not specified, defaultdays setting will be used instead.\"\"\"\n        author = ctx.author\n        guild = ctx.guild\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n        if isinstance(user, int):\n            user = self.bot.get_user(user) or discord.Object(id=user)\n\n        success_, message = await self.ban_user(\n            user=user, ctx=ctx, days=days, reason=reason, create_modlog_case=True\n        )\n\n        await ctx.send(message)\n\n    @commands.command(aliases=[\"hackban\"])\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def massban(\n        self,\n        ctx: commands.Context,\n        user_ids: commands.Greedy[RawUserIds],\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Mass bans user(s) from the server.\n\n        User IDs need to be provided in order to ban\n        using this command.\"\"\"\n        banned = []\n        errors = {}\n        upgrades = []\n\n        async def show_results():\n            text = _(\"Banned {num} users from the server.\").format(\n                num=humanize_number(len(banned))\n            )\n            if errors:\n                text += _(\"\\nErrors:\\n\")\n                text += \"\\n\".join(errors.values())\n            if upgrades:\n                text += _(\n                    \"\\nFollowing user IDs have been upgraded from a temporary to a permanent ban:\\n\"\n                )\n                text += humanize_list(upgrades)\n\n            for p in pagify(text):\n                await ctx.send(p)\n\n        def remove_processed(ids):\n            return [_id for _id in ids if _id not in banned and _id not in errors]\n\n        user_ids = list(set(user_ids))  # No dupes\n\n        author = ctx.author\n        guild = ctx.guild\n\n        if not user_ids:\n            await ctx.send_help()\n            return\n\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n\n        if not (0 <= days <= 7):\n            await ctx.send(_(\"Invalid days. Must be between 0 and 7.\"))\n            return\n\n        if not guild.me.guild_permissions.ban_members:\n            return await ctx.send(_(\"I lack the permissions to do this.\"))\n\n        tempbans = await self.config.guild(guild).current_tempbans()\n\n        ban_list = await guild.bans()\n        for entry in ban_list:\n            for user_id in user_ids:\n                if entry.user.id == user_id:\n                    if user_id in tempbans:\n                        # We need to check if a user is tempbanned here because otherwise they won't be processed later on.\n                        continue\n                    else:\n                        errors[user_id] = _(\"User with ID {user_id} is already banned.\").format(\n                            user_id=user_id\n                        )\n\n        user_ids = remove_processed(user_ids)\n\n        if not user_ids:\n            await show_results()\n            return\n\n        for user_id in user_ids:\n            user = guild.get_member(user_id)\n            if user is not None:\n                if user_id in tempbans:\n                    # We need to check if a user is tempbanned here because otherwise they won't be processed later on.\n                    continue\n                else:\n                    # Instead of replicating all that handling... gets attr from decorator\n                    try:\n                        success, reason = await self.ban_user(\n                            user=user, ctx=ctx, days=days, reason=reason, create_modlog_case=True\n                        )\n                        if success:\n                            banned.append(user_id)\n                        else:\n                            errors[user_id] = _(\"Failed to ban user {user_id}: {reason}\").format(\n                                user_id=user_id, reason=reason\n                            )\n                    except Exception as e:\n                        errors[user_id] = _(\"Failed to ban user {user_id}: {reason}\").format(\n                            user_id=user_id, reason=e\n                        )\n\n        user_ids = remove_processed(user_ids)\n\n        if not user_ids:\n            await show_results()\n            return\n\n        for user_id in user_ids:\n            user = discord.Object(id=user_id)\n            audit_reason = get_audit_reason(author, reason)\n            queue_entry = (guild.id, user_id)\n            async with self.config.guild(guild).current_tempbans() as tempbans:\n                if user_id in tempbans:\n                    tempbans.remove(user_id)\n                    upgrades.append(str(user_id))\n                    log.info(\n                        \"{}({}) upgraded the tempban for {} to a permaban.\".format(\n                            author.name, author.id, user_id\n                        )\n                    )\n                    banned.append(user_id)\n                else:\n                    try:\n                        await guild.ban(user, reason=audit_reason, delete_message_days=days)\n                        log.info(\"{}({}) hackbanned {}\".format(author.name, author.id, user_id))\n                    except discord.NotFound:\n                        errors[user_id] = _(\"User with ID {user_id} not found\").format(\n                            user_id=user_id\n                        )\n                        continue\n                    except discord.Forbidden:\n                        errors[user_id] = _(\n                            \"Could not ban user with ID {user_id}: missing permissions.\"\n                        ).format(user_id=user_id)\n                        continue\n                    else:\n                        banned.append(user_id)\n\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"hackban\",\n                user_id,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n        await show_results()\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def tempban(\n        self,\n        ctx: commands.Context,\n        user: discord.Member,\n        duration: Optional[commands.TimedeltaConverter] = None,\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Temporarily ban a user from this server.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {}\").format(\"\\N{PENSIVE FACE}\")\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        elif guild.me.top_role <= user.top_role or user == guild.owner:\n            await ctx.send(_(\"I cannot do that due to Discord hierarchy rules.\"))\n            return\n\n        if duration is None:\n            duration = timedelta(seconds=await self.config.guild(guild).default_tempban_duration())\n        unban_time = datetime.now(timezone.utc) + duration\n\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n\n        if not (0 <= days <= 7):\n            await ctx.send(_(\"Invalid days. Must be between 0 and 7.\"))\n            return\n        invite = await self.get_invite_for_reinvite(ctx, int(duration.total_seconds() + 86400))\n        if invite is None:\n            invite = \"\"\n\n        queue_entry = (guild.id, user.id)\n        await self.config.member(user).banned_until.set(unban_time.timestamp())\n        async with self.config.guild(guild).current_tempbans() as current_tempbans:\n            current_tempbans.append(user.id)\n\n        with contextlib.suppress(discord.HTTPException):\n            # We don't want blocked DMs preventing us from banning\n            msg = _(\"You have been temporarily banned from {server_name} until {date}.\").format(\n                server_name=guild.name, date=unban_time.strftime(\"%m-%d-%Y %H:%M:%S\")\n            )\n            if invite:\n                msg += _(\" Here is an invite for when your ban expires: {invite_link}\").format(\n                    invite_link=invite\n                )\n            await user.send(msg)\n        try:\n            await guild.ban(user, reason=reason, delete_message_days=days)\n        except discord.Forbidden:\n            await ctx.send(_(\"I can't do that for some reason.\"))\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while banning.\"))\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"tempban\",\n                user,\n                author,\n                reason,\n                unban_time,\n            )\n            await ctx.send(_(\"Done. Enough chaos for now.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def softban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Kick a user and delete 1 day's worth of their messages.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {emoji}\").format(\n                    emoji=\"\\N{PENSIVE FACE}\"\n                )\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n\n        audit_reason = get_audit_reason(author, reason)\n\n        invite = await self.get_invite_for_reinvite(ctx)\n        if invite is None:\n            invite = \"\"\n\n        queue_entry = (guild.id, user.id)\n        try:  # We don't want blocked DMs preventing us from banning\n            msg = await user.send(\n                _(\n                    \"You have been banned and \"\n                    \"then unbanned as a quick way to delete your messages.\\n\"\n                    \"You can now join the server again. {invite_link}\"\n                ).format(invite_link=invite)\n            )\n        except discord.HTTPException:\n            msg = None\n        try:\n            await guild.ban(user, reason=audit_reason, delete_message_days=1)\n        except discord.errors.Forbidden:\n            await ctx.send(_(\"My role is not high enough to softban that user.\"))\n            if msg is not None:\n                await msg.delete()\n            return\n        except discord.HTTPException as e:\n            log.exception(\n                \"{}({}) attempted to softban {}({}), but an error occurred trying to ban them.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n            return\n        try:\n            await guild.unban(user)\n        except discord.HTTPException as e:\n            log.exception(\n                \"{}({}) attempted to softban {}({}), but an error occurred trying to unban them.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n            return\n        else:\n            log.info(\n                \"{}({}) softbanned {}({}), deleting 1 day worth \"\n                \"of messages.\".format(author.name, author.id, user.name, user.id)\n            )\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"softban\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Done. Enough chaos.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.mod_or_permissions(move_members=True)\n    async def voicekick(\n        self, ctx: commands.Context, member: discord.Member, *, reason: str = None\n    ):\n        \"\"\"Kick a member from a voice channel.\"\"\"\n        author = ctx.author\n        guild = ctx.guild\n        user_voice_state: discord.VoiceState = member.voice\n\n        if await self._voice_perm_check(ctx, user_voice_state, move_members=True) is False:\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, member):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        case_channel = member.voice.channel\n        # Store this channel for the case channel.\n\n        try:\n            await member.move_to(None)\n        except discord.Forbidden:  # Very unlikely that this will ever occur\n            await ctx.send(_(\"I am unable to kick this member from the voice channel.\"))\n            return\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while attempting to kick that member.\"))\n            return\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"vkick\",\n                member,\n                author,\n                reason,\n                until=None,\n                channel=case_channel,\n            )\n\n    @commands.command()\n    @commands.guild_only()\n    @checks.admin_or_permissions(mute_members=True, deafen_members=True)\n    async def voiceunban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Unban a user from speaking and listening in the server's voice channels.\"\"\"\n        user_voice_state = user.voice\n        if (\n            await self._voice_perm_check(\n                ctx, user_voice_state, deafen_members=True, mute_members=True\n            )\n            is False\n        ):\n            return\n        needs_unmute = True if user_voice_state.mute else False\n        needs_undeafen = True if user_voice_state.deaf else False\n        audit_reason = get_audit_reason(ctx.author, reason)\n        if needs_unmute and needs_undeafen:\n            await user.edit(mute=False, deafen=False, reason=audit_reason)\n        elif needs_unmute:\n            await user.edit(mute=False, reason=audit_reason)\n        elif needs_undeafen:\n            await user.edit(deafen=False, reason=audit_reason)\n        else:\n            await ctx.send(_(\"That user isn't muted or deafened by the server.\"))\n            return\n\n        guild = ctx.guild\n        author = ctx.author\n        await modlog.create_case(\n            self.bot,\n            guild,\n            ctx.message.created_at.replace(tzinfo=timezone.utc),\n            \"voiceunban\",\n            user,\n            author,\n            reason,\n            until=None,\n            channel=None,\n        )\n        await ctx.send(_(\"User is now allowed to speak and listen in voice channels.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @checks.admin_or_permissions(mute_members=True, deafen_members=True)\n    async def voiceban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Ban a user from speaking and listening in the server's voice channels.\"\"\"\n        user_voice_state: discord.VoiceState = user.voice\n        if (\n            await self._voice_perm_check(\n                ctx, user_voice_state, deafen_members=True, mute_members=True\n            )\n            is False\n        ):\n            return\n        needs_mute = True if user_voice_state.mute is False else False\n        needs_deafen = True if user_voice_state.deaf is False else False\n        audit_reason = get_audit_reason(ctx.author, reason)\n        author = ctx.author\n        guild = ctx.guild\n        if needs_mute and needs_deafen:\n            await user.edit(mute=True, deafen=True, reason=audit_reason)\n        elif needs_mute:\n            await user.edit(mute=True, reason=audit_reason)\n        elif needs_deafen:\n            await user.edit(deafen=True, reason=audit_reason)\n        else:\n            await ctx.send(_(\"That user is already muted and deafened server-wide.\"))\n            return\n\n        await modlog.create_case(\n            self.bot,\n            guild,\n            ctx.message.created_at.replace(tzinfo=timezone.utc),\n            \"voiceban\",\n            user,\n            author,\n            reason,\n            until=None,\n            channel=None,\n        )\n        await ctx.send(_(\"User has been banned from speaking or listening in voice channels.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def unban(self, ctx: commands.Context, user_id: RawUserIds, *, reason: str = None):\n        \"\"\"Unban a user from this server.\n\n        Requires specifying the target user's ID. To find this, you may either:\n         1. Copy it from the mod log case (if one was created), or\n         2. enable developer mode, go to Bans in this server's settings, right-\n        click the user and select 'Copy ID'.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n        audit_reason = get_audit_reason(ctx.author, reason)\n        bans = await guild.bans()\n        bans = [be.user for be in bans]\n        user = discord.utils.get(bans, id=user_id)\n        if not user:\n            await ctx.send(_(\"It seems that user isn't banned!\"))\n            return\n        queue_entry = (guild.id, user_id)\n        try:\n            await guild.unban(user, reason=audit_reason)\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while attempting to unban that user.\"))\n            return\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"unban\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Unbanned that user from this server.\"))\n\n        if await self.config.guild(guild).reinvite_on_unban():\n            user = ctx.bot.get_user(user_id)\n            if not user:\n                await ctx.send(\n                    _(\"I don't share another server with this user. I can't reinvite them.\")\n                )\n                return\n\n            invite = await self.get_invite_for_reinvite(ctx)\n            if invite:\n                try:\n                    await user.send(\n                        _(\n                            \"You've been unbanned from {server}.\\n\"\n                            \"Here is an invite for that server: {invite_link}\"\n                        ).format(server=guild.name, invite_link=invite.url)\n                    )\n                except discord.Forbidden:\n                    await ctx.send(\n                        _(\n                            \"I failed to send an invite to that user. \"\n                            \"Perhaps you may be able to send it for me?\\n\"\n                            \"Here's the invite link: {invite_link}\"\n                        ).format(invite_link=invite.url)\n                    )\n                except discord.HTTPException:\n                    await ctx.send(\n                        _(\n                            \"Something went wrong when attempting to send that user\"\n                            \"an invite. Here's the link so you can try: {invite_link}\"\n                        ).format(invite_link=invite.url)\n                    )\n"], "fixing_code": [".. 3.4.x Changelogs\n\nRedbot 3.4.1 (2020-10-27)\n=========================\n\n| Thanks to all these amazing people that contributed to this release:\n| :ghuser:`absj30`, :ghuser:`aikaterna`, :ghuser:`bobloy`, :ghuser:`chloecormier`, :ghuser:`Dav-Git`, :ghuser:`Drapersniper`, :ghuser:`fixator10`, :ghuser:`Flame442`, :ghuser:`flaree`, :ghuser:`Generaleoley`, :ghuser:`hisztendahl`, :ghuser:`jack1142`, :ghuser:`KaiGucci`, :ghuser:`Kowlin`, :ghuser:`maxbooiii`, :ghuser:`MeatyChunks`, :ghuser:`NeuroAssassin`, :ghuser:`nfitzen`, :ghuser:`palmtree5`, :ghuser:`phenom4n4n`, :ghuser:`PredaaA`, :ghuser:`Predeactor`, :ghuser:`PythonTryHard`, :ghuser:`SharkyTheKing`, :ghuser:`Stonedestroyer`, :ghuser:`thisisjvgrace`, :ghuser:`TrustyJAID`, :ghuser:`TurnrDev`, :ghuser:`Vexed01`, :ghuser:`Vuks69`, :ghuser:`xBlynd`, :ghuser:`zephyrkul`\n\nRead before updating\n--------------------\n\n1. This release fixes a security issue in Mod cog. See `Security changelog below <important-341-2>` for more information.\n2. This Red update bumps discord.py to version 1.5.1, which explicitly requests Discord intents. Red requires all Prvileged Intents to be enabled. More information can be found at :ref:`enabling-privileged-intents`.\n3. Mutes functionality has been moved from the Mod cog to a new separate cog (Mutes) featuring timed and role-based mutes. If you were using it (or want to start now), you can load the new cog with ``[p]load mutes``. You can see the full `Mutes changelog below <important-341-1>`.\n4. Information for Audio users that are using an external Lavalink instance (if you don't know what that is, you should skip this point):\n\n   We've updated our `application.yml file <https://github.com/Cog-Creators/Red-DiscordBot/blob/3.4.1/redbot/cogs/audio/data/application.yml>`_ and you should update your instance's ``application.yml`` appropriately.\n   Please ensure that the WS port in Audio's settings (``[p]llset wsport``) is set to the port from the ``application.yml``.\n\nEnd-user changelog\n------------------\n\n.. _important-341-2:\n\nSecurity\n********\n\n**NOTE:** If you can't update immediately, we recommend globally disabling the affected command until you can.\n\n- **Mod** - Fixed unauthorized privilege escalation exploit in ``[p]massban`` (also called ``[p]hackban``) command. Full security advisory `can be found on our GitHub <https://github.com/Cog-Creators/Red-DiscordBot/security/advisories/GHSA-mp9m-g7qj-6vqr>`_.\n\nCore Bot\n********\n\n- Fixed an incorrect error being reported on ``[p]set name`` when the passed name was longer than 32 characters (:issue:`4364`, :issue:`4363`)\n- Fixed ``[p]set nickname`` erroring when the passed name was longer than 32 characters (:issue:`4364`, :issue:`4363`)\n- Fixed an ungraceful error being raised when running ``[p]traceback`` with closed DMs (:issue:`4329`)\n- Fixed errors that could arise from invalid URLs in ``[p]set avatar`` (:issue:`4437`)\n- Fixed an error being raised with ``[p]set nickname`` when no nickname was provided (:issue:`4451`)\n- Fixed and clarified errors being raised with ``[p]set username`` (:issue:`4463`)\n- Fixed an ungraceful error being raised when the output of ``[p]unload`` is larger than 2k characters (:issue:`4469`)\n- Fixed an ungraceful error being raised when running ``[p]choose`` with empty options (:issue:`4499`)\n- Fixed an ungraceful error being raised when a bot left a guild while a menu was open (:issue:`3902`)\n- Fixed info missing on the non-embed version of ``[p]debuginfo`` (:issue:`4524`)\n- Added ``[p]set api list`` to list all currently set API services, without tokens (:issue:`4370`)\n- Added ``[p]set api remove`` to remove API services, including tokens (:issue:`4370`)\n- Added ``[p]helpset usetick``, toggling command message being ticked when help is sent to DM (:issue:`4467`, :issue:`4075`)\n- Added a default color field to ``[p]set showsettings`` (:issue:`4498`, :issue:`4497`)\n- Added the datapath and metadata file to ``[p]debuginfo`` (:issue:`4524`)\n- Added a list of disabled intents to ``[p]debuginfo`` (:issue:`4423`)\n- Bumped discord.py dependency to version 1.5.1 (:issue:`4423`)\n- Locales and regional formats can now be set in individual guilds using ``[p]set locale`` and ``[p]set regionalformat`` (:issue:`3896`, :issue:`1970`)\n\n    - Global locale and regional format setters have been renamed to ``[p]set globallocale`` and ``[p]set globalregionalformat``\n\nAudio\n*****\n\n- Scattered grammar and typo fixes (:issue:`4446`)\n- Fixed Bandcamp playback (:issue:`4504`)\n- Fixed YouTube playlist playback (:issue:`4504`)\n- Fixed YouTube searching issues (:issue:`4504`)\n- Fixed YouTube age restricted track playback (:issue:`4504`)\n- Fixed the Audio cog not being translated when setting locale (:issue:`4492`, :issue:`4495`)\n- Fixed tracks getting stuck at 0:00 after long player sessions (:issue:`4529`)\n- Removed lavalink logs from being added to backup (:issue:`4453`, :issue:`4452`)\n- Removed stream durations from being in queue duration (:issue:`4513`)\n- Added the Global Audio API, to cut down on Youtube 429 errors and allow Spotify playback past user's quota. (:issue:`4446`)\n- Added persistent queues, allowing for queues to be restored on a bot restart or cog reload (:issue:`4446`)\n- Added ``[p]audioset restart``, allowing for Lavalink connection to be restarted (:issue:`4446`)\n- Added ``[p]audioset autodeafen``, allowing for bot to auto-deafen itself when entering voice channel (:issue:`4446`)\n- Added ``[p]audioset mycountrycode``, allowing Spotify search locale per user (:issue:`4446`)\n- Added ``[p]llsetup java``, allowing for a custom Java executable path (:issue:`4446`)\n- Added ``[p]llset info`` to show Lavalink settings (:issue:`4527`)\n- Added ``[p]audioset logs`` to download Lavalink logs if the Lavalink server is set to internal (:issue:`4527`)\n\nCleanup\n*******\n\n- Allowed ``[p]cleanup self`` to work in DMs for all users (:issue:`4481`)\n\nCustom Commands\n***************\n\n- Fixed an ungraceful error being thrown on ``[p]cc edit`` (:issue:`4325`)\n\nDev\n***\n\n- Added ``[p]repl pause`` to pause/resume the REPL session in the current channel (:issue:`4366`)\n\nEconomy\n*******\n\n- Added an embed option for ``[p]leaderboard`` (:issue:`4184`, :issue:`4104`)\n\nGeneral\n*******\n\n- Fixed issues with text not being properly URL encoded (:issue:`4024`)\n- Fixed an ungraceful error occurring when a title is longer than 256 characters in ``[p]urban`` (:issue:`4474`)\n- Changed \"boosters\" to \"boosts\" in ``[p]serverinfo`` to clarify what the number represents (:issue:`4507`)\n\nMod\n***\n\n- Added ``[p]modset mentionspam strict`` allowing for duplicated mentions to count towards the mention spam cap (:issue:`4359`)\n- Added an option to ban users not in the guild to ``[p]ban`` (:issue:`4422`, :issue:`4419`)\n- Added a default tempban duration for ``[p]tempban`` (:issue:`4473`, :issue:`3992`)\n- Fixed nicknames not being properly stored and logged (:issue:`4131`)\n- Fixed plural typos in ``[p]userinfo`` (:issue:`4397`, :issue:`4379`)\n- Renamed ``[p]hackban`` to ``[p]massban``, keeping ``[p]hackban`` as an alias, allowing for multiple users to be banned at once (:issue:`4422`, :issue:`4419`)\n- Moved mutes to a separate, individual cog (:issue:`3634`)\n\n.. _important-341-1:\n\nMutes\n*****\n\n- Added ``[p]muteset forcerole`` to make mutes role based, instead of permission based (:issue:`3634`)\n- Added an optional time argument to all mutes, to specify when the user should be unmuted (:issue:`3634`)\n- Changed ``[p]mute`` to only handle serverwide muting, ``[p]mute voice`` and ``[p]mute channel`` have been moved to separate commands called ``[p]mutechannel`` and ``[p]mutevoice`` (:issue:`3634`)\n- Mute commands can now take multiple user arguments, to mute multiple users at a time (:issue:`3634`)\n\nModlog\n******\n\n- Fixed an error being raised when running ``[p]casesfor`` and ``[p]case`` (:issue:`4415`)\n- Long reasons in Modlog are now properly shortened in message content (:issue:`4541`)\n\nTrivia Lists\n************\n\n- Fixed incorrect order of Machamp and Machoke questions (:issue:`4424`)\n- Added new MLB trivia list (:issue:`4455`)\n- Added new Who's That Pok\u00e9mon - Gen. IV trivia list (:issue:`4434`)\n- Added new Hockey trivia list (:issue:`4384`)\n\nWarnings\n********\n\n- Fixed users being able to warn users above them in hierarchy (:issue:`4100`)\n- Added bool arguments to toggle commands to improve consistency (:issue:`4409`)\n\nDeveloper changelog\n-------------------\n\n| **Important:**\n| 1. Red now allows users to set locale per guild, which requires 3rd-party cogs to set contextual locale manually in code ran outside of command's context. See the `Core Bot changelog below <important-dev-341-1>` for more information.\n\n.. _important-dev-341-1:\n\nCore Bot\n********\n\n- Added API for setting contextual locales (:issue:`3896`, :issue:`1970`)\n\n    - New function added: `redbot.core.i18n.set_contextual_locales_from_guild()`\n    - Contextual locale is automatically set for commands and only needs to be done manually for things like event listeners; see `guidelines-for-cog-creators` for more information\n\n- Added `bot.remove_shared_api_services() <RedBase.remove_shared_api_services()>` to remove all keys and tokens associated with an API service (:issue:`4370`)\n- Added an option to return all tokens for an API service if ``service_name`` is not specified in `bot.get_shared_api_tokens() <RedBase.get_shared_api_tokens()>` (:issue:`4370`)\n- Added `bot.get_or_fetch_user() <RedBase.get_or_fetch_user()>` and `bot.get_or_fetch_member() <RedBase.get_or_fetch_member()>` methods (:issue:`4403`, :issue:`4402`)\n- Moved ``redbot.core.checks.bot_in_a_guild()`` to `redbot.core.commands.bot_in_a_guild()` (old name has been left as an alias) (:issue:`4515`, :issue:`4510`)\n\nBank\n****\n\n- Bank API methods now consistently throw TypeError if a non-integer amount is supplied (:issue:`4376`)\n\nMod\n***\n\n- Deprecated ``redbot.core.utils.mod.is_allowed_by_hierarchy`` (:issue:`4435`)\n\nModlog\n******\n\n- Added an option to accept a ``discord.Object`` in case creation (:issue:`4326`)\n- Added ``last_known_username`` parameter to `modlog.create_case()` function (:issue:`4326`)\n- Fixed an error being raised with a deleted channel in `Case.message_content()` (:issue:`4415`)\n\nUtility\n*******\n\n- Added `redbot.core.utils.get_end_user_data_statement()` and `redbot.core.utils.get_end_user_data_statement_or_raise()` to attempt to fetch a cog's End User Data Statement (:issue:`4404`)\n- Added `redbot.core.utils.chat_formatting.quote()` to quote text in a message (:issue:`4425`)\n\nDocumentation changes\n---------------------\n\nConfig\n******\n\n- Added custom group documentation and tutorial (:issue:`4416`, :issue:`2896`)\n\nModlog\n******\n\n- Clarified that naive ``datetime`` objects will be treated as local times for parameters ``created_at`` and ``until`` in `modlog.create_case()` (:issue:`4389`)\n\nOther\n*****\n\n- Added guide to creating a Bot Application in Discord Developer Portal, with enabling intents (:issue:`4502`)\n\nMiscellaneous\n-------------\n\n- Added JSON schema files for ``info.json`` files (:issue:`4375`)\n- Added ``[all]`` and ``[dev]`` bundled install extras (:issue:`4443`)\n- Replaced the link to the approved repository list on CogBoard and references to ``cogs.red`` with a link to new Red Index (:issue:`4439`)\n- Improved documentation about arguments in command syntax (:issue:`4058`)\n- Replaced a few instances of Red with the bot name in command docstrings (:issue:`4470`)\n- Fixed grammar in places scattered throughout bot (:issue:`4500`)\n- Properly define supported Python versions to be lower than 3.9 (:issue:`4538`)\n\n\nRedbot 3.4.0 (2020-08-17)\n=========================\n\n| Thanks to all these amazing people that contributed to this release:\n| :ghuser:`Dav-Git`, :ghuser:`DevilXD`, :ghuser:`douglas-cpp`, :ghuser:`Drapersniper`, :ghuser:`flaree`, :ghuser:`jack1142`, :ghuser:`kablekompany`, :ghuser:`Kowlin`, :ghuser:`maxbooiii`, :ghuser:`MeatyChunks`, :ghuser:`mikeshardmind`, :ghuser:`NeuroAssassin`, :ghuser:`PredaaA`, :ghuser:`Predeactor`, :ghuser:`retke`, :ghuser:`SharkyTheKing`, :ghuser:`thisisjvgrace`, :ghuser:`Tinonb`, :ghuser:`TrustyJAID`, :ghuser:`Twentysix26`, :ghuser:`Vexed01`, :ghuser:`zephyrkul`\n|\n| **Read before updating**:\n| 1. Red 3.4 comes with support for data deletion requests. Bot owners should read `red_core_data_statement` to ensure they know what information about their users is stored by the bot.\n| 2. Debian Stretch, Fedora 30 and lower, and OpenSUSE Leap 15.0 and lower are no longer supported as they have already reached end of life.\n| 3. There's been a change in behavior of ``[p]tempban``. Look at `Mod changelog <important-340-1>` for full details.\n| 4. There's been a change in behavior of announcements in Admin cog. Look at `Admin changelog <important-340-2>` for full details.\n| 5. Red 3.4 comes with breaking changes for cog developers. Look at `Developer changelog <important-340-3>` for full details.\n\nEnd-user changelog\n------------------\n\nCore Bot\n********\n\n- Added per-guild cog disabling (:issue:`4043`, :issue:`3945`)\n\n    - Bot owners can set the default state for a cog using ``[p]command defaultdisablecog`` and ``[p]command defaultenablecog`` commands\n    - Guild owners can enable/disable cogs for their guild using ``[p]command disablecog`` and ``[p]command enablecog`` commands\n    - Cogs disabled in the guild can be listed with ``[p]command listdisabledcogs``\n\n- Added support for data deletion requests; see `red_core_data_statement` for more information (:issue:`4045`)\n- Red now logs clearer error if it can't find package to load in any cog path during bot startup (:issue:`4079`)\n- ``[p]licenseinfo`` now has a 3 minute cooldown to prevent a single user from spamming channel by using it (:issue:`4110`)\n- Added ``[p]helpset showsettings`` command (:issue:`4013`, :issue:`4022`)\n- Updated Red's emoji usage to ensure consistent rendering accross different devices (:issue:`4106`, :issue:`4105`, :issue:`4127`)\n- Whitelist and blacklist are now called allowlist and blocklist. Old names have been left as aliases (:issue:`4138`)\n\n.. _important-340-2:\n\nAdmin\n*****\n\n- ``[p]announce`` will now only send announcements to guilds that have explicitly configured text channel to send announcements to using ``[p]announceset channel`` command (:issue:`4088`, :issue:`4089`)\n\nDownloader\n**********\n\n- ``[p]cog info`` command now shows end user data statement made by the cog creator (:issue:`4169`)\n- ``[p]cog update`` command will now notify the user if cog's end user data statement has changed since last update (:issue:`4169`)\n\n.. _important-340-1:\n\nMod\n***\n\n- ``[p]tempban`` now respects default days setting (``[p]modset defaultdays``) (:issue:`3993`)\n- Users can now set mention spam triggers which will warn or kick the user. See ``[p]modset mentionspam`` for more information (:issue:`3786`, :issue:`4038`)\n- ``[p]mute voice`` and ``[p]unmute voice`` now take action instantly if bot has Move Members permission (:issue:`4064`)\n- Added typing to ``[p](un)mute guild`` to indicate that mute is being processed (:issue:`4066`, :issue:`4172`)\n\nModLog\n******\n\n- Added timestamp to text version of ``[p]casesfor`` and ``[p]case`` commands (:issue:`4118`, :issue:`4137`)\n\nStreams\n*******\n\n- Stream alerts will no longer make roles temporarily mentionable if bot has \"Mention @everyone, @here, and All Roles\" permission in the channel (:issue:`4182`)\n- Mixer service has been closed and for that reason we've removed support for it from the cog (:issue:`4072`)\n- Hitbox commands have been renamed to smashcast (:issue:`4161`)\n- Improve error messages for invalid channel names/IDs (:issue:`4147`, :issue:`4148`)\n\nTrivia Lists\n************\n\n- Added ``whosthatpokemon2`` trivia containing Pok\u00e9mons from 2nd generation (:issue:`4102`)\n- Added ``whosthatpokemon3`` trivia containing Pok\u00e9mons from 3rd generation (:issue:`4141`)\n\n.. _important-340-3:\n\nDeveloper changelog\n-------------------\n\n| **Important:**\n| 1. Red now offers cog disabling API, which should be respected by 3rd-party cogs in guild-related actions happening outside of command's context. See the `Core Bot changelog below <important-dev-340-1>` for more information.\n| 2. Red now provides data request API, which should be supported by all 3rd-party cogs. See the changelog entries in the `Core Bot changelog below <important-dev-340-1>` for more information.\n\nBreaking changes\n****************\n\n- By default, none of the ``.send()`` methods mention roles or ``@everyone/@here`` (:issue:`3845`)\n\n    - see `discord.AllowedMentions` and ``allowed_mentions`` kwarg of ``.send()`` methods, if your cog requires to mention roles or ``@everyone/@here``\n\n- `Context.maybe_send_embed()` now supresses all mentions, including user mentions (:issue:`4192`)\n- The default value of the ``filter`` keyword argument has been changed to ``None`` (:issue:`3845`)\n- Cog package names (i.e. name of the folder the cog is in and the name used when loading the cog) now have to be `valid Python identifiers <https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`_ (:issue:`3605`, :issue:`3679`)\n- Method/attribute names starting with ``red_`` or being in the form of ``__red_*__`` are now reserved. See `version_guarantees` for more information (:issue:`4085`)\n- `humanize_list()` no longer raises `IndexError` for empty sequences (:issue:`2982`)\n- Removed things past deprecation time: (:issue:`4163`)\n\n    - ``redbot.core.commands.APIToken``\n    - ``loop`` kwarg from `bounded_gather_iter()`, `bounded_gather()`, and `start_adding_reactions()`\n\n.. _important-dev-340-1:\n\nCore Bot\n********\n\n- Added cog disabling API (:issue:`4043`, :issue:`3945`)\n\n    - New methods added: `bot.cog_disabled_in_guild() <RedBase.cog_disabled_in_guild()>`, `bot.cog_disabled_in_guild_raw() <RedBase.cog_disabled_in_guild_raw()>`\n    - Cog disabling is automatically applied for commands and only needs to be done manually for things like event listeners; see `guidelines-for-cog-creators` for more information\n\n- Added data request API (:issue:`4045`,  :issue:`4169`)\n\n    - New special methods added to `commands.Cog`: `red_get_data_for_user()` (documented provisionally), `red_delete_data_for_user()`\n    - New special module level variable added: ``__red_end_user_data_statement__``\n    - These methods and variables should be added by all cogs according to their documentation; see `guidelines-for-cog-creators` for more information\n    - New ``info.json`` key added: ``end_user_data_statement``; see `Info.json format documentation <info-json-format>` for more information\n\n- Added `bot.message_eligible_as_command() <RedBase.message_eligible_as_command()>` utility method which can be used to determine if a message may be responded to as a command (:issue:`4077`)\n- Added a provisional API for replacing the help formatter. See `documentation <framework-commands-help>` for more details (:issue:`4011`)\n- `bot.ignored_channel_or_guild() <RedBase.ignored_channel_or_guild()>` now accepts `discord.Message` objects (:issue:`4077`)\n- `commands.NoParseOptional <NoParseOptional>` is no longer provisional and is now fully supported part of API (:issue:`4142`)\n- Red no longer fails to run subcommands of a command group allowed or denied by permission hook (:issue:`3956`)\n- Autohelp in group commands is now sent *after* invoking the group, which allows before invoke hooks to prevent autohelp from getting triggered (:issue:`4129`)\n- RPC functionality no longer makes Red hang for a minute on shutdown (:issue:`4134`, :issue:`4143`)\n\nVendored packages\n*****************\n\n- Updated ``discord.ext.menus`` vendor (:issue:`4167`)\n\nUtility Functions\n*****************\n\n- `humanize_list()` now accepts ``locale`` and ``style`` keyword arguments. See its documentation for more information (:issue:`2982`)\n- `humanize_list()` is now properly localized (:issue:`2906`, :issue:`2982`)\n- `humanize_list()` now accepts empty sequences (:issue:`2982`)\n\n\nDocumentation changes\n---------------------\n\n- Removed install instructions for Debian Stretch (:issue:`4099`)\n- Added admin user guide (:issue:`3081`)\n- Added alias user guide (:issue:`3084`)\n- Added bank user guide (:issue:`4149`)\n\n\nMiscellaneous\n-------------\n\n- Updated features list in ``[p]serverinfo`` with the latest changes from Discord (:issue:`4116`)\n- Simple version of ``[p]serverinfo`` now shows info about more detailed ``[p]serverinfo 1`` (:issue:`4121`)\n- ``[p]set nickname``, ``[p]set serverprefix``, ``[p]streamalert``, and ``[p]streamset`` commands now can be run by users with permissions related to the actions they're making (:issue:`4109`)\n- `bordered()` now uses ``+`` for corners if keyword argument ``ascii_border`` is set to `True` (:issue:`4097`)\n- Fixed timestamp storage in few places in Red (:issue:`4017`)\n", "import asyncio\nimport contextlib\nimport logging\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Dict, List, Optional, Tuple, Union\n\nimport discord\nfrom redbot.core import commands, i18n, checks, modlog\nfrom redbot.core.commands import UserInputOptional\nfrom redbot.core.utils import AsyncIter\nfrom redbot.core.utils.chat_formatting import (\n    pagify,\n    humanize_number,\n    bold,\n    humanize_list,\n    format_perms_list,\n)\nfrom redbot.core.utils.mod import get_audit_reason\nfrom .abc import MixinMeta\nfrom .converters import RawUserIds\nfrom .utils import is_allowed_by_hierarchy\n\nlog = logging.getLogger(\"red.mod\")\n_ = i18n.Translator(\"Mod\", __file__)\n\n\nclass KickBanMixin(MixinMeta):\n    \"\"\"\n    Kick and ban commands and tasks go here.\n    \"\"\"\n\n    @staticmethod\n    async def get_invite_for_reinvite(ctx: commands.Context, max_age: int = 86400):\n        \"\"\"Handles the reinvite logic for getting an invite\n        to send the newly unbanned user\n        :returns: :class:`Invite`\"\"\"\n        guild = ctx.guild\n        my_perms: discord.Permissions = guild.me.guild_permissions\n        if my_perms.manage_guild or my_perms.administrator:\n            if \"VANITY_URL\" in guild.features:\n                # guild has a vanity url so use it as the one to send\n                return await guild.vanity_invite()\n            invites = await guild.invites()\n        else:\n            invites = []\n        for inv in invites:  # Loop through the invites for the guild\n            if not (inv.max_uses or inv.max_age or inv.temporary):\n                # Invite is for the guild's default channel,\n                # has unlimited uses, doesn't expire, and\n                # doesn't grant temporary membership\n                # (i.e. they won't be kicked on disconnect)\n                return inv\n        else:  # No existing invite found that is valid\n            channels_and_perms = zip(\n                guild.text_channels, map(guild.me.permissions_in, guild.text_channels)\n            )\n            channel = next(\n                (channel for channel, perms in channels_and_perms if perms.create_instant_invite),\n                None,\n            )\n            if channel is None:\n                return\n            try:\n                # Create invite that expires after max_age\n                return await channel.create_invite(max_age=max_age)\n            except discord.HTTPException:\n                return\n\n    @staticmethod\n    async def _voice_perm_check(\n        ctx: commands.Context, user_voice_state: Optional[discord.VoiceState], **perms: bool\n    ) -> bool:\n        \"\"\"Check if the bot and user have sufficient permissions for voicebans.\n\n        This also verifies that the user's voice state and connected\n        channel are not ``None``.\n\n        Returns\n        -------\n        bool\n            ``True`` if the permissions are sufficient and the user has\n            a valid voice state.\n\n        \"\"\"\n        if user_voice_state is None or user_voice_state.channel is None:\n            await ctx.send(_(\"That user is not in a voice channel.\"))\n            return False\n        voice_channel: discord.VoiceChannel = user_voice_state.channel\n        required_perms = discord.Permissions()\n        required_perms.update(**perms)\n        if not voice_channel.permissions_for(ctx.me) >= required_perms:\n            await ctx.send(\n                _(\"I require the {perms} permission(s) in that user's channel to do that.\").format(\n                    perms=format_perms_list(required_perms)\n                )\n            )\n            return False\n        if (\n            ctx.permission_state is commands.PermState.NORMAL\n            and not voice_channel.permissions_for(ctx.author) >= required_perms\n        ):\n            await ctx.send(\n                _(\n                    \"You must have the {perms} permission(s) in that user's channel to use this \"\n                    \"command.\"\n                ).format(perms=format_perms_list(required_perms))\n            )\n            return False\n        return True\n\n    async def ban_user(\n        self,\n        user: Union[discord.Member, discord.User, discord.Object],\n        ctx: commands.Context,\n        days: int = 0,\n        reason: str = None,\n        create_modlog_case=False,\n    ) -> Tuple[bool, str]:\n        author = ctx.author\n        guild = ctx.guild\n\n        removed_temp = False\n\n        if not (0 <= days <= 7):\n            return False, _(\"Invalid days. Must be between 0 and 7.\")\n\n        if isinstance(user, discord.Member):\n            if author == user:\n                return (\n                    False,\n                    _(\"I cannot let you do that. Self-harm is bad {}\").format(\"\\N{PENSIVE FACE}\"),\n                )\n            elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n                return (\n                    False,\n                    _(\n                        \"I cannot let you do that. You are \"\n                        \"not higher than the user in the role \"\n                        \"hierarchy.\"\n                    ),\n                )\n            elif guild.me.top_role <= user.top_role or user == guild.owner:\n                return False, _(\"I cannot do that due to Discord hierarchy rules.\")\n\n            toggle = await self.config.guild(guild).dm_on_kickban()\n            if toggle:\n                with contextlib.suppress(discord.HTTPException):\n                    em = discord.Embed(\n                        title=bold(_(\"You have been banned from {guild}.\").format(guild=guild))\n                    )\n                    em.add_field(\n                        name=_(\"**Reason**\"),\n                        value=reason if reason is not None else _(\"No reason was given.\"),\n                        inline=False,\n                    )\n                    await user.send(embed=em)\n\n            ban_type = \"ban\"\n        else:\n            tempbans = await self.config.guild(guild).current_tempbans()\n\n            ban_list = [ban.user.id for ban in await guild.bans()]\n            if user.id in ban_list:\n                if user.id in tempbans:\n                    async with self.config.guild(guild).current_tempbans() as tempbans:\n                        tempbans.remove(user.id)\n                    removed_temp = True\n                else:\n                    return (\n                        False,\n                        _(\"User with ID {user_id} is already banned.\").format(user_id=user.id),\n                    )\n\n            ban_type = \"hackban\"\n\n        audit_reason = get_audit_reason(author, reason)\n\n        queue_entry = (guild.id, user.id)\n        if removed_temp:\n            log.info(\n                \"{}({}) upgraded the tempban for {} to a permaban.\".format(\n                    author.name, author.id, user.id\n                )\n            )\n            success_message = _(\n                \"User with ID {user_id} was upgraded from a temporary to a permanent ban.\"\n            ).format(user_id=user.id)\n        else:\n            username = user.name if hasattr(user, \"name\") else \"Unknown\"\n            try:\n                await guild.ban(user, reason=audit_reason, delete_message_days=days)\n                log.info(\n                    \"{}({}) {}ned {}({}), deleting {} days worth of messages.\".format(\n                        author.name, author.id, ban_type, username, user.id, str(days)\n                    )\n                )\n                success_message = _(\"Done. That felt good.\")\n            except discord.Forbidden:\n                return False, _(\"I'm not allowed to do that.\")\n            except discord.NotFound:\n                return False, _(\"User with ID {user_id} not found\").format(user_id=user.id)\n            except Exception as e:\n                log.exception(\n                    \"{}({}) attempted to {} {}({}), but an error occurred.\".format(\n                        author.name, author.id, ban_type, username, user.id\n                    )\n                )\n                return False, _(\"An unexpected error occurred.\")\n\n        if create_modlog_case:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                ban_type,\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n\n        return True, success_message\n\n    async def check_tempban_expirations(self):\n        while self == self.bot.get_cog(\"Mod\"):\n            async for guild in AsyncIter(self.bot.guilds, steps=100):\n                if not guild.me.guild_permissions.ban_members:\n                    continue\n\n                if await self.bot.cog_disabled_in_guild(self, guild):\n                    continue\n\n                async with self.config.guild(guild).current_tempbans() as guild_tempbans:\n                    for uid in guild_tempbans.copy():\n                        unban_time = datetime.fromtimestamp(\n                            await self.config.member_from_ids(guild.id, uid).banned_until(),\n                            timezone.utc,\n                        )\n                        if datetime.now(timezone.utc) > unban_time:  # Time to unban the user\n                            queue_entry = (guild.id, uid)\n                            try:\n                                await guild.unban(\n                                    discord.Object(id=uid), reason=_(\"Tempban finished\")\n                                )\n                            except discord.NotFound:\n                                # user is not banned anymore\n                                guild_tempbans.remove(uid)\n                            except discord.HTTPException as e:\n                                # 50013: Missing permissions error code or 403: Forbidden status\n                                if e.code == 50013 or e.status == 403:\n                                    log.info(\n                                        f\"Failed to unban ({uid}) user from \"\n                                        f\"{guild.name}({guild.id}) guild due to permissions.\"\n                                    )\n                                    break  # skip the rest of this guild\n                                log.info(f\"Failed to unban member: error code: {e.code}\")\n                            else:\n                                # user unbanned successfully\n                                guild_tempbans.remove(uid)\n            await asyncio.sleep(60)\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(kick_members=True)\n    @checks.admin_or_permissions(kick_members=True)\n    async def kick(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Kick a user.\n\n        If a reason is specified, it will be the reason that shows up\n        in the audit log.\n        \"\"\"\n        author = ctx.author\n        guild = ctx.guild\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {emoji}\").format(\n                    emoji=\"\\N{PENSIVE FACE}\"\n                )\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        elif ctx.guild.me.top_role <= user.top_role or user == ctx.guild.owner:\n            await ctx.send(_(\"I cannot do that due to Discord hierarchy rules.\"))\n            return\n        audit_reason = get_audit_reason(author, reason)\n        toggle = await self.config.guild(guild).dm_on_kickban()\n        if toggle:\n            with contextlib.suppress(discord.HTTPException):\n                em = discord.Embed(\n                    title=bold(_(\"You have been kicked from {guild}.\").format(guild=guild))\n                )\n                em.add_field(\n                    name=_(\"**Reason**\"),\n                    value=reason if reason is not None else _(\"No reason was given.\"),\n                    inline=False,\n                )\n                await user.send(embed=em)\n        try:\n            await guild.kick(user, reason=audit_reason)\n            log.info(\"{}({}) kicked {}({})\".format(author.name, author.id, user.name, user.id))\n        except discord.errors.Forbidden:\n            await ctx.send(_(\"I'm not allowed to do that.\"))\n        except Exception as e:\n            log.exception(\n                \"{}({}) attempted to kick {}({}), but an error occurred.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"kick\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Done. That felt good.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def ban(\n        self,\n        ctx: commands.Context,\n        user: Union[discord.Member, RawUserIds],\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Ban a user from this server and optionally delete days of messages.\n\n        A user ID should be provided if the user is not a member of this server.\n\n        If days is not a number, it's treated as the first word of the reason.\n\n        Minimum 0 days, maximum 7. If not specified, defaultdays setting will be used instead.\"\"\"\n        author = ctx.author\n        guild = ctx.guild\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n        if isinstance(user, int):\n            user = self.bot.get_user(user) or discord.Object(id=user)\n\n        success_, message = await self.ban_user(\n            user=user, ctx=ctx, days=days, reason=reason, create_modlog_case=True\n        )\n\n        await ctx.send(message)\n\n    @commands.command(aliases=[\"hackban\"])\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def massban(\n        self,\n        ctx: commands.Context,\n        user_ids: commands.Greedy[RawUserIds],\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Mass bans user(s) from the server.\n\n        User IDs need to be provided in order to ban\n        using this command.\"\"\"\n        banned = []\n        errors = {}\n        upgrades = []\n\n        async def show_results():\n            text = _(\"Banned {num} users from the server.\").format(\n                num=humanize_number(len(banned))\n            )\n            if errors:\n                text += _(\"\\nErrors:\\n\")\n                text += \"\\n\".join(errors.values())\n            if upgrades:\n                text += _(\n                    \"\\nFollowing user IDs have been upgraded from a temporary to a permanent ban:\\n\"\n                )\n                text += humanize_list(upgrades)\n\n            for p in pagify(text):\n                await ctx.send(p)\n\n        def remove_processed(ids):\n            return [_id for _id in ids if _id not in banned and _id not in errors]\n\n        user_ids = list(set(user_ids))  # No dupes\n\n        author = ctx.author\n        guild = ctx.guild\n\n        if not user_ids:\n            await ctx.send_help()\n            return\n\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n\n        if not (0 <= days <= 7):\n            await ctx.send(_(\"Invalid days. Must be between 0 and 7.\"))\n            return\n\n        if not guild.me.guild_permissions.ban_members:\n            return await ctx.send(_(\"I lack the permissions to do this.\"))\n\n        tempbans = await self.config.guild(guild).current_tempbans()\n\n        ban_list = await guild.bans()\n        for entry in ban_list:\n            for user_id in user_ids:\n                if entry.user.id == user_id:\n                    if user_id in tempbans:\n                        # We need to check if a user is tempbanned here because otherwise they won't be processed later on.\n                        continue\n                    else:\n                        errors[user_id] = _(\"User with ID {user_id} is already banned.\").format(\n                            user_id=user_id\n                        )\n\n        user_ids = remove_processed(user_ids)\n\n        if not user_ids:\n            await show_results()\n            return\n\n        # We need to check here, if any of the users isn't a member and if they are,\n        # we need to use our `ban_user()` method to do hierarchy checks.\n        members: Dict[int, discord.Member] = {}\n        to_query: List[int] = []\n\n        for user_id in user_ids:\n            member = guild.get_member(user_id)\n            if member is not None:\n                members[user_id] = member\n            elif not guild.chunked:\n                to_query.append(user_id)\n\n        # If guild isn't chunked, we might possibly be missing the member from cache,\n        # so we need to make sure that isn't the case by querying the user IDs for such guilds.\n        while to_query:\n            queried_members = await guild.query_members(user_ids=to_query[:100], limit=100)\n            members.update((member.id, member) for member in queried_members)\n            to_query = to_query[100:]\n\n        # Call `ban_user()` method for all users that turned out to be guild members.\n        for member in members:\n            try:\n                success, reason = await self.ban_user(\n                    user=member, ctx=ctx, days=days, reason=reason, create_modlog_case=True\n                )\n                if success:\n                    banned.append(user_id)\n                else:\n                    errors[user_id] = _(\"Failed to ban user {user_id}: {reason}\").format(\n                        user_id=user_id, reason=reason\n                    )\n            except Exception as e:\n                errors[user_id] = _(\"Failed to ban user {user_id}: {reason}\").format(\n                    user_id=user_id, reason=e\n                )\n\n        user_ids = remove_processed(user_ids)\n\n        if not user_ids:\n            await show_results()\n            return\n\n        for user_id in user_ids:\n            user = discord.Object(id=user_id)\n            audit_reason = get_audit_reason(author, reason)\n            queue_entry = (guild.id, user_id)\n            async with self.config.guild(guild).current_tempbans() as tempbans:\n                if user_id in tempbans:\n                    tempbans.remove(user_id)\n                    upgrades.append(str(user_id))\n                    log.info(\n                        \"{}({}) upgraded the tempban for {} to a permaban.\".format(\n                            author.name, author.id, user_id\n                        )\n                    )\n                    banned.append(user_id)\n                else:\n                    try:\n                        await guild.ban(user, reason=audit_reason, delete_message_days=days)\n                        log.info(\"{}({}) hackbanned {}\".format(author.name, author.id, user_id))\n                    except discord.NotFound:\n                        errors[user_id] = _(\"User with ID {user_id} not found\").format(\n                            user_id=user_id\n                        )\n                        continue\n                    except discord.Forbidden:\n                        errors[user_id] = _(\n                            \"Could not ban user with ID {user_id}: missing permissions.\"\n                        ).format(user_id=user_id)\n                        continue\n                    else:\n                        banned.append(user_id)\n\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"hackban\",\n                user_id,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n        await show_results()\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def tempban(\n        self,\n        ctx: commands.Context,\n        user: discord.Member,\n        duration: Optional[commands.TimedeltaConverter] = None,\n        days: Optional[int] = None,\n        *,\n        reason: str = None,\n    ):\n        \"\"\"Temporarily ban a user from this server.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {}\").format(\"\\N{PENSIVE FACE}\")\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        elif guild.me.top_role <= user.top_role or user == guild.owner:\n            await ctx.send(_(\"I cannot do that due to Discord hierarchy rules.\"))\n            return\n\n        if duration is None:\n            duration = timedelta(seconds=await self.config.guild(guild).default_tempban_duration())\n        unban_time = datetime.now(timezone.utc) + duration\n\n        if days is None:\n            days = await self.config.guild(guild).default_days()\n\n        if not (0 <= days <= 7):\n            await ctx.send(_(\"Invalid days. Must be between 0 and 7.\"))\n            return\n        invite = await self.get_invite_for_reinvite(ctx, int(duration.total_seconds() + 86400))\n        if invite is None:\n            invite = \"\"\n\n        queue_entry = (guild.id, user.id)\n        await self.config.member(user).banned_until.set(unban_time.timestamp())\n        async with self.config.guild(guild).current_tempbans() as current_tempbans:\n            current_tempbans.append(user.id)\n\n        with contextlib.suppress(discord.HTTPException):\n            # We don't want blocked DMs preventing us from banning\n            msg = _(\"You have been temporarily banned from {server_name} until {date}.\").format(\n                server_name=guild.name, date=unban_time.strftime(\"%m-%d-%Y %H:%M:%S\")\n            )\n            if invite:\n                msg += _(\" Here is an invite for when your ban expires: {invite_link}\").format(\n                    invite_link=invite\n                )\n            await user.send(msg)\n        try:\n            await guild.ban(user, reason=reason, delete_message_days=days)\n        except discord.Forbidden:\n            await ctx.send(_(\"I can't do that for some reason.\"))\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while banning.\"))\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"tempban\",\n                user,\n                author,\n                reason,\n                unban_time,\n            )\n            await ctx.send(_(\"Done. Enough chaos for now.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def softban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Kick a user and delete 1 day's worth of their messages.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n\n        if author == user:\n            await ctx.send(\n                _(\"I cannot let you do that. Self-harm is bad {emoji}\").format(\n                    emoji=\"\\N{PENSIVE FACE}\"\n                )\n            )\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, user):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n\n        audit_reason = get_audit_reason(author, reason)\n\n        invite = await self.get_invite_for_reinvite(ctx)\n        if invite is None:\n            invite = \"\"\n\n        queue_entry = (guild.id, user.id)\n        try:  # We don't want blocked DMs preventing us from banning\n            msg = await user.send(\n                _(\n                    \"You have been banned and \"\n                    \"then unbanned as a quick way to delete your messages.\\n\"\n                    \"You can now join the server again. {invite_link}\"\n                ).format(invite_link=invite)\n            )\n        except discord.HTTPException:\n            msg = None\n        try:\n            await guild.ban(user, reason=audit_reason, delete_message_days=1)\n        except discord.errors.Forbidden:\n            await ctx.send(_(\"My role is not high enough to softban that user.\"))\n            if msg is not None:\n                await msg.delete()\n            return\n        except discord.HTTPException as e:\n            log.exception(\n                \"{}({}) attempted to softban {}({}), but an error occurred trying to ban them.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n            return\n        try:\n            await guild.unban(user)\n        except discord.HTTPException as e:\n            log.exception(\n                \"{}({}) attempted to softban {}({}), but an error occurred trying to unban them.\".format(\n                    author.name, author.id, user.name, user.id\n                )\n            )\n            return\n        else:\n            log.info(\n                \"{}({}) softbanned {}({}), deleting 1 day worth \"\n                \"of messages.\".format(author.name, author.id, user.name, user.id)\n            )\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"softban\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Done. Enough chaos.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.mod_or_permissions(move_members=True)\n    async def voicekick(\n        self, ctx: commands.Context, member: discord.Member, *, reason: str = None\n    ):\n        \"\"\"Kick a member from a voice channel.\"\"\"\n        author = ctx.author\n        guild = ctx.guild\n        user_voice_state: discord.VoiceState = member.voice\n\n        if await self._voice_perm_check(ctx, user_voice_state, move_members=True) is False:\n            return\n        elif not await is_allowed_by_hierarchy(self.bot, self.config, guild, author, member):\n            await ctx.send(\n                _(\n                    \"I cannot let you do that. You are \"\n                    \"not higher than the user in the role \"\n                    \"hierarchy.\"\n                )\n            )\n            return\n        case_channel = member.voice.channel\n        # Store this channel for the case channel.\n\n        try:\n            await member.move_to(None)\n        except discord.Forbidden:  # Very unlikely that this will ever occur\n            await ctx.send(_(\"I am unable to kick this member from the voice channel.\"))\n            return\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while attempting to kick that member.\"))\n            return\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"vkick\",\n                member,\n                author,\n                reason,\n                until=None,\n                channel=case_channel,\n            )\n\n    @commands.command()\n    @commands.guild_only()\n    @checks.admin_or_permissions(mute_members=True, deafen_members=True)\n    async def voiceunban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Unban a user from speaking and listening in the server's voice channels.\"\"\"\n        user_voice_state = user.voice\n        if (\n            await self._voice_perm_check(\n                ctx, user_voice_state, deafen_members=True, mute_members=True\n            )\n            is False\n        ):\n            return\n        needs_unmute = True if user_voice_state.mute else False\n        needs_undeafen = True if user_voice_state.deaf else False\n        audit_reason = get_audit_reason(ctx.author, reason)\n        if needs_unmute and needs_undeafen:\n            await user.edit(mute=False, deafen=False, reason=audit_reason)\n        elif needs_unmute:\n            await user.edit(mute=False, reason=audit_reason)\n        elif needs_undeafen:\n            await user.edit(deafen=False, reason=audit_reason)\n        else:\n            await ctx.send(_(\"That user isn't muted or deafened by the server.\"))\n            return\n\n        guild = ctx.guild\n        author = ctx.author\n        await modlog.create_case(\n            self.bot,\n            guild,\n            ctx.message.created_at.replace(tzinfo=timezone.utc),\n            \"voiceunban\",\n            user,\n            author,\n            reason,\n            until=None,\n            channel=None,\n        )\n        await ctx.send(_(\"User is now allowed to speak and listen in voice channels.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @checks.admin_or_permissions(mute_members=True, deafen_members=True)\n    async def voiceban(self, ctx: commands.Context, user: discord.Member, *, reason: str = None):\n        \"\"\"Ban a user from speaking and listening in the server's voice channels.\"\"\"\n        user_voice_state: discord.VoiceState = user.voice\n        if (\n            await self._voice_perm_check(\n                ctx, user_voice_state, deafen_members=True, mute_members=True\n            )\n            is False\n        ):\n            return\n        needs_mute = True if user_voice_state.mute is False else False\n        needs_deafen = True if user_voice_state.deaf is False else False\n        audit_reason = get_audit_reason(ctx.author, reason)\n        author = ctx.author\n        guild = ctx.guild\n        if needs_mute and needs_deafen:\n            await user.edit(mute=True, deafen=True, reason=audit_reason)\n        elif needs_mute:\n            await user.edit(mute=True, reason=audit_reason)\n        elif needs_deafen:\n            await user.edit(deafen=True, reason=audit_reason)\n        else:\n            await ctx.send(_(\"That user is already muted and deafened server-wide.\"))\n            return\n\n        await modlog.create_case(\n            self.bot,\n            guild,\n            ctx.message.created_at.replace(tzinfo=timezone.utc),\n            \"voiceban\",\n            user,\n            author,\n            reason,\n            until=None,\n            channel=None,\n        )\n        await ctx.send(_(\"User has been banned from speaking or listening in voice channels.\"))\n\n    @commands.command()\n    @commands.guild_only()\n    @commands.bot_has_permissions(ban_members=True)\n    @checks.admin_or_permissions(ban_members=True)\n    async def unban(self, ctx: commands.Context, user_id: RawUserIds, *, reason: str = None):\n        \"\"\"Unban a user from this server.\n\n        Requires specifying the target user's ID. To find this, you may either:\n         1. Copy it from the mod log case (if one was created), or\n         2. enable developer mode, go to Bans in this server's settings, right-\n        click the user and select 'Copy ID'.\"\"\"\n        guild = ctx.guild\n        author = ctx.author\n        audit_reason = get_audit_reason(ctx.author, reason)\n        bans = await guild.bans()\n        bans = [be.user for be in bans]\n        user = discord.utils.get(bans, id=user_id)\n        if not user:\n            await ctx.send(_(\"It seems that user isn't banned!\"))\n            return\n        queue_entry = (guild.id, user_id)\n        try:\n            await guild.unban(user, reason=audit_reason)\n        except discord.HTTPException:\n            await ctx.send(_(\"Something went wrong while attempting to unban that user.\"))\n            return\n        else:\n            await modlog.create_case(\n                self.bot,\n                guild,\n                ctx.message.created_at.replace(tzinfo=timezone.utc),\n                \"unban\",\n                user,\n                author,\n                reason,\n                until=None,\n                channel=None,\n            )\n            await ctx.send(_(\"Unbanned that user from this server.\"))\n\n        if await self.config.guild(guild).reinvite_on_unban():\n            user = ctx.bot.get_user(user_id)\n            if not user:\n                await ctx.send(\n                    _(\"I don't share another server with this user. I can't reinvite them.\")\n                )\n                return\n\n            invite = await self.get_invite_for_reinvite(ctx)\n            if invite:\n                try:\n                    await user.send(\n                        _(\n                            \"You've been unbanned from {server}.\\n\"\n                            \"Here is an invite for that server: {invite_link}\"\n                        ).format(server=guild.name, invite_link=invite.url)\n                    )\n                except discord.Forbidden:\n                    await ctx.send(\n                        _(\n                            \"I failed to send an invite to that user. \"\n                            \"Perhaps you may be able to send it for me?\\n\"\n                            \"Here's the invite link: {invite_link}\"\n                        ).format(invite_link=invite.url)\n                    )\n                except discord.HTTPException:\n                    await ctx.send(\n                        _(\n                            \"Something went wrong when attempting to send that user\"\n                            \"an invite. Here's the link so you can try: {invite_link}\"\n                        ).format(invite_link=invite.url)\n                    )\n"], "filenames": ["docs/changelog_3_4_0.rst", "redbot/cogs/mod/kickban.py"], "buggy_code_start_loc": [12, 5], "buggy_code_end_loc": [20, 465], "fixing_code_start_loc": [12, 5], "fixing_code_end_loc": [31, 478], "type": "CWE-863", "message": "Red Discord Bot before version 3.4.1 has an unauthorized privilege escalation exploit in the Mod module. This exploit allows Discord users with a high privilege level within the guild to bypass hierarchy checks when the application is in a specific condition that is beyond that user's control. By abusing this exploit, it is possible to perform destructive actions within the guild the user has high privileges in. This exploit has been fixed in version 3.4.1. As a workaround, unloading the Mod module with unload mod or, disabling the massban command with command disable global massban can render this exploit not accessible. We still highly recommend updating to 3.4.1 to completely patch this issue.", "other": {"cve": {"id": "CVE-2020-15278", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-28T17:15:12.420", "lastModified": "2020-11-03T13:56:27.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Red Discord Bot before version 3.4.1 has an unauthorized privilege escalation exploit in the Mod module. This exploit allows Discord users with a high privilege level within the guild to bypass hierarchy checks when the application is in a specific condition that is beyond that user's control. By abusing this exploit, it is possible to perform destructive actions within the guild the user has high privileges in. This exploit has been fixed in version 3.4.1. As a workaround, unloading the Mod module with unload mod or, disabling the massban command with command disable global massban can render this exploit not accessible. We still highly recommend updating to 3.4.1 to completely patch this issue."}, {"lang": "es", "value": "Red Discord Bot versiones anteriores a 3.4.1, presenta una explotaci\u00f3n de escalada de privilegios no autorizada en el m\u00f3dulo Mod. Esta explotaci\u00f3n permite a usuarios de Discord con un alto nivel de privilegios dentro del gremio omitir una comprobaci\u00f3n de jerarqu\u00eda cuando la aplicaci\u00f3n est\u00e1 en una condici\u00f3n espec\u00edfica que se encuentra fuera del control de ese usuario. Al abusar de esta explotaci\u00f3n, es posible llevar a cabo acciones destructivas dentro del gremio en el que el usuario presenta altos privilegios. Esta explotaci\u00f3n ha sido corregida en la versi\u00f3n 3.4.1. Como soluci\u00f3n alternativa, descargar el m\u00f3dulo Mod con unload mod o, desactivar el comando massban con el comando disable global massban puede hacer que esta explotaci\u00f3n no sea accesible. Seguimos recomendando encarecidamente actualizar a versi\u00f3n 3.4.1 para parchear completamente este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cogboard:red_discord_bot:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.1", "matchCriteriaId": "0CDC0C00-B046-47B8-9166-DB25A03119AA"}]}]}], "references": [{"url": "https://github.com/Cog-Creators/Red-DiscordBot/commit/726bfd38adfdfaef760412a68e01447b470f438b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Cog-Creators/Red-DiscordBot/releases/tag/3.4.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Cog-Creators/Red-DiscordBot/security/advisories/GHSA-mp9m-g7qj-6vqr", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Cog-Creators/Red-DiscordBot/commit/726bfd38adfdfaef760412a68e01447b470f438b"}}