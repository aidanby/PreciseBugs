{"buggy_code": ["<?php\n\nclass Bootstrap {\n\n    static function init() {\n        #Disable Globals if enabled....before loading config info\n        if(ini_get('register_globals')) {\n           ini_set('register_globals',0);\n           foreach($_REQUEST as $key=>$val)\n               if(isset($$key))\n                   unset($$key);\n        }\n\n        #Disable url fopen && url include\n        ini_set('allow_url_fopen', 0);\n        ini_set('allow_url_include', 0);\n\n        #Disable session ids on url.\n        ini_set('session.use_trans_sid', 0);\n        #No cache\n        session_cache_limiter('nocache');\n\n        #Error reporting...Good idea to ENABLE error reporting to a file. i.e display_errors should be set to false\n        $error_reporting = E_ALL & ~E_NOTICE & ~E_WARNING;\n        if (defined('E_STRICT')) # 5.4.0\n            $error_reporting &= ~E_STRICT;\n        if (defined('E_DEPRECATED')) # 5.3.0\n            $error_reporting &= ~(E_DEPRECATED | E_USER_DEPRECATED);\n        error_reporting($error_reporting); //Respect whatever is set in php.ini (sysadmin knows better??)\n\n        #Don't display errors\n        ini_set('display_errors', 1);\n        ini_set('display_startup_errors', 1);\n\n        //Default timezone\n        if (!ini_get('date.timezone')) {\n            if(function_exists('date_default_timezone_set')) {\n                if(@date_default_timezone_get()) //Let PHP determine the timezone.\n                    @date_default_timezone_set(@date_default_timezone_get());\n                else //Default to EST - if PHP can't figure it out.\n                    date_default_timezone_set('America/New_York');\n            } else { //Default when all fails. PHP < 5.\n                ini_set('date.timezone', 'America/New_York');\n            }\n        }\n        date_default_timezone_set('UTC');\n\n        if (!function_exists('exif_imagetype')) {\n            function exif_imagetype ($filename) {\n                if ((list($width,$height,$type,) = getimagesize($filename)) !== false)\n                    return $type;\n\n                return false;\n            }\n        }\n\n        if (!isset($_SERVER['REMOTE_ADDR']))\n            $_SERVER['REMOTE_ADDR'] = '';\n    }\n\n    static function https() {\n       return osTicket::is_https();\n    }\n\n    static function defineTables($prefix) {\n        #Tables being used sytem wide\n        define('SYSLOG_TABLE',$prefix.'syslog');\n        define('SESSION_TABLE',$prefix.'session');\n        define('CONFIG_TABLE',$prefix.'config');\n\n        define('CANNED_TABLE',$prefix.'canned_response');\n        define('PAGE_TABLE', $prefix.'content');\n        define('FILE_TABLE',$prefix.'file');\n        define('FILE_CHUNK_TABLE',$prefix.'file_chunk');\n\n        define('ATTACHMENT_TABLE',$prefix.'attachment');\n\n        define('USER_TABLE',$prefix.'user');\n        define('USER_CDATA_TABLE', $prefix.'user__cdata');\n        define('USER_EMAIL_TABLE',$prefix.'user_email');\n        define('USER_ACCOUNT_TABLE',$prefix.'user_account');\n\n        define('ORGANIZATION_TABLE', $prefix.'organization');\n        define('ORGANIZATION_CDATA_TABLE', $prefix.'organization__cdata');\n\n        define('NOTE_TABLE', $prefix.'note');\n\n        define('STAFF_TABLE',$prefix.'staff');\n        define('TEAM_TABLE',$prefix.'team');\n        define('TEAM_MEMBER_TABLE',$prefix.'team_member');\n        define('DEPT_TABLE',$prefix.'department');\n        define('STAFF_DEPT_TABLE', $prefix.'staff_dept_access');\n        define('ROLE_TABLE', $prefix.'role');\n\n        define('FAQ_TABLE',$prefix.'faq');\n        define('FAQ_TOPIC_TABLE',$prefix.'faq_topic');\n        define('FAQ_CATEGORY_TABLE',$prefix.'faq_category');\n\n        define('DRAFT_TABLE',$prefix.'draft');\n\n        define('THREAD_TABLE', $prefix.'thread');\n        define('THREAD_ENTRY_TABLE', $prefix.'thread_entry');\n        define('THREAD_ENTRY_EMAIL_TABLE', $prefix.'thread_entry_email');\n        define('THREAD_ENTRY_MERGE_TABLE', $prefix.'thread_entry_merge');\n\n        define('LOCK_TABLE',$prefix.'lock');\n\n        define('TICKET_TABLE',$prefix.'ticket');\n        define('TICKET_CDATA_TABLE', $prefix.'ticket__cdata');\n        define('THREAD_EVENT_TABLE',$prefix.'thread_event');\n        define('THREAD_REFERRAL_TABLE',$prefix.'thread_referral');\n        define('THREAD_COLLABORATOR_TABLE', $prefix.'thread_collaborator');\n        define('TICKET_STATUS_TABLE', $prefix.'ticket_status');\n        define('TICKET_PRIORITY_TABLE',$prefix.'ticket_priority');\n        define('EVENT_TABLE',$prefix.'event');\n\n        define('TASK_TABLE', $prefix.'task');\n        define('TASK_CDATA_TABLE', $prefix.'task__cdata');\n\n        define('PRIORITY_TABLE',TICKET_PRIORITY_TABLE);\n\n\n        define('FORM_SEC_TABLE',$prefix.'form');\n        define('FORM_FIELD_TABLE',$prefix.'form_field');\n\n        define('LIST_TABLE',$prefix.'list');\n        define('LIST_ITEM_TABLE',$prefix.'list_items');\n\n        define('FORM_ENTRY_TABLE',$prefix.'form_entry');\n        define('FORM_ANSWER_TABLE',$prefix.'form_entry_values');\n\n        define('TOPIC_TABLE',$prefix.'help_topic');\n        define('TOPIC_FORM_TABLE',$prefix.'help_topic_form');\n        define('SLA_TABLE', $prefix.'sla');\n\n        define('EMAIL_TABLE',$prefix.'email');\n        define('EMAIL_TEMPLATE_GRP_TABLE',$prefix.'email_template_group');\n        define('EMAIL_TEMPLATE_TABLE',$prefix.'email_template');\n\n        define('FILTER_TABLE', $prefix.'filter');\n        define('FILTER_RULE_TABLE', $prefix.'filter_rule');\n        define('FILTER_ACTION_TABLE', $prefix.'filter_action');\n\n        define('PLUGIN_TABLE', $prefix.'plugin');\n        define('SEQUENCE_TABLE', $prefix.'sequence');\n        define('TRANSLATION_TABLE', $prefix.'translation');\n        define('QUEUE_TABLE', $prefix.'queue');\n        define('COLUMN_TABLE', $prefix.'queue_column');\n        define('QUEUE_COLUMN_TABLE', $prefix.'queue_columns');\n        define('QUEUE_SORT_TABLE', $prefix.'queue_sort');\n        define('QUEUE_SORTING_TABLE', $prefix.'queue_sorts');\n        define('QUEUE_EXPORT_TABLE', $prefix.'queue_export');\n        define('QUEUE_CONFIG_TABLE', $prefix.'queue_config');\n\n        define('SCHEDULE_TABLE', $prefix.'schedule');\n        define('SCHEDULE_ENTRY_TABLE', $prefix.'schedule_entry');\n\n        define('API_KEY_TABLE',$prefix.'api_key');\n        define('TIMEZONE_TABLE',$prefix.'timezone');\n    }\n\n    static function loadConfig() {\n        #load config info\n        $configfile='';\n        if(file_exists(INCLUDE_DIR.'ost-config.php')) //NEW config file v 1.6 stable ++\n            $configfile=INCLUDE_DIR.'ost-config.php';\n        elseif(file_exists(ROOT_DIR.'ostconfig.php')) //Old installs prior to v 1.6 RC5\n            $configfile=ROOT_DIR.'ostconfig.php';\n        elseif(file_exists(INCLUDE_DIR.'settings.php')) { //OLD config file.. v 1.6 RC5\n            $configfile=INCLUDE_DIR.'settings.php';\n            //Die gracefully on upgraded v1.6 RC5 installation - otherwise script dies with confusing message.\n            if(!strcasecmp(basename($_SERVER['SCRIPT_NAME']), 'settings.php'))\n                Http::response(500,\n                    'Please rename config file include/settings.php to include/ost-config.php to continue!');\n        } elseif(file_exists(ROOT_DIR.'setup/'))\n            Http::redirect(ROOT_PATH.'setup/');\n\n        if(!$configfile || !file_exists($configfile))\n            Http::response(500,'<b>Error loading settings. Contact admin.</b>');\n\n        require($configfile);\n        define('CONFIG_FILE',$configfile); //used in admin.php to check perm.\n\n        # This is to support old installations. with no secret salt.\n        if (!defined('SECRET_SALT'))\n            define('SECRET_SALT',md5(TABLE_PREFIX.ADMIN_EMAIL));\n        #Session related\n        define('SESSION_SECRET', MD5(SECRET_SALT)); //Not that useful anymore...\n        define('SESSION_TTL', 86400); // Default 24 hours\n    }\n\n    static function connect() {\n        #Connect to the DB && get configuration from database\n        $ferror=null;\n        $options = array();\n        if (defined('DBSSLCA'))\n            $options['ssl'] = array(\n                'ca' => DBSSLCA,\n                'cert' => DBSSLCERT,\n                'key' => DBSSLKEY\n            );\n\n        if (!db_connect(DBHOST, DBUSER, DBPASS, $options)) {\n            $ferror=sprintf('Unable to connect to the database \u2014 %s',db_connect_error());\n        }elseif(!db_select_database(DBNAME)) {\n            $ferror=sprintf('Unknown or invalid database: %s',DBNAME);\n        }\n\n        if($ferror) //Fatal error\n            self::croak($ferror);\n    }\n\n    static function loadCode() {\n        #include required files\n        require_once INCLUDE_DIR.'class.util.php';\n        require_once INCLUDE_DIR.'class.translation.php';\n        require_once(INCLUDE_DIR.'class.signal.php');\n        require(INCLUDE_DIR.'class.model.php');\n        require(INCLUDE_DIR.'class.user.php');\n        require(INCLUDE_DIR.'class.auth.php');\n        require(INCLUDE_DIR.'class.pagenate.php'); //Pagenate helper!\n        require(INCLUDE_DIR.'class.log.php');\n        require(INCLUDE_DIR.'class.crypto.php');\n        require(INCLUDE_DIR.'class.page.php');\n        require_once(INCLUDE_DIR.'class.format.php'); //format helpers\n        require_once(INCLUDE_DIR.'class.validator.php'); //Class to help with basic form input validation...please help improve it.\n        require(INCLUDE_DIR.'class.mailer.php');\n        require_once INCLUDE_DIR.'mysqli.php';\n        require_once INCLUDE_DIR.'class.i18n.php';\n        require_once INCLUDE_DIR.'class.queue.php';\n    }\n\n    static function i18n_prep() {\n        ini_set('default_charset', 'utf-8');\n        ini_set('output_encoding', 'utf-8');\n\n        // MPDF requires mbstring functions\n        if (!extension_loaded('mbstring')) {\n            if (function_exists('iconv')) {\n                function mb_strpos($a, $b) { return iconv_strpos($a, $b); }\n                function mb_strlen($str) { return iconv_strlen($str); }\n                function mb_substr($a, $b, $c=null) {\n                    return iconv_substr($a, $b, $c); }\n                function mb_convert_encoding($str, $to, $from='utf-8') {\n                    return iconv($from, $to, $str); }\n            }\n            else {\n                function mb_strpos($a, $b) {\n                    $c = preg_replace('/^(\\X*)'.preg_quote($b).'.*$/us', '$1', $a);\n                    return ($c===$a) ? false : mb_strlen($c);\n                }\n                function mb_strlen($str) {\n                    $a = array();\n                    return preg_match_all('/\\X/u', $str, $a);\n                }\n                function mb_substr($a, $b, $c=null) {\n                    return preg_replace(\n                        \"/^\\X{{$b}}(\\X\".($c ? \"{{$c}}\" : \"*\").\").*/us\",'$1',$a);\n                }\n                function mb_convert_encoding($str, $to, $from='utf-8') {\n                    if (strcasecmp($to, $from) == 0)\n                        return $str;\n                    elseif (in_array(strtolower($to), array(\n                            'us-ascii','latin-1','iso-8859-1'))\n                            && function_exists('utf8_encode'))\n                        return utf8_encode($str);\n                    else\n                        return $str;\n                }\n            }\n            define('LATIN1_UC_CHARS', '\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd');\n            define('LATIN1_LC_CHARS', '\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd');\n            function mb_strtoupper($str) {\n                if (is_array($str)) $str = $str[0];\n                return strtoupper(strtr($str, LATIN1_LC_CHARS, LATIN1_UC_CHARS));\n            }\n            function mb_strtolower($str) {\n                if (is_array($str)) $str = $str[0];\n                return strtolower(strtr($str, LATIN1_UC_CHARS, LATIN1_LC_CHARS));\n            }\n            define('MB_CASE_LOWER', 1);\n            define('MB_CASE_UPPER', 2);\n            define('MB_CASE_TITLE', 3);\n            function mb_convert_case($str, $mode) {\n                // XXX: Techincally the calls to strto...() will fail if the\n                //      char is not a single-byte char\n                switch ($mode) {\n                case MB_CASE_LOWER:\n                    return preg_replace_callback('/\\p{Lu}+/u', 'mb_strtolower', $str);\n                case MB_CASE_UPPER:\n                    return preg_replace_callback('/\\p{Ll}+/u', 'mb_strtoupper', $str);\n                case MB_CASE_TITLE:\n                    return preg_replace_callback('/\\b\\p{Ll}/u', 'mb_strtoupper', $str);\n                }\n            }\n            function mb_internal_encoding($encoding) { return 'UTF-8'; }\n            function mb_regex_encoding($encoding) { return 'UTF-8'; }\n            function mb_substr_count($haystack, $needle) {\n                $matches = array();\n                return preg_match_all('`'.preg_quote($needle).'`u', $haystack,\n                    $matches);\n            }\n        }\n        else {\n            // Use UTF-8 for all multi-byte string encoding\n            mb_internal_encoding('utf-8');\n        }\n        if (extension_loaded('iconv'))\n            iconv_set_encoding('internal_encoding', 'UTF-8');\n\n        if (intval(phpversion()) < 7) {\n            function random_int($a, $b) {\n                return rand($a, $b);\n            }\n        }\n\n        function mb_str_wc($str) {\n            return count(preg_split('~[^\\p{L}\\p{N}\\'].+~u', trim($str)));\n        }\n    }\n\n    static function croak($message) {\n        $msg = $message.\"\\n\\n\".THISPAGE;\n        Mailer::sendmail(ADMIN_EMAIL, 'osTicket Fatal Error', $msg,\n            sprintf('\"osTicket Alerts\"<%s>', ADMIN_EMAIL));\n        //Display generic error to the user\n        Http::response(500, \"<b>Fatal Error:</b> Contact system administrator.\");\n    }\n}\n\n#Get real path for root dir ---linux and windows\n$here = dirname(__FILE__);\n$here = ($h = realpath($here)) ? $h : $here;\ndefine('ROOT_DIR',str_replace('\\\\', '/', $here.'/'));\nunset($here); unset($h);\n\ndefine('INCLUDE_DIR',ROOT_DIR.'include/'); //Change this if include is moved outside the web path.\ndefine('PEAR_DIR',INCLUDE_DIR.'pear/');\ndefine('SETUP_DIR',ROOT_DIR.'setup/');\n\ndefine('CLIENTINC_DIR',INCLUDE_DIR.'client/');\ndefine('STAFFINC_DIR',INCLUDE_DIR.'staff/');\n\ndefine('UPGRADE_DIR', INCLUDE_DIR.'upgrader/');\ndefine('I18N_DIR', INCLUDE_DIR.'i18n/');\ndefine('CLI_DIR', INCLUDE_DIR.'cli/');\n\n/*############## Do NOT monkey with anything else beyond this point UNLESS you really know what you are doing ##############*/\n\n#Current version && schema signature (Changes from version to version)\ndefine('GIT_VERSION','$git');\ndefine('MAJOR_VERSION', '1.16');\ndefine('THIS_VERSION', MAJOR_VERSION.'-git'); //Shown on admin panel\n//Path separator\nif(!defined('PATH_SEPARATOR')){\n    if(strpos($_ENV['OS'],'Win')!==false || !strcasecmp(substr(PHP_OS, 0, 3),'WIN'))\n        define('PATH_SEPARATOR', ';' ); //Windows\n    else\n        define('PATH_SEPARATOR',':'); //Linux\n}\n\n//Set include paths. Overwrite the default paths.\nini_set('include_path', './'.PATH_SEPARATOR.INCLUDE_DIR.PATH_SEPARATOR.PEAR_DIR);\n\nrequire(INCLUDE_DIR.'class.osticket.php');\nrequire(INCLUDE_DIR.'class.misc.php');\nrequire(INCLUDE_DIR.'class.http.php');\nrequire(INCLUDE_DIR.'class.validator.php');\n\n// Determine the path in the URI used as the base of the osTicket\n// installation\nif (!defined('ROOT_PATH') && ($rp = osTicket::get_root_path(dirname(__file__))))\n    define('ROOT_PATH', rtrim($rp, '/').'/');\n\nBootstrap::init();\n\n#CURRENT EXECUTING SCRIPT.\ndefine('THISPAGE', Http::url());\n\ndefine('DEFAULT_MAX_FILE_UPLOADS', ini_get('max_file_uploads') ?: 5);\ndefine('DEFAULT_PRIORITY_ID', 1);\n\n?>\n", "<?php\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nrequire_once(INCLUDE_DIR.'class.draft.php');\n\nclass DraftAjaxAPI extends AjaxController {\n\n    static function _createDraft($vars) {\n        if (false === ($vars['body'] = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => __(\"Draft body not found in request\"),\n                'code' => 422,\n                ));\n\n        if (!($draft = Draft::create($vars)) || !$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    static function _getDraft($draft) {\n        if (!$draft || !$draft instanceof Draft)\n            Http::response(205, \"Draft not found. Create one first\");\n\n        $body = Format::viewableImages($draft->getBody());\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'body' => $body,\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    static function _updateDraft($draft) {\n        if (false === ($body = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => array(\n                    'message' => \"Draft body not found in request\",\n                    'code' => 422,\n                )\n            ));\n\n        if (!$draft->setBody($body))\n            return Http::response(500, \"Unable to update draft body\");\n\n        echo \"{}\";\n    }\n\n    static function _uploadInlineImage($draft) {\n        global $cfg;\n\n        if (!isset($_POST['data']) && !isset($_FILES['file']))\n            Http::response(422, \"File not included properly\");\n\n        # Fixup for expected multiple attachments\n        if (isset($_FILES['file'])) {\n            $file = AttachmentFile::format($_FILES['file']);\n\n            # Allow for data-uri uploaded files\n            $fp = fopen($file[0]['tmp_name'], 'rb');\n            if (fread($fp, 5) == 'data:') {\n                $data = 'data:';\n                while ($block = fread($fp, 8192))\n                  $data .= $block;\n                $file[0] = Format::parseRfc2397($data);\n                list(,$ext) = explode('/', $file[0]['type'], 2);\n                $file[0] += array(\n                    'name' => Misc::randCode(8).'.'.$ext,\n                    'size' => strlen($file[0]['data']),\n                );\n            }\n            fclose($fp);\n\n            # TODO: Detect unacceptable attachment extension\n            # TODO: Verify content-type and check file-content to ensure image\n            $type = $file[0]['type'];\n            if (strpos($file[0]['type'], 'image/') !== 0)\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File type is not allowed',\n                    ))\n                );\n\n            # TODO: Verify file size is acceptable\n            if ($file[0]['size'] > $cfg->getMaxFileSize())\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => 'File is too large',\n                    ))\n                );\n\n            // Paste uploads in Chrome will have a name of 'blob'\n            if ($file[0]['name'] == 'blob')\n                $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n\n            $ids = $draft->attachments->upload($file);\n\n            if (!$ids) {\n                if ($file[0]['error']) {\n                    return Http::response(403,\n                        JsonDataEncoder::encode(array(\n                            'error' => $file[0]['error'],\n                        ))\n                    );\n                }\n                else\n                    return Http::response(500, 'Unable to attach image');\n            }\n\n            $id = (is_array($ids)) ? $ids[0] : $ids;\n        }\n        else {\n            $type = explode('/', $_POST['contentType']);\n            $info = array(\n                'data' => base64_decode($_POST['data']),\n                'name' => Misc::randCode(10).'.'.$type[1],\n                // TODO: Ensure _POST['contentType']\n                'type' => $_POST['contentType'],\n            );\n            // TODO: Detect unacceptable filetype\n            // TODO: Verify content-type and check file-content to ensure image\n            $id = $draft->attachments->save($info);\n        }\n        if (!($f = AttachmentFile::lookup($id)))\n            return Http::response(500, 'Unable to attach image');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            Format::sanitize($f->getName()) => array(\n            'content_id' => 'cid:'.$f->getKey(),\n            'id' => $f->getKey(),\n            // Return draft_id to connect the auto draft creation\n            'draft_id' => $draft->getId(),\n            'url' => $f->getDownloadUrl(\n                ['type' => 'D', 'deposition' => 'inline']),\n        )));\n    }\n\n    // Client interface for drafts =======================================\n    function createDraftClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraftClient($namespace) {\n        global $thisclient;\n\n        if ($thisclient) {\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                    $thisclient->getId());\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        else {\n            if (substr($namespace, -12) != substr(session_id(), -12))\n                Http::response(404, \"Draft not found\");\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace, 0);\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        return self::_getDraft($draft);\n    }\n\n    function updateDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        // Check the owning client-id (for logged-in users), and the\n        // session_id() for others\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_updateDraft($draft);\n    }\n\n    function deleteDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        $draft->delete();\n    }\n\n    function uploadInlineImageClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarlyClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace,\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImageClient($draft->getId());\n    }\n\n    // Staff interface for drafts ========================================\n    function createDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n        try {\n            $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                $thisstaff->getId());\n        }\n        catch (DoesNotExist $e) {\n            Http::response(205, \"Draft not found. Create one first\");\n        }\n\n        return self::_getDraft($draft);\n    }\n\n    function updateDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_updateDraft($draft);\n    }\n\n    function uploadInlineImage($draft_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($draft_id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarly($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImage($draft->getId());\n    }\n\n    function deleteDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft edits\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        $draft->delete();\n    }\n\n    function getFileList() {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for file queries\");\n\n        $search = Q::any([\n            Q::all([\n                'attachments__type__in' => array('C', 'F', 'T', 'P'),\n                'attachments__inline' => 1,\n            ]),\n            'ft' => 'L',\n        ]);\n\n        if (isset($_GET['threadId']) && is_numeric($_GET['threadId'])\n            && ($thread = Thread::lookup($_GET['threadId']))\n            && ($object = $thread->getObject())\n            && ($thisstaff->canAccess($object))\n        ) {\n            $search->add(Q::all([\n                'attachments__thread_entry__thread_id' => $_GET['threadId'],\n                'attachments__inline' => 1,\n            ]));\n        }\n\n        $images = AttachmentFile::objects()->filter([\n                $search,\n                'type__startswith' => 'image/',\n            ])->distinct('id');\n\n        $files = array();\n        foreach ($images as $f) {\n            $url = $f->getDownloadUrl();\n            $files[] = array(\n                // Don't send special sizing for thread items 'cause they\n                // should be cached already by the client\n                'thumb' => $url.($f->type != 'H' ? '&s=128' : ''),\n                'url' => $url,\n                'title' => $f->getName(),\n            );\n        }\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode($files);\n    }\n\n    static function _findDraftBody($vars) {\n        if (isset($vars['name'])) {\n            $parts = array();\n            // Support nested `name`, like trans[lang]\n            if (preg_match('`(\\w+)(?:\\[(\\w+)\\])?(?:\\[(\\w+)\\])?`', $_POST['name'], $parts)) {\n                array_shift($parts);\n                $focus = $vars;\n                foreach ($parts as $p)\n                    $focus = $focus[$p];\n                return $focus;\n            }\n        }\n\n        // Get ThreadEntry field name.\n        $tform = TicketForm::objects()->one()->getForm();\n        $tfield = $tform->getField('message')->getFormName();\n        // Get Task Description field name.\n        $aform = TaskForm::objects()->one()->getForm();\n        $afield = $aform->getField('description')->getFormName();\n        $field_list = array('response', 'note', 'answer', 'body',\n             $tfield, 'issue', $afield);\n        foreach ($field_list as $field) {\n            if (isset($vars[$field])) {\n                return $vars[$field];\n            }\n        }\n\n        return false;\n    }\n\n}\n?>\n", "<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getMimeType() {\n        return $this->getType();\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getAttrs() {\n        return $this->attrs;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $ttl=false, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition, $ttl))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false, $ttl=86400) {\n        $this->makeCacheable($ttl);\n\n        if ($scale && extension_loaded('gd')\n                && ($image = imagecreatefromstring($this->getData()))) {\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        header(\"Content-Security-Policy: default-src 'self'\");\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($options=array()) {\n        // Add attachment ref id if object type is set\n        if (isset($options['type'])\n                && !isset($options['id'])\n                && ($a=$this->attachments->findFirst(array(\n                            'type' => $options['type']))))\n            $options['id'] = $a->getId();\n\n        return static::generateDownloadUrl($this->getId(),\n                strtolower($this->getKey()), $this->getSignature(),\n                $options);\n    }\n\n    // Generates full download URL for external sources.\n    // e.g. https://domain.tld/file.php?args=123\n    function getExternalDownloadUrl($options=array()) {\n        global $cfg;\n\n        $download = $this->getDownloadUrl($options);\n        // Separate URL handle and args\n        list($handle, $args) = explode('file.php?', $download);\n\n        return (string) rtrim($cfg->getBaseUrl(), '/').'/file.php?'.$args;\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $options = array()) {\n\n        // Expire at the nearest midnight, allow at least12 hrs access\n        $minage = @$options['minage'] ?: 43200;\n        $gmnow = Misc::gmtime() +  $options['minage'];\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        // Handler / base url\n        $handler = @$options['handler'] ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if (isset($options['disposition']))\n            $args['disposition'] =  $options['disposition'];\n\n        if (isset($options['id']))\n            $args['id'] =  $options['id'];\n\n        return sprintf('%s?%s', $handler, http_build_query($args));\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($name=false, $disposition=false, $expires=false) {\n        $thisstaff = StaffAuthenticationBackend::getUser();\n        $inline = ($thisstaff ? ($thisstaff->getImageAttachmentView() === 'inline') : false);\n        $disposition = ((($disposition && strcasecmp($disposition, 'inline') == 0)\n              || $inline)\n              && strpos($this->getType(), 'image/') !== false)\n            ? 'inline' : 'attachment';\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition, $ttl))\n            return;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($name ?: $this->getName(), $type, null, $disposition);\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    static function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            $file['data'] = $file['data_cbk']();\n        }\n\n        if (isset($file['data'])) {\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n        $f->attrs = $bk->getAttrs() ?: NULL;\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        $this->attrs = $target->getAttrs() ?: NULL;\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n        // Cache a negative lookup if no such file exists\n        try {\n            return parent::lookup(array('key' => $hash));\n        } catch (ObjectNotUnique $e) {\n            // TODO: Figure out why key collission might be happening AND\n            // make key (hash) unique field in the file table as a\n            // protection measure. For now we're returning null to avoid possible wrong file\n            // being displayed.\n            return null;\n        }\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    static function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            $file['name'] = Format::sanitize($file['name']);\n\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n\n        // XXX: Allow plugins to define filetypes which do not represent\n        //      files attached to tickets or other things in the attachment\n        //      table and are not logos\n        $files = static::objects()\n            ->filter(array(\n                'attachments__object_id__isnull' => true,\n                'ft' => 'T',\n                'created__lt' => SqlFunction::NOW()->minus(SqlInterval::DAY(1)),\n            ));\n\n        foreach ($files as $f) {\n            if (!$f->delete())\n                break;\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline', $ttl=false) {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n\n    /**\n     * getAttrs\n     *\n     * Get backend storage attributes.\n     *\n     */\n    function getAttrs() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n\n// FileObject - wrapper for SplFileObject class\nclass FileObject extends SplFileObject {\n\n    protected $_filename;\n\n    function __construct($file, $mode='r') {\n        parent::__construct($file, $mode);\n    }\n\n    /* This allows us to set REAL file name as opposed to basename of the\n     * FS file in question\n     */\n    function setFilename($filename) {\n        $this->_filename = $filename;\n    }\n\n    function getFilename() {\n        return $this->_filename ?: parent::getFilename();\n    }\n\n    /*\n     * Set mime type - well formated mime is expected.\n     */\n    function setMimeType($type) {\n        $this->_mimetype = $type;\n    }\n\n    function getMimeType() {\n        if (!isset($this->_mimetype)) {\n            // Try to to auto-detect mime type\n            $finfo = new finfo(FILEINFO_MIME);\n            $this->_mimetype = $finfo->buffer($this->getContents(),\n                    FILEINFO_MIME_TYPE);\n        }\n\n        return $this->_mimetype;\n    }\n\n    function getContents() {\n        $this->fseek(0);\n        return $this->fread($this->getSize());\n    }\n\n    /*\n     * XXX: Needed for mailer attachments interface\n     */\n    function getData() {\n        return $this->getContents();\n    }\n}\n\n?>\n", "<?php\n/*********************************************************************\n    class.forms.php\n\n    osTicket forms framework\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\n/**\n * Form template, used for designing the custom form and for entering custom\n * data for a ticket\n */\nclass Form {\n    static $renderer = 'GridFluidLayout';\n    static $id = 0;\n\n    var $options = array();\n    var $fields = array();\n    var $title = '';\n    var $instructions = '';\n\n    var $validators = array();\n\n    var $_errors = null;\n    var $_source = false;\n\n    function __construct($source=null, $options=array()) {\n\n        $this->options = $options;\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        if (isset($options['id']))\n            $this->id = $options['id'];\n\n        // Use POST data if source was not specified\n        $this->_source = $source ?: $_POST;\n    }\n\n    function getFormId() {\n        return @$this->id ?: static::$id;\n    }\n    function setId($id) {\n        $this->id = $id;\n    }\n\n    function data($source) {\n        foreach ($this->fields as $name=>$f)\n            if (isset($source[$name]))\n                $f->value = $source[$name];\n    }\n\n    function setFields($fields) {\n\n        if (!is_array($fields) && !$fields instanceof Traversable)\n            return;\n\n        $this->fields = $fields;\n        foreach ($fields as $k=>$f) {\n            $f->setForm($this);\n            if (!$f->get('name') && $k && !is_numeric($k))\n                $f->set('name', $k);\n        }\n    }\n\n    function getFields() {\n        return $this->fields;\n    }\n\n    function getField($name) {\n        $fields = $this->getFields();\n        foreach($fields as $f)\n            if(!strcasecmp($f->get('name'), $name))\n                return $f;\n        if (isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function hasField($name) {\n        return $this->getField($name);\n    }\n\n    function hasAnyEnabledFields() {\n        return $this->hasAnyVisibleFields(false);\n    }\n\n    function hasAnyVisibleFields($user=false) {\n        $visible = 0;\n        $isstaff = $user instanceof Staff;\n        foreach ($this->getFields() as $F) {\n            if (!$user) {\n                // Assume hasAnyEnabledFields\n                if ($F->isEnabled())\n                    $visible++;\n            } elseif($isstaff) {\n                if ($F->isVisibleToStaff())\n                    $visible++;\n            } elseif ($F->isVisibleToUsers()) {\n                $visible++;\n            }\n        }\n        return $visible > 0;\n    }\n\n    function getTitle() { return $this->title; }\n    function getInstructions() { return Format::htmldecode($this->instructions); }\n    function getSource() { return $this->_source; }\n    function setSource($source) { $this->_source = $source; }\n\n    /**\n     * Validate the form and indicate if there no errors.\n     *\n     * Parameters:\n     * $filter - (callback) function to receive each field and return\n     *      boolean true if the field's errors are significant\n     */\n    function isValid($include=false) {\n        if (!isset($this->_errors)) {\n            $this->_errors = array();\n            $this->validate($this->getClean());\n            foreach ($this->getFields() as $field)\n                if ($field->errors() && (!$include || $include($field)))\n                    $this->_errors[$field->get('id')] = $field->errors();\n        }\n        return !$this->_errors;\n    }\n\n    function validate($clean_data) {\n        // Validate the whole form so that errors can be added to the\n        // individual fields and collected below.\n        foreach ($this->validators as $V) {\n            $V($this);\n        }\n    }\n\n    function getClean($validate=true) {\n        if (!$this->_clean) {\n            $this->_clean = array();\n            foreach ($this->getFields() as $key=>$field) {\n                if (!$field->hasData())\n                    continue;\n\n                // Prefer indexing by field.id if indexing numerically\n                if (is_int($key) && $field->get('id'))\n                    $key = $field->get('id');\n                $this->_clean[$key] = $this->_clean[$field->get('name')]\n                    = $field->getClean($validate);\n            }\n            unset($this->_clean[\"\"]);\n        }\n        return $this->_clean;\n    }\n\n    /*\n     * Process the form input and return clean data.\n     *\n     * It's similar to getClean but forms downstream can use it to return\n     * database ready data.\n     */\n    function process($validate=true) {\n        return $this->getClean($validate);\n    }\n\n    function errors($formOnly=false) {\n        return ($formOnly) ? $this->_errors['form'] : $this->_errors;\n    }\n\n    function addError($message, $index=false) {\n\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors['form'][] = $message;\n    }\n\n    function addErrors($errors=array()) {\n        foreach ($errors as $k => $v) {\n            if (($f=$this->getField($k)))\n                $f->addError($v);\n            else\n                $this->addError($v, $k);\n        }\n    }\n\n    function addValidator($function) {\n        if (!is_callable($function))\n            throw new Exception('Form validator must be callable');\n        $this->validators[] = $function;\n    }\n\n    function render($options=array()) {\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        $form = $this;\n        $template = $options['template'] ?: 'dynamic-form.tmpl.php';\n        if (isset($options['staff']) && $options['staff'])\n            include(STAFFINC_DIR . 'templates/' . $template);\n        else\n            include(CLIENTINC_DIR . 'templates/' . $template);\n        echo $this->getMedia();\n    }\n\n    function getLayout($title=false, $options=array()) {\n        $rc = @$options['renderer'] ?: static::$renderer;\n        return new $rc($title, $options);\n    }\n\n    function asTable($title=false, $options=array()) {\n        return $this->getLayout($title, $options)->asTable($this);\n        // XXX: Media can't go in a table\n        echo $this->getMedia();\n    }\n\n    function getMedia() {\n        static $dedup = array();\n\n        foreach ($this->getFields() as $f) {\n            if (($M = $f->getMedia()) && is_array($M)) {\n                foreach ($M as $type=>$files) {\n                    foreach ($files as $url) {\n                        $key = strtolower($type.$url);\n                        if (isset($dedup[$key]))\n                            continue;\n\n                        self::emitMedia($url, $type);\n\n                        $dedup[$key] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    function emitJavascript($options=array()) {\n\n        // Check if we need to emit javascript\n        if (!($fid=$this->getFormId()))\n            return;\n        ?>\n        <script type=\"text/javascript\">\n          $(function() {\n            <?php\n            //XXX: We ONLY want to watch field on this form. We'll only\n            // watch form inputs if form_id is specified. Current FORM API\n            // doesn't generate the entire form  (just fields)\n            if ($fid) {\n                ?>\n                $(document).off('change.<?php echo $fid; ?>');\n                $(document).on('change.<?php echo $fid; ?>',\n                    'form#<?php echo $fid; ?> :input',\n                    function() {\n                        //Clear any current errors...\n                        var errors = $('#field'+$(this).attr('id')+'_error');\n                        if (errors.length)\n                            errors.slideUp('fast', function (){\n                                $(this).remove();\n                                });\n                        //TODO: Validation input inplace or via ajax call\n                        // and set any new errors AND visibilty changes\n                    }\n                   );\n            <?php\n            }\n            ?>\n            });\n        </script>\n        <?php\n    }\n\n    static function emitMedia($url, $type) {\n        if ($url[0] == '/')\n            $url = ROOT_PATH . substr($url, 1);\n\n        switch (strtolower($type)) {\n        case 'css': ?>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"<?php echo $url; ?>\"/><?php\n            break;\n        case 'js': ?>\n        <script type=\"text/javascript\" src=\"<?php echo $url; ?>\"></script><?php\n            break;\n        }\n    }\n\n    /**\n     * getState\n     *\n     * Retrieves an array of information which can be passed to the\n     * ::loadState method later to recreate the current state of the form\n     * fields and values.\n     */\n    function getState() {\n        $info = array();\n        foreach ($this->getFields() as $f) {\n            // Skip invisible fields\n            if (!$f->isVisible())\n                continue;\n\n            // Skip fields set to default values\n            $v = $f->getClean();\n            $d = $f->get('default');\n            if ($v == $d)\n                continue;\n\n            // Skip empty values\n            if (!$v)\n                continue;\n\n            $info[$f->get('name') ?: $f->get('id')] = $f->to_database($v);\n        }\n        return $info;\n    }\n\n    /**\n     * loadState\n     *\n     * Reset this form to the state previously recorded by the ::getState()\n     * method\n     */\n    function loadState($state) {\n        foreach ($this->getFields() as $f) {\n            $name = $f->get('name');\n            $f->reset();\n            if (isset($state[$name])) {\n                $f->value = $f->to_php($state[$name]);\n            }\n        }\n    }\n\n    /*\n     * Initialize a generic static form\n     */\n    static function instantiate() {\n        $r = new ReflectionClass(get_called_class());\n        return $r->newInstanceArgs(func_get_args());\n    }\n}\n\n/**\n * SimpleForm\n * Wrapper for inline/static forms.\n *\n */\nclass SimpleForm extends Form {\n    function __construct($fields=array(), $source=null, $options=array()) {\n        parent::__construct($source, $options);\n        if (isset($options['type']))\n            $this->type = $options['type'];\n        $this->setFields($fields);\n    }\n\n    function getId() {\n        return $this->getFormId();\n    }\n}\n\nclass CustomForm extends SimpleForm {\n\n    function getFields() {\n        global $thisstaff, $thisclient;\n\n        $options = $this->options;\n        $user = $options['user'] ?: $thisstaff ?: $thisclient;\n        $isedit = ($options['mode'] == 'edit');\n        $fields = array();\n        foreach (parent::getFields() as $field) {\n            if ($isedit && !$field->isEditable($user))\n                continue;\n\n            $fields[] = $field;\n        }\n\n        return $fields;\n    }\n}\n\nabstract class AbstractForm extends Form {\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($this->buildFields());\n    }\n    /**\n     * Fetch the fields defined for this form. This method is only called\n     * once.\n     */\n    abstract function buildFields();\n}\n\n/**\n * Container class to represent the connection between the form fields and the\n * rendered state of the form.\n */\ninterface FormRenderer {\n    // Render the form fields into a table\n    function asTable($form);\n    // Render the form fields into divs\n    function asBlock($form);\n}\n\nabstract class FormLayout {\n    static $default_cell_layout = 'Cell';\n\n    var $title;\n    var $options;\n\n    function __construct($title=false, $options=array()) {\n        $this->title = $title;\n        $this->options = $options;\n    }\n\n    function getLayout($field) {\n        $layout = $field->get('layout') ?: static::$default_cell_layout;\n        if (is_string($layout))\n            $layout = new $layout();\n        return $layout;\n    }\n}\n\nclass GridFluidLayout\nextends FormLayout\nimplements FormRenderer {\n    function asTable($form) {\n      ob_start();\n?>\n      <table class=\"<?php echo 'grid form' ?>\">\n          <caption><?php echo Format::htmlchars($this->title ?: $form->getTitle()); ?>\n                  <div><small><?php echo Format::viewableImages($form->getInstructions()); ?></small></div>\n          </caption>\n          <tbody><tr><?php for ($i=0; $i<12; $i++) echo '<td style=\"width:8.3333%\"/>'; ?></tr></tbody>\n<?php\n      $row_size = 12;\n      $cols = $row = 0;\n\n      //Layout and rendering options\n      $options = $this->options;\n\n      foreach ($form->getFields() as $f) {\n          $layout = $this->getLayout($f);\n          $size = $layout->getWidth() ?: 12;\n          if ($offs = $layout->getOffset()) {\n              $size += $offs;\n          }\n          if ($cols < $size || $layout->isBreakForced()) {\n              if ($row) echo '</tr>';\n              echo '<tr>';\n              $cols = $row_size;\n              $row++;\n          }\n          // Render the cell\n          $cols -= $size;\n          $attrs = array('colspan' => $size, 'rowspan' => $layout->getHeight(),\n              'style' => '\"'.$layout->getOption('style').'\"');\n          if ($offs) { ?>\n              <td colspan=\"<?php echo $offs; ?>\"></td> <?php\n          }\n          ?>\n          <td class=\"cell\" <?php echo Format::array_implode('=', ' ', array_filter($attrs)); ?>\n              data-field-id=\"<?php echo $f->get('id'); ?>\">\n              <fieldset class=\"field <?php if (!$f->isVisible()) echo 'hidden'; ?>\"\n                id=\"field<?php echo $f->getWidget()->id; ?>\"\n                data-field-id=\"<?php echo $f->get('id'); ?>\">\n<?php         $label = $f->get('label'); ?>\n              <label class=\"<?php if ($f->isRequired()) echo 'required'; ?>\"\n                  for=\"<?php echo $f->getWidget()->id; ?>\">\n                  <?php echo $label ? (Format::htmlchars($label).':') : '&nbsp;'; ?>\n                <?php if ($f->isRequired()) { ?>\n                <span class=\"error\">*</span>\n              </label>\n<?php         }\n              if ($f->get('hint')) { ?>\n                  <div class=\"field-hint-text\">\n                      <?php echo Format::htmlchars($f->get('hint')); ?>\n                  </div>\n<?php         }\n              $f->render($options);\n              if ($f->errors())\n                  foreach ($f->errors() as $e)\n                      echo sprintf('<div class=\"error\">%s</div>', Format::htmlchars($e));\n?>\n              </fieldset>\n          </td>\n      <?php\n      }\n      if ($row)\n        echo  '</tr>';\n\n      echo '</tbody></table>';\n\n      return ob_get_clean();\n    }\n\n    function asBlock($form) {}\n}\n\n/**\n * Basic container for field and form layouts. By default every cell takes\n * a whole output row and does not imply any sort of width.\n */\nclass Cell {\n    function isBreakForced()  { return true; }\n    function getWidth()       { return false; }\n    function getHeight()      { return 1; }\n    function getOffset()      { return 0; }\n    function getOption($prop) { return false; }\n}\n\n/**\n * Fluid grid layout, meaning each cell renders to the right of the previous\n * cell (for left-to-right layouts). A width in columns can be specified for\n * each cell along with an offset from the previous cell. A height of columns\n * along with an optional break is supported.\n */\nclass GridFluidCell\nextends Cell {\n    var $span;\n    var $options;\n\n    function __construct($span, $options=array()) {\n        $this->span = $span;\n        $this->options = $options + array(\n            'rows' => 1,        # rowspan\n            'offset' => 0,      # skip some columns\n            'break' => false,   # start on a new row\n        );\n    }\n\n    function isBreakForced()  { return $this->options['break']; }\n    function getWidth()       { return $this->span; }\n    function getHeight()      { return $this->options['rows']; }\n    function getOffset()      { return $this->options['offset']; }\n    function getOption($prop) { return $this->options[$prop]; }\n}\n\nrequire_once(INCLUDE_DIR . \"class.json.php\");\n\nclass FormField {\n    static $widget = false;\n\n    var $ht = array(\n        'label' => false,\n        'required' => false,\n        'default' => false,\n        'configuration' => array(),\n    );\n\n    var $_form;\n    var $_cform;\n    var $_clean;\n    var $_errors = array();\n    var $_widget;\n    var $answer;\n    var $parent;\n    var $presentation_only = false;\n\n    static $types = array(\n        /* @trans */ 'Basic Fields' => array(\n            'text'  => array(   /* @trans */ 'Short Answer', 'TextboxField'),\n            'memo' => array(    /* @trans */ 'Long Answer', 'TextareaField'),\n            'thread' => array(  /* @trans */ 'Thread Entry', 'ThreadEntryField', false),\n            'datetime' => array(/* @trans */ 'Date and Time', 'DatetimeField'),\n            'timezone' => array(/* @trans */ 'Timezone', 'TimezoneField'),\n            'phone' => array(   /* @trans */ 'Phone Number', 'PhoneField'),\n            'bool' => array(    /* @trans */ 'Checkbox', 'BooleanField'),\n            'choices' => array( /* @trans */ 'Choices', 'ChoiceField'),\n            'files' => array(   /* @trans */ 'File Upload', 'FileUploadField'),\n            'break' => array(   /* @trans */ 'Section Break', 'SectionBreakField'),\n            'info' => array(    /* @trans */ 'Information', 'FreeTextField'),\n        ),\n    );\n    static $more_types = array();\n    static $uid = null;\n\n    static function _uid() {\n        return ++self::$uid;\n    }\n\n    function __construct($options=array()) {\n        $this->ht = array_merge($this->ht, $options);\n        if (!isset($this->ht['id']))\n            $this->ht['id'] = self::_uid();\n    }\n\n    function __clone() {\n        $this->_widget = null;\n        $this->ht['id'] = self::_uid();\n    }\n\n    static function addFieldTypes($group, $callable) {\n        static::$more_types[$group][] = $callable;\n    }\n\n    static function allTypes() {\n        if (static::$more_types) {\n            foreach (static::$more_types as $group => $entries)\n                foreach ($entries as $c)\n                    static::$types[$group] = array_merge(\n                            static::$types[$group] ?? array(), call_user_func($c));\n\n            static::$more_types = array();\n        }\n        return static::$types;\n    }\n\n    static function getFieldType($type) {\n        foreach (static::allTypes() as $group=>$types)\n            if (isset($types[$type]))\n                return $types[$type];\n    }\n\n    function get($what, $default=null) {\n        return array_key_exists($what, $this->ht)\n            ? $this->ht[$what]\n            : $default;\n    }\n    function set($field, $value) {\n        $this->ht[$field] = $value;\n    }\n\n    function getId() {\n        return $this->ht['id'];\n    }\n\n    /**\n     * getClean\n     *\n     * Validates and cleans inputs from POST request. This is performed on a\n     * field instance, after a DynamicFormSet / DynamicFormSection is\n     * submitted via POST, in order to kick off parsing and validation of\n     * user-entered data.\n     */\n    function getClean($validate=true) {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                // XXX: The widget value may be parsed already if this is\n                //      linked to dynamic data via ::getAnswer()\n                ? $this->value : $this->parse($this->getWidget()->value);\n\n            if ($vs = $this->get('cleaners')) {\n                if (is_array($vs)) {\n                    foreach ($vs as $cleaner)\n                        if (is_callable($cleaner))\n                            $this->_clean = call_user_func_array(\n                                    $cleaner, array($this, $this->_clean));\n                }\n                elseif (is_callable($vs))\n                    $this->_clean = call_user_func_array(\n                            $vs, array($this, $this->_clean));\n            }\n\n            if (!isset($this->_clean) && ($d = $this->get('default')))\n                $this->_clean = $d;\n\n            if ($this->isVisible() && $validate)\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n\n    function reset() {\n        $this->value = $this->_clean = $this->_widget = null;\n    }\n\n    function getValue() {\n        return $this->getWidget()->getValue();\n    }\n\n    function errors() {\n        return $this->_errors;\n    }\n    function addError($message, $index=false) {\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors[] = $message;\n\n        // Update parent form errors for the field\n        if ($this->_form)\n            $this->_form->addError($this->errors(), $this->get('id'));\n    }\n\n    function isValidEntry() {\n        $this->validateEntry();\n        return count($this->_errors) == 0;\n    }\n\n    /**\n     * validateEntry\n     *\n     * Validates user entry on an instance of the field on a dynamic form.\n     * This is called when an instance of this field (like a TextboxField)\n     * receives data from the user and that value should be validated.\n     *\n     * Parameters:\n     * $value - (string) input from the user\n     */\n    function validateEntry($value) {\n        if (!$value && count($this->_errors))\n            return;\n\n        # Validates a user-input into an instance of this field on a dynamic\n        # form\n        if ($this->get('required') && !$value && $this->hasData())\n            $this->_errors[] = $this->getLocal('label')\n                ? sprintf(__('%s is a required field'), $this->getLocal('label'))\n                : __('This is a required field');\n\n        # Perform declared validators for the field\n        if ($vs = $this->get('validators')) {\n            if (is_array($vs)) {\n                foreach ($vs as $validator)\n                    if (is_callable($validator))\n                        $validator($this, $value);\n            }\n            elseif (is_callable($vs))\n                $vs($this, $value);\n        }\n    }\n\n    /**\n     * isVisible\n     *\n     * If this field has visibility configuration, then it will parse the\n     * constraints with the visibility configuration to determine if the\n     * field is visible and should be considered for validation\n     */\n    function isVisible() {\n        if ($this->get('visibility') instanceof VisibilityConstraint) {\n            return $this->get('visibility')->isVisible($this);\n        }\n        return true;\n    }\n\n    /**\n     * Check if the user has edit rights\n     *\n     */\n\n    function isEditable($user=null) {\n\n        // Internal editable flag used by internal forms e.g internal lists\n        if (!$user && isset($this->ht['editable']))\n            return $this->ht['editable'];\n\n        if ($user instanceof Staff)\n            $flag = DynamicFormField::FLAG_AGENT_EDIT;\n        else\n            $flag = DynamicFormField::FLAG_CLIENT_EDIT;\n\n        return (($this->get('flags') & $flag) != 0);\n    }\n\n\n    /**\n     * isStorable\n     *\n     * Indicate if this field data is storable locally (default).Some field's data\n     * might beed to be stored elsewhere for optimization reasons at the\n     * application level.\n     *\n     */\n\n    function isStorable() {\n        return (($this->get('flags') & DynamicFormField::FLAG_EXT_STORED) == 0);\n    }\n\n    function isRequired() {\n        return $this->get('required');\n    }\n\n    /**\n     * parse\n     *\n     * Used to transform user-submitted data to a PHP value. This value is\n     * not yet considered valid. The ::validateEntry() method will be called\n     * on the value to determine if the entry is valid. Therefore, if the\n     * data is clearly invalid, return something like NULL that can easily\n     * be deemed invalid in ::validateEntry(), however, can still produce a\n     * useful error message indicating what is wrong with the input.\n     */\n    function parse($value) {\n        return is_string($value) ? trim($value) : $value;\n    }\n\n    /**\n     * to_php\n     *\n     * Transforms the data from the value stored in the database to a PHP\n     * value. The ::to_database() method is used to produce the database\n     * valse, so this method is the compliment to ::to_database().\n     *\n     * Parameters:\n     * $value - (string or null) database representation of the field's\n     *      content\n     */\n    function to_php($value) {\n        return $value;\n    }\n\n    /**\n     * to_config\n     *\n     * Transform the data from the value to config form (as determined by\n     * field). to_php is used for each field returned from\n     * ::getConfigurationOptions(), and when the whole configuration is\n     * built, to_config() is called and receives the config array. The array\n     * should be returned, perhaps with modifications, and will be JSON\n     * encoded and stashed in the database.\n     */\n    function to_config($value) {\n        return $value;\n    }\n\n    /**\n     * to_database\n     *\n     * Determines the value to be stored in the database. The database\n     * backend for all fields is a text field, so this method should return\n     * a text value or NULL to represent the value of the field. The\n     * ::to_php() method will convert this value back to PHP.\n     *\n     * Paremeters:\n     * $value - PHP value of the field's content\n     */\n    function to_database($value) {\n        return $value;\n    }\n\n    /**\n     * toString\n     *\n     * Converts the PHP value created in ::parse() or ::to_php() to a\n     * pretty-printed value to show to the user. This is especially useful\n     * for something like dates which are stored considerably different in\n     * the database from their respective human-friendly versions.\n     * Furthermore, this method allows for internationalization and\n     * localization.\n     *\n     * Parametes:\n     * $value - PHP value of the field's content\n     */\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function __toString() {\n        return $this->toString($this->value);\n    }\n\n    /**\n     * When data for this field is deleted permanently from some storage\n     * backend (like a database), other associated data may need to be\n     * cleaned as well. This hook allows fields to participate when the data\n     * for a field is cleaned up.\n     */\n    function db_cleanup($field=false) {\n    }\n\n    /**\n     * Returns an HTML friendly value for the data in the field.\n     */\n    function display($value) {\n        return Format::htmlchars($this->toString($value ?: $this->value));\n    }\n\n    /**\n     * Returns a value suitable for exporting to a foreign system. Mostly\n     * useful for things like dates and phone numbers which should be\n     * formatted using a standard when exported\n     */\n    function export($value) {\n        return $this->toString($value);\n    }\n\n    /**\n     * Fetch a value suitable for embedding the value of this field in an\n     * email template. Reference implementation uses ::to_php();\n     */\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    /**\n     * Fetch the var type used with the email templating system's typeahead\n     * feature. This helps with variable expansion if supported by this\n     * field's ::asVar() method. This method should return a valid classname\n     * which implements the `TemplateVariable` interface.\n     */\n    function asVarType() {\n        return false;\n    }\n\n    /**\n     * Describe the difference between the to two values. Note that the\n     * values should be passed through ::parse() or to_php() before\n     * utilizing this method.\n     */\n    function whatChanged($before, $after) {\n        if ($before)\n            $desc = __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>');\n        else\n            $desc = __('set to <strong>%2$s</strong>');\n        return sprintf($desc, $this->display($before), $this->display($after));\n    }\n\n    /**\n     * Convert the field data to something matchable by filtering. The\n     * primary use of this is for ticket filtering.\n     */\n    function getFilterData() {\n        return $this->toString($this->getClean());\n    }\n\n    /**\n     * Fetches a value that represents this content in a consistent,\n     * searchable format. This is used by the search engine system and\n     * backend.\n     */\n    function searchable($value) {\n        return Format::searchable($this->toString($value));\n    }\n\n    function getKeys($value) {\n        return $this->to_database($value);\n    }\n\n    /**\n     * Fetches a list of options for searching. The values returned from\n     * this method are passed to the widget's `::render()` method so that\n     * the widget can be affected by this setting. For instance, date fields\n     * might have a 'between' search option which should trigger rendering\n     * of two date widgets for search results.\n     */\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('is'),\n            'nequal' =>     __('is not'),\n            'contains' =>   __('contains'),\n            'match' =>      __('matches'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'nequal' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'contains' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'match' => array('TextboxField', array(\n                'placeholder' => __('Valid regular expression'),\n                'configuration' => array('size'=>30),\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' ')\n                        && false === @preg_match(\"/$v/\", ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n        );\n    }\n\n    /**\n     * This is used by the searching system to build a query for the search\n     * engine. The function should return a criteria listing to match\n     * content saved by the field by the `::to_database()` function.\n     */\n    function getSearchQ($method, $value, $name=false) {\n        $criteria = array();\n        $Q = new Q();\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n            case 'nset':\n                $Q->negate();\n            case 'set':\n                $criteria[$name . '__isnull'] = false;\n                break;\n\n            case 'nequal':\n                $Q->negate();\n            case 'equal':\n                $criteria[$name] = $value;\n                break;\n\n            case 'contains':\n                $criteria[$name . '__contains'] = $value;\n                break;\n\n            case 'match':\n                $criteria[$name . '__regex'] = $value;\n                break;\n        }\n        return $Q->add($criteria);\n    }\n\n    function getSearchWidget($method) {\n        $methods = $this->getSearchMethodWidgets();\n        $info = $methods[$method];\n        if (is_array($info)) {\n            $class = $info[0];\n            return new $class($info[1]);\n        }\n        return $info;\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'set':\n            return __('%s has a value');\n        case 'nset':\n            return __('%s does not have a value');\n        case 'equal':\n            return __('%s is %s' /* describes an equality */);\n        case 'nequal':\n            return __('%s is not %s' /* describes an inequality */);\n        case 'contains':\n            return __('%s contains \"%s\"');\n        case 'match':\n            return __('%s matches pattern %s');\n        case 'includes':\n            return __('%s in (%s)');\n        case '!includes':\n            return __('%s not in (%s)');\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $desc = $this->describeSearchMethod($method);\n        switch ($method) {\n            case 'set':\n            case 'nset':\n                return sprintf($desc, $name);\n            default:\n                 return sprintf($desc, $name, $this->toString($value));\n        }\n    }\n\n    function addToQuery($query, $name=false) {\n        return $query->values($name ?: $this->get('name'));\n    }\n\n    /**\n     * Similary to to_php() and parse(), except a row from a queryset is\n     * passed. The value returned should be what would be retured from\n     * parse() or to_php()\n     */\n    function from_query($row, $name=false) {\n        return $row[$name ?: $this->get('name')];\n    }\n\n    /**\n     * If the field can be used in a quick filter. To be used, it should\n     * also implement getQuickFilterChoices() which should return a list of\n     * choices to appear in a quick filter drop-down\n     */\n    function supportsQuickFilter() {\n        return false;\n    }\n\n    /**\n     * Fetch a keyed array of quick filter choices. The keys should be\n     * passed later to ::applyQuickFilter() to apply the quick filter to a\n     * query. The values should be localized titles for the choices.\n     */\n    function getQuickFilterChoices() {\n        return array();\n    }\n\n    /**\n     * Apply a quick filter selection of this field to the query. The\n     * modified query should be returned. Optionally, the orm path / field\n     * name can be passed.\n     */\n    function applyQuickFilter($query, $choice, $name=false) {\n        return $query;\n    }\n\n    function getLabel() { return $this->get('label'); }\n\n    function getSortKeys($path) {\n        return array($path);\n    }\n\n    function getOrmPath($name=false, $query=null) {\n        return CustomQueue::getOrmPath($name ?:$this->get('name'), $query);\n    }\n\n    function applyOrderBy($query, $reverse=false, $name=false) {\n        $col = sprintf('%s%s',\n                $reverse ? '-' : '',\n                $this->getOrmPath($name, $query));\n        return $query->order_by($col);\n    }\n\n    /**\n     * getImpl\n     *\n     * Magic method that will return an implementation instance of this\n     * field based on the simple text value of the 'type' value of this\n     * field instance. The list of registered fields is determined by the\n     * global get_dynamic_field_types() function. The data from this model\n     * will be used to initialize the returned instance.\n     *\n     * For instance, if the value of this field is 'text', a TextField\n     * instance will be returned.\n     */\n    function getImpl($parent=null) {\n        // Allow registration with ::addFieldTypes and delayed calling\n        $type = static::getFieldType($this->get('type'));\n        $clazz = $type[1];\n        $inst = new $clazz($this->ht);\n        $inst->parent = $parent;\n        $inst->setForm($this->_form);\n        return $inst;\n    }\n\n    function __call($what, $args) {\n        // XXX: Throw exception if $this->parent is not set\n        if (!$this->parent)\n            throw new Exception(sprintf(__('%s: Call to undefined function'),\n                $what));\n        // BEWARE: DynamicFormField has a __call() which will create a new\n        //      FormField instance and invoke __call() on it or bounce\n        //      immediately back\n        return call_user_func_array(\n            array($this->parent, $what), $args);\n    }\n\n    function getAnswer() { return $this->answer; }\n    function setAnswer($ans) { $this->answer = $ans; }\n\n    function setValue($value) {\n        $this->reset();\n        $this->getWidget()->value = $value;\n    }\n\n    /**\n     * Fetch a pseudo-random id for this form field. It is used when\n     * rendering the widget in the @name attribute emitted in the resulting\n     * HTML. The form element is based on the form id, field id and name,\n     * and the current user's session id. Therefore, the same form fields\n     * will yield differing names for different users. This is used to ward\n     * off bot attacks as it makes it very difficult to predict and\n     * correlate the form names to the data they represent.\n     */\n    function getFormName() {\n        $default = $this->get('name') ?: $this->get('id');\n        if ($this->_form && is_numeric($fid = $this->_form->getFormId()))\n            return substr(md5(\n                session_id() . \"-form-field-id-$fid-$default-\" . SECRET_SALT), -14);\n        elseif (is_numeric($this->get('id')))\n            return substr(md5(\n                session_id() . '-field-id-'.$this->get('id') . '-' . SECRET_SALT), -16);\n\n        return $default;\n    }\n\n    function getFormNames() {\n\n        // All possible names - this is important for inline data injection\n        $names = array_filter([\n                'hash' => $this->getFormName(),\n                'name' => $this->get('name'),\n                'id' => $this->get('id')]);\n\n        // Force pseudo-random name for Dynamicforms on POST (Web Tickets)\n        if (0 && $_POST\n                && !defined('APICALL')\n                && isset($this->ht['form'])\n                && ($this->ht['form'] instanceof DynamicForm))\n            return [$names['hash']];\n\n        return $names;\n    }\n\n    function setForm($form) {\n        $this->_form = $form;\n    }\n    function getForm() {\n        return $this->_form;\n    }\n    /**\n     * Returns the data source for this field. If created from a form, the\n     * data source from the form is returned. Otherwise, if the request is a\n     * POST, then _POST is returned.\n     */\n    function getSource() {\n        if ($this->_form)\n            return $this->_form->getSource();\n        elseif ($_SERVER['REQUEST_METHOD'] == 'POST')\n            return $_POST;\n        else\n            return array();\n    }\n\n    function render($options=array()) {\n        $rv = $this->getWidget()->render($options);\n        if ($v = $this->get('visibility')) {\n            $v->emitJavascript($this);\n        }\n        return $rv;\n    }\n\n    function renderExtras($options=array()) {\n        return;\n    }\n\n    function getMedia() {\n        $widget = $this->getWidget();\n        return $widget::$media;\n    }\n\n    function getConfigurationOptions() {\n        return array();\n    }\n\n    /**\n     * getConfiguration\n     *\n     * Loads configuration information from database into hashtable format.\n     * Also, the defaults from ::getConfigurationOptions() are integrated\n     * into the database-backed options, so that if options have not yet\n     * been set or a new option has been added and not saved for this field,\n     * the default value will be reflected in the returned configuration.\n     */\n    function getConfiguration() {\n        if (!isset($this->_config)) {\n            $this->_config = $this->get('configuration');\n            if (is_string($this->_config))\n                $this->_config = JsonDataParser::parse($this->_config);\n            elseif (!$this->_config)\n                $this->_config = array();\n            foreach ($this->getConfigurationOptions() as $name=>$field)\n                if (!isset($this->_config[$name]))\n                    $this->_config[$name] = $field->get('default');\n        }\n        return $this->_config;\n    }\n\n    /**\n     * If the [Config] button should be shown to allow for the configuration\n     * of this field\n     */\n    function isConfigurable() {\n        return true;\n    }\n\n    /**\n     * Field type is changeable in the admin interface\n     */\n    function isChangeable() {\n        return true;\n    }\n\n    /**\n     * Field does not contain data that should be saved to the database. Ie.\n     * non data fields like section headers\n     */\n    function hasData() {\n        return true;\n    }\n\n    /**\n     * Returns true if the field/widget should be rendered as an entire\n     * block in the target form.\n     */\n    function isBlockLevel() {\n        return false;\n    }\n\n    /**\n     * Fields should not be saved with the dynamic data. It is assumed that\n     * some static processing will store the data elsewhere.\n     */\n    function isPresentationOnly() {\n        return $this->presentation_only;\n    }\n\n    /**\n     * Indicates if the field places data in the `value_id` column. This\n     * is currently used by the materialized view system\n     */\n    function hasIdValue() {\n        return false;\n    }\n\n    /**\n     * Indicates if the field has subfields accessible via getSubFields()\n     * method. Useful for filter integration. Should connect with\n     * getFilterData()\n     */\n    function hasSubFields() {\n        return false;\n    }\n    function getSubFields() {\n        return null;\n    }\n\n    function getConfigurationForm($source=null) {\n        if (!$this->_cform) {\n            $type = static::getFieldType($this->get('type'));\n            $clazz = $type[1];\n            $T = new $clazz($this->ht);\n            $config = $this->getConfiguration();\n            $this->_cform = new SimpleForm($T->getConfigurationOptions(), $source);\n            if (!$source) {\n                foreach ($this->_cform->getFields() as $name=>$f) {\n                    if ($config && isset($config[$name]))\n                        $f->value = $config[$name];\n                    elseif ($f->get('default'))\n                        $f->value = $f->get('default');\n                }\n            }\n        }\n        return $this->_cform;\n    }\n\n    function configure($prop, $value) {\n        $this->getConfiguration();\n        $this->_config[$prop] = $value;\n    }\n\n    function getWidget($widgetClass=false) {\n        if (!static::$widget)\n            throw new Exception(__('Widget not defined for this field'));\n        if (!isset($this->_widget)) {\n            $wc = $widgetClass ?: $this->get('widget') ?: static::$widget;\n            $this->_widget = new $wc($this);\n            $this->_widget->parseValue();\n        }\n        return $this->_widget;\n    }\n\n    function getSelectName() {\n        $name = $this->get('name') ?: 'field_'.$this->get('id');\n        if ($this->hasIdValue())\n            $name .= '_id';\n\n        return $name;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('field.%s.%s%s', $subtag, $this->get('id'),\n            $this->get('form_id') ? '' : '*internal*'));\n    }\n\n    function getLocal($subtag, $default=false) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : ($default ?: $this->get($subtag));\n    }\n\n    function getEditForm($source=null) {\n        $fields = array(\n                'field' => $this,\n                'comments' => new TextareaField(array(\n                        'id' => 2,\n                        'label'=> '',\n                        'required' => false,\n                        'default' => '',\n                        'configuration' => array(\n                            'html' => true,\n                            'size' => 'small',\n                            'placeholder' => __('Optional reason for the update'),\n                            )\n                        ))\n                );\n\n        return new SimpleForm($fields, $source);\n    }\n\n    function getChanges() {\n        $new = $this->getValue();\n        $old = $this->answer ? $this->answer->getValue() : $this->get('default');\n        return ($old != $new) ? array($this->to_database($old), $this->to_database($new)) : false;\n    }\n\n\n    function save() {\n\n        if (!($changes=$this->getChanges()))\n            return true;\n\n        if (!($a = $this->answer))\n            return false;\n\n        $val = $changes[1];\n        if (is_array($val)) {\n            $a->set('value', $val[0]);\n            $a->set('value_id', $val[1]);\n        } else {\n            $a->set('value', $val);\n        }\n\n        if (!$a->save(true))\n            return false;\n\n        $this->_clean = $this->_widget = null;\n        return $this->parent->save();\n    }\n\n\n    static function init($config) {\n        return new Static($config);\n    }\n}\n\nclass TextboxField extends FormField {\n    static $widget = 'TextboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'size'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Size'), 'required'=>false, 'default'=>16,\n                    'validator' => 'number')),\n            'length' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Max Length'), 'required'=>false, 'default'=>30,\n                    'validator' => 'number')),\n            'validator' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Validator'), 'required'=>false, 'default'=>'',\n                'choices' => array('phone'=>__('Phone Number'),'email'=>__('Email Address'),\n                    'ip'=>__('IP Address'), 'number'=>__('Number'),\n                    'regex'=>__('Custom (Regular Expression)'), ''=>__('None')))),\n            'regex' => new TextboxField(array(\n                'id'=>6, 'label'=>__('Regular Expression'), 'required'=>true,\n                'configuration'=>array('size'=>40, 'length'=>100),\n                'visibility' => new VisibilityConstraint(\n                    new Q(array('validator__eq'=>'regex')),\n                    VisibilityConstraint::HIDDEN\n                ),\n                'cleaners' => function ($self, $value) {\n                    $wrapped = \"/\".$value.\"/iu\";\n                    if (false === @preg_match($value, ' ')\n                            && false !== @preg_match($wrapped, ' ')) {\n                        $value = $wrapped;\n                    }\n                    if ($value == '//iu')\n                        return '';\n\n                    return $value;\n                },\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n            'validator-error' => new TextboxField(array(\n                'id'=>4, 'label'=>__('Validation Error'), 'default'=>'',\n                'configuration'=>array('size'=>40, 'length'=>60,\n                    'translatable'=>$this->getTranslateTag('validator-error')\n                ),\n                'hint'=>__('Message shown to user if the input does not match the validator'))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')\n                ),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        //check to see if value is the string '0'\n        $value = ($value === '0') ? '&#48' : Format::htmlchars($this->toString($value ?: $this->value));\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' => '',\n            'noop' => array(\n                function($a, &$b) { return true; }\n            ),\n            'formula' => array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n            'email' =>  array(array('Validator', 'is_valid_email'),\n                __('Enter a valid email address')),\n            'phone' =>  array(array('Validator', 'is_phone'),\n                __('Enter a valid phone number')),\n            'ip' =>     array(array('Validator', 'is_ip'),\n                __('Enter a valid IP address')),\n            'number' => array(array('Validator', 'is_numeric'),\n                __('Enter a number')),\n            'password' => array(array('Validator', 'check_passwd'),\n                __('Invalid Password')),\n            'regex' => array(\n                function($v) use ($config) {\n                    $regex = $config['regex'];\n                    return @preg_match($regex, $v);\n                }, __('Value does not match required pattern')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        $valid = $this->get('validator');\n        if (!$valid) {\n            $valid = $config['validator'];\n        }\n        if (!$value || !isset($validators[$valid]))\n            return;\n        // If no validators are set and not an instanceof AdvancedSearchForm\n        // force formula validation\n        if (!$valid && !($this->getForm() instanceof AdvancedSearchForm))\n            $valid = 'formula';\n        $func = $validators[$valid];\n        $error = $err = null;\n        // If validator is number and the value is &#48 set to 0 (int) for is_numeric\n        if ($valid == 'number' && $value == '&#48')\n            $value = 0;\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func_array($func[0], array($value, &$err)))\n                $this->_errors[] =  $error ?: $err ?: $func[1];\n    }\n\n    function parse($value) {\n        return Format::strip_emoticons(Format::striptags($value));\n    }\n\n    function display($value) {\n        return ($value === '0') ? '&#48;' : Format::htmlchars($this->toString($value ?: $this->value), true);\n    }\n}\n\nclass PasswordField extends TextboxField {\n    static $widget = 'PasswordWidget';\n\n    function __construct($options=array()) {\n        parent::__construct($options);\n        if (!isset($options['validator']))\n            $this->set('validator', 'password');\n    }\n\n    function parse($value) {\n        // Don't trim the value\n        return $value;\n    }\n\n    function to_database($value) {\n        // If not set in UI, don't save the empty value\n        if (!$value)\n            throw new FieldUnchanged();\n        return Crypto::encrypt($value, SECRET_SALT, 'pwfield');\n    }\n\n    function to_php($value) {\n        return Crypto::decrypt($value, SECRET_SALT, 'pwfield');\n    }\n}\n\nclass TextareaField extends FormField {\n    static $widget = 'TextareaWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'cols'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Width').' '.__('(chars)'), 'required'=>true, 'default'=>40)),\n            'rows'  =>  new TextboxField(array(\n                'id'=>2, 'label'=>__('Height').' '.__('(rows)'), 'required'=>false, 'default'=>4)),\n            'length' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Max Length'), 'required'=>false, 'default'=>0)),\n            'html' => new BooleanField(array(\n                'id'=>4, 'label'=>__('HTML'), 'required'=>false, 'default'=>true,\n                'configuration'=>array('desc'=>__('Allow HTML input in this box')))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        if (!$value)\n            return;\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' =>       array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n            'choices' => array(\n                function($val) {\n                    $val = str_replace('\"', '', JsonDataEncoder::encode($val));\n                    $regex = \"/^(?! )[A-z0-9 _-]+:{1}[^\\n]+$/\";\n                    foreach (explode('\\r\\n', $val) as $v) {\n                        if (!preg_match($regex, $v))\n                            return false;\n                    }\n                    return true;\n                }, __('Each choice requires a key and has to be on a new line. (eg. key:value)')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        if (!($valid = $this->get('validator')) && isset($config['validator']))\n            $valid = $config['validator'];\n\n        if (!isset($validators[$valid]))\n            return;\n\n        $func = $validators[$valid];\n        $error = $func[1];\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func($func[0], $value))\n                $this->_errors[] = $error;\n    }\n\n    function display($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::safe_html($value);\n        else\n            return nl2br(Format::htmlchars($value, true));\n    }\n\n    function searchable($value) {\n        $body = new HtmlThreadEntryBody($value);\n        return $body->getSearchable();\n    }\n\n    function export($value) {\n        return (!$value) ? $value : Format::html2text($value);\n    }\n\n    function parse($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::sanitize($value);\n        else\n            return $value;\n    }\n\n}\n\nclass PhoneField extends FormField {\n    static $widget = 'PhoneNumberWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'ext' => new BooleanField(array(\n                'label'=>__('Extension'), 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add a separate field for the extension'),\n                ),\n            )),\n            'digits' => new TextboxField(array(\n                'label'=>__('Minimum length'), 'default'=>7,\n                'hint'=>__('Fewest digits allowed in a valid phone number'),\n                'configuration'=>array('validator'=>'number', 'size'=>5),\n            )),\n            'format' => new ChoiceField(array(\n                'label'=>__('Display format'), 'default'=>'us',\n                'choices'=>array(''=>'-- '.__('Unformatted').' --',\n                    'us'=>__('United States')),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        # Run validator against $this->value for email type\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        if ($phone && (\n                !is_numeric($phone) ||\n                strlen($phone) < $config['digits']))\n            $this->_errors[] = __(\"Enter a valid phone number\");\n        if ($ext && $config['ext']) {\n            if (!is_numeric($ext))\n                $this->_errors[] = __(\"Enter a valid phone extension\");\n            elseif (!$phone)\n                $this->_errors[] = __(\"Enter a phone number for the extension\");\n        }\n    }\n\n    function parse($value) {\n        // NOTE: Value may have a legitimate 'X' to separate the number and\n        // extension parts. Don't remove the 'X'\n        $val = preg_replace('/[^\\dX]/', '', $value);\n        // Pass completely-incorrect string for validation error\n        return $val ?: $value;\n    }\n\n    function toString($value) {\n        $config = $this->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        switch ($config['format']) {\n        case 'us':\n            $phone = Format::phone($phone);\n            break;\n        }\n        if ($ext)\n            $phone.=\" x$ext\";\n        return $phone;\n    }\n}\n\nclass BooleanField extends FormField {\n    static $widget = 'CheckboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'desc' => new TextareaField(array(\n                'id'=>1, 'label'=>__('Description'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown inline with the widget'),\n                'configuration'=>array('rows'=>2)))\n        );\n    }\n\n    function to_database($value) {\n        return ($value) ? '1' : '0';\n    }\n\n    function parse($value) {\n        return $this->to_php($value);\n    }\n    function to_php($value) {\n        return $value ? true : false;\n    }\n\n    function toString($value) {\n        return ($value) ? __('Yes') : __('No');\n    }\n\n    function getClean($validate=true) {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                ? $this->value : $this->getValue();\n\n            if ($this->isVisible() && $validate)\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('checked'),\n            'nset' =>    __('unchecked'),\n        );\n    }\n\n    function describeSearchMethod($method) {\n\n        $methods = $this->get('descsearchmethods');\n        if (isset($methods[$method]))\n            return $methods[$method];\n\n        return parent::describeSearchMethod($method);\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case 'set':\n            return new Q(array($name => '1'));\n        case 'nset':\n            return new Q(array($name => '0'));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return array(\n            true => __('Checked'),\n            false => __('Not Checked'),\n        );\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        return $query->filter(array(\n            $name ?: $this->get('name') => (int) $qf_value,\n        ));\n    }\n}\n\nclass ChoiceField extends FormField {\n    static $widget = 'ChoicesWidget';\n    var $_choices;\n\n    function getConfigurationOptions() {\n        return array(\n            'choices'  =>  new TextareaField(array(\n                'id'=>1, 'label'=>__('Choices'), 'required'=>false, 'default'=>'',\n                'hint'=>__('List choices, one per line. To protect against spelling changes, specify key:value names to preserve entries if the list item names change.</br><b>Note:</b> If you have more than two choices, use a List instead.'),\n                'validator'=>'choices',\n                'configuration'=>array('html'=>false)\n            )),\n            'default' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'hint'=>__('(Enter a key). Value selected from the list initially'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('prompt'),\n                ),\n            )),\n            'multiselect' => new BooleanField(array(\n                'id'=>1, 'label'=>'Multiselect', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>'Allow multiple selections')\n            )),\n        );\n    }\n\n    function parse($value) {\n        return $this->to_php($value ?: null);\n    }\n\n    function to_database($value) {\n        if (!is_array($value)) {\n            $choices = $this->getChoices();\n            if (isset($choices[$value]))\n                $value = array($value => $choices[$value]);\n        }\n        if (is_array($value))\n            $value = JsonDataEncoder::encode($value);\n\n        return $value;\n    }\n\n    function to_php($value) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        // CDATA table may be built with comma-separated key,value,key,value\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            $choices = $this->getChoices();\n            $vals = array_map('trim', explode(',', $value));\n            foreach ($vals as $V) {\n                if (isset($choices[$V]))\n                    $values[$V] = $choices[$V];\n            }\n            if (array_filter($values))\n                $value = $values;\n            elseif($vals)\n                list($value) = $vals;\n\n        }\n        $config = $this->getConfiguration();\n        if (!$config['multiselect'] && is_array($value) && count($value) < 2) {\n            reset($value);\n            $value = key($value);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getKeys($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', array_keys($value));\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $value = $this->to_php($value);\n        return $this->toString($this->getChoice($value));\n    }\n\n    function getChanges() {\n        $new = $this->to_database($this->getValue());\n        $old = $this->to_database($this->answer ? $this->answer->getValue()\n                : $this->get('default'));\n        // Compare old and new\n        return ($old == $new)\n            ? false\n            : array($old, $new);\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = array_map(array($this, 'display'), $added);\n        $deleted = array_map(array($this, 'display'), $deleted);\n        $added = array_filter($added);\n        $deleted = array_filter($deleted);\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n\n    /*\n     Return criteria to which the choice should be filtered by\n     */\n    function getCriteria() {\n        $config = $this->getConfiguration();\n        $criteria = array();\n        if (isset($config['criteria']))\n            $criteria = $config['criteria'];\n\n        return $criteria;\n    }\n\n    function getChoice($value) {\n\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value]))\n            $selection[$value] = $choices[$value];\n        elseif (($v=$this->get('default')) && isset($choices[$v]))\n            $selection[$v] = $choices[$v];\n\n        return $selection;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if ($this->_choices === null || $verbose) {\n            // Allow choices to be set in this->ht (for configurationOptions)\n            $this->_choices = $this->get('choices');\n            if (!$this->_choices) {\n                $this->_choices = array();\n                $config = $this->getConfiguration();\n                $choices = explode(\"\\n\", $config['choices']);\n                foreach ($choices as $choice) {\n                    // Allow choices to be key: value\n                    list($key, $val) = explode(':', $choice, 2);\n                    if ($val == null)\n                        $val = $key;\n                    $this->_choices[trim($key)] = trim($val);\n                }\n                // Add old selections if nolonger available\n                // This is necessary so choices made previously can be\n                // retained\n                $values = ($a=$this->getAnswer()) ? $a->getValue() : array();\n                if ($values && is_array($values)) {\n                    foreach ($values as $k => $v) {\n                        if (!isset($this->_choices[$k])) {\n                            if ($verbose) $v .= ' (retired)';\n                            $this->_choices[$k] = $v;\n                        }\n                    }\n                }\n            }\n        }\n        return $this->_choices;\n    }\n\n    function lookupChoice($value) {\n        return null;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>     __('does not have a value'),\n            'includes' =>   __('includes'),\n            '!includes' =>  __('does not include'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n            '!includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $val = $value;\n        if ($value && is_array($value))\n            $val = '\"?'.implode('(\"|,|$)|\"?', array_keys($value)).'(\"|,|$)';\n        switch ($method) {\n        case '!includes':\n            return Q::not(array(\"{$name}__regex\" => $val));\n        case 'includes':\n            return new Q(array(\"{$name}__regex\" => $val));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'includes':\n            return __('%s includes %s' /* includes -> if a list includes a selection */);\n        case '!includes':\n            return __('%s does not include %s' /* includes -> if a list includes a selection */);\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return $this->getChoices();\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        global $thisstaff;\n\n        $field = new AssigneeChoiceField();\n        //special assignment quick filters\n        switch (true) {\n            case ($qf_value == 'assigned'):\n            case ($qf_value == '!assigned'):\n                $result = $field->getSearchQ($qf_value, $qf_value);\n                return $query->filter($result);\n            case (strpos($qf_value, 's') !== false):\n            case (strpos($qf_value, 't') !== false):\n            case ($qf_value == 'M'):\n            case ($qf_value == 'T'):\n                $value = array($qf_value => $qf_value);\n                $result = $field->getSearchQ('includes', $value);\n                return $query->filter($result);\n                break;\n        }\n\n        return $query->filter(array(\n            $name ?: $this->get('name') => $qf_value,\n        ));\n    }\n}\n\nclass NumericField extends FormField {\n\n    function getSearchMethods() {\n        return array(\n            'equal' =>   __('Equal'),\n            'greater' =>  __('Greater Than'),\n            'less' =>  __('Less Than'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'equal' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n            'greater' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n            'less' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        switch ($method) {\n        case 'equal':\n            return new Q(array(\n                \"{$name}__exact\" => intval($value)\n            ));\n        break;\n        case 'greater':\n            return Q::any(array(\n                \"{$name}__gt\" => intval($value)\n            ));\n        break;\n        case 'less':\n            return Q::any(array(\n                \"{$name}__lt\" => intval($value)\n            ));\n        break;\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n}\n\nclass DatetimeField extends FormField {\n    static $widget = 'DatetimePickerWidget';\n\n    var $min = null;\n    var $max = null;\n\n    static function intervals($count=2, $i='') {\n        $intervals = array(\n            'i' => _N('minute', 'minutes', $count),\n            'h' => _N('hour', 'hours', $count),\n            'd' => _N('day','days', $count),\n            'w' => _N('week', 'weeks', $count),\n            'm' => _N('month', 'months', $count),\n        );\n        return $i ? $intervals[$i] : $intervals;\n    }\n\n    static function periods($period='') {\n        $periods = array(\n                'td' => __('Today'),\n                'yd' => __('Yesterday'),\n                'tw' => __('This Week'),\n                'tm' => __('This Month'),\n                'tq' => __('This Quarter'),\n                'ty' => __('This Year'),\n                'lw' => __('Last Week'),\n                'lm' => __('Last Month'),\n                'lq' => __('Last Quarter'),\n                'ly' => __('Last Year'),\n        );\n        return $period ? $periods[$period] : $periods;\n    }\n\n    // Get php DatateTime object of the field  - null if value is empty\n    function getDateTime($value=null) {\n        return Format::parseDateTime($value ?: $this->value);\n    }\n\n    // Get effective timezone for the field\n    function getTimeZone() {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        $timezone = new DateTimeZone($config['timezone'] ?:\n                $cfg->getTimezone());\n\n        return $timezone;\n    }\n\n    function getMinDateTime() {\n\n        if (!isset($this->min)) {\n            $config = $this->getConfiguration();\n            $this->min = $config['min']\n                ? Format::parseDateTime($config['min']) : false;\n        }\n\n        return $this->min;\n    }\n\n    function getMaxDateTime() {\n\n        if (!isset($this->max)) {\n            $config = $this->getConfiguration();\n            $this->max = $config['max']\n                ? Format::parseDateTime($config['max']) : false;\n        }\n\n        return $this->max;\n    }\n\n    static function getPastPresentLabels() {\n      return array(__('Create Date'), __('Reopen Date'),\n                    __('Close Date'), __('Last Update'));\n    }\n\n    function to_database($value) {\n        // Store time in format given by Date Picker (DateTime::W3C)\n        return $value;\n    }\n\n    function to_php($value) {\n\n        if (!is_numeric($value) && strtotime($value) <= 0)\n            return 0;\n\n        return $value;\n    }\n\n    function display($value) {\n        global $cfg;\n\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return '';\n\n        $config = $this->getConfiguration();\n        $format = $config['format'] ?: false;\n        if ($config['gmt'])\n            return $this->format((int) $datetime->format('U'), $format);\n\n        // Force timezone if field has one.\n        if ($config['timezone']) {\n            $timezone = new DateTimezone($config['timezone']);\n            $datetime->setTimezone($timezone);\n        }\n\n        $value = $this->format($datetime->format('U'),\n                $datetime->getTimezone()->getName(),\n                $format);\n        // No need to show timezone\n        if (!$config['time'] || $format)\n            return $value;\n\n        // Display is NOT timezone aware show entry's timezone.\n        return sprintf('%s (%s)',\n                $value, $datetime->format('T'));\n    }\n\n    function from_query($row, $name=false) {\n        $value = parent::from_query($row, $name);\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        return ($timestamp > 0) ? $timestamp : '';\n    }\n\n    function format($timestamp, $timezone=false, $format=false) {\n\n        if (!$timestamp || $timestamp <= 0)\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['time'])\n            $formatted = Format::datetime($timestamp, false, $format,  $timezone);\n        else\n            $formatted = Format::date($timestamp, false, $format, $timezone);\n\n        return $formatted;\n    }\n\n    function toString($value) {\n        if (is_array($value))\n            return '';\n\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        if ($timestamp <= 0)\n            return '';\n\n        return $this->format($timestamp);\n    }\n\n    function asVar($value, $id=false) {\n        global $cfg;\n\n        if (!$value)\n            return null;\n\n        $datetime = $this->getDateTime($value);\n        $config = $this->getConfiguration();\n        if (!$config['gmt'] || !$config['time'])\n            $timezone  = $datetime->getTimezone()->getName();\n        else\n            $timezone  = false;\n\n        return  new FormattedDate($value, array(\n                    'timezone'  =>  $timezone,\n                    'format'    =>  $config['time'] ? 'long' : 'short'\n                    )\n                );\n    }\n\n    function asVarType() {\n        return 'FormattedDate';\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'time' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Time'), 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>__('Show time selection with date picker')))),\n            'timezone' => new TimezoneField(array(\n                'id'=>2, 'label'=>__('Timezone'), 'required'=>false,\n                'hint'=>__('Timezone of the date time selection'),\n                'configuration' => array('autodetect'=>false,\n                    'prompt' => __(\"User's timezone\")),\n               'visibility' => new VisibilityConstraint(\n                    new Q(array('time__eq'=> true)),\n                    VisibilityConstraint::HIDDEN\n                ),\n                )),\n            'gmt' => new BooleanField(array(\n                'id'=>3, 'label'=>__('Timezone Aware'), 'required'=>false,\n                'configuration'=>array(\n                    'desc'=>__(\"Show date/time relative to user's timezone\")))),\n            'min' => new DatetimeField(array(\n                'id'=>4, 'label'=>__('Earliest'), 'required'=>false,\n                'hint'=>__('Earliest date selectable'))),\n            'max' => new DatetimeField(array(\n                'id'=>5, 'label'=>__('Latest'), 'required'=>false,\n                'default'=>null, 'hint'=>__('Latest date selectable'))),\n            'future' => new BooleanField(array(\n                'id'=>6, 'label'=>__('Allow Future Dates'), 'required'=>false,\n                'default'=>true, 'configuration'=>array(\n                    'desc'=>__('Allow entries into the future' /* Used in the date field */)),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        parent::validateEntry($value);\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return;\n\n        // Get configured min/max (if any)\n        $min = $this->getMinDateTime();\n        $max = $this->getMaxDateTime();\n\n        if (!$datetime) {\n            $this->_errors[] = __('Enter a valid date');\n        } elseif ($min and $datetime < $min) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is earlier than permitted'),\n                     Format::date($min->getTimestamp(), false, false,\n                         $min->getTimezone()->getName() ?: 'UTC')\n                     );\n        } elseif ($max and $datetime > $max) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is later than permitted'),\n                    Format::date($max->getTimestamp(), false, false,\n                        $max->getTimezone()->getName() ?: 'UTC')\n                    );\n        }\n    }\n\n    // SearchableField interface ------------------------------\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('on'),\n            'nequal' =>     __('not on'),\n            'before' =>     __('before'),\n            'after' =>      __('after'),\n            'between' =>    __('between'),\n            'period' =>     __('period'),\n            'ndaysago' =>   __('in the last n days'),\n            'ndays' =>      __('in the next n days'),\n            'future' =>     __('in the future'),\n            'past' =>       __('in the past'),\n            'distfut' =>    __('more than n days from now'),\n            'distpast' =>   __('more than n days ago'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        $config_notime = $config = $this->getConfiguration();\n        $config_notime['time'] = false;\n        $nday_form = function($x=5) {\n            return array(\n                'until' => new TextboxField(array(\n                    'configuration' => array('validator'=>'number', 'size'=>4))\n                ),\n                'int' => new ChoiceField(array(\n                    'default' => 'd',\n                    'choices' => self::intervals($x),\n                )),\n            );\n        };\n        return array(\n            'set' => null,\n            'nset' => null,\n            'past' => null,\n            'future' => null,\n            'equal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'nequal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'before' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'after' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'between' => array('InlineformField', array(\n                'form' => array(\n                    'left' => new DatetimeField($config + array('required' => true)),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => __('and')))\n                    ),\n                    'right' => new DatetimeField($config + array('required' => true)),\n                ),\n                'configuration' => array(\n                    'error' => '',\n                ),\n            )),\n            'period' => array('ChoiceField', array(\n                'choices' => self::periods(),\n            )),\n            'ndaysago' => array('InlineformField', array('form'=>$nday_form())),\n            'ndays' => array('InlineformField', array('form'=>$nday_form())),\n            'distfut' => array('InlineformField', array('form'=>$nday_form())),\n            'distpast' => array('InlineformField', array('form'=>$nday_form())),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        global $cfg;\n\n        static $intervals = array(\n            'm' => 'MONTH',\n            'w' => 'WEEK',\n            'd' => 'DAY',\n            'h' => 'HOUR',\n            'i' => 'MINUTE',\n        );\n        $name = $name ?: $this->get('name');\n        $now = SqlFunction::NOW();\n        $config = $this->getConfiguration();\n       if (is_int($value))\n          $value = DateTime::createFromFormat('U', !$config['gmt'] ? Misc::gmtime($value) : $value) ?: $value;\n       elseif (is_string($value) && strlen($value) > 2)\n           $value = Format::parseDateTime($value) ?: $value;\n\n        switch ($method) {\n        case 'equal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return new Q(array(\n                \"{$name}__gte\" => $l,\n                \"{$name}__lt\" => $r\n            ));\n        case 'nequal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return Q::any(array(\n                \"{$name}__lt\" => $l,\n                \"{$name}__gte\" => $r,\n            ));\n        case 'future':\n            $value = $now;\n        case 'after':\n            return new Q(array(\"{$name}__gte\" => $value));\n        case 'past':\n            $value = $now;\n        case 'before':\n            return new Q(array(\"{$name}__lt\" => $value));\n        case 'between':\n            $left = Format::parseDateTime($value['left']);\n            $right = Format::parseDateTime($value['right']);\n            if (!$left || !$right)\n                return null;\n\n            // TODO: allow time selection for between\n            $left = $left->setTime(00, 00, 00);\n            $right = $right->setTime(23, 59, 59);\n            // Convert time to db timezone\n            $dbtz = new DateTimeZone($cfg->getDbTimezone());\n            $left->setTimezone($dbtz);\n            $right->setTimezone($dbtz);\n            return new Q(array(\n                \"{$name}__gte\" =>  $left->format('Y-m-d H:i:s'),\n                \"{$name}__lte\" =>  $right->format('Y-m-d H:i:s'),\n            ));\n        case 'ndaysago':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__range\" => array($now->minus($interval), $now),\n            ));\n        case 'ndays':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__range\" => array($now, $now->plus($interval)),\n            ));\n        // Distant past and future ranges\n        case 'distpast':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__lte\" => $now->minus($interval),\n            ));\n        case 'distfut':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__gte\" => $now->plus($interval),\n            ));\n        case 'period':\n            // User's effective timezone\n            $tz = new DateTimeZone($cfg->getTimezone());\n            // Get the period range boundaries in user's tz\n            $period = Misc::date_range($value, Misc::gmtime('now'), $tz);\n            // Convert boundaries to db time\n            $dbtz = new DateTimeZone($cfg->getDbTimezone());\n            $start = $period->start->setTimezone($dbtz);\n            $end = $period->end->setTimezone($dbtz);\n            // Set the range\n            return new Q(array(\n                \"{$name}__range\" => array(\n                    $start->format('Y-m-d H:i:s'),\n                    $end->format('Y-m-d H:i:s')\n                    )\n                ));\n            break;\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'before':\n            return __('%1$s before %2$s' /* occurs before a date and time */);\n        case 'after':\n            return __('%1$s after %2$s' /* occurs after a date and time */);\n        case 'ndays':\n            return __('%1$s in the next %2$s' /* occurs within a window (like 3 days) */);\n        case 'ndaysago':\n            return __('%1$s in the last %2$s' /* occurs within a recent window (like 3 days) */);\n        case 'distfut':\n            return __('%1$s after %2$s from now' /* occurs after a window (like 3 days) */);\n        case 'distpast':\n            return __('%1$s before %2$s ago' /* occurs previous to a window (like 3 days) */);\n        case 'between':\n            return __('%1$s between %2$s and %3$s');\n        case 'future':\n            return __('%1$s is in the future');\n        case 'past':\n            return __('%1$s is in the past');\n        case 'period':\n            return __('%1$s is %2$s');\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n\n        $name = $name ?: $this->get('name');\n        $desc = $this->describeSearchMethod($method);\n        switch ($method) {\n            case 'between':\n                return sprintf($desc, $name,\n                        $this->toString($value['left']),\n                        $this->toString($value['right']));\n            case 'ndays':\n            case 'ndaysago':\n            case 'distfut':\n            case 'distpast':\n                $interval = sprintf('%s %s', $value['until'],\n                        self::intervals($value['until'], $value['int']));\n                return sprintf($desc, $name, $interval);\n                break;\n            case 'future':\n            case 'past':\n                return sprintf($desc, $name);\n            case 'before':\n            case 'after':\n                return sprintf($desc, $name, $this->toString($value));\n            case 'period':\n                return sprintf($desc, $name, self::periods($value) ?: $value);\n            default:\n                return parent::describeSearch($method, $value, $name);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return array(\n            'h' => __('Today'),\n            'm' => __('Tomorrow'),\n            'g' => __('Yesterday'),\n            'l7' => __('Last 7 days'),\n            'l30' => __('Last 30 days'),\n            'n7' => __('Next 7 days'),\n            'n30' => __('Next 30 days'),\n            /* Ugh. These boundaries are so difficult in SQL\n            'w' =>  __('This Week'),\n            'm' =>  __('This Month'),\n            'lw' => __('Last Week'),\n            'lm' => __('Last Month'),\n            'nw' => __('Next Week'),\n            'nm' => __('Next Month'),\n            */\n        );\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $now = SqlFunction::NOW();\n        $midnight = Misc::dbtime(time() - (time() % 86400));\n        switch ($qf_value) {\n        case 'l7':\n            return $query->filter([\n                \"{$name}__range\" => array($now->minus(SqlInterval::DAY(7)), $now),\n            ]);\n        case 'l30':\n            return $query->filter([\n                \"{$name}__range\" => array($now->minus(SqlInterval::DAY(30)), $now),\n            ]);\n        case 'n7':\n            return $query->filter([\n                \"{$name}__range\" => array($now, $now->plus(SqlInterval::DAY(7))),\n            ]);\n        case 'n30':\n            return $query->filter([\n                \"{$name}__range\" => array($now, $now->plus(SqlInterval::DAY(30))),\n            ]);\n        case 'g':\n            $midnight -= 86400;\n             // Fall through to the today case\n        case 'm':\n            if ($qf_value === 'm') $midnight += 86400;\n             // Fall through to the today case\n        case 'h':\n            $midnight = DateTime::createFromFormat('U', $midnight);\n            return $query->filter([\n                \"{$name}__range\" => array($midnight,\n                    SqlExpression::plus($midnight, SqlInterval::DAY(1))),\n            ]);\n        }\n    }\n}\n\n\n/**\n * TimeField for time selection\n *\n */\nclass TimeField extends FormField {\n    static $widget = 'TimePickerWidget';\n\n    var $start = null;\n    var $end = null;\n\n    function getTimeZone() {\n        global $cfg;\n        $config = $this->getConfiguration();\n        return new DateTimeZone($config['timezone'] ?: $cfg->getTimezone());\n    }\n}\n\n/**\n * This is kind-of a special field that doesn't have any data. It's used as\n * a field to provide a horizontal section break in the display of a form\n */\nclass SectionBreakField extends FormField {\n    static $widget = 'SectionBreakWidget';\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    function isEditableToStaff() {\n        return $this->isVisibleToStaff();\n    }\n\n    function isEditableToUsers() {\n        return $this->isVisibleToUsers();\n    }\n}\n\nclass ThreadEntryField extends FormField {\n    static $widget = 'ThreadEntryWidget';\n\n    function isChangeable() {\n        return false;\n    }\n    function isBlockLevel() {\n        return true;\n    }\n    function isPresentationOnly() {\n        return true;\n    }\n    function getMedia() {\n        $config = $this->getConfiguration();\n        $media = parent::getMedia() ?: array();\n        if ($config['attachments'])\n            $media = array_merge_recursive($media, FileUploadWidget::$media);\n        return $media;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n        $config = parent::getConfiguration();\n        $config['html'] = (bool) ($cfg && $cfg->isRichTextEnabled());\n        return $config;\n    }\n\n    function getConfigurationOptions() {\n        global $cfg;\n\n        $attachments = new FileUploadField();\n        $fileupload_config = $attachments->getConfigurationOptions();\n        if ($cfg->getAllowedFileTypes())\n            $fileupload_config['extensions']->set('default', $cfg->getAllowedFileTypes());\n\n        foreach ($fileupload_config as $C) {\n            $C->set('visibility', new VisibilityConstraint(new Q(array(\n                'attachments__eq'=>true,\n            )), VisibilityConstraint::HIDDEN));\n        }\n        return array(\n            'attachments' => new BooleanField(array(\n                'label'=>__('Enable Attachments'),\n                'default'=>$cfg->allowAttachments(),\n                'configuration'=>array(\n                    'desc'=>__('Enables attachments, regardless of channel'),\n                ),\n                'validators' => function($self, $value) {\n                    if (!ini_get('file_uploads'))\n                        $self->addError(__('The \"file_uploads\" directive is disabled in php.ini'));\n                }\n            )),\n        )\n        + $fileupload_config;\n    }\n\n    function isAttachmentsEnabled() {\n        $config = $this->getConfiguration();\n        return $config['attachments'];\n    }\n\n    function getWidget($widgetClass=false) {\n        if ($hint = $this->getLocal('hint'))\n            $this->set('placeholder', Format::striptags($hint));\n        $this->set('hint', null);\n        $widget = parent::getWidget($widgetClass);\n        return $widget;\n    }\n}\n\nclass TopicField extends ChoiceField {\n    var $topics;\n    var $_choices;\n\n    function getTopics() {\n        global $thisstaff;\n\n        if (!isset($this->topics))\n            $this->topics = $thisstaff->getTopicNames();\n\n        return $this->topics;\n    }\n\n    function getTopic($id) {\n        if ($this->getTopics() &&\n                isset($this->topics[$id]))\n            return Topic::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $default = $this->get('default');\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Topic)\n            $widget->value = $widget->value->getId();\n        elseif (!isset($widget->value) && $default)\n            $widget->value = $default;\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $this->_choices = $this->getTopics();\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Topic)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n\n        return $this->getTopic($id);\n    }\n\n    function to_database($topic) {\n        return ($topic instanceof Topic)\n            ? array($topic->getName(), $topic->getId())\n            : $topic;\n    }\n\n    function display($topic, &$styles=null) {\n        if (!$topic instanceof Topic)\n            return parent::display($topic);\n\n        return Format::htmlchars($topic->getName());\n    }\n\n    function toString($value) {\n        if (!($value instanceof Topic) && is_numeric($value))\n            $value = $this->getTopic($value);\n\n        return ($value instanceof Topic) ? $value->getName() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Topic) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultTopicId();\n        return $config;\n    }\n}\n\nclass SLAField extends ChoiceField {\n    var $slas;\n    var $_choices;\n\n    function getSLAs() {\n        if (!isset($this->slas))\n            $this->slas = SLA::objects();\n\n        return $this->slas;\n    }\n\n    function getSLA($id) {\n        if ($this->getSLAs() &&\n                ($s=$this->slas->findFirst(array('id' => $id))))\n            return $s;\n\n        return SLA::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $default = $this->get('default');\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof SLA)\n            $widget->value = $widget->value->getId();\n        elseif (!isset($widget->value) && $default)\n            $widget->value = $default;\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $choices = array();\n            foreach ($this->getSLAs() as $s)\n                $choices[$s->getId()] = $s->getName();\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof SLA)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n\n        return $this->getSLA($id);\n    }\n\n    function to_database($sla) {\n        return ($sla instanceof SLA)\n            ? array($sla->getName(), $sla->getId())\n            : $sla;\n    }\n\n    function display($sla, &$styles=null) {\n        if (!$sla instanceof SLA)\n            return parent::display($sla);\n\n        return Format::htmlchars($sla->getName());\n    }\n\n    function toString($value) {\n        if (!($value instanceof SLA) && is_numeric($value))\n            $value = $this->getSLA($value);\n        return ($value instanceof SLA) ? $value->getName() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof SLA) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultSLAId();\n        return $config;\n    }\n}\n\nclass PriorityField extends ChoiceField {\n\n    var $priorities;\n    var $_choices;\n\n    function getPriorities() {\n        if (!isset($this->priorities))\n            $this->priorities = Priority::objects();\n\n        return $this->priorities;\n    }\n\n    function getPriority($id) {\n\n        if ($this->getPriorities() &&\n                ($p=$this->priorities->findFirst(array('priority_id' =>\n                                                       $id))))\n            return $p;\n\n        return Priority::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Priority)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $choices = array();\n            foreach ($this->getPriorities() as $p)\n                $choices[$p->getId()] = $p->getDesc();\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Priority)\n            return $value;\n\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        } elseif (is_array($value)) {\n            list($value, $id) = $value;\n        } elseif ($id === false && is_numeric($value))\n            $id = $value;\n\n        if (is_numeric($id))\n            return $this->getPriority($id);\n\n        return $value;\n    }\n\n    function to_database($value) {\n        if ($value instanceof Priority)\n            return array($value->getDesc(), $value->getId());\n\n        if (is_array($value))\n            return array(current($value), key($value));\n\n        return $value;\n    }\n\n    function display($prio, &$styles=null) {\n        if (!$prio instanceof Priority)\n            return parent::display($prio);\n        if (is_array($styles))\n            $styles += array(\n                'background-color' => $prio->getColor()\n            );\n        return Format::htmlchars($prio->getDesc());\n    }\n\n    function toString($value) {\n        return ($value instanceof Priority) ? $value->getDesc() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        // Priority isn't searchable this way\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Priority) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfigurationOptions() {\n        $choices = $this->getChoices();\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n            'default' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'choices' => $choices,\n                'hint'=>__('Default selection for this field'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n        );\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultPriorityId();\n        return $config;\n    }\n\n    function applyOrderBy($query, $reverse=false, $name=false) {\n        if ($query->model == 'Ticket' && $name == 'cdata__priority') {\n            // Order by the priority urgency field\n            $col = 'cdata__:priority__priority_urgency';\n            $reverse = !$reverse;\n        }\n        else {\n            $col = $name ?: CustomQueue::getOrmPath($this->get('name'), $query);\n        }\n        if ($reverse)\n            $col = \"-$col\";\n        return $query->order_by($col);\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'priority' => array(__('Priority Level'), 'PriorityField'),\n    );\n});\n\n\nclass TimezoneField extends ChoiceField {\n    static $widget = 'TimezoneWidget';\n\n    function hasIdValue() {\n        return false;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        global $cfg;\n\n        $choices = array();\n        foreach (DateTimeZone::listIdentifiers() as $zone)\n            $choices[$zone] =  str_replace('/',' / ',$zone);\n\n        return $choices;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'autodetect' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Auto Detect'), 'required'=>false, 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add Auto Detect Button'))\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\n\nclass DepartmentField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = $this->_widget ?: parent::getWidget($widgetClass);\n        if (is_object($widget->value))\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        global $cfg, $thisstaff;\n\n        $config = $this->getConfiguration();\n        $staff = $config['staff'] ?: $thisstaff;\n        $selected = $this->getWidget();\n        if($selected && $selected->value) {\n          if(is_array($selected->value)) {\n            foreach ($selected->value as $k => $v) {\n              $current_id = $k;\n              $current_name = $v;\n            }\n          }\n          else {\n            $current_id = $selected->value;\n            $current_name = Dept::getNameById($current_id);\n          }\n        }\n\n        $choices = array();\n\n        //get all depts unfiltered\n        $depts = $config['hideDisabled'] ? Dept::getDepartments(array('activeonly' => true)) :\n            Dept::getDepartments(null, true, Dept::DISPLAY_DISABLED);\n\n        //get staff depts based on permissions\n        if ($staff) {\n            $active = $staff->getDepartmentNames(true);\n\n            if ($staff->hasPerm(Dept::PERM_DEPT))\n                return $depts;\n        }\n        //filter custom department fields when there is no staff\n        else {\n            $userDepts = Dept::getDepartments(array('publiconly' => true, 'activeonly' => true));\n\n            return $userDepts;\n        }\n\n         //add selected dept to list\n         if($current_id)\n            $active[$current_id] = $current_name;\n         else\n            return $active;\n\n         foreach ($depts as $id => $name) {\n            $choices[$id] = $name;\n            if(!array_key_exists($id, $active) && $current_id)\n                unset($choices[$id]);\n         }\n\n        return $choices;\n    }\n\n    function display($dept, &$styles=null) {\n        if (!is_numeric($dept) && is_string($dept))\n            return Format::htmlchars($dept);\n        elseif ($dept instanceof Dept)\n            return Format::htmlchars($dept->getName());\n\n        return parent::display($dept);\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function getValue() {\n         if (($value = parent::getValue()) && ($id=$this->getClean()))\n            return $value[$id];\n     }\n\n    function to_php($value, $id=false) {\n        if ($id) {\n            if (is_array($id)) {\n                reset($id);\n                $id = key($id);\n            }\n            return $id;\n        } else {\n            return $value;\n        }\n    }\n\n    function to_database($dept) {\n        if ($dept instanceof Dept)\n            return array($dept->getName(), $dept->getId());\n\n        if (!is_array($dept)) {\n            $choices = $this->getChoices();\n            if (in_array($dept, $choices)) {\n                $deptId = array_search($dept, $choices);\n                $dept = array($dept, $deptId);\n            }\n         }\n\n        return $dept ?: array();\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getChoice($value) {\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value])) {\n            $selection[] = $choices[$value];\n        }\n\n        return $selection;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'department' => array(__('Department'), 'DepartmentField'),\n    );\n});\n\nclass AssigneeField extends ChoiceField {\n    var $_choices = null;\n    var $_criteria = null;\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        $value = $widget->value;\n        if (is_object($value)) {\n            $id = $value->getId();\n            if ($value instanceof Staff)\n                $widget->value = 's'.$id;\n            elseif ($value instanceof Team)\n                $widget->value = 't'.$id;\n        }\n        return $widget;\n    }\n\n    function getCriteria() {\n        if (!isset($this->_criteria)) {\n            $this->_criteria = array('available' => true, 'namesOnly' => true);\n            if (($c=parent::getCriteria()))\n                $this->_criteria = array_merge($this->_criteria, $c);\n        }\n\n        return $this->_criteria;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function setChoices($choices) {\n        $this->_choices = $choices;\n    }\n\n    function display($value) {\n        if ($this->getAnswer() && is_string($this->getAnswer()->value)) {\n            $v = JsonDataParser::parse($this->getAnswer()->value);\n            if (is_array($v))\n                $value = $v[key($v)];\n        }\n        return $value;\n    }\n\n    function getAssignees($options=array()) {\n        global $thisstaff;\n\n        $config = $this->getConfiguration();\n        $criteria = $this->getCriteria();\n        $dept = $config['dept'] ?: null;\n        $staff = $config['staff'] ?: $thisstaff;\n        $assignees = array();\n        switch (strtolower($config['target'])) {\n        case 'agents':\n            if ($dept)\n                foreach ($dept->getAssignees(array('staff' => $staff)) as $a)\n                    $assignees['s'.$a->getId()] = $a;\n            else\n                foreach (Staff::getStaffMembers(array('staff' => $staff)) as $id => $name)\n                    $assignees['s'.$id] = $name;\n            break;\n        case 'teams':\n            foreach (Team::getActiveTeams() ?: array() as $id => $name)\n                $assignees['t'.$id] = $name;\n            break;\n        default:\n            // both agents and teams\n            $assignees = array(\n                    __('Agents') => new ArrayObject(),\n                    __('Teams') => new ArrayObject());\n            $A = current($assignees);\n            $criteria = $this->getCriteria();\n            $agents = array();\n            if ($dept)\n                foreach ($dept->getAssignees(array('staff' => $staff)) as $a)\n                    $A['s'.$a->getId()] = $a;\n            else\n                foreach (Staff::getStaffMembers(array('staff' => $staff)) as $a => $name)\n                    $A['s'.$a] = $name;\n\n            next($assignees);\n            $T = current($assignees);\n            if (($teams = Team::getActiveTeams()))\n                foreach ($teams as $id => $name)\n                    $T['t'.$id] = $name;\n            break;\n        }\n\n        return $assignees;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices))\n            $this->_choices = $this->getAssignees($options);\n\n        return $this->_choices;\n    }\n\n    function getChoice($value) {\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_object($value)) {\n            $keys = null;\n            if ($value instanceof Staff)\n                $keys = array('Agents', 's'.$value->getId());\n            elseif ($value instanceof Team)\n                $keys = array('Teams', 't'.$value->getId());\n            if ($keys && isset($choices[$keys[0]]))\n                $selection = $choices[$keys[0]][$keys[1]];\n\n            if (!empty($selection))\n                return $selection;\n        }\n\n        return parent::getChoice($value);\n    }\n\n    function getQuickFilterChoices() {\n        $choices = $this->getChoices();\n        $names = array();\n        foreach ($choices as $value) {\n            foreach ($value as $key => $value)\n                $names[$key] = is_object($value) ? $value->name : $value;\n        }\n\n        return $names;\n    }\n\n    function getValue() {\n        if (($value = parent::getValue()) && ($id=$this->getClean())) {\n            $name = (is_object($value[key($value)]) && get_class($value[key($value)]) == 'AgentsName') ?\n                $value[key($value)]->name : $value[key($value)];\n            $key = (($value[key($value)] instanceof AgentsName) ? 's' : 't').substr(key($value), 1);\n            return array(array($key => $name), substr(key($value), 1));\n        } else\n            return null;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            list($key, $V) = array_map('trim', explode(',', $value));\n\n            $values[$key] = $V;\n            $value = $values;\n        }\n\n        $type = '';\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n            $type = $id[0];\n            $id = substr($id, 1);\n        }\n        if (is_array($value)) {\n            $type = key($value)[0];\n            if (!$id)\n                $id = substr(key($value), 1);\n        }\n\n        if (!$type && is_numeric($value))\n            return Staff::lookup($value);\n\n        switch ($type) {\n        case 's':\n            return Staff::lookup($id);\n        case 't':\n            return Team::lookup($id);\n        case 'd':\n            return Dept::lookup($id);\n        default:\n            return $id;\n        }\n    }\n\n    function to_database($value) {\n        if (is_object($value)) {\n            $id = $value->getId();\n            if ($value instanceof Staff) {\n                $key = 's'.$id;\n                $name = $value->getName()->name;\n            } elseif ($value instanceof Team) {\n                $key = 't'.$id;\n                $name = $value->getName();\n            }\n\n            return JsonDataEncoder::encode(array($key => $name));\n        }\n        if (is_array($value)) {\n            return JsonDataEncoder::encode($value[0]);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        $value = $this->to_database($value);\n        if (is_array($value))\n            return $value[0];\n\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $v = $this->to_php($value, $id);\n        return $v ? $v->getName() : null;\n    }\n\n    function getChanges() {\n        $new = $this->to_database($this->getValue());\n        $old = $this->to_database($this->answer ? $this->answer->getValue()\n                : $this->get('default'));\n        // Compare old and new\n        return ($old == $new)\n            ? false\n            : array($old, $new);\n    }\n\n    function whatChanged($before, $after) {\n        if ($before)\n            $before = array($before->getName());\n        if ($after)\n            $after = array($after->getName());\n\n        return parent::whatChanged($before, $after);\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'assignee' => array(__('Assignee'), 'AssigneeField'),\n    );\n});\n\n\nclass TicketStateField extends ChoiceField {\n\n    static $_states = array(\n            'open' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Open',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Open'\n                ),\n            'closed' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Closed',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Close'\n                )\n            );\n    // Private states\n    static $_privatestates = array(\n            'archived' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Archived',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Archive'\n                ),\n            'deleted'  => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Deleted',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Delete'\n                )\n            );\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return false;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        static $_choices;\n\n        $states = static::$_states;\n        if ($this->options['private_too'])\n            $states += static::$_privatestates;\n\n        if (!isset($_choices)) {\n            // Translate and cache the choices\n            foreach ($states as $k => $v)\n                $_choices[$k] =  _P('ticket state name', $v['name']);\n\n            $this->ht['default'] =  '';\n        }\n\n        return $_choices;\n    }\n\n    function getChoice($state) {\n\n        if ($state && is_array($state))\n            $state = key($state);\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state name', static::$_states[$state]['name']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state name', static::$_privatestates[$state]['name']);\n\n        return $state;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=> __('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=> __('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n\n    static function getVerb($state) {\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state action', static::$_states[$state]['verb']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state action', static::$_privatestates[$state]['verb']);\n    }\n}\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'state' => array('Ticket State', 'TicketStateField', false),\n    );\n});\n\nclass TicketFlagField extends ChoiceField {\n\n    // Supported flags (TODO: move to configurable custom list)\n    static $_flags = array(\n            'onhold' => array(\n                'flag' => 1,\n                'name' => 'Onhold',\n                'states' => array('open'),\n                ),\n            'overdue' => array(\n                'flag' => 2,\n                'name' => 'Overdue',\n                'states' => array('open'),\n                ),\n            'answered' => array(\n                'flag' => 4,\n                'name' => 'Answered',\n                'states' => array('open'),\n                )\n            );\n\n    var $_choices;\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        $this->ht['default'] =  '';\n\n        if (!$this->_choices) {\n            foreach (static::$_flags as $k => $v)\n                $this->_choices[$k] = $v['name'];\n        }\n\n        return $this->_choices;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>'Prompt', 'required'=>false, 'default'=>'',\n                'hint'=>'Leading text shown before a value is selected',\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'flags' => array('Ticket Flags', 'TicketFlagField', false),\n    );\n});\n\nclass FileUploadField extends FormField {\n    static $widget = 'FileUploadWidget';\n\n    protected $attachments;\n    protected $files;\n\n    static function getFileTypes() {\n        static $filetypes;\n\n        if (!isset($filetypes)) {\n            if (function_exists('apcu_fetch')) {\n                $key = md5(SECRET_SALT . GIT_VERSION . 'filetypes');\n                $filetypes = apcu_fetch($key);\n            }\n            if (!$filetypes)\n                $filetypes = YamlDataParser::load(INCLUDE_DIR . '/config/filetype.yaml');\n            if ($key)\n                apcu_store($key, $filetypes, 7200);\n        }\n        return $filetypes;\n    }\n\n    function getConfigurationOptions() {\n        // Compute size selections\n        $sizes = array('262144' => '\u2014 '.__('Small').' \u2014');\n        $next = 512 << 10;\n        $max = strtoupper(ini_get('upload_max_filesize'));\n        $limit = (int) $max;\n        if (!$limit) $limit = 2 << 20; # 2M default value\n        elseif (strpos($max, 'K')) $limit <<= 10;\n        elseif (strpos($max, 'M')) $limit <<= 20;\n        elseif (strpos($max, 'G')) $limit <<= 30;\n        while ($next <= $limit) {\n            // Select the closest, larger value (in case the\n            // current value is between two)\n            $sizes[$next] = Format::file_size($next);\n            $next *= 2;\n        }\n        // Add extra option if top-limit in php.ini doesn't fall\n        // at a power of two\n        if ($next < $limit * 2)\n            $sizes[$limit] = Format::file_size($limit);\n\n        $types = array();\n        foreach (self::getFileTypes() as $type=>$info) {\n            $types[$type] = $info['description'];\n        }\n\n        global $cfg;\n        return array(\n            'size' => new ChoiceField(array(\n                'label'=>__('Maximum File Size'),\n                'hint'=>__('Choose maximum size of a single file uploaded to this field'),\n                'default'=>$cfg->getMaxFileSize(),\n                'choices'=>$sizes\n            )),\n            'mimetypes' => new ChoiceField(array(\n                'label'=>__('Restrict by File Type'),\n                'hint'=>__('Optionally, choose acceptable file types.'),\n                'required'=>false,\n                'choices'=>$types,\n                'configuration'=>array('multiselect'=>true,'prompt'=>__('No restrictions'))\n            )),\n            'extensions' => new TextareaField(array(\n                'label'=>__('Additional File Type Filters'),\n                'hint'=>__('Optionally, enter comma-separated list of additional file types, by extension. (e.g .doc, .pdf).'),\n                'configuration'=>array('html'=>false, 'rows'=>2),\n            )),\n            'max' => new TextboxField(array(\n                'label'=>__('Maximum Files'),\n                'hint'=>__('Users cannot upload more than this many files.'),\n                'default'=>false,\n                'required'=>false,\n                'validator'=>'number',\n                'configuration'=>array('size'=>8, 'length'=>4, 'placeholder'=>__('No limit')),\n            ))\n        );\n    }\n\n    /**\n     * Called from the ajax handler for async uploads via web clients.\n     */\n    function ajaxUpload($bypass=false) {\n        $config = $this->getConfiguration();\n\n        $files = AttachmentFile::format($_FILES['upload'],\n            // For numeric fields assume configuration exists\n            !is_numeric($this->get('id')));\n        if (count($files) != 1)\n            Http::response(400, 'Send one file at a time');\n        $file = array_shift($files);\n        $file['name'] = urldecode($file['name']);\n\n        if (!self::isValidFile($file))\n            Http::response(413, 'Invalid File');\n\n        if (!$bypass && !$this->isValidFileType($file['name'], $file['type']))\n            Http::response(415, 'File type is not allowed');\n\n        $config = $this->getConfiguration();\n        if (!$bypass && $file['size'] > $config['size'])\n            Http::response(413, 'File is too large');\n\n        if (!($F = AttachmentFile::upload($file)))\n            Http::response(500, 'Unable to store file: '. $file['error']);\n\n        $id = $F->getId();\n\n        // This file is allowed for attachment in this session\n        $_SESSION[':uploadedFiles'][$id] = $F->getName();\n\n        return $id;\n    }\n\n    /**\n     * Called from FileUploadWidget::getValue() when manual upload is used\n     * for browsers which do not support the HTML5 way of uploading async.\n     */\n    function uploadFile($file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!self::isValidFile($file))\n             throw new FileUploadError(__('Invalid File'));\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        return AttachmentFile::upload($file);\n    }\n\n    /**\n     * Called from API and email routines and such to handle attachments\n     * sent other than via web upload\n     */\n    function uploadAttachment(&$file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk']))\n            $file['data'] = $file['data_cbk']();\n\n        if (!isset($file['size']) && isset($file['data'])) {\n            // bootstrap.php include a compat version of mb_strlen\n            if (extension_loaded('mbstring'))\n                $file['size'] = mb_strlen($file['data'], '8bit');\n            else\n                $file['size'] = strlen($file['data']);\n        }\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        if (!$F = AttachmentFile::create($file))\n            throw new FileUploadError(__('Unable to save file'));\n\n        return $F;\n    }\n\n    static function isValidFile($file) {\n\n        // Check invalid image hacks\n        if ($file['tmp_name']\n                && stripos($file['type'], 'image/') === 0\n                && !exif_imagetype($file['tmp_name']))\n            return false;\n\n        return true;\n    }\n\n    function isValidFileType($name, $type=false) {\n        $config = $this->getConfiguration();\n\n        // Check MIME type - file ext. shouldn't be solely trusted.\n        if ($type && $config['__mimetypes']\n                && in_array($type, $config['__mimetypes'], true))\n            return true;\n\n        // Return true if all file types are allowed (.*)\n        if (!$config['__extensions'] || in_array('.*', $config['__extensions']))\n            return true;\n\n        $allowed = $config['__extensions'];\n        $ext = strtolower(pathinfo($name, PATHINFO_EXTENSION));\n\n        return ($ext && is_array($allowed) && in_array(\".$ext\", $allowed));\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments) && ($a = $this->getAnswer())\n            && ($e = $a->getEntry()) && ($e->get('id'))\n        ) {\n            $this->attachments = GenericAttachments::forIdAndType(\n                // Combine the field and entry ids to make the key\n                sprintf('%u', abs(crc32('E'.$this->get('id').$e->get('id')))),\n                'E');\n        }\n        return $this->attachments ?: array();\n    }\n\n    function setAttachments(GenericAttachments $att) {\n        $this->attachments = $att;\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            foreach ($this->getAttachments() as $a) {\n                if ($a && ($f=$a->getFile()))\n                    $files[] = $f;\n            }\n\n            foreach ($this->getClean(false) ?: array() as $key => $value)\n                $files[] = array('id' => $key, 'name' => $value);\n\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        // If no size present default to system setting\n        $config['size'] ??= $cfg->getMaxFileSize();\n        $_types = self::getFileTypes();\n        $mimetypes = array();\n        $extensions = array();\n        if (isset($config['mimetypes']) && is_array($config['mimetypes'])) {\n            foreach ($config['mimetypes'] as $type=>$desc) {\n                foreach ($_types[$type]['types'] as $mime=>$exts) {\n                    $mimetypes[$mime] = true;\n                    if (is_array($exts))\n                        foreach ($exts as $ext)\n                            $extensions['.'.$ext] = true;\n                }\n            }\n        }\n        if (strpos($config['extensions'], '.*') !== false)\n            $config['extensions'] = '';\n\n        if (is_string($config['extensions'])) {\n            foreach (preg_split('/\\s+/', str_replace(',',' ', $config['extensions'])) as $ext) {\n                if (!$ext) {\n                    continue;\n                }\n                elseif (strpos($ext, '/')) {\n                    $mimetypes[$ext] = true;\n                }\n                else {\n                    if ($ext[0] != '.')\n                        $ext = '.' . $ext;\n\n                    // Ensure that the extension is lower-cased for comparison latr\n                    $ext = strtolower($ext);\n\n                    // Add this to the MIME types list so it can be exported to\n                    // the @accept attribute\n                    if (!isset($extensions[$ext]))\n                        $mimetypes[$ext] = true;\n\n                    $extensions[$ext] = true;\n                }\n            }\n            $config['__extensions'] = array_keys($extensions);\n        }\n        elseif (is_array($config['extensions'])) {\n            $config['__extensions'] = $config['extensions'];\n        }\n\n        // 'mimetypes' is the array represented from the user interface,\n        // '__mimetypes' is a complete list of supported MIME types.\n        $config['__mimetypes'] = array_keys($mimetypes);\n        return $config;\n    }\n\n    // When the field is saved to database, encode the ID listing as a json\n    // array. Then, inspect the difference between the files actually\n    // attached to this field\n    function to_database($value) {\n        $this->getAttachments();\n        if (isset($this->attachments) && $this->attachments) {\n            $this->attachments->keepOnlyFileIds($value);\n        }\n        return JsonDataEncoder::encode($value) ?? NULL;\n    }\n\n    function parse($value) {\n        return $value;\n    }\n\n    function to_php($value) {\n        return is_array($value) ? $value : JsonDataParser::decode($value);\n    }\n\n    function display($value) {\n        $links = array();\n        foreach ($this->getAttachments() as $a) {\n            $links[] = sprintf('<a class=\"no-pjax\" href=\"%s\"><i class=\"icon-paperclip icon-flip-horizontal\"></i> %s</a>',\n                Format::htmlchars($a->file->getDownloadUrl()),\n                Format::htmlchars($a->getFilename()));\n        }\n        return implode('<br/>', $links);\n    }\n\n    function toString($value) {\n        $files = array();\n        foreach ($this->getFiles() as $f) {\n            $files[] = $f->name;\n        }\n        return implode(', ', $files);\n    }\n\n    function db_cleanup($field=false) {\n        if ($this->getAttachments()) {\n            $this->attachments->deleteAll();\n        }\n    }\n\n    function asVar($value, $id=false) {\n        if (($attachments = $this->getAttachments()))\n            $attachments = $attachments->all();\n\n        return new FileFieldAttachments($attachments ?: array());\n    }\n    function asVarType() {\n        return 'FileFieldAttachments';\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = Format::htmlchars(array_values($added));\n        $deleted = Format::htmlchars(array_values($deleted));\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n}\n\nclass FileFieldAttachments {\n    var $attachments;\n\n    function __construct($attachments) {\n        $this->attachments = $attachments;\n    }\n\n    function __toString() {\n        $files = array();\n        foreach ($this->getAttachments() as $a) {\n            $files[] = $a->getFilename();\n        }\n        return implode(', ', $files);\n    }\n\n    function getAttachments() {\n        return $this->attachments ?: array();\n    }\n\n    function getVar($tag) {\n        switch ($tag) {\n        case 'names':\n            return $this->__toString();\n        case 'files':\n            throw new OOBContent(OOBContent::FILES, $this->getAttachments());\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of file names'),\n            'files' => __('Attached files'),\n        );\n    }\n}\n\nclass ColorChoiceField extends FormField {\n    static $widget = 'ColorPickerWidget';\n}\n\nclass InlineFormData extends ArrayObject {\n    var $_form;\n\n    function __construct($form, array $data=array()) {\n        parent::__construct($data);\n        $this->_form = $form;\n    }\n\n    function getVar($tag) {\n        foreach ($this->_form->getFields() as $f) {\n            if ($f->get('name') == $tag)\n                return $this[$f->get('id')];\n        }\n    }\n}\n\n\nclass InlineFormField extends FormField {\n    static $widget = 'InlineFormWidget';\n\n    var $_iform = null;\n\n    function validateEntry($value) {\n        if (!$this->getInlineForm()->isValid()) {\n            $config = $this->getConfiguration();\n            $this->_errors[] = isset($config['error'])\n                ? $config['error'] : __('Correct any errors below and try again.');\n        }\n    }\n\n    function parse($value) {\n        // The InlineFieldWidget returns an array of cleaned data\n        return $value;\n    }\n\n    function to_database($value) {\n        return JsonDataEncoder::encode($value);\n    }\n\n    function to_php($value) {\n        $data = JsonDataParser::decode($value);\n        // The InlineFormData helps with the variable replacer API\n        return new InlineFormData($this->getInlineForm(), $data);\n    }\n\n    function display($data) {\n        $form = $this->getInlineForm();\n        ob_start(); ?>\n        <div><?php\n        foreach ($form->getFields() as $field) { ?>\n            <span style=\"display:inline-block;padding:0 5px;vertical-align:top\">\n                <strong><?php echo Format::htmlchars($field->get('label')); ?></strong>\n                <div><?php\n                    $value = $data[$field->get('id')];\n                    echo $field->display($value); ?></div>\n            </span><?php\n        } ?>\n        </div><?php\n        return ob_get_clean();\n    }\n\n    function getInlineForm($data=false) {\n        $form = $this->get('form');\n        if (is_array($form)) {\n            $form = new SimpleForm($form, $data ?: $this->value ?: $this->getSource());\n            // Ensure unique, but predictable form and field IDs\n            $form->setId(sprintf('%u', crc32($this->get('name')) >> 1));\n        }\n        return $form;\n    }\n}\n\nclass InlineDynamicFormField extends FormField {\n    function getInlineForm($data=false) {\n        if (!isset($this->_iform) || $data) {\n            $config = $this->getConfiguration();\n            $this->_iform = DynamicForm::lookup($config['form']);\n            if ($data)\n                $this->_iform = $this->_iform->getForm($data);\n        }\n        return $this->_iform;\n    }\n\n    function getConfigurationOptions() {\n        $forms = DynamicForm::objects()->filter(array('type'=>'G'))\n            ->values_flat('id', 'title');\n        $choices = array();\n        foreach ($forms as $row) {\n            list($id, $title) = $row;\n            $choices[$id] = $title;\n        }\n        return array(\n            'form' => new ChoiceField(array(\n                'id'=>2, 'label'=>'Inline Form', 'required'=>true,\n                'default'=>'', 'choices'=>$choices\n            )),\n        );\n    }\n}\n\nclass InlineFormWidget extends Widget {\n    function render($mode=false) {\n        $form = $this->field->getInlineForm();\n        if (!$form)\n            return;\n        // Handle first-step edits -- load data from $this->value\n        if ($form instanceof DynamicForm && !$form->getSource())\n            $form = $form->getForm($this->value);\n        $inc = ($mode == 'client') ? CLIENTINC_DIR : STAFFINC_DIR;\n        include $inc . 'templates/inline-form.tmpl.php';\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (!$data)\n            return null;\n        $form = $this->field->getInlineForm($data);\n        if (!$form)\n            return null;\n        return $form->getClean();\n    }\n}\n\nclass Widget {\n    static $media = null;\n\n    function __construct($field) {\n        $this->field = $field;\n        $this->name = $field->getFormName();\n        $this->id = '_' . $this->name;\n    }\n\n    function parseValue() {\n        $this->value = $this->getValue();\n        if (!isset($this->value) && is_object($this->field->getAnswer()))\n            $this->value = $this->field->getAnswer()->getValue();\n        if (!isset($this->value) && isset($this->field->value))\n            $this->value = $this->field->value;\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        foreach ($this->field->getFormNames() as $name)\n            if (isset($data[$name]))\n                return $data[$name];\n\n        return null;\n    }\n\n    /**\n     * getJsValueGetter\n     *\n     * Used with the dependent fields feature, this function should return a\n     * single javascript expression which can be used in a larger expression\n     * (<> == true, where <> is the result of this function). The %s token\n     * will be replaced with a jQuery variable representing this widget.\n     */\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.val()', $id);\n    }\n\n    /**\n     * getJsComparator\n     *\n     * Used with the dependent fields to get comparison expression\n     *\n     */\n    function getJsComparator($value, $id) {\n\n        if (strpos($value, '|') !== false)\n            return sprintf('$.inArray(%s, %s) !== -1',\n                   $this->getJsValueGetter($id),\n                   JsonDataEncoder::encode(explode('|', $value)));\n\n        return sprintf('%s == %s',\n                $this->getJsValueGetter($id),\n                JsonDataEncoder::encode($value));\n    }\n}\n\nclass TextboxWidget extends Widget {\n    static $input_type = 'text';\n\n    function render($options=array(), $extraConfig=false) {\n        $config = $this->field->getConfiguration();\n        if (is_array($extraConfig)) {\n            foreach ($extraConfig as $k=>$v)\n                if (!isset($config[$k]) || !$config[$k])\n                    $config[$k] = $v;\n        }\n\n        // Input attributes\n        $attrs = array();\n        foreach ($config as $k => $v) {\n            switch ($k) {\n                case 'autocomplete':\n                    if (is_numeric($v))\n                        $v = $v ? 'on' : 'off';\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'disabled';\n                    $attrs[$k] = '\"disabled\"';\n                    break;\n                case 'translatable':\n                    if ($v)\n                        $attrs['data-translate-tag'] =  '\"'.$v.'\"';\n                    break;\n                case 'length':\n                    $k = 'maxlength';\n                case 'size':\n                case 'maxlength':\n                    if ($v && is_numeric($v))\n                        $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'class':\n                case 'classes':\n                    $attrs['class'] = '\"'.$v.'\"';\n                    break;\n                case 'inputmode':\n                case 'pattern':\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n            }\n        }\n        // autofocus\n        $autofocus = '';\n        if (isset($config['autofocus']))\n            $autofocus = 'autofocus';\n        // placeholder\n        $attrs['placeholder'] = sprintf('\"%s\"',\n                Format::htmlchars($this->field->getLocal('placeholder',\n                    $config['placeholder'])));\n        $type = static::$input_type;\n        $types = array(\n            'email' => 'email',\n            'phone' => 'tel',\n        );\n        if ($type == 'text' && isset($types[$config['validator']]))\n            $type = $types[$config['validator']];\n        ?>\n        <input type=\"<?php echo $type; ?>\"\n            id=\"<?php echo $this->id; ?>\"\n            <?php echo $autofocus .' '.Format::array_implode('=', ' ',\n                    array_filter($attrs)); ?>\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value, true); ?>\"/>\n        <?php\n    }\n}\n\n\nclass TextboxSelectionWidget extends TextboxWidget {\n    //TODO: Support multi-input e.g comma separated inputs\n    function render($options=array(), $extraConfig=array()) {\n\n        if ($this->value && is_array($this->value))\n            $this->value = current($this->value);\n\n        parent::render($options);\n    }\n\n    function getValue() {\n\n        $value = parent::getValue();\n        if ($value && ($item=$this->field->lookupChoice((string) $value)))\n            $value = $item;\n\n        return $value;\n    }\n}\n\nclass PasswordWidget extends TextboxWidget {\n    static $input_type = 'password';\n\n    function render($mode=false, $extra=false) {\n        $extra = array();\n        if ($this->field->value) {\n            $extra['placeholder'] = '\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022';\n        }\n        return parent::render($mode, $extra);\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        // Show empty box unless failed POST\n        if ($_SERVER['REQUEST_METHOD'] != 'POST'\n                || !$this->field->getForm()->isValid())\n            $this->value = '';\n    }\n}\n\nclass TextareaWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        // process textarea attributes\n        $attrs = array();\n        foreach ($config as $k => $v) {\n            switch ($k) {\n                case 'rows':\n                case 'cols':\n                case 'length':\n                case 'maxlength':\n                    if ($v && is_numeric($v))\n                        $attrs[$k] = '\"'.$v.'\"';;\n                    break;\n                case 'context':\n                    $attrs['data-root-context'] =  '\"'.$v.'\"';\n                    break;\n                case 'class':\n                    // This might conflict with html attr below\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'html':\n                    if ($v) {\n                        $class = array('richtext', 'no-bar');\n                        $class[] = @$config['size'] ?: 'small';\n                        $attrs['class'] =  '\"'.implode(' ', $class).'\"';\n                        $this->value = Format::viewableImages($this->value);\n                    }\n                    break;\n            }\n        }\n        // placeholder\n        $attrs['placeholder'] = sprintf('\"%s\"',\n                Format::htmlchars($this->field->getLocal('placeholder',\n                $config['placeholder'])));\n        ?>\n        <span style=\"display:inline-block;width:100%\">\n        <textarea <?php echo Format::array_implode('=', ' ',\n                array_filter($attrs)); ?>\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"><?php\n                echo Format::htmlchars($this->value, ($config['html']));\n            ?></textarea>\n        </span>\n        <?php\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim empty spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass PhoneNumberWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $this->value);\n        ?>\n        <input id=\"<?php echo $this->id; ?>\" type=\"tel\" name=\"<?php echo $this->name; ?>\" value=\"<?php\n        echo Format::htmlchars($phone); ?>\"/><?php\n        // Allow display of extension field even if disabled if the phone\n        // number being edited has an extension\n        if ($ext || $config['ext']) { ?> <?php echo __('Ext'); ?>:\n            <input type=\"text\" name=\"<?php\n            echo $this->name; ?>-ext\" value=\"<?php echo Format::htmlchars($ext);\n                ?>\" size=\"5\"/>\n        <?php }\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        $base = parent::getValue();\n        if ($base === null)\n            return $base;\n        $ext = $data[\"{$this->name}-ext\"];\n        // NOTE: 'X' is significant. Don't change it\n        if ($ext) $ext = 'X'.$ext;\n        return $base . $ext;\n    }\n}\n\nclass ChoicesWidget extends Widget {\n    function render($options=array()) {\n        $mode = null;\n        if (isset($options['mode']))\n            $mode = $options['mode'];\n        elseif (isset($this->field->options['render_mode']))\n            $mode = $this->field->options['render_mode'];\n\n        if ($mode == 'view') {\n            $val = (string) $this->field;\n            echo sprintf('<span id=\"field_%s\" %s >%s</span>', $this->id,\n                    $val ? '': 'class=\"faded\"',\n                    $val ?: __('None'));\n            return;\n        }\n\n        $config = $this->field->getConfiguration();\n        if ($mode == 'search') {\n            $config['multiselect'] = true;\n        }\n\n        // Determine the value for the default (the one listed if nothing is\n        // selected)\n        $choices = $this->field->getChoices(true, $options);\n        $prompt = ($config['prompt'])\n            ? $this->field->getLocal('prompt', $config['prompt'])\n            : __('Select'\n            /* Used as a default prompt for a custom drop-down list */);\n\n        $have_def = false;\n        // We don't consider the 'default' when rendering in 'search' mode\n        if (!strcasecmp($mode, 'search')) {\n            $def_val = $prompt;\n        } else {\n            $showdefault = true;\n            if ($mode != 'create')\n                 $showdefault = false;\n            $def_key = $this->field->get('default');\n            if (!$def_key && isset($config['default']))\n                $def_key = $config['default'];\n            if (is_array($def_key))\n                $def_key = key($def_key);\n            $have_def = isset($choices[$def_key]);\n            $def_val = ($have_def && !$showdefault) ? $choices[$def_key] : $prompt;\n        }\n\n        $values = $this->value;\n        if (!is_array($values) && isset($values)) {\n            $values = array($values => $this->field->getChoice($values));\n        }\n\n        if (!is_array($values))\n            $values = $have_def ? array($def_key => $choices[$def_key]) : array();\n\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        ?>\n        <select name=\"<?php echo $this->name; ?>[]\"\n            <?php echo implode(' ', array_filter(array($classes))); ?>\n            id=\"<?php echo $this->id; ?>\"\n            <?php if (isset($config['data']))\n              foreach ($config['data'] as $D=>$V)\n                echo ' data-'.$D.'=\"'.Format::htmlchars($V).'\"';\n            ?>\n            data-placeholder=\"<?php echo Format::htmlchars($prompt); ?>\"\n            <?php if ($config['multiselect'])\n                echo ' multiple=\"multiple\"'; ?>>\n            <?php if ($showdefault || (!$have_def && !$config['multiselect'])) { ?>\n            <option value=\"<?php echo $showdefault ? '' : $def_key; ?>\">&mdash; <?php\n                echo $def_val; ?> &mdash;</option>\n<?php\n        }\n        $this->emitChoices($choices, $values, $have_def, $def_key); ?>\n        </select>\n        <?php\n        if ($config['multiselect']) {\n         ?>\n        <script type=\"text/javascript\">\n        $(function() {\n            $(\"#<?php echo $this->id; ?>\")\n            .select2({'minimumResultsForSearch':10, 'width': '350px'});\n        });\n        </script>\n       <?php\n        }\n    }\n\n    function emitChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        reset($choices);\n        if (is_array(current($choices)) || current($choices) instanceof Traversable)\n            return $this->emitComplexChoices($choices, $values, $have_def, $def_key);\n\n        foreach ($choices as $key => $name) {\n            if (!$have_def && $key === $def_key)\n                continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n        <?php\n        }\n    }\n\n    function emitComplexChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        foreach ($choices as $label => $group) {\n            if (!count($group)) continue;\n            ?>\n            <optgroup label=\"<?php echo $label; ?>\"><?php\n            foreach ($group as $key => $name) {\n                if (!$have_def && $key == $def_key)\n                    continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n<?php       } ?>\n            </optgroup><?php\n        }\n    }\n\n    function getValue() {\n\n        if (!($value = parent::getValue()))\n            return null;\n\n        if ($value && !is_array($value))\n            $value = array($value);\n\n        // Assume multiselect\n        $values = array();\n        $choices = $this->field->getChoices();\n\n        if ($choices && is_array($value)) {\n            // Complex choices\n            if (is_array(current($choices))\n                    || current($choices) instanceof Traversable) {\n                foreach ($choices as $label => $group) {\n                     foreach ($group as $k => $v)\n                        if (in_array($k, $value))\n                            $values[$k] = $v;\n                }\n            } else {\n                foreach($value as $k => $v) {\n                    if (isset($choices[$v]))\n                        $values[$v] = $choices[$v];\n                    elseif (($i=$this->field->lookupChoice($v)))\n                        $values += $i;\n                    elseif (!$k && $v)\n                      return $v;\n                }\n            }\n        }\n\n        return $values;\n    }\n\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.find(\":selected\").val()', $id);\n    }\n\n}\n\n/**\n * A widget for the ChoiceField which will render a list of radio boxes or\n * checkboxes depending on the value of $config['multiple']. Complex choices\n * are also supported and will be rendered as divs.\n */\nclass BoxChoicesWidget extends Widget {\n    function render($options=array()) {\n        $this->emitChoices($this->field->getChoices());\n    }\n\n    function emitChoices($choices) {\n      static $uid = 1;\n\n      if (!isset($this->value))\n          $this->value = $this->field->get('default');\n      $config = $this->field->getConfiguration();\n      $type = $config['multiple'] ? 'checkbox' : 'radio';\n\n      $classes = array('checkbox');\n      if (isset($config['classes']))\n          $classes = array_merge($classes, (array) $config['classes']);\n\n      foreach ($choices as $k => $v) {\n          if (is_array($v)) {\n              $this->renderSectionBreak($k);\n              $this->emitChoices($v);\n              continue;\n          }\n          $id = sprintf(\"%s-%s\", $this->id, $uid++);\n?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\"\n            for=\"<?php echo $id; ?>\">\n        <input id=\"<?php echo $id; ?>\" type=\"<?php echo $type; ?>\"\n            name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value[$k]) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo Format::htmlchars($k); ?>\"/>\n        <?php\n        if ($v) {\n            echo Format::viewableImages($v);\n        } ?>\n        </label>\n<?php   }\n    }\n\n    function renderSectionBreak($label) { ?>\n        <div><?php echo Format::htmlchars($label); ?></div>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return array();\n            return $this->collectValues($data[$this->name], $this->field->getChoices());\n        }\n        return parent::getValue();\n    }\n\n    function collectValues($data, $choices) {\n        $value = array();\n        foreach ($choices as $k => $v) {\n            if (is_array($v))\n                $value = array_merge($value, $this->collectValues($data, $v));\n            elseif (@in_array($k, $data))\n                $value[$k] = $v;\n        }\n        return $value;\n    }\n}\n\n/**\n * An extension to the BoxChoicesWidget which will render complex choices in\n * tabs.\n */\nclass TabbedBoxChoicesWidget extends BoxChoicesWidget {\n    function render($options=array()) {\n        $tabs = array();\n        foreach ($this->field->getChoices() as $label=>$group) {\n            if (is_array($group)) {\n                $tabs[$label] = $group;\n            }\n            else {\n                $this->emitChoices(array($label=>$group));\n            }\n        }\n        if ($tabs) {\n            ?>\n            <div>\n            <ul class=\"alt tabs\">\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $active = $i++ == 0; ?>\n                <li <?php if ($active) echo 'class=\"active\"';\n                  ?>><a href=\"#<?php echo sprintf('%s-%s', $this->name, Format::slugify($label));\n                  ?>\"><?php echo Format::htmlchars($label); ?></a></li>\n<?php       } ?>\n            </ul>\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $first = $i++ == 0; ?>\n                <div class=\"tab_content <?php if (!$first) echo 'hidden'; ?>\" id=\"<?php\n                  echo sprintf('%s-%s', $this->name, Format::slugify($label));?>\">\n<?php           $this->emitChoices($group); ?>\n                </div>\n<?php       } ?>\n            </div>\n<?php   }\n    }\n}\n\n/**\n* TimezoneWidget extends ChoicesWidget to add auto-detect and select2 search\n* options\n*\n**/\nclass TimezoneWidget extends ChoicesWidget {\n\n    function render($options=array()) {\n        parent::render($options);\n        $config = $this->field->getConfiguration();\n        if (@$config['autodetect']) {\n        ?>\n        <button type=\"button\" class=\"action-button\" onclick=\"javascript:\n            $('head').append($('<script>').attr('src', '<?php\n            echo ROOT_PATH; ?>js/jstz.min.js'));\n            var recheck = setInterval(function() {\n                if (window.jstz !== undefined) {\n                    clearInterval(recheck);\n                    var zone = jstz.determine();\n                    $('#<?php echo $this->id; ?>').val(zone.name()).trigger('change');\n\n                }\n            }, 100);\n            return false;\"\n            style=\"vertical-align:middle\">\n            <i class=\"icon-map-marker\"></i> <?php echo __('Auto Detect'); ?>\n        </button>\n        <?php\n        } ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('#<?php echo $this->id; ?>').select2({\n                    allowClear: true,\n                    width: '300px'\n                });\n            });\n        </script>\n      <?php\n    }\n}\n\nclass CheckboxWidget extends Widget {\n    function __construct($field) {\n        parent::__construct($field);\n        $this->name = '_field-checkboxes';\n    }\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value))\n            $this->value = $this->field->get('default');\n        $classes = array('checkbox');\n        if (isset($config['classes']))\n            $classes = array_merge($classes, (array) $config['classes']);\n        ?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\">\n        <input id=\"<?php echo $this->id; ?>\"\n            type=\"checkbox\" name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo $this->field->get('id'); ?>\"/>\n        <?php\n        if ($config['desc']) {\n            echo Format::viewableImages($config['desc']);\n        } ?>\n        </label>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (is_array($data)) {\n            if (isset($data[$this->name]))\n                return @in_array($this->field->get('id'),\n                        $data[$this->name]);\n            // initial value set on source\n            if (isset($data[$this->field->get('id')]))\n                return $data[$this->field->get('id')];\n        }\n\n        if (!$data && isset($this->value))\n            return $this->value;\n\n\n        return parent::getValue();\n    }\n\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.is(\":checked\")', $id);\n    }\n\n}\n\nclass DatetimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        global $cfg;\n\n        $config = $this->field->getConfiguration();\n        $timezone = $this->field->getTimezone();\n        $dateFormat = $cfg->getDateFormat(true);\n        $timeFormat = $cfg->getTimeFormat(true);\n        if (!isset($this->value) && ($default=$this->field->get('default')))\n            $this->value = $default;\n\n        if ($this->value == 0)\n            $this->value = '';\n\n        if ($this->value) {\n            $datetime = Format::parseDateTime($this->value);\n            if ($config['time'])\n                // Convert to user's timezone for update.\n                $datetime->setTimezone($timezone);\n\n            // Get formatted date\n            $this->value = Format::date($datetime->getTimestamp(), false,\n                        false, $timezone ? $timezone->getName() : 'UTC');\n            // Get formatted time\n            if ($config['time']) {\n                 $this->value .=' '.Format::time($datetime->getTimestamp(),\n                         false, $timeFormat, $timezone ?\n                         $timezone->getName() : 'UTC');\n            }\n\n        } else {\n            // For timezone display purposes\n            $datetime = new DateTime('now');\n            $datetime->setTimezone($timezone);\n        }\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo $this->value; ?>\"\n            size=\"<?php $config['time'] ? 20 : 12; ?>\"\n            autocomplete=\"off\" class=\"dp\" />\n        <?php\n        // Timezone hint\n        // Show timzone hit by default but allow field to turn it off.\n        $showtimezone = true;\n        if (isset($config['showtimezone']))\n            $showtimezone = $config['showtimezone'];\n\n        if ($datetime && $showtimezone) {\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n        ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').<?php echo\n                $config['time'] ? 'datetimepicker':'datepicker';?>({\n                    <?php\n                    if ($dt=$this->field->getMinDateTime())\n                        echo sprintf(\"minDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    if ($dt=$this->field->getMaxDateTime())\n                        echo sprintf(\"maxDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    elseif (!$config['future'])\n                        echo \"maxDate: new Date().getTime(),\\n\";\n\n                    // Set time options\n                    if ($config['time']) {\n                        // Set Timezone\n                        echo sprintf(\"timezone: %s,\\n\",\n                                ($datetime->getOffset()/60));\n                        echo sprintf(\"\n                                controlType: 'select',\\n\n                                timeInput: true,\\n\n                                timeFormat: \\\"%s\\\",\\n\",\n                                Format::dtfmt_php2js($timeFormat));\n                    }\n                    ?>\n                    numberOfMonths: 2,\n                    showButtonPanel: true,\n                    buttonImage: './images/cal.png',\n                    showOn:'both',\n                    dateFormat: '<?php echo\n                        Format::dtfmt_php2js($dateFormat); ?>'\n                });\n            });\n        </script>\n        <?php\n    }\n\n    /**\n     * Function: getValue\n     * Combines the datepicker date value and the time dropdown selected\n     * time value into a single date and time string value in DateTime::W3C\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            if (($dt = Format::parseDateTime($value))) {\n                // Effective timezone for the selection\n                if (($timezone = $this->field->getTimezone()))\n                    $dt->setTimezone($timezone);\n                // Format date time to universal format\n                $value = $dt->format('Y-m-d H:i:s T');\n            }\n        }\n\n        return $value;\n    }\n}\n\nclass TimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value) && ($default=$this->field->get('default')))\n            $this->value = $default;\n\n        // For timezone display purposes only - for now\n        $datetime = new DateTime('now');\n        // Selection timezone\n        $datetime->setTimezone($this->field->getTimeZone());\n\n        if ($this->value) {\n            // TODO: Reformat time here to match settings\n        }\n\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo $this->value; ?>\"\n            size=\"10\"\n            autocomplete=\"off\"  />\n        <?php\n        // Timezone hint\n        // Show timzone hit by default but allow field to turn it off.\n        $showtimezone = true;\n        if (isset($config['showtimezone']))\n            $showtimezone = $config['showtimezone'];\n\n        if ($showtimezone) {\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n        ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').timepicker({\n                    <?php\n                    // Set time options\n                    echo sprintf(\"\n                            controlType: 'select',\\n\n                            timeInput: true,\\n\n                            timeFormat: \\\"%s\\\",\\n\",\n                            \"hh:mm tt\");\n                    echo sprintf(\"timezone: %s\\n\",\n                            ($datetime->getOffset()/60));\n                    ?>\n                });\n            });\n        </script>\n        <?php\n    }\n\n    /**\n     * Function: getValue\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            // TODO: Return ISO format.\n        }\n\n        return $value;\n    }\n}\nclass SectionBreakWidget extends Widget {\n    function render($options=array()) {\n        ?><div class=\"form-header section-break\"><h3><?php\n        echo Format::htmlchars($this->field->getLocal('label'));\n        ?></h3><em><?php echo Format::display($this->field->getLocal('hint'));\n        ?></em></div>\n        <?php\n    }\n}\n\nclass ThreadEntryWidget extends Widget {\n    function render($options=array()) {\n\n        $config = $this->field->getConfiguration();\n        $object_id = false;\n        if ($options['client']) {\n            $namespace = $options['draft-namespace']\n                ?: 'ticket.client';\n             $object_id = substr(session_id(), -12);\n        } else {\n            $namespace = $options['draft-namespace'] ?: 'ticket.staff';\n        }\n\n        list($draft, $attrs) = Draft::getDraftAndDataAttrs($namespace, $object_id, $this->value);\n        ?>\n        <textarea style=\"width:100%;\" name=\"<?php echo $this->name; ?>\"\n            placeholder=\"<?php echo Format::htmlchars($this->field->get('placeholder')); ?>\"\n            class=\"<?php if ($config['html']) echo 'richtext';\n                ?> draft draft-delete\" <?php echo $attrs; ?>\n            cols=\"21\" rows=\"8\" style=\"width:80%;\"><?php echo\n            ThreadEntryBody::clean($this->value ?: $draft); ?></textarea>\n    <?php\n        if (!$config['attachments'])\n            return;\n\n        $attachments = $this->getAttachments($config);\n        print $attachments->render($options);\n        foreach ($attachments->getMedia() as $type=>$urls) {\n            foreach ($urls as $url)\n                Form::emitMedia($url, $type);\n        }\n    }\n\n    function getAttachments($config=false) {\n        if (!$config)\n            $config = $this->field->getConfiguration();\n\n        $field = new FileUploadField(array(\n            'id'=>'attach',\n            'name'=>'attach:' . $this->field->get('id'),\n            'configuration'=>$config)\n        );\n        $field->setForm($this->field->getForm());\n        return $field;\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass FileUploadWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            '/css/filedrop.css',\n        ),\n    );\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $name = $this->field->getFormName();\n        $id = substr(md5(spl_object_hash($this)), 10);\n        $mimetypes = array_filter($config['__mimetypes'],\n            function($t) { return strpos($t, '/') !== false; }\n        );\n        $maxfilesize = ($config['size'] ?: 1048576) / 1048576;\n        $files = array();\n        $new = $this->field->getClean(false);\n\n        foreach ($this->field->getAttachments() as $att) {\n            unset($new[$att->file_id]);\n            $files[] = array(\n                'id' => $att->file->getId(),\n                'name' => $att->getFilename(),\n                'type' => $att->file->getType(),\n                'size' => $att->file->getSize(),\n                'download_url' => $att->file->getDownloadUrl(),\n            );\n        }\n\n        // Add in newly added files not yet saved (if redisplaying after an\n        // error)\n        if ($new) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($new)))\n                ->all();\n\n            foreach ($F as $f) {\n                $f->tmp_name = $new[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n        //see if the attachment is saved in the session for this specific field\n        if ($sessionAttachment = $_SESSION[':form-data'][$this->field->get('name')]) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($sessionAttachment)))\n                ->all();\n\n            foreach ($F as $f) {\n                $f->tmp_name = $sessionAttachment[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n         // Set default $field_id\n        $field_id = $this->field->get('id');\n        // Get Form Type\n        $type = $this->field->getForm()->type;\n        // Determine if for Ticket/Task/Custom\n        if ($type) {\n            if ($type == 'T')\n                $field_id = 'ticket/attach';\n            elseif ($type == 'A')\n                $field_id = 'task/attach';\n        }\n\n        ?><div id=\"<?php echo $id;\n            ?>\" class=\"filedrop\"><div class=\"files\"></div>\n            <div class=\"dropzone\"><i class=\"icon-upload\"></i>\n            <?php echo sprintf(\n                __('Drop files here or %s choose them %s'),\n                '<a href=\"#\" class=\"manual\">', '</a>'); ?>\n        <input type=\"file\" multiple=\"multiple\"\n            id=\"file-<?php echo $id; ?>\" style=\"display:none;\"\n            accept=\"<?php echo implode(',', $config['__mimetypes']); ?>\"/>\n        </div></div>\n        <script type=\"text/javascript\">\n        $(function(){$('#<?php echo $id; ?> .dropzone').filedropbox({\n          url: 'ajax.php/form/upload/<?php echo $field_id; ?>',\n          link: $('#<?php echo $id; ?>').find('a.manual'),\n          paramname: 'upload[]',\n          fallback_id: 'file-<?php echo $id; ?>',\n          allowedfileextensions: <?php echo JsonDataEncoder::encode(\n            $config['__extensions'] ?: array()); ?>,\n          allowedfiletypes: <?php echo JsonDataEncoder::encode(\n            $mimetypes); ?>,\n          maxfiles: <?php echo $config['max'] ?: 20; ?>,\n          maxfilesize: <?php echo str_replace(',', '.', $maxfilesize); ?>,\n          name: '<?php echo $name; ?>[]',\n          files: <?php echo JsonDataEncoder::encode($files); ?>\n        });});\n        </script>\n<?php\n    }\n\n    function getValue() {\n        $ids = array();\n        // Handle manual uploads (IE<10)\n        if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES[$this->name])) {\n            foreach (AttachmentFile::format($_FILES[$this->name]) as $file) {\n                try {\n                    $F = $this->field->uploadFile($file);\n                    $ids[$F->getId()] = $F->getName();\n                }\n                catch (FileUploadError $ex) {}\n            }\n            return $ids;\n        }\n\n        // Files uploaded here MUST have been uploaded by this user and\n        // identified in the session\n        //\n        // If no value was sent, assume an empty list\n        if (!($files = parent::getValue()))\n            return array();\n\n        if ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            $_files = array();\n            foreach ($files as $info) {\n                if (@list($id, $name) = explode(',', $info, 2))\n                    $_files[$id] = $name;\n            }\n            $files = $_files;\n        }\n\n        $allowed = array();\n        // Files already attached to the field are allowed\n        foreach ($this->field->getFiles() as $F) {\n            // FIXME: This will need special porting in v1.10\n            $allowed[$F->id] = $F->getName();\n        }\n\n        // New files uploaded in this session are allowed\n        if (isset($_SESSION[':uploadedFiles']))\n            $allowed += $_SESSION[':uploadedFiles'];\n\n        // Canned attachments initiated by this session\n        if (isset($_SESSION[':cannedFiles']))\n           $allowed += $_SESSION[':cannedFiles'];\n\n        // Parse the files and make sure it's allowed.\n        foreach ($files as $id => $name) {\n            if (!isset($allowed[$id]))\n                continue;\n\n            // Keep the values as the IDs\n            $ids[$id] = $name ?: $allowed[$id];\n        }\n\n        return $ids;\n    }\n}\n\nclass FileUploadError extends Exception {}\n\nclass FreeTextField extends FormField {\n    static $widget = 'FreeTextWidget';\n    protected $attachments;\n\n    function getConfigurationOptions() {\n        return array(\n            'content' => new TextareaField(array(\n                'configuration' => array('html' => true, 'size'=>'large'),\n                'label'=>__('Content'), 'required'=>true, 'default'=>'',\n                'hint'=>__('Free text shown in the form, such as a disclaimer'),\n            )),\n            'attachments' => new FileUploadField(array(\n                'id'=>'attach',\n                'label' => __('Attachments'),\n                'name'=>'files',\n                'configuration' => array('extensions'=>'')\n            )),\n        );\n    }\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    function isEditableToStaff() {\n        return $this->isVisibleToStaff();\n    }\n\n    function isEditableToUsers() {\n        return $this->isVisibleToUsers();\n    }\n\n    /* utils */\n\n    function to_config($config) {\n        if ($config && isset($config['attachments']))\n            $keepers = $config['attachments'];\n        $this->getAttachments()->keepOnlyFileIds($keepers);\n\n        return $config;\n    }\n\n    function db_cleanup($field=false) {\n\n        if ($field && $this->getFiles())\n            $this->getAttachments()->deleteAll();\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments))\n            $this->attachments = GenericAttachments::forIdAndType($this->get('id'), 'I');\n\n        return $this->attachments ?: array();\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            if (($attachments=$this->getAttachments()))\n                foreach ($attachments->all() as $a)\n                    $files[] = $a->getFile();\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n}\n\nclass FreeTextWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $config['classes'] ?: 'thread-body bleed';\n        ?><div class=\"<?php echo $class; ?>\"><?php\n        if ($label = $this->field->getLocal('label')) { ?>\n            <h3><?php\n            echo Format::htmlchars($label);\n        ?></h3><?php\n        }\n        if ($hint = $this->field->getLocal('hint')) { ?>\n        <em><?php\n            echo Format::display($hint);\n        ?></em><?php\n        } ?>\n        <div><?php\n            echo Format::viewableImages($config['content']); ?></div>\n        </div>\n        <?php\n        if (($attachments = $this->field->getAttachments()) && count($attachments)) { ?>\n            <section class=\"freetext-files\">\n            <div class=\"title\"><?php echo __('Related Resources'); ?></div>\n            <?php foreach ($attachments->all() as $attach) {\n                $filename = Format::htmlchars($attach->getFilename());\n                ?>\n                <div class=\"file\">\n                <a href=\"<?php echo $attach->file->getDownloadUrl(); ?>\"\n                    target=\"_blank\" download=\"<?php echo $filename; ?>\"\n                    class=\"truncate no-pjax\">\n                    <i class=\"icon-file\"></i>\n                    <?php echo $filename; ?>\n                </a>\n                </div>\n            <?php } ?>\n        </section>\n        <?php }\n    }\n}\n\nclass ColorPickerWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            'css/spectrum.css',\n        ),\n        'js' => array(\n            'js/spectrum.js',\n        ),\n    );\n\n    function render($options=array()) {\n        ?><input type=\"color\"\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value); ?>\"/><?php\n    }\n}\n\nclass VisibilityConstraint {\n    static $operators = array(\n        'eq' => 1,\n        'neq' => 1,\n    );\n\n    const HIDDEN =      0x0001;\n    const VISIBLE =     0x0002;\n\n    var $initial;\n    var $constraint;\n\n    function __construct($constraint, $initial=self::VISIBLE) {\n        $this->constraint = $constraint;\n        $this->initial = $initial;\n    }\n\n    function emitJavascript($field) {\n\n        if (!$this->constraint->constraints)\n            return;\n\n        $func = 'recheck_'.$field->getWidget()->id;\n        $form = $field->getForm();\n?>\n    <script type=\"text/javascript\">\n      !(function() {\n        var <?php echo $func; ?> = function() {\n          var target = $('#field<?php echo $field->getWidget()->id; ?>');\n<?php   $fields = $this->getAllFields($this->constraint);\n        foreach ($fields as $f) {\n            if (!($field = $form->getField($f)))\n                continue;\n            echo sprintf('var %1$s = x = $(\"#%1$s\");',\n                $field->getWidget()->id);\n        }\n        $expression = $this->compileQ($this->constraint, $form);\n?>\n          if (<?php echo $expression; ?>) {\n            target.slideDown('fast', function (){\n                $(this).trigger('show');\n                });\n          } else {\n            target.slideUp('fast', function (){\n                $(this).trigger('hide');\n                });\n          }\n        };\n\n<?php   foreach ($fields as $f) {\n            if (!($field=$form->getField($f)))\n                continue;\n            $w = $field->getWidget();\n?>\n        $('#<?php echo $w->id; ?>').on('change', <?php echo $func; ?>);\n        $('#field<?php echo $w->id; ?>').on('show hide', <?php\n                echo $func; ?>);\n<?php   } ?>\n      })();\n    </script><?php\n    }\n\n    /**\n     * Determines if the field was visible when the form was submitted\n     */\n    function isVisible($field) {\n\n        // Assume initial visibility if constraint is not provided.\n        if (!$this->constraint->constraints)\n            return $this->initial == self::VISIBLE;\n\n\n        return $this->compileQPhp($this->constraint, $field);\n    }\n\n    static function splitFieldAndOp($field) {\n        if (false !== ($last = strrpos($field, '__'))) {\n            $op = substr($field, $last + 2);\n            if (isset(static::$operators[$op]))\n                $field = substr($field, 0, strrpos($field, '__'));\n        }\n        return array($field, $op);\n    }\n\n    function compileQPhp(Q $Q, $field) {\n        if (!($form = $field->getForm())) {\n            return $this->initial == self::VISIBLE;\n        }\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQPhp($value, $field);\n            }\n            else {\n                @list($f, $op) = self::splitFieldAndOp($c);\n                $field = $form->getField($f);\n                $wval = $field ? $field->getClean() : null;\n                $values = explode('|', $value);\n                switch ($op) {\n                case 'neq':\n                    $expr[] = ($wval && !in_array($wval, $values) && $field->isVisible());\n                    break;\n                case 'eq':\n                case null:\n                    $expr[] = (in_array($wval, $values) && $field->isVisible());\n                }\n            }\n        }\n        $glue = $Q->isOred()\n            ? function($a, $b) { return $a || $b; }\n            : function($a, $b) { return $a && $b; };\n        $initial = !$Q->isOred();\n        $expression = array_reduce($expr, $glue, $initial);\n        if ($Q->isNegated)\n            $expression = !$expression;\n        return $expression;\n    }\n\n    function getAllFields(Q $Q, &$fields=array()) {\n        foreach ($Q->constraints as $c=>$value) {\n            if ($c instanceof Q) {\n                $this->getAllFields($c, $fields);\n            }\n            else {\n                @list($f) = self::splitFieldAndOp($c);\n                $fields[$f] = true;\n            }\n        }\n        return array_keys($fields);\n    }\n\n    function compileQ($Q, $form) {\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQ($value, $form);\n            }\n            else {\n                list($f, $op) = self::splitFieldAndOp($c);\n                if (!($field=$form->getField($f))) continue;\n                $widget = $field->getWidget();\n                $id = $widget->id;\n                switch ($op) {\n                case 'neq':\n                    $expr[] = sprintf('(%s.is(\":visible\") && !(%s))',\n                            $id, $widget->getJsComparator($value, $id));\n                    break;\n                case 'eq':\n                case null:\n                    $expr[] = sprintf('(%s.is(\":visible\") && (%s))',\n                            $id, $widget->getJsComparator($value, $id));\n                }\n            }\n        }\n        $glue = $Q->isOred() ? ' || ' : ' && ';\n        $expression = implode($glue, $expr);\n        if (count($expr) > 1)\n            $expression = '('.$expression.')';\n        if ($Q->isNegated)\n            $expression = '!'.$expression;\n        return $expression;\n    }\n}\n\nclass AssignmentForm extends Form {\n\n    static $id = 'assign';\n    var $_assignee = null;\n    var $_assignees = null;\n\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'assignee' => new AssigneeField(array(\n                    'id'=>1, 'label' => __('Assignee'),\n                    'flags' => hexdec(0X450F3), 'required' => true,\n                    'validator-error' => __('Assignee selection required'),\n                    'configuration' => array(\n                        'criteria' => array(\n                            'available' => true,\n                            ),\n                       ),\n                    )\n                ),\n            'refer' => new BooleanField(array(\n                    'id'=>2, 'label'=>'', 'required'=>false,\n                    'default'=>false,\n                    'configuration'=>array(\n                        'desc' => __('Maintain referral access to current assignees'))\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 3, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        if (isset($this->_assignees))\n            $fields['assignee']->setChoices($this->_assignees);\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('assignee')))\n            return false;\n\n        // Do additional assignment validation\n        if (!($assignee = $this->getAssignee())) {\n            $f->addError(__('Unknown assignee'));\n        } elseif ($assignee instanceof Staff) {\n            // Make sure the agent is available\n            if (!$assignee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        } elseif ($assignee instanceof Team) {\n            // Make sure the team is active and has members\n            if (!$assignee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$assignee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setAssignees($assignees) {\n        $this->_assignees = $assignees;\n        $this->_fields = array();\n    }\n\n    function getAssignees() {\n        return $this->_assignees;\n    }\n\n    function getAssignee() {\n\n        if (!isset($this->_assignee))\n            $this->_assignee = $this->getField('assignee')->getClean();\n\n        return $this->_assignee;\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n\n    function refer() {\n        return $this->getField('refer')->getClean();\n    }\n}\n\nclass ClaimForm extends AssignmentForm {\n\n    var $_fields;\n\n    function setFields($fields) {\n        $this->_fields = $fields;\n        parent::setFields($fields);\n    }\n\n    function getFields() {\n\n        if ($this->_fields)\n            return $this->_fields;\n\n        $fields = parent::getFields();\n\n        // Disable && hide assignee field selection\n        if (isset($fields['assignee'])) {\n            $visibility = new VisibilityConstraint(\n                    new Q(array()), VisibilityConstraint::HIDDEN);\n\n            $fields['assignee']->set('visibility', $visibility);\n        }\n\n        // Change coments placeholder to reflect claim\n        if (isset($fields['comments'])) {\n            $fields['comments']->configure('placeholder',\n                    __('Optional reason for the claim'));\n        }\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n}\n\nclass ReleaseForm extends Form {\n    static $id = 'unassign';\n\n    function getFields() {\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'comments' => new TextareaField(array(\n                    'id' => 1, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for releasing assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n        if (!parent::isValid($include))\n            return false;\n\n        return !$this->errors();\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass MarkAsForm extends Form {\n    static $id = 'markAs';\n\n    function getFields() {\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'comments' => new TextareaField(array(\n                    'id' => 1, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for marking ticket as (un)answered'),\n                        ),\n                    )\n                ),\n            );\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n        if (!parent::isValid($include))\n            return false;\n\n        return !$this->errors();\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass ReferralForm extends Form {\n\n    static $id = 'refer';\n    var $_target = null;\n    var $_choices = null;\n    var $_prompt = '';\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'target' => new ChoiceField(array(\n                    'id'=>1,\n                    'label' => __('Referee'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Selection required'),\n                    'choices' => array(\n                    'agent' => __('Agent'),\n                    'team'  => __('Team'),\n                                'dept'  => __('Department'),\n                               ),\n                            )\n                ),\n            'agent' => new AgentSelectionField(array(\n                    'id'=>2,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Agent selection required'),\n                    'configuration'=>array('prompt'=>__('Select Agent')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'agent')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'team' => new ChoiceField(array(\n                    'id'=>3,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Team selection required'),\n                    'configuration'=>array('prompt'=>__('Select Team')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'team')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'dept' => new DepartmentField(array(\n                    'id'=>4,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Dept. selection required'),\n                    'configuration'=>array('prompt'=>__('Select Department')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'dept')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 5,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the referral'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('target')))\n            return false;\n\n        // Do additional assignment validation\n        $referee = $this->getReferee();\n        switch (true) {\n        case $referee instanceof Staff:\n            // Make sure the agent is available\n            if (!$referee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        break;\n        case $referee instanceof Team:\n            // Make sure the team is active and has members\n            if (!$referee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$referee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        break;\n        case $referee instanceof Dept:\n        break;\n        default:\n            $f->addError(__('Unknown selection'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setChoices($field, $choices, $prompt='') {\n\n        if (!($f= $this->getField($field)))\n           return;\n\n        $f->set('choices', $choices);\n\n        return $f;\n    }\n\n    function getReferee() {\n\n        $target = $this->getField('target')->getClean();\n        if (!$target || !($f=$this->getField($target)))\n            return null;\n\n        $id = $f->getClean();\n        switch($target) {\n        case 'agent':\n            return Staff::lookup($id);\n        case 'team':\n            return Team::lookup($id);\n        case 'dept':\n            return Dept::lookup($id);\n        }\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\n\nclass TransferForm extends Form {\n\n    static $id = 'transfer';\n    var $_dept = null;\n\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n    }\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'dept' => new DepartmentField(array(\n                    'id'=>1,\n                    'label' => __('Department'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Department selection is required'),\n                    )\n                ),\n            'refer' => new BooleanField(array(\n                'id'=>2, 'label'=>'', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc' => 'Maintain referral access to current department')\n            )),\n            'comments' => new TextareaField(array(\n                    'id' => 3,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the transfer'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include))\n            return false;\n\n        // Do additional validations\n        if (!($dept = $this->getDept()))\n            $this->getField('dept')->addError(\n                    __('Unknown department'));\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        get_class(), $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n\n    }\n\n    function refer() {\n        return $this->getField('refer')->getClean();\n    }\n\n    function getDept() {\n\n        if (!isset($this->_dept)) {\n            if (($id = $this->getField('dept')->getClean()))\n                $this->_dept = Dept::lookup($id);\n        }\n\n        return $this->_dept;\n    }\n\n    function hideDisabled() {\n        global $thisstaff;\n\n        if ($f = $this->getField('dept')) {\n            $f->configure('staff', $thisstaff);\n            $f->configure('hideDisabled', true);\n        }\n    }\n}\n\n/**\n * FieldUnchanged\n *\n * Thrown in the to_database() method to indicate the value should not be\n * saved in the database (it wasn't changed in the request)\n */\nclass FieldUnchanged extends Exception {}\n?>\n"], "fixing_code": ["<?php\n\nclass Bootstrap {\n\n    static function init() {\n        #Disable Globals if enabled....before loading config info\n        if(ini_get('register_globals')) {\n           ini_set('register_globals',0);\n           foreach($_REQUEST as $key=>$val)\n               if(isset($$key))\n                   unset($$key);\n        }\n\n        #Disable url fopen && url include\n        ini_set('allow_url_fopen', 0);\n        ini_set('allow_url_include', 0);\n\n        #Disable session ids on url.\n        ini_set('session.use_trans_sid', 0);\n        #No cache\n        session_cache_limiter('nocache');\n\n        #Error reporting...Good idea to ENABLE error reporting to a file. i.e display_errors should be set to false\n        $error_reporting = E_ALL & ~E_NOTICE & ~E_WARNING;\n        if (defined('E_STRICT')) # 5.4.0\n            $error_reporting &= ~E_STRICT;\n        if (defined('E_DEPRECATED')) # 5.3.0\n            $error_reporting &= ~(E_DEPRECATED | E_USER_DEPRECATED);\n        error_reporting($error_reporting); //Respect whatever is set in php.ini (sysadmin knows better??)\n\n        #Don't display errors\n        ini_set('display_errors', 1);\n        ini_set('display_startup_errors', 1);\n\n        //Default timezone\n        if (!ini_get('date.timezone')) {\n            if(function_exists('date_default_timezone_set')) {\n                if(@date_default_timezone_get()) //Let PHP determine the timezone.\n                    @date_default_timezone_set(@date_default_timezone_get());\n                else //Default to EST - if PHP can't figure it out.\n                    date_default_timezone_set('America/New_York');\n            } else { //Default when all fails. PHP < 5.\n                ini_set('date.timezone', 'America/New_York');\n            }\n        }\n        date_default_timezone_set('UTC');\n\n        if (!function_exists('exif_imagetype')) {\n            function exif_imagetype ($filename) {\n                if ((list($width,$height,$type,) = getimagesize($filename)) !== false)\n                    return $type;\n\n                return false;\n            }\n        }\n\n        if (!function_exists('exif_imagetype')) {\n            function exif_imagetype ($filename) {\n                if ((list($width,$height,$type,) = getimagesize($filename)) !== false)\n                    return $type;\n\n                return false;\n            }\n        }\n\n        if (!isset($_SERVER['REMOTE_ADDR']))\n            $_SERVER['REMOTE_ADDR'] = '';\n    }\n\n    static function https() {\n       return osTicket::is_https();\n    }\n\n    static function defineTables($prefix) {\n        #Tables being used sytem wide\n        define('SYSLOG_TABLE',$prefix.'syslog');\n        define('SESSION_TABLE',$prefix.'session');\n        define('CONFIG_TABLE',$prefix.'config');\n\n        define('CANNED_TABLE',$prefix.'canned_response');\n        define('PAGE_TABLE', $prefix.'content');\n        define('FILE_TABLE',$prefix.'file');\n        define('FILE_CHUNK_TABLE',$prefix.'file_chunk');\n\n        define('ATTACHMENT_TABLE',$prefix.'attachment');\n\n        define('USER_TABLE',$prefix.'user');\n        define('USER_CDATA_TABLE', $prefix.'user__cdata');\n        define('USER_EMAIL_TABLE',$prefix.'user_email');\n        define('USER_ACCOUNT_TABLE',$prefix.'user_account');\n\n        define('ORGANIZATION_TABLE', $prefix.'organization');\n        define('ORGANIZATION_CDATA_TABLE', $prefix.'organization__cdata');\n\n        define('NOTE_TABLE', $prefix.'note');\n\n        define('STAFF_TABLE',$prefix.'staff');\n        define('TEAM_TABLE',$prefix.'team');\n        define('TEAM_MEMBER_TABLE',$prefix.'team_member');\n        define('DEPT_TABLE',$prefix.'department');\n        define('STAFF_DEPT_TABLE', $prefix.'staff_dept_access');\n        define('ROLE_TABLE', $prefix.'role');\n\n        define('FAQ_TABLE',$prefix.'faq');\n        define('FAQ_TOPIC_TABLE',$prefix.'faq_topic');\n        define('FAQ_CATEGORY_TABLE',$prefix.'faq_category');\n\n        define('DRAFT_TABLE',$prefix.'draft');\n\n        define('THREAD_TABLE', $prefix.'thread');\n        define('THREAD_ENTRY_TABLE', $prefix.'thread_entry');\n        define('THREAD_ENTRY_EMAIL_TABLE', $prefix.'thread_entry_email');\n        define('THREAD_ENTRY_MERGE_TABLE', $prefix.'thread_entry_merge');\n\n        define('LOCK_TABLE',$prefix.'lock');\n\n        define('TICKET_TABLE',$prefix.'ticket');\n        define('TICKET_CDATA_TABLE', $prefix.'ticket__cdata');\n        define('THREAD_EVENT_TABLE',$prefix.'thread_event');\n        define('THREAD_REFERRAL_TABLE',$prefix.'thread_referral');\n        define('THREAD_COLLABORATOR_TABLE', $prefix.'thread_collaborator');\n        define('TICKET_STATUS_TABLE', $prefix.'ticket_status');\n        define('TICKET_PRIORITY_TABLE',$prefix.'ticket_priority');\n        define('EVENT_TABLE',$prefix.'event');\n\n        define('TASK_TABLE', $prefix.'task');\n        define('TASK_CDATA_TABLE', $prefix.'task__cdata');\n\n        define('PRIORITY_TABLE',TICKET_PRIORITY_TABLE);\n\n\n        define('FORM_SEC_TABLE',$prefix.'form');\n        define('FORM_FIELD_TABLE',$prefix.'form_field');\n\n        define('LIST_TABLE',$prefix.'list');\n        define('LIST_ITEM_TABLE',$prefix.'list_items');\n\n        define('FORM_ENTRY_TABLE',$prefix.'form_entry');\n        define('FORM_ANSWER_TABLE',$prefix.'form_entry_values');\n\n        define('TOPIC_TABLE',$prefix.'help_topic');\n        define('TOPIC_FORM_TABLE',$prefix.'help_topic_form');\n        define('SLA_TABLE', $prefix.'sla');\n\n        define('EMAIL_TABLE',$prefix.'email');\n        define('EMAIL_TEMPLATE_GRP_TABLE',$prefix.'email_template_group');\n        define('EMAIL_TEMPLATE_TABLE',$prefix.'email_template');\n\n        define('FILTER_TABLE', $prefix.'filter');\n        define('FILTER_RULE_TABLE', $prefix.'filter_rule');\n        define('FILTER_ACTION_TABLE', $prefix.'filter_action');\n\n        define('PLUGIN_TABLE', $prefix.'plugin');\n        define('SEQUENCE_TABLE', $prefix.'sequence');\n        define('TRANSLATION_TABLE', $prefix.'translation');\n        define('QUEUE_TABLE', $prefix.'queue');\n        define('COLUMN_TABLE', $prefix.'queue_column');\n        define('QUEUE_COLUMN_TABLE', $prefix.'queue_columns');\n        define('QUEUE_SORT_TABLE', $prefix.'queue_sort');\n        define('QUEUE_SORTING_TABLE', $prefix.'queue_sorts');\n        define('QUEUE_EXPORT_TABLE', $prefix.'queue_export');\n        define('QUEUE_CONFIG_TABLE', $prefix.'queue_config');\n\n        define('SCHEDULE_TABLE', $prefix.'schedule');\n        define('SCHEDULE_ENTRY_TABLE', $prefix.'schedule_entry');\n\n        define('API_KEY_TABLE',$prefix.'api_key');\n        define('TIMEZONE_TABLE',$prefix.'timezone');\n    }\n\n    static function loadConfig() {\n        #load config info\n        $configfile='';\n        if(file_exists(INCLUDE_DIR.'ost-config.php')) //NEW config file v 1.6 stable ++\n            $configfile=INCLUDE_DIR.'ost-config.php';\n        elseif(file_exists(ROOT_DIR.'ostconfig.php')) //Old installs prior to v 1.6 RC5\n            $configfile=ROOT_DIR.'ostconfig.php';\n        elseif(file_exists(INCLUDE_DIR.'settings.php')) { //OLD config file.. v 1.6 RC5\n            $configfile=INCLUDE_DIR.'settings.php';\n            //Die gracefully on upgraded v1.6 RC5 installation - otherwise script dies with confusing message.\n            if(!strcasecmp(basename($_SERVER['SCRIPT_NAME']), 'settings.php'))\n                Http::response(500,\n                    'Please rename config file include/settings.php to include/ost-config.php to continue!');\n        } elseif(file_exists(ROOT_DIR.'setup/'))\n            Http::redirect(ROOT_PATH.'setup/');\n\n        if(!$configfile || !file_exists($configfile))\n            Http::response(500,'<b>Error loading settings. Contact admin.</b>');\n\n        require($configfile);\n        define('CONFIG_FILE',$configfile); //used in admin.php to check perm.\n\n        # This is to support old installations. with no secret salt.\n        if (!defined('SECRET_SALT'))\n            define('SECRET_SALT',md5(TABLE_PREFIX.ADMIN_EMAIL));\n        #Session related\n        define('SESSION_SECRET', MD5(SECRET_SALT)); //Not that useful anymore...\n        define('SESSION_TTL', 86400); // Default 24 hours\n    }\n\n    static function connect() {\n        #Connect to the DB && get configuration from database\n        $ferror=null;\n        $options = array();\n        if (defined('DBSSLCA'))\n            $options['ssl'] = array(\n                'ca' => DBSSLCA,\n                'cert' => DBSSLCERT,\n                'key' => DBSSLKEY\n            );\n\n        if (!db_connect(DBHOST, DBUSER, DBPASS, $options)) {\n            $ferror=sprintf('Unable to connect to the database \u2014 %s',db_connect_error());\n        }elseif(!db_select_database(DBNAME)) {\n            $ferror=sprintf('Unknown or invalid database: %s',DBNAME);\n        }\n\n        if($ferror) //Fatal error\n            self::croak($ferror);\n    }\n\n    static function loadCode() {\n        #include required files\n        require_once INCLUDE_DIR.'class.util.php';\n        require_once INCLUDE_DIR.'class.translation.php';\n        require_once(INCLUDE_DIR.'class.signal.php');\n        require(INCLUDE_DIR.'class.model.php');\n        require(INCLUDE_DIR.'class.user.php');\n        require(INCLUDE_DIR.'class.auth.php');\n        require(INCLUDE_DIR.'class.pagenate.php'); //Pagenate helper!\n        require(INCLUDE_DIR.'class.log.php');\n        require(INCLUDE_DIR.'class.crypto.php');\n        require(INCLUDE_DIR.'class.page.php');\n        require_once(INCLUDE_DIR.'class.format.php'); //format helpers\n        require_once(INCLUDE_DIR.'class.validator.php'); //Class to help with basic form input validation...please help improve it.\n        require(INCLUDE_DIR.'class.mailer.php');\n        require_once INCLUDE_DIR.'mysqli.php';\n        require_once INCLUDE_DIR.'class.i18n.php';\n        require_once INCLUDE_DIR.'class.queue.php';\n    }\n\n    static function i18n_prep() {\n        ini_set('default_charset', 'utf-8');\n        ini_set('output_encoding', 'utf-8');\n\n        // MPDF requires mbstring functions\n        if (!extension_loaded('mbstring')) {\n            if (function_exists('iconv')) {\n                function mb_strpos($a, $b) { return iconv_strpos($a, $b); }\n                function mb_strlen($str) { return iconv_strlen($str); }\n                function mb_substr($a, $b, $c=null) {\n                    return iconv_substr($a, $b, $c); }\n                function mb_convert_encoding($str, $to, $from='utf-8') {\n                    return iconv($from, $to, $str); }\n            }\n            else {\n                function mb_strpos($a, $b) {\n                    $c = preg_replace('/^(\\X*)'.preg_quote($b).'.*$/us', '$1', $a);\n                    return ($c===$a) ? false : mb_strlen($c);\n                }\n                function mb_strlen($str) {\n                    $a = array();\n                    return preg_match_all('/\\X/u', $str, $a);\n                }\n                function mb_substr($a, $b, $c=null) {\n                    return preg_replace(\n                        \"/^\\X{{$b}}(\\X\".($c ? \"{{$c}}\" : \"*\").\").*/us\",'$1',$a);\n                }\n                function mb_convert_encoding($str, $to, $from='utf-8') {\n                    if (strcasecmp($to, $from) == 0)\n                        return $str;\n                    elseif (in_array(strtolower($to), array(\n                            'us-ascii','latin-1','iso-8859-1'))\n                            && function_exists('utf8_encode'))\n                        return utf8_encode($str);\n                    else\n                        return $str;\n                }\n            }\n            define('LATIN1_UC_CHARS', '\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd');\n            define('LATIN1_LC_CHARS', '\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd');\n            function mb_strtoupper($str) {\n                if (is_array($str)) $str = $str[0];\n                return strtoupper(strtr($str, LATIN1_LC_CHARS, LATIN1_UC_CHARS));\n            }\n            function mb_strtolower($str) {\n                if (is_array($str)) $str = $str[0];\n                return strtolower(strtr($str, LATIN1_UC_CHARS, LATIN1_LC_CHARS));\n            }\n            define('MB_CASE_LOWER', 1);\n            define('MB_CASE_UPPER', 2);\n            define('MB_CASE_TITLE', 3);\n            function mb_convert_case($str, $mode) {\n                // XXX: Techincally the calls to strto...() will fail if the\n                //      char is not a single-byte char\n                switch ($mode) {\n                case MB_CASE_LOWER:\n                    return preg_replace_callback('/\\p{Lu}+/u', 'mb_strtolower', $str);\n                case MB_CASE_UPPER:\n                    return preg_replace_callback('/\\p{Ll}+/u', 'mb_strtoupper', $str);\n                case MB_CASE_TITLE:\n                    return preg_replace_callback('/\\b\\p{Ll}/u', 'mb_strtoupper', $str);\n                }\n            }\n            function mb_internal_encoding($encoding) { return 'UTF-8'; }\n            function mb_regex_encoding($encoding) { return 'UTF-8'; }\n            function mb_substr_count($haystack, $needle) {\n                $matches = array();\n                return preg_match_all('`'.preg_quote($needle).'`u', $haystack,\n                    $matches);\n            }\n        }\n        else {\n            // Use UTF-8 for all multi-byte string encoding\n            mb_internal_encoding('utf-8');\n        }\n        if (extension_loaded('iconv'))\n            iconv_set_encoding('internal_encoding', 'UTF-8');\n\n        if (intval(phpversion()) < 7) {\n            function random_int($a, $b) {\n                return rand($a, $b);\n            }\n        }\n\n        function mb_str_wc($str) {\n            return count(preg_split('~[^\\p{L}\\p{N}\\'].+~u', trim($str)));\n        }\n    }\n\n    static function croak($message) {\n        $msg = $message.\"\\n\\n\".THISPAGE;\n        Mailer::sendmail(ADMIN_EMAIL, 'osTicket Fatal Error', $msg,\n            sprintf('\"osTicket Alerts\"<%s>', ADMIN_EMAIL));\n        //Display generic error to the user\n        Http::response(500, \"<b>Fatal Error:</b> Contact system administrator.\");\n    }\n}\n\n#Get real path for root dir ---linux and windows\n$here = dirname(__FILE__);\n$here = ($h = realpath($here)) ? $h : $here;\ndefine('ROOT_DIR',str_replace('\\\\', '/', $here.'/'));\nunset($here); unset($h);\n\ndefine('INCLUDE_DIR',ROOT_DIR.'include/'); //Change this if include is moved outside the web path.\ndefine('PEAR_DIR',INCLUDE_DIR.'pear/');\ndefine('SETUP_DIR',ROOT_DIR.'setup/');\n\ndefine('CLIENTINC_DIR',INCLUDE_DIR.'client/');\ndefine('STAFFINC_DIR',INCLUDE_DIR.'staff/');\n\ndefine('UPGRADE_DIR', INCLUDE_DIR.'upgrader/');\ndefine('I18N_DIR', INCLUDE_DIR.'i18n/');\ndefine('CLI_DIR', INCLUDE_DIR.'cli/');\n\n/*############## Do NOT monkey with anything else beyond this point UNLESS you really know what you are doing ##############*/\n\n#Current version && schema signature (Changes from version to version)\ndefine('GIT_VERSION','$git');\ndefine('MAJOR_VERSION', '1.16');\ndefine('THIS_VERSION', MAJOR_VERSION.'-git'); //Shown on admin panel\n//Path separator\nif(!defined('PATH_SEPARATOR')){\n    if(strpos($_ENV['OS'],'Win')!==false || !strcasecmp(substr(PHP_OS, 0, 3),'WIN'))\n        define('PATH_SEPARATOR', ';' ); //Windows\n    else\n        define('PATH_SEPARATOR',':'); //Linux\n}\n\n//Set include paths. Overwrite the default paths.\nini_set('include_path', './'.PATH_SEPARATOR.INCLUDE_DIR.PATH_SEPARATOR.PEAR_DIR);\n\nrequire(INCLUDE_DIR.'class.osticket.php');\nrequire(INCLUDE_DIR.'class.misc.php');\nrequire(INCLUDE_DIR.'class.http.php');\nrequire(INCLUDE_DIR.'class.validator.php');\n\n// Determine the path in the URI used as the base of the osTicket\n// installation\nif (!defined('ROOT_PATH') && ($rp = osTicket::get_root_path(dirname(__file__))))\n    define('ROOT_PATH', rtrim($rp, '/').'/');\n\nBootstrap::init();\n\n#CURRENT EXECUTING SCRIPT.\ndefine('THISPAGE', Http::url());\n\ndefine('DEFAULT_MAX_FILE_UPLOADS', ini_get('max_file_uploads') ?: 5);\ndefine('DEFAULT_PRIORITY_ID', 1);\n\n?>\n", "<?php\n\nif(!defined('INCLUDE_DIR')) die('!');\n\nrequire_once(INCLUDE_DIR.'class.draft.php');\n\nclass DraftAjaxAPI extends AjaxController {\n\n    static function _createDraft($vars) {\n        if (false === ($vars['body'] = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => __(\"Draft body not found in request\"),\n                'code' => 422,\n                ));\n\n        if (!($draft = Draft::create($vars)) || !$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    static function _getDraft($draft) {\n        if (!$draft || !$draft instanceof Draft)\n            Http::response(205, \"Draft not found. Create one first\");\n\n        $body = Format::viewableImages($draft->getBody());\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            'body' => $body,\n            'draft_id' => $draft->getId(),\n        ));\n    }\n\n    static function _updateDraft($draft) {\n        if (false === ($body = self::_findDraftBody($_POST)))\n            return JsonDataEncoder::encode(array(\n                'error' => array(\n                    'message' => \"Draft body not found in request\",\n                    'code' => 422,\n                )\n            ));\n\n        if (!$draft->setBody($body))\n            return Http::response(500, \"Unable to update draft body\");\n\n        echo \"{}\";\n    }\n\n    static function _uploadInlineImage($draft) {\n        global $cfg;\n\n        if (!isset($_FILES['file']))\n            Http::response(422, \"File not included properly\");\n\n        # Fixup for expected multiple attachments\n        $file = AttachmentFile::format($_FILES['file']);\n\n        # Allow for data-uri uploaded files\n        $fp = fopen($file[0]['tmp_name'], 'rb');\n        if (fread($fp, 5) == 'data:') {\n            $data = 'data:';\n            while ($block = fread($fp, 8192))\n              $data .= $block;\n            $file[0] = Format::parseRfc2397($data);\n            list(,$ext) = explode('/', $file[0]['type'], 2);\n            $file[0] += array(\n                'name' => Misc::randCode(8).'.'.$ext,\n                'size' => strlen($file[0]['data']),\n            );\n        }\n        fclose($fp);\n\n        // Check file type to ensure image\n        $type = $file[0]['type'];\n        if (strpos($file[0]['type'], 'image/') !== 0)\n            return Http::response(403,\n                JsonDataEncoder::encode(array(\n                    'error' => 'File type is not allowed',\n                ))\n            );\n\n        // Check if file is truly an image\n        if (!FileUploadField::isValidFile($file[0]))\n            return Http::response(403,\n                JsonDataEncoder::encode(array(\n                    'error' => 'File is not valid',\n                ))\n            );\n\n        // Verify file size is acceptable\n        if ($file[0]['size'] > $cfg->getMaxFileSize())\n            return Http::response(403,\n                JsonDataEncoder::encode(array(\n                    'error' => 'File is too large',\n                ))\n            );\n\n        // Paste uploads in Chrome will have a name of 'blob'\n        if ($file[0]['name'] == 'blob')\n            $file[0]['name'] = 'screenshot-'.Misc::randCode(4);\n\n        $ids = $draft->attachments->upload($file);\n\n        if (!$ids) {\n            if ($file[0]['error']) {\n                return Http::response(403,\n                    JsonDataEncoder::encode(array(\n                        'error' => $file[0]['error'],\n                    ))\n                );\n\n            }\n            else\n                return Http::response(500, 'Unable to attach image');\n        }\n\n        $id = (is_array($ids)) ? $ids[0] : $ids;\n        if (!($f = AttachmentFile::lookup($id)))\n            return Http::response(500, 'Unable to attach image');\n\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode(array(\n            Format::sanitize($f->getName()) => array(\n            'content_id' => 'cid:'.$f->getKey(),\n            'id' => $f->getKey(),\n            // Return draft_id to connect the auto draft creation\n            'draft_id' => $draft->getId(),\n            'url' => $f->getDownloadUrl(\n                ['type' => 'D', 'deposition' => 'inline']),\n        )));\n    }\n\n    // Client interface for drafts =======================================\n    function createDraftClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraftClient($namespace) {\n        global $thisclient;\n\n        if ($thisclient) {\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                    $thisclient->getId());\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        else {\n            if (substr($namespace, -12) != substr(session_id(), -12))\n                Http::response(404, \"Draft not found\");\n            try {\n                $draft = Draft::lookupByNamespaceAndStaff($namespace, 0);\n            }\n            catch (DoesNotExist $e) {\n                Http::response(205, \"Draft not found. Create one first\");\n            }\n        }\n        return self::_getDraft($draft);\n    }\n\n    function updateDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        // Check the owning client-id (for logged-in users), and the\n        // session_id() for others\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_updateDraft($draft);\n    }\n\n    function deleteDraftClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        $draft->delete();\n    }\n\n    function uploadInlineImageClient($id) {\n        global $thisclient;\n\n        if (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($thisclient) {\n            if ($draft->getStaffId() != $thisclient->getId())\n                Http::response(404, \"Draft not found\");\n        }\n        else {\n            if (substr(session_id(), -12) != substr($draft->getNamespace(), -12))\n                Http::response(404, \"Draft not found\");\n        }\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarlyClient($namespace) {\n        global $thisclient;\n\n        if (!$thisclient && substr($namespace, -12) != substr(session_id(), -12))\n            Http::response(403, \"Valid session required\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace,\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImageClient($draft->getId());\n    }\n\n    // Staff interface for drafts ========================================\n    function createDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n\n        $vars = array(\n            'namespace' => $namespace,\n        );\n\n        return self::_createDraft($vars);\n    }\n\n    function getDraft($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft creation\");\n        try {\n            $draft = Draft::lookupByNamespaceAndStaff($namespace,\n                $thisstaff->getId());\n        }\n        catch (DoesNotExist $e) {\n            Http::response(205, \"Draft not found. Create one first\");\n        }\n\n        return self::_getDraft($draft);\n    }\n\n    function updateDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_updateDraft($draft);\n    }\n\n    function uploadInlineImage($draft_id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n        elseif (!($draft = Draft::lookup($draft_id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        return self::_uploadInlineImage($draft);\n    }\n\n    function uploadInlineImageEarly($namespace) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for image upload\");\n\n        $draft = Draft::create(array(\n            'namespace' => $namespace\n        ));\n        if (!$draft->save())\n            Http::response(500, 'Unable to create draft');\n\n        return $this->uploadInlineImage($draft->getId());\n    }\n\n    function deleteDraft($id) {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for draft edits\");\n        elseif (!($draft = Draft::lookup($id)))\n            Http::response(205, \"Draft not found. Create one first\");\n        elseif ($draft->getStaffId() != $thisstaff->getId())\n            Http::response(404, \"Draft not found\");\n\n        $draft->delete();\n    }\n\n    function getFileList() {\n        global $thisstaff;\n\n        if (!$thisstaff)\n            Http::response(403, \"Login required for file queries\");\n\n        $search = Q::any([\n            Q::all([\n                'attachments__type__in' => array('C', 'F', 'T', 'P'),\n                'attachments__inline' => 1,\n            ]),\n            'ft' => 'L',\n        ]);\n\n        if (isset($_GET['threadId']) && is_numeric($_GET['threadId'])\n            && ($thread = Thread::lookup($_GET['threadId']))\n            && ($object = $thread->getObject())\n            && ($thisstaff->canAccess($object))\n        ) {\n            $search->add(Q::all([\n                'attachments__thread_entry__thread_id' => $_GET['threadId'],\n                'attachments__inline' => 1,\n            ]));\n        }\n\n        $images = AttachmentFile::objects()->filter([\n                $search,\n                'type__startswith' => 'image/',\n            ])->distinct('id');\n\n        $files = array();\n        foreach ($images as $f) {\n            $url = $f->getDownloadUrl();\n            $files[] = array(\n                // Don't send special sizing for thread items 'cause they\n                // should be cached already by the client\n                'thumb' => $url.($f->type != 'H' ? '&s=128' : ''),\n                'url' => $url,\n                'title' => $f->getName(),\n            );\n        }\n        header('Content-Type: application/json; charset=UTF-8');\n        echo JsonDataEncoder::encode($files);\n    }\n\n    static function _findDraftBody($vars) {\n        if (isset($vars['name'])) {\n            $parts = array();\n            // Support nested `name`, like trans[lang]\n            if (preg_match('`(\\w+)(?:\\[(\\w+)\\])?(?:\\[(\\w+)\\])?`', $_POST['name'], $parts)) {\n                array_shift($parts);\n                $focus = $vars;\n                foreach ($parts as $p)\n                    $focus = $focus[$p];\n                return $focus;\n            }\n        }\n\n        // Get ThreadEntry field name.\n        $tform = TicketForm::objects()->one()->getForm();\n        $tfield = $tform->getField('message')->getFormName();\n        // Get Task Description field name.\n        $aform = TaskForm::objects()->one()->getForm();\n        $afield = $aform->getField('description')->getFormName();\n        $field_list = array('response', 'note', 'answer', 'body',\n             $tfield, 'issue', $afield);\n        foreach ($field_list as $field) {\n            if (isset($vars[$field])) {\n                return $vars[$field];\n            }\n        }\n\n        return false;\n    }\n\n}\n?>\n", "<?php\n/*********************************************************************\n    class.file.php\n\n    Peter Rotich <peter@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\nrequire_once(INCLUDE_DIR.'class.signal.php');\nrequire_once(INCLUDE_DIR.'class.error.php');\n\n\n/**\n * Represents a file stored in a storage backend. It is generally attached\n * to something; however company logos, login page backdrops, and other\n * items are also stored in the database for various purposes.\n *\n * FileType-Definitions:\n *    The `ft` field is used to represent the type or purpose of the file\n *    with respect to the system. These are the defined file types (placed\n *    here as the definitions are not needed in code).\n *\n *    - 'T' => Attachments\n *    - 'L' => Logo\n *    - 'B' => Backdrop\n */\nclass AttachmentFile extends VerySimpleModel {\n\n    static $meta = array(\n        'table' => FILE_TABLE,\n        'pk' => array('id'),\n        'joins' => array(\n            'attachments' => array(\n                'reverse' => 'Attachment.file'\n            ),\n        ),\n    );\n    static $keyCache = array();\n\n    function __onload() {\n        // Cache for lookup in the ::lookupByHash method below\n        static::$keyCache[$this->key] = $this;\n    }\n\n    function getHashtable() {\n        return $this->ht;\n    }\n\n    function getInfo() {\n        return $this->getHashtable();\n    }\n\n    function getNumEntries() {\n        return $this->attachments->count();\n    }\n\n    function isCanned() {\n        return $this->getNumEntries();\n    }\n\n    function isInUse() {\n        return $this->getNumEntries();\n    }\n\n    function getId() {\n        return $this->id;\n    }\n\n    function getType() {\n        return $this->type;\n    }\n\n    function getMimeType() {\n        return $this->getType();\n    }\n\n    function getBackend() {\n        return $this->bk;\n    }\n\n    function getSize() {\n        return $this->size;\n    }\n\n    function getName() {\n        return $this->name;\n    }\n\n    function getKey() {\n        return $this->key;\n    }\n\n    function getAttrs() {\n        return $this->attrs;\n    }\n\n    function getSignature($cascade=false) {\n        $sig = $this->signature;\n        if (!$sig && $cascade) return $this->getKey();\n        return $sig;\n    }\n\n    function lastModified() {\n        return $this->created;\n    }\n\n    function open() {\n        return FileStorageBackend::getInstance($this);\n    }\n\n    function sendData($redirect=true, $ttl=false, $disposition='inline') {\n        $bk = $this->open();\n        if ($redirect && $bk->sendRedirectUrl($disposition, $ttl))\n            return;\n\n        @ini_set('zlib.output_compression', 'Off');\n        try {\n            $bk->passthru();\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n    }\n\n    function getData() {\n        # XXX: This is horrible, and is subject to php's memory\n        #      restrictions, etc. Don't use this function!\n        ob_start();\n        try {\n            $this->sendData(false);\n        }\n        catch (IOException $ex) {\n            Http::response(404, 'File not found');\n        }\n        $data = &ob_get_contents();\n        ob_end_clean();\n        return $data;\n    }\n\n    function delete() {\n\n        if (!parent::delete())\n            return false;\n\n        if ($bk = $this->open())\n            $bk->unlink();\n\n        return true;\n    }\n\n    function makeCacheable($ttl=86400) {\n        Http::cacheable($this->getSignature(true), $this->lastModified(), $ttl);\n    }\n\n    function display($scale=false, $ttl=86400) {\n        $this->makeCacheable($ttl);\n\n        if ($scale && extension_loaded('gd')\n                && ($image = imagecreatefromstring($this->getData()))) {\n            $width = imagesx($image);\n            if ($scale <= $width) {\n                $height = imagesy($image);\n                if ($width > $height) {\n                    $heightp = $height * (int)$scale / $width;\n                    $widthp = $scale;\n                } else {\n                    $widthp = $width * (int)$scale / $height;\n                    $heightp = $scale;\n                }\n                $thumb = imagecreatetruecolor($widthp, $heightp);\n                $white = imagecolorallocate($thumb, 255,255,255);\n                imagefill($thumb, 0, 0, $white);\n                imagecopyresized($thumb, $image, 0, 0, 0, 0, $widthp,\n                    $heightp, $width, $height);\n                header('Content-Type: image/png');\n                imagepng($thumb);\n                return;\n            }\n        }\n        header('Content-Type: '.($this->getType()?$this->getType():'application/octet-stream'));\n        header('Content-Length: '.$this->getSize());\n        header(\"Content-Security-Policy: default-src 'self'\");\n        $this->sendData();\n        exit();\n    }\n\n    function getDownloadUrl($options=array()) {\n        // Add attachment ref id if object type is set\n        if (isset($options['type'])\n                && !isset($options['id'])\n                && ($a=$this->attachments->findFirst(array(\n                            'type' => $options['type']))))\n            $options['id'] = $a->getId();\n\n        return static::generateDownloadUrl($this->getId(),\n                strtolower($this->getKey()), $this->getSignature(),\n                $options);\n    }\n\n    // Generates full download URL for external sources.\n    // e.g. https://domain.tld/file.php?args=123\n    function getExternalDownloadUrl($options=array()) {\n        global $cfg;\n\n        $download = $this->getDownloadUrl($options);\n        // Separate URL handle and args\n        list($handle, $args) = explode('file.php?', $download);\n\n        return (string) rtrim($cfg->getBaseUrl(), '/').'/file.php?'.$args;\n    }\n\n    static function generateDownloadUrl($id, $key, $hash, $options = array()) {\n\n        // Expire at the nearest midnight, allow at least12 hrs access\n        $minage = @$options['minage'] ?: 43200;\n        $gmnow = Misc::gmtime() +  $options['minage'];\n        $expires = $gmnow + 86400 - ($gmnow % 86400);\n\n        // Generate a signature based on secret content\n        $signature = static::_genUrlSignature($id, $key, $hash, $expires);\n\n        // Handler / base url\n        $handler = @$options['handler'] ?: ROOT_PATH . 'file.php';\n\n        // Return sanitized query string\n        $args = array(\n            'key' => $key,\n            'expires' => $expires,\n            'signature' => $signature,\n        );\n\n        if (isset($options['disposition']))\n            $args['disposition'] =  $options['disposition'];\n\n        if (isset($options['id']))\n            $args['id'] =  $options['id'];\n\n        return sprintf('%s?%s', $handler, http_build_query($args));\n    }\n\n    function verifySignature($signature, $expires) {\n        $gmnow = Misc::gmtime();\n        if ($expires < $gmnow)\n            return false;\n\n        $check = static::_genUrlSignature($this->getId(), $this->getKey(),\n            $this->getSignature(), $expires);\n        return $signature == $check;\n    }\n\n    static function _genUrlSignature($id, $key, $signature, $expires) {\n        $pieces = array(\n            'Host='.$_SERVER['HTTP_HOST'],\n            'Path='.ROOT_PATH,\n            'Id='.$id,\n            'Key='.strtolower($key),\n            'Hash='.$signature,\n            'Expires='.$expires,\n        );\n        return hash_hmac('sha1', implode(\"\\n\", $pieces), SECRET_SALT);\n    }\n\n    function download($name=false, $disposition=false, $expires=false) {\n        $thisstaff = StaffAuthenticationBackend::getUser();\n        $inline = ($thisstaff ? ($thisstaff->getImageAttachmentView() === 'inline') : false);\n        $disposition = ((($disposition && strcasecmp($disposition, 'inline') == 0)\n              || $inline)\n              && strpos($this->getType(), 'image/') !== false)\n            ? 'inline' : 'attachment';\n        $ttl = ($expires) ? $expires - Misc::gmtime() : false;\n        $bk = $this->open();\n        if ($bk->sendRedirectUrl($disposition, $ttl))\n            return;\n        $this->makeCacheable($ttl);\n        $type = $this->getType() ?: 'application/octet-stream';\n        Http::download($name ?: $this->getName(), $type, null, $disposition);\n        header('Content-Length: '.$this->getSize());\n        $this->sendData(false);\n        exit();\n    }\n\n    static function _getKeyAndHash($data=false, $file=false) {\n        if ($file) {\n            $sha1 = base64_encode(sha1_file($data, true));\n            $md5 = base64_encode(md5_file($data, true));\n        }\n        else {\n            $sha1 = base64_encode(sha1($data, true));\n            $md5 = base64_encode(md5($data, true));\n        }\n\n        // Use 5 chars from the microtime() prefix and 27 chars from the\n        // sha1 hash. This should make a sufficiently strong unique key for\n        // file content. In the event there is a sha1 collision for data, it\n        // should be unlikely that there will be a collision for the\n        // microtime hash coincidently.  Remove =, change + and / to chars\n        // better suited for URLs and filesystem paths\n        $prefix = base64_encode(sha1(microtime(), true));\n        $key = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($prefix, 0, 5) . $sha1);\n\n        // The hash is a 32-char value where the first half is from the last\n        // 16 chars from the SHA1 hash and the last 16 chars are the last 16\n        // chars from the MD5 hash. This should provide for better\n        // resiliance against hash collisions and attacks against any one\n        // hash algorithm. Since we're using base64 encoding, with 6-bits\n        // per char, we should have a total hash strength of 192 bits.\n        $hash = str_replace(\n            array('=','+','/'),\n            array('','-','_'),\n            substr($sha1, 0, 16) . substr($md5, 0, 16));\n\n        return array($key, $hash);\n    }\n\n    /* Function assumes the files types have been validated */\n    static function upload($file, $ft='T', $deduplicate=true) {\n\n        if(!$file['name'] || $file['error'] || !is_uploaded_file($file['tmp_name']))\n            return false;\n\n        list($key, $sig) = self::_getKeyAndHash($file['tmp_name'], true);\n\n        $info=array('type'=>$file['type'],\n                    'filetype'=>$ft,\n                    'size'=>$file['size'],\n                    'name'=>$file['name'],\n                    'key'=>$key,\n                    'signature'=>$sig,\n                    'tmp_name'=>$file['tmp_name'],\n                    );\n\n        return static::create($info, $ft, $deduplicate);\n    }\n\n    static function uploadBackdrop(array $file, &$error) {\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n        }\n        return self::upload($file, 'B', false);\n    }\n\n    static function uploadLogo($file, &$error, $aspect_ratio=2) {\n        /* Borrowed in part from\n         * http://salman-w.blogspot.com/2009/04/crop-to-fit-image-using-aspphp.html\n         */\n        if (extension_loaded('gd')) {\n            $source_path = $file['tmp_name'];\n            list($source_width, $source_height, $source_type) = getimagesize($source_path);\n\n            switch ($source_type) {\n                case IMAGETYPE_GIF:\n                case IMAGETYPE_JPEG:\n                case IMAGETYPE_PNG:\n                    break;\n                default:\n                    $error = __('Invalid image file type');\n                    return false;\n            }\n\n            $source_aspect_ratio = $source_width / $source_height;\n\n            if ($source_aspect_ratio < $aspect_ratio) {\n                $error = __('Image is too square. Upload a wider image');\n                return false;\n            }\n        }\n        return self::upload($file, 'L', false);\n    }\n\n    static function create(&$file, $ft='T', $deduplicate=true) {\n        if (isset($file['encoding'])) {\n            switch ($file['encoding']) {\n            case 'base64':\n                $file['data'] = base64_decode($file['data']);\n            }\n        }\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk'])) {\n            // Allow a callback function to delay or avoid reading or\n            // fetching ihe file contents\n            $file['data'] = $file['data_cbk']();\n        }\n\n        if (isset($file['data'])) {\n            list($key, $file['signature'])\n                = self::_getKeyAndHash($file['data']);\n            if (!$file['key'])\n                $file['key'] = $key;\n        }\n\n        if (isset($file['size']) && $file['size'] > 0) {\n            // Check and see if the file is already on record\n            $existing = static::objects()->filter(array(\n                'signature' => $file['signature'],\n                'size' => $file['size']\n            ))->first();\n\n            // If the record exists in the database already, a file with\n            // the same hash and size is already on file -- just return\n            // the file\n            if ($deduplicate && $existing) {\n                $file['key'] = $existing->key;\n                return $existing;\n            }\n        }\n        elseif (!isset($file['data'])) {\n            // Unable to determine the file's size\n            return false;\n        }\n\n        if (!$file['type'] && extension_loaded('fileinfo')) {\n            $finfo = new finfo(FILEINFO_MIME_TYPE);\n            if ($file['data'])\n                $type = $finfo->buffer($file['data']);\n            elseif ($file['tmp_name'])\n                $type = $finfo->file($file['tmp_name']);\n\n            if ($type)\n                $file['type'] = $type;\n        }\n        if (!$file['type'])\n            $file['type'] = 'application/octet-stream';\n\n\n        $f = new static(array(\n            'type' => strtolower($file['type']),\n            'name' => $file['name'],\n            'key' => $file['key'],\n            'ft' => $ft ?: 'T',\n            'signature' => $file['signature'],\n            'created' => SqlFunction::NOW(),\n        ));\n\n        if (isset($file['size']))\n            $f->size = $file['size'];\n\n        if (!$f->save())\n            return false;\n\n        // Note that this is preferred over $f->open() because the file does\n        // not have a valid backend configured yet. ::getBackendForFile()\n        // will consider the system configuration for storing the file\n        $bks = array(self::getBackendForFile($f));\n        if (!$bks[0]->getBkChar() !== 'D')\n            $bks[] = new AttachmentChunkedData($f);\n\n        // Consider the selected backen first and then save to database\n        // otherwise.\n        $succeeded = false;\n        foreach ($bks as $bk) {\n            try {\n                if (isset($file['tmp_name'])) {\n                    if ($bk->upload($file['tmp_name'])) {\n                        $succeeded = true; break;\n                    }\n                }\n                elseif ($bk->write($file['data']) && $bk->flush()) {\n                    $succeeded = true; break;\n                }\n            }\n            catch (Exception $e) {\n                // Try next backend\n            }\n            // Fallthrough to default backend if different?\n        }\n        if (!$succeeded) {\n            // Unable to save data (weird)\n            return false;\n        }\n\n        $f->bk = $bk->getBkChar();\n        $f->attrs = $bk->getAttrs() ?: NULL;\n\n        if (!isset($file['size'])) {\n            if ($size = $bk->getSize())\n                $f->size = $size;\n            // Prefer mb_strlen, because mbstring.func_overload will\n            // automatically prefer it if configured.\n            elseif (extension_loaded('mbstring'))\n                $f->size = mb_strlen($file['data'], '8bit');\n            // bootstrap.php include a compat version of mb_strlen\n            else\n                $f->size = strlen($file['data']);\n        }\n\n        $f->save();\n        return $f;\n    }\n\n    static function __create($file, &$errors) {\n        return static::create($file);\n    }\n\n    /**\n     * Migrate this file from the current backend to the backend specified.\n     *\n     * Parameters:\n     * $bk - (string) type char of the target storage backend. Use\n     *      AttachmentStorageBackend::allRegistered() to get a list of type\n     *      chars and associated class names\n     *\n     * Returns:\n     * True if the migration was successful and false otherwise.\n     */\n    function migrate($bk) {\n\n        // Copy the file to the new backend and hash the contents\n        $target = FileStorageBackend::lookup($bk, $this);\n        $source = $this->open();\n\n        // Initialize hashing algorithm to verify uploaded contents\n        $algos = $target->getNativeHashAlgos();\n        $common_algo = 'sha1';\n        if ($algos && is_array($algos)) {\n            $supported = hash_algos();\n            foreach ($algos as $a) {\n                if (in_array(strtolower($a), $supported)) {\n                    $common_algo = strtolower($a);\n                    break;\n                }\n            }\n        }\n        $before = hash_init($common_algo);\n        // TODO: Make this resumable so that if the file cannot be migrated\n        //      in the max_execution_time, the migration can be continued\n        //      the next time the cron runs\n        try {\n            while ($block = $source->read($target->getBlockSize())) {\n                hash_update($before, $block);\n                $target->write($block);\n            }\n            $target->flush();\n        }\n        catch (Exception $e) {\n            // Migration failed\n            return false;\n        }\n\n        // Ask the backend to generate its own hash if at all possible\n        if (!($target_hash = $target->getHashDigest($common_algo))) {\n            $after = hash_init($common_algo);\n            // Verify that the hash of the target file matches the hash of\n            // the source file\n            $target = FileStorageBackend::lookup($bk, $this);\n            while ($block = $target->read())\n                hash_update($after, $block);\n            $target_hash = hash_final($after);\n        }\n\n        if (hash_final($before) != $target_hash) {\n            $target->unlink();\n            return false;\n        }\n\n        $this->bk = $target->getBkChar();\n        $this->attrs = $target->getAttrs() ?: NULL;\n        if (!$this->save())\n            return false;\n\n        return $source->unlink();\n    }\n\n    /**\n     * Considers the system's configuration for file storage selection based\n     * on the file information and purpose (FAQ attachment, image, etc).\n     *\n     * Parameters:\n     * $file - (hasharray) file information which would be passed to\n     * ::save() for instance.\n     *\n     * Returns:\n     * Instance<FileStorageBackend> backend selected based on the file\n     * received.\n     */\n    static function getBackendForFile($file) {\n        global $cfg;\n\n        $char = null;\n        if ($cfg) {\n            $char = $cfg->getDefaultStorageBackendChar();\n        }\n        try {\n            return FileStorageBackend::lookup($char ?: 'D', $file);\n        }\n        catch (Exception $x) {\n            return new AttachmentChunkedData($file);\n        }\n    }\n\n    static function lookupByHash($hash) {\n        if (isset(static::$keyCache[$hash]))\n            return static::$keyCache[$hash];\n        // Cache a negative lookup if no such file exists\n        try {\n            return parent::lookup(array('key' => $hash));\n        } catch (ObjectNotUnique $e) {\n            // TODO: Figure out why key collission might be happening AND\n            // make key (hash) unique field in the file table as a\n            // protection measure. For now we're returning null to avoid possible wrong file\n            // being displayed.\n            return null;\n        }\n    }\n\n    static function lookup($id) {\n        return is_string($id)\n            ? static::lookupByHash($id)\n            : parent::lookup($id);\n    }\n\n    /*\n      Method formats http based $_FILE uploads - plus basic validation.\n     */\n    static function format($files) {\n        global $ost;\n\n        if(!$files || !is_array($files))\n            return null;\n\n        //Reformat $_FILE  for the sane.\n        $attachments = array();\n        foreach($files as $k => $a) {\n            if(is_array($a))\n                foreach($a as $i => $v)\n                    $attachments[$i][$k] = $v;\n        }\n\n        //Basic validation.\n        foreach($attachments as $i => &$file) {\n            $file['name'] = Format::sanitize($file['name']);\n\n            //skip no file upload \"error\" - why PHP calls it an error is beyond me.\n            if($file['error'] && $file['error']==UPLOAD_ERR_NO_FILE) {\n                unset($attachments[$i]);\n                continue;\n            }\n\n            if($file['error']) //PHP defined error!\n                $file['error'] = 'File upload error #'.$file['error'];\n            elseif(!$file['tmp_name'] || !is_uploaded_file($file['tmp_name']))\n                $file['error'] = 'Invalid or bad upload POST';\n        }\n        unset($file);\n\n        return array_filter($attachments);\n    }\n\n    /**\n     * Removes files and associated meta-data for files which no ticket,\n     * canned-response, or faq point to any more.\n     */\n    static function deleteOrphans() {\n\n        // XXX: Allow plugins to define filetypes which do not represent\n        //      files attached to tickets or other things in the attachment\n        //      table and are not logos\n        $files = static::objects()\n            ->filter(array(\n                'attachments__object_id__isnull' => true,\n                'ft' => 'T',\n                'created__lt' => SqlFunction::NOW()->minus(SqlInterval::DAY(1)),\n            ));\n\n        foreach ($files as $f) {\n            if (!$f->delete())\n                break;\n        }\n\n        return true;\n    }\n\n    static function allLogos() {\n        return static::objects()\n            ->filter(array('ft' => 'L'))\n            ->order_by('created');\n    }\n\n    static function allBackdrops() {\n        return static::objects()\n            ->filter(array('ft' => 'B'))\n            ->order_by('created');\n    }\n}\n\nclass FileStorageBackend {\n    var $meta;\n    static $desc = false;\n    static $registry;\n    static $blocksize = 131072;\n    static $private = false;\n\n    /**\n     * All storage backends should call this function during the request\n     * bootstrap phase.\n     */\n    static function register($typechar, $class) {\n        self::$registry[$typechar] = $class;\n    }\n\n    static function allRegistered($private=false) {\n        $R = self::$registry;\n        if (!$private) {\n            foreach ($R as $i=>$bk) {\n                if ($bk::$private)\n                    unset($R[$i]);\n            }\n        }\n        return $R;\n    }\n\n    /**\n     * Retrieves the type char registered for this storage backend's class.\n     * Null is returned if the backend is not properly registered.\n     */\n    function getBkChar() {\n        foreach (self::$registry as $tc=>$class)\n            if ($this instanceof $class)\n                return $tc;\n    }\n\n    static function isRegistered($type) {\n        return isset(self::$registry[$type]);\n    }\n\n    static function lookup($type, $file=null) {\n        if (!isset(self::$registry[$type]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$type];\n        return new $class($file);\n    }\n\n    static function getInstance($file) {\n        if (!isset(self::$registry[$file->getBackend()]))\n            throw new Exception(\"No such backend registered\");\n\n        $class = self::$registry[$file->getBackend()];\n        return new $class($file);\n    }\n\n    /**\n     * Returns the optimal block size for the backend. When migrating, this\n     * size blocks would be best for sending to the ::write() method\n     */\n    function getBlockSize() {\n        return static::$blocksize;\n    }\n\n    /**\n     * Create an instance of the storage backend linking the related file.\n     * Information about the file metadata is accessible via the received\n     * filed object.\n     */\n    function __construct($meta) {\n        $this->meta = $meta;\n    }\n\n    /**\n     * Commit file to the storage backend. This method is used if the\n     * backend cannot support writing a file directly. Otherwise, the\n     * ::upload($file) method is preferred.\n     *\n     * Parameters:\n     * $data - (string|binary) file contents to be written to the backend\n     */\n    function write($data) {\n        return false;\n    }\n\n    /**\n     * Called after all the blocks are sent to the ::write() method. This\n     * method should return boolean FALSE if flushing the data was\n     * somehow inhibited.\n     */\n    function flush() {\n        return true;\n    }\n\n    /**\n     * Upload a file to the backend. This method is preferred over ::write()\n     * for files which are uploaded or are otherwise available out of\n     * memory. The backend is encouraged to avoid reading the entire\n     * contents into memory.\n     */\n    function upload($filepath) {\n        return $this->write(file_get_contents($filepath));\n    }\n\n    /**\n     * Returns data from the backend, optionally returning only the number\n     * of bytes indicated at the specified offset. If the data is available\n     * in chunks, one chunk may be returned at a time. The backend should\n     * return boolean false when no more chunks are available.\n     */\n    function read($amount=0, $offset=0) {\n        return false;\n    }\n\n    /**\n     * Convenience method to send all the file to standard output\n     */\n    function passthru() {\n        while ($block = $this->read())\n            echo $block;\n    }\n\n    /**\n     * If the data is not stored or not available locally, a redirect\n     * response can be sent to the user agent indicating the actual HTTP\n     * location of the data.\n     *\n     * If the data is available locally, this method should return boolean\n     * false to indicate that the read() method should be used to retrieve\n     * the data and broker it to the user agent.\n     */\n    function sendRedirectUrl($disposition='inline', $ttl=false) {\n        return false;\n    }\n\n    /**\n     * Requests the backend to remove the file contents.\n     */\n    function unlink() {\n        return false;\n    }\n\n    /**\n     * Fetches a list of hash algorithms that are supported transparently\n     * through the ::write() and ::upload() methods. After writing or\n     * uploading file content, the ::getHashDigest($algo) method can be\n     * called to get a hash of the remote content without fetching the\n     * entire data stream to verify the content locally.\n     */\n    function getNativeHashAlgos() {\n        return array();\n    }\n\n    /**\n     * Returns a hash of the content calculated remotely by the storage\n     * backend. If this method fails, the hash chould be calculated by\n     * downloading the content and hashing locally\n     */\n    function getHashDigest($algo) {\n        return false;\n    }\n\n    /**\n     * getSize\n     *\n     * Retrieves the size of the contents written or available to be read.\n     * The backend should optimize this process if possible by keeping track\n     * of the bytes written in a way apart from `strlen`. This value will be\n     * used instead of inspecting the contents using `strlen`.\n     */\n    function getSize() {\n        return false;\n    }\n\n    /**\n     * getAttrs\n     *\n     * Get backend storage attributes.\n     *\n     */\n    function getAttrs() {\n        return false;\n    }\n}\n\n\n/**\n * Attachments stored in the database are cut into 500kB chunks and stored\n * in the FILE_CHUNK_TABLE to overcome the max_allowed_packet limitation of\n * LOB fields in the MySQL database\n */\ndefine('CHUNK_SIZE', 500*1024); # Beware if you change this...\nclass AttachmentFileChunk extends VerySimpleModel {\n    static $meta = array(\n        'table' => FILE_CHUNK_TABLE,\n        'pk' => array('file_id', 'chunk_id'),\n        'joins' => array(\n            'file' => array(\n                'constraint' => array('file_id' => 'AttachmentFile.id'),\n            ),\n        ),\n    );\n}\n\nclass AttachmentChunkedData extends FileStorageBackend {\n    static $desc = /* @trans */ \"In the database\";\n    static $blocksize = CHUNK_SIZE;\n\n    function __construct($file) {\n        $this->file = $file;\n        $this->_chunk = 0;\n        $this->_buffer = false;\n        $this->eof = false;\n    }\n\n    function getSize() {\n        $row = AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->aggregate(array('length' => SqlAggregate::SUM(SqlFunction::LENGTH(new SqlField('filedata')))))\n            ->one();\n        return $row['length'];\n    }\n\n    function read($amount=CHUNK_SIZE, $offset=0) {\n        # Read requested length of data from attachment chunks\n        if ($this->eof)\n            return false;\n\n        while (strlen($this->_buffer) < $amount + $offset) {\n            try {\n                list($buf) = AttachmentFileChunk::objects()\n                    ->filter(array('file' => $this->file, 'chunk_id' => $this->_chunk++))\n                    ->values_flat('filedata')\n                    ->one();\n            }\n            catch (DoesNotExist $e) {\n                $this->eof = true;\n                break;\n            }\n            $this->_buffer .= $buf;\n        }\n        $chunk = substr($this->_buffer, $offset, $amount);\n        $this->_buffer = substr($this->_buffer, $offset + $amount);\n        return $chunk;\n    }\n\n    function write($what, $chunk_size=CHUNK_SIZE) {\n        $offset=0;\n        while ($block = substr($what, $offset, $chunk_size)) {\n            // Chunks are considered immutable. Importing chunks should\n            // forceable remove the contents of a file before write()ing new\n            // chunks. Therefore, inserts should be safe.\n            $chunk = new AttachmentFileChunk(array(\n                'file' => $this->file,\n                'chunk_id' => $this->_chunk++,\n                'filedata' => $block\n            ));\n            if (!$chunk->save())\n                return false;\n            $offset += strlen($block);\n        }\n\n        return $this->_chunk;\n    }\n\n    function unlink() {\n        return AttachmentFileChunk::objects()\n            ->filter(array('file' => $this->file))\n            ->delete();\n    }\n}\nFileStorageBackend::register('D', 'AttachmentChunkedData');\n\n/**\n * This class provides an interface for files attached on the filesystem in\n * versions previous to v1.7. The upgrader will keep the attachments on the\n * disk where they were and write the path into the `attrs` field of the\n * %file table. This module will continue to serve those files until they\n * are migrated with the `file` cli app\n */\nclass OneSixAttachments extends FileStorageBackend {\n    static $desc = \"upload_dir folder (from osTicket v1.6)\";\n    static $private = true;\n\n    function read($bytes=32768, $offset=false) {\n        $filename = $this->meta->attrs;\n        if (!$this->fp)\n            $this->fp = @fopen($filename, 'rb');\n        if (!$this->fp)\n            throw new IOException($filename.': Unable to open for reading');\n        if ($offset)\n            fseek($this->fp, $offset);\n        if (($status = @fread($this->fp, $bytes)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function passthru() {\n        $filename = $this->meta->attrs;\n        if (($status = @readfile($filename)) === false)\n            throw new IOException($filename.': Unable to read from file');\n        return $status;\n    }\n\n    function write($data) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function upload($filepath) {\n        throw new IOException('This backend does not support new files');\n    }\n\n    function unlink() {\n        $filename = $this->meta->attrs;\n        if (!@unlink($filename))\n            throw new IOException($filename.': Unable to delete file');\n        // Drop usage of the `attrs` field\n        $this->meta->attrs = null;\n        $this->meta->save();\n        return true;\n    }\n}\nFileStorageBackend::register('6', 'OneSixAttachments');\n\n// FileObject - wrapper for SplFileObject class\nclass FileObject extends SplFileObject {\n\n    protected $_filename;\n\n    function __construct($file, $mode='r') {\n        parent::__construct($file, $mode);\n    }\n\n    /* This allows us to set REAL file name as opposed to basename of the\n     * FS file in question\n     */\n    function setFilename($filename) {\n        $this->_filename = $filename;\n    }\n\n    function getFilename() {\n        return $this->_filename ?: parent::getFilename();\n    }\n\n    /*\n     * Set mime type - well formated mime is expected.\n     */\n    function setMimeType($type) {\n        $this->_mimetype = $type;\n    }\n\n    function getMimeType() {\n        if (!isset($this->_mimetype))\n            $this->_mimetype = self::mime_type($this->getRealPath());\n\n        return $this->_mimetype;\n    }\n\n    function getContents() {\n        $this->fseek(0);\n        return $this->fread($this->getSize());\n    }\n\n    /*\n     * XXX: Needed for mailer attachments interface\n     */\n    function getData() {\n        return $this->getContents();\n    }\n\n    /*\n     * Given a filepath - auto detect the mime type\n     *\n     */\n    static function mime_type($filepath) {\n        // Try to to auto-detect mime type\n        $type = null;\n        if (function_exists('finfo_open')) {\n            $finfo = finfo_open(FILEINFO_MIME_TYPE);\n            $type = finfo_file($finfo, $filepath);\n            finfo_close($finfo);\n        }\n        return $type ?: mime_content_type($filepath);\n    }\n}\n\n?>\n", "<?php\n/*********************************************************************\n    class.forms.php\n\n    osTicket forms framework\n\n    Jared Hancock <jared@osticket.com>\n    Copyright (c)  2006-2013 osTicket\n    http://www.osticket.com\n\n    Released under the GNU General Public License WITHOUT ANY WARRANTY.\n    See LICENSE.TXT for details.\n\n    vim: expandtab sw=4 ts=4 sts=4:\n**********************************************************************/\n\n/**\n * Form template, used for designing the custom form and for entering custom\n * data for a ticket\n */\nclass Form {\n    static $renderer = 'GridFluidLayout';\n    static $id = 0;\n\n    var $options = array();\n    var $fields = array();\n    var $title = '';\n    var $instructions = '';\n\n    var $validators = array();\n\n    var $_errors = null;\n    var $_source = false;\n\n    function __construct($source=null, $options=array()) {\n\n        $this->options = $options;\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        if (isset($options['id']))\n            $this->id = $options['id'];\n\n        // Use POST data if source was not specified\n        $this->_source = $source ?: $_POST;\n    }\n\n    function getFormId() {\n        return @$this->id ?: static::$id;\n    }\n    function setId($id) {\n        $this->id = $id;\n    }\n\n    function data($source) {\n        foreach ($this->fields as $name=>$f)\n            if (isset($source[$name]))\n                $f->value = $source[$name];\n    }\n\n    function setFields($fields) {\n\n        if (!is_array($fields) && !$fields instanceof Traversable)\n            return;\n\n        $this->fields = $fields;\n        foreach ($fields as $k=>$f) {\n            $f->setForm($this);\n            if (!$f->get('name') && $k && !is_numeric($k))\n                $f->set('name', $k);\n        }\n    }\n\n    function getFields() {\n        return $this->fields;\n    }\n\n    function getField($name) {\n        $fields = $this->getFields();\n        foreach($fields as $f)\n            if(!strcasecmp($f->get('name'), $name))\n                return $f;\n        if (isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function hasField($name) {\n        return $this->getField($name);\n    }\n\n    function hasAnyEnabledFields() {\n        return $this->hasAnyVisibleFields(false);\n    }\n\n    function hasAnyVisibleFields($user=false) {\n        $visible = 0;\n        $isstaff = $user instanceof Staff;\n        foreach ($this->getFields() as $F) {\n            if (!$user) {\n                // Assume hasAnyEnabledFields\n                if ($F->isEnabled())\n                    $visible++;\n            } elseif($isstaff) {\n                if ($F->isVisibleToStaff())\n                    $visible++;\n            } elseif ($F->isVisibleToUsers()) {\n                $visible++;\n            }\n        }\n        return $visible > 0;\n    }\n\n    function getTitle() { return $this->title; }\n    function getInstructions() { return Format::htmldecode($this->instructions); }\n    function getSource() { return $this->_source; }\n    function setSource($source) { $this->_source = $source; }\n\n    /**\n     * Validate the form and indicate if there no errors.\n     *\n     * Parameters:\n     * $filter - (callback) function to receive each field and return\n     *      boolean true if the field's errors are significant\n     */\n    function isValid($include=false) {\n        if (!isset($this->_errors)) {\n            $this->_errors = array();\n            $this->validate($this->getClean());\n            foreach ($this->getFields() as $field)\n                if ($field->errors() && (!$include || $include($field)))\n                    $this->_errors[$field->get('id')] = $field->errors();\n        }\n        return !$this->_errors;\n    }\n\n    function validate($clean_data) {\n        // Validate the whole form so that errors can be added to the\n        // individual fields and collected below.\n        foreach ($this->validators as $V) {\n            $V($this);\n        }\n    }\n\n    function getClean($validate=true) {\n        if (!$this->_clean) {\n            $this->_clean = array();\n            foreach ($this->getFields() as $key=>$field) {\n                if (!$field->hasData())\n                    continue;\n\n                // Prefer indexing by field.id if indexing numerically\n                if (is_int($key) && $field->get('id'))\n                    $key = $field->get('id');\n                $this->_clean[$key] = $this->_clean[$field->get('name')]\n                    = $field->getClean($validate);\n            }\n            unset($this->_clean[\"\"]);\n        }\n        return $this->_clean;\n    }\n\n    /*\n     * Process the form input and return clean data.\n     *\n     * It's similar to getClean but forms downstream can use it to return\n     * database ready data.\n     */\n    function process($validate=true) {\n        return $this->getClean($validate);\n    }\n\n    function errors($formOnly=false) {\n        return ($formOnly) ? $this->_errors['form'] : $this->_errors;\n    }\n\n    function addError($message, $index=false) {\n\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors['form'][] = $message;\n    }\n\n    function addErrors($errors=array()) {\n        foreach ($errors as $k => $v) {\n            if (($f=$this->getField($k)))\n                $f->addError($v);\n            else\n                $this->addError($v, $k);\n        }\n    }\n\n    function addValidator($function) {\n        if (!is_callable($function))\n            throw new Exception('Form validator must be callable');\n        $this->validators[] = $function;\n    }\n\n    function render($options=array()) {\n        if (isset($options['title']))\n            $this->title = $options['title'];\n        if (isset($options['instructions']))\n            $this->instructions = $options['instructions'];\n        $form = $this;\n        $template = $options['template'] ?: 'dynamic-form.tmpl.php';\n        if (isset($options['staff']) && $options['staff'])\n            include(STAFFINC_DIR . 'templates/' . $template);\n        else\n            include(CLIENTINC_DIR . 'templates/' . $template);\n        echo $this->getMedia();\n    }\n\n    function getLayout($title=false, $options=array()) {\n        $rc = @$options['renderer'] ?: static::$renderer;\n        return new $rc($title, $options);\n    }\n\n    function asTable($title=false, $options=array()) {\n        return $this->getLayout($title, $options)->asTable($this);\n        // XXX: Media can't go in a table\n        echo $this->getMedia();\n    }\n\n    function getMedia() {\n        static $dedup = array();\n\n        foreach ($this->getFields() as $f) {\n            if (($M = $f->getMedia()) && is_array($M)) {\n                foreach ($M as $type=>$files) {\n                    foreach ($files as $url) {\n                        $key = strtolower($type.$url);\n                        if (isset($dedup[$key]))\n                            continue;\n\n                        self::emitMedia($url, $type);\n\n                        $dedup[$key] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    function emitJavascript($options=array()) {\n\n        // Check if we need to emit javascript\n        if (!($fid=$this->getFormId()))\n            return;\n        ?>\n        <script type=\"text/javascript\">\n          $(function() {\n            <?php\n            //XXX: We ONLY want to watch field on this form. We'll only\n            // watch form inputs if form_id is specified. Current FORM API\n            // doesn't generate the entire form  (just fields)\n            if ($fid) {\n                ?>\n                $(document).off('change.<?php echo $fid; ?>');\n                $(document).on('change.<?php echo $fid; ?>',\n                    'form#<?php echo $fid; ?> :input',\n                    function() {\n                        //Clear any current errors...\n                        var errors = $('#field'+$(this).attr('id')+'_error');\n                        if (errors.length)\n                            errors.slideUp('fast', function (){\n                                $(this).remove();\n                                });\n                        //TODO: Validation input inplace or via ajax call\n                        // and set any new errors AND visibilty changes\n                    }\n                   );\n            <?php\n            }\n            ?>\n            });\n        </script>\n        <?php\n    }\n\n    static function emitMedia($url, $type) {\n        if ($url[0] == '/')\n            $url = ROOT_PATH . substr($url, 1);\n\n        switch (strtolower($type)) {\n        case 'css': ?>\n        <link rel=\"stylesheet\" type=\"text/css\" href=\"<?php echo $url; ?>\"/><?php\n            break;\n        case 'js': ?>\n        <script type=\"text/javascript\" src=\"<?php echo $url; ?>\"></script><?php\n            break;\n        }\n    }\n\n    /**\n     * getState\n     *\n     * Retrieves an array of information which can be passed to the\n     * ::loadState method later to recreate the current state of the form\n     * fields and values.\n     */\n    function getState() {\n        $info = array();\n        foreach ($this->getFields() as $f) {\n            // Skip invisible fields\n            if (!$f->isVisible())\n                continue;\n\n            // Skip fields set to default values\n            $v = $f->getClean();\n            $d = $f->get('default');\n            if ($v == $d)\n                continue;\n\n            // Skip empty values\n            if (!$v)\n                continue;\n\n            $info[$f->get('name') ?: $f->get('id')] = $f->to_database($v);\n        }\n        return $info;\n    }\n\n    /**\n     * loadState\n     *\n     * Reset this form to the state previously recorded by the ::getState()\n     * method\n     */\n    function loadState($state) {\n        foreach ($this->getFields() as $f) {\n            $name = $f->get('name');\n            $f->reset();\n            if (isset($state[$name])) {\n                $f->value = $f->to_php($state[$name]);\n            }\n        }\n    }\n\n    /*\n     * Initialize a generic static form\n     */\n    static function instantiate() {\n        $r = new ReflectionClass(get_called_class());\n        return $r->newInstanceArgs(func_get_args());\n    }\n}\n\n/**\n * SimpleForm\n * Wrapper for inline/static forms.\n *\n */\nclass SimpleForm extends Form {\n    function __construct($fields=array(), $source=null, $options=array()) {\n        parent::__construct($source, $options);\n        if (isset($options['type']))\n            $this->type = $options['type'];\n        $this->setFields($fields);\n    }\n\n    function getId() {\n        return $this->getFormId();\n    }\n}\n\nclass CustomForm extends SimpleForm {\n\n    function getFields() {\n        global $thisstaff, $thisclient;\n\n        $options = $this->options;\n        $user = $options['user'] ?: $thisstaff ?: $thisclient;\n        $isedit = ($options['mode'] == 'edit');\n        $fields = array();\n        foreach (parent::getFields() as $field) {\n            if ($isedit && !$field->isEditable($user))\n                continue;\n\n            $fields[] = $field;\n        }\n\n        return $fields;\n    }\n}\n\nabstract class AbstractForm extends Form {\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n        $this->setFields($this->buildFields());\n    }\n    /**\n     * Fetch the fields defined for this form. This method is only called\n     * once.\n     */\n    abstract function buildFields();\n}\n\n/**\n * Container class to represent the connection between the form fields and the\n * rendered state of the form.\n */\ninterface FormRenderer {\n    // Render the form fields into a table\n    function asTable($form);\n    // Render the form fields into divs\n    function asBlock($form);\n}\n\nabstract class FormLayout {\n    static $default_cell_layout = 'Cell';\n\n    var $title;\n    var $options;\n\n    function __construct($title=false, $options=array()) {\n        $this->title = $title;\n        $this->options = $options;\n    }\n\n    function getLayout($field) {\n        $layout = $field->get('layout') ?: static::$default_cell_layout;\n        if (is_string($layout))\n            $layout = new $layout();\n        return $layout;\n    }\n}\n\nclass GridFluidLayout\nextends FormLayout\nimplements FormRenderer {\n    function asTable($form) {\n      ob_start();\n?>\n      <table class=\"<?php echo 'grid form' ?>\">\n          <caption><?php echo Format::htmlchars($this->title ?: $form->getTitle()); ?>\n                  <div><small><?php echo Format::viewableImages($form->getInstructions()); ?></small></div>\n          </caption>\n          <tbody><tr><?php for ($i=0; $i<12; $i++) echo '<td style=\"width:8.3333%\"/>'; ?></tr></tbody>\n<?php\n      $row_size = 12;\n      $cols = $row = 0;\n\n      //Layout and rendering options\n      $options = $this->options;\n\n      foreach ($form->getFields() as $f) {\n          $layout = $this->getLayout($f);\n          $size = $layout->getWidth() ?: 12;\n          if ($offs = $layout->getOffset()) {\n              $size += $offs;\n          }\n          if ($cols < $size || $layout->isBreakForced()) {\n              if ($row) echo '</tr>';\n              echo '<tr>';\n              $cols = $row_size;\n              $row++;\n          }\n          // Render the cell\n          $cols -= $size;\n          $attrs = array('colspan' => $size, 'rowspan' => $layout->getHeight(),\n              'style' => '\"'.$layout->getOption('style').'\"');\n          if ($offs) { ?>\n              <td colspan=\"<?php echo $offs; ?>\"></td> <?php\n          }\n          ?>\n          <td class=\"cell\" <?php echo Format::array_implode('=', ' ', array_filter($attrs)); ?>\n              data-field-id=\"<?php echo $f->get('id'); ?>\">\n              <fieldset class=\"field <?php if (!$f->isVisible()) echo 'hidden'; ?>\"\n                id=\"field<?php echo $f->getWidget()->id; ?>\"\n                data-field-id=\"<?php echo $f->get('id'); ?>\">\n<?php         $label = $f->get('label'); ?>\n              <label class=\"<?php if ($f->isRequired()) echo 'required'; ?>\"\n                  for=\"<?php echo $f->getWidget()->id; ?>\">\n                  <?php echo $label ? (Format::htmlchars($label).':') : '&nbsp;'; ?>\n                <?php if ($f->isRequired()) { ?>\n                <span class=\"error\">*</span>\n              </label>\n<?php         }\n              if ($f->get('hint')) { ?>\n                  <div class=\"field-hint-text\">\n                      <?php echo Format::htmlchars($f->get('hint')); ?>\n                  </div>\n<?php         }\n              $f->render($options);\n              if ($f->errors())\n                  foreach ($f->errors() as $e)\n                      echo sprintf('<div class=\"error\">%s</div>', Format::htmlchars($e));\n?>\n              </fieldset>\n          </td>\n      <?php\n      }\n      if ($row)\n        echo  '</tr>';\n\n      echo '</tbody></table>';\n\n      return ob_get_clean();\n    }\n\n    function asBlock($form) {}\n}\n\n/**\n * Basic container for field and form layouts. By default every cell takes\n * a whole output row and does not imply any sort of width.\n */\nclass Cell {\n    function isBreakForced()  { return true; }\n    function getWidth()       { return false; }\n    function getHeight()      { return 1; }\n    function getOffset()      { return 0; }\n    function getOption($prop) { return false; }\n}\n\n/**\n * Fluid grid layout, meaning each cell renders to the right of the previous\n * cell (for left-to-right layouts). A width in columns can be specified for\n * each cell along with an offset from the previous cell. A height of columns\n * along with an optional break is supported.\n */\nclass GridFluidCell\nextends Cell {\n    var $span;\n    var $options;\n\n    function __construct($span, $options=array()) {\n        $this->span = $span;\n        $this->options = $options + array(\n            'rows' => 1,        # rowspan\n            'offset' => 0,      # skip some columns\n            'break' => false,   # start on a new row\n        );\n    }\n\n    function isBreakForced()  { return $this->options['break']; }\n    function getWidth()       { return $this->span; }\n    function getHeight()      { return $this->options['rows']; }\n    function getOffset()      { return $this->options['offset']; }\n    function getOption($prop) { return $this->options[$prop]; }\n}\n\nrequire_once(INCLUDE_DIR . \"class.json.php\");\n\nclass FormField {\n    static $widget = false;\n\n    var $ht = array(\n        'label' => false,\n        'required' => false,\n        'default' => false,\n        'configuration' => array(),\n    );\n\n    var $_form;\n    var $_cform;\n    var $_clean;\n    var $_errors = array();\n    var $_widget;\n    var $answer;\n    var $parent;\n    var $presentation_only = false;\n\n    static $types = array(\n        /* @trans */ 'Basic Fields' => array(\n            'text'  => array(   /* @trans */ 'Short Answer', 'TextboxField'),\n            'memo' => array(    /* @trans */ 'Long Answer', 'TextareaField'),\n            'thread' => array(  /* @trans */ 'Thread Entry', 'ThreadEntryField', false),\n            'datetime' => array(/* @trans */ 'Date and Time', 'DatetimeField'),\n            'timezone' => array(/* @trans */ 'Timezone', 'TimezoneField'),\n            'phone' => array(   /* @trans */ 'Phone Number', 'PhoneField'),\n            'bool' => array(    /* @trans */ 'Checkbox', 'BooleanField'),\n            'choices' => array( /* @trans */ 'Choices', 'ChoiceField'),\n            'files' => array(   /* @trans */ 'File Upload', 'FileUploadField'),\n            'break' => array(   /* @trans */ 'Section Break', 'SectionBreakField'),\n            'info' => array(    /* @trans */ 'Information', 'FreeTextField'),\n        ),\n    );\n    static $more_types = array();\n    static $uid = null;\n\n    static function _uid() {\n        return ++self::$uid;\n    }\n\n    function __construct($options=array()) {\n        $this->ht = array_merge($this->ht, $options);\n        if (!isset($this->ht['id']))\n            $this->ht['id'] = self::_uid();\n    }\n\n    function __clone() {\n        $this->_widget = null;\n        $this->ht['id'] = self::_uid();\n    }\n\n    static function addFieldTypes($group, $callable) {\n        static::$more_types[$group][] = $callable;\n    }\n\n    static function allTypes() {\n        if (static::$more_types) {\n            foreach (static::$more_types as $group => $entries)\n                foreach ($entries as $c)\n                    static::$types[$group] = array_merge(\n                            static::$types[$group] ?? array(), call_user_func($c));\n\n            static::$more_types = array();\n        }\n        return static::$types;\n    }\n\n    static function getFieldType($type) {\n        foreach (static::allTypes() as $group=>$types)\n            if (isset($types[$type]))\n                return $types[$type];\n    }\n\n    function get($what, $default=null) {\n        return array_key_exists($what, $this->ht)\n            ? $this->ht[$what]\n            : $default;\n    }\n    function set($field, $value) {\n        $this->ht[$field] = $value;\n    }\n\n    function getId() {\n        return $this->ht['id'];\n    }\n\n    /**\n     * getClean\n     *\n     * Validates and cleans inputs from POST request. This is performed on a\n     * field instance, after a DynamicFormSet / DynamicFormSection is\n     * submitted via POST, in order to kick off parsing and validation of\n     * user-entered data.\n     */\n    function getClean($validate=true) {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                // XXX: The widget value may be parsed already if this is\n                //      linked to dynamic data via ::getAnswer()\n                ? $this->value : $this->parse($this->getWidget()->value);\n\n            if ($vs = $this->get('cleaners')) {\n                if (is_array($vs)) {\n                    foreach ($vs as $cleaner)\n                        if (is_callable($cleaner))\n                            $this->_clean = call_user_func_array(\n                                    $cleaner, array($this, $this->_clean));\n                }\n                elseif (is_callable($vs))\n                    $this->_clean = call_user_func_array(\n                            $vs, array($this, $this->_clean));\n            }\n\n            if (!isset($this->_clean) && ($d = $this->get('default')))\n                $this->_clean = $d;\n\n            if ($this->isVisible() && $validate)\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n\n    function reset() {\n        $this->value = $this->_clean = $this->_widget = null;\n    }\n\n    function getValue() {\n        return $this->getWidget()->getValue();\n    }\n\n    function errors() {\n        return $this->_errors;\n    }\n    function addError($message, $index=false) {\n        if ($index)\n            $this->_errors[$index] = $message;\n        else\n            $this->_errors[] = $message;\n\n        // Update parent form errors for the field\n        if ($this->_form)\n            $this->_form->addError($this->errors(), $this->get('id'));\n    }\n\n    function isValidEntry() {\n        $this->validateEntry();\n        return count($this->_errors) == 0;\n    }\n\n    /**\n     * validateEntry\n     *\n     * Validates user entry on an instance of the field on a dynamic form.\n     * This is called when an instance of this field (like a TextboxField)\n     * receives data from the user and that value should be validated.\n     *\n     * Parameters:\n     * $value - (string) input from the user\n     */\n    function validateEntry($value) {\n        if (!$value && count($this->_errors))\n            return;\n\n        # Validates a user-input into an instance of this field on a dynamic\n        # form\n        if ($this->get('required') && !$value && $this->hasData())\n            $this->_errors[] = $this->getLocal('label')\n                ? sprintf(__('%s is a required field'), $this->getLocal('label'))\n                : __('This is a required field');\n\n        # Perform declared validators for the field\n        if ($vs = $this->get('validators')) {\n            if (is_array($vs)) {\n                foreach ($vs as $validator)\n                    if (is_callable($validator))\n                        $validator($this, $value);\n            }\n            elseif (is_callable($vs))\n                $vs($this, $value);\n        }\n    }\n\n    /**\n     * isVisible\n     *\n     * If this field has visibility configuration, then it will parse the\n     * constraints with the visibility configuration to determine if the\n     * field is visible and should be considered for validation\n     */\n    function isVisible() {\n        if ($this->get('visibility') instanceof VisibilityConstraint) {\n            return $this->get('visibility')->isVisible($this);\n        }\n        return true;\n    }\n\n    /**\n     * Check if the user has edit rights\n     *\n     */\n\n    function isEditable($user=null) {\n\n        // Internal editable flag used by internal forms e.g internal lists\n        if (!$user && isset($this->ht['editable']))\n            return $this->ht['editable'];\n\n        if ($user instanceof Staff)\n            $flag = DynamicFormField::FLAG_AGENT_EDIT;\n        else\n            $flag = DynamicFormField::FLAG_CLIENT_EDIT;\n\n        return (($this->get('flags') & $flag) != 0);\n    }\n\n\n    /**\n     * isStorable\n     *\n     * Indicate if this field data is storable locally (default).Some field's data\n     * might beed to be stored elsewhere for optimization reasons at the\n     * application level.\n     *\n     */\n\n    function isStorable() {\n        return (($this->get('flags') & DynamicFormField::FLAG_EXT_STORED) == 0);\n    }\n\n    function isRequired() {\n        return $this->get('required');\n    }\n\n    /**\n     * parse\n     *\n     * Used to transform user-submitted data to a PHP value. This value is\n     * not yet considered valid. The ::validateEntry() method will be called\n     * on the value to determine if the entry is valid. Therefore, if the\n     * data is clearly invalid, return something like NULL that can easily\n     * be deemed invalid in ::validateEntry(), however, can still produce a\n     * useful error message indicating what is wrong with the input.\n     */\n    function parse($value) {\n        return is_string($value) ? trim($value) : $value;\n    }\n\n    /**\n     * to_php\n     *\n     * Transforms the data from the value stored in the database to a PHP\n     * value. The ::to_database() method is used to produce the database\n     * valse, so this method is the compliment to ::to_database().\n     *\n     * Parameters:\n     * $value - (string or null) database representation of the field's\n     *      content\n     */\n    function to_php($value) {\n        return $value;\n    }\n\n    /**\n     * to_config\n     *\n     * Transform the data from the value to config form (as determined by\n     * field). to_php is used for each field returned from\n     * ::getConfigurationOptions(), and when the whole configuration is\n     * built, to_config() is called and receives the config array. The array\n     * should be returned, perhaps with modifications, and will be JSON\n     * encoded and stashed in the database.\n     */\n    function to_config($value) {\n        return $value;\n    }\n\n    /**\n     * to_database\n     *\n     * Determines the value to be stored in the database. The database\n     * backend for all fields is a text field, so this method should return\n     * a text value or NULL to represent the value of the field. The\n     * ::to_php() method will convert this value back to PHP.\n     *\n     * Paremeters:\n     * $value - PHP value of the field's content\n     */\n    function to_database($value) {\n        return $value;\n    }\n\n    /**\n     * toString\n     *\n     * Converts the PHP value created in ::parse() or ::to_php() to a\n     * pretty-printed value to show to the user. This is especially useful\n     * for something like dates which are stored considerably different in\n     * the database from their respective human-friendly versions.\n     * Furthermore, this method allows for internationalization and\n     * localization.\n     *\n     * Parametes:\n     * $value - PHP value of the field's content\n     */\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function __toString() {\n        return $this->toString($this->value);\n    }\n\n    /**\n     * When data for this field is deleted permanently from some storage\n     * backend (like a database), other associated data may need to be\n     * cleaned as well. This hook allows fields to participate when the data\n     * for a field is cleaned up.\n     */\n    function db_cleanup($field=false) {\n    }\n\n    /**\n     * Returns an HTML friendly value for the data in the field.\n     */\n    function display($value) {\n        return Format::htmlchars($this->toString($value ?: $this->value));\n    }\n\n    /**\n     * Returns a value suitable for exporting to a foreign system. Mostly\n     * useful for things like dates and phone numbers which should be\n     * formatted using a standard when exported\n     */\n    function export($value) {\n        return $this->toString($value);\n    }\n\n    /**\n     * Fetch a value suitable for embedding the value of this field in an\n     * email template. Reference implementation uses ::to_php();\n     */\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    /**\n     * Fetch the var type used with the email templating system's typeahead\n     * feature. This helps with variable expansion if supported by this\n     * field's ::asVar() method. This method should return a valid classname\n     * which implements the `TemplateVariable` interface.\n     */\n    function asVarType() {\n        return false;\n    }\n\n    /**\n     * Describe the difference between the to two values. Note that the\n     * values should be passed through ::parse() or to_php() before\n     * utilizing this method.\n     */\n    function whatChanged($before, $after) {\n        if ($before)\n            $desc = __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>');\n        else\n            $desc = __('set to <strong>%2$s</strong>');\n        return sprintf($desc, $this->display($before), $this->display($after));\n    }\n\n    /**\n     * Convert the field data to something matchable by filtering. The\n     * primary use of this is for ticket filtering.\n     */\n    function getFilterData() {\n        return $this->toString($this->getClean());\n    }\n\n    /**\n     * Fetches a value that represents this content in a consistent,\n     * searchable format. This is used by the search engine system and\n     * backend.\n     */\n    function searchable($value) {\n        return Format::searchable($this->toString($value));\n    }\n\n    function getKeys($value) {\n        return $this->to_database($value);\n    }\n\n    /**\n     * Fetches a list of options for searching. The values returned from\n     * this method are passed to the widget's `::render()` method so that\n     * the widget can be affected by this setting. For instance, date fields\n     * might have a 'between' search option which should trigger rendering\n     * of two date widgets for search results.\n     */\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('is'),\n            'nequal' =>     __('is not'),\n            'contains' =>   __('contains'),\n            'match' =>      __('matches'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'equal' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'nequal' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'contains' => array('TextboxField', array('configuration' => array('size' => 40))),\n            'match' => array('TextboxField', array(\n                'placeholder' => __('Valid regular expression'),\n                'configuration' => array('size'=>30),\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' ')\n                        && false === @preg_match(\"/$v/\", ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n        );\n    }\n\n    /**\n     * This is used by the searching system to build a query for the search\n     * engine. The function should return a criteria listing to match\n     * content saved by the field by the `::to_database()` function.\n     */\n    function getSearchQ($method, $value, $name=false) {\n        $criteria = array();\n        $Q = new Q();\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n            case 'nset':\n                $Q->negate();\n            case 'set':\n                $criteria[$name . '__isnull'] = false;\n                break;\n\n            case 'nequal':\n                $Q->negate();\n            case 'equal':\n                $criteria[$name] = $value;\n                break;\n\n            case 'contains':\n                $criteria[$name . '__contains'] = $value;\n                break;\n\n            case 'match':\n                $criteria[$name . '__regex'] = $value;\n                break;\n        }\n        return $Q->add($criteria);\n    }\n\n    function getSearchWidget($method) {\n        $methods = $this->getSearchMethodWidgets();\n        $info = $methods[$method];\n        if (is_array($info)) {\n            $class = $info[0];\n            return new $class($info[1]);\n        }\n        return $info;\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'set':\n            return __('%s has a value');\n        case 'nset':\n            return __('%s does not have a value');\n        case 'equal':\n            return __('%s is %s' /* describes an equality */);\n        case 'nequal':\n            return __('%s is not %s' /* describes an inequality */);\n        case 'contains':\n            return __('%s contains \"%s\"');\n        case 'match':\n            return __('%s matches pattern %s');\n        case 'includes':\n            return __('%s in (%s)');\n        case '!includes':\n            return __('%s not in (%s)');\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $desc = $this->describeSearchMethod($method);\n        switch ($method) {\n            case 'set':\n            case 'nset':\n                return sprintf($desc, $name);\n            default:\n                 return sprintf($desc, $name, $this->toString($value));\n        }\n    }\n\n    function addToQuery($query, $name=false) {\n        return $query->values($name ?: $this->get('name'));\n    }\n\n    /**\n     * Similary to to_php() and parse(), except a row from a queryset is\n     * passed. The value returned should be what would be retured from\n     * parse() or to_php()\n     */\n    function from_query($row, $name=false) {\n        return $row[$name ?: $this->get('name')];\n    }\n\n    /**\n     * If the field can be used in a quick filter. To be used, it should\n     * also implement getQuickFilterChoices() which should return a list of\n     * choices to appear in a quick filter drop-down\n     */\n    function supportsQuickFilter() {\n        return false;\n    }\n\n    /**\n     * Fetch a keyed array of quick filter choices. The keys should be\n     * passed later to ::applyQuickFilter() to apply the quick filter to a\n     * query. The values should be localized titles for the choices.\n     */\n    function getQuickFilterChoices() {\n        return array();\n    }\n\n    /**\n     * Apply a quick filter selection of this field to the query. The\n     * modified query should be returned. Optionally, the orm path / field\n     * name can be passed.\n     */\n    function applyQuickFilter($query, $choice, $name=false) {\n        return $query;\n    }\n\n    function getLabel() { return $this->get('label'); }\n\n    function getSortKeys($path) {\n        return array($path);\n    }\n\n    function getOrmPath($name=false, $query=null) {\n        return CustomQueue::getOrmPath($name ?:$this->get('name'), $query);\n    }\n\n    function applyOrderBy($query, $reverse=false, $name=false) {\n        $col = sprintf('%s%s',\n                $reverse ? '-' : '',\n                $this->getOrmPath($name, $query));\n        return $query->order_by($col);\n    }\n\n    /**\n     * getImpl\n     *\n     * Magic method that will return an implementation instance of this\n     * field based on the simple text value of the 'type' value of this\n     * field instance. The list of registered fields is determined by the\n     * global get_dynamic_field_types() function. The data from this model\n     * will be used to initialize the returned instance.\n     *\n     * For instance, if the value of this field is 'text', a TextField\n     * instance will be returned.\n     */\n    function getImpl($parent=null) {\n        // Allow registration with ::addFieldTypes and delayed calling\n        $type = static::getFieldType($this->get('type'));\n        $clazz = $type[1];\n        $inst = new $clazz($this->ht);\n        $inst->parent = $parent;\n        $inst->setForm($this->_form);\n        return $inst;\n    }\n\n    function __call($what, $args) {\n        // XXX: Throw exception if $this->parent is not set\n        if (!$this->parent)\n            throw new Exception(sprintf(__('%s: Call to undefined function'),\n                $what));\n        // BEWARE: DynamicFormField has a __call() which will create a new\n        //      FormField instance and invoke __call() on it or bounce\n        //      immediately back\n        return call_user_func_array(\n            array($this->parent, $what), $args);\n    }\n\n    function getAnswer() { return $this->answer; }\n    function setAnswer($ans) { $this->answer = $ans; }\n\n    function setValue($value) {\n        $this->reset();\n        $this->getWidget()->value = $value;\n    }\n\n    /**\n     * Fetch a pseudo-random id for this form field. It is used when\n     * rendering the widget in the @name attribute emitted in the resulting\n     * HTML. The form element is based on the form id, field id and name,\n     * and the current user's session id. Therefore, the same form fields\n     * will yield differing names for different users. This is used to ward\n     * off bot attacks as it makes it very difficult to predict and\n     * correlate the form names to the data they represent.\n     */\n    function getFormName() {\n        $default = $this->get('name') ?: $this->get('id');\n        if ($this->_form && is_numeric($fid = $this->_form->getFormId()))\n            return substr(md5(\n                session_id() . \"-form-field-id-$fid-$default-\" . SECRET_SALT), -14);\n        elseif (is_numeric($this->get('id')))\n            return substr(md5(\n                session_id() . '-field-id-'.$this->get('id') . '-' . SECRET_SALT), -16);\n\n        return $default;\n    }\n\n    function getFormNames() {\n\n        // All possible names - this is important for inline data injection\n        $names = array_filter([\n                'hash' => $this->getFormName(),\n                'name' => $this->get('name'),\n                'id' => $this->get('id')]);\n\n        // Force pseudo-random name for Dynamicforms on POST (Web Tickets)\n        if (0 && $_POST\n                && !defined('APICALL')\n                && isset($this->ht['form'])\n                && ($this->ht['form'] instanceof DynamicForm))\n            return [$names['hash']];\n\n        return $names;\n    }\n\n    function setForm($form) {\n        $this->_form = $form;\n    }\n    function getForm() {\n        return $this->_form;\n    }\n    /**\n     * Returns the data source for this field. If created from a form, the\n     * data source from the form is returned. Otherwise, if the request is a\n     * POST, then _POST is returned.\n     */\n    function getSource() {\n        if ($this->_form)\n            return $this->_form->getSource();\n        elseif ($_SERVER['REQUEST_METHOD'] == 'POST')\n            return $_POST;\n        else\n            return array();\n    }\n\n    function render($options=array()) {\n        $rv = $this->getWidget()->render($options);\n        if ($v = $this->get('visibility')) {\n            $v->emitJavascript($this);\n        }\n        return $rv;\n    }\n\n    function renderExtras($options=array()) {\n        return;\n    }\n\n    function getMedia() {\n        $widget = $this->getWidget();\n        return $widget::$media;\n    }\n\n    function getConfigurationOptions() {\n        return array();\n    }\n\n    /**\n     * getConfiguration\n     *\n     * Loads configuration information from database into hashtable format.\n     * Also, the defaults from ::getConfigurationOptions() are integrated\n     * into the database-backed options, so that if options have not yet\n     * been set or a new option has been added and not saved for this field,\n     * the default value will be reflected in the returned configuration.\n     */\n    function getConfiguration() {\n        if (!isset($this->_config)) {\n            $this->_config = $this->get('configuration');\n            if (is_string($this->_config))\n                $this->_config = JsonDataParser::parse($this->_config);\n            elseif (!$this->_config)\n                $this->_config = array();\n            foreach ($this->getConfigurationOptions() as $name=>$field)\n                if (!isset($this->_config[$name]))\n                    $this->_config[$name] = $field->get('default');\n        }\n        return $this->_config;\n    }\n\n    /**\n     * If the [Config] button should be shown to allow for the configuration\n     * of this field\n     */\n    function isConfigurable() {\n        return true;\n    }\n\n    /**\n     * Field type is changeable in the admin interface\n     */\n    function isChangeable() {\n        return true;\n    }\n\n    /**\n     * Field does not contain data that should be saved to the database. Ie.\n     * non data fields like section headers\n     */\n    function hasData() {\n        return true;\n    }\n\n    /**\n     * Returns true if the field/widget should be rendered as an entire\n     * block in the target form.\n     */\n    function isBlockLevel() {\n        return false;\n    }\n\n    /**\n     * Fields should not be saved with the dynamic data. It is assumed that\n     * some static processing will store the data elsewhere.\n     */\n    function isPresentationOnly() {\n        return $this->presentation_only;\n    }\n\n    /**\n     * Indicates if the field places data in the `value_id` column. This\n     * is currently used by the materialized view system\n     */\n    function hasIdValue() {\n        return false;\n    }\n\n    /**\n     * Indicates if the field has subfields accessible via getSubFields()\n     * method. Useful for filter integration. Should connect with\n     * getFilterData()\n     */\n    function hasSubFields() {\n        return false;\n    }\n    function getSubFields() {\n        return null;\n    }\n\n    function getConfigurationForm($source=null) {\n        if (!$this->_cform) {\n            $type = static::getFieldType($this->get('type'));\n            $clazz = $type[1];\n            $T = new $clazz($this->ht);\n            $config = $this->getConfiguration();\n            $this->_cform = new SimpleForm($T->getConfigurationOptions(), $source);\n            if (!$source) {\n                foreach ($this->_cform->getFields() as $name=>$f) {\n                    if ($config && isset($config[$name]))\n                        $f->value = $config[$name];\n                    elseif ($f->get('default'))\n                        $f->value = $f->get('default');\n                }\n            }\n        }\n        return $this->_cform;\n    }\n\n    function configure($prop, $value) {\n        $this->getConfiguration();\n        $this->_config[$prop] = $value;\n    }\n\n    function getWidget($widgetClass=false) {\n        if (!static::$widget)\n            throw new Exception(__('Widget not defined for this field'));\n        if (!isset($this->_widget)) {\n            $wc = $widgetClass ?: $this->get('widget') ?: static::$widget;\n            $this->_widget = new $wc($this);\n            $this->_widget->parseValue();\n        }\n        return $this->_widget;\n    }\n\n    function getSelectName() {\n        $name = $this->get('name') ?: 'field_'.$this->get('id');\n        if ($this->hasIdValue())\n            $name .= '_id';\n\n        return $name;\n    }\n\n    function getTranslateTag($subtag) {\n        return _H(sprintf('field.%s.%s%s', $subtag, $this->get('id'),\n            $this->get('form_id') ? '' : '*internal*'));\n    }\n\n    function getLocal($subtag, $default=false) {\n        $tag = $this->getTranslateTag($subtag);\n        $T = CustomDataTranslation::translate($tag);\n        return $T != $tag ? $T : ($default ?: $this->get($subtag));\n    }\n\n    function getEditForm($source=null) {\n        $fields = array(\n                'field' => $this,\n                'comments' => new TextareaField(array(\n                        'id' => 2,\n                        'label'=> '',\n                        'required' => false,\n                        'default' => '',\n                        'configuration' => array(\n                            'html' => true,\n                            'size' => 'small',\n                            'placeholder' => __('Optional reason for the update'),\n                            )\n                        ))\n                );\n\n        return new SimpleForm($fields, $source);\n    }\n\n    function getChanges() {\n        $new = $this->getValue();\n        $old = $this->answer ? $this->answer->getValue() : $this->get('default');\n        return ($old != $new) ? array($this->to_database($old), $this->to_database($new)) : false;\n    }\n\n\n    function save() {\n\n        if (!($changes=$this->getChanges()))\n            return true;\n\n        if (!($a = $this->answer))\n            return false;\n\n        $val = $changes[1];\n        if (is_array($val)) {\n            $a->set('value', $val[0]);\n            $a->set('value_id', $val[1]);\n        } else {\n            $a->set('value', $val);\n        }\n\n        if (!$a->save(true))\n            return false;\n\n        $this->_clean = $this->_widget = null;\n        return $this->parent->save();\n    }\n\n\n    static function init($config) {\n        return new Static($config);\n    }\n}\n\nclass TextboxField extends FormField {\n    static $widget = 'TextboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'size'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Size'), 'required'=>false, 'default'=>16,\n                    'validator' => 'number')),\n            'length' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Max Length'), 'required'=>false, 'default'=>30,\n                    'validator' => 'number')),\n            'validator' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Validator'), 'required'=>false, 'default'=>'',\n                'choices' => array('phone'=>__('Phone Number'),'email'=>__('Email Address'),\n                    'ip'=>__('IP Address'), 'number'=>__('Number'),\n                    'regex'=>__('Custom (Regular Expression)'), ''=>__('None')))),\n            'regex' => new TextboxField(array(\n                'id'=>6, 'label'=>__('Regular Expression'), 'required'=>true,\n                'configuration'=>array('size'=>40, 'length'=>100),\n                'visibility' => new VisibilityConstraint(\n                    new Q(array('validator__eq'=>'regex')),\n                    VisibilityConstraint::HIDDEN\n                ),\n                'cleaners' => function ($self, $value) {\n                    $wrapped = \"/\".$value.\"/iu\";\n                    if (false === @preg_match($value, ' ')\n                            && false !== @preg_match($wrapped, ' ')) {\n                        $value = $wrapped;\n                    }\n                    if ($value == '//iu')\n                        return '';\n\n                    return $value;\n                },\n                'validators' => function($self, $v) {\n                    if (false === @preg_match($v, ' '))\n                        $self->addError(__('Cannot compile this regular expression'));\n                })),\n            'validator-error' => new TextboxField(array(\n                'id'=>4, 'label'=>__('Validation Error'), 'default'=>'',\n                'configuration'=>array('size'=>40, 'length'=>60,\n                    'translatable'=>$this->getTranslateTag('validator-error')\n                ),\n                'hint'=>__('Message shown to user if the input does not match the validator'))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')\n                ),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        //check to see if value is the string '0'\n        $value = ($value === '0') ? '&#48' : Format::htmlchars($this->toString($value ?: $this->value));\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' => '',\n            'noop' => array(\n                function($a, &$b) { return true; }\n            ),\n            'formula' => array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n            'email' =>  array(array('Validator', 'is_valid_email'),\n                __('Enter a valid email address')),\n            'phone' =>  array(array('Validator', 'is_phone'),\n                __('Enter a valid phone number')),\n            'ip' =>     array(array('Validator', 'is_ip'),\n                __('Enter a valid IP address')),\n            'number' => array(array('Validator', 'is_numeric'),\n                __('Enter a number')),\n            'password' => array(array('Validator', 'check_passwd'),\n                __('Invalid Password')),\n            'regex' => array(\n                function($v) use ($config) {\n                    $regex = $config['regex'];\n                    return @preg_match($regex, $v);\n                }, __('Value does not match required pattern')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        $valid = $this->get('validator');\n        if (!$valid) {\n            $valid = $config['validator'];\n        }\n        if (!$value || !isset($validators[$valid]))\n            return;\n        // If no validators are set and not an instanceof AdvancedSearchForm\n        // force formula validation\n        if (!$valid && !($this->getForm() instanceof AdvancedSearchForm))\n            $valid = 'formula';\n        $func = $validators[$valid];\n        $error = $err = null;\n        // If validator is number and the value is &#48 set to 0 (int) for is_numeric\n        if ($valid == 'number' && $value == '&#48')\n            $value = 0;\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func_array($func[0], array($value, &$err)))\n                $this->_errors[] =  $error ?: $err ?: $func[1];\n    }\n\n    function parse($value) {\n        return Format::strip_emoticons(Format::striptags($value));\n    }\n\n    function display($value) {\n        return ($value === '0') ? '&#48;' : Format::htmlchars($this->toString($value ?: $this->value), true);\n    }\n}\n\nclass PasswordField extends TextboxField {\n    static $widget = 'PasswordWidget';\n\n    function __construct($options=array()) {\n        parent::__construct($options);\n        if (!isset($options['validator']))\n            $this->set('validator', 'password');\n    }\n\n    function parse($value) {\n        // Don't trim the value\n        return $value;\n    }\n\n    function to_database($value) {\n        // If not set in UI, don't save the empty value\n        if (!$value)\n            throw new FieldUnchanged();\n        return Crypto::encrypt($value, SECRET_SALT, 'pwfield');\n    }\n\n    function to_php($value) {\n        return Crypto::decrypt($value, SECRET_SALT, 'pwfield');\n    }\n}\n\nclass TextareaField extends FormField {\n    static $widget = 'TextareaWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'cols'  =>  new TextboxField(array(\n                'id'=>1, 'label'=>__('Width').' '.__('(chars)'), 'required'=>true, 'default'=>40)),\n            'rows'  =>  new TextboxField(array(\n                'id'=>2, 'label'=>__('Height').' '.__('(rows)'), 'required'=>false, 'default'=>4)),\n            'length' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Max Length'), 'required'=>false, 'default'=>0)),\n            'html' => new BooleanField(array(\n                'id'=>4, 'label'=>__('HTML'), 'required'=>false, 'default'=>true,\n                'configuration'=>array('desc'=>__('Allow HTML input in this box')))),\n            'placeholder' => new TextboxField(array(\n                'id'=>5, 'label'=>__('Placeholder'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown in before any input from the user'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('placeholder')),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        if (!$value)\n            return;\n        $config = $this->getConfiguration();\n        $validators = array(\n            '' =>       array(array('Validator', 'is_formula'),\n                __('Content cannot start with the following characters: = - + @')),\n            'choices' => array(\n                function($val) {\n                    $val = str_replace('\"', '', JsonDataEncoder::encode($val));\n                    $regex = \"/^(?! )[A-z0-9 _-]+:{1}[^\\n]+$/\";\n                    foreach (explode('\\r\\n', $val) as $v) {\n                        if (!preg_match($regex, $v))\n                            return false;\n                    }\n                    return true;\n                }, __('Each choice requires a key and has to be on a new line. (eg. key:value)')\n            ),\n        );\n        // Support configuration forms, as well as GUI-based form fields\n        if (!($valid = $this->get('validator')) && isset($config['validator']))\n            $valid = $config['validator'];\n\n        if (!isset($validators[$valid]))\n            return;\n\n        $func = $validators[$valid];\n        $error = $func[1];\n        if ($config['validator-error'])\n            $error = $this->getLocal('validator-error', $config['validator-error']);\n        if (is_array($func) && is_callable($func[0]))\n            if (!call_user_func($func[0], $value))\n                $this->_errors[] = $error;\n    }\n\n    function display($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::safe_html($value);\n        else\n            return nl2br(Format::htmlchars($value, true));\n    }\n\n    function searchable($value) {\n        $body = new HtmlThreadEntryBody($value);\n        return $body->getSearchable();\n    }\n\n    function export($value) {\n        return (!$value) ? $value : Format::html2text($value);\n    }\n\n    function parse($value) {\n        $config = $this->getConfiguration();\n        if ($config['html'])\n            return Format::sanitize($value);\n        else\n            return $value;\n    }\n\n}\n\nclass PhoneField extends FormField {\n    static $widget = 'PhoneNumberWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'ext' => new BooleanField(array(\n                'label'=>__('Extension'), 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add a separate field for the extension'),\n                ),\n            )),\n            'digits' => new TextboxField(array(\n                'label'=>__('Minimum length'), 'default'=>7,\n                'hint'=>__('Fewest digits allowed in a valid phone number'),\n                'configuration'=>array('validator'=>'number', 'size'=>5),\n            )),\n            'format' => new ChoiceField(array(\n                'label'=>__('Display format'), 'default'=>'us',\n                'choices'=>array(''=>'-- '.__('Unformatted').' --',\n                    'us'=>__('United States')),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        parent::validateEntry($value);\n        $config = $this->getConfiguration();\n        # Run validator against $this->value for email type\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        if ($phone && (\n                !is_numeric($phone) ||\n                strlen($phone) < $config['digits']))\n            $this->_errors[] = __(\"Enter a valid phone number\");\n        if ($ext && $config['ext']) {\n            if (!is_numeric($ext))\n                $this->_errors[] = __(\"Enter a valid phone extension\");\n            elseif (!$phone)\n                $this->_errors[] = __(\"Enter a phone number for the extension\");\n        }\n    }\n\n    function parse($value) {\n        // NOTE: Value may have a legitimate 'X' to separate the number and\n        // extension parts. Don't remove the 'X'\n        $val = preg_replace('/[^\\dX]/', '', $value);\n        // Pass completely-incorrect string for validation error\n        return $val ?: $value;\n    }\n\n    function toString($value) {\n        $config = $this->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $value, 2);\n        switch ($config['format']) {\n        case 'us':\n            $phone = Format::phone($phone);\n            break;\n        }\n        if ($ext)\n            $phone.=\" x$ext\";\n        return $phone;\n    }\n}\n\nclass BooleanField extends FormField {\n    static $widget = 'CheckboxWidget';\n\n    function getConfigurationOptions() {\n        return array(\n            'desc' => new TextareaField(array(\n                'id'=>1, 'label'=>__('Description'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Text shown inline with the widget'),\n                'configuration'=>array('rows'=>2)))\n        );\n    }\n\n    function to_database($value) {\n        return ($value) ? '1' : '0';\n    }\n\n    function parse($value) {\n        return $this->to_php($value);\n    }\n    function to_php($value) {\n        return $value ? true : false;\n    }\n\n    function toString($value) {\n        return ($value) ? __('Yes') : __('No');\n    }\n\n    function getClean($validate=true) {\n        if (!isset($this->_clean)) {\n            $this->_clean = (isset($this->value))\n                ? $this->value : $this->getValue();\n\n            if ($this->isVisible() && $validate)\n                $this->validateEntry($this->_clean);\n        }\n        return $this->_clean;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('checked'),\n            'nset' =>    __('unchecked'),\n        );\n    }\n\n    function describeSearchMethod($method) {\n\n        $methods = $this->get('descsearchmethods');\n        if (isset($methods[$method]))\n            return $methods[$method];\n\n        return parent::describeSearchMethod($method);\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        switch ($method) {\n        case 'set':\n            return new Q(array($name => '1'));\n        case 'nset':\n            return new Q(array($name => '0'));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return array(\n            true => __('Checked'),\n            false => __('Not Checked'),\n        );\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        return $query->filter(array(\n            $name ?: $this->get('name') => (int) $qf_value,\n        ));\n    }\n}\n\nclass ChoiceField extends FormField {\n    static $widget = 'ChoicesWidget';\n    var $_choices;\n\n    function getConfigurationOptions() {\n        return array(\n            'choices'  =>  new TextareaField(array(\n                'id'=>1, 'label'=>__('Choices'), 'required'=>false, 'default'=>'',\n                'hint'=>__('List choices, one per line. To protect against spelling changes, specify key:value names to preserve entries if the list item names change.</br><b>Note:</b> If you have more than two choices, use a List instead.'),\n                'validator'=>'choices',\n                'configuration'=>array('html'=>false)\n            )),\n            'default' => new TextboxField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'hint'=>__('(Enter a key). Value selected from the list initially'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40,\n                    'translatable'=>$this->getTranslateTag('prompt'),\n                ),\n            )),\n            'multiselect' => new BooleanField(array(\n                'id'=>1, 'label'=>'Multiselect', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>'Allow multiple selections')\n            )),\n        );\n    }\n\n    function parse($value) {\n        return $this->to_php($value ?: null);\n    }\n\n    function to_database($value) {\n        if (!is_array($value)) {\n            $choices = $this->getChoices();\n            if (isset($choices[$value]))\n                $value = array($value => $choices[$value]);\n        }\n        if (is_array($value))\n            $value = JsonDataEncoder::encode($value);\n\n        return $value;\n    }\n\n    function to_php($value) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        // CDATA table may be built with comma-separated key,value,key,value\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            $choices = $this->getChoices();\n            $vals = array_map('trim', explode(',', $value));\n            foreach ($vals as $V) {\n                if (isset($choices[$V]))\n                    $values[$V] = $choices[$V];\n            }\n            if (array_filter($values))\n                $value = $values;\n            elseif($vals)\n                list($value) = $vals;\n\n        }\n        $config = $this->getConfiguration();\n        if (!$config['multiselect'] && is_array($value) && count($value) < 2) {\n            reset($value);\n            $value = key($value);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getKeys($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', array_keys($value));\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $value = $this->to_php($value);\n        return $this->toString($this->getChoice($value));\n    }\n\n    function getChanges() {\n        $new = $this->to_database($this->getValue());\n        $old = $this->to_database($this->answer ? $this->answer->getValue()\n                : $this->get('default'));\n        // Compare old and new\n        return ($old == $new)\n            ? false\n            : array($old, $new);\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = array_map(array($this, 'display'), $added);\n        $deleted = array_map(array($this, 'display'), $deleted);\n        $added = array_filter($added);\n        $deleted = array_filter($deleted);\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n\n    /*\n     Return criteria to which the choice should be filtered by\n     */\n    function getCriteria() {\n        $config = $this->getConfiguration();\n        $criteria = array();\n        if (isset($config['criteria']))\n            $criteria = $config['criteria'];\n\n        return $criteria;\n    }\n\n    function getChoice($value) {\n\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value]))\n            $selection[$value] = $choices[$value];\n        elseif (($v=$this->get('default')) && isset($choices[$v]))\n            $selection[$v] = $choices[$v];\n\n        return $selection;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if ($this->_choices === null || $verbose) {\n            // Allow choices to be set in this->ht (for configurationOptions)\n            $this->_choices = $this->get('choices');\n            if (!$this->_choices) {\n                $this->_choices = array();\n                $config = $this->getConfiguration();\n                $choices = explode(\"\\n\", $config['choices']);\n                foreach ($choices as $choice) {\n                    // Allow choices to be key: value\n                    list($key, $val) = explode(':', $choice, 2);\n                    if ($val == null)\n                        $val = $key;\n                    $this->_choices[trim($key)] = trim($val);\n                }\n                // Add old selections if nolonger available\n                // This is necessary so choices made previously can be\n                // retained\n                $values = ($a=$this->getAnswer()) ? $a->getValue() : array();\n                if ($values && is_array($values)) {\n                    foreach ($values as $k => $v) {\n                        if (!isset($this->_choices[$k])) {\n                            if ($verbose) $v .= ' (retired)';\n                            $this->_choices[$k] = $v;\n                        }\n                    }\n                }\n            }\n        }\n        return $this->_choices;\n    }\n\n    function lookupChoice($value) {\n        return null;\n    }\n\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>     __('does not have a value'),\n            'includes' =>   __('includes'),\n            '!includes' =>  __('does not include'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'set' => null,\n            'nset' => null,\n            'includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n            '!includes' => array('ChoiceField', array(\n                'choices' => $this->getChoices(),\n                'configuration' => array('multiselect' => true),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $val = $value;\n        if ($value && is_array($value))\n            $val = '\"?'.implode('(\"|,|$)|\"?', array_keys($value)).'(\"|,|$)';\n        switch ($method) {\n        case '!includes':\n            return Q::not(array(\"{$name}__regex\" => $val));\n        case 'includes':\n            return new Q(array(\"{$name}__regex\" => $val));\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'includes':\n            return __('%s includes %s' /* includes -> if a list includes a selection */);\n        case '!includes':\n            return __('%s does not include %s' /* includes -> if a list includes a selection */);\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return $this->getChoices();\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        global $thisstaff;\n\n        $field = new AssigneeChoiceField();\n        //special assignment quick filters\n        switch (true) {\n            case ($qf_value == 'assigned'):\n            case ($qf_value == '!assigned'):\n                $result = $field->getSearchQ($qf_value, $qf_value);\n                return $query->filter($result);\n            case (strpos($qf_value, 's') !== false):\n            case (strpos($qf_value, 't') !== false):\n            case ($qf_value == 'M'):\n            case ($qf_value == 'T'):\n                $value = array($qf_value => $qf_value);\n                $result = $field->getSearchQ('includes', $value);\n                return $query->filter($result);\n                break;\n        }\n\n        return $query->filter(array(\n            $name ?: $this->get('name') => $qf_value,\n        ));\n    }\n}\n\nclass NumericField extends FormField {\n\n    function getSearchMethods() {\n        return array(\n            'equal' =>   __('Equal'),\n            'greater' =>  __('Greater Than'),\n            'less' =>  __('Less Than'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        return array(\n            'equal' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n            'greater' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n            'less' => array('TextboxField', array(\n                    'configuration' => array(\n                        'validator' => 'number',\n                        'size' => 6\n                        ),\n            )),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        switch ($method) {\n        case 'equal':\n            return new Q(array(\n                \"{$name}__exact\" => intval($value)\n            ));\n        break;\n        case 'greater':\n            return Q::any(array(\n                \"{$name}__gt\" => intval($value)\n            ));\n        break;\n        case 'less':\n            return Q::any(array(\n                \"{$name}__lt\" => intval($value)\n            ));\n        break;\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n}\n\nclass DatetimeField extends FormField {\n    static $widget = 'DatetimePickerWidget';\n\n    var $min = null;\n    var $max = null;\n\n    static function intervals($count=2, $i='') {\n        $intervals = array(\n            'i' => _N('minute', 'minutes', $count),\n            'h' => _N('hour', 'hours', $count),\n            'd' => _N('day','days', $count),\n            'w' => _N('week', 'weeks', $count),\n            'm' => _N('month', 'months', $count),\n        );\n        return $i ? $intervals[$i] : $intervals;\n    }\n\n    static function periods($period='') {\n        $periods = array(\n                'td' => __('Today'),\n                'yd' => __('Yesterday'),\n                'tw' => __('This Week'),\n                'tm' => __('This Month'),\n                'tq' => __('This Quarter'),\n                'ty' => __('This Year'),\n                'lw' => __('Last Week'),\n                'lm' => __('Last Month'),\n                'lq' => __('Last Quarter'),\n                'ly' => __('Last Year'),\n        );\n        return $period ? $periods[$period] : $periods;\n    }\n\n    // Get php DatateTime object of the field  - null if value is empty\n    function getDateTime($value=null) {\n        return Format::parseDateTime($value ?: $this->value);\n    }\n\n    // Get effective timezone for the field\n    function getTimeZone() {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        $timezone = new DateTimeZone($config['timezone'] ?:\n                $cfg->getTimezone());\n\n        return $timezone;\n    }\n\n    function getMinDateTime() {\n\n        if (!isset($this->min)) {\n            $config = $this->getConfiguration();\n            $this->min = $config['min']\n                ? Format::parseDateTime($config['min']) : false;\n        }\n\n        return $this->min;\n    }\n\n    function getMaxDateTime() {\n\n        if (!isset($this->max)) {\n            $config = $this->getConfiguration();\n            $this->max = $config['max']\n                ? Format::parseDateTime($config['max']) : false;\n        }\n\n        return $this->max;\n    }\n\n    static function getPastPresentLabels() {\n      return array(__('Create Date'), __('Reopen Date'),\n                    __('Close Date'), __('Last Update'));\n    }\n\n    function to_database($value) {\n        // Store time in format given by Date Picker (DateTime::W3C)\n        return $value;\n    }\n\n    function to_php($value) {\n\n        if (!is_numeric($value) && strtotime($value) <= 0)\n            return 0;\n\n        return $value;\n    }\n\n    function display($value) {\n        global $cfg;\n\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return '';\n\n        $config = $this->getConfiguration();\n        $format = $config['format'] ?: false;\n        if ($config['gmt'])\n            return $this->format((int) $datetime->format('U'), $format);\n\n        // Force timezone if field has one.\n        if ($config['timezone']) {\n            $timezone = new DateTimezone($config['timezone']);\n            $datetime->setTimezone($timezone);\n        }\n\n        $value = $this->format($datetime->format('U'),\n                $datetime->getTimezone()->getName(),\n                $format);\n        // No need to show timezone\n        if (!$config['time'] || $format)\n            return $value;\n\n        // Display is NOT timezone aware show entry's timezone.\n        return sprintf('%s (%s)',\n                $value, $datetime->format('T'));\n    }\n\n    function from_query($row, $name=false) {\n        $value = parent::from_query($row, $name);\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        return ($timestamp > 0) ? $timestamp : '';\n    }\n\n    function format($timestamp, $timezone=false, $format=false) {\n\n        if (!$timestamp || $timestamp <= 0)\n            return '';\n\n        $config = $this->getConfiguration();\n        if ($config['time'])\n            $formatted = Format::datetime($timestamp, false, $format,  $timezone);\n        else\n            $formatted = Format::date($timestamp, false, $format, $timezone);\n\n        return $formatted;\n    }\n\n    function toString($value) {\n        if (is_array($value))\n            return '';\n\n        $timestamp = is_int($value) ? $value : (int) strtotime($value);\n        if ($timestamp <= 0)\n            return '';\n\n        return $this->format($timestamp);\n    }\n\n    function asVar($value, $id=false) {\n        global $cfg;\n\n        if (!$value)\n            return null;\n\n        $datetime = $this->getDateTime($value);\n        $config = $this->getConfiguration();\n        if (!$config['gmt'] || !$config['time'])\n            $timezone  = $datetime->getTimezone()->getName();\n        else\n            $timezone  = false;\n\n        return  new FormattedDate($value, array(\n                    'timezone'  =>  $timezone,\n                    'format'    =>  $config['time'] ? 'long' : 'short'\n                    )\n                );\n    }\n\n    function asVarType() {\n        return 'FormattedDate';\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'time' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Time'), 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc'=>__('Show time selection with date picker')))),\n            'timezone' => new TimezoneField(array(\n                'id'=>2, 'label'=>__('Timezone'), 'required'=>false,\n                'hint'=>__('Timezone of the date time selection'),\n                'configuration' => array('autodetect'=>false,\n                    'prompt' => __(\"User's timezone\")),\n               'visibility' => new VisibilityConstraint(\n                    new Q(array('time__eq'=> true)),\n                    VisibilityConstraint::HIDDEN\n                ),\n                )),\n            'gmt' => new BooleanField(array(\n                'id'=>3, 'label'=>__('Timezone Aware'), 'required'=>false,\n                'configuration'=>array(\n                    'desc'=>__(\"Show date/time relative to user's timezone\")))),\n            'min' => new DatetimeField(array(\n                'id'=>4, 'label'=>__('Earliest'), 'required'=>false,\n                'hint'=>__('Earliest date selectable'))),\n            'max' => new DatetimeField(array(\n                'id'=>5, 'label'=>__('Latest'), 'required'=>false,\n                'default'=>null, 'hint'=>__('Latest date selectable'))),\n            'future' => new BooleanField(array(\n                'id'=>6, 'label'=>__('Allow Future Dates'), 'required'=>false,\n                'default'=>true, 'configuration'=>array(\n                    'desc'=>__('Allow entries into the future' /* Used in the date field */)),\n            )),\n        );\n    }\n\n    function validateEntry($value) {\n        global $cfg;\n\n        $config = $this->getConfiguration();\n        parent::validateEntry($value);\n        if (!$value || !($datetime = Format::parseDateTime($value)))\n            return;\n\n        // Get configured min/max (if any)\n        $min = $this->getMinDateTime();\n        $max = $this->getMaxDateTime();\n\n        if (!$datetime) {\n            $this->_errors[] = __('Enter a valid date');\n        } elseif ($min and $datetime < $min) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is earlier than permitted'),\n                     Format::date($min->getTimestamp(), false, false,\n                         $min->getTimezone()->getName() ?: 'UTC')\n                     );\n        } elseif ($max and $datetime > $max) {\n            $this->_errors[] = sprintf('%s (%s)',\n                    __('Selected date is later than permitted'),\n                    Format::date($max->getTimestamp(), false, false,\n                        $max->getTimezone()->getName() ?: 'UTC')\n                    );\n        }\n    }\n\n    // SearchableField interface ------------------------------\n    function getSearchMethods() {\n        return array(\n            'set' =>        __('has a value'),\n            'nset' =>       __('does not have a value'),\n            'equal' =>      __('on'),\n            'nequal' =>     __('not on'),\n            'before' =>     __('before'),\n            'after' =>      __('after'),\n            'between' =>    __('between'),\n            'period' =>     __('period'),\n            'ndaysago' =>   __('in the last n days'),\n            'ndays' =>      __('in the next n days'),\n            'future' =>     __('in the future'),\n            'past' =>       __('in the past'),\n            'distfut' =>    __('more than n days from now'),\n            'distpast' =>   __('more than n days ago'),\n        );\n    }\n\n    function getSearchMethodWidgets() {\n        $config_notime = $config = $this->getConfiguration();\n        $config_notime['time'] = false;\n        $nday_form = function($x=5) {\n            return array(\n                'until' => new TextboxField(array(\n                    'configuration' => array('validator'=>'number', 'size'=>4))\n                ),\n                'int' => new ChoiceField(array(\n                    'default' => 'd',\n                    'choices' => self::intervals($x),\n                )),\n            );\n        };\n        return array(\n            'set' => null,\n            'nset' => null,\n            'past' => null,\n            'future' => null,\n            'equal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'nequal' => array('DatetimeField', array(\n                'configuration' => $config_notime,\n            )),\n            'before' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'after' => array('DatetimeField', array(\n                'configuration' => $config,\n            )),\n            'between' => array('InlineformField', array(\n                'form' => array(\n                    'left' => new DatetimeField($config + array('required' => true)),\n                    'text' => new FreeTextField(array(\n                        'configuration' => array('content' => __('and')))\n                    ),\n                    'right' => new DatetimeField($config + array('required' => true)),\n                ),\n                'configuration' => array(\n                    'error' => '',\n                ),\n            )),\n            'period' => array('ChoiceField', array(\n                'choices' => self::periods(),\n            )),\n            'ndaysago' => array('InlineformField', array('form'=>$nday_form())),\n            'ndays' => array('InlineformField', array('form'=>$nday_form())),\n            'distfut' => array('InlineformField', array('form'=>$nday_form())),\n            'distpast' => array('InlineformField', array('form'=>$nday_form())),\n        );\n    }\n\n    function getSearchQ($method, $value, $name=false) {\n        global $cfg;\n\n        static $intervals = array(\n            'm' => 'MONTH',\n            'w' => 'WEEK',\n            'd' => 'DAY',\n            'h' => 'HOUR',\n            'i' => 'MINUTE',\n        );\n        $name = $name ?: $this->get('name');\n        $now = SqlFunction::NOW();\n        $config = $this->getConfiguration();\n       if (is_int($value))\n          $value = DateTime::createFromFormat('U', !$config['gmt'] ? Misc::gmtime($value) : $value) ?: $value;\n       elseif (is_string($value) && strlen($value) > 2)\n           $value = Format::parseDateTime($value) ?: $value;\n\n        switch ($method) {\n        case 'equal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return new Q(array(\n                \"{$name}__gte\" => $l,\n                \"{$name}__lt\" => $r\n            ));\n        case 'nequal':\n            $l = clone $value;\n            $r = $value->add(new DateInterval('P1D'));\n            return Q::any(array(\n                \"{$name}__lt\" => $l,\n                \"{$name}__gte\" => $r,\n            ));\n        case 'future':\n            $value = $now;\n        case 'after':\n            return new Q(array(\"{$name}__gte\" => $value));\n        case 'past':\n            $value = $now;\n        case 'before':\n            return new Q(array(\"{$name}__lt\" => $value));\n        case 'between':\n            $left = Format::parseDateTime($value['left']);\n            $right = Format::parseDateTime($value['right']);\n            if (!$left || !$right)\n                return null;\n\n            // TODO: allow time selection for between\n            $left = $left->setTime(00, 00, 00);\n            $right = $right->setTime(23, 59, 59);\n            // Convert time to db timezone\n            $dbtz = new DateTimeZone($cfg->getDbTimezone());\n            $left->setTimezone($dbtz);\n            $right->setTimezone($dbtz);\n            return new Q(array(\n                \"{$name}__gte\" =>  $left->format('Y-m-d H:i:s'),\n                \"{$name}__lte\" =>  $right->format('Y-m-d H:i:s'),\n            ));\n        case 'ndaysago':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__range\" => array($now->minus($interval), $now),\n            ));\n        case 'ndays':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__range\" => array($now, $now->plus($interval)),\n            ));\n        // Distant past and future ranges\n        case 'distpast':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__lte\" => $now->minus($interval),\n            ));\n        case 'distfut':\n            $int = $intervals[$value['int'] ?: 'd'] ?: 'DAY';\n            $interval = new SqlInterval($int, $value['until']);\n            return new Q(array(\n                \"{$name}__gte\" => $now->plus($interval),\n            ));\n        case 'period':\n            // User's effective timezone\n            $tz = new DateTimeZone($cfg->getTimezone());\n            // Get the period range boundaries in user's tz\n            $period = Misc::date_range($value, Misc::gmtime('now'), $tz);\n            // Convert boundaries to db time\n            $dbtz = new DateTimeZone($cfg->getDbTimezone());\n            $start = $period->start->setTimezone($dbtz);\n            $end = $period->end->setTimezone($dbtz);\n            // Set the range\n            return new Q(array(\n                \"{$name}__range\" => array(\n                    $start->format('Y-m-d H:i:s'),\n                    $end->format('Y-m-d H:i:s')\n                    )\n                ));\n            break;\n        default:\n            return parent::getSearchQ($method, $value, $name);\n        }\n    }\n\n    function describeSearchMethod($method) {\n        switch ($method) {\n        case 'before':\n            return __('%1$s before %2$s' /* occurs before a date and time */);\n        case 'after':\n            return __('%1$s after %2$s' /* occurs after a date and time */);\n        case 'ndays':\n            return __('%1$s in the next %2$s' /* occurs within a window (like 3 days) */);\n        case 'ndaysago':\n            return __('%1$s in the last %2$s' /* occurs within a recent window (like 3 days) */);\n        case 'distfut':\n            return __('%1$s after %2$s from now' /* occurs after a window (like 3 days) */);\n        case 'distpast':\n            return __('%1$s before %2$s ago' /* occurs previous to a window (like 3 days) */);\n        case 'between':\n            return __('%1$s between %2$s and %3$s');\n        case 'future':\n            return __('%1$s is in the future');\n        case 'past':\n            return __('%1$s is in the past');\n        case 'period':\n            return __('%1$s is %2$s');\n        default:\n            return parent::describeSearchMethod($method);\n        }\n    }\n\n    function describeSearch($method, $value, $name=false) {\n\n        $name = $name ?: $this->get('name');\n        $desc = $this->describeSearchMethod($method);\n        switch ($method) {\n            case 'between':\n                return sprintf($desc, $name,\n                        $this->toString($value['left']),\n                        $this->toString($value['right']));\n            case 'ndays':\n            case 'ndaysago':\n            case 'distfut':\n            case 'distpast':\n                $interval = sprintf('%s %s', $value['until'],\n                        self::intervals($value['until'], $value['int']));\n                return sprintf($desc, $name, $interval);\n                break;\n            case 'future':\n            case 'past':\n                return sprintf($desc, $name);\n            case 'before':\n            case 'after':\n                return sprintf($desc, $name, $this->toString($value));\n            case 'period':\n                return sprintf($desc, $name, self::periods($value) ?: $value);\n            default:\n                return parent::describeSearch($method, $value, $name);\n        }\n    }\n\n    function supportsQuickFilter() {\n        return true;\n    }\n\n    function getQuickFilterChoices() {\n        return array(\n            'h' => __('Today'),\n            'm' => __('Tomorrow'),\n            'g' => __('Yesterday'),\n            'l7' => __('Last 7 days'),\n            'l30' => __('Last 30 days'),\n            'n7' => __('Next 7 days'),\n            'n30' => __('Next 30 days'),\n            /* Ugh. These boundaries are so difficult in SQL\n            'w' =>  __('This Week'),\n            'm' =>  __('This Month'),\n            'lw' => __('Last Week'),\n            'lm' => __('Last Month'),\n            'nw' => __('Next Week'),\n            'nm' => __('Next Month'),\n            */\n        );\n    }\n\n    function applyQuickFilter($query, $qf_value, $name=false) {\n        $name = $name ?: $this->get('name');\n        $now = SqlFunction::NOW();\n        $midnight = Misc::dbtime(time() - (time() % 86400));\n        switch ($qf_value) {\n        case 'l7':\n            return $query->filter([\n                \"{$name}__range\" => array($now->minus(SqlInterval::DAY(7)), $now),\n            ]);\n        case 'l30':\n            return $query->filter([\n                \"{$name}__range\" => array($now->minus(SqlInterval::DAY(30)), $now),\n            ]);\n        case 'n7':\n            return $query->filter([\n                \"{$name}__range\" => array($now, $now->plus(SqlInterval::DAY(7))),\n            ]);\n        case 'n30':\n            return $query->filter([\n                \"{$name}__range\" => array($now, $now->plus(SqlInterval::DAY(30))),\n            ]);\n        case 'g':\n            $midnight -= 86400;\n             // Fall through to the today case\n        case 'm':\n            if ($qf_value === 'm') $midnight += 86400;\n             // Fall through to the today case\n        case 'h':\n            $midnight = DateTime::createFromFormat('U', $midnight);\n            return $query->filter([\n                \"{$name}__range\" => array($midnight,\n                    SqlExpression::plus($midnight, SqlInterval::DAY(1))),\n            ]);\n        }\n    }\n}\n\n\n/**\n * TimeField for time selection\n *\n */\nclass TimeField extends FormField {\n    static $widget = 'TimePickerWidget';\n\n    var $start = null;\n    var $end = null;\n\n    function getTimeZone() {\n        global $cfg;\n        $config = $this->getConfiguration();\n        return new DateTimeZone($config['timezone'] ?: $cfg->getTimezone());\n    }\n}\n\n/**\n * This is kind-of a special field that doesn't have any data. It's used as\n * a field to provide a horizontal section break in the display of a form\n */\nclass SectionBreakField extends FormField {\n    static $widget = 'SectionBreakWidget';\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    function isEditableToStaff() {\n        return $this->isVisibleToStaff();\n    }\n\n    function isEditableToUsers() {\n        return $this->isVisibleToUsers();\n    }\n}\n\nclass ThreadEntryField extends FormField {\n    static $widget = 'ThreadEntryWidget';\n\n    function isChangeable() {\n        return false;\n    }\n    function isBlockLevel() {\n        return true;\n    }\n    function isPresentationOnly() {\n        return true;\n    }\n    function getMedia() {\n        $config = $this->getConfiguration();\n        $media = parent::getMedia() ?: array();\n        if ($config['attachments'])\n            $media = array_merge_recursive($media, FileUploadWidget::$media);\n        return $media;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n        $config = parent::getConfiguration();\n        $config['html'] = (bool) ($cfg && $cfg->isRichTextEnabled());\n        return $config;\n    }\n\n    function getConfigurationOptions() {\n        global $cfg;\n\n        $attachments = new FileUploadField();\n        $fileupload_config = $attachments->getConfigurationOptions();\n        if ($cfg->getAllowedFileTypes())\n            $fileupload_config['extensions']->set('default', $cfg->getAllowedFileTypes());\n\n        foreach ($fileupload_config as $C) {\n            $C->set('visibility', new VisibilityConstraint(new Q(array(\n                'attachments__eq'=>true,\n            )), VisibilityConstraint::HIDDEN));\n        }\n        return array(\n            'attachments' => new BooleanField(array(\n                'label'=>__('Enable Attachments'),\n                'default'=>$cfg->allowAttachments(),\n                'configuration'=>array(\n                    'desc'=>__('Enables attachments, regardless of channel'),\n                ),\n                'validators' => function($self, $value) {\n                    if (!ini_get('file_uploads'))\n                        $self->addError(__('The \"file_uploads\" directive is disabled in php.ini'));\n                }\n            )),\n        )\n        + $fileupload_config;\n    }\n\n    function isAttachmentsEnabled() {\n        $config = $this->getConfiguration();\n        return $config['attachments'];\n    }\n\n    function getWidget($widgetClass=false) {\n        if ($hint = $this->getLocal('hint'))\n            $this->set('placeholder', Format::striptags($hint));\n        $this->set('hint', null);\n        $widget = parent::getWidget($widgetClass);\n        return $widget;\n    }\n}\n\nclass TopicField extends ChoiceField {\n    var $topics;\n    var $_choices;\n\n    function getTopics() {\n        global $thisstaff;\n\n        if (!isset($this->topics))\n            $this->topics = $thisstaff->getTopicNames();\n\n        return $this->topics;\n    }\n\n    function getTopic($id) {\n        if ($this->getTopics() &&\n                isset($this->topics[$id]))\n            return Topic::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $default = $this->get('default');\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Topic)\n            $widget->value = $widget->value->getId();\n        elseif (!isset($widget->value) && $default)\n            $widget->value = $default;\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $this->_choices = $this->getTopics();\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Topic)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n\n        return $this->getTopic($id);\n    }\n\n    function to_database($topic) {\n        return ($topic instanceof Topic)\n            ? array($topic->getName(), $topic->getId())\n            : $topic;\n    }\n\n    function display($topic, &$styles=null) {\n        if (!$topic instanceof Topic)\n            return parent::display($topic);\n\n        return Format::htmlchars($topic->getName());\n    }\n\n    function toString($value) {\n        if (!($value instanceof Topic) && is_numeric($value))\n            $value = $this->getTopic($value);\n\n        return ($value instanceof Topic) ? $value->getName() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Topic) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultTopicId();\n        return $config;\n    }\n}\n\nclass SLAField extends ChoiceField {\n    var $slas;\n    var $_choices;\n\n    function getSLAs() {\n        if (!isset($this->slas))\n            $this->slas = SLA::objects();\n\n        return $this->slas;\n    }\n\n    function getSLA($id) {\n        if ($this->getSLAs() &&\n                ($s=$this->slas->findFirst(array('id' => $id))))\n            return $s;\n\n        return SLA::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $default = $this->get('default');\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof SLA)\n            $widget->value = $widget->value->getId();\n        elseif (!isset($widget->value) && $default)\n            $widget->value = $default;\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $choices = array();\n            foreach ($this->getSLAs() as $s)\n                $choices[$s->getId()] = $s->getName();\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof SLA)\n            return $value;\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        }\n        elseif (is_array($value))\n            list($value, $id) = $value;\n        elseif ($id === false)\n            $id = $value;\n\n        return $this->getSLA($id);\n    }\n\n    function to_database($sla) {\n        return ($sla instanceof SLA)\n            ? array($sla->getName(), $sla->getId())\n            : $sla;\n    }\n\n    function display($sla, &$styles=null) {\n        if (!$sla instanceof SLA)\n            return parent::display($sla);\n\n        return Format::htmlchars($sla->getName());\n    }\n\n    function toString($value) {\n        if (!($value instanceof SLA) && is_numeric($value))\n            $value = $this->getSLA($value);\n        return ($value instanceof SLA) ? $value->getName() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof SLA) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultSLAId();\n        return $config;\n    }\n}\n\nclass PriorityField extends ChoiceField {\n\n    var $priorities;\n    var $_choices;\n\n    function getPriorities() {\n        if (!isset($this->priorities))\n            $this->priorities = Priority::objects();\n\n        return $this->priorities;\n    }\n\n    function getPriority($id) {\n\n        if ($this->getPriorities() &&\n                ($p=$this->priorities->findFirst(array('priority_id' =>\n                                                       $id))))\n            return $p;\n\n        return Priority::lookup($id);\n    }\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        if ($widget->value instanceof Priority)\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices)) {\n            $choices = array();\n            foreach ($this->getPriorities() as $p)\n                $choices[$p->getId()] = $p->getDesc();\n            $this->_choices = $choices;\n        }\n\n        return $this->_choices;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if ($value instanceof Priority)\n            return $value;\n\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n        } elseif (is_array($value)) {\n            list($value, $id) = $value;\n        } elseif ($id === false && is_numeric($value))\n            $id = $value;\n\n        if (is_numeric($id))\n            return $this->getPriority($id);\n\n        return $value;\n    }\n\n    function to_database($value) {\n        if ($value instanceof Priority)\n            return array($value->getDesc(), $value->getId());\n\n        if (is_array($value))\n            return array(current($value), key($value));\n\n        return $value;\n    }\n\n    function display($prio, &$styles=null) {\n        if (!$prio instanceof Priority)\n            return parent::display($prio);\n        if (is_array($styles))\n            $styles += array(\n                'background-color' => $prio->getColor()\n            );\n        return Format::htmlchars($prio->getDesc());\n    }\n\n    function toString($value) {\n        return ($value instanceof Priority) ? $value->getDesc() : $value;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        // Priority isn't searchable this way\n        return null;\n    }\n\n    function getKeys($value) {\n        return ($value instanceof Priority) ? array($value->getId()) : null;\n    }\n\n    function asVar($value, $id=false) {\n        return $this->to_php($value, $id);\n    }\n\n    function getConfigurationOptions() {\n        $choices = $this->getChoices();\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n            'default' => new ChoiceField(array(\n                'id'=>3, 'label'=>__('Default'), 'required'=>false, 'default'=>'',\n                'choices' => $choices,\n                'hint'=>__('Default selection for this field'),\n                'configuration'=>array('size'=>20, 'length'=>40),\n            )),\n        );\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        if (!isset($config['default']))\n            $config['default'] = $cfg->getDefaultPriorityId();\n        return $config;\n    }\n\n    function applyOrderBy($query, $reverse=false, $name=false) {\n        if ($query->model == 'Ticket' && $name == 'cdata__priority') {\n            // Order by the priority urgency field\n            $col = 'cdata__:priority__priority_urgency';\n            $reverse = !$reverse;\n        }\n        else {\n            $col = $name ?: CustomQueue::getOrmPath($this->get('name'), $query);\n        }\n        if ($reverse)\n            $col = \"-$col\";\n        return $query->order_by($col);\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'priority' => array(__('Priority Level'), 'PriorityField'),\n    );\n});\n\n\nclass TimezoneField extends ChoiceField {\n    static $widget = 'TimezoneWidget';\n\n    function hasIdValue() {\n        return false;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        global $cfg;\n\n        $choices = array();\n        foreach (DateTimeZone::listIdentifiers() as $zone)\n            $choices[$zone] =  str_replace('/',' / ',$zone);\n\n        return $choices;\n    }\n\n    function whatChanged($before, $after) {\n        return parent::whatChanged($before, $after);\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'autodetect' => new BooleanField(array(\n                'id'=>1, 'label'=>__('Auto Detect'), 'required'=>false, 'default'=>true,\n                'configuration'=>array(\n                    'desc'=>__('Add Auto Detect Button'))\n            )),\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\n\nclass DepartmentField extends ChoiceField {\n    function getWidget($widgetClass=false) {\n        $widget = $this->_widget ?: parent::getWidget($widgetClass);\n        if (is_object($widget->value))\n            $widget->value = $widget->value->getId();\n        return $widget;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        global $cfg, $thisstaff;\n\n        $config = $this->getConfiguration();\n        $staff = $config['staff'] ?: $thisstaff;\n        $selected = $this->getWidget();\n        if($selected && $selected->value) {\n          if(is_array($selected->value)) {\n            foreach ($selected->value as $k => $v) {\n              $current_id = $k;\n              $current_name = $v;\n            }\n          }\n          else {\n            $current_id = $selected->value;\n            $current_name = Dept::getNameById($current_id);\n          }\n        }\n\n        $choices = array();\n\n        //get all depts unfiltered\n        $depts = $config['hideDisabled'] ? Dept::getDepartments(array('activeonly' => true)) :\n            Dept::getDepartments(null, true, Dept::DISPLAY_DISABLED);\n\n        //get staff depts based on permissions\n        if ($staff) {\n            $active = $staff->getDepartmentNames(true);\n\n            if ($staff->hasPerm(Dept::PERM_DEPT))\n                return $depts;\n        }\n        //filter custom department fields when there is no staff\n        else {\n            $userDepts = Dept::getDepartments(array('publiconly' => true, 'activeonly' => true));\n\n            return $userDepts;\n        }\n\n         //add selected dept to list\n         if($current_id)\n            $active[$current_id] = $current_name;\n         else\n            return $active;\n\n         foreach ($depts as $id => $name) {\n            $choices[$id] = $name;\n            if(!array_key_exists($id, $active) && $current_id)\n                unset($choices[$id]);\n         }\n\n        return $choices;\n    }\n\n    function display($dept, &$styles=null) {\n        if (!is_numeric($dept) && is_string($dept))\n            return Format::htmlchars($dept);\n        elseif ($dept instanceof Dept)\n            return Format::htmlchars($dept->getName());\n\n        return parent::display($dept);\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function getValue() {\n         if (($value = parent::getValue()) && ($id=$this->getClean()))\n            return $value[$id];\n     }\n\n    function to_php($value, $id=false) {\n        if ($id) {\n            if (is_array($id)) {\n                reset($id);\n                $id = key($id);\n            }\n            return $id;\n        } else {\n            return $value;\n        }\n    }\n\n    function to_database($dept) {\n        if ($dept instanceof Dept)\n            return array($dept->getName(), $dept->getId());\n\n        if (!is_array($dept)) {\n            $choices = $this->getChoices();\n            if (in_array($dept, $choices)) {\n                $deptId = array_search($dept, $choices);\n                $dept = array($dept, $deptId);\n            }\n         }\n\n        return $dept ?: array();\n    }\n\n    function toString($value) {\n        if (!is_array($value))\n            $value = $this->getChoice($value);\n        if (is_array($value))\n            return implode(', ', $value);\n        return (string) $value;\n    }\n\n    function getChoice($value) {\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_array($value)) {\n            $selection = $value;\n        } elseif (isset($choices[$value])) {\n            $selection[] = $choices[$value];\n        }\n\n        return $selection;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'department' => array(__('Department'), 'DepartmentField'),\n    );\n});\n\nclass AssigneeField extends ChoiceField {\n    var $_choices = null;\n    var $_criteria = null;\n\n    function getWidget($widgetClass=false) {\n        $widget = parent::getWidget($widgetClass);\n        $value = $widget->value;\n        if (is_object($value)) {\n            $id = $value->getId();\n            if ($value instanceof Staff)\n                $widget->value = 's'.$id;\n            elseif ($value instanceof Team)\n                $widget->value = 't'.$id;\n        }\n        return $widget;\n    }\n\n    function getCriteria() {\n        if (!isset($this->_criteria)) {\n            $this->_criteria = array('available' => true, 'namesOnly' => true);\n            if (($c=parent::getCriteria()))\n                $this->_criteria = array_merge($this->_criteria, $c);\n        }\n\n        return $this->_criteria;\n    }\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function setChoices($choices) {\n        $this->_choices = $choices;\n    }\n\n    function display($value) {\n        if ($this->getAnswer() && is_string($this->getAnswer()->value)) {\n            $v = JsonDataParser::parse($this->getAnswer()->value);\n            if (is_array($v))\n                $value = $v[key($v)];\n        }\n        return $value;\n    }\n\n    function getAssignees($options=array()) {\n        global $thisstaff;\n\n        $config = $this->getConfiguration();\n        $criteria = $this->getCriteria();\n        $dept = $config['dept'] ?: null;\n        $staff = $config['staff'] ?: $thisstaff;\n        $assignees = array();\n        switch (strtolower($config['target'])) {\n        case 'agents':\n            if ($dept)\n                foreach ($dept->getAssignees(array('staff' => $staff)) as $a)\n                    $assignees['s'.$a->getId()] = $a;\n            else\n                foreach (Staff::getStaffMembers(array('staff' => $staff)) as $id => $name)\n                    $assignees['s'.$id] = $name;\n            break;\n        case 'teams':\n            foreach (Team::getActiveTeams() ?: array() as $id => $name)\n                $assignees['t'.$id] = $name;\n            break;\n        default:\n            // both agents and teams\n            $assignees = array(\n                    __('Agents') => new ArrayObject(),\n                    __('Teams') => new ArrayObject());\n            $A = current($assignees);\n            $criteria = $this->getCriteria();\n            $agents = array();\n            if ($dept)\n                foreach ($dept->getAssignees(array('staff' => $staff)) as $a)\n                    $A['s'.$a->getId()] = $a;\n            else\n                foreach (Staff::getStaffMembers(array('staff' => $staff)) as $a => $name)\n                    $A['s'.$a] = $name;\n\n            next($assignees);\n            $T = current($assignees);\n            if (($teams = Team::getActiveTeams()))\n                foreach ($teams as $id => $name)\n                    $T['t'.$id] = $name;\n            break;\n        }\n\n        return $assignees;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        if (!isset($this->_choices))\n            $this->_choices = $this->getAssignees($options);\n\n        return $this->_choices;\n    }\n\n    function getChoice($value) {\n        $choices = $this->getChoices();\n        $selection = array();\n        if ($value && is_object($value)) {\n            $keys = null;\n            if ($value instanceof Staff)\n                $keys = array('Agents', 's'.$value->getId());\n            elseif ($value instanceof Team)\n                $keys = array('Teams', 't'.$value->getId());\n            if ($keys && isset($choices[$keys[0]]))\n                $selection = $choices[$keys[0]][$keys[1]];\n\n            if (!empty($selection))\n                return $selection;\n        }\n\n        return parent::getChoice($value);\n    }\n\n    function getQuickFilterChoices() {\n        $choices = $this->getChoices();\n        $names = array();\n        foreach ($choices as $value) {\n            foreach ($value as $key => $value)\n                $names[$key] = is_object($value) ? $value->name : $value;\n        }\n\n        return $names;\n    }\n\n    function getValue() {\n        if (($value = parent::getValue()) && ($id=$this->getClean())) {\n            $name = (is_object($value[key($value)]) && get_class($value[key($value)]) == 'AgentsName') ?\n                $value[key($value)]->name : $value[key($value)];\n            $key = (($value[key($value)] instanceof AgentsName) ? 's' : 't').substr(key($value), 1);\n            return array(array($key => $name), substr(key($value), 1));\n        } else\n            return null;\n    }\n\n    function parse($id) {\n        return $this->to_php(null, $id);\n    }\n\n    function to_php($value, $id=false) {\n        if (is_string($value))\n            $value = JsonDataParser::parse($value) ?: $value;\n\n        if (is_string($value) && strpos($value, ',')) {\n            $values = array();\n            list($key, $V) = array_map('trim', explode(',', $value));\n\n            $values[$key] = $V;\n            $value = $values;\n        }\n\n        $type = '';\n        if (is_array($id)) {\n            reset($id);\n            $id = key($id);\n            $type = $id[0];\n            $id = substr($id, 1);\n        }\n        if (is_array($value)) {\n            $type = key($value)[0];\n            if (!$id)\n                $id = substr(key($value), 1);\n        }\n\n        if (!$type && is_numeric($value))\n            return Staff::lookup($value);\n\n        switch ($type) {\n        case 's':\n            return Staff::lookup($id);\n        case 't':\n            return Team::lookup($id);\n        case 'd':\n            return Dept::lookup($id);\n        default:\n            return $id;\n        }\n    }\n\n    function to_database($value) {\n        if (is_object($value)) {\n            $id = $value->getId();\n            if ($value instanceof Staff) {\n                $key = 's'.$id;\n                $name = $value->getName()->name;\n            } elseif ($value instanceof Team) {\n                $key = 't'.$id;\n                $name = $value->getName();\n            }\n\n            return JsonDataEncoder::encode(array($key => $name));\n        }\n        if (is_array($value)) {\n            return JsonDataEncoder::encode($value[0]);\n        }\n        return $value;\n    }\n\n    function toString($value) {\n        return (string) $value;\n    }\n\n    function searchable($value) {\n        return null;\n    }\n\n    function getKeys($value) {\n        $value = $this->to_database($value);\n        if (is_array($value))\n            return $value[0];\n\n        return (string) $value;\n    }\n\n    function asVar($value, $id=false) {\n        $v = $this->to_php($value, $id);\n        return $v ? $v->getName() : null;\n    }\n\n    function getChanges() {\n        $new = $this->to_database($this->getValue());\n        $old = $this->to_database($this->answer ? $this->answer->getValue()\n                : $this->get('default'));\n        // Compare old and new\n        return ($old == $new)\n            ? false\n            : array($old, $new);\n    }\n\n    function whatChanged($before, $after) {\n        if ($before)\n            $before = array($before->getName());\n        if ($after)\n            $after = array($after->getName());\n\n        return parent::whatChanged($before, $after);\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>__('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=>__('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\nFormField::addFieldTypes(/*@trans*/ 'Dynamic Fields', function() {\n    return array(\n        'assignee' => array(__('Assignee'), 'AssigneeField'),\n    );\n});\n\n\nclass TicketStateField extends ChoiceField {\n\n    static $_states = array(\n            'open' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Open',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Open'\n                ),\n            'closed' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Closed',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Close'\n                )\n            );\n    // Private states\n    static $_privatestates = array(\n            'archived' => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Archived',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Archive'\n                ),\n            'deleted'  => array(\n                'name' => /* @trans, @context \"ticket state name\" */ 'Deleted',\n                'verb' => /* @trans, @context \"ticket state action\" */ 'Delete'\n                )\n            );\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return false;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        static $_choices;\n\n        $states = static::$_states;\n        if ($this->options['private_too'])\n            $states += static::$_privatestates;\n\n        if (!isset($_choices)) {\n            // Translate and cache the choices\n            foreach ($states as $k => $v)\n                $_choices[$k] =  _P('ticket state name', $v['name']);\n\n            $this->ht['default'] =  '';\n        }\n\n        return $_choices;\n    }\n\n    function getChoice($state) {\n\n        if ($state && is_array($state))\n            $state = key($state);\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state name', static::$_states[$state]['name']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state name', static::$_privatestates[$state]['name']);\n\n        return $state;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=> __('Prompt'), 'required'=>false, 'default'=>'',\n                'hint'=> __('Leading text shown before a value is selected'),\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n\n    static function getVerb($state) {\n\n        if (isset(static::$_states[$state]))\n            return _P('ticket state action', static::$_states[$state]['verb']);\n\n        if (isset(static::$_privatestates[$state]))\n            return _P('ticket state action', static::$_privatestates[$state]['verb']);\n    }\n}\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'state' => array('Ticket State', 'TicketStateField', false),\n    );\n});\n\nclass TicketFlagField extends ChoiceField {\n\n    // Supported flags (TODO: move to configurable custom list)\n    static $_flags = array(\n            'onhold' => array(\n                'flag' => 1,\n                'name' => 'Onhold',\n                'states' => array('open'),\n                ),\n            'overdue' => array(\n                'flag' => 2,\n                'name' => 'Overdue',\n                'states' => array('open'),\n                ),\n            'answered' => array(\n                'flag' => 4,\n                'name' => 'Answered',\n                'states' => array('open'),\n                )\n            );\n\n    var $_choices;\n\n    function hasIdValue() {\n        return true;\n    }\n\n    function isChangeable() {\n        return true;\n    }\n\n    function getChoices($verbose=false, $options=array()) {\n        $this->ht['default'] =  '';\n\n        if (!$this->_choices) {\n            foreach (static::$_flags as $k => $v)\n                $this->_choices[$k] = $v['name'];\n        }\n\n        return $this->_choices;\n    }\n\n    function getConfigurationOptions() {\n        return array(\n            'prompt' => new TextboxField(array(\n                'id'=>2, 'label'=>'Prompt', 'required'=>false, 'default'=>'',\n                'hint'=>'Leading text shown before a value is selected',\n                'configuration'=>array('size'=>40, 'length'=>40),\n            )),\n        );\n    }\n}\n\nFormField::addFieldTypes('Dynamic Fields', function() {\n    return array(\n        'flags' => array('Ticket Flags', 'TicketFlagField', false),\n    );\n});\n\nclass FileUploadField extends FormField {\n    static $widget = 'FileUploadWidget';\n\n    protected $attachments;\n    protected $files;\n\n    static function getFileTypes() {\n        static $filetypes;\n\n        if (!isset($filetypes)) {\n            if (function_exists('apcu_fetch')) {\n                $key = md5(SECRET_SALT . GIT_VERSION . 'filetypes');\n                $filetypes = apcu_fetch($key);\n            }\n            if (!$filetypes)\n                $filetypes = YamlDataParser::load(INCLUDE_DIR . '/config/filetype.yaml');\n            if ($key)\n                apcu_store($key, $filetypes, 7200);\n        }\n        return $filetypes;\n    }\n\n    function getConfigurationOptions() {\n        // Compute size selections\n        $sizes = array('262144' => '\u2014 '.__('Small').' \u2014');\n        $next = 512 << 10;\n        $max = strtoupper(ini_get('upload_max_filesize'));\n        $limit = (int) $max;\n        if (!$limit) $limit = 2 << 20; # 2M default value\n        elseif (strpos($max, 'K')) $limit <<= 10;\n        elseif (strpos($max, 'M')) $limit <<= 20;\n        elseif (strpos($max, 'G')) $limit <<= 30;\n        while ($next <= $limit) {\n            // Select the closest, larger value (in case the\n            // current value is between two)\n            $sizes[$next] = Format::file_size($next);\n            $next *= 2;\n        }\n        // Add extra option if top-limit in php.ini doesn't fall\n        // at a power of two\n        if ($next < $limit * 2)\n            $sizes[$limit] = Format::file_size($limit);\n\n        $types = array();\n        foreach (self::getFileTypes() as $type=>$info) {\n            $types[$type] = $info['description'];\n        }\n\n        global $cfg;\n        return array(\n            'size' => new ChoiceField(array(\n                'label'=>__('Maximum File Size'),\n                'hint'=>__('Choose maximum size of a single file uploaded to this field'),\n                'default'=>$cfg->getMaxFileSize(),\n                'choices'=>$sizes\n            )),\n            'mimetypes' => new ChoiceField(array(\n                'label'=>__('Restrict by File Type'),\n                'hint'=>__('Optionally, choose acceptable file types.'),\n                'required'=>false,\n                'choices'=>$types,\n                'configuration'=>array('multiselect'=>true,'prompt'=>__('No restrictions'))\n            )),\n            'extensions' => new TextareaField(array(\n                'label'=>__('Additional File Type Filters'),\n                'hint'=>__('Optionally, enter comma-separated list of additional file types, by extension. (e.g .doc, .pdf).'),\n                'configuration'=>array('html'=>false, 'rows'=>2),\n            )),\n            'max' => new TextboxField(array(\n                'label'=>__('Maximum Files'),\n                'hint'=>__('Users cannot upload more than this many files.'),\n                'default'=>false,\n                'required'=>false,\n                'validator'=>'number',\n                'configuration'=>array('size'=>8, 'length'=>4, 'placeholder'=>__('No limit')),\n            ))\n        );\n    }\n\n    /**\n     * Called from the ajax handler for async uploads via web clients.\n     */\n    function ajaxUpload($bypass=false) {\n        $config = $this->getConfiguration();\n\n        $files = AttachmentFile::format($_FILES['upload'],\n            // For numeric fields assume configuration exists\n            !is_numeric($this->get('id')));\n        if (count($files) != 1)\n            Http::response(400, 'Send one file at a time');\n        $file = array_shift($files);\n        $file['name'] = urldecode($file['name']);\n\n        if (!self::isValidFile($file))\n            Http::response(413, 'Invalid File');\n\n        if (!$bypass && !$this->isValidFileType($file['name'], $file['type']))\n            Http::response(415, 'File type is not allowed');\n\n        $config = $this->getConfiguration();\n        if (!$bypass && $file['size'] > $config['size'])\n            Http::response(413, 'File is too large');\n\n        if (!($F = AttachmentFile::upload($file)))\n            Http::response(500, 'Unable to store file: '. $file['error']);\n\n        $id = $F->getId();\n\n        // This file is allowed for attachment in this session\n        $_SESSION[':uploadedFiles'][$id] = $F->getName();\n\n        return $id;\n    }\n\n    /**\n     * Called from FileUploadWidget::getValue() when manual upload is used\n     * for browsers which do not support the HTML5 way of uploading async.\n     */\n    function uploadFile($file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!self::isValidFile($file))\n             throw new FileUploadError(__('Invalid File'));\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        return AttachmentFile::upload($file);\n    }\n\n    /**\n     * Called from API and email routines and such to handle attachments\n     * sent other than via web upload\n     */\n    function uploadAttachment(&$file) {\n        if (!$this->isValidFileType($file['name'], $file['type']))\n            throw new FileUploadError(__('File type is not allowed'));\n\n        if (!isset($file['data']) && isset($file['data_cbk'])\n                && is_callable($file['data_cbk']))\n            $file['data'] = $file['data_cbk']();\n\n        if (!isset($file['size']) && isset($file['data'])) {\n            // bootstrap.php include a compat version of mb_strlen\n            if (extension_loaded('mbstring'))\n                $file['size'] = mb_strlen($file['data'], '8bit');\n            else\n                $file['size'] = strlen($file['data']);\n        }\n\n        $config = $this->getConfiguration();\n        if ($file['size'] > $config['size'])\n            throw new FileUploadError(__('File size is too large'));\n\n        if (!$F = AttachmentFile::create($file))\n            throw new FileUploadError(__('Unable to save file'));\n\n        return $F;\n    }\n\n    static function isValidFile($file) {\n        // Make sure mime type is valid\n        if (strcasecmp(FileObject::mime_type($file['tmp_name']),\n                    $file['type']) !== 0)\n            return false;\n\n        // Check invalid image hacks\n        if ($file['tmp_name']\n                && stripos($file['type'], 'image/') === 0\n                && !exif_imagetype($file['tmp_name']))\n            return false;\n\n        return true;\n    }\n\n    function isValidFileType($name, $type=false) {\n        $config = $this->getConfiguration();\n\n        // Check MIME type - file ext. shouldn't be solely trusted.\n        if ($type && $config['__mimetypes']\n                && in_array($type, $config['__mimetypes'], true))\n            return true;\n\n        // Return true if all file types are allowed (.*)\n        if (!$config['__extensions'] || in_array('.*', $config['__extensions']))\n            return true;\n\n        $allowed = $config['__extensions'];\n        $ext = strtolower(pathinfo($name, PATHINFO_EXTENSION));\n\n        return ($ext && is_array($allowed) && in_array(\".$ext\", $allowed));\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments) && ($a = $this->getAnswer())\n            && ($e = $a->getEntry()) && ($e->get('id'))\n        ) {\n            $this->attachments = GenericAttachments::forIdAndType(\n                // Combine the field and entry ids to make the key\n                sprintf('%u', abs(crc32('E'.$this->get('id').$e->get('id')))),\n                'E');\n        }\n        return $this->attachments ?: array();\n    }\n\n    function setAttachments(GenericAttachments $att) {\n        $this->attachments = $att;\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            foreach ($this->getAttachments() as $a) {\n                if ($a && ($f=$a->getFile()))\n                    $files[] = $f;\n            }\n\n            foreach ($this->getClean(false) ?: array() as $key => $value)\n                $files[] = array('id' => $key, 'name' => $value);\n\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n\n    function getConfiguration() {\n        global $cfg;\n\n        $config = parent::getConfiguration();\n        // If no size present default to system setting\n        $config['size'] ??= $cfg->getMaxFileSize();\n        $_types = self::getFileTypes();\n        $mimetypes = array();\n        $extensions = array();\n        if (isset($config['mimetypes']) && is_array($config['mimetypes'])) {\n            foreach ($config['mimetypes'] as $type=>$desc) {\n                foreach ($_types[$type]['types'] as $mime=>$exts) {\n                    $mimetypes[$mime] = true;\n                    if (is_array($exts))\n                        foreach ($exts as $ext)\n                            $extensions['.'.$ext] = true;\n                }\n            }\n        }\n        if (strpos($config['extensions'], '.*') !== false)\n            $config['extensions'] = '';\n\n        if (is_string($config['extensions'])) {\n            foreach (preg_split('/\\s+/', str_replace(',',' ', $config['extensions'])) as $ext) {\n                if (!$ext) {\n                    continue;\n                }\n                elseif (strpos($ext, '/')) {\n                    $mimetypes[$ext] = true;\n                }\n                else {\n                    if ($ext[0] != '.')\n                        $ext = '.' . $ext;\n\n                    // Ensure that the extension is lower-cased for comparison latr\n                    $ext = strtolower($ext);\n\n                    // Add this to the MIME types list so it can be exported to\n                    // the @accept attribute\n                    if (!isset($extensions[$ext]))\n                        $mimetypes[$ext] = true;\n\n                    $extensions[$ext] = true;\n                }\n            }\n            $config['__extensions'] = array_keys($extensions);\n        }\n        elseif (is_array($config['extensions'])) {\n            $config['__extensions'] = $config['extensions'];\n        }\n\n        // 'mimetypes' is the array represented from the user interface,\n        // '__mimetypes' is a complete list of supported MIME types.\n        $config['__mimetypes'] = array_keys($mimetypes);\n        return $config;\n    }\n\n    // When the field is saved to database, encode the ID listing as a json\n    // array. Then, inspect the difference between the files actually\n    // attached to this field\n    function to_database($value) {\n        $this->getAttachments();\n        if (isset($this->attachments) && $this->attachments) {\n            $this->attachments->keepOnlyFileIds($value);\n        }\n        return JsonDataEncoder::encode($value) ?? NULL;\n    }\n\n    function parse($value) {\n        return $value;\n    }\n\n    function to_php($value) {\n        return is_array($value) ? $value : JsonDataParser::decode($value);\n    }\n\n    function display($value) {\n        $links = array();\n        foreach ($this->getAttachments() as $a) {\n            $links[] = sprintf('<a class=\"no-pjax\" href=\"%s\"><i class=\"icon-paperclip icon-flip-horizontal\"></i> %s</a>',\n                Format::htmlchars($a->file->getDownloadUrl()),\n                Format::htmlchars($a->getFilename()));\n        }\n        return implode('<br/>', $links);\n    }\n\n    function toString($value) {\n        $files = array();\n        foreach ($this->getFiles() as $f) {\n            $files[] = $f->name;\n        }\n        return implode(', ', $files);\n    }\n\n    function db_cleanup($field=false) {\n        if ($this->getAttachments()) {\n            $this->attachments->deleteAll();\n        }\n    }\n\n    function asVar($value, $id=false) {\n        if (($attachments = $this->getAttachments()))\n            $attachments = $attachments->all();\n\n        return new FileFieldAttachments($attachments ?: array());\n    }\n    function asVarType() {\n        return 'FileFieldAttachments';\n    }\n\n    function whatChanged($before, $after) {\n        $B = (array) $before;\n        $A = (array) $after;\n        $added = array_diff($A, $B);\n        $deleted = array_diff($B, $A);\n        $added = Format::htmlchars(array_values($added));\n        $deleted = Format::htmlchars(array_values($deleted));\n\n        if ($added && $deleted) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong> and removed <strong>%2$s</strong>'),\n                implode(', ', $added), implode(', ', $deleted));\n        }\n        elseif ($added) {\n            $desc = sprintf(\n                __('added <strong>%1$s</strong>'),\n                implode(', ', $added));\n        }\n        elseif ($deleted) {\n            $desc = sprintf(\n                __('removed <strong>%1$s</strong>'),\n                implode(', ', $deleted));\n        }\n        else {\n            $desc = sprintf(\n                __('changed from <strong>%1$s</strong> to <strong>%2$s</strong>'),\n                $this->display($before), $this->display($after));\n        }\n        return $desc;\n    }\n}\n\nclass FileFieldAttachments {\n    var $attachments;\n\n    function __construct($attachments) {\n        $this->attachments = $attachments;\n    }\n\n    function __toString() {\n        $files = array();\n        foreach ($this->getAttachments() as $a) {\n            $files[] = $a->getFilename();\n        }\n        return implode(', ', $files);\n    }\n\n    function getAttachments() {\n        return $this->attachments ?: array();\n    }\n\n    function getVar($tag) {\n        switch ($tag) {\n        case 'names':\n            return $this->__toString();\n        case 'files':\n            throw new OOBContent(OOBContent::FILES, $this->getAttachments());\n        }\n    }\n\n    static function getVarScope() {\n        return array(\n            'names' => __('List of file names'),\n            'files' => __('Attached files'),\n        );\n    }\n}\n\nclass ColorChoiceField extends FormField {\n    static $widget = 'ColorPickerWidget';\n}\n\nclass InlineFormData extends ArrayObject {\n    var $_form;\n\n    function __construct($form, array $data=array()) {\n        parent::__construct($data);\n        $this->_form = $form;\n    }\n\n    function getVar($tag) {\n        foreach ($this->_form->getFields() as $f) {\n            if ($f->get('name') == $tag)\n                return $this[$f->get('id')];\n        }\n    }\n}\n\n\nclass InlineFormField extends FormField {\n    static $widget = 'InlineFormWidget';\n\n    var $_iform = null;\n\n    function validateEntry($value) {\n        if (!$this->getInlineForm()->isValid()) {\n            $config = $this->getConfiguration();\n            $this->_errors[] = isset($config['error'])\n                ? $config['error'] : __('Correct any errors below and try again.');\n        }\n    }\n\n    function parse($value) {\n        // The InlineFieldWidget returns an array of cleaned data\n        return $value;\n    }\n\n    function to_database($value) {\n        return JsonDataEncoder::encode($value);\n    }\n\n    function to_php($value) {\n        $data = JsonDataParser::decode($value);\n        // The InlineFormData helps with the variable replacer API\n        return new InlineFormData($this->getInlineForm(), $data);\n    }\n\n    function display($data) {\n        $form = $this->getInlineForm();\n        ob_start(); ?>\n        <div><?php\n        foreach ($form->getFields() as $field) { ?>\n            <span style=\"display:inline-block;padding:0 5px;vertical-align:top\">\n                <strong><?php echo Format::htmlchars($field->get('label')); ?></strong>\n                <div><?php\n                    $value = $data[$field->get('id')];\n                    echo $field->display($value); ?></div>\n            </span><?php\n        } ?>\n        </div><?php\n        return ob_get_clean();\n    }\n\n    function getInlineForm($data=false) {\n        $form = $this->get('form');\n        if (is_array($form)) {\n            $form = new SimpleForm($form, $data ?: $this->value ?: $this->getSource());\n            // Ensure unique, but predictable form and field IDs\n            $form->setId(sprintf('%u', crc32($this->get('name')) >> 1));\n        }\n        return $form;\n    }\n}\n\nclass InlineDynamicFormField extends FormField {\n    function getInlineForm($data=false) {\n        if (!isset($this->_iform) || $data) {\n            $config = $this->getConfiguration();\n            $this->_iform = DynamicForm::lookup($config['form']);\n            if ($data)\n                $this->_iform = $this->_iform->getForm($data);\n        }\n        return $this->_iform;\n    }\n\n    function getConfigurationOptions() {\n        $forms = DynamicForm::objects()->filter(array('type'=>'G'))\n            ->values_flat('id', 'title');\n        $choices = array();\n        foreach ($forms as $row) {\n            list($id, $title) = $row;\n            $choices[$id] = $title;\n        }\n        return array(\n            'form' => new ChoiceField(array(\n                'id'=>2, 'label'=>'Inline Form', 'required'=>true,\n                'default'=>'', 'choices'=>$choices\n            )),\n        );\n    }\n}\n\nclass InlineFormWidget extends Widget {\n    function render($mode=false) {\n        $form = $this->field->getInlineForm();\n        if (!$form)\n            return;\n        // Handle first-step edits -- load data from $this->value\n        if ($form instanceof DynamicForm && !$form->getSource())\n            $form = $form->getForm($this->value);\n        $inc = ($mode == 'client') ? CLIENTINC_DIR : STAFFINC_DIR;\n        include $inc . 'templates/inline-form.tmpl.php';\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (!$data)\n            return null;\n        $form = $this->field->getInlineForm($data);\n        if (!$form)\n            return null;\n        return $form->getClean();\n    }\n}\n\nclass Widget {\n    static $media = null;\n\n    function __construct($field) {\n        $this->field = $field;\n        $this->name = $field->getFormName();\n        $this->id = '_' . $this->name;\n    }\n\n    function parseValue() {\n        $this->value = $this->getValue();\n        if (!isset($this->value) && is_object($this->field->getAnswer()))\n            $this->value = $this->field->getAnswer()->getValue();\n        if (!isset($this->value) && isset($this->field->value))\n            $this->value = $this->field->value;\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        foreach ($this->field->getFormNames() as $name)\n            if (isset($data[$name]))\n                return $data[$name];\n\n        return null;\n    }\n\n    /**\n     * getJsValueGetter\n     *\n     * Used with the dependent fields feature, this function should return a\n     * single javascript expression which can be used in a larger expression\n     * (<> == true, where <> is the result of this function). The %s token\n     * will be replaced with a jQuery variable representing this widget.\n     */\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.val()', $id);\n    }\n\n    /**\n     * getJsComparator\n     *\n     * Used with the dependent fields to get comparison expression\n     *\n     */\n    function getJsComparator($value, $id) {\n\n        if (strpos($value, '|') !== false)\n            return sprintf('$.inArray(%s, %s) !== -1',\n                   $this->getJsValueGetter($id),\n                   JsonDataEncoder::encode(explode('|', $value)));\n\n        return sprintf('%s == %s',\n                $this->getJsValueGetter($id),\n                JsonDataEncoder::encode($value));\n    }\n}\n\nclass TextboxWidget extends Widget {\n    static $input_type = 'text';\n\n    function render($options=array(), $extraConfig=false) {\n        $config = $this->field->getConfiguration();\n        if (is_array($extraConfig)) {\n            foreach ($extraConfig as $k=>$v)\n                if (!isset($config[$k]) || !$config[$k])\n                    $config[$k] = $v;\n        }\n\n        // Input attributes\n        $attrs = array();\n        foreach ($config as $k => $v) {\n            switch ($k) {\n                case 'autocomplete':\n                    if (is_numeric($v))\n                        $v = $v ? 'on' : 'off';\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'disabled';\n                    $attrs[$k] = '\"disabled\"';\n                    break;\n                case 'translatable':\n                    if ($v)\n                        $attrs['data-translate-tag'] =  '\"'.$v.'\"';\n                    break;\n                case 'length':\n                    $k = 'maxlength';\n                case 'size':\n                case 'maxlength':\n                    if ($v && is_numeric($v))\n                        $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'class':\n                case 'classes':\n                    $attrs['class'] = '\"'.$v.'\"';\n                    break;\n                case 'inputmode':\n                case 'pattern':\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n            }\n        }\n        // autofocus\n        $autofocus = '';\n        if (isset($config['autofocus']))\n            $autofocus = 'autofocus';\n        // placeholder\n        $attrs['placeholder'] = sprintf('\"%s\"',\n                Format::htmlchars($this->field->getLocal('placeholder',\n                    $config['placeholder'])));\n        $type = static::$input_type;\n        $types = array(\n            'email' => 'email',\n            'phone' => 'tel',\n        );\n        if ($type == 'text' && isset($types[$config['validator']]))\n            $type = $types[$config['validator']];\n        ?>\n        <input type=\"<?php echo $type; ?>\"\n            id=\"<?php echo $this->id; ?>\"\n            <?php echo $autofocus .' '.Format::array_implode('=', ' ',\n                    array_filter($attrs)); ?>\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value, true); ?>\"/>\n        <?php\n    }\n}\n\n\nclass TextboxSelectionWidget extends TextboxWidget {\n    //TODO: Support multi-input e.g comma separated inputs\n    function render($options=array(), $extraConfig=array()) {\n\n        if ($this->value && is_array($this->value))\n            $this->value = current($this->value);\n\n        parent::render($options);\n    }\n\n    function getValue() {\n\n        $value = parent::getValue();\n        if ($value && ($item=$this->field->lookupChoice((string) $value)))\n            $value = $item;\n\n        return $value;\n    }\n}\n\nclass PasswordWidget extends TextboxWidget {\n    static $input_type = 'password';\n\n    function render($mode=false, $extra=false) {\n        $extra = array();\n        if ($this->field->value) {\n            $extra['placeholder'] = '\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022\u2022';\n        }\n        return parent::render($mode, $extra);\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        // Show empty box unless failed POST\n        if ($_SERVER['REQUEST_METHOD'] != 'POST'\n                || !$this->field->getForm()->isValid())\n            $this->value = '';\n    }\n}\n\nclass TextareaWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        // process textarea attributes\n        $attrs = array();\n        foreach ($config as $k => $v) {\n            switch ($k) {\n                case 'rows':\n                case 'cols':\n                case 'length':\n                case 'maxlength':\n                    if ($v && is_numeric($v))\n                        $attrs[$k] = '\"'.$v.'\"';;\n                    break;\n                case 'context':\n                    $attrs['data-root-context'] =  '\"'.$v.'\"';\n                    break;\n                case 'class':\n                    // This might conflict with html attr below\n                    $attrs[$k] = '\"'.$v.'\"';\n                    break;\n                case 'html':\n                    if ($v) {\n                        $class = array('richtext', 'no-bar');\n                        $class[] = @$config['size'] ?: 'small';\n                        $attrs['class'] =  '\"'.implode(' ', $class).'\"';\n                        $this->value = Format::viewableImages($this->value);\n                    }\n                    break;\n            }\n        }\n        // placeholder\n        $attrs['placeholder'] = sprintf('\"%s\"',\n                Format::htmlchars($this->field->getLocal('placeholder',\n                $config['placeholder'])));\n        ?>\n        <span style=\"display:inline-block;width:100%\">\n        <textarea <?php echo Format::array_implode('=', ' ',\n                array_filter($attrs)); ?>\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"><?php\n                echo Format::htmlchars($this->value, ($config['html']));\n            ?></textarea>\n        </span>\n        <?php\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim empty spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass PhoneNumberWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        list($phone, $ext) = explode(\"X\", $this->value);\n        ?>\n        <input id=\"<?php echo $this->id; ?>\" type=\"tel\" name=\"<?php echo $this->name; ?>\" value=\"<?php\n        echo Format::htmlchars($phone); ?>\"/><?php\n        // Allow display of extension field even if disabled if the phone\n        // number being edited has an extension\n        if ($ext || $config['ext']) { ?> <?php echo __('Ext'); ?>:\n            <input type=\"text\" name=\"<?php\n            echo $this->name; ?>-ext\" value=\"<?php echo Format::htmlchars($ext);\n                ?>\" size=\"5\"/>\n        <?php }\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        $base = parent::getValue();\n        if ($base === null)\n            return $base;\n        $ext = $data[\"{$this->name}-ext\"];\n        // NOTE: 'X' is significant. Don't change it\n        if ($ext) $ext = 'X'.$ext;\n        return $base . $ext;\n    }\n}\n\nclass ChoicesWidget extends Widget {\n    function render($options=array()) {\n        $mode = null;\n        if (isset($options['mode']))\n            $mode = $options['mode'];\n        elseif (isset($this->field->options['render_mode']))\n            $mode = $this->field->options['render_mode'];\n\n        if ($mode == 'view') {\n            $val = (string) $this->field;\n            echo sprintf('<span id=\"field_%s\" %s >%s</span>', $this->id,\n                    $val ? '': 'class=\"faded\"',\n                    $val ?: __('None'));\n            return;\n        }\n\n        $config = $this->field->getConfiguration();\n        if ($mode == 'search') {\n            $config['multiselect'] = true;\n        }\n\n        // Determine the value for the default (the one listed if nothing is\n        // selected)\n        $choices = $this->field->getChoices(true, $options);\n        $prompt = ($config['prompt'])\n            ? $this->field->getLocal('prompt', $config['prompt'])\n            : __('Select'\n            /* Used as a default prompt for a custom drop-down list */);\n\n        $have_def = false;\n        // We don't consider the 'default' when rendering in 'search' mode\n        if (!strcasecmp($mode, 'search')) {\n            $def_val = $prompt;\n        } else {\n            $showdefault = true;\n            if ($mode != 'create')\n                 $showdefault = false;\n            $def_key = $this->field->get('default');\n            if (!$def_key && isset($config['default']))\n                $def_key = $config['default'];\n            if (is_array($def_key))\n                $def_key = key($def_key);\n            $have_def = isset($choices[$def_key]);\n            $def_val = ($have_def && !$showdefault) ? $choices[$def_key] : $prompt;\n        }\n\n        $values = $this->value;\n        if (!is_array($values) && isset($values)) {\n            $values = array($values => $this->field->getChoice($values));\n        }\n\n        if (!is_array($values))\n            $values = $have_def ? array($def_key => $choices[$def_key]) : array();\n\n        if (isset($config['classes']))\n            $classes = 'class=\"'.$config['classes'].'\"';\n        ?>\n        <select name=\"<?php echo $this->name; ?>[]\"\n            <?php echo implode(' ', array_filter(array($classes))); ?>\n            id=\"<?php echo $this->id; ?>\"\n            <?php if (isset($config['data']))\n              foreach ($config['data'] as $D=>$V)\n                echo ' data-'.$D.'=\"'.Format::htmlchars($V).'\"';\n            ?>\n            data-placeholder=\"<?php echo Format::htmlchars($prompt); ?>\"\n            <?php if ($config['multiselect'])\n                echo ' multiple=\"multiple\"'; ?>>\n            <?php if ($showdefault || (!$have_def && !$config['multiselect'])) { ?>\n            <option value=\"<?php echo $showdefault ? '' : $def_key; ?>\">&mdash; <?php\n                echo $def_val; ?> &mdash;</option>\n<?php\n        }\n        $this->emitChoices($choices, $values, $have_def, $def_key); ?>\n        </select>\n        <?php\n        if ($config['multiselect']) {\n         ?>\n        <script type=\"text/javascript\">\n        $(function() {\n            $(\"#<?php echo $this->id; ?>\")\n            .select2({'minimumResultsForSearch':10, 'width': '350px'});\n        });\n        </script>\n       <?php\n        }\n    }\n\n    function emitChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        reset($choices);\n        if (is_array(current($choices)) || current($choices) instanceof Traversable)\n            return $this->emitComplexChoices($choices, $values, $have_def, $def_key);\n\n        foreach ($choices as $key => $name) {\n            if (!$have_def && $key === $def_key)\n                continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n        <?php\n        }\n    }\n\n    function emitComplexChoices($choices, $values=array(), $have_def=false, $def_key=null) {\n        foreach ($choices as $label => $group) {\n            if (!count($group)) continue;\n            ?>\n            <optgroup label=\"<?php echo $label; ?>\"><?php\n            foreach ($group as $key => $name) {\n                if (!$have_def && $key == $def_key)\n                    continue; ?>\n            <option value=\"<?php echo $key; ?>\" <?php\n                if (isset($values[$key])) echo 'selected=\"selected\"';\n            ?>><?php echo Format::htmlchars($name); ?></option>\n<?php       } ?>\n            </optgroup><?php\n        }\n    }\n\n    function getValue() {\n\n        if (!($value = parent::getValue()))\n            return null;\n\n        if ($value && !is_array($value))\n            $value = array($value);\n\n        // Assume multiselect\n        $values = array();\n        $choices = $this->field->getChoices();\n\n        if ($choices && is_array($value)) {\n            // Complex choices\n            if (is_array(current($choices))\n                    || current($choices) instanceof Traversable) {\n                foreach ($choices as $label => $group) {\n                     foreach ($group as $k => $v)\n                        if (in_array($k, $value))\n                            $values[$k] = $v;\n                }\n            } else {\n                foreach($value as $k => $v) {\n                    if (isset($choices[$v]))\n                        $values[$v] = $choices[$v];\n                    elseif (($i=$this->field->lookupChoice($v)))\n                        $values += $i;\n                    elseif (!$k && $v)\n                      return $v;\n                }\n            }\n        }\n\n        return $values;\n    }\n\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.find(\":selected\").val()', $id);\n    }\n\n}\n\n/**\n * A widget for the ChoiceField which will render a list of radio boxes or\n * checkboxes depending on the value of $config['multiple']. Complex choices\n * are also supported and will be rendered as divs.\n */\nclass BoxChoicesWidget extends Widget {\n    function render($options=array()) {\n        $this->emitChoices($this->field->getChoices());\n    }\n\n    function emitChoices($choices) {\n      static $uid = 1;\n\n      if (!isset($this->value))\n          $this->value = $this->field->get('default');\n      $config = $this->field->getConfiguration();\n      $type = $config['multiple'] ? 'checkbox' : 'radio';\n\n      $classes = array('checkbox');\n      if (isset($config['classes']))\n          $classes = array_merge($classes, (array) $config['classes']);\n\n      foreach ($choices as $k => $v) {\n          if (is_array($v)) {\n              $this->renderSectionBreak($k);\n              $this->emitChoices($v);\n              continue;\n          }\n          $id = sprintf(\"%s-%s\", $this->id, $uid++);\n?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\"\n            for=\"<?php echo $id; ?>\">\n        <input id=\"<?php echo $id; ?>\" type=\"<?php echo $type; ?>\"\n            name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value[$k]) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo Format::htmlchars($k); ?>\"/>\n        <?php\n        if ($v) {\n            echo Format::viewableImages($v);\n        } ?>\n        </label>\n<?php   }\n    }\n\n    function renderSectionBreak($label) { ?>\n        <div><?php echo Format::htmlchars($label); ?></div>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (count($data)) {\n            if (!isset($data[$this->name]))\n                return array();\n            return $this->collectValues($data[$this->name], $this->field->getChoices());\n        }\n        return parent::getValue();\n    }\n\n    function collectValues($data, $choices) {\n        $value = array();\n        foreach ($choices as $k => $v) {\n            if (is_array($v))\n                $value = array_merge($value, $this->collectValues($data, $v));\n            elseif (@in_array($k, $data))\n                $value[$k] = $v;\n        }\n        return $value;\n    }\n}\n\n/**\n * An extension to the BoxChoicesWidget which will render complex choices in\n * tabs.\n */\nclass TabbedBoxChoicesWidget extends BoxChoicesWidget {\n    function render($options=array()) {\n        $tabs = array();\n        foreach ($this->field->getChoices() as $label=>$group) {\n            if (is_array($group)) {\n                $tabs[$label] = $group;\n            }\n            else {\n                $this->emitChoices(array($label=>$group));\n            }\n        }\n        if ($tabs) {\n            ?>\n            <div>\n            <ul class=\"alt tabs\">\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $active = $i++ == 0; ?>\n                <li <?php if ($active) echo 'class=\"active\"';\n                  ?>><a href=\"#<?php echo sprintf('%s-%s', $this->name, Format::slugify($label));\n                  ?>\"><?php echo Format::htmlchars($label); ?></a></li>\n<?php       } ?>\n            </ul>\n<?php       $i = 0;\n            foreach ($tabs as $label => $group) {\n                $first = $i++ == 0; ?>\n                <div class=\"tab_content <?php if (!$first) echo 'hidden'; ?>\" id=\"<?php\n                  echo sprintf('%s-%s', $this->name, Format::slugify($label));?>\">\n<?php           $this->emitChoices($group); ?>\n                </div>\n<?php       } ?>\n            </div>\n<?php   }\n    }\n}\n\n/**\n* TimezoneWidget extends ChoicesWidget to add auto-detect and select2 search\n* options\n*\n**/\nclass TimezoneWidget extends ChoicesWidget {\n\n    function render($options=array()) {\n        parent::render($options);\n        $config = $this->field->getConfiguration();\n        if (@$config['autodetect']) {\n        ?>\n        <button type=\"button\" class=\"action-button\" onclick=\"javascript:\n            $('head').append($('<script>').attr('src', '<?php\n            echo ROOT_PATH; ?>js/jstz.min.js'));\n            var recheck = setInterval(function() {\n                if (window.jstz !== undefined) {\n                    clearInterval(recheck);\n                    var zone = jstz.determine();\n                    $('#<?php echo $this->id; ?>').val(zone.name()).trigger('change');\n\n                }\n            }, 100);\n            return false;\"\n            style=\"vertical-align:middle\">\n            <i class=\"icon-map-marker\"></i> <?php echo __('Auto Detect'); ?>\n        </button>\n        <?php\n        } ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('#<?php echo $this->id; ?>').select2({\n                    allowClear: true,\n                    width: '300px'\n                });\n            });\n        </script>\n      <?php\n    }\n}\n\nclass CheckboxWidget extends Widget {\n    function __construct($field) {\n        parent::__construct($field);\n        $this->name = '_field-checkboxes';\n    }\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value))\n            $this->value = $this->field->get('default');\n        $classes = array('checkbox');\n        if (isset($config['classes']))\n            $classes = array_merge($classes, (array) $config['classes']);\n        ?>\n        <label class=\"<?php echo implode(' ', $classes); ?>\">\n        <input id=\"<?php echo $this->id; ?>\"\n            type=\"checkbox\" name=\"<?php echo $this->name; ?>[]\" <?php\n            if ($this->value) echo 'checked=\"checked\"'; ?> value=\"<?php\n            echo $this->field->get('id'); ?>\"/>\n        <?php\n        if ($config['desc']) {\n            echo Format::viewableImages($config['desc']);\n        } ?>\n        </label>\n<?php\n    }\n\n    function getValue() {\n        $data = $this->field->getSource();\n        if (is_array($data)) {\n            if (isset($data[$this->name]))\n                return @in_array($this->field->get('id'),\n                        $data[$this->name]);\n            // initial value set on source\n            if (isset($data[$this->field->get('id')]))\n                return $data[$this->field->get('id')];\n        }\n\n        if (!$data && isset($this->value))\n            return $this->value;\n\n\n        return parent::getValue();\n    }\n\n    function getJsValueGetter($id='%s') {\n        return sprintf('%s.is(\":checked\")', $id);\n    }\n\n}\n\nclass DatetimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        global $cfg;\n\n        $config = $this->field->getConfiguration();\n        $timezone = $this->field->getTimezone();\n        $dateFormat = $cfg->getDateFormat(true);\n        $timeFormat = $cfg->getTimeFormat(true);\n        if (!isset($this->value) && ($default=$this->field->get('default')))\n            $this->value = $default;\n\n        if ($this->value == 0)\n            $this->value = '';\n\n        if ($this->value) {\n            $datetime = Format::parseDateTime($this->value);\n            if ($config['time'])\n                // Convert to user's timezone for update.\n                $datetime->setTimezone($timezone);\n\n            // Get formatted date\n            $this->value = Format::date($datetime->getTimestamp(), false,\n                        false, $timezone ? $timezone->getName() : 'UTC');\n            // Get formatted time\n            if ($config['time']) {\n                 $this->value .=' '.Format::time($datetime->getTimestamp(),\n                         false, $timeFormat, $timezone ?\n                         $timezone->getName() : 'UTC');\n            }\n\n        } else {\n            // For timezone display purposes\n            $datetime = new DateTime('now');\n            $datetime->setTimezone($timezone);\n        }\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo $this->value; ?>\"\n            size=\"<?php $config['time'] ? 20 : 12; ?>\"\n            autocomplete=\"off\" class=\"dp\" />\n        <?php\n        // Timezone hint\n        // Show timzone hit by default but allow field to turn it off.\n        $showtimezone = true;\n        if (isset($config['showtimezone']))\n            $showtimezone = $config['showtimezone'];\n\n        if ($datetime && $showtimezone) {\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n        ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').<?php echo\n                $config['time'] ? 'datetimepicker':'datepicker';?>({\n                    <?php\n                    if ($dt=$this->field->getMinDateTime())\n                        echo sprintf(\"minDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    if ($dt=$this->field->getMaxDateTime())\n                        echo sprintf(\"maxDate: new Date(%s),\\n\", $dt->format('U')*1000);\n                    elseif (!$config['future'])\n                        echo \"maxDate: new Date().getTime(),\\n\";\n\n                    // Set time options\n                    if ($config['time']) {\n                        // Set Timezone\n                        echo sprintf(\"timezone: %s,\\n\",\n                                ($datetime->getOffset()/60));\n                        echo sprintf(\"\n                                controlType: 'select',\\n\n                                timeInput: true,\\n\n                                timeFormat: \\\"%s\\\",\\n\",\n                                Format::dtfmt_php2js($timeFormat));\n                    }\n                    ?>\n                    numberOfMonths: 2,\n                    showButtonPanel: true,\n                    buttonImage: './images/cal.png',\n                    showOn:'both',\n                    dateFormat: '<?php echo\n                        Format::dtfmt_php2js($dateFormat); ?>'\n                });\n            });\n        </script>\n        <?php\n    }\n\n    /**\n     * Function: getValue\n     * Combines the datepicker date value and the time dropdown selected\n     * time value into a single date and time string value in DateTime::W3C\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            if (($dt = Format::parseDateTime($value))) {\n                // Effective timezone for the selection\n                if (($timezone = $this->field->getTimezone()))\n                    $dt->setTimezone($timezone);\n                // Format date time to universal format\n                $value = $dt->format('Y-m-d H:i:s T');\n            }\n        }\n\n        return $value;\n    }\n}\n\nclass TimePickerWidget extends Widget {\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        if (!isset($this->value) && ($default=$this->field->get('default')))\n            $this->value = $default;\n\n        // For timezone display purposes only - for now\n        $datetime = new DateTime('now');\n        // Selection timezone\n        $datetime->setTimezone($this->field->getTimeZone());\n\n        if ($this->value) {\n            // TODO: Reformat time here to match settings\n        }\n\n        ?>\n        <input type=\"text\" name=\"<?php echo $this->name; ?>\"\n            id=\"<?php echo $this->id; ?>\" style=\"display:inline-block;width:auto\"\n            value=\"<?php echo $this->value; ?>\"\n            size=\"10\"\n            autocomplete=\"off\"  />\n        <?php\n        // Timezone hint\n        // Show timzone hit by default but allow field to turn it off.\n        $showtimezone = true;\n        if (isset($config['showtimezone']))\n            $showtimezone = $config['showtimezone'];\n\n        if ($showtimezone) {\n            echo sprintf('&nbsp;<span class=\"faded\">(<a href=\"#\"\n                        data-placement=\"top\" data-toggle=\"tooltip\"\n                        title=\"%s\">%s</a>)</span>',\n                    $datetime->getTimezone()->getName(),\n                    $datetime->format('T'));\n        }\n        ?>\n        <script type=\"text/javascript\">\n            $(function() {\n                $('input[name=\"<?php echo $this->name; ?>\"]').timepicker({\n                    <?php\n                    // Set time options\n                    echo sprintf(\"\n                            controlType: 'select',\\n\n                            timeInput: true,\\n\n                            timeFormat: \\\"%s\\\",\\n\",\n                            \"hh:mm tt\");\n                    echo sprintf(\"timezone: %s\\n\",\n                            ($datetime->getOffset()/60));\n                    ?>\n                });\n            });\n        </script>\n        <?php\n    }\n\n    /**\n     * Function: getValue\n     */\n    function getValue() {\n        global $cfg;\n\n        if ($value = parent::getValue()) {\n            // TODO: Return ISO format.\n        }\n\n        return $value;\n    }\n}\nclass SectionBreakWidget extends Widget {\n    function render($options=array()) {\n        ?><div class=\"form-header section-break\"><h3><?php\n        echo Format::htmlchars($this->field->getLocal('label'));\n        ?></h3><em><?php echo Format::display($this->field->getLocal('hint'));\n        ?></em></div>\n        <?php\n    }\n}\n\nclass ThreadEntryWidget extends Widget {\n    function render($options=array()) {\n\n        $config = $this->field->getConfiguration();\n        $object_id = false;\n        if ($options['client']) {\n            $namespace = $options['draft-namespace']\n                ?: 'ticket.client';\n             $object_id = substr(session_id(), -12);\n        } else {\n            $namespace = $options['draft-namespace'] ?: 'ticket.staff';\n        }\n\n        list($draft, $attrs) = Draft::getDraftAndDataAttrs($namespace, $object_id, $this->value);\n        ?>\n        <textarea style=\"width:100%;\" name=\"<?php echo $this->name; ?>\"\n            placeholder=\"<?php echo Format::htmlchars($this->field->get('placeholder')); ?>\"\n            class=\"<?php if ($config['html']) echo 'richtext';\n                ?> draft draft-delete\" <?php echo $attrs; ?>\n            cols=\"21\" rows=\"8\" style=\"width:80%;\"><?php echo\n            ThreadEntryBody::clean($this->value ?: $draft); ?></textarea>\n    <?php\n        if (!$config['attachments'])\n            return;\n\n        $attachments = $this->getAttachments($config);\n        print $attachments->render($options);\n        foreach ($attachments->getMedia() as $type=>$urls) {\n            foreach ($urls as $url)\n                Form::emitMedia($url, $type);\n        }\n    }\n\n    function getAttachments($config=false) {\n        if (!$config)\n            $config = $this->field->getConfiguration();\n\n        $field = new FileUploadField(array(\n            'id'=>'attach',\n            'name'=>'attach:' . $this->field->get('id'),\n            'configuration'=>$config)\n        );\n        $field->setForm($this->field->getForm());\n        return $field;\n    }\n\n    function parseValue() {\n        parent::parseValue();\n        if (isset($this->value)) {\n            $value = $this->value;\n            $config = $this->field->getConfiguration();\n            // Trim spaces based on text input type.\n            // Preserve original input if not empty.\n            if ($config['html'])\n                $this->value = trim($value, \" <>br/\\t\\n\\r\") ? $value : '';\n            else\n                $this->value = trim($value) ? $value : '';\n        }\n    }\n\n}\n\nclass FileUploadWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            '/css/filedrop.css',\n        ),\n    );\n\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $name = $this->field->getFormName();\n        $id = substr(md5(spl_object_hash($this)), 10);\n        $mimetypes = array_filter($config['__mimetypes'],\n            function($t) { return strpos($t, '/') !== false; }\n        );\n        $maxfilesize = ($config['size'] ?: 1048576) / 1048576;\n        $files = array();\n        $new = $this->field->getClean(false);\n\n        foreach ($this->field->getAttachments() as $att) {\n            unset($new[$att->file_id]);\n            $files[] = array(\n                'id' => $att->file->getId(),\n                'name' => $att->getFilename(),\n                'type' => $att->file->getType(),\n                'size' => $att->file->getSize(),\n                'download_url' => $att->file->getDownloadUrl(),\n            );\n        }\n\n        // Add in newly added files not yet saved (if redisplaying after an\n        // error)\n        if ($new) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($new)))\n                ->all();\n\n            foreach ($F as $f) {\n                $f->tmp_name = $new[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n        //see if the attachment is saved in the session for this specific field\n        if ($sessionAttachment = $_SESSION[':form-data'][$this->field->get('name')]) {\n            $F = AttachmentFile::objects()\n                ->filter(array('id__in' => array_keys($sessionAttachment)))\n                ->all();\n\n            foreach ($F as $f) {\n                $f->tmp_name = $sessionAttachment[$f->getId()];\n                $files[] = array(\n                    'id' => $f->getId(),\n                    'name' => $f->getName(),\n                    'type' => $f->getType(),\n                    'size' => $f->getSize(),\n                    'download_url' => $f->getDownloadUrl(),\n                );\n            }\n        }\n\n         // Set default $field_id\n        $field_id = $this->field->get('id');\n        // Get Form Type\n        $type = $this->field->getForm()->type;\n        // Determine if for Ticket/Task/Custom\n        if ($type) {\n            if ($type == 'T')\n                $field_id = 'ticket/attach';\n            elseif ($type == 'A')\n                $field_id = 'task/attach';\n        }\n\n        ?><div id=\"<?php echo $id;\n            ?>\" class=\"filedrop\"><div class=\"files\"></div>\n            <div class=\"dropzone\"><i class=\"icon-upload\"></i>\n            <?php echo sprintf(\n                __('Drop files here or %s choose them %s'),\n                '<a href=\"#\" class=\"manual\">', '</a>'); ?>\n        <input type=\"file\" multiple=\"multiple\"\n            id=\"file-<?php echo $id; ?>\" style=\"display:none;\"\n            accept=\"<?php echo implode(',', $config['__mimetypes']); ?>\"/>\n        </div></div>\n        <script type=\"text/javascript\">\n        $(function(){$('#<?php echo $id; ?> .dropzone').filedropbox({\n          url: 'ajax.php/form/upload/<?php echo $field_id; ?>',\n          link: $('#<?php echo $id; ?>').find('a.manual'),\n          paramname: 'upload[]',\n          fallback_id: 'file-<?php echo $id; ?>',\n          allowedfileextensions: <?php echo JsonDataEncoder::encode(\n            $config['__extensions'] ?: array()); ?>,\n          allowedfiletypes: <?php echo JsonDataEncoder::encode(\n            $mimetypes); ?>,\n          maxfiles: <?php echo $config['max'] ?: 20; ?>,\n          maxfilesize: <?php echo str_replace(',', '.', $maxfilesize); ?>,\n          name: '<?php echo $name; ?>[]',\n          files: <?php echo JsonDataEncoder::encode($files); ?>\n        });});\n        </script>\n<?php\n    }\n\n    function getValue() {\n        $ids = array();\n        // Handle manual uploads (IE<10)\n        if ($_SERVER['REQUEST_METHOD'] == 'POST' && isset($_FILES[$this->name])) {\n            foreach (AttachmentFile::format($_FILES[$this->name]) as $file) {\n                try {\n                    $F = $this->field->uploadFile($file);\n                    $ids[$F->getId()] = $F->getName();\n                }\n                catch (FileUploadError $ex) {}\n            }\n            return $ids;\n        }\n\n        // Files uploaded here MUST have been uploaded by this user and\n        // identified in the session\n        //\n        // If no value was sent, assume an empty list\n        if (!($files = parent::getValue()))\n            return array();\n\n        if ($_SERVER['REQUEST_METHOD'] == 'POST') {\n            $_files = array();\n            foreach ($files as $info) {\n                if (@list($id, $name) = explode(',', $info, 2))\n                    $_files[$id] = $name;\n            }\n            $files = $_files;\n        }\n\n        $allowed = array();\n        // Files already attached to the field are allowed\n        foreach ($this->field->getFiles() as $F) {\n            // FIXME: This will need special porting in v1.10\n            $allowed[$F->id] = $F->getName();\n        }\n\n        // New files uploaded in this session are allowed\n        if (isset($_SESSION[':uploadedFiles']))\n            $allowed += $_SESSION[':uploadedFiles'];\n\n        // Canned attachments initiated by this session\n        if (isset($_SESSION[':cannedFiles']))\n           $allowed += $_SESSION[':cannedFiles'];\n\n        // Parse the files and make sure it's allowed.\n        foreach ($files as $id => $name) {\n            if (!isset($allowed[$id]))\n                continue;\n\n            // Keep the values as the IDs\n            $ids[$id] = $name ?: $allowed[$id];\n        }\n\n        return $ids;\n    }\n}\n\nclass FileUploadError extends Exception {}\n\nclass FreeTextField extends FormField {\n    static $widget = 'FreeTextWidget';\n    protected $attachments;\n\n    function getConfigurationOptions() {\n        return array(\n            'content' => new TextareaField(array(\n                'configuration' => array('html' => true, 'size'=>'large'),\n                'label'=>__('Content'), 'required'=>true, 'default'=>'',\n                'hint'=>__('Free text shown in the form, such as a disclaimer'),\n            )),\n            'attachments' => new FileUploadField(array(\n                'id'=>'attach',\n                'label' => __('Attachments'),\n                'name'=>'files',\n                'configuration' => array('extensions'=>'')\n            )),\n        );\n    }\n\n    function hasData() {\n        return false;\n    }\n\n    function isBlockLevel() {\n        return true;\n    }\n\n    function isEditableToStaff() {\n        return $this->isVisibleToStaff();\n    }\n\n    function isEditableToUsers() {\n        return $this->isVisibleToUsers();\n    }\n\n    /* utils */\n\n    function to_config($config) {\n        if ($config && isset($config['attachments']))\n            $keepers = $config['attachments'];\n        $this->getAttachments()->keepOnlyFileIds($keepers);\n\n        return $config;\n    }\n\n    function db_cleanup($field=false) {\n\n        if ($field && $this->getFiles())\n            $this->getAttachments()->deleteAll();\n    }\n\n    function getAttachments() {\n        if (!isset($this->attachments))\n            $this->attachments = GenericAttachments::forIdAndType($this->get('id'), 'I');\n\n        return $this->attachments ?: array();\n    }\n\n    function getFiles() {\n        if (!isset($this->files)) {\n            $files = array();\n            if (($attachments=$this->getAttachments()))\n                foreach ($attachments->all() as $a)\n                    $files[] = $a->getFile();\n            $this->files = $files;\n        }\n        return $this->files;\n    }\n}\n\nclass FreeTextWidget extends Widget {\n    function render($options=array()) {\n        $config = $this->field->getConfiguration();\n        $class = $config['classes'] ?: 'thread-body bleed';\n        ?><div class=\"<?php echo $class; ?>\"><?php\n        if ($label = $this->field->getLocal('label')) { ?>\n            <h3><?php\n            echo Format::htmlchars($label);\n        ?></h3><?php\n        }\n        if ($hint = $this->field->getLocal('hint')) { ?>\n        <em><?php\n            echo Format::display($hint);\n        ?></em><?php\n        } ?>\n        <div><?php\n            echo Format::viewableImages($config['content']); ?></div>\n        </div>\n        <?php\n        if (($attachments = $this->field->getAttachments()) && count($attachments)) { ?>\n            <section class=\"freetext-files\">\n            <div class=\"title\"><?php echo __('Related Resources'); ?></div>\n            <?php foreach ($attachments->all() as $attach) {\n                $filename = Format::htmlchars($attach->getFilename());\n                ?>\n                <div class=\"file\">\n                <a href=\"<?php echo $attach->file->getDownloadUrl(); ?>\"\n                    target=\"_blank\" download=\"<?php echo $filename; ?>\"\n                    class=\"truncate no-pjax\">\n                    <i class=\"icon-file\"></i>\n                    <?php echo $filename; ?>\n                </a>\n                </div>\n            <?php } ?>\n        </section>\n        <?php }\n    }\n}\n\nclass ColorPickerWidget extends Widget {\n    static $media = array(\n        'css' => array(\n            'css/spectrum.css',\n        ),\n        'js' => array(\n            'js/spectrum.js',\n        ),\n    );\n\n    function render($options=array()) {\n        ?><input type=\"color\"\n            id=\"<?php echo $this->id; ?>\"\n            name=\"<?php echo $this->name; ?>\"\n            value=\"<?php echo Format::htmlchars($this->value); ?>\"/><?php\n    }\n}\n\nclass VisibilityConstraint {\n    static $operators = array(\n        'eq' => 1,\n        'neq' => 1,\n    );\n\n    const HIDDEN =      0x0001;\n    const VISIBLE =     0x0002;\n\n    var $initial;\n    var $constraint;\n\n    function __construct($constraint, $initial=self::VISIBLE) {\n        $this->constraint = $constraint;\n        $this->initial = $initial;\n    }\n\n    function emitJavascript($field) {\n\n        if (!$this->constraint->constraints)\n            return;\n\n        $func = 'recheck_'.$field->getWidget()->id;\n        $form = $field->getForm();\n?>\n    <script type=\"text/javascript\">\n      !(function() {\n        var <?php echo $func; ?> = function() {\n          var target = $('#field<?php echo $field->getWidget()->id; ?>');\n<?php   $fields = $this->getAllFields($this->constraint);\n        foreach ($fields as $f) {\n            if (!($field = $form->getField($f)))\n                continue;\n            echo sprintf('var %1$s = x = $(\"#%1$s\");',\n                $field->getWidget()->id);\n        }\n        $expression = $this->compileQ($this->constraint, $form);\n?>\n          if (<?php echo $expression; ?>) {\n            target.slideDown('fast', function (){\n                $(this).trigger('show');\n                });\n          } else {\n            target.slideUp('fast', function (){\n                $(this).trigger('hide');\n                });\n          }\n        };\n\n<?php   foreach ($fields as $f) {\n            if (!($field=$form->getField($f)))\n                continue;\n            $w = $field->getWidget();\n?>\n        $('#<?php echo $w->id; ?>').on('change', <?php echo $func; ?>);\n        $('#field<?php echo $w->id; ?>').on('show hide', <?php\n                echo $func; ?>);\n<?php   } ?>\n      })();\n    </script><?php\n    }\n\n    /**\n     * Determines if the field was visible when the form was submitted\n     */\n    function isVisible($field) {\n\n        // Assume initial visibility if constraint is not provided.\n        if (!$this->constraint->constraints)\n            return $this->initial == self::VISIBLE;\n\n\n        return $this->compileQPhp($this->constraint, $field);\n    }\n\n    static function splitFieldAndOp($field) {\n        if (false !== ($last = strrpos($field, '__'))) {\n            $op = substr($field, $last + 2);\n            if (isset(static::$operators[$op]))\n                $field = substr($field, 0, strrpos($field, '__'));\n        }\n        return array($field, $op);\n    }\n\n    function compileQPhp(Q $Q, $field) {\n        if (!($form = $field->getForm())) {\n            return $this->initial == self::VISIBLE;\n        }\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQPhp($value, $field);\n            }\n            else {\n                @list($f, $op) = self::splitFieldAndOp($c);\n                $field = $form->getField($f);\n                $wval = $field ? $field->getClean() : null;\n                $values = explode('|', $value);\n                switch ($op) {\n                case 'neq':\n                    $expr[] = ($wval && !in_array($wval, $values) && $field->isVisible());\n                    break;\n                case 'eq':\n                case null:\n                    $expr[] = (in_array($wval, $values) && $field->isVisible());\n                }\n            }\n        }\n        $glue = $Q->isOred()\n            ? function($a, $b) { return $a || $b; }\n            : function($a, $b) { return $a && $b; };\n        $initial = !$Q->isOred();\n        $expression = array_reduce($expr, $glue, $initial);\n        if ($Q->isNegated)\n            $expression = !$expression;\n        return $expression;\n    }\n\n    function getAllFields(Q $Q, &$fields=array()) {\n        foreach ($Q->constraints as $c=>$value) {\n            if ($c instanceof Q) {\n                $this->getAllFields($c, $fields);\n            }\n            else {\n                @list($f) = self::splitFieldAndOp($c);\n                $fields[$f] = true;\n            }\n        }\n        return array_keys($fields);\n    }\n\n    function compileQ($Q, $form) {\n        $expr = array();\n        foreach ($Q->constraints as $c=>$value) {\n            if ($value instanceof Q) {\n                $expr[] = $this->compileQ($value, $form);\n            }\n            else {\n                list($f, $op) = self::splitFieldAndOp($c);\n                if (!($field=$form->getField($f))) continue;\n                $widget = $field->getWidget();\n                $id = $widget->id;\n                switch ($op) {\n                case 'neq':\n                    $expr[] = sprintf('(%s.is(\":visible\") && !(%s))',\n                            $id, $widget->getJsComparator($value, $id));\n                    break;\n                case 'eq':\n                case null:\n                    $expr[] = sprintf('(%s.is(\":visible\") && (%s))',\n                            $id, $widget->getJsComparator($value, $id));\n                }\n            }\n        }\n        $glue = $Q->isOred() ? ' || ' : ' && ';\n        $expression = implode($glue, $expr);\n        if (count($expr) > 1)\n            $expression = '('.$expression.')';\n        if ($Q->isNegated)\n            $expression = '!'.$expression;\n        return $expression;\n    }\n}\n\nclass AssignmentForm extends Form {\n\n    static $id = 'assign';\n    var $_assignee = null;\n    var $_assignees = null;\n\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'assignee' => new AssigneeField(array(\n                    'id'=>1, 'label' => __('Assignee'),\n                    'flags' => hexdec(0X450F3), 'required' => true,\n                    'validator-error' => __('Assignee selection required'),\n                    'configuration' => array(\n                        'criteria' => array(\n                            'available' => true,\n                            ),\n                       ),\n                    )\n                ),\n            'refer' => new BooleanField(array(\n                    'id'=>2, 'label'=>'', 'required'=>false,\n                    'default'=>false,\n                    'configuration'=>array(\n                        'desc' => __('Maintain referral access to current assignees'))\n                    )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 3, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        if (isset($this->_assignees))\n            $fields['assignee']->setChoices($this->_assignees);\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('assignee')))\n            return false;\n\n        // Do additional assignment validation\n        if (!($assignee = $this->getAssignee())) {\n            $f->addError(__('Unknown assignee'));\n        } elseif ($assignee instanceof Staff) {\n            // Make sure the agent is available\n            if (!$assignee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        } elseif ($assignee instanceof Team) {\n            // Make sure the team is active and has members\n            if (!$assignee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$assignee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setAssignees($assignees) {\n        $this->_assignees = $assignees;\n        $this->_fields = array();\n    }\n\n    function getAssignees() {\n        return $this->_assignees;\n    }\n\n    function getAssignee() {\n\n        if (!isset($this->_assignee))\n            $this->_assignee = $this->getField('assignee')->getClean();\n\n        return $this->_assignee;\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n\n    function refer() {\n        return $this->getField('refer')->getClean();\n    }\n}\n\nclass ClaimForm extends AssignmentForm {\n\n    var $_fields;\n\n    function setFields($fields) {\n        $this->_fields = $fields;\n        parent::setFields($fields);\n    }\n\n    function getFields() {\n\n        if ($this->_fields)\n            return $this->_fields;\n\n        $fields = parent::getFields();\n\n        // Disable && hide assignee field selection\n        if (isset($fields['assignee'])) {\n            $visibility = new VisibilityConstraint(\n                    new Q(array()), VisibilityConstraint::HIDDEN);\n\n            $fields['assignee']->set('visibility', $visibility);\n        }\n\n        // Change coments placeholder to reflect claim\n        if (isset($fields['comments'])) {\n            $fields['comments']->configure('placeholder',\n                    __('Optional reason for the claim'));\n        }\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n}\n\nclass ReleaseForm extends Form {\n    static $id = 'unassign';\n\n    function getFields() {\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'comments' => new TextareaField(array(\n                    'id' => 1, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for releasing assignment'),\n                        ),\n                    )\n                ),\n            );\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n        if (!parent::isValid($include))\n            return false;\n\n        return !$this->errors();\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass MarkAsForm extends Form {\n    static $id = 'markAs';\n\n    function getFields() {\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'comments' => new TextareaField(array(\n                    'id' => 1, 'label'=> '', 'required'=>false, 'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for marking ticket as (un)answered'),\n                        ),\n                    )\n                ),\n            );\n\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n    function isValid($include=false) {\n        if (!parent::isValid($include))\n            return false;\n\n        return !$this->errors();\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\nclass ReferralForm extends Form {\n\n    static $id = 'refer';\n    var $_target = null;\n    var $_choices = null;\n    var $_prompt = '';\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'target' => new ChoiceField(array(\n                    'id'=>1,\n                    'label' => __('Referee'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Selection required'),\n                    'choices' => array(\n                    'agent' => __('Agent'),\n                    'team'  => __('Team'),\n                                'dept'  => __('Department'),\n                               ),\n                            )\n                ),\n            'agent' => new AgentSelectionField(array(\n                    'id'=>2,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Agent selection required'),\n                    'configuration'=>array('prompt'=>__('Select Agent')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'agent')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'team' => new ChoiceField(array(\n                    'id'=>3,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Team selection required'),\n                    'configuration'=>array('prompt'=>__('Select Team')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'team')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'dept' => new DepartmentField(array(\n                    'id'=>4,\n                    'label' => '',\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Dept. selection required'),\n                    'configuration'=>array('prompt'=>__('Select Department')),\n                            'visibility' => new VisibilityConstraint(\n                                    new Q(array('target__eq'=>'dept')),\n                                    VisibilityConstraint::HIDDEN\n                              ),\n                            )\n                ),\n            'comments' => new TextareaField(array(\n                    'id' => 5,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the referral'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function getField($name) {\n\n        if (($fields = $this->getFields())\n                && isset($fields[$name]))\n            return $fields[$name];\n    }\n\n\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include) || !($f=$this->getField('target')))\n            return false;\n\n        // Do additional assignment validation\n        $referee = $this->getReferee();\n        switch (true) {\n        case $referee instanceof Staff:\n            // Make sure the agent is available\n            if (!$referee->isAvailable())\n                $f->addError(__('Agent is unavailable for assignment'));\n        break;\n        case $referee instanceof Team:\n            // Make sure the team is active and has members\n            if (!$referee->isActive())\n                $f->addError(__('Team is disabled'));\n            elseif (!$referee->getNumMembers())\n                $f->addError(__('Team does not have members'));\n        break;\n        case $referee instanceof Dept:\n        break;\n        default:\n            $f->addError(__('Unknown selection'));\n        }\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        'FormUtils', $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n    }\n\n    function setChoices($field, $choices, $prompt='') {\n\n        if (!($f= $this->getField($field)))\n           return;\n\n        $f->set('choices', $choices);\n\n        return $f;\n    }\n\n    function getReferee() {\n\n        $target = $this->getField('target')->getClean();\n        if (!$target || !($f=$this->getField($target)))\n            return null;\n\n        $id = $f->getClean();\n        switch($target) {\n        case 'agent':\n            return Staff::lookup($id);\n        case 'team':\n            return Team::lookup($id);\n        case 'dept':\n            return Dept::lookup($id);\n        }\n    }\n\n    function getComments() {\n        return $this->getField('comments')->getClean();\n    }\n}\n\n\nclass TransferForm extends Form {\n\n    static $id = 'transfer';\n    var $_dept = null;\n\n    function __construct($source=null, $options=array()) {\n        parent::__construct($source, $options);\n    }\n\n    function getFields() {\n\n        if ($this->fields)\n            return $this->fields;\n\n        $fields = array(\n            'dept' => new DepartmentField(array(\n                    'id'=>1,\n                    'label' => __('Department'),\n                    'flags' => hexdec(0X450F3),\n                    'required' => true,\n                    'validator-error' => __('Department selection is required'),\n                    )\n                ),\n            'refer' => new BooleanField(array(\n                'id'=>2, 'label'=>'', 'required'=>false, 'default'=>false,\n                'configuration'=>array(\n                    'desc' => 'Maintain referral access to current department')\n            )),\n            'comments' => new TextareaField(array(\n                    'id' => 3,\n                    'label'=> '',\n                    'required'=>false,\n                    'default'=>'',\n                    'configuration' => array(\n                        'html' => true,\n                        'size' => 'small',\n                        'placeholder' => __('Optional reason for the transfer'),\n                        ),\n                    )\n                ),\n            );\n\n        $this->setFields($fields);\n\n        return $this->fields;\n    }\n\n    function isValid($include=false) {\n\n        if (!parent::isValid($include))\n            return false;\n\n        // Do additional validations\n        if (!($dept = $this->getDept()))\n            $this->getField('dept')->addError(\n                    __('Unknown department'));\n\n        return !$this->errors();\n    }\n\n    function render($options=array()) {\n\n        switch(strtolower($options['template'])) {\n        case 'simple':\n            $inc = STAFFINC_DIR . 'templates/dynamic-form-simple.tmpl.php';\n            break;\n        default:\n            throw new Exception(sprintf(__('%s: Unknown template style %s'),\n                        get_class(), $options['template']));\n        }\n\n        $form = $this;\n        include $inc;\n\n    }\n\n    function refer() {\n        return $this->getField('refer')->getClean();\n    }\n\n    function getDept() {\n\n        if (!isset($this->_dept)) {\n            if (($id = $this->getField('dept')->getClean()))\n                $this->_dept = Dept::lookup($id);\n        }\n\n        return $this->_dept;\n    }\n\n    function hideDisabled() {\n        global $thisstaff;\n\n        if ($f = $this->getField('dept')) {\n            $f->configure('staff', $thisstaff);\n            $f->configure('hideDisabled', true);\n        }\n    }\n}\n\n/**\n * FieldUnchanged\n *\n * Thrown in the to_database() method to indicate the value should not be\n * saved in the database (it wasn't changed in the request)\n */\nclass FieldUnchanged extends Exception {}\n?>\n"], "filenames": ["bootstrap.php", "include/ajax.draft.php", "include/class.file.php", "include/class.forms.php"], "buggy_code_start_loc": [46, 56, 1057, 3913], "buggy_code_end_loc": [46, 128, 1077, 3913], "fixing_code_start_loc": [47, 56, 1057, 3914], "fixing_code_end_loc": [56, 122, 1089, 3918], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository osticket/osticket prior to v1.16.6.", "other": {"cve": {"id": "CVE-2023-1320", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-10T16:15:11.010", "lastModified": "2023-03-13T03:47:55.653", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository osticket/osticket prior to v1.16.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:enhancesoft:osticket:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.6", "matchCriteriaId": "2B613AD0-4A4B-4AE9-8971-66464AEE67B6"}]}]}], "references": [{"url": "https://github.com/osticket/osticket/commit/86f9693dc64ed54220ed6c10e13e824ca4f6aacf", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/c2bb34ac-452d-4624-a1b9-c5b54f52f0cd", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/osticket/osticket/commit/86f9693dc64ed54220ed6c10e13e824ca4f6aacf"}}