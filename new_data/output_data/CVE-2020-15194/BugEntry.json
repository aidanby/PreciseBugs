{"buggy_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing CPUDevice = Eigen::ThreadPoolDevice;\n\ntemplate <typename T>\nclass SparseFillEmptyRowsOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const int kIndicesInput = 0;\n    const int kValuesInput = 1;\n    const int kDenseShapeInput = 2;\n    const int kDefaultValueInput = 3;\n\n    const int kOutputIndicesOutput = 0;\n    const int kOutputValuesOutput = 1;\n    const int kEmptyRowIndicatorOutput = 2;\n    const int kReverseIndexMapOutput = 3;\n\n    const Tensor& indices_t = context->input(kIndicesInput);\n    const Tensor& values_t = context->input(kValuesInput);\n    const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n    const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n                errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                                        dense_shape_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                        indices_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),\n                errors::InvalidArgument(\"values must be a vector, saw: \",\n                                        values_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n                errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                                        default_value_t.shape().DebugString()));\n    // TODO(ebrevdo): add shape checks between values, indices,\n    // dense_shape.  Also add check that dense rank > 0.\n\n    const T& default_value = default_value_t.scalar<T>()();\n    const auto indices = indices_t.matrix<int64>();\n    const auto values = values_t.vec<T>();\n    const auto dense_shape = dense_shape_t.vec<int64>();\n\n    const int64 N = indices_t.shape().dim_size(0);\n    const int64 dense_rows = dense_shape(0);\n\n    bool* empty_row_indicator = nullptr;\n    if (context->output_required(kEmptyRowIndicatorOutput)) {\n      Tensor* empty_row_indicator_t = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(kEmptyRowIndicatorOutput,\n                                              TensorShape({dense_rows}),\n                                              &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t->vec<bool>().data();\n    }\n    int64* reverse_index_map = nullptr;\n    if (context->output_required(kReverseIndexMapOutput)) {\n      Tensor* reverse_index_map_t = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(kReverseIndexMapOutput,\n                                                       TensorShape({N}),\n                                                       &reverse_index_map_t));\n      reverse_index_map = reverse_index_map_t->vec<int64>().data();\n    }\n\n    int rank = indices_t.shape().dim_size(1);\n\n    if (dense_rows == 0) {\n      OP_REQUIRES(\n          context, N == 0,\n          errors::InvalidArgument(\"Received SparseTensor with dense_shape[0] = \"\n                                  \"0 but indices.shape[0] = \",\n                                  N));\n      Tensor* output_indices_t;\n      TensorShape output_indices_shape({0, rank});\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,\n                                                       output_indices_shape,\n                                                       &output_indices_t));\n      Tensor* output_values_t;\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,\n                                                       TensorShape({0}),\n                                                       &output_values_t));\n\n      // Exit early, nothing more to do.\n      return;\n    }\n\n    bool rows_are_ordered = true;\n    int64 last_indices_row = 0;\n    std::vector<int64> csr_offset(dense_rows, 0);\n    for (int i = 0; i < N; ++i) {\n      const int64 row = indices(i, 0);\n      OP_REQUIRES(context, row >= 0 && row < dense_rows,\n                  errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \",\n                                          row, \" >= \", dense_rows));\n      ++csr_offset[row];\n      rows_are_ordered = rows_are_ordered & (row >= last_indices_row);\n      last_indices_row = row;\n    }\n    bool all_rows_full = true;\n    for (int row = 0; row < dense_rows; ++row) {\n      // csr_offset here describes the number of elements in this dense row\n      bool row_empty = (csr_offset[row] == 0);\n      if (empty_row_indicator) {\n        empty_row_indicator[row] = row_empty;\n      }\n      all_rows_full = all_rows_full & !row_empty;\n      // In filled version, each row has at least one element.\n      csr_offset[row] = std::max(csr_offset[row], int64{1});\n      // Update csr_offset to represent the number of elements up to and\n      // including dense_row + 1:\n      //  csr_offset(0) == #{elements of row 0}\n      //  csr_offset(1) == #{elements of row 1} + #{elements of row 0}\n      //  ..\n      //  csr_offset(i) == starting index for elements in row i + 1.\n      if (row > 0) {\n        csr_offset[row] += csr_offset[row - 1];\n      }\n    }\n\n    if (all_rows_full && rows_are_ordered) {\n      context->set_output(kOutputIndicesOutput, indices_t);\n      context->set_output(kOutputValuesOutput, values_t);\n      if (reverse_index_map) {\n        for (int64 i = 0; i < N; ++i) {\n          reverse_index_map[i] = i;\n        }\n      }\n    } else {\n      Tensor* output_indices_t;\n      const int64 N_full = csr_offset[dense_rows - 1];\n      TensorShape output_indices_shape({N_full, rank});\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,\n                                                       output_indices_shape,\n                                                       &output_indices_t));\n      auto output_indices = output_indices_t->matrix<int64>();\n\n      Tensor* output_values_t;\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,\n                                                       TensorShape({N_full}),\n                                                       &output_values_t));\n      auto output_values = output_values_t->vec<T>();\n\n      std::vector<int64> filled_count(dense_rows, 0);\n\n      // Fill in values for rows that are not missing\n      for (int64 i = 0; i < N; ++i) {\n        const int64 row = indices(i, 0);\n        int64& offset = filled_count[row];\n        const int64 output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;\n        offset++;  // Increment the filled count for this row.\n        std::copy_n(&indices(i, 0), rank, &output_indices(output_i, 0));\n        output_values(output_i) = values(i);\n        // We'll need this reverse index map to backprop correctly.\n        if (reverse_index_map) {\n          reverse_index_map[i] = output_i;\n        }\n      }\n\n      // Fill in values for rows that are missing\n      for (int64 row = 0; row < dense_rows; ++row) {\n        const int64 row_count = filled_count[row];\n        if (row_count == 0) {  // We haven't filled this row\n          const int64 starting_index = (row == 0) ? 0 : csr_offset[row - 1];\n          // Remaining index values were set to zero already.\n          // Just need to set the row index in the right location.\n          output_indices(starting_index, 0) = row;\n          for (int64 col = 1; col < rank; ++col) {\n            output_indices(starting_index, col) = 0;\n          }\n          output_values(starting_index) = default_value;\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNELS(type)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")     \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          SparseFillEmptyRowsOp<type>)\n\nTF_CALL_ALL_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\ntemplate <typename T>\nclass SparseFillEmptyRowsGradOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor* reverse_index_map_t;\n    const Tensor* grad_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"reverse_index_map\", &reverse_index_map_t));\n    OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n        errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                reverse_index_map_t->shape().DebugString()));\n\n    const auto reverse_index_map = reverse_index_map_t->vec<int64>();\n    const auto grad_values = grad_values_t->vec<T>();\n\n    const int64 N = reverse_index_map_t->shape().dim_size(0);\n    const int64 N_full = grad_values_t->shape().dim_size(0);\n\n    Tensor* d_values_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"d_values\", TensorShape({N}), &d_values_t));\n    auto d_values = d_values_t->vec<T>();\n    Tensor* d_default_value_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"d_default_value\", TensorShape({}),\n                                            &d_default_value_t));\n    T& d_default_value = d_default_value_t->scalar<T>()();\n    d_default_value = T();\n\n    Tensor visited_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(d) = visited.constant(false);\n\n    for (int i = 0; i < N; ++i) {\n      // Locate the index of the output of the forward prop associated\n      // with this location in the input of the forward prop.  Copy\n      // the gradient into it.  Mark it as visited.\n      d_values(i) = grad_values(reverse_index_map(i));\n      visited(reverse_index_map(i)) = true;\n    }\n    for (int j = 0; j < N_full; ++j) {\n      // The default value gradient gets the accumulated remainder of\n      // the backprop values (since the default value was used to fill\n      // in these slots in the forward calculation).\n      if (!visited(j)) {\n        d_default_value += grad_values(j);\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNELS(type)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRowsGrad\") \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          SparseFillEmptyRowsGradOp<type>)\n\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\n# Need array_grad to register gradient for Identity.\nfrom tensorflow.python.ops import array_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gradient_checker_v2 as gradient_checker\nfrom tensorflow.python.ops import math_ops\n# Need sparse_grad to register gradient for SparseToDense.\nfrom tensorflow.python.ops import sparse_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass SparseOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  def testSparseEye(self):\n    def test_one(n, m, as_tensors):\n      expected = np.eye(n, m)\n      if as_tensors:\n        m = constant_op.constant(m)\n        n = constant_op.constant(n)\n      s = sparse_ops.sparse_eye(n, m)\n      d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n      self.assertAllEqual(self.evaluate(d), expected)\n\n    for n in range(2, 10, 2):\n      for m in range(2, 10, 2):\n        # Test with n and m as both constants and tensors.\n        test_one(n, m, True)\n        test_one(n, m, False)\n\n  def testDenseFromConstantToSparse(self):\n    expected_constant = np.reshape(np.arange(24, dtype=np.int64), (3, 4, 2))\n    tensor = constant_op.constant(expected_constant)\n    sparse = sparse_ops.from_dense(tensor)\n    dense = sparse_ops.sparse_to_dense(sparse.indices, sparse.dense_shape,\n                                       sparse.values)\n    constant = self.evaluate(dense)\n    self.assertAllEqual(expected_constant, constant)\n\n  def testTransposePreservesShape(self):\n    with ops.Graph().as_default():\n      t = sparse_tensor.SparseTensor(indices=[[0, 0]],\n                                     values=[0.],\n                                     dense_shape=[3, 4])\n      self.assertTrue(t.shape.is_fully_defined)\n      transposed = sparse_ops.sparse_transpose(t)\n      self.assertAllEqual(transposed.shape, [4, 3])\n\n  def testSparseExpandDims(self):\n    for rank in range(1, 4):\n      # Create a dummy input. When rank=3, shape=[2, 4, 6].\n      shape = np.arange(1, rank + 1) * 2\n      before = np.arange(np.prod(shape)).reshape(shape)\n\n      # Make entries sparse.\n      before *= np.random.binomial(1, .2, before.shape)\n      dense_shape = before.shape\n      indices = np.array(np.where(before)).T\n      values = before[before != 0]\n\n      # Try every possible valid value of axis.\n      for axis in range(-rank - 1, rank):\n        expected_after = np.expand_dims(before, axis)\n\n        for axis_as_tensor in [False, True]:\n          dense_shape_t = constant_op.constant(dense_shape, dtype=dtypes.int64)\n          indices_t = constant_op.constant(indices)\n          values_t = constant_op.constant(values)\n          before_t = sparse_tensor.SparseTensor(\n              indices=indices_t, values=values_t, dense_shape=dense_shape_t)\n\n          if axis_as_tensor:\n            axis = constant_op.constant(axis)\n\n          s = sparse_ops.sparse_expand_dims(before_t, axis)\n          d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n          self.assertAllEqual(self.evaluate(d), expected_after)\n\n  @parameterized.parameters([\n      (math_ops.abs, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 3.0, 4.0]),\n      (math_ops.negative, [1.0, -1.0, 3.0, -4.0], [-1.0, 1.0, -3.0, 4.0]),\n      (math_ops.sign, [3.0, -2.0, 0.0, -4.0], [1.0, -1.0, 0.0, -1.0]),\n      (math_ops.square, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 9.0, 16.0]),\n  ])\n  def testUnarySparseDispatch(self, op, values, expected):\n    st = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [0, 1], [2, 0], [2, 4]],\n        values=values,\n        dense_shape=[3, 6])\n    result = op(st)\n    result_value = self.evaluate(result)\n    self.assertAllEqual(result_value.indices, st.indices)\n    self.assertAllEqual(result_value.values, expected)\n    self.assertAllEqual(result_value.dense_shape, st.dense_shape)\n\n  def testSparseToDenseGradient(self):\n\n    def f(sparse_values, default_value):\n      st = sparse_tensor.SparseTensor(\n          indices=[[0, 3, 6], [1, 4, 7], [2, 5, 8]],\n          values=sparse_values,\n          dense_shape=[3, 6, 9])\n      return sparse_ops.sparse_tensor_to_dense(st, default_value)\n\n    grads = gradient_checker.compute_gradient(\n        f, [constant_op.constant([1.0, 2.0, 3.0]),\n            constant_op.constant(0.0)])\n    epsilon = 1e-4\n    self.assertLess(gradient_checker.max_error(*grads), epsilon)\n\n  def testSparseTensorToDenseString(self):\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=['a', 'b'], dense_shape=[2, 3])\n    dense = sparse_ops.sparse_tensor_to_dense(sp)\n    expected_dense = [[b'a', b'', b''], [b'', b'', b'b']]\n    result_dense = self.evaluate(dense)\n    self.assertAllEqual(expected_dense, result_dense)\n\n  def testDenseSparseTensorMatMul(self):\n\n    np.random.seed(42)\n    dense_numpy_array = np.random.rand(3, 3)\n    independent_dense_tf = constant_op.constant(\n        dense_numpy_array, dtype='float32')\n\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=[4., 8.], dense_shape=[3, 3])\n    dense_of_sparse = sparse_ops.sparse_to_dense(sp.indices, sp.shape,\n                                                 sp.values)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=False)\n    expected = math_ops.matmul(independent_dense_tf, dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=True)\n    expected = math_ops.matmul(independent_dense_tf,\n                               array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=False)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf), dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=True)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf),\n        array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n  def testMapValues(self):\n    # supplying no sparse tensor should result in ValueError\n    with self.assertRaises(ValueError):\n      sparse_ops.map_values(math_ops.abs, 0.0)\n\n    sp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 1.0, 0.0]])\n\n    # helper function to check equality of sparse tensor\n    def assert_sparse_equal(expected, result):\n      self.assertAllEqual(expected.values, result.values, msg='Values differ')\n      self.assertAllEqual(\n          expected.indices, result.indices, msg='Indices differ')\n      self.assertAllEqual(\n          expected.dense_shape, result.dense_shape, msg='Shapes differ')\n\n    # check for a single sparse argument\n    expected = sparse_ops.from_dense([[0.0, 1.0, 0.0], [2.0, 1.0, 0.0]])\n    result = sparse_ops.map_values(math_ops.abs, sp)\n    assert_sparse_equal(expected, result)\n\n    # check correct passing of keyword argument, and handling of two sparse\n    # arguments at the same time\n    def mapping(arg1, arg2, kwarg):\n      self.assertEqual(kwarg, 'kwarg')\n      return arg1 + arg2\n\n    result = sparse_ops.map_values(mapping, sp, sp, kwarg='kwarg')\n    expected = sparse_ops.from_dense([[0.0, 2.0, 0.0], [-4.0, 2.0, 0.0]])\n    assert_sparse_equal(expected, result)\n\n    # check that index mismatches are correctly detected even if the `value`s\n    # have compatible shape\n    sp_incomp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 0.0, 1.0]])\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n    # check that shape mismatches are correctly detected\n    sp_incomp = sparse_tensor.SparseTensor(sp.indices, sp.values, (25, 25))\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n  def testConstantStringToSparse(self):\n    # Test case for GitHub issue 40633.\n    tensor = constant_op.constant(list('ababa'))\n    sparse = sparse_ops.from_dense(tensor)\n    result = self.evaluate(sparse)\n    self.assertAllEqual([[0], [1], [2], [3], [4]], result.indices)\n    self.assertAllEqual([b'a', b'b', b'a', b'b', b'a'], result.values)\n    self.assertAllEqual([5], result.dense_shape)\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "fixing_code": ["/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#define EIGEN_USE_THREADS\n\n#include <algorithm>\n#include <numeric>\n#include <unordered_map>\n#include <utility>\n#include <vector>\n\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_util.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/lib/gtl/inlined_vector.h\"\n#include \"tensorflow/core/util/sparse/sparse_tensor.h\"\n\nnamespace tensorflow {\n\nusing CPUDevice = Eigen::ThreadPoolDevice;\n\ntemplate <typename T>\nclass SparseFillEmptyRowsOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const int kIndicesInput = 0;\n    const int kValuesInput = 1;\n    const int kDenseShapeInput = 2;\n    const int kDefaultValueInput = 3;\n\n    const int kOutputIndicesOutput = 0;\n    const int kOutputValuesOutput = 1;\n    const int kEmptyRowIndicatorOutput = 2;\n    const int kReverseIndexMapOutput = 3;\n\n    const Tensor& indices_t = context->input(kIndicesInput);\n    const Tensor& values_t = context->input(kValuesInput);\n    const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n    const Tensor& default_value_t = context->input(kDefaultValueInput);\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n                errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                                        dense_shape_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                        indices_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(values_t.shape()),\n                errors::InvalidArgument(\"values must be a vector, saw: \",\n                                        values_t.shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n                errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                                        default_value_t.shape().DebugString()));\n    // TODO(ebrevdo): add shape checks between values, indices,\n    // dense_shape.  Also add check that dense rank > 0.\n\n    const T& default_value = default_value_t.scalar<T>()();\n    const auto indices = indices_t.matrix<int64>();\n    const auto values = values_t.vec<T>();\n    const auto dense_shape = dense_shape_t.vec<int64>();\n\n    const int64 N = indices_t.shape().dim_size(0);\n    const int64 dense_rows = dense_shape(0);\n\n    bool* empty_row_indicator = nullptr;\n    if (context->output_required(kEmptyRowIndicatorOutput)) {\n      Tensor* empty_row_indicator_t = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(kEmptyRowIndicatorOutput,\n                                              TensorShape({dense_rows}),\n                                              &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t->vec<bool>().data();\n    }\n    int64* reverse_index_map = nullptr;\n    if (context->output_required(kReverseIndexMapOutput)) {\n      Tensor* reverse_index_map_t = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(kReverseIndexMapOutput,\n                                                       TensorShape({N}),\n                                                       &reverse_index_map_t));\n      reverse_index_map = reverse_index_map_t->vec<int64>().data();\n    }\n\n    int rank = indices_t.shape().dim_size(1);\n\n    if (dense_rows == 0) {\n      OP_REQUIRES(\n          context, N == 0,\n          errors::InvalidArgument(\"Received SparseTensor with dense_shape[0] = \"\n                                  \"0 but indices.shape[0] = \",\n                                  N));\n      Tensor* output_indices_t;\n      TensorShape output_indices_shape({0, rank});\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,\n                                                       output_indices_shape,\n                                                       &output_indices_t));\n      Tensor* output_values_t;\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,\n                                                       TensorShape({0}),\n                                                       &output_values_t));\n\n      // Exit early, nothing more to do.\n      return;\n    }\n\n    bool rows_are_ordered = true;\n    int64 last_indices_row = 0;\n    std::vector<int64> csr_offset(dense_rows, 0);\n    for (int i = 0; i < N; ++i) {\n      const int64 row = indices(i, 0);\n      OP_REQUIRES(context, row >= 0 && row < dense_rows,\n                  errors::InvalidArgument(\"indices(\", i, \", 0) is invalid: \",\n                                          row, \" >= \", dense_rows));\n      ++csr_offset[row];\n      rows_are_ordered = rows_are_ordered & (row >= last_indices_row);\n      last_indices_row = row;\n    }\n    bool all_rows_full = true;\n    for (int row = 0; row < dense_rows; ++row) {\n      // csr_offset here describes the number of elements in this dense row\n      bool row_empty = (csr_offset[row] == 0);\n      if (empty_row_indicator) {\n        empty_row_indicator[row] = row_empty;\n      }\n      all_rows_full = all_rows_full & !row_empty;\n      // In filled version, each row has at least one element.\n      csr_offset[row] = std::max(csr_offset[row], int64{1});\n      // Update csr_offset to represent the number of elements up to and\n      // including dense_row + 1:\n      //  csr_offset(0) == #{elements of row 0}\n      //  csr_offset(1) == #{elements of row 1} + #{elements of row 0}\n      //  ..\n      //  csr_offset(i) == starting index for elements in row i + 1.\n      if (row > 0) {\n        csr_offset[row] += csr_offset[row - 1];\n      }\n    }\n\n    if (all_rows_full && rows_are_ordered) {\n      context->set_output(kOutputIndicesOutput, indices_t);\n      context->set_output(kOutputValuesOutput, values_t);\n      if (reverse_index_map) {\n        for (int64 i = 0; i < N; ++i) {\n          reverse_index_map[i] = i;\n        }\n      }\n    } else {\n      Tensor* output_indices_t;\n      const int64 N_full = csr_offset[dense_rows - 1];\n      TensorShape output_indices_shape({N_full, rank});\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputIndicesOutput,\n                                                       output_indices_shape,\n                                                       &output_indices_t));\n      auto output_indices = output_indices_t->matrix<int64>();\n\n      Tensor* output_values_t;\n      OP_REQUIRES_OK(context, context->allocate_output(kOutputValuesOutput,\n                                                       TensorShape({N_full}),\n                                                       &output_values_t));\n      auto output_values = output_values_t->vec<T>();\n\n      std::vector<int64> filled_count(dense_rows, 0);\n\n      // Fill in values for rows that are not missing\n      for (int64 i = 0; i < N; ++i) {\n        const int64 row = indices(i, 0);\n        int64& offset = filled_count[row];\n        const int64 output_i = ((row == 0) ? 0 : csr_offset[row - 1]) + offset;\n        offset++;  // Increment the filled count for this row.\n        std::copy_n(&indices(i, 0), rank, &output_indices(output_i, 0));\n        output_values(output_i) = values(i);\n        // We'll need this reverse index map to backprop correctly.\n        if (reverse_index_map) {\n          reverse_index_map[i] = output_i;\n        }\n      }\n\n      // Fill in values for rows that are missing\n      for (int64 row = 0; row < dense_rows; ++row) {\n        const int64 row_count = filled_count[row];\n        if (row_count == 0) {  // We haven't filled this row\n          const int64 starting_index = (row == 0) ? 0 : csr_offset[row - 1];\n          // Remaining index values were set to zero already.\n          // Just need to set the row index in the right location.\n          output_indices(starting_index, 0) = row;\n          for (int64 col = 1; col < rank; ++col) {\n            output_indices(starting_index, col) = 0;\n          }\n          output_values(starting_index) = default_value;\n        }\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNELS(type)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRows\")     \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          SparseFillEmptyRowsOp<type>)\n\nTF_CALL_ALL_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n\ntemplate <typename T>\nclass SparseFillEmptyRowsGradOp : public OpKernel {\n public:\n  explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor* reverse_index_map_t;\n    const Tensor* grad_values_t;\n    OP_REQUIRES_OK(context,\n                   context->input(\"reverse_index_map\", &reverse_index_map_t));\n    OP_REQUIRES_OK(context, context->input(\"grad_values\", &grad_values_t));\n\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()),\n        errors::InvalidArgument(\"reverse_index_map must be a vector, saw: \",\n                                reverse_index_map_t->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(grad_values_t->shape()),\n                errors::InvalidArgument(\"grad_values must be a vector, saw: \",\n                                        grad_values_t->shape().DebugString()));\n\n    const auto reverse_index_map = reverse_index_map_t->vec<int64>();\n    const auto grad_values = grad_values_t->vec<T>();\n\n    const int64 N = reverse_index_map_t->shape().dim_size(0);\n    const int64 N_full = grad_values_t->shape().dim_size(0);\n\n    Tensor* d_values_t;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"d_values\", TensorShape({N}), &d_values_t));\n    auto d_values = d_values_t->vec<T>();\n    Tensor* d_default_value_t;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\"d_default_value\", TensorShape({}),\n                                            &d_default_value_t));\n    T& d_default_value = d_default_value_t->scalar<T>()();\n    d_default_value = T();\n\n    Tensor visited_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(d) = visited.constant(false);\n\n    for (int i = 0; i < N; ++i) {\n      // Locate the index of the output of the forward prop associated\n      // with this location in the input of the forward prop.  Copy\n      // the gradient into it.  Mark it as visited.\n      int64 reverse_index = reverse_index_map(i);\n      OP_REQUIRES(\n          context, 0 <= reverse_index && reverse_index < N_full,\n          errors::InvalidArgument(\"Elements in reverse index must be in [0, \",\n                                  N_full, \") but got \", reverse_index));\n      d_values(i) = grad_values(reverse_index);\n      visited(reverse_index) = true;\n    }\n    for (int j = 0; j < N_full; ++j) {\n      // The default value gradient gets the accumulated remainder of\n      // the backprop values (since the default value was used to fill\n      // in these slots in the forward calculation).\n      if (!visited(j)) {\n        d_default_value += grad_values(j);\n      }\n    }\n  }\n};\n\n#define REGISTER_KERNELS(type)                            \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseFillEmptyRowsGrad\") \\\n                              .Device(DEVICE_CPU)         \\\n                              .TypeConstraint<type>(\"T\"), \\\n                          SparseFillEmptyRowsGradOp<type>)\n\nTF_CALL_NUMBER_TYPES(REGISTER_KERNELS);\n#undef REGISTER_KERNELS\n}  // namespace tensorflow\n", "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\n# Need array_grad to register gradient for Identity.\nfrom tensorflow.python.ops import array_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_sparse_ops\nfrom tensorflow.python.ops import gradient_checker_v2 as gradient_checker\nfrom tensorflow.python.ops import math_ops\n# Need sparse_grad to register gradient for SparseToDense.\nfrom tensorflow.python.ops import sparse_grad  # pylint: disable=unused-import\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import googletest\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass SparseOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  def testSparseEye(self):\n    def test_one(n, m, as_tensors):\n      expected = np.eye(n, m)\n      if as_tensors:\n        m = constant_op.constant(m)\n        n = constant_op.constant(n)\n      s = sparse_ops.sparse_eye(n, m)\n      d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n      self.assertAllEqual(self.evaluate(d), expected)\n\n    for n in range(2, 10, 2):\n      for m in range(2, 10, 2):\n        # Test with n and m as both constants and tensors.\n        test_one(n, m, True)\n        test_one(n, m, False)\n\n  def testDenseFromConstantToSparse(self):\n    expected_constant = np.reshape(np.arange(24, dtype=np.int64), (3, 4, 2))\n    tensor = constant_op.constant(expected_constant)\n    sparse = sparse_ops.from_dense(tensor)\n    dense = sparse_ops.sparse_to_dense(sparse.indices, sparse.dense_shape,\n                                       sparse.values)\n    constant = self.evaluate(dense)\n    self.assertAllEqual(expected_constant, constant)\n\n  def testTransposePreservesShape(self):\n    with ops.Graph().as_default():\n      t = sparse_tensor.SparseTensor(indices=[[0, 0]],\n                                     values=[0.],\n                                     dense_shape=[3, 4])\n      self.assertTrue(t.shape.is_fully_defined)\n      transposed = sparse_ops.sparse_transpose(t)\n      self.assertAllEqual(transposed.shape, [4, 3])\n\n  def testSparseExpandDims(self):\n    for rank in range(1, 4):\n      # Create a dummy input. When rank=3, shape=[2, 4, 6].\n      shape = np.arange(1, rank + 1) * 2\n      before = np.arange(np.prod(shape)).reshape(shape)\n\n      # Make entries sparse.\n      before *= np.random.binomial(1, .2, before.shape)\n      dense_shape = before.shape\n      indices = np.array(np.where(before)).T\n      values = before[before != 0]\n\n      # Try every possible valid value of axis.\n      for axis in range(-rank - 1, rank):\n        expected_after = np.expand_dims(before, axis)\n\n        for axis_as_tensor in [False, True]:\n          dense_shape_t = constant_op.constant(dense_shape, dtype=dtypes.int64)\n          indices_t = constant_op.constant(indices)\n          values_t = constant_op.constant(values)\n          before_t = sparse_tensor.SparseTensor(\n              indices=indices_t, values=values_t, dense_shape=dense_shape_t)\n\n          if axis_as_tensor:\n            axis = constant_op.constant(axis)\n\n          s = sparse_ops.sparse_expand_dims(before_t, axis)\n          d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)\n          self.assertAllEqual(self.evaluate(d), expected_after)\n\n  @parameterized.parameters([\n      (math_ops.abs, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 3.0, 4.0]),\n      (math_ops.negative, [1.0, -1.0, 3.0, -4.0], [-1.0, 1.0, -3.0, 4.0]),\n      (math_ops.sign, [3.0, -2.0, 0.0, -4.0], [1.0, -1.0, 0.0, -1.0]),\n      (math_ops.square, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 9.0, 16.0]),\n  ])\n  def testUnarySparseDispatch(self, op, values, expected):\n    st = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [0, 1], [2, 0], [2, 4]],\n        values=values,\n        dense_shape=[3, 6])\n    result = op(st)\n    result_value = self.evaluate(result)\n    self.assertAllEqual(result_value.indices, st.indices)\n    self.assertAllEqual(result_value.values, expected)\n    self.assertAllEqual(result_value.dense_shape, st.dense_shape)\n\n  def testSparseToDenseGradient(self):\n\n    def f(sparse_values, default_value):\n      st = sparse_tensor.SparseTensor(\n          indices=[[0, 3, 6], [1, 4, 7], [2, 5, 8]],\n          values=sparse_values,\n          dense_shape=[3, 6, 9])\n      return sparse_ops.sparse_tensor_to_dense(st, default_value)\n\n    grads = gradient_checker.compute_gradient(\n        f, [constant_op.constant([1.0, 2.0, 3.0]),\n            constant_op.constant(0.0)])\n    epsilon = 1e-4\n    self.assertLess(gradient_checker.max_error(*grads), epsilon)\n\n  def testSparseTensorToDenseString(self):\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=['a', 'b'], dense_shape=[2, 3])\n    dense = sparse_ops.sparse_tensor_to_dense(sp)\n    expected_dense = [[b'a', b'', b''], [b'', b'', b'b']]\n    result_dense = self.evaluate(dense)\n    self.assertAllEqual(expected_dense, result_dense)\n\n  def testDenseSparseTensorMatMul(self):\n\n    np.random.seed(42)\n    dense_numpy_array = np.random.rand(3, 3)\n    independent_dense_tf = constant_op.constant(\n        dense_numpy_array, dtype='float32')\n\n    sp = sparse_tensor.SparseTensor(\n        indices=[[0, 0], [1, 2]], values=[4., 8.], dense_shape=[3, 3])\n    dense_of_sparse = sparse_ops.sparse_to_dense(sp.indices, sp.shape,\n                                                 sp.values)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=False)\n    expected = math_ops.matmul(independent_dense_tf, dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=False, adjoint_b=True)\n    expected = math_ops.matmul(independent_dense_tf,\n                               array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=False)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf), dense_of_sparse)\n    self.assertAllEqual(expected, result)\n\n    result = sparse_ops.sparse_tensor_dense_matmul(\n        independent_dense_tf, sp, adjoint_a=True, adjoint_b=True)\n    expected = math_ops.matmul(\n        array_ops.transpose(independent_dense_tf),\n        array_ops.transpose(dense_of_sparse))\n    self.assertAllEqual(expected, result)\n\n  def testMapValues(self):\n    # supplying no sparse tensor should result in ValueError\n    with self.assertRaises(ValueError):\n      sparse_ops.map_values(math_ops.abs, 0.0)\n\n    sp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 1.0, 0.0]])\n\n    # helper function to check equality of sparse tensor\n    def assert_sparse_equal(expected, result):\n      self.assertAllEqual(expected.values, result.values, msg='Values differ')\n      self.assertAllEqual(\n          expected.indices, result.indices, msg='Indices differ')\n      self.assertAllEqual(\n          expected.dense_shape, result.dense_shape, msg='Shapes differ')\n\n    # check for a single sparse argument\n    expected = sparse_ops.from_dense([[0.0, 1.0, 0.0], [2.0, 1.0, 0.0]])\n    result = sparse_ops.map_values(math_ops.abs, sp)\n    assert_sparse_equal(expected, result)\n\n    # check correct passing of keyword argument, and handling of two sparse\n    # arguments at the same time\n    def mapping(arg1, arg2, kwarg):\n      self.assertEqual(kwarg, 'kwarg')\n      return arg1 + arg2\n\n    result = sparse_ops.map_values(mapping, sp, sp, kwarg='kwarg')\n    expected = sparse_ops.from_dense([[0.0, 2.0, 0.0], [-4.0, 2.0, 0.0]])\n    assert_sparse_equal(expected, result)\n\n    # check that index mismatches are correctly detected even if the `value`s\n    # have compatible shape\n    sp_incomp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 0.0, 1.0]])\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n    # check that shape mismatches are correctly detected\n    sp_incomp = sparse_tensor.SparseTensor(sp.indices, sp.values, (25, 25))\n    with self.assertRaises((errors.InvalidArgumentError, ValueError)):\n      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')\n      self.evaluate(result)\n\n  def testConstantStringToSparse(self):\n    # Test case for GitHub issue 40633.\n    tensor = constant_op.constant(list('ababa'))\n    sparse = sparse_ops.from_dense(tensor)\n    result = self.evaluate(sparse)\n    self.assertAllEqual([[0], [1], [2], [3], [4]], result.indices)\n    self.assertAllEqual([b'a', b'b', b'a', b'b', b'a'], result.values)\n    self.assertAllEqual([5], result.dense_shape)\n\n\n@test_util.run_all_in_graph_and_eager_modes\nclass RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):\n\n  def testSparseFillEmptyRowsGrad(self):\n    reverse_index_map = [2, 1]\n    grad_values = [0, 1, 2, 3]\n    d_values, d_default_value = self.evaluate(\n        gen_sparse_ops.SparseFillEmptyRowsGrad(\n            reverse_index_map=reverse_index_map, grad_values=grad_values))\n    self.assertAllEqual([2, 1], d_values)\n    self.assertEqual(3, d_default_value)\n\n  def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):\n    reverse_index_map = [2, -1]\n    grad_values = [0, 1, 2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        r'Elements in reverse index must be in \\[0, 4\\)'):\n      self.evaluate(\n          gen_sparse_ops.SparseFillEmptyRowsGrad(\n              reverse_index_map=reverse_index_map, grad_values=grad_values))\n\n  def testSparseFillEmptyRowsGradLargeIndexMapValue(self):\n    reverse_index_map = [2, 10]\n    grad_values = [0, 1, 2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        r'Elements in reverse index must be in \\[0, 4\\)'):\n      self.evaluate(\n          gen_sparse_ops.SparseFillEmptyRowsGrad(\n              reverse_index_map=reverse_index_map, grad_values=grad_values))\n\n  def testSparseFillEmptyRowsGradMatrix(self):\n    reverse_index_map = [0, 1]\n    grad_values = [[0, 1], [2, 3]]\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  r'grad_values must be a vector'):\n        self.evaluate(\n            gen_sparse_ops.SparseFillEmptyRowsGrad(\n                reverse_index_map=reverse_index_map, grad_values=grad_values))\n    else:\n      with self.assertRaisesRegex(ValueError,\n                                  r'Shape must be rank 1 but is rank 2'):\n        self.evaluate(\n            gen_sparse_ops.SparseFillEmptyRowsGrad(\n                reverse_index_map=reverse_index_map, grad_values=grad_values))\n\n\nif __name__ == '__main__':\n  googletest.main()\n"], "filenames": ["tensorflow/core/kernels/sparse_fill_empty_rows_op.cc", "tensorflow/python/ops/sparse_ops_test.py"], "buggy_code_start_loc": [238, 23], "buggy_code_end_loc": [269, 236], "fixing_code_start_loc": [239, 24], "fixing_code_end_loc": [277, 291], "type": "CWE-20", "message": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\"", "other": {"cve": {"id": "CVE-2020-15194", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-25T19:15:14.683", "lastModified": "2021-08-17T13:21:51.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `SparseFillEmptyRowsGrad` implementation has incomplete validation of the shapes of its arguments. Although `reverse_index_map_t` and `grad_values_t` are accessed in a similar pattern, only `reverse_index_map_t` is validated to be of proper shape. Hence, malicious users can pass a bad `grad_values_t` to trigger an assertion failure in `vec`, causing denial of service in serving installations. The issue is patched in commit 390611e0d45c5793c7066110af37c8514e6a6c54, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.\""}, {"lang": "es", "value": "En Tensorflow versiones anteriores a 1.15.4, 2.0.3, 2.1.2, 2.2.1 y 2.3.1, la implementaci\u00f3n de \"SparseFillEmptyRowsGrad\" presenta una comprobaci\u00f3n incompleta de las formas de sus argumentos.&#xa0;Aunque se accede a \"reverse_index_map_t\" y \"grad_values_t\" con un patr\u00f3n similar, solo \"reverse_index_map_t\" se comprueba que tenga la forma adecuada.&#xa0;Por lo tanto, los usuarios maliciosos pueden pasar un \"grad_values_t\" incorrecto para desencadenar un fallo de aserci\u00f3n en \"vec\", causando la denegaci\u00f3n de servicio en las instalaciones de servicio.&#xa0;El problema es parcheado en el commit 390611e0d45c5793c7066110af37c8514e6a6c54 y es publicado en TensorFlow versiones 1.15.4, 2.0.3, 2.1.2, 2.2.1 o 2.3.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-617"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionEndExcluding": "1.15.4", "matchCriteriaId": "EC688B44-17B7-462D-B6E3-BAAF99334782"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.0.3", "matchCriteriaId": "B6271763-8DFA-4A8F-9596-F1148961ECC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.2", "matchCriteriaId": "AA3FD62B-13CB-4EB5-939F-C848DE9AE071"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.1", "matchCriteriaId": "029CB8A9-ED3D-486D-967C-4CE0AF8D8FAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:-:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.1", "matchCriteriaId": "B617650A-B5A1-44BB-BB3A-2EF83648B100"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-10/msg00065.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/390611e0d45c5793c7066110af37c8514e6a6c54", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.3.1", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-9mqp-7v2h-2382", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/390611e0d45c5793c7066110af37c8514e6a6c54"}}